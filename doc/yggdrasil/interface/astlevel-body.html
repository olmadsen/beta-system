<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<TITLE>Astlevel Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/printframe.js"></SCRIPT>
<BASE TARGET="_top">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="astlevel">Astlevel Interface</A></H1>
<PRE CLASS=interface>
ORIGIN '~beta/basiclib/betaenv';
LIB_DEF 'mpsastlevel' '../lib';
INCLUDE '~beta/sysutils/pathhandler'
        '~beta/containers/hashTable'
        'property';
BODY 'private/astPrivate';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)
-- LIB: Attributes --
(* This fragment contains the tree level interface to the abstract syntax trees
 * and interface to the fragment library.
 *) (* idx: 2 *)
<B>astInterface</B><A name="astInterface.1(1)"></A>:
  (# &lt;&lt;SLOT astInterfaceLib:Attributes&gt;&gt;;
     <B>yggdrasilVersion</B><A name="astInterface.1:yggdrasilVersion.2(2)"></A><A name="yggdrasilVersion.2(2)"></A>:
       (* describes the version of THIS(astInterface) *) (#  exit 'v5.2' #);
     <B>ast</B><A name="astInterface.1:ast.2(3)"></A><A name="ast.2(3)"></A>:
       (* Basic class, which is the super-pattern of all patterns describing
        * abstract syntax trees.  Ast's are stored in a special purpose format
        * which is internally allocated in a repetition.
        *)
       (# &lt;&lt;SLOT astLib:Attributes&gt;&gt;;
          <B>frag</B><A name="astInterface.1:ast.2:frag.3(4)"></A><A name="frag.3(4)"></A>: (* where THIS(ast) belongs *)
            ^fragmentForm;
          <B>symbol</B><A name="astInterface.1:ast.2:symbol.3(5)"></A><A name="symbol.3(5)"></A>: (* the nonterminal symbol of THIS(ast) *)
            (# lab: @integer
            enter
               (# enter lab ... #)
            exit
               (# ...
               exit lab
               #)
            #);
          <B>father</B><A name="astInterface.1:ast.2:father.3(6)"></A><A name="father.3(6)"></A>:
            (* return the father of THIS(ast) or NONE, if we are in the root *)
            (#
            exit (# as: ^ast ... exit as[] #)
            #);
          <B>nextBrother</B><A name="astInterface.1:ast.2:nextBrother.3(7)"></A><A name="nextBrother.3(7)"></A>:
            (# brother: ^ast
            ...
            exit brother[]
            #);
          <B>sonNo</B><A name="astInterface.1:ast.2:sonNo.3(8)"></A><A name="sonNo.3(8)"></A>:
            (* returns the sonNo of THIS(ast) in the father node *)
            (# inx,finx,son: @integer
            ...
            exit son
            #);
          <B>kind</B><A name="astInterface.1:ast.2:kind.3(9)"></A><A name="kind.3(9)"></A>:
            (* return the subCategory of ast this node is *)
            (#
            exit (# kind: @integer ... exit kind #)
            #);
          <B>equal</B><A name="astInterface.1:ast.2:equal.3(10)"></A><A name="equal.3(10)"></A>:
            (* determines if THIS(ast) and another ast-reference points to the
             * same ast. This operations is to be used instead of testing
             * reference-equivalence directly: instead of testing
             *      a1,a2: ^ast;
             *      (if a1[]=a2[] then ... if);
             * you must test
             *      (if (a1[]-&gt;a2.equal) then ... if)
             *)
            (# comparedAst: ^ast;
            enter comparedAst[]
            exit (# eq: @boolean ... exit eq #)
            #);
          <B>nearestCommonAncestor</B><A name="astInterface.1:ast.2:nearestCommonAncestor.3(11)"></A><A name="nearestCommonAncestor.3(11)"></A>:
            (* find the nearest common ancestor of THIS(ast) and the ast
             * entered
             *)
            (# testAst,nca: ^ast; testSonNo,mySonNo: @integer
            enter testAst[]
            do ...
            exit
               (nca[],testSonNo,mySonNo)
                 (* TestSonNo is the number of the son where
                  * father-chain of the entered ast differs.  MySonNo is
                  * the number of the son where father-chain THIS(ast)
                  * differs
                  *)
            #);
          <B>lt</B><A name="astInterface.1:ast.2:lt.3(12)"></A><A name="lt.3(12)"></A>:
            (* Determine whether the ast entered or THIS(ast) will be met first
             * in a preorder traversal of the tree. Return true if the ast
             * entered comes first
             *)
            (# testAst: ^ast; testSonNo,mySonNo: @integer
            enter testAst[]
            do ...
            exit (testSonNo &lt; mySonNo)
            #);
          <B>putAttribute</B><A name="astInterface.1:ast.2:putAttribute.3(13)"></A><A name="putAttribute.3(13)"></A>:
            (* save an integer value as an attribute to THIS(ast) *)
            (# val,attributNo: @integer;
            enter (val,attributNo)
               ...
            #);
          <B>getAttribute</B><A name="astInterface.1:ast.2:getAttribute.3(14)"></A><A name="getAttribute.3(14)"></A>:
            (* get an integer-valued attribute *)
            (# attributNo,val: @integer;
            enter attributNo
               ...
            exit val
            #);
          <B>putNodeAttribute</B><A name="astInterface.1:ast.2:putNodeAttribute.3(15)"></A><A name="putNodeAttribute.3(15)"></A>:
            (* save an ast-reference as an attribute to THIS(ast) *)
            (# val: ^ast; attributNo: @integer
            enter (val[],attributno)
               ...
            #);
          <B>getNodeAttribute</B><A name="astInterface.1:ast.2:getNodeAttribute.3(16)"></A><A name="getNodeAttribute.3(16)"></A>:
            (* get an ast-reference - valued attribute *)
            (# attributNo: @integer; val: ^ast
            enter attributno
               ...
            exit val[]
            #);
          <B>putSlotAttribute</B><A name="astInterface.1:ast.2:putSlotAttribute.3(17)"></A><A name="putSlotAttribute.3(17)"></A>:
            (* save an integer value as an attribute to THIS(ast) *)
            (# val,attributNo: @integer;
            enter (val,attributNo)
               ...
            #);
          <B>getSlotAttribute</B><A name="astInterface.1:ast.2:getSlotAttribute.3(18)"></A><A name="getSlotAttribute.3(18)"></A>:
            (* get an integer-valued attribute *)
            (# attributNo,val: @integer;
            enter attributNo
               ...
            exit val
            #);
          <B>putSlotNodeAttribute</B><A name="astInterface.1:ast.2:putSlotNodeAttribute.3(19)"></A><A name="putSlotNodeAttribute.3(19)"></A>:
            (* save an ast-reference as an attribute to THIS(ast) *)
            (# val: ^ast; attributNo: @integer
            enter (val[],attributno)
               ...
            #);
          <B>getSlotNodeAttribute</B><A name="astInterface.1:ast.2:getSlotNodeAttribute.3(20)"></A><A name="getSlotNodeAttribute.3(20)"></A>: (* get an ast-reference - valued attribute *)
            (# attributNo: @integer; val: ^ast
            enter attributno
               ...
            exit val[]
            #);
          <B>addComment</B><A name="astInterface.1:ast.2:addComment.3(21)"></A><A name="addComment.3(21)"></A>:
            (* add a commment to THIS(ast). Overwrites existing comments *)
            (# l: ^lexemText;
            enter l[]
               ...
            #);
          <B>getComment</B><A name="astInterface.1:ast.2:getComment.3(22)"></A><A name="getComment.3(22)"></A>:
            (* return the comment associated with THIS(ast) *)
            (#
            exit (# as: ^ast ... exit as[] #)
            #);
          <B>getNextComment</B><A name="astInterface.1:ast.2:getNextComment.3(23)"></A><A name="getNextComment.3(23)"></A>:
            (* This is a special operation that only should be used by the
             * prettyprinter. A comment c for at subAST is organized as
             * follows:
             * c = c1 c2 ... cn, where the positions of the ci's are:
             * c1 son1 c2 son2 c3 .... cn sonn cn+1
             * each ci can be further divided into a subsequence of comments
             * that must be prettyprinted separately.
             * NextComment scans all subcomments one of the time.
             * A call of nextComment returns the next subcomment in the
             * sequence of comments belonging to THIS(ast).
             *
             * if n is -2 the whole comment is empty and subcomment is none
             * if n is -1 the subcomment is empty and 'subcomment' is none
             * if n is 0 there is only one comment between the two sons or
             *           it is the last subcomment
             * if n is 1 there are more than one subcomment and 'subcomment'
             *           contains the current one
             * if n is 2 the whole comment has been scanned, 'subcomment'
             *           contains the last one
             *
             * The representation of the comment looks like this:
             * ' xxx 21 yyy 2 zzz 21 aaa 2'
             *
             * where 1 (ascii 1) is the separator between the subcomments and
             * 2 (ascii 2) is the subsequence separator
             *
             * and it should be prettyprinted like this:
             * [* xxx *] son1 [* yyy *] [* zzz *] son2 [* aaa *]
             *)
            (# subcomment: ^text; n: @integer;
            do (if getNextCommentComponent[]=NONE then
                   &amp;|getNextCommentOp[]-&gt;getNextCommentComponent[]
               if);
               getNextCommentComponent-&gt;(subcomment[],n);
            exit (subcomment[],n)
            #);
          <B>getNextCommentComponent</B><A name="astInterface.1:ast.2:getNextCommentComponent.3(24)"></A><A name="getNextCommentComponent.3(24)"></A>: (*private*)^|getNextCommentOp;
          <B>getNextCommentOp</B><A name="astInterface.1:ast.2:getNextCommentOp.3(25)"></A><A name="getNextCommentOp.3(25)"></A>: (*private*)
            (# subcomment: ^text; n: @integer
            do ...
            exit (subcomment[],n)
            #);
          <B>insertSubcomments</B><A name="astInterface.1:ast.2:insertSubcomments.3(26)"></A><A name="insertSubcomments.3(26)"></A>:
            (* This is a special operation that only should be used by the
             * editor Inserts the subcomments with index inx (1..n)
             * Subcomments must include subsequence separators.  THIS(ast)
             * must already have a comment.  An empty comment with separators
             * can be created using the prettyprinter.
             *)
            (# subcomments: ^text; inx: @integer
            enter (subcomments[],inx)
            do ...
            #);
          <B>setSubcomments</B><A name="astInterface.1:ast.2:setSubcomments.3(27)"></A><A name="setSubcomments.3(27)"></A>:
            (* This is a special operation that only should be used by the
             * editor. Sets the subcomments corresponding to index inx (1..n)
             * Subcomments must include subsequence separators.  If
             * subcomments is empty, the existing subcomments at index inx
             * are deleted.  THIS(ast) must already have a comment.  An empty
             * comment with separators can be created using the
             * prettyprinter.
             *)
            (# subcomments: ^text; inx: @integer
            enter (subcomments[],inx)
            do ...
            #);
          <B>getSubcomments</B><A name="astInterface.1:ast.2:getSubcomments.3(28)"></A><A name="getSubcomments.3(28)"></A>:
            (* This is a special operation that only should be used by the
             * editor. Returns subcomments with index inx (1..n), including
             * subsequence separators.  If the node has no comment or the
             * subcomments are empty the empty string is returned.
             *)
            (# subcomments: ^text; inx: @integer
            enter (inx)
            do ...
            exit subcomments[]
            #);
          <B>scanComments</B><A name="astInterface.1:ast.2:scanComments.3(29)"></A><A name="scanComments.3(29)"></A>:
            (*
             * A comment c for at subAST is organized as follows:
             * c = c1 c2 ... cn, where the positions of the ci's are:
             * c1 son1 c2 son2 c3 .... cn sonn cn+1
             * Each ci can be further divided into comments that must be
             * prettyprinted separately.
             * ScanComment scans all subcomments one of the time
             * calling INNER for each subcomment.
             * 'current' contains the current subcomment with indexes
             * inx (1..n, the ci number) and subinx (1..n, the number in
             * the subsequence)
             *)
            (# current: ^text; inx,subinx: @integer
            do ...
            #);
          <B>insertSubcomment</B><A name="astInterface.1:ast.2:insertSubcomment.3(30)"></A><A name="insertSubcomment.3(30)"></A>:
            (* Inserts subcomment with indexes inx and subinx
             * THIS(ast) must already have a comment.
             * An empty comment with separators
             * can be created using the prettyprinter.
             *)
            (# subcomment: ^text; inx,subinx: @integer
            enter (subcomment[],inx,subinx)
            do ...
            #);
          <B>setSubcomment</B><A name="astInterface.1:ast.2:setSubcomment.3(31)"></A><A name="setSubcomment.3(31)"></A>:
            (* Sets subcomment with indexes inx and subinx,
             * If subcomment is empty, the existing subcomment is deleted.
             * THIS(ast) must already have a comment.
             * An empty comment with separators
             * can be created using the prettyprinter.
             *)
            (# subcomment: ^text; inx,subinx: @integer
            enter (subcomment[],inx,subinx)
            do ...
            #);
          <B>getSubcomment</B><A name="astInterface.1:ast.2:getSubcomment.3(32)"></A><A name="getSubcomment.3(32)"></A>:
            (* Returns subcomment with indexes inx and subinx,
             * if the node has no comment or the subcomment is empty
             * the empty string is returned
             *)
            (# subcomment: ^text; inx,subinx: @integer
            enter (inx,subinx)
            do ...
            exit subcomment[]
            #);
          <B>hasComment</B><A name="astInterface.1:ast.2:hasComment.3(33)"></A><A name="hasComment.3(33)"></A>:
            (* tells if there is a comment associated with THIS(ast) *)
            (# has: @boolean ... exit has #);
          <B>hasCommentProp</B><A name="astInterface.1:ast.2:hasCommentProp.3(34)"></A><A name="hasCommentProp.3(34)"></A>:
            (#
            exit (typeOfComment = 17)
            #);
          <B>getCommentProp</B><A name="astInterface.1:ast.2:getCommentProp.3(35)"></A><A name="getCommentProp.3(35)"></A>:
            (# prop: ^propertyList;
            do ...
            exit prop[]
            #);
          <B>setCommentProp</B><A name="astInterface.1:ast.2:setCommentProp.3(36)"></A><A name="setCommentProp.3(36)"></A>:
            (# prop: ^propertyList;
            enter (prop[])
            do ...
            #);
          <B>typeOfComment</B><A name="astInterface.1:ast.2:typeOfComment.3(37)"></A><A name="typeOfComment.3(37)"></A>:
            (* sets or returns the type of THIS(comment) *)
            (# type: @integer
            enter
               (#  enter type ... #)
            exit
               (# ...
               exit type
               #)
            #);
          <B>dump</B><A name="astInterface.1:ast.2:dump.3(38)"></A><A name="dump.3(38)"></A>:&lt; (* do a nearly human readable dump of THIS(ast) to a stream *)
            (# level: @integer; dmp: ^stream;
            enter (level,dmp[])
               ...
            #);
          <B>copy</B><A name="astInterface.1:ast.2:copy.3(39)"></A><A name="copy.3(39)"></A>: protect
            (* make a copy of THIS(ast) with all sons. The enter-parameter
             * tells which fragmentForm the copy shall belong to
             *)
            (# copyFrag: ^fragmentForm
            enter copyFrag[]
            exit
               (# as: ^ast
               ...
               exit as[]
               #)
            #);
          <B>match</B><A name="astInterface.1:ast.2:match.3(40)"></A><A name="match.3(40)"></A>:&lt;
            (* pattern-matching. Returns true if the entered ast match
             * THIS(ast)
             *)
            (# doesMatch: @boolean; treeToMatch: ^ast
            enter treeTomatch[]
               ...
            exit doesMatch
            #);
          <B>hasSemanticError</B><A name="astInterface.1:ast.2:hasSemanticError.3(41)"></A><A name="hasSemanticError.3(41)"></A>:
            (* returns true if THIS(ast) has semantic errors *)
            (#
            enter
               (# b: @boolean
               enter b
               do (b,1,1)-&gt;frag.a[index].%PutBits
               #)
            exit (1,1)-&gt;frag.a[index].%GetBits
            #);
          <B>semanticError</B><A name="astInterface.1:ast.2:semanticError.3(42)"></A><A name="semanticError.3(42)"></A>: (* if hasSemanticError, this is the errorNumber *)
            (#
            enter
               (# errorNumber: @integer
               enter errorNumber
               ...
               #)
            exit
               (# errorNumber: @integer;
               ...
               exit errorNumber
               #)
            #);
          <B>stopYggdrasil</B><A name="astInterface.1:ast.2:stopYggdrasil.3(43)"></A><A name="stopYggdrasil.3(43)"></A>:&lt; astException;
          <B>astException</B><A name="astInterface.1:ast.2:astException.3(44)"></A><A name="astException.3(44)"></A>: astInterfaceException
            (#
            do INNER astException;
               msg.newLine;
               ' index = '-&gt;msg.puttext;
               (index)-&gt;msg.putInt;
               ' symbol = '-&gt;msg.puttext;
               (symbol)-&gt;msg.putInt;
            #);
          &lt;&lt;SLOT astPrivateLib:Attributes&gt;&gt;;
          <B>index</B><A name="astInterface.1:ast.2:index.3(45)"></A><A name="index.3(45)"></A>:
            (* Private: architecture of an ast:
             *
             *           |      ....    |
             *           -----------------
             * index -&gt;  |    prodno     |
             *           -----------------
             *           |  next brother | (if negative: -index to father)
             *           -----------------
             *           |   first son   | (for lexems: pointer to text)
             *           -----------------
             *           |first attribute|
             *           -----------------
             *           |     ....     |
             *
             *) @integer;
          <B>copyPrivate</B><A name="astInterface.1:ast.2:copyPrivate.3(46)"></A><A name="copyPrivate.3(46)"></A>:&lt; (* Private *)
            (# theCopy: ^ast; theCopyInx: @integer; copyFrag: ^fragmentForm;
            enter copyFrag[]
               ...
            exit theCopyInx
            #);
       do INNER
       #);
     <B>expanded</B><A name="astInterface.1:expanded.2(47)"></A><A name="expanded.2(47)"></A>: ast
       (* this pattern describes all expanded ast *)
       (# &lt;&lt;SLOT expandedLib:Attributes&gt;&gt;;
          <B>noOfsons</B><A name="astInterface.1:expanded.2:noOfsons.3(48)"></A><A name="noOfsons.3(48)"></A>:
            (* return the number of sons of THIS(expanded) *)
            (# sons: @integer;
            do ...
            exit sons
            #);
          <B>get</B><A name="astInterface.1:expanded.2:get.3(49)"></A><A name="get.3(49)"></A>:
            (* get a son with a given son-number *)
            (# i: @integer;
            enter i
            exit (# as: ^ast ... exit as[] #)
            #);
          <B>put</B><A name="astInterface.1:expanded.2:put.3(50)"></A><A name="put.3(50)"></A>:
            (* sets the entered ast to be a son of this son with a given
             * son-number
             *)
            (# i: @integer;
               s: ^ast;
               notSameFragment:&lt; astException
                 (* exception called if the entered ast is not in same fragment
                  * as THIS(expanded)
                  *)
                 (#
                 do INNER notSameFragment;
                    'Error in put. Inserted ast is not from same fragmentForm '
                      -&gt;msg.putline;
                 #);
            enter (i,s[])
            do ...
            #);
          <B>scan</B><A name="astInterface.1:expanded.2:scan.3(51)"></A><A name="scan.3(51)"></A>:
            (* iterates over all sons *)
            (# current: ^ast; currentSonNo: @integer;
            do ...
            #);
          <B>suffixWalk</B><A name="astInterface.1:expanded.2:suffixWalk.3(52)"></A><A name="suffixWalk.3(52)"></A>:
            (* make a preorder traversal of the tree with THIS(expanded) as
             * root. cutIf can be used to cut the traversal of some sub-ast's
             *)
            (# cutIf:&lt;
                 (# prod: @integer; toCut: @boolean
                 enter prod
                 do false-&gt;toCut; INNER
                 exit toCut
                 #);
               current: (* the ast-iterator *) ^ast;
            do ...
            #);
          <B>suffixWalkforProd</B><A name="astInterface.1:expanded.2:suffixWalkforProd.3(53)"></A><A name="suffixWalkforProd.3(53)"></A>:
            (* make a preorder traversal of the tree with THIS(expanded) as
             * root.  Will only call INNER for ast's which have the symbol
             * 'prod'. cutIf can be used to cut the traversal of some sub-ast's
             *)
            (# scanCat:&lt; ast;
               cutIf:&lt;
                 (# prod: @integer; toCut: @boolean
                 enter prod
                 do false-&gt;toCut; INNER
                 exit toCut
                 #);
               current: (* the ast-iterator *) ^scanCat;
               prod: @integer;
            enter prod
            do ...
            #);
          <B>insert</B><A name="astInterface.1:expanded.2:insert.3(54)"></A><A name="insert.3(54)"></A>:
            (* insert an ast before a son with the given son-number. Must
             * externally only be called for lists
             *)
            (# i: @integer;
               s: ^ast;
               notSameFragment:&lt; astException
                 (* exception called if the entered ast is not in same fragment
                  * as THIS(expanded)
                  *)
                 (#
                 do INNER notSameFragment;
                    'Error in put. inserted ast is not from same fragmentForm '
                      -&gt;msg.putline;
                 #);
            enter (i,s[])
            do ...
            #);
          <B>getson1</B><A name="astInterface.1:expanded.2:getson1.3(55)"></A><A name="getson1.3(55)"></A>:
            (* optimized version of getson1: (# exit 1 -&gt; get #) *)
            (#
            exit (1-&gt;frag.a[index+1].%getShort)*2
                   -&gt;frag.indexToNode
            #);
          <B>getson2</B><A name="astInterface.1:expanded.2:getson2.3(56)"></A><A name="getson2.3(56)"></A>: (#  exit 2-&gt;get #);
          <B>getson3</B><A name="astInterface.1:expanded.2:getson3.3(57)"></A><A name="getson3.3(57)"></A>: (#  exit 3-&gt;get #);
          <B>getson4</B><A name="astInterface.1:expanded.2:getson4.3(58)"></A><A name="getson4.3(58)"></A>: (#  exit 4-&gt;get #);
          <B>getson5</B><A name="astInterface.1:expanded.2:getson5.3(59)"></A><A name="getson5.3(59)"></A>: (#  exit 5-&gt;get #);
          <B>getson6</B><A name="astInterface.1:expanded.2:getson6.3(60)"></A><A name="getson6.3(60)"></A>: (#  exit 6-&gt;get #);
          <B>getson7</B><A name="astInterface.1:expanded.2:getson7.3(61)"></A><A name="getson7.3(61)"></A>: (#  exit 7-&gt;get #);
          <B>getson8</B><A name="astInterface.1:expanded.2:getson8.3(62)"></A><A name="getson8.3(62)"></A>: (#  exit 8-&gt;get #);
          <B>getson9</B><A name="astInterface.1:expanded.2:getson9.3(63)"></A><A name="getson9.3(63)"></A>: (#  exit 9-&gt;get #);
          <B>putson1</B><A name="astInterface.1:expanded.2:putson1.3(64)"></A><A name="putson1.3(64)"></A>: (# a: ^ast enter a[] do (1,a[])-&gt;put #);
          <B>putson2</B><A name="astInterface.1:expanded.2:putson2.3(65)"></A><A name="putson2.3(65)"></A>: (# a: ^ast enter a[] do (2,a[])-&gt;put #);
          <B>putson3</B><A name="astInterface.1:expanded.2:putson3.3(66)"></A><A name="putson3.3(66)"></A>: (# a: ^ast enter a[] do (3,a[])-&gt;put #);
          <B>putson4</B><A name="astInterface.1:expanded.2:putson4.3(67)"></A><A name="putson4.3(67)"></A>: (# a: ^ast enter a[] do (4,a[])-&gt;put #);
          <B>putson5</B><A name="astInterface.1:expanded.2:putson5.3(68)"></A><A name="putson5.3(68)"></A>: (# a: ^ast enter a[] do (5,a[])-&gt;put #);
          <B>putson6</B><A name="astInterface.1:expanded.2:putson6.3(69)"></A><A name="putson6.3(69)"></A>: (# a: ^ast enter a[] do (6,a[])-&gt;put #);
          <B>putson7</B><A name="astInterface.1:expanded.2:putson7.3(70)"></A><A name="putson7.3(70)"></A>: (# a: ^ast enter a[] do (7,a[])-&gt;put #);
          <B>putson8</B><A name="astInterface.1:expanded.2:putson8.3(71)"></A><A name="putson8.3(71)"></A>: (# a: ^ast enter a[] do (8,a[])-&gt;put #);
          <B>putson9</B><A name="astInterface.1:expanded.2:putson9.3(72)"></A><A name="putson9.3(72)"></A>: (# a: ^ast enter a[] do (9,a[])-&gt;put #);
          &lt;&lt;SLOT expandedPrivate:Attributes&gt;&gt;;
          <B>dump</B><A name="astInterface.1:expanded.2:dump.3(73)"></A><A name="dump.3(73)"></A>::&lt; (* Private *)
            (# do ... #);
          <B>match</B><A name="astInterface.1:expanded.2:match.3(74)"></A><A name="match.3(74)"></A>::&lt; (* Private *)
            (# do ... #);
          <B>copyPrivate</B><A name="astInterface.1:expanded.2:copyPrivate.3(75)"></A><A name="copyPrivate.3(75)"></A>::&lt; (* Private *)
            (#  do ... #);
       do INNER ;
       #);
     <B>cons</B><A name="astInterface.1:cons.2(76)"></A><A name="cons.2(76)"></A>: expanded
       (* describes ast's derived from a constructor-production *)
       (# &lt;&lt;SLOT consLib:Attributes&gt;&gt;;
          <B>delete</B><A name="astInterface.1:cons.2:delete.3(77)"></A><A name="delete.3(77)"></A>:
            (* delete a son with the given son-number. Inserts an unExpanded
             * instead
             *)
            (# sonnr: @integer;
            enter sonnr
            do ...
            #);
          <B>dump</B><A name="astInterface.1:cons.2:dump.3(78)"></A><A name="dump.3(78)"></A>::&lt; (* Private *)
            (#
            do 'CONS'-&gt;dmp.puttext; INNER
            #)
       #);
     <B>list</B><A name="astInterface.1:list.2(79)"></A><A name="list.2(79)"></A>: expanded
       (* describes ast's derived from a list-production *)
       (# &lt;&lt;SLOT listLib:Attributes&gt;&gt;;
          <B>sonCat</B><A name="astInterface.1:list.2:sonCat.3(80)"></A><A name="sonCat.3(80)"></A>:&lt; ast;
          <B>newScan</B><A name="astInterface.1:list.2:newScan.3(81)"></A><A name="newScan.3(81)"></A>: (* iterates over all sons *)
            (# predefined:&lt; (# current: ^Ast enter current[] do INNER #);
               a: ^ast;
               current: ^sonCat;
               currentSonNo: @integer;
            do ...
            #);
          <B>append</B><A name="astInterface.1:list.2:append.3(82)"></A><A name="append.3(82)"></A>:
            (* append a son to the list *)
            (# a: ^ast;  enter a[] do (noOfSons+1,a[])-&gt;insert;  #);
          <B>delete</B><A name="astInterface.1:list.2:delete.3(83)"></A><A name="delete.3(83)"></A>: (* delete the son with the given son-number from the list *)
            (# sonnr: @integer;
            enter sonnr
            do ...
            #);
          <B>dump</B><A name="astInterface.1:list.2:dump.3(84)"></A><A name="dump.3(84)"></A>::&lt; (* Private *)
            (#
            do 'LIST'-&gt;dmp.puttext;
               INNER
            #);
       #);
     <B>lexem</B><A name="astInterface.1:lexem.2(85)"></A><A name="lexem.2(85)"></A>: ast
       (* describes all ast's derived from one of the predefined
        * nonterminals
        *)
       (# &lt;&lt;SLOT lexemLib:Attributes&gt;&gt; #);
     <B>lexemText</B><A name="astInterface.1:lexemText.2(86)"></A><A name="lexemText.2(86)"></A>: lexem
       (* describes all ast's having textual contents *)
       (# &lt;&lt;SLOT lexemTextLib:Attributes&gt;&gt;;
          <B>getText</B><A name="astInterface.1:lexemText.2:getText.3(87)"></A><A name="getText.3(87)"></A>: (* get the textual content *)
            (# t: ^text;
            do &amp;text[]-&gt;t[]; ...
            exit t[]
            #);
          <B>putText</B><A name="astInterface.1:lexemText.2:putText.3(88)"></A><A name="putText.3(88)"></A>: (* set the textual content *)
            (# t: ^text;
            enter t[]
            do ...
            #);
          <B>clear</B><A name="astInterface.1:lexemText.2:clear.3(89)"></A><A name="clear.3(89)"></A>: (* clear the textual content *)
          ...;
          <B>getChar</B><A name="astInterface.1:lexemText.2:getChar.3(90)"></A><A name="getChar.3(90)"></A>: (* get a char *)
            (# index: @integer; ch: @char
            enter index
            do ...
            exit ch
            #);
          <B>putChar</B><A name="astInterface.1:lexemText.2:putChar.3(91)"></A><A name="putChar.3(91)"></A>: (* append a char to the textual content *)
            (# c: @char;
            enter c
            do ...
            #);
          <B>curLength</B><A name="astInterface.1:lexemText.2:curLength.3(92)"></A><A name="curLength.3(92)"></A>: (* sets or returns the length of the textual contents *)
            (# l: @integer
            enter
               (#
               enter l
               do ...
               #)
            exit
               (# ...
               exit l
               #)
            #);
          &lt;&lt;SLOT lexemTextPrivate:Attributes&gt;&gt;;
          <B>dump</B><A name="astInterface.1:lexemText.2:dump.3(93)"></A><A name="dump.3(93)"></A>::&lt; (* Private *)
            (#
            do INNER ;
               '^'-&gt;dmp.put;
               getText-&gt;dmp.puttext
            #);
          <B>copyPrivate</B><A name="astInterface.1:lexemText.2:copyPrivate.3(94)"></A><A name="copyPrivate.3(94)"></A>::&lt; (* Private *)
            (# theLexCopy: ^lexemText
            do theCopy[]-&gt;theLexCopy[];
               getText-&gt;theLexCopy.puttext;
               INNER
            #);
          <B>match</B><A name="astInterface.1:lexemText.2:match.3(95)"></A><A name="match.3(95)"></A>::&lt; (* Private *)
            (# theMatchLexem: ^lexemText;
               theT,theMatchText: ^text;
            ...
            #)
       #);
     <B>nameDecl</B><A name="astInterface.1:nameDecl.2(96)"></A><A name="nameDecl.2(96)"></A>: lexemText
       (* describes ast's derived from the predefined nonterminal &lt;nameDecl&gt; *)
       (# &lt;&lt;SLOT nameDeclLib:Attributes&gt;&gt;;
       exit prodNo.nameDecl
       #);
     <B>nameAppl</B><A name="astInterface.1:nameAppl.2(97)"></A><A name="nameAppl.2(97)"></A>: lexemText
       (* describes ast derived from the predefined nonterminal &lt;nameAppl&gt; *)
       (# &lt;&lt;SLOT nameApplLib:Attributes&gt;&gt;;
       exit prodNo.nameAppl
       #);
     <B>string</B><A name="astInterface.1:string.2(98)"></A><A name="string.2(98)"></A>: lexemText
       (* describes ast derived from the predefined nonterminal &lt;string&gt; *)
       (# &lt;&lt;SLOT stringLib:Attributes&gt;&gt; exit prodNo.string #);
     <B>comment</B><A name="astInterface.1:comment.2(99)"></A><A name="comment.2(99)"></A>: lexemText
       (# &lt;&lt;SLOT commentLib:Attributes&gt;&gt;;
          <B>commentType</B><A name="astInterface.1:comment.2:commentType.3(100)"></A><A name="commentType.3(100)"></A>:
            (# type: @integer
            enter
               (#  enter type ... #)
            exit
               (# ...
               exit type
               #)
            #);
          <B>copyPrivate</B><A name="astInterface.1:comment.2:copyPrivate.3(101)"></A><A name="copyPrivate.3(101)"></A>::&lt; (* Private *)
            (#  ... #);
       exit prodNo.comment
       #);
     <B>const</B><A name="astInterface.1:const.2(102)"></A><A name="const.2(102)"></A>: lexemText
       (* describes ast derived from the predefined nonterminal &lt;const&gt; *)
       (# &lt;&lt;SLOT constLib:Attributes&gt;&gt;;
          <B>putValue</B><A name="astInterface.1:const.2:putValue.3(103)"></A><A name="putValue.3(103)"></A>:
            (# val: @integer;
            enter val
            do ...
            #);
          <B>getValue</B><A name="astInterface.1:const.2:getValue.3(104)"></A><A name="getValue.3(104)"></A>:
            (# val: @integer;
            do ...
            exit val
            #);
          <B>dump</B><A name="astInterface.1:const.2:dump.3(105)"></A><A name="dump.3(105)"></A>::&lt; (* Private *)
            (# do INNER ; '&amp;'-&gt;dmp.put; getText-&gt;dmp.putText #);
          <B>copyPrivate</B><A name="astInterface.1:const.2:copyPrivate.3(106)"></A><A name="copyPrivate.3(106)"></A>::&lt; (* Private *)
            (# theCnCopy: ^const;
            do theCopy[]-&gt;theCnCopy[]; getText-&gt;theCnCopy.putText;
            #);
       exit prodNo.const
       #);
     <B>unExpanded</B><A name="astInterface.1:unExpanded.2(107)"></A><A name="unExpanded.2(107)"></A>: ast (* describes ast's which have not been derived yet *)
       (# &lt;&lt;SLOT unExpandedLib:Attributes&gt;&gt;;
          <B>nonterminalSymbol</B><A name="astInterface.1:unExpanded.2:nonterminalSymbol.3(108)"></A><A name="nonterminalSymbol.3(108)"></A>:
            (* describes which symbol, THIS(unExpanded) may derive.
             * THIS(unexpanded).symbol returns prodNo.unExpanded
             *)
            (#
            enter
               (# val: @integer
               enter val
               do (val,1)-&gt;frag.a[index+1].%putShort
               #)
            exit 1-&gt;frag.a[index+1].%GetSignedShort
            #);
          <B>isSlot</B><A name="astInterface.1:unExpanded.2:isSlot.3(109)"></A><A name="isSlot.3(109)"></A>:
            (# b: @boolean
            enter (#  enter b do (b,0,1)-&gt;frag.a[index].%PutBits #)
            exit (0,1)-&gt;frag.a[index].%GetBits-&gt;b
            #);
          <B>theSlot</B><A name="astInterface.1:unExpanded.2:theSlot.3(110)"></A><A name="theSlot.3(110)"></A>:
            (#
            enter
               (# o: ^slotDesc
               enter o[]
               ...
               #)
            exit
               (# sd: ^slotDesc
               ...
               exit sd[]
               #)
            #);
          <B>sy</B><A name="astInterface.1:unExpanded.2:sy.3(111)"></A><A name="sy.3(111)"></A>: (* Private *) @integer;
          <B>dump</B><A name="astInterface.1:unExpanded.2:dump.3(112)"></A><A name="dump.3(112)"></A>::&lt; (* Private *)  (#  ... #);
          <B>copyPrivate</B><A name="astInterface.1:unExpanded.2:copyPrivate.3(113)"></A><A name="copyPrivate.3(113)"></A>::&lt; (* Private *)
            (#  do ... #);
       do prodNo.unExpanded-&gt;sy;
          INNER
       exit sy
       #);
     <B>optional</B><A name="astInterface.1:optional.2(114)"></A><A name="optional.2(114)"></A>: unExpanded
       (* nodes in the tree which are empty (for optionals) are generated as
        * instances of 'optional'
        *)
       (# &lt;&lt;SLOT optionalLib:Attributes&gt;&gt;;
          <B>dump</B><A name="astInterface.1:optional.2:dump.3(115)"></A><A name="dump.3(115)"></A>::&lt; (* Private *)
            (#  do '#'-&gt;dmp.put; INNER #);
       do prodNo.optional-&gt;sy
       #);
     <B>slotDesc</B><A name="astInterface.1:slotDesc.2(116)"></A><A name="slotDesc.2(116)"></A>: ast
       (# &lt;&lt;SLOT slotDescLib:Attributes&gt;&gt;;
          <B>name</B><A name="astInterface.1:slotDesc.2:name.3(117)"></A><A name="name.3(117)"></A>:
            (#
            enter
                  (# t: ^text;
                  enter t[]
                  do ...
                  #)
            exit
                 (# c: ^comment
                   ...
                 exit c.getText
                 #)
            #);
          <B>category</B><A name="astInterface.1:slotDesc.2:category.3(118)"></A><A name="category.3(118)"></A>:
            (# f: ^unExpanded do father-&gt;f[];  exit f.nonterminalSymbol #);
          <B>isBound</B><A name="astInterface.1:slotDesc.2:isBound.3(119)"></A><A name="isBound.3(119)"></A>: (* Private *) @boolean;
          <B>node</B><A name="astInterface.1:slotDesc.2:node.3(120)"></A><A name="node.3(120)"></A>: (* Private *)
            (# father: @integer; ff: ^fragmentForm
            ...
            exit (father,ff[])
            #);
          <B>copyPrivate</B><A name="astInterface.1:slotDesc.2:copyPrivate.3(121)"></A><A name="copyPrivate.3(121)"></A>::&lt; (* Private *)
            (#
            do ...
            #);
          <B>dump</B><A name="astInterface.1:slotDesc.2:dump.3(122)"></A><A name="dump.3(122)"></A>::&lt; (* Private *)  (#  ... #);
       exit prodNo.slotDesc
       #);
     <B>nonterminalSymbol</B><A name="astInterface.1:nonterminalSymbol.2(123)"></A><A name="nonterminalSymbol.2(123)"></A>:
       (* may be used to describe symbol numbers *)
       (# &lt;&lt;SLOT nonterminalSymbolLib:Attributes&gt;&gt;;
          symbol: @integer;
          predefined:
            (#
            exit (symbol &lt;= 0)
            #);
          isLexem:
            (#
            exit ((symbol &lt; - 2) and (symbol &gt; - 7))
            #)
       enter symbol
       exit symbol
       #);
     (*--------------------- Fragment patterns ------------------------------*)
     <B>formType</B><A name="astInterface.1:formType.2(124)"></A><A name="formType.2(124)"></A>: (#  exit 0 #);
     <B>groupType</B><A name="astInterface.1:groupType.2(125)"></A><A name="groupType.2(125)"></A>: (#  exit 1 #);
     <B>fragment</B><A name="astInterface.1:fragment.2(126)"></A><A name="fragment.2(126)"></A>:
       (* Abstract super-pattern for fragments.  A fragment has a unique
        * identification in form of a hierarchical name: '/foo1/foo2/.../foon';
        * '/foo1/foo2/...' is called the path of the fragment; 'foo' is called
        * the (local) name.  Only name needs to be stored since the path can be
        * fetched recursively from the father.
        *)
       (# &lt;&lt;SLOT fragmentLib:Attributes&gt;&gt;;
          <B>name</B><A name="astInterface.1:fragment.2:name.3(127)"></A><A name="name.3(127)"></A>:
            (* exit the local name of THIS(fragment) *)
            (#  enter nameT[] exit nameT[] #);
          <B>fullName</B><A name="astInterface.1:fragment.2:fullName.3(128)"></A><A name="fullName.3(128)"></A>: (* exit the full name (path/name) of THIS(fragment) *)
            (# n: ^Text ... exit n[] #);
          <B>father</B><A name="astInterface.1:fragment.2:father.3(129)"></A><A name="father.3(129)"></A>:
            (#
            enter fatherR[]
            exit fatherR[]
            #);
          <B>isOpen</B><A name="astInterface.1:fragment.2:isOpen.3(130)"></A><A name="isOpen.3(130)"></A>:
            (* returns true if THIS(fragment) has been opened *) @boolean;
          <B>close</B><A name="astInterface.1:fragment.2:close.3(131)"></A><A name="close.3(131)"></A>:&lt; (* Close THIS(fragment) *)
            (#
            do (if changed then markAsChanged if);
               INNER ;
               false-&gt;isOpen
            #);
          <B>type</B><A name="astInterface.1:fragment.2:type.3(132)"></A><A name="type.3(132)"></A>: (* returns one of formType or groupType *)
            (#  exit fragType #);
          <B>init</B><A name="astInterface.1:fragment.2:init.3(133)"></A><A name="init.3(133)"></A>:&lt;
            (#
            do &amp;propertyList[]-&gt;prop[]; prop.init; false-&gt;changed; INNER
            #);
          <B>reset</B><A name="astInterface.1:fragment.2:reset.3(134)"></A><A name="reset.3(134)"></A>:&lt;
            (* reset fragmentForm to be as if it has just been parsed up *)
            (# do INNER #);
          <B>modtime</B><A name="astInterface.1:fragment.2:modtime.3(135)"></A><A name="modtime.3(135)"></A>: (* time of last visit of file-representation *) @integer;
          <B>markAsChanged</B><A name="astInterface.1:fragment.2:markAsChanged.3(136)"></A><A name="markAsChanged.3(136)"></A>: protect
            (* call this when you want to save some changes *)
            (# ... #);
          <B>changed</B><A name="astInterface.1:fragment.2:changed.3(137)"></A><A name="changed.3(137)"></A>: @boolean;
          <B>checkDiskRepresentation</B><A name="astInterface.1:fragment.2:checkDiskRepresentation.3(138)"></A><A name="checkDiskRepresentation.3(138)"></A>:&lt;
            (* called when it should be checked, if the disk-representation
             * of the fragment have been changed by another fragment.  If it
             * have, the internal state of the fragment is updated according to
             * the disk-representation
             *)
            (# haveBeenChanged: @boolean; error: ^stream
            enter error[]
            do ...
            exit haveBeenChanged
            #);
          <B>diskFileName</B><A name="astInterface.1:fragment.2:diskFileName.3(139)"></A><A name="diskFileName.3(139)"></A>:&lt; (* returns the filename of the disk-representation *)
            (# t: ^text do &amp;text[]-&gt;t[]; INNER exit t[] #);
          <B>textFileName</B><A name="astInterface.1:fragment.2:textFileName.3(140)"></A><A name="textFileName.3(140)"></A>:&lt;
            (* returns the file-name of the text-representation of
             * THIS(fragment)
             *)
            (# t: ^text do &amp;text[]-&gt;t[]; INNER exit t[] #);
          <B>origin</B><A name="astInterface.1:fragment.2:origin.3(141)"></A><A name="origin.3(141)"></A>: (#  enter originR[] exit originR[] #);
          <B>bind</B><A name="astInterface.1:fragment.2:bind.3(142)"></A><A name="bind.3(142)"></A>:&lt; (* bind the fragment f inside THIS(fragment) *)
            (# f: ^fragmentForm; op: ^slotDesc
            enter f[]
               ...
            exit op[]
            #);
          <B>bindToOrigin</B><A name="astInterface.1:fragment.2:bindToOrigin.3(143)"></A><A name="bindToOrigin.3(143)"></A>:
            (# f: ^FragmentForm; op: ^slotDesc
            enter f[]
               ...
            exit op[]
            #);
          <B>setupOrigin</B><A name="astInterface.1:fragment.2:setupOrigin.3(144)"></A><A name="setupOrigin.3(144)"></A>:
            (# error: ^stream
            enter error[]
            do ...
            #);
          <B>prop</B><A name="astInterface.1:fragment.2:prop.3(145)"></A><A name="prop.3(145)"></A>: ^propertyList;
          <B>pack</B><A name="astInterface.1:fragment.2:pack.3(146)"></A><A name="pack.3(146)"></A>:&lt;
            (* Private: pack representation into byte stream *)
            (# fileName: (* if none diskFileName is used *) ^text
            enter fileName[]
            do INNER 
            #);
          <B>unpack</B><A name="astInterface.1:fragment.2:unpack.3(147)"></A><A name="unpack.3(147)"></A>:&lt; (* Private: unpack rep. from bytestream *)
            (# fileName: (* if none diskFileName is used *) ^text; 
               error: ^stream 
            enter (fileName[],error[]) 
            do INNER 
            #);
          <B>bindMark</B><A name="astInterface.1:fragment.2:bindMark.3(148)"></A><A name="bindMark.3(148)"></A>:
            (* Private: true =&gt; attempting to bind slots in THIS(fragment) *)
            @boolean;
          <B>nameT</B><A name="astInterface.1:fragment.2:nameT.3(149)"></A><A name="nameT.3(149)"></A>: (* Private *) ^text;
          <B>fullNameT</B><A name="astInterface.1:fragment.2:fullNameT.3(150)"></A><A name="fullNameT.3(150)"></A>: (* Private *) ^text;
          <B>fatherR</B><A name="astInterface.1:fragment.2:fatherR.3(151)"></A><A name="fatherR.3(151)"></A>: (* Private: the enclosing group *) ^fragmentGroup;
          <B>fragType</B><A name="astInterface.1:fragment.2:fragType.3(152)"></A><A name="fragType.3(152)"></A>: (* Private *) @integer;
          <B>originR</B><A name="astInterface.1:fragment.2:originR.3(153)"></A><A name="originR.3(153)"></A>: (* Private: Attribute where THIS(fragment) 'belongs' *)
            ^fragment;
          <B>ffNameSeparatorChar</B><A name="astInterface.1:fragment.2:ffNameSeparatorChar.3(154)"></A><A name="ffNameSeparatorChar.3(154)"></A>: (* Private *) (#  exit '-' #);
          <B>catcher</B><A name="astInterface.1:fragment.2:catcher.3(155)"></A><A name="catcher.3(155)"></A>: handler (* Private *)
            (#  ... #);
       do INNER
       #);
     <B>newFragmentGroup</B><A name="astInterface.1:newFragmentGroup.2(156)"></A><A name="newFragmentGroup.2(156)"></A>:
       (* returns a new instance of fragmentGroup *)
       (# <B>g</B><A name="astInterface.1:newFragmentGroup.2:g.3(157)"></A><A name="g.3(157)"></A>: ^fragmentGroup do &amp;fragmentGroup[]-&gt;g[]; g.init;  exit g[] #);
     <B>fragmentGroup</B><A name="astInterface.1:fragmentGroup.2(158)"></A><A name="fragmentGroup.2(158)"></A>: fragment (* This is a group of fragments *)
       (# &lt;&lt;SLOT fragmentGroupLib:Attributes&gt;&gt;;
          <B>scan</B><A name="astInterface.1:fragmentGroup.2:scan.3(159)"></A><A name="scan.3(159)"></A>:
            (* scans through all fragment forms in this(fragmentGroup) *)
            (# <B>current</B><A name="astInterface.1:fragmentGroup.2:scan.3:current.4(160)"></A><A name="current.4(160)"></A>: ^fragment
            ...
            #);
          <B>scanIncludes</B><A name="astInterface.1:fragmentGroup.2:scanIncludes.3(161)"></A><A name="scanIncludes.3(161)"></A>:
            (* scans through all included fragmentGroups in
             * this(fragmentGroup)
             *)
            (# <B>current</B><A name="astInterface.1:fragmentGroup.2:scanIncludes.3:current.4(162)"></A><A name="current.4(162)"></A>: ^linklisttype.link;
            ...
            #);
          <B>scanSlots</B><A name="astInterface.1:fragmentGroup.2:scanSlots.3(163)"></A><A name="scanSlots.3(163)"></A>:
            (* scans through all SLOTs in this(fragmentGroup) *)
            (# <B>current</B><A name="astInterface.1:fragmentGroup.2:scanSlots.3:current.4(164)"></A><A name="current.4(164)"></A>: ^slotDesc
            ...
            #);
          <B>open</B><A name="astInterface.1:fragmentGroup.2:open.3(165)"></A><A name="open.3(165)"></A>: protect
            (* This operation opens a local fragment, localPath, of this group.
             * LocalPath may be a local name of the form 'foo' or a local path
             * 'foo1/foo2/.../foon' which will be interpreted local to this
             * group
             *)
            (# <B>localPath</B><A name="astInterface.1:fragmentGroup.2:open.3:localPath.4(166)"></A><A name="localPath.4(166)"></A>: ^text;
               <B>f</B><A name="astInterface.1:fragmentGroup.2:open.3:f.4(167)"></A><A name="f.4(167)"></A>: ^fragment;
               <B>g</B><A name="astInterface.1:fragmentGroup.2:open.3:g.4(168)"></A><A name="g.4(168)"></A>: ^fragmentGroup;
               <B>error</B><A name="astInterface.1:fragmentGroup.2:open.3:error.4(169)"></A><A name="error.4(169)"></A>: ^stream;
               <B>groupInx</B><A name="astInterface.1:fragmentGroup.2:open.3:groupInx.4(170)"></A><A name="groupInx.4(170)"></A>,<B>dirInx</B><A name="astInterface.1:fragmentGroup.2:open.3:dirInx.4(171)"></A><A name="dirInx.4(171)"></A>: @integer
            enter (localPath[],error[])
            ...
            exit f[]
            #);
          <B>close</B><A name="astInterface.1:fragmentGroup.2:close.3(172)"></A><A name="close.3(172)"></A>::&lt;
            (#
            ...
            #);
          <B>fragmentListElement</B><A name="astInterface.1:fragmentGroup.2:fragmentListElement.3(173)"></A><A name="fragmentListElement.3(173)"></A>:
            (# <B>f</B><A name="astInterface.1:fragmentGroup.2:fragmentListElement.3:f.4(174)"></A><A name="f.4(174)"></A>: ^fragment;
               <B>type</B><A name="astInterface.1:fragmentGroup.2:fragmentListElement.3:type.4(175)"></A><A name="type.4(175)"></A>: @integer;
               <B>name</B><A name="astInterface.1:fragmentGroup.2:fragmentListElement.3:name.4(176)"></A><A name="name.4(176)"></A>: ^text;
               <B>localName</B><A name="astInterface.1:fragmentGroup.2:fragmentListElement.3:localName.4(177)"></A><A name="localName.4(177)"></A>,<B>
               fullNameOfLink</B><A name="astInterface.1:fragmentGroup.2:fragmentListElement.3:fullNameOfLink.4(178)"></A><A name="fullNameOfLink.4(178)"></A>:
                 (* ought to be in a subpattern, Only o.k. for link-type *)
                 ^text;
               <B>open</B><A name="astInterface.1:fragmentGroup.2:fragmentListElement.3:open.4(179)"></A><A name="open.4(179)"></A>:
                 (# error: ^stream
                 enter error[]
                    ...
                 exit f[]
                 #);
               &lt;&lt;SLOT fragmentListElementPrivate:Attributes&gt;&gt;
            #);
          <B>fragmentList</B><A name="astInterface.1:fragmentGroup.2:fragmentList.3(180)"></A><A name="fragmentList.3(180)"></A>:
            ^fragmentListDescription;
          <B>loadIncludes</B><A name="astInterface.1:fragmentGroup.2:loadIncludes.3(181)"></A><A name="loadIncludes.3(181)"></A>: ...;
          <B>linkListType</B><A name="astInterface.1:fragmentGroup.2:linkListType.3(182)"></A><A name="linkListType.3(182)"></A>:
            (* to cache include links *)
            (# <B>link</B><A name="astInterface.1:fragmentGroup.2:linkListType.3:link.4(183)"></A><A name="link.4(183)"></A>:
                 (# linkname: ^text;
                    fullname: @
                      (# fn: ^text
                      ...
                      exit fn[]
                      #);
                    next: ^link
                 #);
               <B>head</B><A name="astInterface.1:fragmentGroup.2:linkListType.3:head.4(184)"></A><A name="head.4(184)"></A>: ^link
            #);
          <B>linkList</B><A name="astInterface.1:fragmentGroup.2:linkList.3(185)"></A><A name="linkList.3(185)"></A>: ^linkListType;
          <B>fragmentListDescription</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3(186)"></A><A name="fragmentListDescription.3(186)"></A>: containerList
            (# <B>element</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:element.4(187)"></A><A name="element.4(187)"></A>::&lt; fragmentListElement;
               <B>deleteLocalName</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:deleteLocalName.4(188)"></A><A name="deleteLocalName.4(188)"></A>: (* delete the fragment with the local name n *)
                 (# <B>n</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:deleteLocalName.4:n.5(189)"></A><A name="n.5(189)"></A>: ^text (* the local path *)
                 enter n[]
                    ...
                 #);
               <B>find</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:find.4(190)"></A><A name="find.4(190)"></A>:
                 (* find a local fragment. If the fragment is not open return
                  * NONE
                  *)
                 (# <B>n</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:find.4:n.5(191)"></A><A name="n.5(191)"></A>: ^text (* the local path *) ; <B>r</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:find.4:r.5(192)"></A><A name="r.5(192)"></A>: ^fragment
                 enter n[]
                    ...
                 exit r[]
                 #);
               <B>open</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:open.4(193)"></A><A name="open.4(193)"></A>:
                 (* Find a local fragment. If the fragment is not open then
                  * open it
                  *)
                 (# <B>f</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:open.4:f.5(194)"></A><A name="f.5(194)"></A>: ^fragment;
                    <B>n</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:open.4:n.5(195)"></A><A name="n.5(195)"></A>: ^text;
                    <B>e</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:open.4:e.5(196)"></A><A name="e.5(196)"></A>: ^element;
                    <B>error</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:open.4:error.5(197)"></A><A name="error.5(197)"></A>: ^stream;
                    <B>removeHeadingSlashes</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:open.4:removeHeadingSlashes.5(198)"></A><A name="removeHeadingSlashes.5(198)"></A>:
                      (* this routine removes '/' 's at the head of a
                       * text
                       *)
                      (# t: ^text; ch: @char
                      enter t[]
                      do 0-&gt;t.setPos;
                         loop:
                           (if (t.get-&gt;ch)='/' then restart loop if);
                         (if (t.pos &gt; 1) then
                             (1,t.pos-1)-&gt;t.delete
                         if)
                      exit t
                      #);
                 enter (n[],error[])
                    ...
                 exit f[]
                 #);
               <B>insertFragment</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:insertFragment.4(199)"></A><A name="insertFragment.4(199)"></A>: protect
                 (# <B>f</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:insertFragment.4:f.5(200)"></A><A name="f.5(200)"></A>: ^fragment;
                    <B>newElement</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:insertFragment.4:newElement.5(201)"></A><A name="newElement.5(201)"></A>: ^element;
                    <B>alreadyThere</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:insertFragment.4:alreadyThere.5(202)"></A><A name="alreadyThere.5(202)"></A>:&lt; (* exception, which may be called *)
                      astInterfaceException
                 enter f[]
                 ...
                 #);
               <B>addFragment</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:addFragment.4(203)"></A><A name="addFragment.4(203)"></A>: insertFragment (#  do newElement[]-&gt;append #);
               <B>insertFragmentBefore</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:insertFragmentBefore.4(204)"></A><A name="insertFragmentBefore.4(204)"></A>: insertFragment
                 (# <B>before</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:insertFragmentBefore.4:before.5(205)"></A><A name="before.5(205)"></A>: ^theCellType
                 enter before[]
                 do (newElement[],before[])-&gt;insertBefore
                 #);
               <B>insertFragmentAfter</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:insertFragmentAfter.4(206)"></A><A name="insertFragmentAfter.4(206)"></A>: insertFragment
                 (# <B>after</B><A name="astInterface.1:fragmentGroup.2:fragmentListDescription.3:insertFragmentAfter.4:after.5(207)"></A><A name="after.5(207)"></A>: ^theCellType
                 enter after[]
                 do (newElement[],after[])-&gt;insertAfter
                 #);
               &lt;&lt;SLOT fragmentListDescriptorPrivate:Attributes&gt;&gt;
            #);
          <B>defaultGrammar</B><A name="astInterface.1:fragmentGroup.2:defaultGrammar.3(208)"></A><A name="defaultGrammar.3(208)"></A>:
            ^treeLevel;
          <B>saveAs</B><A name="astInterface.1:fragmentGroup.2:saveAs.3(209)"></A><A name="saveAs.3(209)"></A>: protect
            (* save THIS(FragmentGroup) using the name fullname *)
            (# <B>fullname</B><A name="astInterface.1:fragmentGroup.2:saveAs.3:fullname.4(210)"></A><A name="fullname.4(210)"></A>: ^Text
            enter fullname[]
            do ...
            #);
          <B>saveBackup</B><A name="astInterface.1:fragmentGroup.2:saveBackup.3(211)"></A><A name="saveBackup.3(211)"></A>: protect
            (* save THIS(FragmentGroup) using the name diskFileName+ext *)
            (# <B>ext</B><A name="astInterface.1:fragmentGroup.2:saveBackup.3:ext.4(212)"></A><A name="ext.4(212)"></A>: ^Text
            enter ext[]
            do ...
            #);
          <B>restoreBackup</B><A name="astInterface.1:fragmentGroup.2:restoreBackup.3(213)"></A><A name="restoreBackup.3(213)"></A>: protect
            (* restore THIS(FragmentGroup) using the name diskFileName+ext *)
            (# <B>ext</B><A name="astInterface.1:fragmentGroup.2:restoreBackup.3:ext.4(214)"></A><A name="ext.4(214)"></A>: ^Text
            enter ext[]
            do ...
            #);
          <B>diskFileName</B><A name="astInterface.1:fragmentGroup.2:diskFileName.3(215)"></A><A name="diskFileName.3(215)"></A>::&lt;
            (#
            ...
            #);
          <B>textFileName</B><A name="astInterface.1:fragmentGroup.2:textFileName.3(216)"></A><A name="textFileName.3(216)"></A>::&lt;(#  ... #);
          <B>isRealOpen</B><A name="astInterface.1:fragmentGroup.2:isRealOpen.3(217)"></A><A name="isRealOpen.3(217)"></A>:
            (# <B>opened</B><A name="astInterface.1:fragmentGroup.2:isRealOpen.3:opened.4(218)"></A><A name="opened.4(218)"></A>: @Boolean;
            ...
            exit opened
            #);
          <B>realOpen</B><A name="astInterface.1:fragmentGroup.2:realOpen.3(219)"></A><A name="realOpen.3(219)"></A>: protect
            (* only to be used by the compiler *)
            (# do ... #);
          <B>parse</B><A name="astInterface.1:fragmentGroup.2:parse.3(220)"></A><A name="parse.3(220)"></A>: (* for parsing a fragmentGroup *)
            (# <B>groupParser</B><A name="astInterface.1:fragmentGroup.2:parse.3:groupParser.4(221)"></A><A name="groupParser.4(221)"></A>:
               ...;
               <B>parseErrors</B><A name="astInterface.1:fragmentGroup.2:parse.3:parseErrors.4(222)"></A><A name="parseErrors.4(222)"></A>:&lt; (* exception called if parse-errors *)
                 astInterfaceException;
               <B>fatalParseError</B><A name="astInterface.1:fragmentGroup.2:parse.3:fatalParseError.4(223)"></A><A name="fatalParseError.4(223)"></A>:&lt; astInterfaceException
                 (# errNo: @integer enter errNo do INNER #);
               <B>doubleFormDeclaration</B><A name="astInterface.1:fragmentGroup.2:parse.3:doubleFormDeclaration.4(224)"></A><A name="doubleFormDeclaration.4(224)"></A>:&lt;
                 (* exception called if two fragmentForms with the same name *)
                 astInterfaceException;
               <B>inputname</B><A name="astInterface.1:fragmentGroup.2:parse.3:inputname.4(225)"></A><A name="inputname.4(225)"></A>: ^text;
               <B>error</B><A name="astInterface.1:fragmentGroup.2:parse.3:error.4(226)"></A><A name="error.4(226)"></A>: ^stream;
               <B>ok</B><A name="astInterface.1:fragmentGroup.2:parse.3:ok.4(227)"></A><A name="ok.4(227)"></A>: @boolean
            enter (inputname[],error[])
            do groupParser
            exit ok
            #);
          <B>init</B><A name="astInterface.1:fragmentGroup.2:init.3(228)"></A><A name="init.3(228)"></A>::&lt;  (#  ... #);
          <B>bind</B><A name="astInterface.1:fragmentGroup.2:bind.3(229)"></A><A name="bind.3(229)"></A>::&lt;
            (#
            do ...
            #);
          <B>getBinding</B><A name="astInterface.1:fragmentGroup.2:getBinding.3(230)"></A><A name="getBinding.3(230)"></A>:
            (* Get the bindings of the slot within THIS(fragmentGroup).  All
             * bindings are delivered.  For each binding, found is called.  The
             * elements of THIS(fragmentGroup) must be fragment forms or
             * fragment links to such.
             *)
            (# <B>mark</B><A name="astInterface.1:fragmentGroup.2:getBinding.3:mark.4(231)"></A><A name="mark.4(231)"></A>: @
                 (# f: ^fragmentGroup;
                    inserted: @boolean;
                    scan:
                      (# current: ^fragmentGroup;
                      do ...
                      #);
                    elm:
                      (* Private *) (# f: ^fragmentGroup; succ: ^elm #);
                    head: (* Private *) ^elm;
                 enter f[]
                    ...
                 exit inserted
                 #);
               <B>markRelatedFragments</B><A name="astInterface.1:fragmentGroup.2:getBinding.3:markRelatedFragments.4(232)"></A><A name="markRelatedFragments.4(232)"></A>:&lt;
                 (# f: ^fragment;
                 enter f[]
                 do (if (f[] &lt;&gt; none) then INNER if)
                 #);
               <B>found</B><A name="astInterface.1:fragmentGroup.2:getBinding.3:found.4(233)"></A><A name="found.4(233)"></A>:&lt;
                 (# theBinding: ^fragmentForm
                 enter theBinding[]
                 ...
                 #);
               <B>sl</B><A name="astInterface.1:fragmentGroup.2:getBinding.3:sl.4(234)"></A><A name="sl.4(234)"></A>: ^slotDesc
            enter sl[]
               ...
            #);
          (* lock/unlock/locked operations *)
          <B>lock</B><A name="astInterface.1:fragmentGroup.2:lock.3(235)"></A><A name="lock.3(235)"></A>:
            (* operation to signal to the rest of the users of this MPS,
             * that I will be working on this fg, and it may be in
             * inconsistent state
             *)
            (# ... #);
          <B>unlock</B><A name="astInterface.1:fragmentGroup.2:unlock.3(236)"></A><A name="unlock.3(236)"></A>:
            (* operation to signal to the rest of the users of this MPS,
             * that I am releasing the lock on this fg.
             *)
            (# ... #);
          <B>locked</B><A name="astInterface.1:fragmentGroup.2:locked.3(237)"></A><A name="locked.3(237)"></A>: @booleanValue;
          (********** PRIVATE PART *********************)
          <B>pack</B><A name="astInterface.1:fragmentGroup.2:pack.3(238)"></A><A name="pack.3(238)"></A>::&lt; (* Private *)
            (#  ... #);
          <B>unpack</B><A name="astInterface.1:fragmentGroup.2:unpack.3(239)"></A><A name="unpack.3(239)"></A>::&lt; (* Private *)
            (# 
            do ...
            #);
          <B>checkDiskRepresentation</B><A name="astInterface.1:fragmentGroup.2:checkDiskRepresentation.3(240)"></A><A name="checkDiskRepresentation.3(240)"></A>::&lt; (* Private *)
            (#  ... #);
          <B>isDirectory</B><A name="astInterface.1:fragmentGroup.2:isDirectory.3(241)"></A><A name="isDirectory.3(241)"></A>:
            (* Private: true if the group is not a 'real' group but a
             * directory
             *) @boolean;
          <B>controller</B><A name="astInterface.1:fragmentGroup.2:controller.3(242)"></A><A name="controller.3(242)"></A>: @ (* used by the control module in the compiler *)
            (# <B>status</B><A name="astInterface.1:fragmentGroup.2:controller.3:status.4(243)"></A><A name="status.4(243)"></A>: @integer;
               <B>ancestorTime</B><A name="astInterface.1:fragmentGroup.2:controller.3:ancestorTime.4(244)"></A><A name="ancestorTime.4(244)"></A>: @integer;
               <B>ancestorsChecked</B><A name="astInterface.1:fragmentGroup.2:controller.3:ancestorsChecked.4(245)"></A><A name="ancestorsChecked.4(245)"></A>: @boolean;
               <B>doneCheck</B><A name="astInterface.1:fragmentGroup.2:controller.3:doneCheck.4(246)"></A><A name="doneCheck.4(246)"></A>: @boolean;
               <B>groupT</B><A name="astInterface.1:fragmentGroup.2:controller.3:groupT.4(247)"></A><A name="groupT.4(247)"></A>: @Integer;
               <B>printName</B><A name="astInterface.1:fragmentGroup.2:controller.3:printName.4(248)"></A><A name="printName.4(248)"></A>: ^text;
            #);
          <B>private</B><A name="astInterface.1:fragmentGroup.2:private.3(249)"></A><A name="private.3(249)"></A>: @...;
       #) (* fragmentGroup *);
     <B>newFragmentForm</B><A name="astInterface.1:newFragmentForm.2(250)"></A><A name="newFragmentForm.2(250)"></A>: (* returns a new instance of fragmentForm *)
       (# <B>g</B><A name="astInterface.1:newFragmentForm.2:g.3(251)"></A><A name="g.3(251)"></A>: ^treeLevel; <B>f</B><A name="astInterface.1:newFragmentForm.2:f.3(252)"></A><A name="f.3(252)"></A>: ^fragmentForm
       enter g[]
       do &amp;fragmentForm[]-&gt;f[]; g[]-&gt;f.grammar[]; f.init;
       exit f[]
       #);
     <B>fragmentForm</B><A name="astInterface.1:fragmentForm.2(253)"></A><A name="fragmentForm.2(253)"></A>: fragment
       (* This is the basic form of a fragment defined by means of a general
        * sentential form
        *)
       (# &lt;&lt;SLOT fragmentFormLib:Attributes&gt;&gt;;
          <B>category</B><A name="astInterface.1:fragmentForm.2:category.3(254)"></A><A name="category.3(254)"></A>:
            (# <B>sy</B><A name="astInterface.1:fragmentForm.2:category.3:sy.4(255)"></A><A name="sy.4(255)"></A>: @integer
            ...
            exit sy
            #);
          <B>theGsForm</B><A name="astInterface.1:fragmentForm.2:theGsForm.3(256)"></A><A name="theGsForm.3(256)"></A>: (#  exit (root.index,THIS(fragmentForm)[]) #);
          <B>fragNode</B><A name="astInterface.1:fragmentForm.2:fragNode.3(257)"></A><A name="fragNode.3(257)"></A>: (#  exit (0,THIS(fragmentForm)[]) #);
          <B>print</B><A name="astInterface.1:fragmentForm.2:print.3(258)"></A><A name="print.3(258)"></A>:
            (#
            do 'Print called of fragmentForm '-&gt;screen.puttext;
               fullName-&gt;screen.puttext;
               screen.newLine;
            #);
          <B>binding</B><A name="astInterface.1:fragmentForm.2:binding.3(259)"></A><A name="binding.3(259)"></A>: (* The SLOT bound by THIS(fragmentForm) *) ^slotDesc;
          <B>modificationStatus</B><A name="astInterface.1:fragmentForm.2:modificationStatus.3(260)"></A><A name="modificationStatus.3(260)"></A>: @integer;
          <B>root</B><A name="astInterface.1:fragmentForm.2:root.3(261)"></A><A name="root.3(261)"></A>:
            (* the root symbol of the ast kept in the array.  Set by the
             * parser
             *) ^ast;
          <B>recomputeSlotChain</B><A name="astInterface.1:fragmentForm.2:recomputeSlotChain.3(262)"></A><A name="recomputeSlotChain.3(262)"></A>:
            (#  do ...;  #);
          <B>scanSlots</B><A name="astInterface.1:fragmentForm.2:scanSlots.3(263)"></A><A name="scanSlots.3(263)"></A>:
            (* access operations: scan all SLOTs in THIS(fragmentForm) *)
            (# <B>inx</B><A name="astInterface.1:fragmentForm.2:scanSlots.3:inx.4(264)"></A><A name="inx.4(264)"></A>: @integer; <B>current</B><A name="astInterface.1:fragmentForm.2:scanSlots.3:current.4(265)"></A><A name="current.4(265)"></A>: ^slotDesc;
            ...
            #);
          <B>grammar</B><A name="astInterface.1:fragmentForm.2:grammar.3(266)"></A><A name="grammar.3(266)"></A>: ^treeLevel;
          <B>indexToNode</B><A name="astInterface.1:fragmentForm.2:indexToNode.3(267)"></A><A name="indexToNode.3(267)"></A>:
            (# <B>inx</B><A name="astInterface.1:fragmentForm.2:indexToNode.3:inx.4(268)"></A><A name="inx.4(268)"></A>: @integer;
               <B>as</B><A name="astInterface.1:fragmentForm.2:indexToNode.3:as.4(269)"></A><A name="as.4(269)"></A>: ^ast;
               <B>indexOutOfRange</B><A name="astInterface.1:fragmentForm.2:indexToNode.3:indexOutOfRange.4(270)"></A><A name="indexOutOfRange.4(270)"></A>:&lt;
                 astInterfaceException;
               <B>noSuchSymbol</B><A name="astInterface.1:fragmentForm.2:indexToNode.3:noSuchSymbol.4(271)"></A><A name="noSuchSymbol.4(271)"></A>:&lt; astInterfaceException;
               <B>grammarGenRefArrayError</B><A name="astInterface.1:fragmentForm.2:indexToNode.3:grammarGenRefArrayError.4(272)"></A><A name="grammarGenRefArrayError.4(272)"></A>:&lt; astInterfaceException;
            enter inx
            do ...
            exit as[]
            #);
          &lt;&lt;SLOT fragmentFormPrivate:Attributes&gt;&gt;;
          <B>a</B><A name="astInterface.1:fragmentForm.2:a.3(273)"></A><A name="a.3(273)"></A>: (* Private *) [initialLength] @integer;
          <B>curtop</B><A name="astInterface.1:fragmentForm.2:curtop.3(274)"></A><A name="curtop.3(274)"></A>: (* Private: current heapTop in the array a *) @integer;
          <B>l</B><A name="astInterface.1:fragmentForm.2:l.3(275)"></A><A name="l.3(275)"></A>: (* Private *) [initialLength] @integer;
          <B>lcurtop</B><A name="astInterface.1:fragmentForm.2:lcurtop.3(276)"></A><A name="lcurtop.3(276)"></A>: (* Private: current heapTop in the array 'l' *) @integer;
          <B>initialLength</B><A name="astInterface.1:fragmentForm.2:initialLength.3(277)"></A><A name="initialLength.3(277)"></A>:&lt; (* Private *)
            (# <B>max</B><A name="astInterface.1:fragmentForm.2:initialLength.3:max.4(278)"></A><A name="max.4(278)"></A>: @integer do 200-&gt;max; INNER exit max #);
          <B>firstSlot</B><A name="astInterface.1:fragmentForm.2:firstSlot.3(279)"></A><A name="firstSlot.3(279)"></A>:
            (* Private: The index of the first SLOT in the array a. The SLOTs
             * are linked together through the 'slotUsage-field' of SLOTs
             *) @integer;
          <B>diskFileName</B><A name="astInterface.1:fragmentForm.2:diskFileName.3(280)"></A><A name="diskFileName.3(280)"></A>::&lt; (* Private *)
            (#  do fatherR.diskFileName-&gt;t[] #);
          <B>textFileName</B><A name="astInterface.1:fragmentForm.2:textFileName.3(281)"></A><A name="textFileName.3(281)"></A>::&lt; (* Private *)
            (#  do fatherR.textFileName-&gt;t[] #);
          <B>import</B><A name="astInterface.1:fragmentForm.2:import.3(282)"></A><A name="import.3(282)"></A>: @ (* Private *)
            (* An indexed collection of fragments referred by
             * THIS(fragmentForm)
             *)
            (# <B>impL</B><A name="astInterface.1:fragmentForm.2:import.3:impL.4(283)"></A><A name="impL.4(283)"></A>: ^list;
               <B>inxC</B><A name="astInterface.1:fragmentForm.2:import.3:inxC.4(284)"></A><A name="inxC.4(284)"></A>: @integer;
               <B>element</B><A name="astInterface.1:fragmentForm.2:import.3:element.4(285)"></A><A name="element.4(285)"></A>: (# n: ^text; f: ^fragmentForm #);
               <B>list</B><A name="astInterface.1:fragmentForm.2:import.3:list.4(286)"></A><A name="list.4(286)"></A>:
                 (# noOfElements:&lt;(# nu: @integer;  do 10-&gt;nu; INNER exit nu #);
                    l: [noOfElements] ^element;
                 #);
               &lt;&lt;SLOT fragmentFormImportPrivate:Attributes&gt;&gt;
            #);
          <B>rootInx</B><A name="astInterface.1:fragmentForm.2:rootInx.3(287)"></A><A name="rootInx.3(287)"></A>: @integer;
          <B>init</B><A name="astInterface.1:fragmentForm.2:init.3(288)"></A><A name="init.3(288)"></A>::&lt; (* Private *)
            (#
            ...
            #);
          <B>reset</B><A name="astInterface.1:fragmentForm.2:reset.3(289)"></A><A name="reset.3(289)"></A>::&lt; (* Private *)
            (#  ... #);
          <B>private</B><A name="astInterface.1:fragmentForm.2:private.3(290)"></A><A name="private.3(290)"></A>: @...;
       #);
     <B>astFileExtension</B><A name="astInterface.1:astFileExtension.2(291)"></A><A name="astFileExtension.2(291)"></A>:
       (* exits the filename extension for AST files on the particular
        * architecture (the extension differs e.g. for big- and little endian
        * architectures).  See e.g. initialization in astBody.bet
        *) (#  exit astFileExt[] #);
     <B>parserFileExtension</B><A name="astInterface.1:parserFileExtension.2(292)"></A><A name="parserFileExtension.2(292)"></A>:
       (* exits the filename extension for parser table files on the particular
        * architecture (the extension differs e.g. for big- and little endian
        * architectures).  See e.g. initialization in astBody.bet
        *) (#  exit parserFileExt[] #);
     <B>ppFileExtension</B><A name="astInterface.1:ppFileExtension.2(293)"></A><A name="ppFileExtension.2(293)"></A>:
       (* exits the filename extension for pretty-printer table files on the
        * particular architecture (the extension differs e.g. for big- and
        * little endian architectures).  See e.g. initialization in astBody.bet
        *) (#  exit ppFileExt[] #);
     <B>astFileExt</B><A name="astInterface.1:astFileExt.2(294)"></A><A name="astFileExt.2(294)"></A>: (* Private *) ^text;
     <B>parserFileExt</B><A name="astInterface.1:parserFileExt.2(295)"></A><A name="parserFileExt.2(295)"></A>: (* Private *) ^text;
     <B>ppFileExt</B><A name="astInterface.1:ppFileExt.2(296)"></A><A name="ppFileExt.2(296)"></A>: (* Private *) ^text;

     (************** END The Fragment Library END ***************)
     <B>top</B><A name="astInterface.1:top.2(297)"></A><A name="top.2(297)"></A>: @
       (# <B>init</B><A name="astInterface.1:top.2:init.3(298)"></A><A name="init.3(298)"></A>: (#  ... #);
          <B>groupTable</B><A name="astInterface.1:top.2:groupTable.3(299)"></A><A name="groupTable.3(299)"></A>: @HashTable
            (# element::
                 (# fullname: ^Text;
                    g: ^FragmentGroup;
                    open:
                      (# error: ^Stream;
                      enter error[]
                         ...
                      exit g[]
                      #);
                 #);
               dummy: @Element;
               hashFunction::
                 (# inx: @Integer;
                 do L:
                      (for i: 26 repeat
                           e.fullname.lgth-i+1-&gt;inx;
                           (if inx &lt; 1 then leave L if);
                           e.fullname.T[inx]+value-&gt;value;

                      for)
                 #);
               equal::
                 (#  do left.fullname[]-&gt;right.fullname.equal-&gt;value #);
               rangeInitial::  (#  do 500-&gt;value #);
               find:
                 (* find a fragment group. If the fragment is not open return
                  * NONE
                  *)
                 (# fullName: ^text (* the path *) ; g: ^fragmentGroup
                 enter fullName[]
                    ...
                 exit g[]
                 #);
               open:
                 (* Find a local fragment. If the fragment is not open then
                  * open it
                  *)
                 (# g: ^fragmentgroup;
                    fullName: ^text;
                    e: ^element;
                    error: ^stream;
                    removeHeadingSlashes:
                      (* this routine removes '/' 's at the head of a
                       * text
                       *)
                      (# t: ^text; ch: @char
                      enter t[]
                      do 0-&gt;t.setPos;
                         loop:
                           (if (t.get-&gt;ch)='/' then restart loop if);
                         (if (t.pos &gt; 1) then
                             (1,t.pos-1)-&gt;t.delete
                         if)
                      exit t
                      #);
                 enter (fullName[],error[])
                    ...
                 exit g[]
                 #);
               &lt;&lt;SLOT topTablePrivate:Attributes&gt;&gt;
            #);
          <B>open</B><A name="astInterface.1:top.2:open.3(300)"></A><A name="open.3(300)"></A>: protect
            (* This operation opens a fragmentgroup file: fileName
             *)
            (# fileName: ^text;
               g: ^fragmentGroup;
               f: ^fragment;
               error: ^stream
            enter (fileName[],error[])
            do ...;
               g[]-&gt;f[];
            exit f[]
            #);
          <B>newGroup</B><A name="astInterface.1:top.2:newGroup.3(301)"></A><A name="newGroup.3(301)"></A>: (* make a new group with top as father *)
            (# fullname: ^Text;
               fg: ^FragmentGroup;
               alreadyOpen:&lt; astInterfaceException;
            enter fullname[]
               ...
            exit fg[]
            #);
          <B>close</B><A name="astInterface.1:top.2:close.3(302)"></A><A name="close.3(302)"></A>: (* close FragmentGroup fg *)
            (# fg: ^fragmentGroup;
            enter fg[]
            ...
            #);
          <B>namedClose</B><A name="astInterface.1:top.2:namedClose.3(303)"></A><A name="namedClose.3(303)"></A>: (* close FragmentGroup fullname *)
            (# fullname: ^text
            enter fullname[]
            ...
            #);
          <B>delete</B><A name="astInterface.1:top.2:delete.3(304)"></A><A name="delete.3(304)"></A>:
            (* delete FragmentGroup fg *)
            (# fg: ^fragmentGroup;
            enter fg[]
            ...
            #);
          <B>insert</B><A name="astInterface.1:top.2:insert.3(305)"></A><A name="insert.3(305)"></A>:
            (* insert a FragmentGroup into top table *)
            (# fg: ^fragmentGroup;
            enter fg[]
            do ...
            #);
          <B>isOpen</B><A name="astInterface.1:top.2:isOpen.3(306)"></A><A name="isOpen.3(306)"></A>:
            (* return Group fullname if it is already open, otherwise NONE *)
            (# fullname: ^Text; fg: ^FragmentGroup;
            enter fullname[]
               ...
            exit fg[]
            #);
          <B>topGroup</B><A name="astInterface.1:top.2:topGroup.3(307)"></A><A name="topGroup.3(307)"></A>: ^FragmentGroup;
          <B>catcher</B><A name="astInterface.1:top.2:catcher.3(308)"></A><A name="catcher.3(308)"></A>: handler (* Private *)
            (#  ... #);
       #);
     (* end of top *)
     <B>parseSymbolDescriptor</B><A name="astInterface.1:parseSymbolDescriptor.2(309)"></A><A name="parseSymbolDescriptor.2(309)"></A>:
       (# <B>terminals</B><A name="astInterface.1:parseSymbolDescriptor.2:terminals.3(310)"></A><A name="terminals.3(310)"></A>: (* is dynamically expanded *) [1]
            ^text;
          <B>nonterminals</B><A name="astInterface.1:parseSymbolDescriptor.2:nonterminals.3(311)"></A><A name="nonterminals.3(311)"></A>: (* is dynamically expanded *) [1] @integer;
       #);
     <B>errorReporter</B><A name="astInterface.1:errorReporter.2(312)"></A><A name="errorReporter.2(312)"></A>:
       (* error-reporter pattern. Create a specialization of this pattern if
        * you want to do your own error-reporting
        *)
       (# <B>frag</B><A name="astInterface.1:errorReporter.2:frag.3(313)"></A><A name="frag.3(313)"></A>: ^fragment;
          <B>errorStream</B><A name="astInterface.1:errorReporter.2:errorStream.3(314)"></A><A name="errorStream.3(314)"></A>: ^stream;
          <B>beforeFirstError</B><A name="astInterface.1:errorReporter.2:beforeFirstError.3(315)"></A><A name="beforeFirstError.3(315)"></A>:&lt; object;
          <B>afterLastError</B><A name="astInterface.1:errorReporter.2:afterLastError.3(316)"></A><A name="afterLastError.3(316)"></A>:&lt; object;
          <B>forEachError</B><A name="astInterface.1:errorReporter.2:forEachError.3(317)"></A><A name="forEachError.3(317)"></A>:&lt;
            (# streamPos,startLineNo: @integer;
               errorLines:
                 (* 1, 2 or 3 lines of text before the
                  * error.  Approx. 100 chars
                  *) @text;
               errorPos: (* the pos in errorLines of the error *) @integer;
               legalSymbols: ^parseSymbolDescriptor
            enter (streamPos,startLineNo,errorLines,errorPos (*inx*) ,legalSymbols[])
            do INNER
            #);
       #);
     <B>theErrorReporter</B><A name="astInterface.1:theErrorReporter.2(318)"></A><A name="theErrorReporter.2(318)"></A>:
       (* the error reporter which will be called from the fragmentGroupparser
        * or from fragmentForm.parser.errorReport
        *) ^errorReporter;
     <B>treeLevel</B><A name="astInterface.1:treeLevel.2(319)"></A><A name="treeLevel.2(319)"></A>:
       (* prefix for descriptions of grammars *)
       (# &lt;&lt;SLOT treeLevelLib:Attributes&gt;&gt;;
          <B>grammarAst</B><A name="astInterface.1:treeLevel.2:grammarAst.3(320)"></A><A name="grammarAst.3(320)"></A>:
            (* if not NONE this point to the form of the ast describing the
             * grammar
             *) ^fragmentForm;
          <B>symbolToName</B><A name="astInterface.1:treeLevel.2:symbolToName.3(321)"></A><A name="symbolToName.3(321)"></A>: (* gives a human-readable name for a symbol-number *)
            (# <B>symbol</B><A name="astInterface.1:treeLevel.2:symbolToName.3:symbol.4(322)"></A><A name="symbol.4(322)"></A>: @integer; <B>t</B><A name="astInterface.1:treeLevel.2:symbolToName.3:t.4(323)"></A><A name="t.4(323)"></A>: ^text;
            enter symbol
            do &amp;text[]-&gt;t[]; ...
            exit t[]
            #);
          <B>symbolToAst</B><A name="astInterface.1:treeLevel.2:symbolToAst.3(324)"></A><A name="symbolToAst.3(324)"></A>:
            (# <B>symbol</B><A name="astInterface.1:treeLevel.2:symbolToAst.3:symbol.4(325)"></A><A name="symbol.4(325)"></A>: @integer;
               <B>as</B><A name="astInterface.1:treeLevel.2:symbolToAst.3:as.4(326)"></A><A name="as.4(326)"></A>: ^ast;
            enter symbol
               ...
            exit as[]
            #);
          <B>newAst</B><A name="astInterface.1:treeLevel.2:newAst.3(327)"></A><A name="newAst.3(327)"></A>: (* returns a new instance of ast *)
            (# <B>prod</B><A name="astInterface.1:treeLevel.2:newAst.3:prod.4(328)"></A><A name="prod.4(328)"></A>: @integer; <B>as</B><A name="astInterface.1:treeLevel.2:newAst.3:as.4(329)"></A><A name="as.4(329)"></A>: ^ast; <B>frag</B><A name="astInterface.1:treeLevel.2:newAst.3:frag.4(330)"></A><A name="frag.4(330)"></A>: ^fragmentForm;
            enter (prod,frag[])
            do ...
            exit as[]
            #);
          <B>newAstWithoutSons</B><A name="astInterface.1:treeLevel.2:newAstWithoutSons.3(331)"></A><A name="newAstWithoutSons.3(331)"></A>:
            (# <B>prod</B><A name="astInterface.1:treeLevel.2:newAstWithoutSons.3:prod.4(332)"></A><A name="prod.4(332)"></A>: @integer;
               <B>as</B><A name="astInterface.1:treeLevel.2:newAstWithoutSons.3:as.4(333)"></A><A name="as.4(333)"></A>: ^ast;
               <B>frag</B><A name="astInterface.1:treeLevel.2:newAstWithoutSons.3:frag.4(334)"></A><A name="frag.4(334)"></A>: ^fragmentForm;
            enter (prod,frag[])
               ...
            exit as[]
            #);
          <B>newLexemText</B><A name="astInterface.1:treeLevel.2:newLexemText.3(335)"></A><A name="newLexemText.3(335)"></A>: (* returns a new instance of lexemText *)
            (# <B>length</B><A name="astInterface.1:treeLevel.2:newLexemText.3:length.4(336)"></A><A name="length.4(336)"></A>: @integer;
               <B>prod</B><A name="astInterface.1:treeLevel.2:newLexemText.3:prod.4(337)"></A><A name="prod.4(337)"></A>: @integer;
               <B>frag</B><A name="astInterface.1:treeLevel.2:newLexemText.3:frag.4(338)"></A><A name="frag.4(338)"></A>: ^fragmentForm;
               <B>inx</B><A name="astInterface.1:treeLevel.2:newLexemText.3:inx.4(339)"></A><A name="inx.4(339)"></A>,<B>base</B><A name="astInterface.1:treeLevel.2:newLexemText.3:base.4(340)"></A><A name="base.4(340)"></A>: @integer;
            enter
                  (#
                  enter (prod,length,frag[])
                     ...
                  #)
            exit
                 (# as: ^ast
                   ...
                 exit as[]
                 #)
            #);
          <B>newConst</B><A name="astInterface.1:treeLevel.2:newConst.3(341)"></A><A name="newConst.3(341)"></A>: (* returns a new instance of const *)
            (# <B>c</B><A name="astInterface.1:treeLevel.2:newConst.3:c.4(342)"></A><A name="c.4(342)"></A>: ^const; <B>frag</B><A name="astInterface.1:treeLevel.2:newConst.3:frag.4(343)"></A><A name="frag.4(343)"></A>: ^fragmentForm
            enter frag[]
               ...
            exit c[]
            #);
          <B>newUnexpanded</B><A name="astInterface.1:treeLevel.2:newUnexpanded.3(344)"></A><A name="newUnexpanded.3(344)"></A>:
            (* returns a new instance of unExpanded *)
            (# <B>s</B><A name="astInterface.1:treeLevel.2:newUnexpanded.3:s.4(345)"></A><A name="s.4(345)"></A>: ^unExpanded; <B>syncatNo</B><A name="astInterface.1:treeLevel.2:newUnexpanded.3:syncatNo.4(346)"></A><A name="syncatNo.4(346)"></A>: @integer; <B>frag</B><A name="astInterface.1:treeLevel.2:newUnexpanded.3:frag.4(347)"></A><A name="frag.4(347)"></A>: ^fragmentForm
            enter (syncatNo,frag[])
               ...
            exit s[]
            #);
          <B>newOptional</B><A name="astInterface.1:treeLevel.2:newOptional.3(348)"></A><A name="newOptional.3(348)"></A>:
            (* returns a new instance of optional *)
            (# <B>s</B><A name="astInterface.1:treeLevel.2:newOptional.3:s.4(349)"></A><A name="s.4(349)"></A>: ^optional; <B>syncatNo</B><A name="astInterface.1:treeLevel.2:newOptional.3:syncatNo.4(350)"></A><A name="syncatNo.4(350)"></A>: @integer; <B>frag</B><A name="astInterface.1:treeLevel.2:newOptional.3:frag.4(351)"></A><A name="frag.4(351)"></A>: ^fragmentForm;
            enter (syncatNo,frag[])
               ...
            exit s[]
            #);
          <B>newSlot</B><A name="astInterface.1:treeLevel.2:newSlot.3(352)"></A><A name="newSlot.3(352)"></A>:
            (* returns a new instance of slotDesc *)
            (# <B>s</B><A name="astInterface.1:treeLevel.2:newSlot.3:s.4(353)"></A><A name="s.4(353)"></A>: ^slotDesc; <B>frag</B><A name="astInterface.1:treeLevel.2:newSlot.3:frag.4(354)"></A><A name="frag.4(354)"></A>: ^fragmentForm
            enter frag[]
               ...
            exit s[]
            #);
          <B>version</B><A name="astInterface.1:treeLevel.2:version.3(355)"></A><A name="version.3(355)"></A>:&lt; (* returns the grammar version *)
            integerObject (# ... #);
          <B>grammarIdentification</B><A name="astInterface.1:treeLevel.2:grammarIdentification.3(356)"></A><A name="grammarIdentification.3(356)"></A>:&lt; (* the grammar name *)
            (# <B>theGrammarName</B><A name="astInterface.1:treeLevel.2:grammarIdentification.3:theGrammarName.4(357)"></A><A name="theGrammarName.4(357)"></A>: ^text
            ...
            exit theGrammarName[]
            #);
          <B>suffix</B><A name="astInterface.1:treeLevel.2:suffix.3(358)"></A><A name="suffix.3(358)"></A>:&lt;
            (* the file-name extension used for files containing programs
             * derived from this grammar.  Default extension is '.text'.
             *)
            (# <B>theSuffix</B><A name="astInterface.1:treeLevel.2:suffix.3:theSuffix.4(359)"></A><A name="theSuffix.4(359)"></A>: ^text
            ...
            exit theSuffix[]
            #);
          <B>init</B><A name="astInterface.1:treeLevel.2:init.3(360)"></A><A name="init.3(360)"></A>:&lt;(# do ... #);
          <B>parser</B><A name="astInterface.1:treeLevel.2:parser.3(361)"></A><A name="parser.3(361)"></A>: @parse;
          <B>parse</B><A name="astInterface.1:treeLevel.2:parse.3(362)"></A><A name="parse.3(362)"></A>:
            (# <B>errorReport</B><A name="astInterface.1:treeLevel.2:parse.3:errorReport.4(363)"></A><A name="errorReport.4(363)"></A>:
                 (* produce an errorReport on stream if the last parse did not
                  * succeed
                  *)
                 (# input,error: ^stream;
                 enter (input[],error[])
                 do ...
                 #);
               <B>findSymbolNo</B><A name="astInterface.1:treeLevel.2:parse.3:findSymbolNo.4(364)"></A><A name="findSymbolNo.4(364)"></A>:
                 (* given a text-string, find the nonterminal-symbol, that has
                  * that name
                  *)
                 (# symbol: ^text; no: @integer
                 enter symbol[]
                    ...
                 exit no
                 #);
               <B>input</B><A name="astInterface.1:treeLevel.2:parse.3:input.4(365)"></A><A name="input.4(365)"></A>,<B>error</B><A name="astInterface.1:treeLevel.2:parse.3:error.4(366)"></A><A name="error.4(366)"></A>: ^stream;
               <B>goalSymbol</B><A name="astInterface.1:treeLevel.2:parse.3:goalSymbol.4(367)"></A><A name="goalSymbol.4(367)"></A>:
                 @nonterminalSymbol;
               <B>frag</B><A name="astInterface.1:treeLevel.2:parse.3:frag.4(368)"></A><A name="frag.4(368)"></A>: ^fragmentForm;
               <B>ok</B><A name="astInterface.1:treeLevel.2:parse.3:ok.4(369)"></A><A name="ok.4(369)"></A>,<B>haveBeenInitialized</B><A name="astInterface.1:treeLevel.2:parse.3:haveBeenInitialized.4(370)"></A><A name="haveBeenInitialized.4(370)"></A>: @boolean;
               <B>parseEndPos</B><A name="astInterface.1:treeLevel.2:parse.3:parseEndPos.4(371)"></A><A name="parseEndPos.4(371)"></A>: @integer;
               <B>lastCh</B><A name="astInterface.1:treeLevel.2:parse.3:lastCh.4(372)"></A><A name="lastCh.4(372)"></A>: @char;
               <B>privatePart</B><A name="astInterface.1:treeLevel.2:parse.3:privatePart.4(373)"></A><A name="privatePart.4(373)"></A>: @...;
               <B>initialize</B><A name="astInterface.1:treeLevel.2:parse.3:initialize.4(374)"></A><A name="initialize.4(374)"></A>:
                 (# fileName: ^text;
                    isEos:&lt;
                      (* '--' may be considered as end-of-stream *) 
                      booleanValue(# do true-&gt;value #);
                    longLexems:&lt;
                      (* the lexems may be long (multi-word lexems) *)
                      booleanValue;
                    dashNames:&lt; (* dash '-' may be allowed in indentifiers *)
                      booleanValue;
                    caseSensitive:&lt; (* allows keywords to be case sensitive *)
                      booleanValue;
                    EOLasComEnd:&lt; (* EOL is also accepted as end-of-comment *)
                      booleanValue;
                    SplitString:&lt;(* a string may be split into several units 
                                   * 'xxx' 'yyy' is lexed as 'xxx&lt;0&gt;yyy'
                                  *)
                      BooleanValue
                 enter fileName[]
                    ...
                 #);
               <B>doParse</B><A name="astInterface.1:treeLevel.2:parse.3:doParse.4(375)"></A><A name="doParse.4(375)"></A>: protect
                 (# catcher: handler (* Private *)
                      (#  ... #)
                 enter (goalSymbol,input[],error[],frag[])
                 do ...
                 exit ok
                 #);
               <B>commentId</B><A name="astInterface.1:treeLevel.2:parse.3:commentId.4(376)"></A><A name="commentId.4(376)"></A>:
                 (* declared to be able to get the value of comment inside the
                  * comment-binding in the parser
                  *) (#  exit comment #);
            enter (goalSymbol,input[],error[],frag[])
            do doParse;
            exit ok
            #);
          &lt;&lt;SLOT treeLevelPrivate:Attributes&gt;&gt;;
          <B>private</B><A name="astInterface.1:treeLevel.2:private.3(377)"></A><A name="private.3(377)"></A>: @ ...;
          <B>kindArray</B><A name="astInterface.1:treeLevel.2:kindArray.3(378)"></A><A name="kindArray.3(378)"></A>: (* Private *) [maxProductions] @integer;
          <B>nodeClassArray</B><A name="astInterface.1:treeLevel.2:nodeClassArray.3(379)"></A><A name="nodeClassArray.3(379)"></A>: (* Private *) [maxProductions] @integer;
          <B>sonArray</B><A name="astInterface.1:treeLevel.2:sonArray.3(380)"></A><A name="sonArray.3(380)"></A>: (* Private *) [maxProductions] @integer;
          <B>roomArray</B><A name="astInterface.1:treeLevel.2:roomArray.3(381)"></A><A name="roomArray.3(381)"></A>: (* Private *) [maxProductions] @integer;
          <B>genRefArray</B><A name="astInterface.1:treeLevel.2:genRefArray.3(382)"></A><A name="genRefArray.3(382)"></A>: (* Private *) [maxProductions] ##ast;
          <B>prettyPrinter</B><A name="astInterface.1:treeLevel.2:prettyPrinter.3(383)"></A><A name="prettyPrinter.3(383)"></A>: (* Private *) ^object;
          <B>maxProductions</B><A name="astInterface.1:treeLevel.2:maxProductions.3(384)"></A><A name="maxProductions.3(384)"></A>:&lt; integerObject (* Private *)
            (#  do 400-&gt;value; INNER #);
       #);
     <B>kinds</B><A name="astInterface.1:kinds.2(385)"></A><A name="kinds.2(385)"></A>: @
       (# <B>interior</B><A name="astInterface.1:kinds.2:interior.3(386)"></A><A name="interior.3(386)"></A>: (#  exit 1 #);
          <B>unExpanded</B><A name="astInterface.1:kinds.2:unExpanded.3(387)"></A><A name="unExpanded.3(387)"></A>: (#  exit 2 #);
          <B>optional</B><A name="astInterface.1:kinds.2:optional.3(388)"></A><A name="optional.3(388)"></A>: (#  exit 3 #);
          <B>nameAppl</B><A name="astInterface.1:kinds.2:nameAppl.3(389)"></A><A name="nameAppl.3(389)"></A>: (#  exit 4 #);
          <B>nameDecl</B><A name="astInterface.1:kinds.2:nameDecl.3(390)"></A><A name="nameDecl.3(390)"></A>: (#  exit 5 #);
          <B>string</B><A name="astInterface.1:kinds.2:string.3(391)"></A><A name="string.3(391)"></A>: (#  exit 6 #);
          <B>const</B><A name="astInterface.1:kinds.2:const.3(392)"></A><A name="const.3(392)"></A>: (#  exit 7 #);
          <B>comment</B><A name="astInterface.1:kinds.2:comment.3(393)"></A><A name="comment.3(393)"></A>: (#  exit 8 #);
          <B>slotDesc</B><A name="astInterface.1:kinds.2:slotDesc.3(394)"></A><A name="slotDesc.3(394)"></A>: (#  exit 9 #);
          <B>list</B><A name="astInterface.1:kinds.2:list.3(395)"></A><A name="list.3(395)"></A>: (* this will only be returned by 'nodeClass' *)
            (#  exit 117 #);
          <B>cons</B><A name="astInterface.1:kinds.2:cons.3(396)"></A><A name="cons.3(396)"></A>: (* this will only be returned by 'nodeClass' *)
            (#  exit 118 #);
          <B>dummy</B><A name="astInterface.1:kinds.2:dummy.3(397)"></A><A name="dummy.3(397)"></A>: (* temporary declaration. Is never returned *)
            (#  exit - 317 #)
       #);
     <B>prodNo</B><A name="astInterface.1:prodNo.2(398)"></A><A name="prodNo.2(398)"></A>: @
       (# <B>unExpanded</B><A name="astInterface.1:prodNo.2:unExpanded.3(399)"></A><A name="unExpanded.3(399)"></A>: (#  exit - 1 #);
          <B>optional</B><A name="astInterface.1:prodNo.2:optional.3(400)"></A><A name="optional.3(400)"></A>: (#  exit - 2 #);
          <B>nameAppl</B><A name="astInterface.1:prodNo.2:nameAppl.3(401)"></A><A name="nameAppl.3(401)"></A>: (#  exit - 3 #);
          <B>nameDecl</B><A name="astInterface.1:prodNo.2:nameDecl.3(402)"></A><A name="nameDecl.3(402)"></A>: (#  exit - 4 #);
          <B>const</B><A name="astInterface.1:prodNo.2:const.3(403)"></A><A name="const.3(403)"></A>: (#  exit - 5 #);
          <B>string</B><A name="astInterface.1:prodNo.2:string.3(404)"></A><A name="string.3(404)"></A>: (#  exit - 6 #);
          <B>comment</B><A name="astInterface.1:prodNo.2:comment.3(405)"></A><A name="comment.3(405)"></A>: (#  exit - 7 #);
          <B>slotDesc</B><A name="astInterface.1:prodNo.2:slotDesc.3(406)"></A><A name="slotDesc.3(406)"></A>: (#  exit - 8 #)
       #);
     <B>CommentSeparator1</B><A name="astInterface.1:CommentSeparator1.2(407)"></A><A name="CommentSeparator1.2(407)"></A>: (#  exit 1 #);
     (* Separation of comments *)
     <B>CommentSeparator2</B><A name="astInterface.1:CommentSeparator2.2(408)"></A><A name="CommentSeparator2.2(408)"></A>: (#  exit 2 #);
     (* Separation of comments in same son *)
     <B>CommentSeparator3</B><A name="astInterface.1:CommentSeparator3.2(409)"></A><A name="CommentSeparator3.2(409)"></A>: (#  exit 3 #);
     (* Separation of comments in properties *)
     <B>CommentSieve</B><A name="astInterface.1:CommentSieve.2(410)"></A><A name="CommentSieve.2(410)"></A>: [256] @Char;
     <B>printComment</B><A name="astInterface.1:printComment.2(411)"></A><A name="printComment.2(411)"></A>:
       (# <B>comment</B><A name="astInterface.1:printComment.2:comment.3(412)"></A><A name="comment.3(412)"></A>: ^Text; <B>output</B><A name="astInterface.1:printComment.2:output.3(413)"></A><A name="output.3(413)"></A>: ^Stream;
       enter (comment[],output[])
          ...
       #);
     <B>undefinedGrammarName</B><A name="astInterface.1:undefinedGrammarName.2(414)"></A><A name="undefinedGrammarName.2(414)"></A>:
       (* describes unknown grammars *) (#  exit '????' #);
     <B>undefinedVersion</B><A name="astInterface.1:undefinedVersion.2(415)"></A><A name="undefinedVersion.2(415)"></A>: (* describes unknown versions of grammars *)
       (#  exit - 1 #);
     <B>grammarTable</B><A name="astInterface.1:grammarTable.2(416)"></A><A name="grammarTable.2(416)"></A>: @
       (# <B>BETA</B><A name="astInterface.1:grammarTable.2:BETA.3(417)"></A><A name="BETA.3(417)"></A>,<B>propertyGrammar</B><A name="astInterface.1:grammarTable.2:propertyGrammar.3(418)"></A><A name="propertyGrammar.3(418)"></A>,<B>meta</B><A name="astInterface.1:grammarTable.2:meta.3(419)"></A><A name="meta.3(419)"></A>,<B>pretty</B><A name="astInterface.1:grammarTable.2:pretty.3(420)"></A><A name="pretty.3(420)"></A>:
            (* some different grammars, which might by instantiated by the
             * application
             *) ^treeLevel;
          <B>noOfKnownGrammars</B><A name="astInterface.1:grammarTable.2:noOfKnownGrammars.3(421)"></A><A name="noOfKnownGrammars.3(421)"></A>: @integer;
          <B>scan</B><A name="astInterface.1:grammarTable.2:scan.3(422)"></A><A name="scan.3(422)"></A>:
            (# <B>current</B><A name="astInterface.1:grammarTable.2:scan.3:current.4(423)"></A><A name="current.4(423)"></A>: ^treeLevel;
               <B>currentName</B><A name="astInterface.1:grammarTable.2:scan.3:currentName.4(424)"></A><A name="currentName.4(424)"></A>,<B> currentExtension</B><A name="astInterface.1:grammarTable.2:scan.3:currentExtension.4(425)"></A><A name="currentExtension.4(425)"></A>,<B> currentPath</B><A name="astInterface.1:grammarTable.2:scan.3:currentPath.4(426)"></A><A name="currentPath.4(426)"></A>: ^text
              ...
            #);
          <B>scanExtensions</B><A name="astInterface.1:grammarTable.2:scanExtensions.3(427)"></A><A name="scanExtensions.3(427)"></A>:
            (# <B>currentExtension</B><A name="astInterface.1:grammarTable.2:scanExtensions.3:currentExtension.4(428)"></A><A name="currentExtension.4(428)"></A>: ^text
              ...
            #);
          <B>legalExtension</B><A name="astInterface.1:grammarTable.2:legalExtension.3(429)"></A><A name="legalExtension.3(429)"></A>: booleanValue
            (# <B>ext</B><A name="astInterface.1:grammarTable.2:legalExtension.3:ext.4(430)"></A><A name="ext.4(430)"></A>: ^text
            enter ext[]
            ...
            #);
          <B>find</B><A name="astInterface.1:grammarTable.2:find.3(431)"></A><A name="find.3(431)"></A>:
            (# <B>grammarName</B><A name="astInterface.1:grammarTable.2:find.3:grammarName.4(432)"></A><A name="grammarName.4(432)"></A>: ^text;
               <B>error</B><A name="astInterface.1:grammarTable.2:find.3:error.4(433)"></A><A name="error.4(433)"></A>: ^stream;
               <B>ifNotFound</B><A name="astInterface.1:grammarTable.2:find.3:ifNotFound.4(434)"></A><A name="ifNotFound.4(434)"></A>:&lt; astInterfaceException
                 (* exception called if grammar not found *)
                 (# ... #);
               <B>noParserAvailable</B><A name="astInterface.1:grammarTable.2:find.3:noParserAvailable.4(435)"></A><A name="noParserAvailable.4(435)"></A>:&lt; astInterfaceNotification
                 (* notification invoked if no parser is available
                  * for this grammar
                  *)
                 (# ... #);
               <B>accessError</B><A name="astInterface.1:grammarTable.2:find.3:accessError.4(436)"></A><A name="accessError.4(436)"></A>:&lt; astInterfaceException
                 (* invoked if any access error occurs during the
                  * search of grammars
                  *);
               <B>MPSerror</B><A name="astInterface.1:grammarTable.2:find.3:MPSerror.4(437)"></A><A name="MPSerror.4(437)"></A>:&lt; astInterfaceException
                 (* invoked if any MPS error occurs during the
                  * opening of grammars
                  *);
               <B>startParsing</B><A name="astInterface.1:grammarTable.2:find.3:startParsing.4(438)"></A><A name="startParsing.4(438)"></A>:&lt;
                 (* invoked if parsing is done during the opening of
                  * grammars
                  *)
                 (# do INNER #);
               <B>inx</B><A name="astInterface.1:grammarTable.2:find.3:inx.4(439)"></A><A name="inx.4(439)"></A>: @integer;
               <B>thename</B><A name="astInterface.1:grammarTable.2:find.3:thename.4(440)"></A><A name="thename.4(440)"></A>: @text;
               <B>treelevelGrammarTableFindCatcher</B><A name="astInterface.1:grammarTable.2:find.3:treelevelGrammarTableFindCatcher.4(441)"></A><A name="treelevelGrammarTableFindCatcher.4(441)"></A>: (* Private *) @handler
                 (# ... #)
            enter (grammarName[],error[])
            do ...
            exit table[inx].gram[]
            #);
          <B>element</B><A name="astInterface.1:grammarTable.2:element.3(442)"></A><A name="element.3(442)"></A>: (# <B>name</B><A name="astInterface.1:grammarTable.2:element.3:name.4(443)"></A><A name="name.4(443)"></A>,<B> extension</B><A name="astInterface.1:grammarTable.2:element.3:extension.4(444)"></A><A name="extension.4(444)"></A>,<B> path</B><A name="astInterface.1:grammarTable.2:element.3:path.4(445)"></A><A name="path.4(445)"></A>: ^text; <B>gram</B><A name="astInterface.1:grammarTable.2:element.3:gram.4(446)"></A><A name="gram.4(446)"></A>: ^treelevel #);
          <B>table</B><A name="astInterface.1:grammarTable.2:table.3(447)"></A><A name="table.3(447)"></A>: [0] (* Private *) ^element;
          <B>tableCheck</B><A name="astInterface.1:grammarTable.2:tableCheck.3(448)"></A><A name="tableCheck.3(448)"></A>: (* private *)
            ...;
          <B>insert</B><A name="astInterface.1:grammarTable.2:insert.3(449)"></A><A name="insert.3(449)"></A>: (* Private *)
            (# <B>theGrammar</B><A name="astInterface.1:grammarTable.2:insert.3:theGrammar.4(450)"></A><A name="theGrammar.4(450)"></A>: ^treeLevel
            enter theGrammar[]
               ...
            #);
          <B>insertMetagrammar</B><A name="astInterface.1:grammarTable.2:insertMetagrammar.3(451)"></A><A name="insertMetagrammar.3(451)"></A>:
            (* Private: an instance of metaGrammar must be inserted into
             * grammarTable before any usages of grammarTable
             *)
            (# <B>location</B><A name="astInterface.1:grammarTable.2:insertMetagrammar.3:location.4(452)"></A><A name="location.4(452)"></A>: ^text
            enter (meta[],location[])
               ...
            #)
       #);
     <B>registerGrammar</B><A name="astInterface.1:registerGrammar.2(453)"></A><A name="registerGrammar.2(453)"></A>:
     (# <B>name</B><A name="astInterface.1:registerGrammar.2:name.3(454)"></A><A name="name.3(454)"></A>,<B> ext</B><A name="astInterface.1:registerGrammar.2:ext.3(455)"></A><A name="ext.3(455)"></A>,<B> path</B><A name="astInterface.1:registerGrammar.2:path.3(456)"></A><A name="path.3(456)"></A>: ^text; <B>inx</B><A name="astInterface.1:registerGrammar.2:inx.3(457)"></A><A name="inx.3(457)"></A>: @integer;
     enter (name[], ext[], path[])
     ...
     #);
     <B>grammarFinder</B><A name="astInterface.1:grammarFinder.2(458)"></A><A name="grammarFinder.2(458)"></A>:
       (* create subpatterns of this pattern to implement your strategy for
        * looking-up grammars.  The fragment: findGrammar.bet contains such a
        * subpattern, implementing the standard look-up method used in the
        * Mjolner BETA System
        *)
       (# <B>grammar</B><A name="astInterface.1:grammarFinder.2:grammar.3(459)"></A><A name="grammar.3(459)"></A>: ^text;
          <B>error</B><A name="astInterface.1:grammarFinder.2:error.3(460)"></A><A name="error.3(460)"></A>: ^stream;
          <B>installed</B><A name="astInterface.1:grammarFinder.2:installed.3(461)"></A><A name="installed.3(461)"></A>: @boolean;
          <B>noRegisteredGrammars</B><A name="astInterface.1:grammarFinder.2:noRegisteredGrammars.3(462)"></A><A name="noRegisteredGrammars.3(462)"></A>:&lt; astInterfaceException
            (* invoked if no grammars have been registered.  If
             * grammars are registered during this exception, and
             * control is returned to grammarFinder, the registered
             * grammars will be used.
             *)
            (# ... #);
          <B>registerGrammars</B><A name="astInterface.1:grammarFinder.2:registerGrammars.3(463)"></A><A name="registerGrammars.3(463)"></A>:&lt; (* invoked to register the grammars *)
            (# error: ^stream;
            enter error[]
               ...
            #);
          <B>registeredGrammars</B><A name="astInterface.1:grammarFinder.2:registeredGrammars.3(464)"></A><A name="registeredGrammars.3(464)"></A>:&lt;
            (* may return a fragmentGroup containing the registered grammars *)
            (# grammarsGroup: ^fragmentGroup
            do INNER
            exit grammarsGroup[]
            #);
       enter (grammar[],error[])
            (* here the look-up for a grammar should takes place.  Either by
             * looking somehow amoung the previously registered grammars, or by
             * using some dynamic grammar look-up method
             *)
          ...
       exit installed
            (* true if new grammar installed in grammarTable *)
       #);
     <B>defaultGrammarFinder</B><A name="astInterface.1:defaultGrammarFinder.2(465)"></A><A name="defaultGrammarFinder.2(465)"></A>:&lt;
       (* default grammarFinder installed by astLevelInit *) grammarFinder;
     <B>grammarMissing</B><A name="astInterface.1:grammarMissing.2(466)"></A><A name="grammarMissing.2(466)"></A>:
       (* called when a grammar is missing.
        * grammarMissing.registerGrammars is invoked in astLevelInit
        *) ^grammarFinder;
     <B>thePathHandler</B><A name="astInterface.1:thePathHandler.2(467)"></A><A name="thePathHandler.2(467)"></A>: @fileNameConverter;
     <B>stripPathName</B><A name="astInterface.1:stripPathName.2(468)"></A><A name="stripPathName.2(468)"></A>:
       (* Strips last filename from a path specification in order to
        * conform with the new pathHandler.
        *)
       (# <B>PN</B><A name="astInterface.1:stripPathName.2:PN.3(469)"></A><A name="PN.3(469)"></A>,<B>newPN</B><A name="astInterface.1:stripPathName.2:newPN.3(470)"></A><A name="newPN.3(470)"></A>: ^text; <B>ix</B><A name="astInterface.1:stripPathName.2:ix.3(471)"></A><A name="ix.3(471)"></A>: @integer;
       enter PN[]
       do directoryChar-&gt;PN.findAll(#  do inx-&gt;ix #);
          (if ix=0 then
              none -&gt;newPN[]
           else
              (* terminating directoryChar is not removed due to 'strange'
               * behavior in localPath
               *)
              (1,ix)-&gt;PN.sub-&gt;newPN[]
          if)
       exit newPN[]
       #);
     <B>expandToFullPath</B><A name="astInterface.1:expandToFullPath.2(472)"></A><A name="expandToFullPath.2(472)"></A>:
       (# <B>name</B><A name="astInterface.1:expandToFullPath.2:name.3(473)"></A><A name="name.3(473)"></A>: ^text;
       enter name[]
       exit
            (name[],currentDirectory)-&gt;thePathHandler.convertFilePath
       #);
     <B>offendingFormName</B><A name="astInterface.1:offendingFormName.2(474)"></A><A name="offendingFormName.2(474)"></A>:
       (* set in case of a doubleDeclaration in fragmentForm names *) ^text;
     <B>trace</B><A name="astInterface.1:trace.2(475)"></A><A name="trace.2(475)"></A>: @
       (* different tracing possibilities. I.e. to trace open of
        * fragments use
        *      (trace.fragmentOpen,true) -&gt; trace.set;
        * To activate tracing through the BETA compiler,
        * set compileroption=number given here+400
        * (e.g. "beta -s 490 ..." to activate trace of slot bindings).
        * The trace will be delivered on the stream trace.str.  This may be
        * set by e.g.:
        *      traceFile[] -&gt; trace.output;
        * By default, trace is delivered on screen.
        *)
       (# <B>fragmentOpen</B><A name="astInterface.1:trace.2:fragmentOpen.3(476)"></A><A name="fragmentOpen.3(476)"></A>: (#  exit 1 #);
          <B>onParse</B><A name="astInterface.1:trace.2:onParse.3(477)"></A><A name="onParse.3(477)"></A>: (#  exit 2 #);
          <B>topOpen</B><A name="astInterface.1:trace.2:topOpen.3(478)"></A><A name="topOpen.3(478)"></A>: (#  exit 3 #);
          <B>fragmentClose</B><A name="astInterface.1:trace.2:fragmentClose.3(479)"></A><A name="fragmentClose.3(479)"></A>: (#  exit 4 #);
          <B>topClose</B><A name="astInterface.1:trace.2:topClose.3(480)"></A><A name="topClose.3(480)"></A>: (#  exit 4 #);
          <B>compactOpen</B><A name="astInterface.1:trace.2:compactOpen.3(481)"></A><A name="compactOpen.3(481)"></A>: (#  exit 10 #);
          <B>grammars</B><A name="astInterface.1:trace.2:grammars.3(482)"></A><A name="grammars.3(482)"></A>: (#  exit 20 #);
          <B>parsingComments</B><A name="astInterface.1:trace.2:parsingComments.3(483)"></A><A name="parsingComments.3(483)"></A>: (#  exit 30 #);
          <B>getnextComment</B><A name="astInterface.1:trace.2:getnextComment.3(484)"></A><A name="getnextComment.3(484)"></A>: (#  exit 31 #);
          <B>editingComments</B><A name="astInterface.1:trace.2:editingComments.3(485)"></A><A name="editingComments.3(485)"></A>: (#  exit 32 #);
          <B>parser</B><A name="astInterface.1:trace.2:parser.3(486)"></A><A name="parser.3(486)"></A>: (#  exit 50 #);
          <B>getBinding</B><A name="astInterface.1:trace.2:getBinding.3(487)"></A><A name="getBinding.3(487)"></A>: (#  exit 90 #);
          <B>getBindingMark</B><A name="astInterface.1:trace.2:getBindingMark.3(488)"></A><A name="getBindingMark.3(488)"></A>: (#  exit 91 #);
          <B>set</B><A name="astInterface.1:trace.2:set.3(489)"></A><A name="set.3(489)"></A>: (* call this to trace something in the astInterface *)
            (# no: @integer; on: @boolean;
            enter (no,on)
            ...
            #);
          <B>output</B><A name="astInterface.1:trace.2:output.3(490)"></A><A name="output.3(490)"></A>:
            (# str: ^stream
            enter str[]
            ...
            #);
          <B>active</B><A name="astInterface.1:trace.2:active.3(491)"></A><A name="active.3(491)"></A>: (* true iff any trace options are set *) @boolean;
          <B>d</B><A name="astInterface.1:trace.2:d.3(492)"></A><A name="d.3(492)"></A>: (* Private *) [100] @boolean;
          <B>private</B><A name="astInterface.1:trace.2:private.3(493)"></A><A name="private.3(493)"></A>: @...
       #);
     <B>options</B><A name="astInterface.1:options.2(494)"></A><A name="options.2(494)"></A>: @
       (* different options available.  I.e. to set these options use
        *       true -&gt; options.forceParse
        * and to test whether these options are set, use
        *      (if options.forceParse ... if)
        *)
       (# <B>forceParse</B><A name="astInterface.1:options.2:forceParse.3(495)"></A><A name="forceParse.3(495)"></A>: (#  enter option[1] exit option[1] #);
          <B>option</B><A name="astInterface.1:options.2:option.3(496)"></A><A name="option.3(496)"></A>: (* Private *) [10] @boolean
       #);
     <B>astInterfaceNotification</B><A name="astInterface.1:astInterfaceNotification.2(497)"></A><A name="astInterfaceNotification.2(497)"></A>:
       notification
       (# <B>m</B><A name="astInterface.1:astInterfaceNotification.2:m.3(498)"></A><A name="m.3(498)"></A>: ^text
       enter m[]
          ...
       #);
     <B>astInterfaceException</B><A name="astInterface.1:astInterfaceException.2(499)"></A><A name="astInterfaceException.2(499)"></A>: exception
       (# <B>m</B><A name="astInterface.1:astInterfaceException.2:m.3(500)"></A><A name="m.3(500)"></A>: ^text
       enter m[]
          ...
       #);
     <B>astInterfaceError</B><A name="astInterface.1:astInterfaceError.2(501)"></A><A name="astInterfaceError.2(501)"></A>:&lt; astInterfaceException;
     <B>protect</B><A name="astInterface.1:protect.2(502)"></A><A name="protect.2(502)"></A>:
       (* This operation is used to protect a MPS operation (or
        * sequence of MPS operations agains the dynamically generated
        * MPS exceptions.
        *)
       (# <B>astOverflow</B><A name="astInterface.1:protect.2:astOverflow.3(503)"></A><A name="astOverflow.3(503)"></A>:&lt; astInterfaceException;
          <B>startingParsing</B><A name="astInterface.1:protect.2:startingParsing.3(504)"></A><A name="startingParsing.3(504)"></A>:&lt; (# do INNER #);
          <B>fragmentNotExisting</B><A name="astInterface.1:protect.2:fragmentNotExisting.3(505)"></A><A name="fragmentNotExisting.3(505)"></A>:&lt; astInterfaceException
            (# do true-&gt;continue; INNER #);
          <B>grammarNotFound</B><A name="astInterface.1:protect.2:grammarNotFound.3(506)"></A><A name="grammarNotFound.3(506)"></A>:&lt; astInterfaceException;
          <B>badFormat</B><A name="astInterface.1:protect.2:badFormat.3(507)"></A><A name="badFormat.3(507)"></A>:&lt; astInterfaceException;
          <B>parseErrors</B><A name="astInterface.1:protect.2:parseErrors.3(508)"></A><A name="parseErrors.3(508)"></A>:&lt; astInterfaceException;
          <B>fatalParseError</B><A name="astInterface.1:protect.2:fatalParseError.3(509)"></A><A name="fatalParseError.3(509)"></A>:&lt; astInterfaceException
            (# errNo: @integer enter errNo do INNER #);
          <B>doubleFormDeclaration</B><A name="astInterface.1:protect.2:doubleFormDeclaration.3(510)"></A><A name="doubleFormDeclaration.3(510)"></A>:&lt; astInterfaceException;
          <B>readAccessError</B><A name="astInterface.1:protect.2:readAccessError.3(511)"></A><A name="readAccessError.3(511)"></A>:&lt; astInterfaceException;
          <B>writeAccessError</B><A name="astInterface.1:protect.2:writeAccessError.3(512)"></A><A name="writeAccessError.3(512)"></A>:&lt; astInterfaceException;
          <B>writeAccessOnLstFileError</B><A name="astInterface.1:protect.2:writeAccessOnLstFileError.3(513)"></A><A name="writeAccessOnLstFileError.3(513)"></A>:&lt; astInterfaceException;
          <B>EOSError</B><A name="astInterface.1:protect.2:EOSError.3(514)"></A><A name="EOSError.3(514)"></A>:&lt; astInterfaceException;
          <B>noSuchFileError</B><A name="astInterface.1:protect.2:noSuchFileError.3(515)"></A><A name="noSuchFileError.3(515)"></A>:&lt; astInterfaceException;
          <B>fileExistsError</B><A name="astInterface.1:protect.2:fileExistsError.3(516)"></A><A name="fileExistsError.3(516)"></A>:&lt; astInterfaceException;
          <B>noSpaceLeftError</B><A name="astInterface.1:protect.2:noSpaceLeftError.3(517)"></A><A name="noSpaceLeftError.3(517)"></A>:&lt; astInterfaceException;
          <B>otherFileError</B><A name="astInterface.1:protect.2:otherFileError.3(518)"></A><A name="otherFileError.3(518)"></A>:&lt; astInterfaceException;
          <B>protectCatcher</B><A name="astInterface.1:protect.2:protectCatcher.3(519)"></A><A name="protectCatcher.3(519)"></A>: @handler (* Private *)
            (# ... #)
       ...
       #);
     <B>astLevelInit</B><A name="astInterface.1:astLevelInit.2(520)"></A><A name="astLevelInit.2(520)"></A>:
       (#
       do ...
       #);
     (********** PRIVATE PART *********************)
     <B>private</B><A name="astInterface.1:private.2(521)"></A><A name="private.2(521)"></A>: @...;
     <B>parseErrorsLst</B><A name="astInterface.1:parseErrorsLst.2(522)"></A><A name="parseErrorsLst.2(522)"></A>: ^text; (* if during, the last parsing, there was
                             * parse errors, and no '.lst' file could
                             * be written, then this will contain the
                             * information otherwise found in the
                             * '.lst' file
                             *)
     (*      referenceGenerator: {* Private *}
      *        (# as: ^ast do INNER exit as[] #);
      *      genUnExpanded: {* Private *} @referenceGenerator
      *        (#  do &amp;unExpanded[]-&gt;as[] #);
      *      genOptional: {* Private *} @referenceGenerator
      *        (#  do &amp;optional[]-&gt;as[] #);
      * 
      *)
       <B>offset</B><A name="astInterface.1:offset.2(523)"></A><A name="offset.2(523)"></A>: @
       (* Private: the following constants are private constants to ast, which
        * tells where in array A relative from 'index' different information
        * can be found
        *)
       (# <B>attribute</B><A name="astInterface.1:offset.2:attribute.3(524)"></A><A name="attribute.3(524)"></A>: (#  exit 2 #);
          <B>slotUsage</B><A name="astInterface.1:offset.2:slotUsage.3(525)"></A><A name="slotUsage.3(525)"></A>: (#  exit 2 #);
          <B>slotAttribute</B><A name="astInterface.1:offset.2:slotAttribute.3(526)"></A><A name="slotAttribute.3(526)"></A>: (#  exit 3 #);
          <B>commentType</B><A name="astInterface.1:offset.2:commentType.3(527)"></A><A name="commentType.3(527)"></A>: (#  exit 2 #);
          <B>sizePerNode</B><A name="astInterface.1:offset.2:sizePerNode.3(528)"></A><A name="sizePerNode.3(528)"></A>:
            (* tells how many entries in A is needed per node (not including
             * extra attributes)
             *) (#  exit 2 #);
          <B>sizePerUnExpanded</B><A name="astInterface.1:offset.2:sizePerUnExpanded.3(529)"></A><A name="sizePerUnExpanded.3(529)"></A>: (#  exit 2 #);
          <B>sizePerNameAppl</B><A name="astInterface.1:offset.2:sizePerNameAppl.3(530)"></A><A name="sizePerNameAppl.3(530)"></A>: (#  exit 2 #);
          <B>sizePerNameDecl</B><A name="astInterface.1:offset.2:sizePerNameDecl.3(531)"></A><A name="sizePerNameDecl.3(531)"></A>: (* must be equal to sizePerNameAppl *)
            (#  exit 2 #);
          <B>sizePerString</B><A name="astInterface.1:offset.2:sizePerString.3(532)"></A><A name="sizePerString.3(532)"></A>: (#  exit 2 #);
          <B>sizePerConst</B><A name="astInterface.1:offset.2:sizePerConst.3(533)"></A><A name="sizePerConst.3(533)"></A>: (#  exit 4 #);
          <B>sizePerComment</B><A name="astInterface.1:offset.2:sizePerComment.3(534)"></A><A name="sizePerComment.3(534)"></A>: (#  exit 4 #);
          <B>sizePerSlotDesc</B><A name="astInterface.1:offset.2:sizePerSlotDesc.3(535)"></A><A name="sizePerSlotDesc.3(535)"></A>: (#  exit 12 #);
       #);
     <B>groupBlackNumber</B><A name="astInterface.1:groupBlackNumber.2(536)"></A><A name="groupBlackNumber.2(536)"></A>: (* Private *)
       (* magic number. To be used to recognize group-files *)
       (#  exit 131453937 #);
     <B>errorNumbers</B><A name="astInterface.1:errorNumbers.2(537)"></A><A name="errorNumbers.2(537)"></A>: @ (* Private *)
       (#  <B>noReadAccess</B><A name="astInterface.1:errorNumbers.2:noReadAccess.3(538)"></A><A name="noReadAccess.3(538)"></A>: (#  exit 1 #);
          <B>noWriteAccess</B><A name="astInterface.1:errorNumbers.2:noWriteAccess.3(539)"></A><A name="noWriteAccess.3(539)"></A>: (#  exit 2 #);
          <B>notExisting</B><A name="astInterface.1:errorNumbers.2:notExisting.3(540)"></A><A name="notExisting.3(540)"></A>: (#  exit 3 #);
          <B>badFormat</B><A name="astInterface.1:errorNumbers.2:badFormat.3(541)"></A><A name="badFormat.3(541)"></A>: (#  exit 4 #);
          <B>parseErrors</B><A name="astInterface.1:errorNumbers.2:parseErrors.3(542)"></A><A name="parseErrors.3(542)"></A>: (#  exit 5 #);
          <B>grammarNotFound</B><A name="astInterface.1:errorNumbers.2:grammarNotFound.3(543)"></A><A name="grammarNotFound.3(543)"></A>: (#  exit 6 #);
          <B>arrayTooBig</B><A name="astInterface.1:errorNumbers.2:arrayTooBig.3(544)"></A><A name="arrayTooBig.3(544)"></A>: (#  exit 7 #);
          <B>noSpaceLeft</B><A name="astInterface.1:errorNumbers.2:noSpaceLeft.3(545)"></A><A name="noSpaceLeft.3(545)"></A>: (#  exit 8 #);
          <B>writeAccessOnLstFileError</B><A name="astInterface.1:errorNumbers.2:writeAccessOnLstFileError.3(546)"></A><A name="writeAccessOnLstFileError.3(546)"></A>: (#  exit 9 #);
          <B>doubleFormDeclaration</B><A name="astInterface.1:errorNumbers.2:doubleFormDeclaration.3(547)"></A><A name="doubleFormDeclaration.3(547)"></A>: (#  exit 10 #);
          <B>EOSError</B><A name="astInterface.1:errorNumbers.2:EOSError.3(548)"></A><A name="EOSError.3(548)"></A>: (#  exit 14 #);
          <B>noSuchFile</B><A name="astInterface.1:errorNumbers.2:noSuchFile.3(549)"></A><A name="noSuchFile.3(549)"></A>: (#  exit 15 #);
          <B>fileExists</B><A name="astInterface.1:errorNumbers.2:fileExists.3(550)"></A><A name="fileExists.3(550)"></A>: (#  exit 16 #);
          <B>otherFileError</B><A name="astInterface.1:errorNumbers.2:otherFileError.3(551)"></A><A name="otherFileError.3(551)"></A>: (#  exit 18 #);
          <B>fatalParseError</B><A name="astInterface.1:errorNumbers.2:fatalParseError.3(552)"></A><A name="fatalParseError.3(552)"></A>:
            (* The error numbers between 101 and 199 are exclusively allocated
             * for BOBS fatal parse error numbers.  The original BOBS error
             * number is this (no-100):
             *) (# no: @integer enter no exit (100 &lt; no) and (no &lt; 200) #);
       #);
     <B>notificationNumbers</B><A name="astInterface.1:notificationNumbers.2(553)"></A><A name="notificationNumbers.2(553)"></A>: @ (* Private *)
       (# <B>startingParsing</B><A name="astInterface.1:notificationNumbers.2:startingParsing.3(554)"></A><A name="startingParsing.3(554)"></A>: (#  exit 201 #);
          <B>noParserAvailable</B><A name="astInterface.1:notificationNumbers.2:noParserAvailable.3(555)"></A><A name="noParserAvailable.3(555)"></A>: (#  exit 202 #)
       #);
     <B>handler</B><A name="astInterface.1:handler.2(556)"></A><A name="handler.2(556)"></A>: (* Private *)
       (# <B>no</B><A name="astInterface.1:handler.2:no.3(557)"></A><A name="no.3(557)"></A>: @integer; <B>msg</B><A name="astInterface.1:handler.2:msg.3(558)"></A><A name="msg.3(558)"></A>: ^text; <B>oldCatcher</B><A name="astInterface.1:handler.2:oldCatcher.3(559)"></A><A name="oldCatcher.3(559)"></A>: ^handler enter (no,msg[]) do INNER #);
     <B>theCatcher</B><A name="astInterface.1:theCatcher.2(560)"></A><A name="theCatcher.2(560)"></A>: ^handler (* Private *) ;
     <B>maxdepth</B><A name="astInterface.1:maxdepth.2(561)"></A><A name="maxdepth.2(561)"></A>: (* Private: maximal elements in a stack *) (#  exit 50 #);
     <B>stak</B><A name="astInterface.1:stak.2(562)"></A><A name="stak.2(562)"></A>: (* Private *)
       (# <B>stakOverflowException</B><A name="astInterface.1:stak.2:stakOverflowException.3(563)"></A><A name="stakOverflowException.3(563)"></A>: astInterfaceException
            (#  do INNER ; 'error: stack overrun'-&gt;msg.putline #);
          <B>a</B><A name="astInterface.1:stak.2:a.3(564)"></A><A name="a.3(564)"></A>: [maxdepth] @integer;
          <B>topindex</B><A name="astInterface.1:stak.2:topindex.3(565)"></A><A name="topindex.3(565)"></A>: @integer;
          <B>init</B><A name="astInterface.1:stak.2:init.3(566)"></A><A name="init.3(566)"></A>: (#  do 0-&gt;topindex #);
          <B>push</B><A name="astInterface.1:stak.2:push.3(567)"></A><A name="push.3(567)"></A>:
            (# e: @integer
            enter e
            do (if topIndex=maxDepth then stakOverflowException if);
               e-&gt;a[topindex+1-&gt;topindex]
            #);
          <B>pop</B><A name="astInterface.1:stak.2:pop.3(568)"></A><A name="pop.3(568)"></A>:
            (# e: @integer;
            do a[topindex]-&gt;e; topindex-1-&gt;topIndex;
            exit e
            #);
          <B>empty</B><A name="astInterface.1:stak.2:empty.3(569)"></A><A name="empty.3(569)"></A>: (#  exit (topindex = 0) #);
       #);
     (* The following category defines some constants used as values for super
      * attributes in metagrammar-ast's
      *)
     <B>super</B><A name="astInterface.1:super.2(570)"></A><A name="super.2(570)"></A>: @ (* Private *)
       (# <B>undefined</B><A name="astInterface.1:super.2:undefined.3(571)"></A><A name="undefined.3(571)"></A>: (#  exit - 10 #);
          <B>cons</B><A name="astInterface.1:super.2:cons.3(572)"></A><A name="cons.3(572)"></A>: (#  exit - 11 #);
          <B>list</B><A name="astInterface.1:super.2:list.3(573)"></A><A name="list.3(573)"></A>: (#  exit 99999 #)
       #);
     <B>tracer</B><A name="astInterface.1:tracer.2(574)"></A><A name="tracer.2(574)"></A>: (* Private *)
       (# <B>traceNo</B><A name="astInterface.1:tracer.2:traceNo.3(575)"></A><A name="traceNo.3(575)"></A>: @integer; <B>dmp</B><A name="astInterface.1:tracer.2:dmp.3(576)"></A><A name="dmp.3(576)"></A>: ^stream
       enter traceNo
       ...
       #);
     <B>repS</B><A name="astInterface.1:repS.2(577)"></A><A name="repS.2(577)"></A>: (* Private *) ^repetitionStream;
     <B>doRealOpen</B><A name="astInterface.1:doRealOpen.2(578)"></A><A name="doRealOpen.2(578)"></A>:
       (* Private: if this boolean is false, unpack of fragments will only
        * read in part of the fragment description.  Should only be used by the
        * BETA compiler
        *) @boolean;
     <B>useModificationStatus</B><A name="astInterface.1:useModificationStatus.2(579)"></A><A name="useModificationStatus.2(579)"></A>: (* Private *) @boolean;
  do astLevelInit; INNER ;
  #);
<B>containerList</B><A name="containerList.1(580)"></A>: list
  (* Private: Empty specialization of the list pattern defined in the
   * containers library.  It is only defined to circumvent name-clash between
   * the list pattern defined in containers, and the list pattern defined here
   * in astInterface.
   *) (#  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="40%" align="left"><ADDRESS>Astlevel Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
