<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Propertyparser Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="propertyparser">Propertyparser Interface</A></H1>

<PRE CLASS=interface>
ORIGIN 'astlevel';
INCLUDE '~beta/basiclib/file';
LIB_ITEM 'mpsastlevel';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1986-93
 *       All rights reserved.
 *)
-- fragmentgrouplib: Attributes --
<B>propertyParser</B><A name="propertyParser.1(951)"></A>: (* for parsing a property specification *)
(* Recursive-descend parser for the grammar:
 * 
 *   &lt;group&gt; ::= &lt;propertyList&gt;;
 *   &lt;propertyList&gt; ::= &lt;property&gt; {';' property}* ;
 *   &lt;property&gt; ::| &lt;predefined property&gt;
 *                | &lt;auxilary property&gt; ;
 *   &lt;predefined property&gt; ::| &lt;origin property&gt; | &lt;include property&gt;
 *                           | &lt;body property&gt; | &lt;mdbody property&gt; ;
 *   &lt;origin property&gt;  ::= 'ORIGIN'  STRING                     ;
 *   &lt;include property&gt; ::= 'INCLUDE' STRING      {STRING}*      ;
 *   &lt;body property&gt;    ::= 'BODY'    STRING      {STRING}*      ;
 *   &lt;mdbody property&gt;  ::= 'MDBODY'  NAME STRING {NAME STRING}* ;
 *   &lt;auxilary property&gt;::= &lt;propertyName&gt; {NAME | STRING | CONST}* | EMPTY ;
 *   
 * Lexical tokens: --(-)* [[ ]] ; : NAME STRING CONST EOF
 * 
 *)
  (#
     <B>parseErrors</B><A name="propertyParser.1.parseErrors.2(952)"></A><A name="parseErrors.2(952)"></A>:&lt; (* exception called if parse-errors *)
      astInterfaceException;
     <B>doubleFormDeclaration</B><A name="propertyParser.1.doubleFormDeclaration.2(953)"></A><A name="doubleFormDeclaration.2(953)"></A>:&lt;
     (* exception called if two fragmentForms with the same name *)
      astInterfaceException;
     <B>input</B><A name="propertyParser.1.input.2(954)"></A><A name="input.2(954)"></A>: ^stream;
     <B>error</B><A name="propertyParser.1.error.2(955)"></A><A name="error.2(955)"></A>: ^stream;
     <B>ok</B><A name="propertyParser.1.ok.2(956)"></A><A name="ok.2(956)"></A>: @boolean;
     <B>dash</B><A name="propertyParser.1.dash.2(957)"></A><A name="dash.2(957)"></A>: (#  exit - 1 #);
     <B>beginGroup</B><A name="propertyParser.1.beginGroup.2(958)"></A><A name="beginGroup.2(958)"></A>: (#  exit - 2 #);
     <B>endGroup</B><A name="propertyParser.1.endGroup.2(959)"></A><A name="endGroup.2(959)"></A>: (#  exit - 3 #);
     <B>name</B><A name="propertyParser.1.name.2(960)"></A><A name="name.2(960)"></A>: (#  exit - 4 #);
     <B>string</B><A name="propertyParser.1.string.2(961)"></A><A name="string.2(961)"></A>: (#  exit - 5 #);
     <B>const</B><A name="propertyParser.1.const.2(962)"></A><A name="const.2(962)"></A>: (#  exit - 6 #);
     <B>EOF</B><A name="propertyParser.1.EOF.2(963)"></A><A name="EOF.2(963)"></A>: (#  exit - 7 #);
     <B>origin</B><A name="propertyParser.1.origin.2(964)"></A><A name="origin.2(964)"></A>: (#  exit - 8 #);
     <B>include</B><A name="propertyParser.1.include.2(965)"></A><A name="include.2(965)"></A>: (#  exit - 9 #);
     <B>body</B><A name="propertyParser.1.body.2(966)"></A><A name="body.2(966)"></A>: (#  exit - 10 #);
     <B>mdbody</B><A name="propertyParser.1.mdbody.2(967)"></A><A name="mdbody.2(967)"></A>: (#  exit - 11 #);
     <B>semiColon</B><A name="propertyParser.1.semiColon.2(968)"></A><A name="semiColon.2(968)"></A>: (#  exit ';' #);
     <B>colon</B><A name="propertyParser.1.colon.2(969)"></A><A name="colon.2(969)"></A>: (#  exit ':' #);
     <B>EOSchar</B><A name="propertyParser.1.EOSchar.2(970)"></A><A name="EOSchar.2(970)"></A>: @char;
     <B>inputPos</B><A name="propertyParser.1.inputPos.2(971)"></A><A name="inputPos.2(971)"></A>,<B>lastOKPos</B><A name="propertyParser.1.lastOKPos.2(972)"></A><A name="lastOKPos.2(972)"></A>: @integer;
     <B>firstComment</B><A name="propertyParser.1.firstComment.2(973)"></A><A name="firstComment.2(973)"></A>: @boolean;
     <B>fgComment</B><A name="propertyParser.1.fgComment.2(974)"></A><A name="fgComment.2(974)"></A>: @Text;
     <B>get</B><A name="propertyParser.1.get.2(975)"></A><A name="get.2(975)"></A>: @
       (# printError: @
            (# 
            do 'Read ascii.nul character during property parsing.\n' -&gt; screen.putText;
               'fullname is ' -&gt; screen.putText;
               fullname-&gt;screen.putline;                  
               'inputpos is ' -&gt; screen.putText;
               inputpos-&gt;screen.putint; screen.newLine;
            #);
       do (if input.eos then
              EOF-&gt;nextCh
           else
              inputPos+1-&gt;inputPos;input.get-&gt;nextCh;
              (if nextCh=0 then
                  printError;
              else
                 CommentSieve[nextCh]-&gt;nextCh;
              if)
          if)
       exit nextCh
       #);
     <B>dirWriteable</B><A name="propertyParser.1.dirWriteable.2(976)"></A><A name="dirWriteable.2(976)"></A>: @
       (# f: @file
       enter f.name
       exit f.entry.writeable
         (#
            error:: 
              (# 
              do true-&gt;continue; (errorNumbers.otherFileError,msg[])-&gt;catcher
              #)
         #)
       #);
     <B>markError</B><A name="propertyParser.1.markError.2(977)"></A><A name="markError.2(977)"></A>:
       (#
          whatToBeExpected: @text;
          errorPos,inx,noOfTerminals: @integer;
          ch: @char;
          errorReport:
            (#
               N: @integer;
               beforeText: @text;
               get: @input.get;
               eos: @input.eos;
               ch: @char;
               print,oldPrint: @boolean;
               startLineNo,lineNo: @integer;
               pos,first,beforePos: @integer;
               lst: ^stream;
               constructLegals:
                 (# symb: ^parseSymbolDescriptor; j: @integer; t: ^text
                 do &amp;parseSymbolDescriptor[]-&gt;symb[];
                    noOfTerminals-&gt;symb.terminals.new;
                    0-&gt;whatToBeExpected.pos;
                    (for i: NoOfTerminals repeat
                      whatToBeExpected.getAtom-&gt;t[]; t[]-&gt;symb.terminals[i][]; 
                    for)
                 exit symb[]
                 #);
               
            enter lst[]
            do 1-&gt;lineNo;
               THIS(fragmentGroup)[]-&gt;theErrorReporter.frag[];
               lst[]-&gt;theErrorReporter.errorStream[];
               theErrorReporter.beforeFirstError;
               1-&gt;N;
               Loop:
               (if (N &lt;= 1) then
                   print-&gt;oldPrint;
                   ((errorPos-100) &lt;= pos)-&gt;print;
                   (if print then
                       (if oldPrint then
                           (if (beforeText.length &gt; 100) then
                               startLineNo+1-&gt;startLineNo;
                               test:
                               ascii.newLine
                                 -&gt;beforeText.findAll
                                   (# 
                                   do inx+beforePos-&gt;beforePos;
                                      (1,inx)-&gt;beforeText.delete;
                                      leave test
                                   #);
                               
                           if)
                        else
                           beforeText.clear;
                           pos-&gt;beforePos;
                           lineNo-&gt;startLineNo;
                           
                       if)
                   if);
                   lineNo+1-&gt;lineNo;
                   pos-&gt;first;
                   readLine:
                     (# 
                     do pos+1-&gt;pos;
                        (if eos then leave readline if);
                        get-&gt;ch;
                        (if print then ch-&gt;beforeText.put if);
                        (if ch = ascii.newline then leave readLine if);
                        restart readLine;
                        
                     #);
                   (if print then
                       mark:
                       (if (errorPos &lt;= pos) then
                           (errorPos,startLineNo,beforeText,errorPos-beforePos,
                            constructLegals)-&gt;theErrorReporter.forEachError;
                           N+1-&gt;N;
                           
                       if);
                       
                   if);
                   restart Loop
               if);
               theErrorReporter.afterLastError;
               
            #);
          lstFile: @file
            (#
               accessError:: 
                 (# 
                 do (errorNumbers.WriteAccessOnLstFileError,msg[])-&gt;catcher
                 #)
            #);
          
       enter (whatToBeExpected,NoOfTerminals)
       do lastOKPos+1-&gt;errorPos;
          (if error[] = none then
              screen[]-&gt;error[];
              '***WARNING: error stream in markError not specified.  Using screen[] as error[]'
                -&gt;error.putline;
              
          if);
          error.newLine;
          input.reset;
          error[]-&gt;errorReport;
            (# t: ^text
            do fullName-&gt;t[]; '.lst'-&gt;(t.copy).Append-&gt;lstFile.name; 
            #);
          (if (lstFile.entry.path.head-&gt;dirWriteable) then
              (if lstFile.entry.writeable
                (#
                   error:: 
                     (# 
                     do true-&gt;continue;
                        (errorNumbers.otherFileError,msg[])-&gt;catcher
                     #)
                #) then
                  lstFile.openWrite;
                  input.reset;
                  lstFile[]-&gt;errorReport;
                  lstFile.close;
                  false-&gt;ok;
                  ''-&gt;parseErrors;
               else
                    (# t: @text
                    do 'No write access to the file: "'-&gt;t;
                       lstFile.name-&gt;t.append;
                       '"'-&gt;t.putline;
                       (errorNumbers.WriteAccessOnLstFileError,t[])-&gt;catcher
                    #)
              if)
           else
                (# t: @text
                do 'No write access to the directory: "'-&gt;t;
                   lstFile.entry.path.head-&gt;t.append;
                   '"'-&gt;t.putline;
                   (errorNumbers.WriteAccessOnLstFileError,t[])-&gt;catcher
                #)
          if);
          
       #)
       (* markError *)
       ;
     <B>currentToken</B><A name="propertyParser.1.currentToken.2(978)"></A><A name="currentToken.2(978)"></A>: @ (# val: @integer;  enter val exit val #);
     <B>advance</B><A name="propertyParser.1.advance.2(979)"></A><A name="advance.2(979)"></A>: @|
       (# 
       do get;
          cycle
            (# 
            do inputPos-&gt;lastOKPos;
               (if nextCh
                // EOSchar then
                   (if get = EOSchar then
                       loop1: (if get = EOSchar then restart loop1 if);
                       dash-&gt;currentToken;
                       SUSPEND;
                       
                    else
                       EOSchar-&gt;currentToken; SUSPEND; 
                   if);
                   
                // '[' then
                   (if get = '[' then
                       beginGroup-&gt;currentToken; SUSPEND; get
                    else
                       '['-&gt;currentToken; SUSPEND
                   if);
                   
                // ']' then
                   (if get = ']' then
                       endGroup-&gt;currentToken; SUSPEND; get
                    else
                       ']'-&gt;currentToken; SUSPEND
                   if);
                   
                // '\'' then
                   theText.clear;
                   get;
                   loop:
                   (if nextCh
                    // '\'' then
                       leave loop; 
                    // '\\' then
                       (if get
                        // ascii.newLine then
                           ascii.newline-&gt;theText.put; 
                        // 'n' then
                           ascii.newline-&gt;theText.put
                        // 't' then
                           ascii.ht-&gt;theText.put
                        // 'v' then
                           ascii.vt-&gt;theText.put
                        // 'b' then
                           ascii.bs-&gt;theText.put
                        // 'r' then
                           ascii.cr-&gt;theText.put
                        // 'f' then
                           ascii.np-&gt;theText.put
                        // 'a' then
                           ascii.bel-&gt;theText.put
                        // '\\' then
                           '\\'-&gt;theText.put
                        // '?' then
                           '?'-&gt;theText.put
                        // '\'' then
                           '\''-&gt;theText.put
                        // '"' then
                           '"'-&gt;theText.put
                        // EOF then
                           ('EOF reached while reading this string',6)
                             -&gt;markerror
                        else
                             (#
                                V: @integer;
                                oneMore: @boolean;
                                isDigit:
                                  (# bool: @boolean
                                  do (if ('0' &lt;= nextCh) and (nextCh &lt;= '7')
                                      then
                                         nextCh-'0'+V*8-&gt;V; true-&gt;bool
                                     if)
                                  exit bool
                                  #);
                                
                             do (if isDigit then
                                    get;
                                    (if isDigit then
                                        get; (if isDigit then get;  if)
                                    if);
                                    V-&gt;theText.put
                                if);
                                restart loop
                             #)
                       if);
                       get;
                       restart loop
                    // ascii.newLine then
                       inputPos-1-&gt;inputPos;
                       ('end-of-line is not allowed in strings',6)-&gt;markerror
                    // EOF then
                       ('EOF reached while reading this string',6)-&gt;markerror
                    // ascii.nul then
                       ('Ascii nul character reached while reading this string',6)-&gt;markerror
                    else
                       nextCh-&gt;theText.put; get; restart loop
                   if);
                   string-&gt;currentToken;
                   SUSPEND;
                   get
                // '(' then
                   (if get = '*' then
                       (if firstComment then false-&gt;firstComment if);
                       loop:
                       (if get
                        // '*' then
                           loop1:
                           (if get
                            // '*' then
                               nextCh-&gt;fgComment.put; restart loop1
                            // ')' then
                               CommentSeparator2-&gt;fgComment.put; get; leave loop
                            // EOF then
                               ('EOF reached while skipping this comment',6)
                                 -&gt;markerror
                    // ascii.nul then
                       ('Ascii nul character reached while skipping this comment',6)-&gt;markerror
                            else
                               '*'-&gt;fgComment.put;
                               nextCh-&gt;fgComment.put;
                               restart loop
                           if)
                        // EOF then
                           ('EOF reached while skipping this comment',6)
                             -&gt;markerror
                    // ascii.nul then
                       ('Ascii nul character reached while skipping this comment',6)-&gt;markerror
                        else
                           nextCh-&gt;fgComment.put; restart loop
                       if)
                    else
                       '('-&gt;currentToken; SUSPEND
                   if)
                // EOF // ascii.fs then
                   EOF-&gt;currentToken; SUSPEND; 
                    // ascii.nul then
                       ('Ascii nul character reached in non classified situation',6)-&gt;markerror
                else
                   (if true
                    // ('0' &lt;= nextCh) and ('9' &gt;= nextCh) then
                       nextCh-'0'-&gt;theConst;
                       get;
                       loop:
                       (if ('0' &lt;= nextCh) and ('9' &gt;= nextCh) then
                           10*theConst+nextCh-'0'-&gt;theConst; get; restart loop
                       if);
                       const-&gt;currentToken;
                       SUSPEND;
                       
                    //
                    ('A' &lt;= (nextCh-&gt;ascii.upcase))
                    and
                    ('Z' &gt;= (nextCh-&gt;ascii.upcase)) // ('_' = nextCh) then
                       theText.clear;
                       nextCh-&gt;theText.put;
                       get;
                       loop:
                       (if true
                        //
                        ('A' &lt;= (nextCh-&gt;ascii.upcase))
                        and
                        ('Z' &gt;= (nextCh-&gt;ascii.upcase))
                        // ('0' &lt;= nextCh) and ('9' &gt;= nextCh)
                        // ('_' = nextCh) then
                           nextCh-&gt;theText.put; get; restart loop
                       if);
                       (if true
                        // 'ORIGIN'-&gt;nameEqual then
                           origin-&gt;currentToken; SUSPEND
                        // 'INCLUDE'-&gt;nameEqual then
                           include-&gt;currentToken; SUSPEND
                        // 'BODY'-&gt;nameEqual then
                           body-&gt;currentToken; SUSPEND
                        // 'MDBODY'-&gt;nameEqual then
                           mdbody-&gt;currentToken; SUSPEND
                        else
                           name-&gt;currentToken; SUSPEND
                       if)
                    // (0 &lt;= nextCh) and (nextCh &lt;= 32) then
                       get
                    else
                       nextCh-&gt;currentToken; SUSPEND; get
                   if)
               if)
            #)
       #);
     <B>nextCh</B><A name="propertyParser.1.nextCh.2(980)"></A><A name="nextCh.2(980)"></A>: @integer;
     <B>theText</B><A name="propertyParser.1.theText.2(981)"></A><A name="theText.2(981)"></A>: @text;
     <B>theConst</B><A name="propertyParser.1.theConst.2(982)"></A><A name="theConst.2(982)"></A>: @integer;
     <B>accept</B><A name="propertyParser.1.accept.2(983)"></A><A name="accept.2(983)"></A>: @
       (# token: @integer; errorText: @text
       enter token
       do (if currentToken &lt;&gt; token then
              (if token
               // name then
                  ('NAME',1)-&gt;markError; 
               // string then
                  ('STRING',1)-&gt;markError; 
               // const then
                  ('CONST',1)-&gt;markError; 
               // origin then
                  ('origin',1)-&gt;markError; 
               // include then
                  ('include',1)-&gt;markError; 
               // body then
                  ('body',1)-&gt;markError; 
               // mdbody then
                  ('mdbody',1)-&gt;markError; 
               // beginGroup then
                  ('[[',1)-&gt;markError; 
               // endGroup then
                  (']]',1)-&gt;markError; 
               // dash then
                  errorText.clear;
                  EOSchar-&gt;errorText.put;
                  EOSchar-&gt;errorText.put;
                  (errorText,1)-&gt;markError;
                  
               // EOF then
                  ('EOF',1)-&gt;markError; 
                    // ascii.nul then
                       ('Ascii nul character',6)-&gt;markerror
               else
                  errorText.clear;
                  token-&gt;errorText.put;
                  (errorText,1)-&gt;markError
              if)
          if)
       #);
     <B>nameEqual</B><A name="propertyParser.1.nameEqual.2(984)"></A><A name="nameEqual.2(984)"></A>: @
       (# name: ^text enter name[] exit (theText[]-&gt;name.equalNCS) #);
     <B>parsePropertyList</B><A name="propertyParser.1.parsePropertyList.2(985)"></A><A name="parsePropertyList.2(985)"></A>:
       (# 
       do parseProperty;
          loop:
          (if currentToken
           // semiColon then
              advance;
              CommentSeparator1-&gt;fgComment.put;
              parseProperty;
              restart loop
           // name // origin // include // body // mdbody then
              semiColon-&gt;accept
          if)
       #);
     <B>parseProperty</B><A name="propertyParser.1.parseProperty.2(986)"></A><A name="parseProperty.2(986)"></A>: @
       (# propName: @text; pe: ^prop.propElement
       do (if currentToken
           // name then
              CommentSeparator3-&gt;fgComment.put;
              name-&gt;accept;
              theText-&gt;propName;
              advance;
              propName.copy
                -&gt;prop.addProp
                  (# ifPropExist::  (#  do false-&gt;delete #); 
                  do loop:
                     (if currentToken
                      // name then
                         CommentSeparator3-&gt;fgComment.put;
                         theText.copy-&gt;addName;
                         advance;
                         restart loop
                      // string then
                         CommentSeparator3-&gt;fgComment.put;
                         theText.copy-&gt;addString;
                         advance;
                         restart loop
                      // const then
                         CommentSeparator3-&gt;fgComment.put;
                         theConst-&gt;addConst;
                         advance;
                         restart loop
                     if)
                  #)
           // origin then
              CommentSeparator3-&gt;fgComment.put;
              origin-&gt;accept;
              theText-&gt;propName;
              advance;
              string-&gt;accept;
              propName.copy
                -&gt;prop.addProp
                  (# ifPropExist::  (#  do false-&gt;delete #); 
                  do (if currentToken = string then
                         CommentSeparator3-&gt;fgComment.put;
                         theText.copy-&gt;addString;
                         advance;
                         
                     if)
                  #);
              
           // include then
              CommentSeparator3-&gt;fgComment.put;
              include-&gt;accept;
              theText-&gt;propName;
              advance;
              string-&gt;accept;
              propName.copy
                -&gt;prop.addProp
                  (# ifPropExist::  (#  do false-&gt;delete #); 
                  do loop:
                     (if currentToken
                      // string then
                         CommentSeparator3-&gt;fgComment.put;
                         theText.copy-&gt;addString;
                         advance;
                         restart loop
                      // name // const then
                         string-&gt;accept; 
                      // origin // include // body // mdbody then
                         semiColon-&gt;accept
                     if)
                  #);
              
           // body then
              CommentSeparator3-&gt;fgComment.put;
              body-&gt;accept;
              theText-&gt;propName;
              advance;
              string-&gt;accept;
              propName.copy
                -&gt;prop.addProp
                  (# ifPropExist::  (#  do false-&gt;delete #); 
                  do loop:
                     (if currentToken = string then
                         CommentSeparator3-&gt;fgComment.put;
                         theText.copy-&gt;addString;
                         advance;
                         restart loop
                     if)
                  #)
           // mdbody then
              CommentSeparator3-&gt;fgComment.put;
              mdbody-&gt;accept;
              theText-&gt;propName;
              advance;
              name-&gt;accept;
              propName.copy
                -&gt;prop.addProp
                  (# ifPropExist::  (#  do false-&gt;delete #); 
                  do loop:
                     (if currentToken
                      // name then
                         CommentSeparator3-&gt;fgComment.put;
                         theText.copy-&gt;addName;
                         advance;
                         string-&gt;accept;
                         (if currentToken = string then
                             CommentSeparator3-&gt;fgComment.put;
                             theText.copy-&gt;addString;
                             advance;
                             restart loop
                         if)
                      // string // const then
                         name-&gt;accept
                      // origin // include // body // mdbody then
                         semiColon-&gt;accept
                     if)
                  #)
          if)
       #)
  enter (input[],error[])
  do 0-&gt;EOSchar;
     prop.proplist.clear;
     prop.init;
     none -&gt;linklist[];
     (* to cancel cached INCLUDE's *)
     true-&gt;ok;
     0-&gt;inputPos;
     true-&gt;firstComment;
     fgComment.clear;
     advance;
     INNER propertyParser;
     'Comment'
       -&gt;prop.addProp
         (#
            ifPropExist:: 
              (# 
              do '**WARNING: Property Comment is predefined'-&gt;error.putline
              #);
            
         do fgComment.copy-&gt;addString; 
         #);
     (*ESS: NO!!!!! (if ok then markAsChanged if);*)
     
  exit ok
  #);
<B>parseProperty</B><A name="parseProperty.1(987)"></A>: propertyParser (#  do parsePropertyList #)
</PRE>
<TABLE BORDER=0 ALIGN=RIGHT>
<TR>
<TD>
<A HREF="http://validator.w3.org/check/referer">
<IMG BORDER=0 SRC="../../images/vh40.gif" ALT="Valid HTML 4.0!" HEIGHT=31 WIDTH=88>
</A>
</TD>
</TR>
</TABLE>
<BR CLEAR=right>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Propertyparser Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size=-1>&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
