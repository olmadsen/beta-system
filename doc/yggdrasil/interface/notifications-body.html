<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Notifications Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript">
<!--
    CheckParent("notifications");
//-->
</SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="notifications">Notifications Interface</A></H1>

<PRE CLASS=interface>
ORIGIN 'astlevel';
INCLUDE 'observer';
LIB_ITEM 'mpsastlevel';
BODY 'private/notificationsbody';
(* This fragment implements a signalling system to be used by different
 * software components, each manipulating fragments through the same
 * mps instance.
 *
 * The system consists of the concept of a 'handle', which the software
 * component can use to both signal, that it has made some changes to
 * a fragment, and to subscribe to information on what other software
 * components are doing to the fragments.
 *
 * A handle therefore has a dual set of operations:
 *    'signal's and 'event's
 * A 'signal' operation is named 'signalXXX', and the corresponding
 * event is called 'onXXX', where 'XXX' is the name of the change
 * being reported.
 *
 * It is the responsability of the software component making the change
 * to signal this change.  This is done by invoking the corresponding
 * 'signalXXX' operation.  If a software component want to monitor
 * particular changes, it must obtain a handle with proper further
 * binding of the corresonding 'eventXXX' (more on this later).
 *
 * A few of these signals are automatically invoked by 'mps'.
 * In these cases, this is explicitly specified in the operation below.
 *
 * A software component obtains a handle by:
 *
 *    mps.getHandle
 *      (# handleType::
 *           (# onGroupOpen::
 *                (# do fg.fullname-&gt;puttext; ' opened'-&gt;putline #);
 *              onGroupClose
 *                (# do fg.fullname-&gt;puttext; ' closed'-&gt;putline #);
 *              ...etc...
 *           #)
 *      #);
 *
 * This handle monitors opening and closing of all fragment groups.
 *
 * If you want a handle, that only monitors a particular fragment
 * group, you can do this by:
 *
 *    mps.getHandle
 *      (# handleType::
 *           (# ignore:: (# (fg[]&lt;&gt;myFG[])-&gt;value #);
 *              ... som ovenfor ...
 *          #)
 *      #);
 *
 * You can get hold of this newly created handle by:
 *
 *    mps.getHandle(# ...som ovenfor... #)-&gt;h[];
 *
 * in which case it becomes possible later to decide to cancel this
 * handle by:
 *
 *    h[]-&gt;mps.ignoreHandle;
 *
 * If you later want to reactivate this handle, you can always do :
 *
 *    h[]-&gt;mps.activateHandle;
 *
 * If you have made changes to a fragment group, e.g. replaced an ast,
 * you can signal this to the other components by:
 *
 *    (fg[], ff[], oldAst[], newAst[])-&gt;mps.signalAstReplaced
 *
 * If you wish to control which handlers, signals are send to, you can
 * use the 'where' clause of 'signal'.  E.g. if you with to send a
 * signal to all handlers, except 'h[]', you can do this by:
 *
 *    (fg[], ff[], oldAst[], newAst[])-&gt;mps.signalAstReplaced
 *      (# where:: (# do (current[]&lt;&gt;h[])-&gt;value #) #)
 *)
(* This fragment implements a signalling system to be used by different
 * software components, each manipulating fragments through the same
 * mps instance.
 *
 * The system consists of the concept of a 'handle', which the software
 * component can use to both signal, that it has made some changes to
 * a fragment, and to subscribe to information on what other software
 * components are doing to the fragments.
 *
 * A handle therefore has a dual set of operations:
 *    'signal's and 'event's
 * A 'signal' operation is named 'signalXXX', and the corresponding
 * event is called 'onXXX', where 'XXX' is the name of the change
 * being reported.
 *
 * It is the responsability of the software component making the change
 * to signal this change.  This is done by invoking the corresponding
 * 'signalXXX' operation.  If a software component want to monitor
 * particular changes, it must obtain a handle with proper further
 * binding of the corresonding 'eventXXX' (more on this later).
 *
 * A few of these signals are automatically invoked by 'mps'.
 * In these cases, this is explicitly specified in the operation below.
 *
 * A software component obtains a handle by:
 *
 *    mps.getHandle
 *      (# handleType::
 *           (# onGroupOpen::
 *                (# do fg.fullname-&gt;puttext; ' opened'-&gt;putline #);
 *              onGroupClose
 *                (# do fg.fullname-&gt;puttext; ' closed'-&gt;putline #);
 *              ...etc...
 *           #)
 *      #);
 *
 * This handle monitors opening and closing of all fragment groups.
 *
 * If you want a handle, that only monitors a particular fragment
 * group, you can do this by:
 *
 *    mps.getHandle
 *      (# handleType::
 *           (# ignore:: (# (fg[]&lt;&gt;myFG[])-&gt;value #);
 *              ... som ovenfor ...
 *          #)
 *      #);
 *
 * You can get hold of this newly created handle by:
 *
 *    mps.getHandle(# ...som ovenfor... #)-&gt;h[];
 *
 * in which case it becomes possible later to decide to cancel this
 * handle by:
 *
 *    h[]-&gt;mps.ignoreHandle;
 *
 * If you later want to reactivate this handle, you can always do :
 *
 *    h[]-&gt;mps.activateHandle;
 *
 * If you have made changes to a fragment group, e.g. replaced an ast,
 * you can signal this to the other components by:
 *
 *    (fg[], ff[], oldAst[], newAst[])-&gt;mps.signalAstReplaced
 *
 * If you wish to control which handlers, signals are send to, you can
 * use the 'where' clause of 'signal'.  E.g. if you with to send a
 * signal to all handlers, except 'h[]', you can do this by:
 *
 *    (fg[], ff[], oldAst[], newAst[])-&gt;mps.signalAstReplaced
 *      (# where:: (# do (current[]&lt;&gt;h[])-&gt;value #) #)
 *)
-- astinterfacelib: Attributes --
<B>getHandle</B><A name="getHandle.1(692)"></A>: (* called to get a new handle on this MPS *)
  (# <B>handleType</B><A name="getHandle.1.handleType.2(693)"></A><A name="handleType.2(693)"></A>:&lt; handle; <B>h</B><A name="getHandle.1.h.2(694)"></A><A name="h.2(694)"></A>: ^handleType
  ...
  exit h[]
  #);
<B>ignoreHandle</B><A name="ignoreHandle.1(695)"></A>:
(* called to return a handle (i.e. now wanting to be monitoring
 * this MPS through this handle 'h' any longer
 *) (# <B>h</B><A name="ignoreHandle.1.h.2(696)"></A><A name="h.2(696)"></A>: ^handle enter h[] ... #);
<B>activateHandle</B><A name="activateHandle.1(697)"></A>:
(* called to activate a handle (i.e. now wanting to be monitoring
 * this MPS through this handle 'h' again
 *) (# <B>h</B><A name="activateHandle.1.h.2(698)"></A><A name="h.2(698)"></A>: ^handle enter h[] ... #);
<B>handle</B><A name="handle.1(699)"></A>:
(* this defines the events of a handle *)
  (#
     <B>ignore</B><A name="handle.1.ignore.2(700)"></A><A name="ignore.2(700)"></A>:&lt; booleanValue
     (* if this returns TRUE, this(handle) will be ignored *)
       (#
          fg: ^astInterface.fragmentGroup;
          ff: ^astInterface.fragmentForm;
          node: ^astInterface.ast
       enter (fg[],ff[],node[])
       do INNER
       #);
     <B>event</B><A name="handle.1.event.2(701)"></A><A name="event.2(701)"></A>: (* abstract superpattern *) (# do INNER #);
     <B>fragmentGroupEvent</B><A name="handle.1.fragmentGroupEvent.2(702)"></A><A name="fragmentGroupEvent.2(702)"></A>: event (* abstract superpattern *)
       (# fg: ^astInterface.fragmentGroup;  enter fg[] do INNER ;  #);
     <B>fragmentFormEvent</B><A name="handle.1.fragmentFormEvent.2(703)"></A><A name="fragmentFormEvent.2(703)"></A>: fragmentGroupEvent (* abstract superpattern *)
       (# ff: ^astInterface.fragmentForm;  enter ff[] do INNER ;  #);
     <B>astEvent</B><A name="handle.1.astEvent.2(704)"></A><A name="astEvent.2(704)"></A>: fragmentFormEvent (* abstract superpattern *)
       (# node: ^astInterface.ast enter node[] do INNER #);
     <B>onGroupOpen</B><A name="handle.1.onGroupOpen.2(705)"></A><A name="onGroupOpen.2(705)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS when fg[] have been opened by someone *)
       (# do INNER #);
     <B>onGroupLock</B><A name="handle.1.onGroupLock.2(706)"></A><A name="onGroupLock.2(706)"></A>:&lt; fragmentGroupEvent (* invoked by MPS when fg[] is locked *)
       (# do INNER #);
     <B>onGroupUnlock</B><A name="handle.1.onGroupUnlock.2(707)"></A><A name="onGroupUnlock.2(707)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS when fg[] is unlocked *) (# do INNER #);
     <B>onGroupPack</B><A name="handle.1.onGroupPack.2(708)"></A><A name="onGroupPack.2(708)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS when fg[] is saved to disk *) (# do INNER #);
     <B>onGroupUnpack</B><A name="handle.1.onGroupUnpack.2(709)"></A><A name="onGroupUnpack.2(709)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS when fg[] is unpacked from disk *)
       (# do INNER #);
     <B>onBeforeGroupClose</B><A name="handle.1.onBeforeGroupClose.2(710)"></A><A name="onBeforeGroupClose.2(710)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS before fg[] is closed
      *    okToClose=false   =&gt; fg will not be closed.
      *)
       (# okToClose: @boolean
       do true-&gt;okToClose; INNER
       exit okToClose
       #);
     <B>onGroupClose</B><A name="handle.1.onGroupClose.2(711)"></A><A name="onGroupClose.2(711)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS when fg[] have been closed *) (# do INNER #);
     <B>onTrace</B><A name="handle.1.onTrace.2(712)"></A><A name="onTrace.2(712)"></A>:&lt; event (* invoked by MPS if tracing is activated *)
       (# msg: ^text enter msg[] do INNER #)
  #);
<B>signal</B><A name="signal.1(713)"></A>:
  (#
     <B>where</B><A name="signal.1.where.2(714)"></A><A name="where.2(714)"></A>:&lt; booleanValue (#  do true-&gt;value; INNER #);
     <B>start</B><A name="signal.1.start.2(715)"></A><A name="start.2(715)"></A>:&lt; object (* executed before the signal is posted to all handlers *) ;
     <B>current</B><A name="signal.1.current.2(716)"></A><A name="current.2(716)"></A>: ^handle;
     <B>fg</B><A name="signal.1.fg.2(717)"></A><A name="fg.2(717)"></A>: ^astInterface.fragmentGroup;
     <B>ff</B><A name="signal.1.ff.2(718)"></A><A name="ff.2(718)"></A>: ^astInterface.fragmentForm;
     <B>node</B><A name="signal.1.node.2(719)"></A><A name="node.2(719)"></A>: ^astInterface.ast;
     
  ...
  #);
<B>fragmentGroupSignal</B><A name="fragmentGroupSignal.1(720)"></A>: signal
(* abstract superpattern *) (#  enter fg[] do INNER #);
<B>fragmentFormSignal</B><A name="fragmentFormSignal.1(721)"></A>: signal (* abstract superpattern *)
  (#  enter ff[] do INNER #);
<B>astSignal</B><A name="astSignal.1(722)"></A>: signal (* abstract superpattern *)
  (#  enter node[] do INNER #);
<B>signalGroupOpen</B><A name="signalGroupOpen.1(723)"></A>: fragmentGroupSignal (#  do fg[]-&gt;current.onGroupOpen #);
<B>signalGroupLock</B><A name="signalGroupLock.1(724)"></A>: fragmentGroupSignal (#  do fg[]-&gt;current.onGroupLock #);
<B>signalGroupUnlock</B><A name="signalGroupUnlock.1(725)"></A>: fragmentGroupSignal
  (#  do fg[]-&gt;current.onGroupUnlock #);
<B>signalGroupPack</B><A name="signalGroupPack.1(726)"></A>: fragmentGroupSignal (#  do fg[]-&gt;current.onGroupPack #);
<B>signalGroupUnpack</B><A name="signalGroupUnpack.1(727)"></A>: fragmentGroupSignal
  (#  do fg[]-&gt;current.onGroupUnpack #);
<B>signalBeforeGroupClose</B><A name="signalBeforeGroupClose.1(728)"></A>: fragmentGroupSignal
  (# <B>okToClose</B><A name="signalBeforeGroupClose.1.okToClose.2(729)"></A><A name="okToClose.2(729)"></A>: @boolean; <B>start</B><A name="signalBeforeGroupClose.1.start.2(730)"></A><A name="start.2(730)"></A>::&lt;  (#  do true-&gt;okToClose; INNER #); 
  do (okToClose and (fg[]-&gt;current.onBeforeGroupClose))-&gt;okToClose
  exit okToClose
  #);
<B>signalGroupClose</B><A name="signalGroupClose.1(731)"></A>: fragmentGroupSignal (#  do fg[]-&gt;current.onGroupClose #);
<B>signalTrace</B><A name="signalTrace.1(732)"></A>: signal
  (#
     <B>traceNo</B><A name="signalTrace.1.traceNo.2(733)"></A><A name="traceNo.2(733)"></A>: @integer;
     <B>msg</B><A name="signalTrace.1.msg.2(734)"></A><A name="msg.2(734)"></A>: ^text;
     <B>start</B><A name="signalTrace.1.start.2(735)"></A><A name="start.2(735)"></A>::&lt; 
       (# 
       do 'Trace: '-&gt;msg[]; traceNo-&gt;msg.putInt; ' '-&gt;msg.put; INNER
       #)
  enter traceNo
  do msg[]-&gt;current.onTrace
  #);
<B>astFocus</B><A name="astFocus.1(736)"></A>:
  (# <B>node</B><A name="astFocus.1.node.2(737)"></A><A name="node.2(737)"></A>: ^astInterface.ast; <B>length</B><A name="astFocus.1.length.2(738)"></A><A name="length.2(738)"></A>,<B>subCommentInx1</B><A name="astFocus.1.subCommentInx1.2(739)"></A><A name="subCommentInx1.2(739)"></A>,<B>subCommentInx2</B><A name="astFocus.1.subCommentInx2.2(740)"></A><A name="subCommentInx2.2(740)"></A>: @integer
  enter (node[],length,subCommentInx1,subCommentInx2)
  exit (node[],length,subCommentInx1,subCommentInx2)
  #);
<B>astList</B><A name="astList.1(741)"></A>: (# <B>elm</B><A name="astList.1.elm.2(742)"></A><A name="elm.2(742)"></A>: [50] ^astInterface.ast #);
<B>astReplacedElement</B><A name="astReplacedElement.1(743)"></A>: (# <B>oldAst</B><A name="astReplacedElement.1.oldAst.2(744)"></A><A name="oldAst.2(744)"></A>,<B>newAst</B><A name="astReplacedElement.1.newAst.2(745)"></A><A name="newAst.2(745)"></A>: ^astInterface.ast #);
<B>astReplacedList</B><A name="astReplacedList.1(746)"></A>: containerList
  (#
     <B>element</B><A name="astReplacedList.1.element.2(747)"></A><A name="element.2(747)"></A>:: astReplacedElement;
     <B>appendElement</B><A name="astReplacedList.1.appendElement.2(748)"></A><A name="appendElement.2(748)"></A>:
       (# oldAst,newAst: ^astInterface.ast; e: ^astReplacedElement; 
       enter (oldAst[],newAst[])
       do &amp;astReplacedElement[]-&gt;e[];
          oldAst[]-&gt;e.oldAst[];
          newAst[]-&gt;e.newAst[];
          e[]-&gt;append
       #)
  #);
  
-- fragmentGroupLib: Attributes --
<B>attachObserver</B><A name="attachObserver.1(749)"></A>: (* called to attach a new observer on this fragmentgroup *)
  (# <B>theObserver</B><A name="attachObserver.1.theObserver.2(750)"></A><A name="theObserver.2(750)"></A>: ^fragmentGroupObserver; 
  enter theObserver[]
  ...
  #);
<B>detachObserver</B><A name="detachObserver.1(751)"></A>:
(* called to detach an observer (i.e. now wanting to be monitoring
 * this fragmentGroup through this observer 'o' any longer
 *)
  (# <B>theObserver</B><A name="detachObserver.1.theObserver.2(752)"></A><A name="theObserver.2(752)"></A>: ^fragmentGroupObserver; 
  enter theObserver[]
  ...
  #);
<B>notify</B><A name="notify.1(753)"></A>:
  (#
     <B>where</B><A name="notify.1.where.2(754)"></A><A name="where.2(754)"></A>:&lt;
      booleanValue (#  do true-&gt;value; INNER #);
     <B>before</B><A name="notify.1.before.2(755)"></A><A name="before.2(755)"></A>:&lt; object
     (* executed before the notification is posted to all observers *) ;
     <B>after</B><A name="notify.1.after.2(756)"></A><A name="after.2(756)"></A>:&lt; object
     (* executed after the notification is posted to all observers *) ;
     <B>current</B><A name="notify.1.current.2(757)"></A><A name="current.2(757)"></A>: ^fragmentGroupObserver;
     <B>ff</B><A name="notify.1.ff.2(758)"></A><A name="ff.2(758)"></A>: ^astInterface.fragmentForm;
     
  ...
  #);
<B>notifyAs</B><A name="notifyAs.1(759)"></A>:
  (#
     <B>where</B><A name="notifyAs.1.where.2(760)"></A><A name="where.2(760)"></A>:&lt; booleanValue
       (# 
       do true-&gt;value; INNER
       #);
     <B>before</B><A name="notifyAs.1.before.2(761)"></A><A name="before.2(761)"></A>:&lt; object
     (* executed before the notification is posted to all observers *) ;
     <B>after</B><A name="notifyAs.1.after.2(762)"></A><A name="after.2(762)"></A>:&lt; object
     (* executed after the notification is posted to all observers *) ;
     <B>current</B><A name="notifyAs.1.current.2(763)"></A><A name="current.2(763)"></A>: ^type;
     <B>type</B><A name="notifyAs.1.type.2(764)"></A><A name="type.2(764)"></A>:&lt; fragmentGroupObserver;
     <B>ff</B><A name="notifyAs.1.ff.2(765)"></A><A name="ff.2(765)"></A>: ^astInterface.fragmentForm;
     
  ...
  #);
<B>fragmentFormNotify</B><A name="fragmentFormNotify.1(766)"></A>: notify
  (#  enter ff[] do INNER #);
<B>notifyNameChanged</B><A name="notifyNameChanged.1(767)"></A>:
 fragmentFormNotify
  (# <B>oldName</B><A name="notifyNameChanged.1.oldName.2(768)"></A><A name="oldName.2(768)"></A>,<B>newName</B><A name="notifyNameChanged.1.newName.2(769)"></A><A name="newName.2(769)"></A>: ^text; 
  enter (oldName[],newName[])
  do (ff[],oldName[],newName[])-&gt;current.onNameChanged
  #);
<B>notifyFragmentInserted</B><A name="notifyFragmentInserted.1(770)"></A>: fragmentFormNotify
  (#  do ff[]-&gt;current.onFragmentInserted #);
<B>notifyFragmentDeleted</B><A name="notifyFragmentDeleted.1(771)"></A>: fragmentFormNotify
  (#  do ff[]-&gt;current.onFragmentDeleted #);
<B>notifyPropertiesChanged</B><A name="notifyPropertiesChanged.1(772)"></A>: notify
  (# <B>oldProp</B><A name="notifyPropertiesChanged.1.oldProp.2(773)"></A><A name="oldProp.2(773)"></A>,<B>newProp</B><A name="notifyPropertiesChanged.1.newProp.2(774)"></A><A name="newProp.2(774)"></A>: ^propertyList; 
  enter (oldProp[],newProp[])
  do (oldProp[],newProp[])-&gt;current.onPropertiesChanged
  #);
<B>notifyGroupSaved</B><A name="notifyGroupSaved.1(775)"></A>: notify (#  do current.onGroupSaved #);
<B>notifyGroupNotSaved</B><A name="notifyGroupNotSaved.1(776)"></A>: notify (#  do current.onGroupNotSaved #);
<B>notifyGroupAutosaved</B><A name="notifyGroupAutosaved.1(777)"></A>: notify (#  do current.onGroupAutosaved #);
<B>notifyGroupChecked</B><A name="notifyGroupChecked.1(778)"></A>: notify
  (# <B>semanticErrors</B><A name="notifyGroupChecked.1.semanticErrors.2(779)"></A><A name="semanticErrors.2(779)"></A>: @boolean
  enter semanticErrors
  do semanticErrors-&gt;current.onGroupChecked
  #);
<B>notifyGroupLocked</B><A name="notifyGroupLocked.1(780)"></A>: notify (#  do current.onGroupLocked #);
<B>notifyGroupUnlocked</B><A name="notifyGroupUnlocked.1(781)"></A>: notify (#  do current.onGroupUnlocked #);
<B>notifyBeforeGroupClose</B><A name="notifyBeforeGroupClose.1(782)"></A>: notify
  (# <B>okToClose</B><A name="notifyBeforeGroupClose.1.okToClose.2(783)"></A><A name="okToClose.2(783)"></A>: @boolean; <B>before</B><A name="notifyBeforeGroupClose.1.before.2(784)"></A><A name="before.2(784)"></A>::&lt;  (#  do true-&gt;okToClose; INNER #); 
  do (okToClose and current.onBeforeGroupClose)-&gt;okToClose
  exit okToClose
  #);
<B>notifyGroupClosed</B><A name="notifyGroupClosed.1(785)"></A>: notify (#  do current.onGroupClosed #);
  
-- fragmentFormLib: Attributes --
<B>attachObserver</B><A name="attachObserver.1(786)"></A>: (* called to attach a new observer on this fragmentform *)
  (# <B>theObserver</B><A name="attachObserver.1.theObserver.2(787)"></A><A name="theObserver.2(787)"></A>: ^fragmentFormObserver; 
  enter theObserver[]
  ...
  #);
<B>detachObserver</B><A name="detachObserver.1(788)"></A>:
(* called to detach an observer (i.e. now wanting to be monitoring
 * this fragmentForm through this observer 'o' any longer
 *)
  (# <B>theObserver</B><A name="detachObserver.1.theObserver.2(789)"></A><A name="theObserver.2(789)"></A>: ^fragmentFormObserver
  enter theObserver[]
  ...
  #);
<B>notify</B><A name="notify.1(790)"></A>:
  (#
     <B>where</B><A name="notify.1.where.2(791)"></A><A name="where.2(791)"></A>:&lt;
      booleanValue (#  do true-&gt;value; INNER #);
     <B>before</B><A name="notify.1.before.2(792)"></A><A name="before.2(792)"></A>:&lt; object
     (* executed before the notification is posted to all observers *) ;
     <B>after</B><A name="notify.1.after.2(793)"></A><A name="after.2(793)"></A>:&lt; object
     (* executed after the notification is posted to all observers *) ;
     <B>current</B><A name="notify.1.current.2(794)"></A><A name="current.2(794)"></A>: ^fragmentFormObserver;
     <B>node</B><A name="notify.1.node.2(795)"></A><A name="node.2(795)"></A>: ^astInterface.ast;
     
  ...
  #);
<B>notifyAs</B><A name="notifyAs.1(796)"></A>:
  (#
     <B>where</B><A name="notifyAs.1.where.2(797)"></A><A name="where.2(797)"></A>:&lt; booleanValue
       (# 
       do true-&gt;value; INNER
       #);
     <B>before</B><A name="notifyAs.1.before.2(798)"></A><A name="before.2(798)"></A>:&lt; object
     (* executed before the notification is posted to all observers *) ;
     <B>after</B><A name="notifyAs.1.after.2(799)"></A><A name="after.2(799)"></A>:&lt; object
     (* executed after the notification is posted to all observers *) ;
     <B>current</B><A name="notifyAs.1.current.2(800)"></A><A name="current.2(800)"></A>: ^type;
     <B>type</B><A name="notifyAs.1.type.2(801)"></A><A name="type.2(801)"></A>:&lt; fragmentFormObserver;
     <B>node</B><A name="notifyAs.1.node.2(802)"></A><A name="node.2(802)"></A>: ^astInterface.ast;
     
  ...
  #);
<B>listNotify</B><A name="listNotify.1(803)"></A>: notify
(* abstract superpattern *) (#  enter node[] do INNER #);
<B>notifyAstReplaced</B><A name="notifyAstReplaced.1(804)"></A>: notify
  (# <B>oldAst</B><A name="notifyAstReplaced.1.oldAst.2(805)"></A><A name="oldAst.2(805)"></A>,<B>newAst</B><A name="notifyAstReplaced.1.newAst.2(806)"></A><A name="newAst.2(806)"></A>: ^astInterface.ast; 
  enter (oldAst[],newAst[])
  do (oldAst[],newAst[])-&gt;current.onAstReplaced
  #);
<B>notifyAstReplacedSequence</B><A name="notifyAstReplacedSequence.1(807)"></A>: notify
  (# <B>theSequence</B><A name="notifyAstReplacedSequence.1.theSequence.2(808)"></A><A name="theSequence.2(808)"></A>: ^astReplacedList
  enter (node[],theSequence[])
  do (node[],theSequence[])-&gt;current.onAstReplacedSequence
  #);
<B>notifyListElementInserted</B><A name="notifyListElementInserted.1(809)"></A>: listNotify
  (# <B>position</B><A name="notifyListElementInserted.1.position.2(810)"></A><A name="position.2(810)"></A>: @integer
  enter position
  do (node[],position)-&gt;current.onListElementInserted
  #);
<B>notifyListElementsDeleted</B><A name="notifyListElementsDeleted.1(811)"></A>: listNotify
  (# <B>oldElements</B><A name="notifyListElementsDeleted.1.oldElements.2(812)"></A><A name="oldElements.2(812)"></A>: ^astList; <B>position</B><A name="notifyListElementsDeleted.1.position.2(813)"></A><A name="position.2(813)"></A>,<B>length</B><A name="notifyListElementsDeleted.1.length.2(814)"></A><A name="length.2(814)"></A>: @integer
  enter (position,length,oldElements[])
  do (node[],position,length,oldElements[])-&gt;current.onListElementsDeleted
  #);
<B>notifyListElementsReplaced</B><A name="notifyListElementsReplaced.1(815)"></A>: listNotify
  (# <B>oldElements</B><A name="notifyListElementsReplaced.1.oldElements.2(816)"></A><A name="oldElements.2(816)"></A>: ^astList; <B>position</B><A name="notifyListElementsReplaced.1.position.2(817)"></A><A name="position.2(817)"></A>,<B>length</B><A name="notifyListElementsReplaced.1.length.2(818)"></A><A name="length.2(818)"></A>,<B>newLength</B><A name="notifyListElementsReplaced.1.newLength.2(819)"></A><A name="newLength.2(819)"></A>: @integer
  enter (position,length,oldElements[],newLength)
  do (node[],position,length,oldElements[],newLength)
       -&gt;current.onListElementsReplaced
  #);
<B>locked</B><A name="locked.1(820)"></A>: booleanValue (# ... #);
<B>lock</B><A name="lock.1(821)"></A>: (# ... #);
<B>unLock</B><A name="unLock.1(822)"></A>: (# ... #);
  
-- lib: Attributes --
<B>fragmentGroupObserver</B><A name="fragmentGroupObserver.1(823)"></A>: observer
  (#
     <B>group</B><A name="fragmentGroupObserver.1.group.2(824)"></A><A name="group.2(824)"></A>: ^astInterface.fragmentGroup;
     <B>no</B><A name="fragmentGroupObserver.1.no.2(825)"></A><A name="no.2(825)"></A>: @integer;
     <B>ignore</B><A name="fragmentGroupObserver.1.ignore.2(826)"></A><A name="ignore.2(826)"></A>:&lt; booleanValue
     (* if this returns TRUE, this(fragmentGroupObserver) will be ignored *)
       (# do INNER #);
     <B>fragmentFormEvent</B><A name="fragmentGroupObserver.1.fragmentFormEvent.2(827)"></A><A name="fragmentFormEvent.2(827)"></A>:
       (# ff: ^astInterface.fragmentForm enter ff[] do INNER #);
     <B>fragmentGroupEvent</B><A name="fragmentGroupObserver.1.fragmentGroupEvent.2(828)"></A><A name="fragmentGroupEvent.2(828)"></A>: (# do INNER #);
     <B>onNameChanged</B><A name="fragmentGroupObserver.1.onNameChanged.2(829)"></A><A name="onNameChanged.2(829)"></A>:&lt; fragmentFormEvent
     (* invoked if ff[] have been given a new name *)
       (# oldName,newName: ^text; 
       enter (oldName[],newName[])
       do INNER ; 
       #);
     <B>onFragmentInserted</B><A name="fragmentGroupObserver.1.onFragmentInserted.2(830)"></A><A name="onFragmentInserted.2(830)"></A>:&lt; fragmentFormEvent
     (* invoked when ff[] is inserted in fg[] *) (# do INNER #);
     <B>onFragmentDeleted</B><A name="fragmentGroupObserver.1.onFragmentDeleted.2(831)"></A><A name="onFragmentDeleted.2(831)"></A>:&lt; fragmentFormEvent
     (* invoked when ff[] is deleted from fg[] *) (# do INNER #);
     <B>onPropertiesChanged</B><A name="fragmentGroupObserver.1.onPropertiesChanged.2(832)"></A><A name="onPropertiesChanged.2(832)"></A>:&lt; fragmentGroupEvent
     (* invoked when the properties of fg[] have changed *)
       (# oldProp,newProp: ^propertyList; 
       enter (oldProp[],newProp[])
       do INNER
       #);
     <B>onGroupSaved</B><A name="fragmentGroupObserver.1.onGroupSaved.2(833)"></A><A name="onGroupSaved.2(833)"></A>:&lt; fragmentGroupEvent (* invoked when fg[] have been saved *)
       (# do INNER #);
     <B>onGroupNotSaved</B><A name="fragmentGroupObserver.1.onGroupNotSaved.2(834)"></A><A name="onGroupNotSaved.2(834)"></A>:&lt; fragmentGroupEvent 
     (* invoked when quitting without saving the fg[], 
      * either because no changes have been made to the fg 
      * or becauset he user has decided not to save the changes
      *)
       (# do INNER #);
     <B>onGroupAutoSaved</B><A name="fragmentGroupObserver.1.onGroupAutoSaved.2(835)"></A><A name="onGroupAutoSaved.2(835)"></A>:&lt; fragmentGroupEvent
     (* invoked when fg[] have been auto-saved *) (# do INNER #);
     <B>onGroupChecked</B><A name="fragmentGroupObserver.1.onGroupChecked.2(836)"></A><A name="onGroupChecked.2(836)"></A>:&lt; fragmentGroupEvent
     (* invoked when fg[] have been checked by the checker *)
       (# semanticErrors: @boolean enter semanticErrors do INNER #);
     <B>onGroupLocked</B><A name="fragmentGroupObserver.1.onGroupLocked.2(837)"></A><A name="onGroupLocked.2(837)"></A>:&lt; fragmentGroupEvent (* invoked by MPS when fg[] is locked *)
     (# do INNER #);
     <B>onGroupUnlocked</B><A name="fragmentGroupObserver.1.onGroupUnlocked.2(838)"></A><A name="onGroupUnlocked.2(838)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS when fg[] is unlocked *) (# do INNER #);
     <B>onBeforeGroupClose</B><A name="fragmentGroupObserver.1.onBeforeGroupClose.2(839)"></A><A name="onBeforeGroupClose.2(839)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS before fg[] is closed
      *    okToClose=false   =&gt; fg will not be closed.
      *)
       (# okToClose: @boolean
       do true-&gt;okToClose; INNER
       exit okToClose
       #);
     <B>onGroupClosed</B><A name="fragmentGroupObserver.1.onGroupClosed.2(840)"></A><A name="onGroupClosed.2(840)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS when fg[] have been closed *) (# do INNER #)
  #);
<B>fragmentFormObserver</B><A name="fragmentFormObserver.1(841)"></A>: observer
  (#
     <B>frag</B><A name="fragmentFormObserver.1.frag.2(842)"></A><A name="frag.2(842)"></A>: ^astinterface.fragmentForm;
     <B>no</B><A name="fragmentFormObserver.1.no.2(843)"></A><A name="no.2(843)"></A>: @integer;
     <B>astEvent</B><A name="fragmentFormObserver.1.astEvent.2(844)"></A><A name="astEvent.2(844)"></A>: (* abstract superpattern *)
       (#  do before; INNER ; after #);
     <B>listEvent</B><A name="fragmentFormObserver.1.listEvent.2(845)"></A><A name="listEvent.2(845)"></A>: astEvent
       (# node: ^astInterface.list enter node[] do INNER #);
     <B>before</B><A name="fragmentFormObserver.1.before.2(846)"></A><A name="before.2(846)"></A>:&lt; object (* executed before INNER in all astEvents   *) ;
     <B>after</B><A name="fragmentFormObserver.1.after.2(847)"></A><A name="after.2(847)"></A>:&lt; object (* executed after INNER in all astEvents *) ;
     <B>onAstReplaced</B><A name="fragmentFormObserver.1.onAstReplaced.2(848)"></A><A name="onAstReplaced.2(848)"></A>:&lt; astEvent (* invoked when an ast has been replaced *)
       (# oldAst,newAst: ^astInterface.ast; 
       enter (oldAst[],newAst[])
       do INNER
       #);
     <B>onAstReplacedSequence</B><A name="fragmentFormObserver.1.onAstReplacedSequence.2(849)"></A><A name="onAstReplacedSequence.2(849)"></A>:&lt; astEvent
     (* invoked when a sequence of astReplaced events have occured in node[]  *)
       (# node: ^astInterface.ast; theSequence: ^astInterface.astReplacedList
       enter (node[],theSequence[])
       do INNER
       #);
     <B>onListElementInserted</B><A name="fragmentFormObserver.1.onListElementInserted.2(850)"></A><A name="onListElementInserted.2(850)"></A>:&lt; listEvent
     (* invoked when a new list element have been inserted in node[] *)
       (# position: @integer;  enter position do INNER #);
     <B>onListElementsDeleted</B><A name="fragmentFormObserver.1.onListElementsDeleted.2(851)"></A><A name="onListElementsDeleted.2(851)"></A>:&lt; listEvent
     (* invoked when a list of elements have been deleted from node[] *)
       (# oldElements: ^astInterface.astList; position,length: @integer
       enter (position,length,oldElements[])
       do INNER
       #);
     <B>onListElementsReplaced</B><A name="fragmentFormObserver.1.onListElementsReplaced.2(852)"></A><A name="onListElementsReplaced.2(852)"></A>:&lt; listEvent
     (* invoked when a list of elements have been replaced in node[] *)
       (#
          oldElements: ^astInterface.astList;
          position,length,newLength: @integer
       enter (position,length,oldElements[],newLength)
       do INNER
       #)
  #)
</PRE>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Notifications Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
