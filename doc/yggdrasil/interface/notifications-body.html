<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<TITLE>Notifications Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/printframe.js"></SCRIPT>
<BASE TARGET="_top">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="notifications">Notifications Interface</A></H1>
<PRE CLASS=interface>
ORIGIN 'astlevel';
INCLUDE 'observer';
LIB_ITEM 'mpsastlevel';
BODY 'private/notificationsbody';
(* This fragment implements a signalling system to be used by different
 * software components, each manipulating fragments through the same
 * mps instance.
 *
 * The system consists of the concept of a 'handle', which the software
 * component can use to both signal, that it has made some changes to
 * a fragment, and to subscribe to information on what other software
 * components are doing to the fragments.
 *
 * A handle therefore has a dual set of operations:
 *    'signal's and 'event's
 * A 'signal' operation is named 'signalXXX', and the corresponding
 * event is called 'onXXX', where 'XXX' is the name of the change
 * being reported.
 *
 * It is the responsability of the software component making the change
 * to signal this change.  This is done by invoking the corresponding
 * 'signalXXX' operation.  If a software component want to monitor
 * particular changes, it must obtain a handle with proper further
 * binding of the corresonding 'eventXXX' (more on this later).
 *
 * A few of these signals are automatically invoked by 'mps'.
 * In these cases, this is explicitly specified in the operation below.
 *
 * A software component obtains a handle by:
 *
 *    mps.getHandle
 *      (# handleType::
 *           (# onGroupOpen::
 *                (# do fg.fullname-&gt;puttext; ' opened'-&gt;putline #);
 *              onGroupClose
 *                (# do fg.fullname-&gt;puttext; ' closed'-&gt;putline #);
 *              ...etc...
 *           #)
 *      #);
 *
 * This handle monitors opening and closing of all fragment groups.
 *
 * If you want a handle, that only monitors a particular fragment
 * group, you can do this by:
 *
 *    mps.getHandle
 *      (# handleType::
 *           (# ignore:: (# (fg[]&lt;&gt;myFG[])-&gt;value #);
 *              ... som ovenfor ...
 *          #)
 *      #);
 *
 * You can get hold of this newly created handle by:
 *
 *    mps.getHandle(# ...som ovenfor... #)-&gt;h[];
 *
 * in which case it becomes possible later to decide to cancel this
 * handle by:
 *
 *    h[]-&gt;mps.ignoreHandle;
 *
 * If you later want to reactivate this handle, you can always do :
 *
 *    h[]-&gt;mps.activateHandle;
 *
 * If you have made changes to a fragment group, e.g. replaced an ast,
 * you can signal this to the other components by:
 *
 *    (fg[], ff[], oldAst[], newAst[])-&gt;mps.signalAstReplaced
 *
 * If you wish to control which handlers, signals are send to, you can
 * use the 'where' clause of 'signal'.  E.g. if you with to send a
 * signal to all handlers, except 'h[]', you can do this by:
 *
 *    (fg[], ff[], oldAst[], newAst[])-&gt;mps.signalAstReplaced
 *      (# where:: (# do (current[]&lt;&gt;h[])-&gt;value #) #)
 *)
(* This fragment implements a signalling system to be used by different
 * software components, each manipulating fragments through the same
 * mps instance.
 *
 * The system consists of the concept of a 'handle', which the software
 * component can use to both signal, that it has made some changes to
 * a fragment, and to subscribe to information on what other software
 * components are doing to the fragments.
 *
 * A handle therefore has a dual set of operations:
 *    'signal's and 'event's
 * A 'signal' operation is named 'signalXXX', and the corresponding
 * event is called 'onXXX', where 'XXX' is the name of the change
 * being reported.
 *
 * It is the responsability of the software component making the change
 * to signal this change.  This is done by invoking the corresponding
 * 'signalXXX' operation.  If a software component want to monitor
 * particular changes, it must obtain a handle with proper further
 * binding of the corresonding 'eventXXX' (more on this later).
 *
 * A few of these signals are automatically invoked by 'mps'.
 * In these cases, this is explicitly specified in the operation below.
 *
 * A software component obtains a handle by:
 *
 *    mps.getHandle
 *      (# handleType::
 *           (# onGroupOpen::
 *                (# do fg.fullname-&gt;puttext; ' opened'-&gt;putline #);
 *              onGroupClose
 *                (# do fg.fullname-&gt;puttext; ' closed'-&gt;putline #);
 *              ...etc...
 *           #)
 *      #);
 *
 * This handle monitors opening and closing of all fragment groups.
 *
 * If you want a handle, that only monitors a particular fragment
 * group, you can do this by:
 *
 *    mps.getHandle
 *      (# handleType::
 *           (# ignore:: (# (fg[]&lt;&gt;myFG[])-&gt;value #);
 *              ... som ovenfor ...
 *          #)
 *      #);
 *
 * You can get hold of this newly created handle by:
 *
 *    mps.getHandle(# ...som ovenfor... #)-&gt;h[];
 *
 * in which case it becomes possible later to decide to cancel this
 * handle by:
 *
 *    h[]-&gt;mps.ignoreHandle;
 *
 * If you later want to reactivate this handle, you can always do :
 *
 *    h[]-&gt;mps.activateHandle;
 *
 * If you have made changes to a fragment group, e.g. replaced an ast,
 * you can signal this to the other components by:
 *
 *    (fg[], ff[], oldAst[], newAst[])-&gt;mps.signalAstReplaced
 *
 * If you wish to control which handlers, signals are send to, you can
 * use the 'where' clause of 'signal'.  E.g. if you with to send a
 * signal to all handlers, except 'h[]', you can do this by:
 *
 *    (fg[], ff[], oldAst[], newAst[])-&gt;mps.signalAstReplaced
 *      (# where:: (# do (current[]&lt;&gt;h[])-&gt;value #) #)
 *)
-- astinterfacelib: Attributes --
<B>getHandle</B><A name="getHandle.1(690)"></A>: (* called to get a new handle on this MPS *)
  (# <B>handleType</B><A name="getHandle.1:handleType.2(691)"></A><A name="handleType.2(691)"></A>:&lt; handle; <B>h</B><A name="getHandle.1:h.2(692)"></A><A name="h.2(692)"></A>: ^handleType
  ...
  exit h[]
  #);
<B>ignoreHandle</B><A name="ignoreHandle.1(693)"></A>:
(* called to return a handle (i.e. now wanting to be monitoring
 * this MPS through this handle 'h' any longer
 *) (# <B>h</B><A name="ignoreHandle.1:h.2(694)"></A><A name="h.2(694)"></A>: ^handle enter h[] ... #);
<B>activateHandle</B><A name="activateHandle.1(695)"></A>:
(* called to activate a handle (i.e. now wanting to be monitoring
 * this MPS through this handle 'h' again
 *) (# <B>h</B><A name="activateHandle.1:h.2(696)"></A><A name="h.2(696)"></A>: ^handle enter h[] ... #);
<B>handle</B><A name="handle.1(697)"></A>:
(* this defines the events of a handle *)
  (#
     <B>ignore</B><A name="handle.1:ignore.2(698)"></A><A name="ignore.2(698)"></A>:&lt; booleanValue
     (* if this returns TRUE, this(handle) will be ignored *)
       (#
          fg: ^astInterface.fragmentGroup;
          ff: ^astInterface.fragmentForm;
          node: ^astInterface.ast
       enter (fg[],ff[],node[])
       do INNER
       #);
     <B>event</B><A name="handle.1:event.2(699)"></A><A name="event.2(699)"></A>: (* abstract superpattern *) (# do INNER #);
     <B>fragmentGroupEvent</B><A name="handle.1:fragmentGroupEvent.2(700)"></A><A name="fragmentGroupEvent.2(700)"></A>: event (* abstract superpattern *)
       (# fg: ^astInterface.fragmentGroup;  enter fg[] do INNER ;  #);
     <B>fragmentFormEvent</B><A name="handle.1:fragmentFormEvent.2(701)"></A><A name="fragmentFormEvent.2(701)"></A>: fragmentGroupEvent (* abstract superpattern *)
       (# ff: ^astInterface.fragmentForm;  enter ff[] do INNER ;  #);
     <B>astEvent</B><A name="handle.1:astEvent.2(702)"></A><A name="astEvent.2(702)"></A>: fragmentFormEvent (* abstract superpattern *)
       (# node: ^astInterface.ast enter node[] do INNER #);
     <B>onGroupOpen</B><A name="handle.1:onGroupOpen.2(703)"></A><A name="onGroupOpen.2(703)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS when fg[] have been opened by someone *)
       (# do INNER #);
     <B>onGroupLock</B><A name="handle.1:onGroupLock.2(704)"></A><A name="onGroupLock.2(704)"></A>:&lt; fragmentGroupEvent (* invoked by MPS when fg[] is locked *)
       (# do INNER #);
     <B>onGroupUnlock</B><A name="handle.1:onGroupUnlock.2(705)"></A><A name="onGroupUnlock.2(705)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS when fg[] is unlocked *) (# do INNER #);
     <B>onGroupPack</B><A name="handle.1:onGroupPack.2(706)"></A><A name="onGroupPack.2(706)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS when fg[] is saved to disk *) (# do INNER #);
     <B>onGroupUnpack</B><A name="handle.1:onGroupUnpack.2(707)"></A><A name="onGroupUnpack.2(707)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS when fg[] is unpacked from disk *)
       (# do INNER #);
     <B>onBeforeGroupClose</B><A name="handle.1:onBeforeGroupClose.2(708)"></A><A name="onBeforeGroupClose.2(708)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS before fg[] is closed
      *    okToClose=false   =&gt; fg will not be closed.
      *)
       (# okToClose: @boolean
       do true-&gt;okToClose; INNER
       exit okToClose
       #);
     <B>onGroupClose</B><A name="handle.1:onGroupClose.2(709)"></A><A name="onGroupClose.2(709)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS when fg[] have been closed *) (# do INNER #);
     <B>onTrace</B><A name="handle.1:onTrace.2(710)"></A><A name="onTrace.2(710)"></A>:&lt; event (* invoked by MPS if tracing is activated *)
       (# msg: ^text enter msg[] do INNER #)
  #);
<B>signal</B><A name="signal.1(711)"></A>:
  (#
     <B>where</B><A name="signal.1:where.2(712)"></A><A name="where.2(712)"></A>:&lt; booleanValue (#  do true-&gt;value; INNER #);
     <B>start</B><A name="signal.1:start.2(713)"></A><A name="start.2(713)"></A>:&lt; object (* executed before the signal is posted to all handlers *) ;
     <B>current</B><A name="signal.1:current.2(714)"></A><A name="current.2(714)"></A>: ^handle;
     <B>fg</B><A name="signal.1:fg.2(715)"></A><A name="fg.2(715)"></A>: ^astInterface.fragmentGroup;
     <B>ff</B><A name="signal.1:ff.2(716)"></A><A name="ff.2(716)"></A>: ^astInterface.fragmentForm;
     <B>node</B><A name="signal.1:node.2(717)"></A><A name="node.2(717)"></A>: ^astInterface.ast;
     
  ...
  #);
<B>fragmentGroupSignal</B><A name="fragmentGroupSignal.1(718)"></A>: signal
(* abstract superpattern *) (#  enter fg[] do INNER #);
<B>fragmentFormSignal</B><A name="fragmentFormSignal.1(719)"></A>: signal (* abstract superpattern *)
  (#  enter ff[] do INNER #);
<B>astSignal</B><A name="astSignal.1(720)"></A>: signal (* abstract superpattern *)
  (#  enter node[] do INNER #);
<B>signalGroupOpen</B><A name="signalGroupOpen.1(721)"></A>: fragmentGroupSignal (#  do fg[]-&gt;current.onGroupOpen #);
<B>signalGroupLock</B><A name="signalGroupLock.1(722)"></A>: fragmentGroupSignal (#  do fg[]-&gt;current.onGroupLock #);
<B>signalGroupUnlock</B><A name="signalGroupUnlock.1(723)"></A>: fragmentGroupSignal
  (#  do fg[]-&gt;current.onGroupUnlock #);
<B>signalGroupPack</B><A name="signalGroupPack.1(724)"></A>: fragmentGroupSignal (#  do fg[]-&gt;current.onGroupPack #);
<B>signalGroupUnpack</B><A name="signalGroupUnpack.1(725)"></A>: fragmentGroupSignal
  (#  do fg[]-&gt;current.onGroupUnpack #);
<B>signalBeforeGroupClose</B><A name="signalBeforeGroupClose.1(726)"></A>: fragmentGroupSignal
  (# <B>okToClose</B><A name="signalBeforeGroupClose.1:okToClose.2(727)"></A><A name="okToClose.2(727)"></A>: @boolean; <B>start</B><A name="signalBeforeGroupClose.1:start.2(728)"></A><A name="start.2(728)"></A>::&lt;  (#  do true-&gt;okToClose; INNER #); 
  do (okToClose and (fg[]-&gt;current.onBeforeGroupClose))-&gt;okToClose
  exit okToClose
  #);
<B>signalGroupClose</B><A name="signalGroupClose.1(729)"></A>: fragmentGroupSignal (#  do fg[]-&gt;current.onGroupClose #);
<B>signalTrace</B><A name="signalTrace.1(730)"></A>: signal
  (#
     <B>traceNo</B><A name="signalTrace.1:traceNo.2(731)"></A><A name="traceNo.2(731)"></A>: @integer;
     <B>msg</B><A name="signalTrace.1:msg.2(732)"></A><A name="msg.2(732)"></A>: ^text;
     <B>start</B><A name="signalTrace.1:start.2(733)"></A><A name="start.2(733)"></A>::&lt; 
       (# 
       do 'Trace: '-&gt;msg[]; traceNo-&gt;msg.putInt; ' '-&gt;msg.put; INNER
       #)
  enter traceNo
  do msg[]-&gt;current.onTrace
  #);
<B>astFocus</B><A name="astFocus.1(734)"></A>:
  (# <B>node</B><A name="astFocus.1:node.2(735)"></A><A name="node.2(735)"></A>: ^astInterface.ast; <B>length</B><A name="astFocus.1:length.2(736)"></A><A name="length.2(736)"></A>,<B>subCommentInx1</B><A name="astFocus.1:subCommentInx1.2(737)"></A><A name="subCommentInx1.2(737)"></A>,<B>subCommentInx2</B><A name="astFocus.1:subCommentInx2.2(738)"></A><A name="subCommentInx2.2(738)"></A>: @integer
  enter (node[],length,subCommentInx1,subCommentInx2)
  exit (node[],length,subCommentInx1,subCommentInx2)
  #);
<B>astList</B><A name="astList.1(739)"></A>: (# <B>elm</B><A name="astList.1:elm.2(740)"></A><A name="elm.2(740)"></A>: [50] ^astInterface.ast #);
<B>astReplacedElement</B><A name="astReplacedElement.1(741)"></A>: (# <B>oldAst</B><A name="astReplacedElement.1:oldAst.2(742)"></A><A name="oldAst.2(742)"></A>,<B>newAst</B><A name="astReplacedElement.1:newAst.2(743)"></A><A name="newAst.2(743)"></A>: ^astInterface.ast #);
<B>astReplacedList</B><A name="astReplacedList.1(744)"></A>: containerList
  (#
     <B>element</B><A name="astReplacedList.1:element.2(745)"></A><A name="element.2(745)"></A>:: astReplacedElement;
     <B>appendElement</B><A name="astReplacedList.1:appendElement.2(746)"></A><A name="appendElement.2(746)"></A>:
       (# oldAst,newAst: ^astInterface.ast; e: ^astReplacedElement; 
       enter (oldAst[],newAst[])
       do &amp;astReplacedElement[]-&gt;e[];
          oldAst[]-&gt;e.oldAst[];
          newAst[]-&gt;e.newAst[];
          e[]-&gt;append
       #)
  #);
  
-- fragmentGroupLib: Attributes --
<B>attachObserver</B><A name="attachObserver.1(747)"></A>: (* called to attach a new observer on this fragmentgroup *)
  (# <B>theObserver</B><A name="attachObserver.1:theObserver.2(748)"></A><A name="theObserver.2(748)"></A>: ^fragmentGroupObserver; 
  enter theObserver[]
  ...
  #);
<B>detachObserver</B><A name="detachObserver.1(749)"></A>:
(* called to detach an observer (i.e. now wanting to be monitoring
 * this fragmentGroup through this observer 'o' any longer
 *)
  (# <B>theObserver</B><A name="detachObserver.1:theObserver.2(750)"></A><A name="theObserver.2(750)"></A>: ^fragmentGroupObserver; 
  enter theObserver[]
  ...
  #);
<B>notify</B><A name="notify.1(751)"></A>:
  (#
     <B>where</B><A name="notify.1:where.2(752)"></A><A name="where.2(752)"></A>:&lt;
      booleanValue (#  do true-&gt;value; INNER #);
     <B>before</B><A name="notify.1:before.2(753)"></A><A name="before.2(753)"></A>:&lt; object
     (* executed before the notification is posted to all observers *) ;
     <B>after</B><A name="notify.1:after.2(754)"></A><A name="after.2(754)"></A>:&lt; object
     (* executed after the notification is posted to all observers *) ;
     <B>current</B><A name="notify.1:current.2(755)"></A><A name="current.2(755)"></A>: ^fragmentGroupObserver;
     <B>ff</B><A name="notify.1:ff.2(756)"></A><A name="ff.2(756)"></A>: ^astInterface.fragmentForm;
     
  ...
  #);
<B>notifyAs</B><A name="notifyAs.1(757)"></A>:
  (#
     <B>where</B><A name="notifyAs.1:where.2(758)"></A><A name="where.2(758)"></A>:&lt; booleanValue
       (# 
       do true-&gt;value; INNER
       #);
     <B>before</B><A name="notifyAs.1:before.2(759)"></A><A name="before.2(759)"></A>:&lt; object
     (* executed before the notification is posted to all observers *) ;
     <B>after</B><A name="notifyAs.1:after.2(760)"></A><A name="after.2(760)"></A>:&lt; object
     (* executed after the notification is posted to all observers *) ;
     <B>current</B><A name="notifyAs.1:current.2(761)"></A><A name="current.2(761)"></A>: ^type;
     <B>type</B><A name="notifyAs.1:type.2(762)"></A><A name="type.2(762)"></A>:&lt; fragmentGroupObserver;
     <B>ff</B><A name="notifyAs.1:ff.2(763)"></A><A name="ff.2(763)"></A>: ^astInterface.fragmentForm;
     
  ...
  #);
<B>fragmentFormNotify</B><A name="fragmentFormNotify.1(764)"></A>: notify
  (#  enter ff[] do INNER #);
<B>notifyNameChanged</B><A name="notifyNameChanged.1(765)"></A>:
 fragmentFormNotify
  (# <B>oldName</B><A name="notifyNameChanged.1:oldName.2(766)"></A><A name="oldName.2(766)"></A>,<B>newName</B><A name="notifyNameChanged.1:newName.2(767)"></A><A name="newName.2(767)"></A>: ^text; 
  enter (oldName[],newName[])
  do (ff[],oldName[],newName[])-&gt;current.onNameChanged
  #);
<B>notifyFragmentInserted</B><A name="notifyFragmentInserted.1(768)"></A>: fragmentFormNotify
  (#  do ff[]-&gt;current.onFragmentInserted #);
<B>notifyFragmentDeleted</B><A name="notifyFragmentDeleted.1(769)"></A>: fragmentFormNotify
  (#  do ff[]-&gt;current.onFragmentDeleted #);
<B>notifyPropertiesChanged</B><A name="notifyPropertiesChanged.1(770)"></A>: notify
  (# <B>oldProp</B><A name="notifyPropertiesChanged.1:oldProp.2(771)"></A><A name="oldProp.2(771)"></A>,<B>newProp</B><A name="notifyPropertiesChanged.1:newProp.2(772)"></A><A name="newProp.2(772)"></A>: ^propertyList; 
  enter (oldProp[],newProp[])
  do (oldProp[],newProp[])-&gt;current.onPropertiesChanged
  #);
<B>notifyGroupSaved</B><A name="notifyGroupSaved.1(773)"></A>: notify (#  do current.onGroupSaved #);
<B>notifyGroupNotSaved</B><A name="notifyGroupNotSaved.1(774)"></A>: notify (#  do current.onGroupNotSaved #);
<B>notifyGroupAutosaved</B><A name="notifyGroupAutosaved.1(775)"></A>: notify (#  do current.onGroupAutosaved #);
<B>notifyGroupChecked</B><A name="notifyGroupChecked.1(776)"></A>: notify
  (# <B>semanticErrors</B><A name="notifyGroupChecked.1:semanticErrors.2(777)"></A><A name="semanticErrors.2(777)"></A>: @boolean
  enter semanticErrors
  do semanticErrors-&gt;current.onGroupChecked
  #);
<B>notifyGroupLocked</B><A name="notifyGroupLocked.1(778)"></A>: notify (#  do current.onGroupLocked #);
<B>notifyGroupUnlocked</B><A name="notifyGroupUnlocked.1(779)"></A>: notify (#  do current.onGroupUnlocked #);
<B>notifyBeforeGroupClose</B><A name="notifyBeforeGroupClose.1(780)"></A>: notify
  (# <B>okToClose</B><A name="notifyBeforeGroupClose.1:okToClose.2(781)"></A><A name="okToClose.2(781)"></A>: @boolean; <B>before</B><A name="notifyBeforeGroupClose.1:before.2(782)"></A><A name="before.2(782)"></A>::&lt;  (#  do true-&gt;okToClose; INNER #); 
  do (okToClose and current.onBeforeGroupClose)-&gt;okToClose
  exit okToClose
  #);
<B>notifyGroupClosed</B><A name="notifyGroupClosed.1(783)"></A>: notify (#  do current.onGroupClosed #);
  
-- fragmentFormLib: Attributes --
<B>attachObserver</B><A name="attachObserver.1(784)"></A>: (* called to attach a new observer on this fragmentform *)
  (# <B>theObserver</B><A name="attachObserver.1:theObserver.2(785)"></A><A name="theObserver.2(785)"></A>: ^fragmentFormObserver; 
  enter theObserver[]
  ...
  #);
<B>detachObserver</B><A name="detachObserver.1(786)"></A>:
(* called to detach an observer (i.e. now wanting to be monitoring
 * this fragmentForm through this observer 'o' any longer
 *)
  (# <B>theObserver</B><A name="detachObserver.1:theObserver.2(787)"></A><A name="theObserver.2(787)"></A>: ^fragmentFormObserver
  enter theObserver[]
  ...
  #);
<B>notify</B><A name="notify.1(788)"></A>:
  (#
     <B>where</B><A name="notify.1:where.2(789)"></A><A name="where.2(789)"></A>:&lt;
      booleanValue (#  do true-&gt;value; INNER #);
     <B>before</B><A name="notify.1:before.2(790)"></A><A name="before.2(790)"></A>:&lt; object
     (* executed before the notification is posted to all observers *) ;
     <B>after</B><A name="notify.1:after.2(791)"></A><A name="after.2(791)"></A>:&lt; object
     (* executed after the notification is posted to all observers *) ;
     <B>current</B><A name="notify.1:current.2(792)"></A><A name="current.2(792)"></A>: ^fragmentFormObserver;
     <B>node</B><A name="notify.1:node.2(793)"></A><A name="node.2(793)"></A>: ^astInterface.ast;
     
  ...
  #);
<B>notifyAs</B><A name="notifyAs.1(794)"></A>:
  (#
     <B>where</B><A name="notifyAs.1:where.2(795)"></A><A name="where.2(795)"></A>:&lt; booleanValue
       (# 
       do true-&gt;value; INNER
       #);
     <B>before</B><A name="notifyAs.1:before.2(796)"></A><A name="before.2(796)"></A>:&lt; object
     (* executed before the notification is posted to all observers *) ;
     <B>after</B><A name="notifyAs.1:after.2(797)"></A><A name="after.2(797)"></A>:&lt; object
     (* executed after the notification is posted to all observers *) ;
     <B>current</B><A name="notifyAs.1:current.2(798)"></A><A name="current.2(798)"></A>: ^type;
     <B>type</B><A name="notifyAs.1:type.2(799)"></A><A name="type.2(799)"></A>:&lt; fragmentFormObserver;
     <B>node</B><A name="notifyAs.1:node.2(800)"></A><A name="node.2(800)"></A>: ^astInterface.ast;
     
  ...
  #);
<B>listNotify</B><A name="listNotify.1(801)"></A>: notify
(* abstract superpattern *) (#  enter node[] do INNER #);
<B>notifyAstReplaced</B><A name="notifyAstReplaced.1(802)"></A>: notify
  (# <B>oldAst</B><A name="notifyAstReplaced.1:oldAst.2(803)"></A><A name="oldAst.2(803)"></A>,<B>newAst</B><A name="notifyAstReplaced.1:newAst.2(804)"></A><A name="newAst.2(804)"></A>: ^astInterface.ast; 
  enter (oldAst[],newAst[])
  do (oldAst[],newAst[])-&gt;current.onAstReplaced
  #);
<B>notifyAstReplacedSequence</B><A name="notifyAstReplacedSequence.1(805)"></A>: notify
  (# <B>theSequence</B><A name="notifyAstReplacedSequence.1:theSequence.2(806)"></A><A name="theSequence.2(806)"></A>: ^astReplacedList
  enter (node[],theSequence[])
  do (node[],theSequence[])-&gt;current.onAstReplacedSequence
  #);
<B>notifyListElementInserted</B><A name="notifyListElementInserted.1(807)"></A>: listNotify
  (# <B>position</B><A name="notifyListElementInserted.1:position.2(808)"></A><A name="position.2(808)"></A>: @integer
  enter position
  do (node[],position)-&gt;current.onListElementInserted
  #);
<B>notifyListElementsDeleted</B><A name="notifyListElementsDeleted.1(809)"></A>: listNotify
  (# <B>oldElements</B><A name="notifyListElementsDeleted.1:oldElements.2(810)"></A><A name="oldElements.2(810)"></A>: ^astList; <B>position</B><A name="notifyListElementsDeleted.1:position.2(811)"></A><A name="position.2(811)"></A>,<B>length</B><A name="notifyListElementsDeleted.1:length.2(812)"></A><A name="length.2(812)"></A>: @integer
  enter (position,length,oldElements[])
  do (node[],position,length,oldElements[])-&gt;current.onListElementsDeleted
  #);
<B>notifyListElementsReplaced</B><A name="notifyListElementsReplaced.1(813)"></A>: listNotify
  (# <B>oldElements</B><A name="notifyListElementsReplaced.1:oldElements.2(814)"></A><A name="oldElements.2(814)"></A>: ^astList; <B>position</B><A name="notifyListElementsReplaced.1:position.2(815)"></A><A name="position.2(815)"></A>,<B>length</B><A name="notifyListElementsReplaced.1:length.2(816)"></A><A name="length.2(816)"></A>,<B>newLength</B><A name="notifyListElementsReplaced.1:newLength.2(817)"></A><A name="newLength.2(817)"></A>: @integer
  enter (position,length,oldElements[],newLength)
  do (node[],position,length,oldElements[],newLength)
       -&gt;current.onListElementsReplaced
  #);
<B>locked</B><A name="locked.1(818)"></A>: booleanValue (# ... #);
<B>lock</B><A name="lock.1(819)"></A>: (# ... #);
<B>unLock</B><A name="unLock.1(820)"></A>: (# ... #);
  
-- lib: Attributes --
<B>fragmentGroupObserver</B><A name="fragmentGroupObserver.1(821)"></A>: observer
  (#
     <B>group</B><A name="fragmentGroupObserver.1:group.2(822)"></A><A name="group.2(822)"></A>: ^astInterface.fragmentGroup;
     <B>no</B><A name="fragmentGroupObserver.1:no.2(823)"></A><A name="no.2(823)"></A>: @integer;
     <B>ignore</B><A name="fragmentGroupObserver.1:ignore.2(824)"></A><A name="ignore.2(824)"></A>:&lt; booleanValue
     (* if this returns TRUE, this(fragmentGroupObserver) will be ignored *)
       (# do INNER #);
     <B>fragmentFormEvent</B><A name="fragmentGroupObserver.1:fragmentFormEvent.2(825)"></A><A name="fragmentFormEvent.2(825)"></A>:
       (# ff: ^astInterface.fragmentForm enter ff[] do INNER #);
     <B>fragmentGroupEvent</B><A name="fragmentGroupObserver.1:fragmentGroupEvent.2(826)"></A><A name="fragmentGroupEvent.2(826)"></A>: (# do INNER #);
     <B>onNameChanged</B><A name="fragmentGroupObserver.1:onNameChanged.2(827)"></A><A name="onNameChanged.2(827)"></A>:&lt; fragmentFormEvent
     (* invoked if ff[] have been given a new name *)
       (# oldName,newName: ^text; 
       enter (oldName[],newName[])
       do INNER ; 
       #);
     <B>onFragmentInserted</B><A name="fragmentGroupObserver.1:onFragmentInserted.2(828)"></A><A name="onFragmentInserted.2(828)"></A>:&lt; fragmentFormEvent
     (* invoked when ff[] is inserted in fg[] *) (# do INNER #);
     <B>onFragmentDeleted</B><A name="fragmentGroupObserver.1:onFragmentDeleted.2(829)"></A><A name="onFragmentDeleted.2(829)"></A>:&lt; fragmentFormEvent
     (* invoked when ff[] is deleted from fg[] *) (# do INNER #);
     <B>onPropertiesChanged</B><A name="fragmentGroupObserver.1:onPropertiesChanged.2(830)"></A><A name="onPropertiesChanged.2(830)"></A>:&lt; fragmentGroupEvent
     (* invoked when the properties of fg[] have changed *)
       (# oldProp,newProp: ^propertyList; 
       enter (oldProp[],newProp[])
       do INNER
       #);
     <B>onGroupSaved</B><A name="fragmentGroupObserver.1:onGroupSaved.2(831)"></A><A name="onGroupSaved.2(831)"></A>:&lt; fragmentGroupEvent (* invoked when fg[] have been saved *)
       (# do INNER #);
     <B>onGroupNotSaved</B><A name="fragmentGroupObserver.1:onGroupNotSaved.2(832)"></A><A name="onGroupNotSaved.2(832)"></A>:&lt; fragmentGroupEvent 
     (* invoked when quitting without saving the fg[], 
      * either because no changes have been made to the fg 
      * or becauset he user has decided not to save the changes
      *)
       (# do INNER #);
     <B>onGroupAutoSaved</B><A name="fragmentGroupObserver.1:onGroupAutoSaved.2(833)"></A><A name="onGroupAutoSaved.2(833)"></A>:&lt; fragmentGroupEvent
     (* invoked when fg[] have been auto-saved *) (# do INNER #);
     <B>onGroupChecked</B><A name="fragmentGroupObserver.1:onGroupChecked.2(834)"></A><A name="onGroupChecked.2(834)"></A>:&lt; fragmentGroupEvent
     (* invoked when fg[] have been checked by the checker *)
       (# semanticErrors: @boolean enter semanticErrors do INNER #);
     <B>onGroupLocked</B><A name="fragmentGroupObserver.1:onGroupLocked.2(835)"></A><A name="onGroupLocked.2(835)"></A>:&lt; fragmentGroupEvent (* invoked by MPS when fg[] is locked *)
     (# do INNER #);
     <B>onGroupUnlocked</B><A name="fragmentGroupObserver.1:onGroupUnlocked.2(836)"></A><A name="onGroupUnlocked.2(836)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS when fg[] is unlocked *) (# do INNER #);
     <B>onBeforeGroupClose</B><A name="fragmentGroupObserver.1:onBeforeGroupClose.2(837)"></A><A name="onBeforeGroupClose.2(837)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS before fg[] is closed
      *    okToClose=false   =&gt; fg will not be closed.
      *)
       (# okToClose: @boolean
       do true-&gt;okToClose; INNER
       exit okToClose
       #);
     <B>onGroupClosed</B><A name="fragmentGroupObserver.1:onGroupClosed.2(838)"></A><A name="onGroupClosed.2(838)"></A>:&lt; fragmentGroupEvent
     (* invoked by MPS when fg[] have been closed *) (# do INNER #)
  #);
<B>fragmentFormObserver</B><A name="fragmentFormObserver.1(839)"></A>: observer
  (#
     <B>frag</B><A name="fragmentFormObserver.1:frag.2(840)"></A><A name="frag.2(840)"></A>: ^astinterface.fragmentForm;
     <B>no</B><A name="fragmentFormObserver.1:no.2(841)"></A><A name="no.2(841)"></A>: @integer;
     <B>astEvent</B><A name="fragmentFormObserver.1:astEvent.2(842)"></A><A name="astEvent.2(842)"></A>: (* abstract superpattern *)
       (#  do before; INNER ; after #);
     <B>listEvent</B><A name="fragmentFormObserver.1:listEvent.2(843)"></A><A name="listEvent.2(843)"></A>: astEvent
       (# node: ^astInterface.list enter node[] do INNER #);
     <B>before</B><A name="fragmentFormObserver.1:before.2(844)"></A><A name="before.2(844)"></A>:&lt; object (* executed before INNER in all astEvents   *) ;
     <B>after</B><A name="fragmentFormObserver.1:after.2(845)"></A><A name="after.2(845)"></A>:&lt; object (* executed after INNER in all astEvents *) ;
     <B>onAstReplaced</B><A name="fragmentFormObserver.1:onAstReplaced.2(846)"></A><A name="onAstReplaced.2(846)"></A>:&lt; astEvent (* invoked when an ast has been replaced *)
       (# oldAst,newAst: ^astInterface.ast; 
       enter (oldAst[],newAst[])
       do INNER
       #);
     <B>onAstReplacedSequence</B><A name="fragmentFormObserver.1:onAstReplacedSequence.2(847)"></A><A name="onAstReplacedSequence.2(847)"></A>:&lt; astEvent
     (* invoked when a sequence of astReplaced events have occured in node[]  *)
       (# node: ^astInterface.ast; theSequence: ^astInterface.astReplacedList
       enter (node[],theSequence[])
       do INNER
       #);
     <B>onListElementInserted</B><A name="fragmentFormObserver.1:onListElementInserted.2(848)"></A><A name="onListElementInserted.2(848)"></A>:&lt; listEvent
     (* invoked when a new list element have been inserted in node[] *)
       (# position: @integer;  enter position do INNER #);
     <B>onListElementsDeleted</B><A name="fragmentFormObserver.1:onListElementsDeleted.2(849)"></A><A name="onListElementsDeleted.2(849)"></A>:&lt; listEvent
     (* invoked when a list of elements have been deleted from node[] *)
       (# oldElements: ^astInterface.astList; position,length: @integer
       enter (position,length,oldElements[])
       do INNER
       #);
     <B>onListElementsReplaced</B><A name="fragmentFormObserver.1:onListElementsReplaced.2(850)"></A><A name="onListElementsReplaced.2(850)"></A>:&lt; listEvent
     (* invoked when a list of elements have been replaced in node[] *)
       (#
          oldElements: ^astInterface.astList;
          position,length,newLength: @integer
       enter (position,length,oldElements[],newLength)
       do INNER
       #)
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="40%" align="left"><ADDRESS>Notifications Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
