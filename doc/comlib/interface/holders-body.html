<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<TITLE>Holders Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/printframe.js"></SCRIPT>
<BASE TARGET="_top">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="holders">Holders Interface</A></H1>
<PRE CLASS=interface>
ORIGIN '~beta/basiclib/wtext';
BODY 'private/textholderbody';
BODY 'private/wtextholderbody';
--LIB: attributes--

(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-98
 *       All rights reserved.
 *)

(* Holder patterns for predefined BETA types *)

<B>integerHolder</B><A name="integerHolder.1(1)"></A>: Holder
  (# <B>value</B><A name="integerHolder.1:value.2(2)"></A><A name="value.2(2)"></A>: @integer enter value exit value #);
<B>shortIntHolder</B><A name="shortIntHolder.1(3)"></A>: Holder
  (# <B>value</B><A name="shortIntHolder.1:value.2(4)"></A><A name="value.2(4)"></A>: @shortInt enter value exit value #);
<B>charHolder</B><A name="charHolder.1(5)"></A>: Holder
  (# <B>value</B><A name="charHolder.1:value.2(6)"></A><A name="value.2(6)"></A>: @char enter value exit value #);
<B>booleanHolder</B><A name="booleanHolder.1(7)"></A>: Holder
  (# <B>value</B><A name="booleanHolder.1:value.2(8)"></A><A name="value.2(8)"></A>: @boolean #);
<B>realHolder</B><A name="realHolder.1(9)"></A>: Holder
  (# <B>value</B><A name="realHolder.1:value.2(10)"></A><A name="value.2(10)"></A>: @real enter value exit value #);
<B>int8Holder</B><A name="int8Holder.1(11)"></A>: Holder
  (# <B>value</B><A name="int8Holder.1:value.2(12)"></A><A name="value.2(12)"></A>: @int8 enter value exit value #);
<B>int8uHolder</B><A name="int8uHolder.1(13)"></A>: Holder
  (# <B>value</B><A name="int8uHolder.1:value.2(14)"></A><A name="value.2(14)"></A>: @int8u enter value exit value #);
<B>int16Holder</B><A name="int16Holder.1(15)"></A>: Holder
  (# <B>value</B><A name="int16Holder.1:value.2(16)"></A><A name="value.2(16)"></A>: @int16 enter value exit value #);
<B>int16uHolder</B><A name="int16uHolder.1(17)"></A>: Holder
  (# <B>value</B><A name="int16uHolder.1:value.2(18)"></A><A name="value.2(18)"></A>: @int16u enter value exit value #);
<B>int32Holder</B><A name="int32Holder.1(19)"></A>: Holder
  (# <B>value</B><A name="int32Holder.1:value.2(20)"></A><A name="value.2(20)"></A>: @int32 enter value exit value #);
<B>int32uHolder</B><A name="int32uHolder.1(21)"></A>: Holder
  (# <B>value</B><A name="int32uHolder.1:value.2(22)"></A><A name="value.2(22)"></A>: @int32u enter value exit value #);
<B>int64Holder</B><A name="int64Holder.1(23)"></A>: Holder
  (# <B>value</B><A name="int64Holder.1:value.2(24)"></A><A name="value.2(24)"></A>: @int64 enter value exit value #);
<B>int64uHolder</B><A name="int64uHolder.1(25)"></A>: Holder
  (# <B>value</B><A name="int64uHolder.1:value.2(26)"></A><A name="value.2(26)"></A>: @int64u enter value exit value #);
<B>wcharHolder</B><A name="wcharHolder.1(27)"></A>: Holder
  (# <B>value</B><A name="wcharHolder.1:value.2(28)"></A><A name="value.2(28)"></A>: @wchar enter value exit value #);

(* Holder for COM references (interfaces) *)
<B>RefHolder</B><A name="RefHolder.1(29)"></A>: Holder
  (# <B>type</B><A name="RefHolder.1:type.2(30)"></A><A name="type.2(30)"></A>:&lt; COM;
     <B>ref</B><A name="RefHolder.1:ref.2(31)"></A><A name="ref.2(31)"></A>: ^type;
  enter ref[] 
  exit ref[]
  #);

(* Holder for text objects *)

(* Other proposal:
 *   cText: stream
 *     (# charptr: @integer
 *          {* The pointer to the external string *};
 *        ....
 *     #);
 *   cTextHolder: RefHolder
 *     (# type::cText
 *     #);
 *)

<B>TextHolder</B><A name="TextHolder.1(32)"></A>: Holder
  (* Externally allocated string used for pointer-to-text parameters
   * in COM interfaces.
   *)
  (# <B>charptr</B><A name="TextHolder.1:charptr.2(33)"></A><A name="charptr.2(33)"></A>: @integer
       (* The pointer to the external string *);
     <B>allocate</B><A name="TextHolder.1:allocate.2(34)"></A><A name="allocate.2(34)"></A>: 
       (* Allocate length bytes (default 256) using malloc, and assign the
        * result to charptr. You may want to explicitly free THIS(TextHolder)
        * before a reallocation.
        *)
       (# length: @integer;
       enter length 
       do ...
       #);
     <B>free</B><A name="TextHolder.1:free.2(35)"></A><A name="free.2(35)"></A>: 
       (* Free the externally allocated string. The chars of the externally
        * allocated string will be unaccessible after this operation.
        *)
       (# ... #);
     <B>set</B><A name="TextHolder.1:set.2(36)"></A><A name="set.2(36)"></A>: 
       (* Initializes THIS(TextHolder) to be large enough to hold the
        * chars of T, and then copies the chars of T to
        * THIS(TextHolder). You may want to explicitly free
        * THIS(TextHolder) before this operation, if this is a
        * reinitialization.  For convenience, it also exits the char
        * pointer.
        *)
       (# T: ^text; 
       enter T[]
       do ...
       exit charptr
       #);
     <B>get</B><A name="TextHolder.1:get.2(37)"></A><A name="get.2(37)"></A>:
       (* Return the chars of THIS(TextHolder) copied into the text T *)
       (# T: ^text;
       do ... 
       exit T[]
       #);
     <B>getChars</B><A name="TextHolder.1:getChars.2(38)"></A><A name="getChars.2(38)"></A>:
       (* Return a repetition, with the chars of THIS(TextHolder)
        * copied to it
        *)
       (# R: [0]@char;
       do ...
       exit R
       #);
     <B>length</B><A name="TextHolder.1:length.2(39)"></A><A name="length.2(39)"></A>: IntegerValue
       (* Return the string-length if THIS(TextHolder), i.e., the
        * number of chars before the NULL-char in the externally
        * allocated string.
        *)
       (# ... #);
     <B>inxPut</B><A name="TextHolder.1:inxPut.2(40)"></A><A name="inxPut.2(40)"></A>:
       (* Put ch at index inx in the externally allocated
        * TextHolder. The first char is at index 0. NOTICE: There is no
        * index check, it is up to the programmer to ensure, that it is
        * allowed to put at the given index.
        *)
       (# inx: @integer;
          ch: @char;
       enter (inx, ch) 
          ...
       #);
     <B>inxGet</B><A name="TextHolder.1:inxGet.2(41)"></A><A name="inxGet.2(41)"></A>:
       (* Obtain the char at the given index in the externally
        * allocated string.  The first char is at index 0.
        *)
       (# inx: @integer;
          ch: @char;
       enter inx
          ...
       exit ch
       #);
     &lt;&lt;SLOT TextHolderLib: attributes&gt;&gt;;
  #);

(* Other proposal:
 *   wString: 
 *     (# wcharptr: @integer
 *          {* The pointer to the external string *};
 *        ....
 *     #);
 *   wStringHolder: RefHolder
 *     (# type::wtext
 *     #);
 *   BSTR: wString(# .. #);
 *   BSTRHolder: refHolder
 *     (# type::BSTR #)
 *)

<B>wTextHolder</B><A name="wTextHolder.1(42)"></A>: Holder
  (* Externally allocated string used for pointer-to-wtext parameters
   * in COM interfaces.
   *)
  (# <B>wcharptr</B><A name="wTextHolder.1:wcharptr.2(43)"></A><A name="wcharptr.2(43)"></A>: @integer
       (* The pointer to the external string *);
     
     (* The following can be used to give a negative offset to store
      * length in. Used for modelling BSTR.
      * Notice, that the current implementation does NOT support
      * NULL chars in the middle of BSTR's.
      *)
     <B>BSTRoffset</B><A name="wTextHolder.1:BSTRoffset.2(44)"></A><A name="BSTRoffset.2(44)"></A>:&lt;integervalue;
     <B>BSTRoff</B><A name="wTextHolder.1:BSTRoff.2(45)"></A><A name="BSTRoff.2(45)"></A>: @BSTRoffset;
     
     <B>allocate</B><A name="wTextHolder.1:allocate.2(46)"></A><A name="allocate.2(46)"></A>: 
       (* Allocate length int16 (default 256) using malloc, and assign the
        * result to wcharptr. You may want to explicitly free THIS(wTextHolder)
        * before a reallocation.
        *)
       (# length: @integer;
       enter length 
       do ...
       #);
     <B>free</B><A name="wTextHolder.1:free.2(47)"></A><A name="free.2(47)"></A>: 
       (* Free the externally allocated string. The chars of the externally
        * allocated string will be unaccessible after this operation.
        *)
       (# ... #);
     <B>set</B><A name="wTextHolder.1:set.2(48)"></A><A name="set.2(48)"></A>: 
       (* Initializes THIS(wTextHolder) to be large enough to hold the
        * wchars of T, and then copies the wchars of T to
        * THIS(wTextHolder). You may want to explicitly free
        * THIS(wTextHolder) before this operation, if this is a
        * reinitialization.  For convenience, it also exits the wchar
        * pointer.
        *)
       (# T: ^wText; 
       enter T[]
       do ...
       exit wcharptr
       #);
     <B>get</B><A name="wTextHolder.1:get.2(49)"></A><A name="get.2(49)"></A>:
       (* Return the chars of THIS(wTextHolder) copied into the wText T *)
       (# T: ^wText;
       do ... 
       exit T[]
       #);
     <B>setText</B><A name="wTextHolder.1:setText.2(50)"></A><A name="setText.2(50)"></A>: 
       (* Initializes THIS(wTextHolder) to be large enough to hold the
        * chars of T, and then copies the chars of T to
        * THIS(wTextHolder). You may want to explicitly free
        * THIS(wTextHolder) before this operation, if this is a
        * reinitialization.  For convenience, it also exits the char
        * pointer.
        *)
       (# T: ^Text; 
       enter T[]
       do ...
       exit wcharptr
       #);
     <B>getText</B><A name="wTextHolder.1:getText.2(51)"></A><A name="getText.2(51)"></A>:
       (* Return the chars of THIS(wTextHolder) copied into the text T *)
       (# T: ^text;
       do ... 
       exit T[]
       #);
     <B>getChars</B><A name="wTextHolder.1:getChars.2(52)"></A><A name="getChars.2(52)"></A>:
       (* Return a repetition, with the wchars of THIS(wTextHolder)
        * copied to it
        *)
       (# R: [0]@wchar;
       do ...
       exit R
       #);
     <B>length</B><A name="wTextHolder.1:length.2(53)"></A><A name="length.2(53)"></A>: IntegerValue
       (* Return the string-length if THIS(wTextHolder), i.e., the
        * number of chars before the NULL-char in the externally
        * allocated string.
        *)
       (# ... #);
     <B>inxPut</B><A name="wTextHolder.1:inxPut.2(54)"></A><A name="inxPut.2(54)"></A>:
       (* Put ch at index inx in the externally allocated
        * wTextHolder. The first char is at index 0. NOTICE: There is no
        * index check, it is up to the programmer to ensure, that it is
        * allowed to put at the given index.
        *)
       (# inx: @integer;
          ch: @wchar;
       enter (inx, ch) 
          ...
       #);
     <B>inxGet</B><A name="wTextHolder.1:inxGet.2(55)"></A><A name="inxGet.2(55)"></A>:
       (* Obtain the char at the given index in the externally
        * allocated string.  The first char is at index 0.
        *)
       (# inx: @integer;
          ch: @wchar;
       enter inx
          ...
       exit ch
       #);
     &lt;&lt;SLOT wTextHolderLib: attributes&gt;&gt;;
  #);

<B>BSTRHolder</B><A name="BSTRHolder.1(56)"></A>: wTextHolder
  (# <B>BSTRoffset</B><A name="BSTRHolder.1:BSTRoffset.2(57)"></A><A name="BSTRoffset.2(57)"></A>::(# do 4-&gt;value #)#);
<B>BSTR</B><A name="BSTR.1(58)"></A>: BSTRHolder
  (# enter wcharptr exit wcharptr #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="40%" align="left"><ADDRESS>Holders Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
