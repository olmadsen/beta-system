<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<TITLE>Unicodetext Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT DEFER TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/printframe.js"></SCRIPT>
<BASE TARGET="_top">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="unicodetext">Unicodetext Interface</A></H1>
<PRE CLASS=interface>
ORIGIN '~beta/basiclib/betaenv';
BODY 'private/unicodebody'
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1997-98 
 *       All rights reserved.
 *
 * This fragment implements a UniCode text concept
 *)
---lib:attributes---
<B>wStream</B><A name="wStream.1(59)"></A>: 
  (# &lt;&lt;SLOT wStreamLib: attributes&gt;&gt;;
     <B>length</B><A name="wStream.1:length.2(60)"></A><A name="length.2(60)"></A>:&lt; integerValue (* returns the length of THIS(wStream) *)
       (#
       do -1-&gt;value; INNER length
       #);
     <B>position</B><A name="wStream.1:position.2(61)"></A><A name="position.2(61)"></A>: (* current position of THIS(wStream) *)
       (# 
       enter setPos
       exit getPos
       #);
     <B>eos</B><A name="wStream.1:eos.2(62)"></A><A name="eos.2(62)"></A>:&lt; (* returns 'true' if THIS(wStream) is at end-of-wStream *)
       booleanValue;
     <B>reset</B><A name="wStream.1:reset.2(63)"></A><A name="reset.2(63)"></A>: (* sets 'position' to zero *)
       (#
       do 0-&gt;setPos
       exit THIS(wStream)[]
       #);
     <B>peek</B><A name="wStream.1:peek.2(64)"></A><A name="peek.2(64)"></A>:&lt; (* looks at the next character of THIS(wStream) *)
       (# ch: @wchar
       do INNER peek
       exit ch
       #);
     <B>get</B><A name="wStream.1:get.2(65)"></A><A name="get.2(65)"></A>:&lt; (* reads a character from THIS(wStream) *)
       (# ch: @wchar
       do INNER get
       exit ch
       #);
     <B>getNonBlank</B><A name="wStream.1:getNonBlank.2(66)"></A><A name="getNonBlank.2(66)"></A>: 
       (* Reads first non-whitespace character from THIS(wStream).
        * If called at end-of-wStream the character 'ascii.fs' is
        * returned
        *)
       (# ch: @wchar;
          skipblanks: @scanWhiteSpace;
          testEOS: @EOS;
          getCh: @get;
       ...
       exit ch
       #);
     <B>getint</B><A name="wStream.1:getint.2(67)"></A><A name="getint.2(67)"></A>: integerValue
       (* Reads an integer: skips whitespace characters and
        * returns the following digits. 
        * 
        * See numberio.bet for more numerical output operations
        *)
       (# syntaxError:&lt; wStreamException
            (# 
            do 'getint: syntax error - looking at: "'-&gt;msg.append;
               peek-&gt;msg.put; '"'-&gt;msg.putline; INNER syntaxError
            #);
          geti: @... 
       do geti; INNER getint
       #);
     <B>getAtom</B><A name="wStream.1:getAtom.2(68)"></A><A name="getAtom.2(68)"></A>:&lt;
       (* Returns the next atom (i.e. sequence of non-white
        * characters - skipping leading blanks)
        *)
       (# txt: ^wtext;
       do &amp;wText[]-&gt;txt[]; INNER getAtom;
       exit txt[]
       #);
     <B>getline</B><A name="wStream.1:getline.2(69)"></A><A name="getline.2(69)"></A>:&lt;
       (* Reads a sequence of characters until nl-character
        * appears and returns the characters read.
        *)
       (# txt: ^wText;
       do &amp;wText[]-&gt;txt[]; INNER getline
       exit txt[]
       #);
     <B>asInt</B><A name="wStream.1:asInt.2(70)"></A><A name="asInt.2(70)"></A>:
       (* converts THIS(wText) to an integer value, ignoring
        * leading and trailing whitespace.  See numberio.bet for
        * more numerical conversion operations.
        *)
       (# i: @integer;
          syntaxError:&lt; wStreamException
            (# peekCh: @wchar
            enter peekCh
            do 'asInt: syntax error - looking at: "'-&gt;msg.append;
               peekCh-&gt;msg.put; '"'-&gt;msg.put;
               INNER syntaxError
            #)
       ...
       exit i
       #);
     <B>put</B><A name="wStream.1:put.2(71)"></A><A name="put.2(71)"></A>:&lt; (* writes a character to THIS(wStream) *)
       (# ch: @wchar
       enter ch
       do INNER put
       exit THIS(wStream)[]
       #);
     <B>newline</B><A name="wStream.1:newline.2(72)"></A><A name="newline.2(72)"></A>: (* writes the nl-character *) 
       (#
       do ascii.newline-&gt;put
       exit THIS(wStream)[]
       #);
     <B>putint</B><A name="wStream.1:putint.2(73)"></A><A name="putint.2(73)"></A>: 
       (* Writes an integer to THIS(wStream); The format may be
        * controlled by the 'signed', 'blankSign', 'width',
        * 'adjustLeft' and 'zeroPadding' variable attributes.
        * 'width' is extended if it is too small.  Examples:
        * '10-&gt;putint' yields: '10'; '10*pi-&gt;putint(# do 10-&gt;width;
        * true-&gt;adjustLeft #)' yields: '10 '; and '10-&gt;putint(# do * 10-&gt;width; true-&gt;zeroPadding #)' yields: '0000000010'.
        * 
        * See numberio.bet for more numerical output operations
        *)
       (# n: @integer;
          signed: @boolean
            (* If integer is positive, a '+' will always be
             * displayed
             *);
          blankSign: @boolean 
            (* If integer is positive, a ' ' space is displayed as
             * the sign.  Ignored if 'signed=true'
             *);
          width: @integer
            (* Minimum width *);
          adjustLeft: @boolean
            (* Specifies if the number is to be aligned left or
             * right, if padding of spaces is necessary to fill up
             * the specified width.
             *);
          zeroPadding: @boolean
            (* width is padded with leading zero instead of
             * spaces.  Ignored if 'adjustLeft=true'
             *);
          format:&lt; (# do INNER format #);
          puti: @...
       enter n
       do 1-&gt;width; format; INNER putint; puti
       exit THIS(wStream)[]
       #);
     <B>putText</B><A name="wStream.1:putText.2(74)"></A><A name="putText.2(74)"></A>:&lt; (* Writes a wText to THIS(wStream). *)
       (# txt: ^wText
       enter txt[]
       do (if txt[]&lt;&gt;NONE then INNER puttext if)
       exit THIS(wStream)[]
       #);
     <B>putline</B><A name="wStream.1:putline.2(75)"></A><A name="putline.2(75)"></A>: 
       (* 'puttext' followed by 'newline' *)
       (# T: ^wText; putT: @puttext; newL: @newline
       enter T[]
       do INNER putline; T[]-&gt;putT; newL
       exit THIS(wStream)[]
       #);
     <B>scan</B><A name="wStream.1:scan.2(76)"></A><A name="scan.2(76)"></A>: 
       (* Scan chars from current position in THIS(wStream) while
        * '(ch-&gt;while)=true'; perform INNER for each char being
        * scanned
        *)
       (# while:&lt;
            (# ch: @wchar; value: @boolean
            enter ch
            do true-&gt;value; INNER while
            exit value
            #);
          ch: @wchar;
          whilecondition: @while;
          testEOS: @EOS;
          getPeek: @peek;
          getCh: @get;
       ...
       exit THIS(wStream)[]
       #);
     <B>scanWhiteSpace</B><A name="wStream.1:scanWhiteSpace.2(77)"></A><A name="scanWhiteSpace.2(77)"></A>: scan 
       (* Scan whitespace characters *)
       (# while::&lt; (# do ch-&gt;ascii.isWhiteSpace-&gt;value #);
       do INNER scanWhiteSpace
       exit THIS(wStream)[]
       #);
     <B>scanAtom</B><A name="wStream.1:scanAtom.2(78)"></A><A name="scanAtom.2(78)"></A>: 
       (* Scan until first non-whitespace char.  Scan the next
        * sequence of non-whitespace chars.  Stop at first
        * whitespace char.  For each non-whitespace char an INNER
        * is performed. Usage: 'scanAtom(# do ch-&gt;&lt;destination&gt; #)'
        *)
       (# ch: @wchar;
       ...
       exit THIS(wStream)[]
       #);
     <B>scanToNl</B><A name="wStream.1:scanToNl.2(79)"></A><A name="scanToNl.2(79)"></A>: 
       (* Scan all chars in current line including newline char *)
       (# ch: @wchar; getCh: @get;
       ...
       exit THIS(wStream)[]
       #);
     <B>wStreamException</B><A name="wStream.1:wStreamException.2(80)"></A><A name="wStreamException.2(80)"></A>: exception
       (# do INNER wStreamException #);
     <B>EOSerror</B><A name="wStream.1:EOSerror.2(81)"></A><A name="EOSerror.2(81)"></A>:&lt; wStreamException
       (* Raised from 'get' and 'peek' when attempted to read past
        * the end of the wStream.
        *)
       (# 
       do 'Attempt to read past end-of-wStream'-&gt;msg.putline; 
          INNER EOSerror
       #);
     <B>otherError</B><A name="wStream.1:otherError.2(82)"></A><A name="otherError.2(82)"></A>:&lt; wStreamException
       (* Raised when some other kind of wStream error apart from
        * the one mentioned above occurs.
        *);
     <B>getPos</B><A name="wStream.1:getPos.2(83)"></A><A name="getPos.2(83)"></A>:&lt; (* returns current position of THIS(wStream) *)
       integerValue;
     <B>setPos</B><A name="wStream.1:setPos.2(84)"></A><A name="setPos.2(84)"></A>:&lt; (* sets current position in THIS(wStream) to 'p' *)
       (# p: @integer
       enter p
       do INNER setPos
       exit THIS(wStream)[]
       #)
  #); (* pattern wStream *)

(*****  wText pattern **********************************************)
<B>wText</B><A name="wText.1(85)"></A>: wStream
  (* A wText is a sequence of characters.  Let 'T: @wText'. The
   * range of 'T' is '[1,T.length]'.  A wText can be initialized by
   * executing 'T.clear' or by assigning it another (initialized)
   * wText.  A wText-constant has the form 'foo'.  The 'wText' pattern
   * is primarily intended for small wTexts but there is no upper
   * limit in the size. However, most of the operations becomes
   * less efficient with larger wTexts.
   *)
  (# &lt;&lt;SLOT wTextLib: attributes&gt;&gt;;
     <B>length</B><A name="wText.1:length.2(86)"></A><A name="length.2(86)"></A>::&lt; (* Returns the length of THIS(wText) *) 
       (# do lgth-&gt;value; INNER length #);
     <B>eos</B><A name="wText.1:eos.2(87)"></A><A name="eos.2(87)"></A>::&lt;(# ... #);
     <B>empty</B><A name="wText.1:empty.2(88)"></A><A name="empty.2(88)"></A>: 
       (# exit (lgth = 0) #);
     <B>clear</B><A name="wText.1:clear.2(89)"></A><A name="clear.2(89)"></A>: (* Sets the length and position of THIS(wText) to zero *)
       (#
       do 0-&gt;pos-&gt;lgth
       exit THIS(wText)[]
       #);
     <B>equal</B><A name="wText.1:equal.2(90)"></A><A name="equal.2(90)"></A>: booleanValue
       (* Tests if THIS(wText) is equal to the entered wText.  If
        * 'NCS' is further bound to 'trueObject', the comparison
        * will be done Non Case Sensitive.
        *)
       (# txt: ^wText;
          NCS:&lt; booleanObject
       enter txt[]
       ...
       #);
     <B>equalNCS</B><A name="wText.1:equalNCS.2(91)"></A><A name="equalNCS.2(91)"></A>: equal
       (* As 'equal', except the the comparison will be done Non
        * Case Sensitive
        *)
       (# NCS:: trueObject #);
     <B>less</B><A name="wText.1:less.2(92)"></A><A name="less.2(92)"></A>: booleanValue
       (* Tests whether the entered wText 'T1[1: length]' is less
        * than 'THIS(wText)[1: T1.length]'.  The lexicographical
        * ordering is used.
        *)
       (# T1: ^wText
       enter T1[]
       ...
       #);
     <B>greater</B><A name="wText.1:greater.2(93)"></A><A name="greater.2(93)"></A>: booleanValue
       (* Tests whether the entered wText 'T1[1: length]' is
        * greater than 'THIS(wText)[1: T1.length]'.  The
        * lexicographical ordering is used.
        *)
       (# T1: ^wText
       enter T1[]
       ...
       #);
     <B>peek</B><A name="wText.1:peek.2(94)"></A><A name="peek.2(94)"></A>::&lt;
       (* Returns the character at current position; does not
        * update 'position'
        *)
       (# ... #);
     <B>get</B><A name="wText.1:get.2(95)"></A><A name="get.2(95)"></A>::&lt;
       (* Returns the character at current position; increments
        * 'position'
        *) 
       (# ... #);
     <B>inxGet</B><A name="wText.1:inxGet.2(96)"></A><A name="inxGet.2(96)"></A>: wcharValue
       (* Returns the character at position 'i' *)
       (# i: @integer;
          iget: @...
       enter i
       do iget
       #);
     <B>getAtom</B><A name="wText.1:getAtom.2(97)"></A><A name="getAtom.2(97)"></A>::&lt;
       (* Returns the next atom (i.e. sequence of non-white
        * characters - skipping leading blanks)
        *)
       (# ... #);
     <B>getline</B><A name="wText.1:getline.2(98)"></A><A name="getline.2(98)"></A>::&lt;
       (* Reads a sequence of characters until nl-character
        * appears and returns the characters read.
        *)
       (# ... #);
     <B>put</B><A name="wText.1:put.2(99)"></A><A name="put.2(99)"></A>::&lt;
       (* writes the character 'ch' at current position in
        * THIS(wText); increments 'position'
        *) 
       (# ... #);
     <B>inxPut</B><A name="wText.1:inxPut.2(100)"></A><A name="inxPut.2(100)"></A>: 
       (* Replaces the character at position 'i' *)
       (# ch: @wchar;
          i: @integer;
          iput: @...
       enter (ch,i)
       do iput
       exit THIS(wText)[]
       #);
     <B>puttext</B><A name="wText.1:puttext.2(101)"></A><A name="puttext.2(101)"></A>::&lt;(# ... #);
     <B>append</B><A name="wText.1:append.2(102)"></A><A name="append.2(102)"></A>: 
       (* Appends a wText to THIS(wText); does not change 'position'
        *)
       (# T1: ^wText
       enter T1[]
       ...
       exit THIS(wText)[]
       #);
     <B>prepend</B><A name="wText.1:prepend.2(103)"></A><A name="prepend.2(103)"></A>: 
       (* Inserts the wText in 'T1' in front of THIS(wText); updates
        * current position to 'position+T1.length' if 'position&gt;0'
        *)
       (# T1: ^wText
       enter T1[]
       ...
       exit THIS(wText)[]
       #);
     <B>insert</B><A name="wText.1:insert.2(104)"></A><A name="insert.2(104)"></A>: 
       (* Inserts a wText before the character at position 'inx'.
        * Note: inx&lt;1 means inx=1; inx&gt;length means inx=length+1.
        * If 'position&gt;=inx' then 'position+T1.length-&gt;position'.
        *)
       (# T1: ^wText;
          inx: @integer
       enter (T1[],inx)
       ...
       exit THIS(wText)[]
       #);
     <B>delete</B><A name="wText.1:delete.2(105)"></A><A name="delete.2(105)"></A>: 
       (* Deletes THIS(wText)[i: j]; updates current position:
        *      i&lt;=position&lt;j =&gt; i-1-&gt;position
        *      j&lt;=position   =&gt; position-(j-i+1)-&gt;position
        *)
       (# i,j: @integer; 
          deleteT: @...
       enter (i,j)
       do deleteT
       exit THIS(wText)[]
       #);
     <B>makeLC</B><A name="wText.1:makeLC.2(106)"></A><A name="makeLC.2(106)"></A>: (* Converts all characters to lower case *)
       (# ...
       exit THIS(wText)[]
       #);
     <B>makeUC</B><A name="wText.1:makeUC.2(107)"></A><A name="makeUC.2(107)"></A>: 
       (* Converts all characters to upper case *)
       (# ...
       exit THIS(wText)[]
       #);
     <B>sub</B><A name="wText.1:sub.2(108)"></A><A name="sub.2(108)"></A>:
       (* Returns a copy of THIS(wText)[i:j].  If 'i&lt;1', 'i' is
        * adjusted to 1. If 'j&gt;length', 'j' is adjusted to
        * 'length'.  If (after adjustment) 'i&gt;j', an empty wText is
        * returned.
        *)
       (# i,j: @integer; T1: ^wText;
          subI: @...
       enter (i,j)
       do subI
       exit T1[]
       #);
     <B>copy</B><A name="wText.1:copy.2(109)"></A><A name="copy.2(109)"></A>: 
       (# T1: ^wText;
          copyI: @...
       do copyI
       exit T1[]
       #);
     <B>scanAll</B><A name="wText.1:scanAll.2(110)"></A><A name="scanAll.2(110)"></A>: 
       (* Scans all the elements in THIS(wText).  For 'ch' in '[1:
        * THIS(wText).length]' do INNER
        *)
       (# ch: @wchar
       do (for i: lgth repeat T[i]-&gt;ch; INNER scanAll for)
       exit THIS(wText)[]
       #);
     <B>find</B><A name="wText.1:find.2(111)"></A><A name="find.2(111)"></A>:
       (* find all occurrences of the character 'ch' in
        * THIS(wText), executing INNER for each occurrence found,
        * beginning at 'THIS(wText).position'.  'inx' will contain
        * the position of each 'ch' in THIS(wText).  If 'NCS' is
        * further bound to 'trueObject', the comparison will be
        * done Non Case Sensitive.  If 'from' is further bound, the
        * search will begin at position 'from'.
        *)
       (# ch: @wchar;
          inx: @integer;
          NCS:&lt; booleanObject;
          from:&lt; integerObject(# do pos-&gt;value; INNER from #)
       enter ch
       ...
       exit THIS(wText)[]
       #);
     <B>findAll</B><A name="wText.1:findAll.2(112)"></A><A name="findAll.2(112)"></A>: find
       (* As 'find', except that the entire wText will be searched.
        * Replaces 'findCh' in previous versions of betaenv (v1.4
        * and earlier)
        *)
       (# from:: (# do 0-&gt;value #)
       do INNER findAll
       #);
     <B>findwText</B><A name="wText.1:findwText.2(113)"></A><A name="findwText.2(113)"></A>:
       (* find all occurrences of the 'txt' in THIS(wText),
        * executing INNER for each occurrence found, beginning at
        * 'THIS(wText).position'.  'inx' will contain the position
        * of the first character of each occurrence found
        * THIS(wText).  If 'NCS' is further bound to 'trueObject',
        * the comparison will be done Non Case Sensitive.  If
        * 'from' is further bound, the search will begin at
        * position 'from'.
        *)
       (# txt: ^wText;
          inx: @integer;
          NCS:&lt; booleanObject;
          from:&lt; integerObject(# do pos-&gt;value; INNER from #)
       enter txt[]
       ...
       exit THIS(wText)[]
       #);
     <B>findwTextAll</B><A name="wText.1:findwTextAll.2(114)"></A><A name="findwTextAll.2(114)"></A>: findwText
       (* As 'findwText', except that the entire wText will be
        * searched
        *)
       (# from:: (# do 0-&gt;value #)
       do INNER findwTextAll
       #);
     <B>extend</B><A name="wText.1:extend.2(115)"></A><A name="extend.2(115)"></A>: 
       (* Extend THIS(wText) with 'L' (undefined) chars. Notice
        * that it is only the representation of the THIS(wText),
        * that is extended, the 'length' and 'position' are not
        * changed.
        *)
       (# L: @integer
       enter L do L-&gt;T.extend
       exit THIS(wText)[]
       #);
     <B>indexError</B><A name="wText.1:indexError.2(116)"></A><A name="indexError.2(116)"></A>:&lt; wStreamException
       (* Raised from 'Check' when the index goes outside the
        * range of the wText. Message: "Index error in wText!".
        *)
       (# inx: @integer 
       enter inx
       ...
       #);
     <B>EOSerror</B><A name="wText.1:EOSerror.2(117)"></A><A name="EOSerror.2(117)"></A>::&lt;
       (* Raised from 'get' and 'peek' when the end of the wStream is
        * passed.
        *) 
       (# ... #);
     <B>otherError</B><A name="wText.1:otherError.2(118)"></A><A name="otherError.2(118)"></A>::&lt;
       (* Raised when an error other than the Index-/EOSerror
        * occurs.
        *) 
       (# ... #);
     <B>setPos</B><A name="wText.1:setPos.2(119)"></A><A name="setPos.2(119)"></A>::&lt;(# ... #);
     <B>getPos</B><A name="wText.1:getPos.2(120)"></A><A name="getPos.2(120)"></A>::&lt;(# do pos-&gt;value; INNER getPos #);
     (* Private attributes: !!OBS!! The 3 attributes 'T', 'lgth'
      * and 'pos' declared below MUST be the first data items
      * declared in 'wStream' and 'wText' since their addresses are
      * hardcoded into the compiler.
      *)
     <B>T</B><A name="wText.1:T.2(121)"></A><A name="T.2(121)"></A>: [16] @wchar;
     <B>lgth</B><A name="wText.1:lgth.2(122)"></A><A name="lgth.2(122)"></A>,<B>pos</B><A name="wText.1:pos.2(123)"></A><A name="pos.2(123)"></A>: (* 16 is default size *) @integer;
     <B>setT</B><A name="wText.1:setT.2(124)"></A><A name="setT.2(124)"></A>: (# enter T do T.range-&gt;lgth-&gt;pos #);
     <B>setAscii</B><A name="wText.1:setAscii.2(125)"></A><A name="setAscii.2(125)"></A>:
       (# t: ^ text
       enter T[]
       do T.scanAll(#do ch -&gt; put #)
       #);
     <B>asAscii</B><A name="wText.1:asAscii.2(126)"></A><A name="asAscii.2(126)"></A>:
       (# T: @text
       do scanAll(#do ch -&gt; T.put #)
       exit T[]
       #)
  enter setT
  exit T[1<A name="wText.1:1.2(127)"></A><A name="1.2(127)"></A>: lgth]
  #) (* Pattern wText *); 

<B>ascii2wText</B><A name="ascii2wText.1(128)"></A>:
  (# <B>T1</B><A name="ascii2wText.1:T1.2(129)"></A><A name="T1.2(129)"></A>: ^text; <B>T2</B><A name="ascii2wText.1:T2.2(130)"></A><A name="T2.2(130)"></A>: @wText
  enter T1[]
  do T1.scanAll(#do ch -&gt; T2.put #);  
  exit T2[]
  #);
---textLib:attributes---
<B>aswText</B><A name="aswText.1(131)"></A>:
  (# <B>UT</B><A name="aswText.1:UT.2(132)"></A><A name="UT.2(132)"></A>: @wText
  do scanAll(#do ch -&gt; UT.put #)
  exit UT[]
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="40%" align="left"><ADDRESS>Unicodetext Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
