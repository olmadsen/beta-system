<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Comlib Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="ObjIdl.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Comlib Interface</H1>
<PRE CLASS=interface>
ORIGIN 'ObjIdl';
INCLUDE 'comtypes';
BODY 'private/comlibbody';
--LIB: attributes--

(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-98
 *       All rights reserved.
 *)

<B>CoInitialize</B><A name="CoInitialize.1(2073)"></A>: external
  (# <B>LPVoid</B><A name="CoInitialize.1:LPVoid.2(2074)"></A><A name="LPVoid.2(2074)"></A>,<B>hresult</B><A name="CoInitialize.1:hresult.2(2075)"></A><A name="hresult.2(2075)"></A>: @Int32;
  enter LPVoid
  do CallStd; 
  exit hresult
  #);
<B>CoUninitialize</B><A name="CoUninitialize.1(2076)"></A>: external
  (# 
  do CallStd;
  #);

<B>CLSIDFromProgID</B><A name="CLSIDFromProgID.1(2077)"></A>: 
  (# <B>progid</B><A name="CLSIDFromProgID.1:progid.2(2078)"></A><A name="progid.2(2078)"></A>: ^BSTR;
     <B>theclsid</B><A name="CLSIDFromProgID.1:theclsid.2(2079)"></A><A name="theclsid.2(2079)"></A>: ^CLSID;
  enter progid[]
  do ...
  exit theclsid[]
  #);

<B>CoCreateInstance</B><A name="CoCreateInstance.1(2080)"></A>:
  (# <B>theclsid</B><A name="CoCreateInstance.1:theclsid.2(2081)"></A><A name="theclsid.2(2081)"></A>: ^CLSID; 
     <B>outer</B><A name="CoCreateInstance.1:outer.2(2082)"></A><A name="outer.2(2082)"></A>: ^IUnknown;
     <B>Flags</B><A name="CoCreateInstance.1:Flags.2(2083)"></A><A name="Flags.2(2083)"></A>: @Int32;
     <B>theiid</B><A name="CoCreateInstance.1:theiid.2(2084)"></A><A name="theiid.2(2084)"></A>: ^IID;
     <B>Iptr</B><A name="CoCreateInstance.1:Iptr.2(2085)"></A><A name="Iptr.2(2085)"></A>: ^IUnknown;
  enter (theclsid[], outer[], Flags, theiid[])
  do ...  
  exit Iptr[]
  #);

(* ole2.h *)
(* WINOLEAPI OleInitialize(LPVOID pvReserved); *)
<B>OleInitialize</B><A name="OleInitialize.1(2086)"></A>: external
  (# <B>pvReserved</B><A name="OleInitialize.1:pvReserved.2(2087)"></A><A name="pvReserved.2(2087)"></A>: @integer;
     <B>hResult</B><A name="OleInitialize.1:hResult.2(2088)"></A><A name="hResult.2(2088)"></A>: @integer;
  enter pvReserved
  do CallStd;
  exit hResult
  #);

(* WINOLEAPI_(void) OleUninitialize(void); *)
<B>OleUninitialize</B><A name="OleUninitialize.1(2089)"></A>: external
  (# 
  do CallStd;
  #);

(* Drag/Drop APIs *)

<B>RegisterDragDrop</B><A name="RegisterDragDrop.1(2090)"></A>: external
  (# <B>hwnd</B><A name="RegisterDragDrop.1:hwnd.2(2091)"></A><A name="hwnd.2(2091)"></A>: @integer; (* HWND *)
     <B>pDropTarget</B><A name="RegisterDragDrop.1:pDropTarget.2(2092)"></A><A name="pDropTarget.2(2092)"></A>: @integer; (* LPDROPTARGET *)
     <B>hRes</B><A name="RegisterDragDrop.1:hRes.2(2093)"></A><A name="hRes.2(2093)"></A>: @integer;
  enter (hwnd, pDropTarget)
  do callStd;
  exit hRes
  #);
     
<B>RevokeDragDrop</B><A name="RevokeDragDrop.1(2094)"></A>: external
  (# <B>hwnd</B><A name="RevokeDragDrop.1:hwnd.2(2095)"></A><A name="hwnd.2(2095)"></A>: @integer; (* HWND *)
     <B>hRes</B><A name="RevokeDragDrop.1:hRes.2(2096)"></A><A name="hRes.2(2096)"></A>: @integer;
  enter hwnd
  do callStd;
  exit hRes
  #);

<B>DoDragDrop</B><A name="DoDragDrop.1(2097)"></A>: external
  (# <B>pDataObj</B><A name="DoDragDrop.1:pDataObj.2(2098)"></A><A name="pDataObj.2(2098)"></A>: @integer; (* LPDATAOBJECT *)
     <B>pDropSource</B><A name="DoDragDrop.1:pDropSource.2(2099)"></A><A name="pDropSource.2(2099)"></A>: @integer; (* LPDROPSOURCE *)
     <B>dwOKEffects</B><A name="DoDragDrop.1:dwOKEffects.2(2100)"></A><A name="dwOKEffects.2(2100)"></A>: @integer; (* DWORD *)
     <B>pdwEffect</B><A name="DoDragDrop.1:pdwEffect.2(2101)"></A><A name="pdwEffect.2(2101)"></A>: @integer; (* pdwEffect *)
     <B>hRes</B><A name="DoDragDrop.1:hRes.2(2102)"></A><A name="hRes.2(2102)"></A>: @integer;
  enter (pDataObj, pDropSource, dwOKEffects, pdwEffect)
  do callStd;
  exit hRes
  #);

(* Clipboard APIs *)

<B>OleSetClipboard</B><A name="OleSetClipboard.1(2103)"></A>: external
  (# <B>pDataObj</B><A name="OleSetClipboard.1:pDataObj.2(2104)"></A><A name="pDataObj.2(2104)"></A>: @integer; (* LPDATAOBJECT *)
     <B>hRes</B><A name="OleSetClipboard.1:hRes.2(2105)"></A><A name="hRes.2(2105)"></A>: @integer;
  enter pDataObj
  do callStd;
  exit hRes
  #);

<B>OleGetClipboard</B><A name="OleGetClipboard.1(2106)"></A>: external
  (# <B>ppDataObj</B><A name="OleGetClipboard.1:ppDataObj.2(2107)"></A><A name="ppDataObj.2(2107)"></A>: @integer;
     <B>hRes</B><A name="OleGetClipboard.1:hRes.2(2108)"></A><A name="hRes.2(2108)"></A>: @integer;
  enter ppDataObj
  do callStd
  exit hRes
  #);

<B>OleFlushClipboard</B><A name="OleFlushClipboard.1(2109)"></A>: external
  (# <B>hRes</B><A name="OleFlushClipboard.1:hRes.2(2110)"></A><A name="hRes.2(2110)"></A>: @integer;
  do callStd;
  exit hRes
  #);

<B>OleIsCurrentClipboard</B><A name="OleIsCurrentClipboard.1(2111)"></A>: external
  (# <B>pDataObj</B><A name="OleIsCurrentClipboard.1:pDataObj.2(2112)"></A><A name="pDataObj.2(2112)"></A>: @integer; (* LPDATAOBJECT *)
     <B>hRes</B><A name="OleIsCurrentClipboard.1:hRes.2(2113)"></A><A name="hRes.2(2113)"></A>: @integer;
  enter pDataObj
  do callStd;
  exit hRes
  #);

(* objbase.h *)
<B>CoRegisterClassObject</B><A name="CoRegisterClassObject.1(2114)"></A>: external
  
  (# <B>rclsid</B><A name="CoRegisterClassObject.1:rclsid.2(2115)"></A><A name="rclsid.2(2115)"></A>: @integer
       (* Class identifier (CLSID) to be registered *);
     <B>pUnk</B><A name="CoRegisterClassObject.1:pUnk.2(2116)"></A><A name="pUnk.2(2116)"></A>: @integer
       (* Pointer to the class object *);
     <B>dwClsContext</B><A name="CoRegisterClassObject.1:dwClsContext.2(2117)"></A><A name="dwClsContext.2(2117)"></A>: @integer
       (* Context for running executable code *);
     <B>flags</B><A name="CoRegisterClassObject.1:flags.2(2118)"></A><A name="flags.2(2118)"></A>: @integer
       (* How to connect to the class object *);
     <B>lpdwRegister</B><A name="CoRegisterClassObject.1:lpdwRegister.2(2119)"></A><A name="lpdwRegister.2(2119)"></A>: @integer
       (* Pointer to the value returned *);
     <B>result</B><A name="CoRegisterClassObject.1:result.2(2120)"></A><A name="result.2(2120)"></A>: @integer
       (* This function supports the standard return values E_INVALIDARG,
        * E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following: S_OK:
        * The class object was registered successfully.  CO_E_OBJISREG:
        * Already registered in the class object table.
        *); 
  enter (rclsid,pUnk,dwClsContext,flags,lpdwRegister)
  do callStd;
  exit result
  #);

<B>CoRevokeClassObject</B><A name="CoRevokeClassObject.1(2121)"></A>: external
  (# <B>lpdwRegister</B><A name="CoRevokeClassObject.1:lpdwRegister.2(2122)"></A><A name="lpdwRegister.2(2122)"></A>: @integer
       (* Pointer to the value returned in CoRegisterClassObject *);
     <B>result</B><A name="CoRevokeClassObject.1:result.2(2123)"></A><A name="result.2(2123)"></A>: @integer;
  enter lpdwRegister
  do callStd
  exit result
  #);

(* oleauto.h *)
<B>RegisterActiveObject</B><A name="RegisterActiveObject.1(2124)"></A>: external
  (# <B>punk</B><A name="RegisterActiveObject.1:punk.2(2125)"></A><A name="punk.2(2125)"></A>: @integer; (* IUnknown FAR* *)
     <B>rclsid</B><A name="RegisterActiveObject.1:rclsid.2(2126)"></A><A name="rclsid.2(2126)"></A>: @integer; (* REFCLSID *)
     <B>dwFlags</B><A name="RegisterActiveObject.1:dwFlags.2(2127)"></A><A name="dwFlags.2(2127)"></A>: @integer; (* DWORD *)
     <B>pdwRegister</B><A name="RegisterActiveObject.1:pdwRegister.2(2128)"></A><A name="pdwRegister.2(2128)"></A>: @integer; (* unsigned long FAR* *)
     <B>result</B><A name="RegisterActiveObject.1:result.2(2129)"></A><A name="result.2(2129)"></A>: @integer;
  enter (punk, rclsid, dwFlags, pdwRegister)
  do callStd;
  exit result
  #);

<B>RevokeActiveObject</B><A name="RevokeActiveObject.1(2130)"></A>: external
  (# <B>dwRegister</B><A name="RevokeActiveObject.1:dwRegister.2(2131)"></A><A name="dwRegister.2(2131)"></A>: @integer; (* unsigned long *)
     <B>pvReserved</B><A name="RevokeActiveObject.1:pvReserved.2(2132)"></A><A name="pvReserved.2(2132)"></A>: @integer; (* void FAR *)
     <B>result</B><A name="RevokeActiveObject.1:result.2(2133)"></A><A name="result.2(2133)"></A>: @integer;
  enter (dwRegister, pvReserved)
  do callStd;
  exit result
  #);

(* SHLOBJ.H 
 *
 * Task allocator API
 *
 * All the shell extensions MUST use the task allocator (see OLE 2.0
 * programming guild for its definition) when they allocate or free
 * memory objects (mostly ITEMIDLIST) that are returned across any
 * shell interfaces. There are two ways to access the task allocator
 * from a shell extension depending on whether or not it is linked with
 * OLE32.DLL or not (purely for efficiency).
 *
 * (1) A shell extension which calls any OLE API (i.e., linked with
 *     OLE32.DLL) should call OLE's task allocator (by retrieving
 *     the task allocator by calling CoGetMalloc API).
 *
 * (2) A shell extension which does not call any OLE API (i.e., not linked
 *     with OLE32.DLL) should call the shell task allocator API (defined
 *     below), so that the shell can quickly loads it when OLE32.DLL is not
 *     loaded by any application at that point.
 *)

(* WINSHELLAPI HRESULT WINAPI SHGetMalloc(LPMALLOC * ppMalloc); *)
<B>SHGetMalloc</B><A name="SHGetMalloc.1(2134)"></A>: external
  (# <B>ppMalloc</B><A name="SHGetMalloc.1:ppMalloc.2(2135)"></A><A name="ppMalloc.2(2135)"></A>: @integer; 
     <B>result</B><A name="SHGetMalloc.1:result.2(2136)"></A><A name="result.2(2136)"></A>: @integer;
  enter ppMalloc
  do callStd;
  exit result
  #);

(* WINSHELLAPI HRESULT WINAPI 
 * SHGetSpecialFolderLocation(HWND hwndOwner, int nFolder, LPITEMIDLIST *ppidl)
 * 
 * Caller should call SHFree to free the returned pidl.
 *)
<B>SHGetSpecialFolderLocation</B><A name="SHGetSpecialFolderLocation.1(2137)"></A>: external
  (# <B>hwndOwner</B><A name="SHGetSpecialFolderLocation.1:hwndOwner.2(2138)"></A><A name="hwndOwner.2(2138)"></A>: @integer;       
     <B>nFolder</B><A name="SHGetSpecialFolderLocation.1:nFolder.2(2139)"></A><A name="nFolder.2(2139)"></A>: @integer;         
     <B>ppidl</B><A name="SHGetSpecialFolderLocation.1:ppidl.2(2140)"></A><A name="ppidl.2(2140)"></A>: @integer;
     <B>result</B><A name="SHGetSpecialFolderLocation.1:result.2(2141)"></A><A name="result.2(2141)"></A>: @integer;
  enter (hwndOwner,nFolder,ppidl)
  do callStd;
  exit result
  #);

(* Helper function which returns a IShellFolder interface to the desktop
 * folder. This is equivalent to call CoCreateInstance with
 * CLSID_ShellDesktop.
 *
 *  CoCreateInstance(CLSID_Desktop, NULL,
 *                   CLSCTX_INPROC, IID_IShellFolder, &amp;pshf);
 *
 * WINSHELLAPI HRESULT WINAPI SHGetDesktopFolder(LPSHELLFOLDER *ppshf);
 *)
<B>SHGetDesktopFolder</B><A name="SHGetDesktopFolder.1(2142)"></A>: external
  (# <B>ppshf</B><A name="SHGetDesktopFolder.1:ppshf.2(2143)"></A><A name="ppshf.2(2143)"></A>: @integer;
     <B>result</B><A name="SHGetDesktopFolder.1:result.2(2144)"></A><A name="result.2(2144)"></A>: @integer;
  enter ppshf
  do callStd;
  exit result
  #);

(* oledlg.h *)
<B>OleUIAddVerbMenu</B><A name="OleUIAddVerbMenu.1(2145)"></A>: external
  (# <B>lpOleObj</B><A name="OleUIAddVerbMenu.1:lpOleObj.2(2146)"></A><A name="lpOleObj.2(2146)"></A>,<B>lpszShortType</B><A name="OleUIAddVerbMenu.1:lpszShortType.2(2147)"></A><A name="lpszShortType.2(2147)"></A>,<B>hMenu</B><A name="OleUIAddVerbMenu.1:hMenu.2(2148)"></A><A name="hMenu.2(2148)"></A>,<B>uPos</B><A name="OleUIAddVerbMenu.1:uPos.2(2149)"></A><A name="uPos.2(2149)"></A>,<B>uIDVerbMin</B><A name="OleUIAddVerbMenu.1:uIDVerbMin.2(2150)"></A><A name="uIDVerbMin.2(2150)"></A>,<B>uIDVerbMax</B><A name="OleUIAddVerbMenu.1:uIDVerbMax.2(2151)"></A><A name="uIDVerbMax.2(2151)"></A>,<B>
     bAddConvert</B><A name="OleUIAddVerbMenu.1:bAddConvert.2(2152)"></A><A name="bAddConvert.2(2152)"></A>,<B> idConvert</B><A name="OleUIAddVerbMenu.1:idConvert.2(2153)"></A><A name="idConvert.2(2153)"></A>,<B> lphMenu</B><A name="OleUIAddVerbMenu.1:lphMenu.2(2154)"></A><A name="lphMenu.2(2154)"></A>: @integer;
     <B>result</B><A name="OleUIAddVerbMenu.1:result.2(2155)"></A><A name="result.2(2155)"></A>: @integer;
  enter (lpOleObj, lpszShortType, hMenu, uPos, uIDVerbMin, uIDVerbMax, 
     bAddConvert, idConvert, lphMenu)
  do callStd;
  exit result
  #);

(* objbase.h *)
(*
 * Common typedefs for paramaters used in Storage API's, gleamed from
 * storage.h.
 * Also contains Storage error codes, which should be moved into the storage
 * idl files.
 *)

<B>CWCSTORAGENAME</B><A name="CWCSTORAGENAME.1(2156)"></A>: (# exit 32 #);

(* Storage instantiation modes *)
<B>STGM_DIRECT</B><A name="STGM_DIRECT.1(2157)"></A>: (# exit              0x00000000 #);
<B>STGM_TRANSACTED</B><A name="STGM_TRANSACTED.1(2158)"></A>: (# exit          0x00010000 #);
<B>STGM_SIMPLE</B><A name="STGM_SIMPLE.1(2159)"></A>: (# exit              0x08000000 #);

<B>STGM_READ</B><A name="STGM_READ.1(2160)"></A>: (# exit                0x00000000 #);
<B>STGM_WRITE</B><A name="STGM_WRITE.1(2161)"></A>: (# exit               0x00000001 #);
<B>STGM_READWRITE</B><A name="STGM_READWRITE.1(2162)"></A>: (# exit           0x00000002 #);

<B>STGM_SHARE_DENY_NONE</B><A name="STGM_SHARE_DENY_NONE.1(2163)"></A>: (# exit     0x00000040 #);
<B>STGM_SHARE_DENY_READ</B><A name="STGM_SHARE_DENY_READ.1(2164)"></A>: (# exit     0x00000030 #);
<B>STGM_SHARE_DENY_WRITE</B><A name="STGM_SHARE_DENY_WRITE.1(2165)"></A>: (# exit    0x00000020 #);
<B>STGM_SHARE_EXCLUSIVE</B><A name="STGM_SHARE_EXCLUSIVE.1(2166)"></A>: (# exit     0x00000010 #);

<B>STGM_PRIORITY</B><A name="STGM_PRIORITY.1(2167)"></A>: (# exit            0x00040000 #);
<B>STGM_DELETEONRELEASE</B><A name="STGM_DELETEONRELEASE.1(2168)"></A>: (# exit     0x04000000 #);

<B>STGM_NOSCRATCH</B><A name="STGM_NOSCRATCH.1(2169)"></A>: (# exit           0x00100000 #);

<B>STGM_CREATE</B><A name="STGM_CREATE.1(2170)"></A>: (# exit              0x00001000 #);
<B>STGM_CONVERT</B><A name="STGM_CONVERT.1(2171)"></A>: (# exit             0x00020000 #);
<B>STGM_FAILIFTHERE</B><A name="STGM_FAILIFTHERE.1(2172)"></A>: (# exit         0x00000000 #);

<B>STGM_NOSNAPSHOT</B><A name="STGM_NOSNAPSHOT.1(2173)"></A>: (# exit          0x00200000 #);

(* Storage API Prototypes *)

<B>StgCreateDocfile</B><A name="StgCreateDocfile.1(2174)"></A>: external
  (# <B>result</B><A name="StgCreateDocfile.1:result.2(2175)"></A><A name="result.2(2175)"></A>: @integer;
     <B>pwcsName</B><A name="StgCreateDocfile.1:pwcsName.2(2176)"></A><A name="pwcsName.2(2176)"></A>: ^wtext;
     <B>grfMode</B><A name="StgCreateDocfile.1:grfMode.2(2177)"></A><A name="grfMode.2(2177)"></A>,<B> reserved</B><A name="StgCreateDocfile.1:reserved.2(2178)"></A><A name="reserved.2(2178)"></A>: @integer;
     <B>ppstgOpen</B><A name="StgCreateDocfile.1:ppstgOpen.2(2179)"></A><A name="ppstgOpen.2(2179)"></A>: ^IStorageHolder;
  enter (pwcsName[], grfMode, reserved, ppstgOpen[])
  do callStd;
  exit result
  #);

<B>StgOpenStorage</B><A name="StgOpenStorage.1(2180)"></A>: external
  (# <B>pwcsName</B><A name="StgOpenStorage.1:pwcsName.2(2181)"></A><A name="pwcsName.2(2181)"></A>: ^wtext;
     <B>pstgPriority</B><A name="StgOpenStorage.1:pstgPriority.2(2182)"></A><A name="pstgPriority.2(2182)"></A>,<B> grfMode</B><A name="StgOpenStorage.1:grfMode.2(2183)"></A><A name="grfMode.2(2183)"></A>,<B> snbExclude</B><A name="StgOpenStorage.1:snbExclude.2(2184)"></A><A name="snbExclude.2(2184)"></A>,<B> reserved</B><A name="StgOpenStorage.1:reserved.2(2185)"></A><A name="reserved.2(2185)"></A>: @integer;
     <B>ppstgOpen</B><A name="StgOpenStorage.1:ppstgOpen.2(2186)"></A><A name="ppstgOpen.2(2186)"></A>: ^IStorageHolder;
     <B>result</B><A name="StgOpenStorage.1:result.2(2187)"></A><A name="result.2(2187)"></A>: @integer;
  enter (pwcsName[], pstgPriority, grfMode, snbExclude, reserved, ppstgOpen[])
  do callStd;
  exit result
  #);

<B>StgIsStorageFile</B><A name="StgIsStorageFile.1(2188)"></A>: external
  (# <B>pwcsName</B><A name="StgIsStorageFile.1:pwcsName.2(2189)"></A><A name="pwcsName.2(2189)"></A>: ^wtext;
     <B>result</B><A name="StgIsStorageFile.1:result.2(2190)"></A><A name="result.2(2190)"></A>: @integer;
  enter pwcsName[]
  do callStd;
  exit result
  #);

<B>ComErrorMessage</B><A name="ComErrorMessage.1(2191)"></A>: external
  (* Display "msg" followed by a human-readable explanation
   * of the error encoded in "hr".
   * Source: private/external/errormessage.cpp
   *)
  (# <B>msg</B><A name="ComErrorMessage.1:msg.2(2192)"></A><A name="msg.2(2192)"></A>: [0]@char;
     <B>hr</B><A name="ComErrorMessage.1:hr.2(2193)"></A><A name="hr.2(2193)"></A>: @int32;
  enter (msg, hr)
  do CallC
  #);

<B>Query</B><A name="Query.1(2194)"></A>: 
  (* More user-friendly version of QueryInterface than the 
   * autogenerated one in Unknwn.bet.
   *)
  (# <B>theIID</B><A name="Query.1:theIID.2(2195)"></A><A name="theIID.2(2195)"></A>: ^IID;  
     <B>theUnknown</B><A name="Query.1:theUnknown.2(2196)"></A><A name="theUnknown.2(2196)"></A>,<B> Iptr</B><A name="Query.1:Iptr.2(2197)"></A><A name="Iptr.2(2197)"></A>: ^IUnknown;
     <B>hr</B><A name="Query.1:hr.2(2198)"></A><A name="hr.2(2198)"></A>: @HRESULT;
  enter (theUnknown[], theIID[])
  do ...
  exit Iptr[]
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="33%" align="left"><ADDRESS>Interface Description</ADDRESS></TD>
<TD width="34%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="33%" align="right"><FONT size=-1><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></FONT></TD>
</TABLE>
<P></P>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="ObjIdl.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
