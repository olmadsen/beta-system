<H1>BETA Compiler Reference Manual</H1>
<A NAME=HEADING2-1></A>
<H1>Introduction</H1>
 <A NAME=MARKER-9-12>
<P> This manual describes version 5.4 of the BETA compiler
(corresponding to release 5.0 of the Mj&oslash;lner System). The
compiler implements most parts of the BETA language as described in <A
HREF="../bibliography/index.html#mmn93">[MMN93]</A>.

There are, however, some changes that have been made to BETA since
the publication of [MMN93]. These changes are described in:
<ul>
  <li><a href=../beta/beta.html>BETA Language Modifications</a>
</ul>

<P> A <A HREF="../basiclib/basiclib-32.html"> general interface to C 
and assembly language </A> is part of the libraries/compiler. </P> 

<P> The rest of this manual is organized as follows: Section 2
describes the simplest way of using the compiler. Section 3 describes
the organization of the basic BETA libraries. Section 4 describes the
files generated by the compiler.  Section 5 describes compile- and
run-time errors. These sections contain useful information for all
users. </P>

<P> The remaining sections are only for advanced users. In section 6,
a number of different arguments to the compiler are described. In
section 7, it is described how to instantiate machine dependent
configurations of a program. In section 8 it is described how code is
generated for multiple machines.</P>

<A NAME=HEADING2-11></A>
<H1>Simple Use of the Compiler</H1>

The following is an example of a very small BETA program.

<BETA CAP="hello.bet">
ORIGIN '~beta/basiclib/betaenv'
--- PROGRAM: descriptor ---
(#
do 'Welcome to Mjolner' -> putLine
#)
</BETA>

<P> Only the part between <CODE>(# ... #)</CODE> is BETA. The
<CODE>ORIGIN</CODE> specification:</P>

<BETA>
ORIGIN '~beta/basiclib/betaenv'
</BETA>

<P> describes that the fragment <CODE>betaenv</CODE> from the BETA
basic library (basiclib) is used. </P> 

<P> The fragment name and category:</P>

<BETA>
--- PROGRAM: descriptor ---
</BETA>

<P> describes that the BETA program is filled into a slot in betaenv
called PROGRAM. The BETA compiler is integrated with the
Mj&oslash;lner fragment system. The above BETA program is an example
of a BETA fragment. </P>

<P> Assume that the above BETA fragment is located in the file
<code>foo.bet</code>. The BETA fragment may then be compiled by
issuing the command
</P>

<BETA>
beta foo.bet
</BETA>

which will compile, assemble, and link the BETA fragment.  On most
platforms binary object code is generated directly.  In this case the
assembly phase is omitted.  For the HP platforms assembly code is
generated and assembled.  The final object code will be in the file
<code>foo</code>, which may be executed.

<P> How to invoke the compiler depends on whether Macintosh, PC or
UNIX is used. Details about the different variants of the BETA
compiler may be found in 
<A HREF="../bibliography/index.html#mia99-36">[MIA 99-36]</A>.
</P>
<A NAME=HEADING2-28></A>

<H1>The BETA Library</H1> <P> The BETA library is a collection of
patterns and objects that include input/output, a text concept, the
user interface toolkit, the metaprogramming system, a container
library, a system library, etc. The library is organized as
fragments. </P> <P> One part of the library contains the basic
patterns and objects which are used by most programs. This basic BETA
library is called basiclib and is described in 
<A HREF="../bibliography/index.html#mia90-8">[MIA90-8]</A>,
which also
describes the interface to C and assembly language. </P> <P> The
library basiclib contains a number of different fragments groups
containing basic patterns, a text concept, various functions and
control patterns, a file concept, etc. One of these fragment groups is
betaenv, which contains the basic patterns, the text concept, other
basic patterns and objects representing the screen and the
keyboard. All BETA programs must use betaenv, which has the form: </P>


<BETA CAP="betaenv.bet">
(# ...
   (* A lot of useful patterns *)
   ...
   <<SLOT LIB: attributes>>
   ...
   program: <<SLOT program: descriptor>>
   theProgram: ^|program;
do ...
   &|program[] -> theProgram[];
   theProgram;
   ...
#)
</BETA>

The LIB slot describes where most libraries are inserted. The program
slot describes where an ordinary user program is inserted (see section
6 for more explanation of this). 

<P> On UNIX, the BETA library is
often located in the directory <CODE>/usr/local/lib/beta</CODE>. </P>
<P> For Macintosh, the convention is that the BETA library is located
in a folder called <CODE>beta</CODE>. </P> <P> In the rest of this
manual, we assume that the basic library is located in
<CODE>/usr/local/lib/beta</CODE>. 

We also use the UNIX convention for denoting directories with the
character <CODE>/</CODE> to separate directory and file names.</P>

<P> When using the Mj&oslash;lner System, the BETA library must be
installed on the file system of the computer. BETA fragments will need
to refer to fragments in the BETA library. Since the location of the
BETA library may differ from machine to machine, a fragment may denote
the BETA library by means of the name:

<beta>
~beta
</BETA>

The file containing the <INX>betaenv</INX> fragment may then be denoted by

<beta>
~beta/basiclib/betaenv
</BETA>

On many UNIX systems, the BETA library is often placed in the
directory:

<BETA>/usr/local/lib/beta/basiclib</BETA>

In this case a fragment denotation like

<BETA>~beta/basiclib/betaenv</BETA>

then refers to the file

<BETA>/usr/local/lib/beta/basiclib/betaenv</BETA>

<P> The meaning of <code>~beta</code> can be changed by using the
<CODE>BETALIB</CODE> environment variable, see 
<A HREF="../bibliography/index.html#mia99-36">[MIA 99-36]</A>.</P>


<P> A program using betaenv may then look as follows:

<BETA CAP="hello.bet">
ORIGIN '~beta/basiclib/betaenv'
--- PROGRAM: descriptor ---
(#
do 'Welcome to Mjolner' -> PutLine
#)
</BETA>


<P> Please note, that on Windows and Macintosh the separator in ORIGIN
specifications is also <code>/</code>. See section 6.2.</P>

<P> Assume that the above program resides on the file
<code>foo.bet</code>. The program may then be compiled by issuing the
command: </P> 

<BETA>beta foo.bet</BETA>

<P> The file <code>foo</code> will now contain an executable version
of <code>foo.bet</code>. </P>

<P> When developing the program, it may be an
advantage to invoke the compiler as</P> 

<BETA>beta -r foo.bet</BETA>

<P> This will run the compiler in repeating mode. After having
translated the fragments specified in the argument list, if in
repeating mode, the compiler prompts the user for the name of another
fragment to be translated. Hitting &lt;RETURN&gt; in this case will
recompiler the program last compiled. See section 8 for a survey of
the legal command line options.
(This is currently not possible on Windows and Macintosh.)

<P> Please consult the BETA tutorial <A
HREF="../bibliography/index.html#mia94-26">[MIA94-26]</A> for a quick
survey of the BETA language and the basic libraries.</P>

<A NAME=HEADING2-75></A>
<H2>Files Generated by the Compiler</H2><A NAME=MARKER-2-14></A>

<P> For each fragment file, a number of other files and directories
may be produced by the compiler.For the BETA fragment <tt>foo.bet</tt>
the following files and directories are produced: Then </P>

<DL>
<DT>File: <tt>foo.lst </tt> 
<DD>contains information about possible
syntactic and static semantic errors. If such errors occur, then the
file contains a pretty-print of the fragment with an indication of the
error(s). See section 7 for further information about error
handling. Possible semantic error messages are listed in appendix A.
The compiler also prints short error messages on the screen during
compilation.
</P>

<DT>File: <tt>foo.ast</tt> or <tt>foo.astL</tt> 
<DD>contains the abstract
syntax tree representation of the compiled source code for big-endian
and little-endian architectures, respectively. The AST files are used
by many tools in the Mj&oslash;lner System.
<P>
<DT>
One of the following directories depending on the platform:
(The extensions <tt>..s</tt> and <tt>.o</tt> differ on
the various platforms.) 
<P>
  <DL>
  <DT><tt>sun4s</tt>: on a SUN Sparc running Solaris
  <DT><tt>sgi</tt>: on a Silicon Graphics MIPS running Unix
  <DT><tt>linux</tt>: on a PC running Linux
  <DT><tt>hpux9pa</tt>: on a HP PA Risc running HP UX
  <DT><tt>nti-gnu</tt>: on a Windows PC based on GNU tools
  <DT><tt>nti-ms</tt>: on a Windows PC based on Microsoft tools
  <DT><tt>ppcmac</tt>: on a Power Macintosh
  </DL>
<P>
<DD>The code directory contains the following files:
<P>

<DL>

<DT>File: <tt>foo..s </tt> 
<DD>contains the generated assembly code for the compiled source code
(As mentioned assembly code is only generated for HPUX9PA) The
assembly file is usually deleted by the compiler after assembly.</P>

<DT>File: <TT>foo.o</tt>
<DD> contains the object code generated by the
compiler or assembler. </P>

<DT>File: <tt>foo.db </tt>
<DD>contains information used by the debugger
Valhalla when debugging the foo fragment. See 
<A HREF="../bibliography/index.html#mia99-40">[MIA90-12]</A>. 

<DT>File: <tt>foo..job </tt> 
<DD>containing directives for assembly and linking.  This file is
usually deleted by the compiler after linking.

</DL>

<P> The above list of files is generated for each fragment group that
is included in a program. In addition, the following file is 
generated for each program:</P>

<DL>

<DT>File: <tt>foo </tt>
<DD>containing the executable code for the program. 

</DL>

<A NAME=HEADING2-1603></A>
<H1>Error Handling</H1>
<P> BETA programs containing errors will cause error messages during compilation. Error messages may appear during syntax analysis, static semantic analysis, code generation and assembly/linking. In addition various forms of system errors may occur. </P>
<A NAME=HEADING2-1605></A>
<H2>Syntax Errors</H2><A NAME=MARKER-2-24></A>
<P> A syntax error is given when there are errors in the context free syntax of the BETA program. These includes missing semicolons, non-matching brackets, etc. Such errors are printed on the screen and may look as follows: </P>

<BETA>
 Parse errors 
 #   1 ORIGIN '~beta/basiclib/betaenv'
 #   2 --PROGRAM: descriptor--
 #   3 (# T: (# #);
 #   4    X: [100) @integer;
 # ************* ^
 #  Expected symbols: >= mod < <= = % <> > -> * ] div +  / 
    xor or and
  File 'syntaxerror.bet'; Line 4
 #   3 (# T: (# #);
 #   4    X: [100) @integer;
 #   5 do (for i: X.range repeat
 #   6         3->X[i];
 #   7    if)
 # ******* ^
 #  Expected symbols: _NAME_ _KONST_ _STRING_ none not @@ 
    restart leave ; (# % & ( this +  inner for tos suspend
  File 'syntaxerror.bet'; Line 7
</BETA>

The error message shows that there are syntax errors in lines 4 and
7. In line 4 the arrow(^) points at the place where an illegal symbol
is met. The compiler gives a list of acceptable symbols. In this case
) should have been a ]. In line 7, the if should have been a for. </P>

<A NAME=HEADING2-1627></A>
<H3>Static Semantic Errors</H3><A NAME=MARKER-2-25></A>


<P> Static semantic errors appear in situations where a name is used
without being declared, where a pattern name is used as an object,
etc. Each error found is printed on the screen with a small indication
of the context. After the checking, a pretty print of the fragment
including a precise indication of the error is generated on the
lst-file (see section 4).

<p>
Some semantic errors may cause the compiler to fail without generating
a pretty print. There should however always be an error indication on
the screen. In case the compiler fails during checking and it is not
obvious for what reason, it is possible to trace the checking of
declarations and imperatives using the option <tt>--traceCheck</tt>
(see section 8). However, this may generate a large amount of output
on the screen. The compiler may also fail during code
generation. These errors may be traced using option
<tt>--traceCode</tt>. However, tracing errors in this way should
rarely be needed.



<p>

Semantic error messages and warnings that may be reported by
the compiler are listed in

<p>
<A href="messages.html">Semantic error messages and warnings</A>

<A NAME=HEADING2-1630></A>
<H2>Check for bound SLOTs.</H2>
<P> In general the compiler will only attempt to link, if a PROGRAM slot has been found in the dependency graph. </P>
<P> If SLOTs of category DoPart or Descriptor in the dependency graph are not bound, and linking would otherwise have happened, the compiler issues a warning, and does not attempt to link.</P>
<P> Likewise, if two or more fragments tries to bind the same SLOT, the compiler will give a warning.</P>

<A NAME=HEADING2-1634></A>
<H2>Assembler and Linker Errors</H2>
<P> Errors may also appear during assembling and linking. The following type of errors may appear: </P>

<ul>
<li>
 The assembler/linker complains about a corrupt ..s or .o file. This
 may happen if the compilation/assembly has been interrupted for some
 reason leaving an incomplete file. This can usually be handled by
 forcing a recompilation of the corresponding BETA file. (Delete the
 ..s <I>and</I> .o files in question)</P>

<li>
The linker may report errors such as 'Undefined Reference'
or 'Multiply Defined Symbol'. This may be due to violations
of the restrictions mentioned in section 6. </P>

<li>The disk may run full during assembling or linking. Restart
compilation after having obtained more disk space.</P>

</ul>

<P> See also section 6.6.</P>

<A NAME=HEADING2-1640></A>
<H2>System Errors</H2>
<P> Two kinds of system errors may appear: (1) Errors in the compiler, and (2) error situations in the operating systems. Most times a meaningful error message is given in these situations, but due to the nature of these errors this is not always the case.</P>
<P> Compiler errors should be reported to Mj&oslash;lner Informatics</P>

See <A HREF="../install/misc.html#errors">[MIA 99-36], section 4.5</A>

<P> Operating system errors are often due to local problems. Examples
of such errors may be: insufficient access to files, no more disc
space, file server inaccessible, etc. </P>

<A NAME=HEADING2-1647></A>
<H2>Run-time Errors</H2>

<P>
Runtime errors are errors in the program detected during its
execution. In this case an error message is given and a dump of the
call stack of objects is generated.
</P>
<P>See
<BLOCKQUOTE>
<A HREF="../betarun/beta-dump.html">BETA runtime error stack dump</A>
</BLOCKQUOTE>
for details.
</P>

<A NAME=HEADING2-1704></A>
<H1>Compiler Arguments</H1>

<P> When activating the BETA compiler, the following command line
arguments are valid. </P>

<P> Most options have both a '--&lt;name&gt;' and a
'--no&lt;name&gt;' form: Activate the option using
'--&lt;name&gt;'; deactivate the option using
'--no&lt;name&gt;'. In the listing below, the activating
form is shown first (and explained), if both exist for an option.</P>

<P> For most options, there is a short (one-character) option for the
non-default form. One-character options allow multiple option
characters after the '-' (e.g. '-qwd').</P>

<P> Long option names are case insensitive, whereas one-character
options are case sensitive.</P>

<P> A star (<B>*</B>) in the listings below indicates the
<I>default</I> option.</P>

<BLOCKQUOTE>
<P> <B>--help</B> <B>-h</B> Show a brief overview of the legal command
line options</P> 
<P> </P>

<P> <B>--repeat</B> <B>-r </B> Run compiler in repeating mode. After
having translated the fragments specified in the argument list, if in
repeating mode, the compiler prompts the user for the name of another
fragment to be translated: </P>

<P> </P>

<P>Type Fragment File Name:</P>

<P> </P>

<P> This interaction is continued until the compiler is explicitly
killed, e.g. by sending a control-C or the end-of-stream character to
the compiler process. </P>

<P> The compiler may also be given additional options at the prompt,
e.g. you may type --nolink foo.bet to translate foo.bet, but avoid
linking of it.</P>

<P> If no new fragments are specified at the prompt, the compiler will
retranslate the last fragment it has translated when &lt;RETURN&gt; it
typed.</P>

<P> By using repeating mode, the compiler saves time when analyzing
dependencies between fragments, since fragments are saved in memory
between compilations. </P>

<P> <B>--noRepeat</B>  <B>*</B></P>
<P> </P>
<P> <B>--link</B>  <B>*</B>  Link program</P>
<P> <B>--noLink</B>  <B>-x</B> </P>
<P> </P>
<P> <B>--static</B>   Use static linking<A NAME=MARKER-2-26></A></P>
<P> <B>--dynamic</B>  <B>*</B>  Use dynamic linking<A NAME=MARKER-2-27></A></P>
<P> </P>
<P> <B>--list</B>  <B>*</B>  Generate .lst file, if semantic errors</P>
<P> <B>--noList</B>  <B>-l</B> </P>
<P> </P>

<P> <B>--debug</B> <B>*</B> Generate debug info to enable
debugging. Include debugging information<A NAME=MARKER-2-28></A> in
the generated code. This is used by the BETA
debugger&Ntilde;Vvalhalla. On the other hand, using --noDebug forces
the linker to strip the application , which reduces the size of the
executable files by 30-50%, and also speeds up linking time. The
actual machinelevel code generated for the BETA program is identical
with or without debug info.???</P>

<P> <B>--noDebug</B>  <B>-d</B> </P>
<P> </P>
<P> <B>--code</B>  <B>*</B>  Generate code</P>
<P> <B>--noCode</B>  <B>-c</B> </P>
<P> </P>
<P> <B>--checkQua</B>  <B>*</B>  Generate runtime checks for QUA errors<A NAME=MARKER-2-29></A></P>
<P> <B>--noCheckQua</B>  <B>-Q</B> </P>
<P> </P>
<P> <B>--checkNone</B>  <B>*</B>  Generate runtime checks for NONE references<A NAME=MARKER-2-30></A></P>
<P> <B>--noCheckNone</B>  <B>-N</B> </P>
<P> </P>
<P> <B>--checkIndex</B>  <B>*</B>  Generate runtime checks for repetition index out of range</P>
<P> <B>--noCheckIndex</B>  <B>-I</B> </P>
<P> </P>
<P> <B>--warn</B>  <B>*</B>  Generate warnings<A NAME=MARKER-2-31></A></P>
<P> <B>--noWarn</B>  <B>-w</B> </P>
<P>  </P>
<P> <B>--warnQua</B>  <B>*</B>  Generate warnings about runtime QUA checks<A NAME=MARKER-2-32></A></P>
<P> <B>--noWarnQua</B>  <B>-q</B> </P>
<P> </P>
<P> <B>--verbose</B>   Verbose compiler info output<A NAME=MARKER-2-33></A></P>
<P> <B>--quiet</B>  <B>*</B>  Only compiler info on parse, check, etc.</P>
<P> <B>--mute</B>   No compiler info output</P>
<P> </P>
<P> <B>--traceCheck</B>   Trace the compiler during semantic checking</P>
<P> <B>--noTraceCheck</B></P>
<P> </P>
<P> <B>--traceCode</B>   Trace the compiler during code generation</P>
<P> <B>--noTraceCode</B> </P>
<P> </P>
<P> <B>--out</B>  <B>-o</B>  Specify name to use for resulting executable image</P>
<P> </P>
<P> <B>--preserve</B>  <B>-p</B>  Preserve generated .job and assembly files</P>
<P> <B>--noPreserve</B>  <B>*</B></P>
<P> </P>
<P> <B>--job</B>  <B>*</B>  Execute the ..job file</P>
<P> <B>--noJob</B>  <B>-j</B> </P>
<P> </P>

<P> <B>--switch</B> <B>-s</B> Set/unset one or more compiler
switches. The -s option makes it possible to define one or more
so-called compiler switches. Switches are specified as integers on the
command line after --switch or -s, possibly terminated by a 0
(zero). Switches are used for a number of purposes: parameterization
of the compiler, debugging, testing etc. The most interesting switches
with respect to parameterization are listed below; notice that some of
them may also be set as ordinary options.</P>

<P> &middot; <B>5</B>: Suppress code generation. I.e. only semantic checking is performed. This switch will also set switch 33. Same as <B>-c</B>.</P>
<P> &middot; <B>6</B>: Suppress linking. Same as <B>-x</B>.</P>
<P> &middot;  <B>14</B>: Do not generate run-time checks for NONE-references. Same as <B>-N</B></P>
<P> &middot;  <B>15</B>: Do not generate run-time checks for index-errors. Same as <B>-I</B>.</P>
<P> &middot;  <B>18</B>: Preserve assembly- and job-files. Same as <B>-p</B>.</P>
<P> &middot;  <B>19</B>: Suppress notification of insertion of run-time checks for qualification errors in reference assignment. Same as <B>-q</B>.</P>
<P> &middot;  <B>21</B>: Continue translation after semantic errors.</P>
<P> &middot; <B>23</B>: Preserve job-files.</P>
<P> &middot;  <B>32</B>: Do not produce .lst file in case of semantic errors. Same as <B>-l</B>.</P>
<P> &middot;  <B>33</B>: Do not execute .job file. Same as <B>-j</B>.</P>
<P> &middot;  <B>37</B>: Do not generate debugging information. Same as <B>-d</B>.</P>
<P> &middot; <B>42</B>: Do not generate run-time checks for qualification errors in reference assignment. Same as <B>-Q.</B></P>
<P> &middot;  <B>191</B>: Print each descriptor just before it is checked.</P>
<P> &middot;  <B>192</B>: Print each declaration just before it is checked.</P>
<P> &middot;  <B>193</B>: Print each imperative just before it is checked.</P>
<P> &middot; <B>308</B>: Print each declaration just before code is generated for it.</P>
<P> &middot; <B>311</B>: Print each imperative just before code is generated for it.</P>
<P> </P>
<P> <B>--linkOpts</B>   Specify text string to be appended to the link directive</P>
<P> </P>

<P> <I>fragment1 ... fragmentN<B> <BR></B></I>Arguments other than the
above mentioned options are treated as the names of fragments to be
translated by the compiler. It should be noted that for an option to
take effect in the translation of a fragment whose name is passed as
argument to the compiler, the option must appear <I>before</I> the
fragment name in the argument list. </P>
</BLOCKQUOTE>

<A NAME=HEADING2-1792></A>
<H1>Machine Dependent Configurations</H1>

<P> In this section, the terminology of the fragment system is used
freely without further explanation. The fragment system has been
extended to support generic software descriptions. The same generic
software description may be used to instantiate configurations for
different machines. The term 'machine' covers a CPU and an operating
system running on that CPU. </P>

<P> The concept of generic software descriptions is implemented by
means of special 'generic properties'. Normally, a property has
exactly <I>one</I> associated set of values. A generic property has
<I>a number of</I> such value-sets. The idea is that the programmer
can specify a value-set for each machine. These value-sets are the
ones termed <I>&lt;MachineSpecificationList&gt;</I> in the formal
specification of properties in section 6.3 and 6.5. As an example:

<BETA>
OBJFILE  sun4s   'xlib.o'
         linux   'zlib.o' 
         default 'wlib.o'
</BETA>

<P> <A NAME=MARKER-2-34></A>OBJFILE is the name of a generic
property. The OBJFILE property is used for inclusion in the linkage
phase of external object files, e.g. produced by a C compiler. A
generic property specification should be seen as a kind of
'switch/case' statement. The semantics of the above OBJFILE property
is that when instantiating a configuration for the machine sun4s, the
value xlib.o is chosen. This means that the object file xlib.o is
included when linking a configuration for a sun4s machine. Similarly
for linux machines. The default literal indicates that when
instantiating configurations for machines <I>other</I> than sun4s or
linux , the object file wlib.o should be included. </P>

<P> Besides OBJFILE, there are the following generic properties: MAKE,
BETARUN, LIBFILE, LINKOPT, RESOURCE, and MDBODY. For all of these
properties, the relation between machine symbols and value-sets are
specified in the same manner as described above. To be precise, the
following algorithm is used when instantiating a configuration for a
specific machine type, say A.</P>

<P> 1. If A matches any of the machine symbols of the generic
property, the value-set associated with that particular machine symbol
is chosen. If no match is possible, proceed with step 2. </P>

<P> 2. If the symbol default is specified as machine symbol, the
associated value-set is chosen. If not, a warning is issued. </P>

<P> The only distinction between the different generic properties is
in the interpretation of the elements of the chosen value-set. For
OBJFILE, the value-set is interpreted as external object files. MAKE
is meant to point out a number of so-called makefiles. These are
executed just prior to the linkage phase. A makefile is often used to
keep the included object files up to date with respect to the source
files from which they originate. For BETARUN, the value-sets must
contain exactly one element, and this element denotes the runtime
system to be used in the resulting configuration. With respect to
LIBFILE, the elements of the value-sets are interpreted as external
libraries, e.g. the X11 library, to be included in the linkage
phase. The chosen value-set in an MDBODY property denotes ordinary
BETA fragments to be treated as if they had been specified by means of
a normal BODY property. The MDBODY property may thus be used to
specify that a fragment appears in a number of machine dependent
variants. Finally, the LINKOPT property denotes arguments to append to
the link-directive in the linking phase of compilations. Finally, the
RESOURCE property is used (only on PC and Macintosh) to specify a set
of resource files to add to the application.</P>

<P> Configurations are instantiated by the compiler, by default for
the machine on which the compilation takes place. It is possible to
instantiate a configuration for a machine other than the one, on which
the compilation is performed ('cross-compilation'). This requires
extensions to the Mj&oslash;lner System; please contact Mj&oslash;lner
Informatics if this is needed.</P>

<A NAME=HEADING2-1804></A>
<H2>BUILD Property</H2>

<P> The BUILD property unifies the OBJFILE and MAKE properties. The
BUILD property is used to specify rules for keeping external
(i.e. non-BETA) sources up to date, and to include the external files
in the link directive.</P>

<A NAME=HEADING2-1806></A>
<H3>Syntax</H3>
<beta>
BUILD <machine> '<objectfile>' 
     '<dep1>' '<dep2>' ... '<depN>' 
     '<command>';
</beta>
<P> where</P>

<P> &lt;machine&gt; is the target machine specification (see MDBODY
description)</P>

<P> &lt;objectfile&gt; is the external objectfile to include and
possibly maintain. A $$ in this specification is expanded to the
machine type. This is unlike other properties, like MDBODY, where a
single $ is expanded to the machine type. If a backslash (\) or a
newline must be included literally in the specification, it must be
quoted with backslash.</P>

<BETA>
<dep1>
<dep2>
...
<depN>  
</BETA>

<P>Are source files, that the &lt;objectfile&gt; depends on. </P>
<P> &lt;command&gt; is a command (sequence) that is executed by the compiler as it is, except for the following substitutions:</P>
<P>  $$ is expanded to the machine type, as explained above.</P>
<P>  $0 is expanded to &lt;objectfile&gt;</P>
<P>  $1 is expanded to &lt;dep1&gt;</P>
<P>  $2 is expanded to &lt;dep2&gt;</P>
<P>  ...</P>
<P>  $N is expanded to &lt;depN&gt;</P>
<P>  If a backslash (\) or a newline must be included literally in the commands, it must be quoted with backslash.</P>

<A NAME=HEADING2-1825></A>
<H3>Functionality</H3>

<P> The &lt;objectfile&gt; is included in the link directive. The
compiler will execute &lt;commands&gt; if and only if</P>

<P> a.  &lt;objectfile&gt; does not exist</P> 
<P> or </P> 
<P> b.  any
of the files &lt;dep1&gt;, &lt;dep2&gt;, ... &lt;depN&gt; are newer
than an existing &lt;objectfile&gt;</P> <P> The compiler will execute
&lt;commands&gt; from the directory in which the file containing the
BUILD property resides.</P>

<A NAME=HEADING2-1831></A>
<H3>Example</H3>

<P> If the object file foo.o (foo.obj) is to be generated from the
foo.c file in the external directory, but also depends on the foo.h
file in the external directory, you could specify this as:</P>

<BETA>
BUILD nti     '$$/foo.obj' 'external/foo.c' 'external/foo.h'
              'cl -c $1 -Fo$0 -nologo -w -O2 -Zd -Zp4'
      ppcmac  ':$$:foo.obj' ':external:foo.c' ':external:foo.h'
                 'MrC -D MAC -o $0 $1'
      default '$$/foo.o'   'external/foo.c' 'external/foo.h'
              '$CC -o $0 $1';
</BETA>

<P> Notice, that regular environment variables may be used in the
&lt;commands&gt; specification, e.g. in the default (UNIX)
specification, the variable CC are used (on UNIX, this is always set
to an appropriate value in the job-file).</P>

<A NAME=HEADING2-1840></A>
<H3>More than one build pr. fragment</H3>
<P> In general, more than one build pr. fragment will not work. The reason is that the meta-programming system combines all build directives into one directive (property). This means that:</P>

<BETA>
BUILD sun4s 'cc1' default 'cc2'; 
BUILD sun4s 'cc3' default 'cc4'
</BETA>

<P> means the same as:</P>

<BETA>
BUILD sun4s 'cc1' default 'cc2' sun4s 'cc3' default 'cc4'
</BETA>

<P> BUILD 'executes' all entries for a given plaform. This means that
the 2 sun4s entries will be executed for sun4s. The 2 default entries
will be executed for all other platforms.</P>

<P> If the following two build entries are used:</P>

<BETA>
BUILD sun4s 'cc1' default 'cc2'; 
BUILD sgi   'cc3' default 'cc4'
</BETA>

<P> ONLY cc1 will be executed for sun4s and ONLY cc3 for sgi, and the
2 default entries for all other platforms. This is probably not what
is intedended: For sun4s you would expect cc1 and cc4 to be executed
and sgi, cc2 and cc3.</P>

<P> To fix this, changes in the meaning of properties in MPS must be
changed.</P>

<P> Summary: more than one build directive in a fragment file will work if they have the same structure with respect to platform.</P>
<P> Alternative</P>
<P> It would be easy to implementa build directives on the form:</P>

<BETA>
BUILD1 sun4s 'cc1' default 'cc2'; 
BUILD2 sgi   'cc3' default 'cc4'
</BETA>

<P> This will give different properties and the compiler can be made to handle this. It is, however, not an ideal solution.</P>

<A NAME=HEADING2-1859></A>
<H1>Code Generation for Multiple Machines</H1>
<P> When instantiating a configuration for some machine, a number of object files are produced by the compiler - one for each fragment contributing to the configuration. On most architectures, the compiler actually generates symbolic assembly code, and this code is turned into object files by means of the native assembler. The native linker is used to produce an executable image for the machine in question on basis of these object files. </P>

<A NAME=HEADING2-1861></A>
<H2>Placement of Object Code </H2>
<P> Different machines normally use different formats for object files. The files containing object code and symbolic assembly code are always placed in a sub-directory relative to the directory containing the common source code. A sub-directory is created for each special object file format. Currently the following subdirectories are used: </P>

<BETA>
sun4s    SUN-4 (SPARC) running Solaris 2.x
hpux9pa  HP 9000/700 running HP-UX 9.x
sgi      Silicon Graphics (MIPS) running IRIX 5.3
linux    PC running Linux 1.0 or later
nti      PC running Windows NT or Windows 95
ppcmac   Power   Macintosh 3.2 or later
</BETA>

<P> For executable images to be activated directly, without prefixing their name with the name of a sub-directory, executable images are placed in the same directory as the common source files. It is however possible to control the naming of the executable images. This is done by means of the -o option to the compiler. </P>

<A NAME=HEADING2-1871></A>
<H2>Macro Expansion</H2><A NAME=MARKER-2-35></A>
<P> Consider this use of the MDBODY property:</P>
<P>       MDBODY default './$/betaenvbody_$'</P>
<P> The symbol $ is expanded by the compiler. It is expanded to the name of the subdirectory into which the generated code will be placed. That is, if code is generated for a ppcmac (Macintosh) machine, the above expands to ./ppcmac/betaenvbody_mac. This may be a convenient short-hand, but may also make is possible to instantiate configurations for new machines without changing the original source code. </P>

<A NAME=HEADING2-1885></A>
<H2> Appendix A. Semantic Errors and Warnings</H2>
<A NAME=HEADING2-1886></A>

Semantic error messages and warnings that may be reported by
the compiler are listed in:
<p>
<DL>
<DT><A href="messages.html">Semantic error messages and warnings</A>
<DD>
</DL>

<A NAME=HEADING2-2046></A>
<H2> Appendix B. The BETA Grammar</H2>
<P> </P>
An HTML interface to the BETA grammar can be found in

<DL>
<DT><A HREF="../grammars/beta.html">BETA Grammar</A>.
<DD>
</DL>

