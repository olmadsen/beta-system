<H1> <A NAME="LINK-beta-intro-_Toc403635899"><A NAME=MARKER-9-139></A>Virtual Pattern</A></H1>



<A NAME=HEADING25-4></A>
<H1> Structural equivalence  is used in BETA</H1>
<P> In the example in section 3 it was mentioned that a redefinition of a virtual procedure pattern<A NAME=MARKER-2-141></A> is not a redefinition (overriding) as in C++. In fact a virtual pattern in BETA can only be extended and cannot be completely redefined. The rationale behind this is that a subpattern should have the same properties as its superpattern including which imperatives are executed. Ideally a subpattern should be behaviorally equivalent<A NAME=MARKER-2-142></A> to its superpattern. This will, however, require a correctness proof. The subpattern mechanism of BETA supports a form of structural equivalence<A NAME=MARKER-2-143></A> between a subpattern and its superpattern. </P>
<P> Consider the following patterns:</P>
<A NAME=HEADING25-7></A>
<H1> Patterns A and AA</H1>
<PRE CLASS=beta>
A: (# V:&lt; (# x:  do I1; inner; I2 #) #);
AA: A(# V::&lt; (# y:  do I3; inner; I4#) #)
</PRE>
<P> The pattern A has a virtual procedure attribute V. V has an attribute x and its do-part contains the execution of I1; inner; I2. The subpattern AA of A extend<A NAME=MARKER-2-144></A>s the definition of V. The extended definition of V in AA corresponds to the following object-descriptor (except for scope rules):</P>
<A NAME=HEADING25-10></A>
<H1> Combined descriptor</H1>
<PRE CLASS=beta>
(# x: ; y:  do I1; I3; inner; I4; I2 #)
</PRE>
<P> As may be seen the V attribute of AA has the attributes x and y and the do-part consists of I1; I3; inner; I4; I2. The definition of V is an extension of the one from A and not a replacement.</P>
<P> The subpattern AB of A describes another extension of V:</P>
<A NAME=HEADING25-14></A>
<H1> Pattern AB</H1>
<PRE CLASS=beta>
AB: A(# V::&lt; (# z:  do I5; inner; I6 #) #)
</PRE>
<P> Here V corresponds to the following object descriptor:</P>
<PRE CLASS=beta>
V: (# x: ; z:  do I1; I5; inner; I6; I2 #)
</PRE>
<P> The definition of V may be further extended in subpatterns of AA also as shown in the definition AAA:</P>
<A NAME=HEADING25-19></A>
<H1> Pattern AAA</H1>
<PRE CLASS=beta>
AAA: AA(# V::&lt; (# q:  do I7; inner; I8 #) #)
</PRE>
<P> The definition of V corresponds to the following object-descriptor:</P>
<PRE CLASS=beta>
V: (# x: ; y: ; q:  do I1; I3; I7; inner; I8; I4; I2 #)
</PRE>
<P> As may be seen, the pattern V is a combination of the definitions of V from A, AA and AAA. </P>
<A NAME=HEADING25-24></A>
<H1> Final binding</H1>
<P> The definition of V may be extended using a final binding<A NAME=MARKER-2-145></A> (<A NAME=MARKER-2-146></A>) in subpatterns of A as shown in the definition AC:</P>
<PRE CLASS=beta>
AC: A(# V::(# q:  do I2; inner; I4 #) #)
</PRE>
<P> The final binding of V means that V cannot be extended in subpatterns of AC. The extended definition of V in AC corresponds to the following object-descriptor (except for scope rules):</P>
<PRE CLASS=beta>
(# x: ; y:  do I1; I3; inner; I4; I2 #)
</PRE>
<P> The virtual mechanism in BETA guarantees that behavior defined in a superpattern cannot be replaced in a subpattern. This form of structural equivalence is useful when defining libraries of patterns that are supposed to execute a certain sequence of actions. In C++, the programmer must explicitly invoke the actions from the superclass by means of superclass::functionname. This is illustrated by the example in the next section.</P>
<P> The inner construct is more general than shown above, since a pattern may have more than one inner and inner may appear inside control structures and nested singular object descriptors.</P>












