<H1> <A NAME="LINK-beta-intro-_Toc403635896"><A NAME=MARKER-9-124></A>Subprocedure</A></H1>
<P> The previous sections has shown examples of patterns used as classes and procedures. For class patterns, examples of subpatterns have been given. Subpatterns may also be used for procedure pattern<A NAME=MARKER-2-126></A>s. For attributes, subpattern<A NAME=MARKER-2-127></A>s may add new attributes and extend definitions of virtual patterns in the superpattern. In addition, a subpattern may specify further imperatives which have to be combined with the imperatives of the superpattern. The combination of the imperatives is handled by the inner<A NAME=MARKER-2-128></A> construct. Consider the following objects:</P>
<PRE CLASS=beta>
mutex: @semaphore; sharedVar: @integer
</PRE>
<P> The variable sharedVar is shared by a number of concurrent processes. Mutual access to the variable is handled by the semaphore mutex. Update of sharedVar should then be performed as follows:</P>
<PRE CLASS=beta>
mutex.P; m+sharedVar -&gt; sharedVar; mutex.V
</PRE>
<A NAME=HEADING22-5></A>
<H1> Abstract procedure pattern</H1>
<P> This pattern of actions must be used whenever sharedVar and other shared objects have to be accessed. Instead of manipulating the semaphore directly it is possible to encapsulate these operations in an abstract procedure pattern. The pattern entry can describe this encapsulation:</P>
<PRE CLASS=beta>
entry: (# do mutex.P; inner; mutex.V #)
</PRE>
<P> Execution of entry locks mutex before the inner and releases it afterwards. inner may then in subpatterns of entry be replaced by arbitrary imperatives. The subpattern updateShared of entry updates sharedVar:</P>
<PRE CLASS=beta>
updateShared: entry
  (# m: @integer 
  enter m 
  do sharedVar+m-&gt; sharedVar
  #)
</PRE>
<P> Execution of an imperative</P>
<PRE CLASS=beta>
123 -&gt; updateShared
</PRE>
<P> will then result in execution of the actions</P>
<PRE CLASS=beta>
mutex.P; sharedVar+123-&gt;sharedVar; mutex.V
</PRE>
<P> We may now define an abstract superpattern corresponding to a monitor:</P>
<PRE CLASS=beta>
monitor:
  (# mutex: @semaphore;
     entry: (# do mutex.P; inner; mutex.V #);
     init:&lt; (# do mutex.V(*initially open*); inner #)
  #);
</PRE>
<P> A (singular) monitor object may now be declared like shared below:</P>
<PRE CLASS=beta>
shared: @monitor
  (# var: @integer;
     update: entry(# m: @integer enter m do var+m-&gt;var #);
     get: entry(# v: @integer do var-&gt;v exit v #)
  #)
</PRE>
<P> Semaphores are the basic mechanism in BETA for synchronization. They can express most synchronization problems, but may be complicated to use. It is therefore mandatory that high level abstraction mechanisms like monitor can be defined. In section 9 below, further details about concurrency in BETA will be given.</P>











