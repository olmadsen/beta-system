<H1> <A NAME="LINK-beta-intro-_Toc403635904"><A NAME=MARKER-9-169></A>Concurrency</A></H1>
<P> As previously mentioned, it is possible to perform concurrent execution<A NAME=MARKER-2-171></A> of components by means of the fork operation as sketched in the following example:</P>
<PRE CLASS=beta>
(# S1: @| (#  do  #);
   S2: @| (#  do  #);
   S3: @| (#  do  #)
  do S1[] -&gt; fork; S2[] -&gt; fork; S3[] -&gt; fork;  
#)
</PRE>
<P> The execution of S1, S2 and S3 will take place concurrently with each other and with the object executing the fork<A NAME=MARKER-2-172></A> operations. Concurrent objects may access the same shared objects without synchronization, but may synchronize access to shared objects by means of semaphores. In section 5 above the pattern semaphore has been described. It is well known that a semaphore is a low level synchronization mechanism which may be difficult to use in other than simple situations. For this reason the Mj&oslash;lner library has a number of patterns defining higher level synchronization mechanisms. This library includes a monitor pattern as described in section 5 above. The library also includes patterns defining synchronization in the form of rendezvous as in Ada.</P>
<A NAME=HEADING30-4></A>
<H1> Monitor Example</H1>
<P> The following example describes a company with a number of salesmen, workers and carriers. The salesmen obtain orders from customers and store them in an order pool. The workers obtain orders from the order pool, process them and deliver the resulting item in an item pool. The carriers pick up the items from the item pool and bring them to the customer. Salesmen, workers and carriers are described as active objects whereas the order- and item pools are represented as monitor objects.</P>
<PRE CLASS=beta>
(# salesman: employee
     (# getOrder: (#  exit anOrder[] #)
     do cycle (# do getOrder -&gt; jobPool.put #)
     #);
   S1,S2, : @|salesman;
   jobPool: @monitor
     (# jobs: @register(# type::&lt; order #);
        put: entry
          (# ord: ^order enter ord[] do ord[] -&gt;jobs.insert #);
        get: entry
          (# ord: ^order do jobs.remove -&gt; ord[] exit ord[] #)  
     #);
   worker: employee
     (# processJob: (#  enter anOrder[] do  exit anItem[] #)
     do cycle(# do jobPool.get -&gt; processJob -&gt; itemPool.put #)
     #);
   W1,W2,: @| worker;
   itemPool: @monitor(#  #);
   carrier: employee
     (# deliverItem: (# enter anItem[] do  #)
     do cycle(# do itemPool.get -&gt;DeliverItem #)
     #);
   C1,C2, : @| carrier;
do jobPool.init; itemPool.init; 
   conc(# do S1[]-&gt;start;  W1[]-&gt;start;  C1[]-&gt;start;  #)
#)
</PRE>
<A NAME=HEADING30-7></A>
<H1> Procedure pattern conc<A NAME=MARKER-2-173></A></H1>
<P> The procedure pattern conc is another example of a high-level concurrency pattern from the Mj&oslash;lner library. It does not terminate execution until components being started (by S1[]-&gt;start, etc.) have terminated their execution.</P>
<A NAME=HEADING30-9></A>
<H1> Rendezvous Example</H1>
<P> Next we show an example of using the library patterns for describing synchronized rendezvous<A NAME=MARKER-2-174></A>. The example shows a drink machine that provides coffee and soup. A customer operates the machine by pushing either makeCoffee or makeSoup. If makeCoffee has been pushed, then the customer may obtain the coffee by means of getCoffee. Similarly if makeSoup has been pushed then the soup may be obtained by means of getSoup. </P>
<P> The system pattern has a port attribute which may be used to define synchronization ports. The drink machine described below has three such ports, activate, coffeeReady, and soupReady. A port object has a pattern attribute entry which may be used to define procedure patterns associated with port. For the port activate, two procedure patterns makeCoffee and makeSoup are defined. For coffeeReady and soupReady, the procedure patterns getCoffee and getSoup are defined.</P>
<P> An execution of a port-entry operation like aDrinkMachine.makeCoffee will only be executed if the drinkMachine has executed a corresponding accept by means of activate.accept.</P>
<UL>
<LI> Initially a drinkMachine is ready to accept either makeCoffee or makeSoup.
<LI> If e.g. makeCoffee is executed, then when 'the coffee has been made', the drinkMachine is willing to accept the operation getCoffee. This is signaled by executing an accept on the port coffeeReady. Technically this is implemented by assigning a reference to coffeeReady to the port reference drinkReady. The do-part of drinkMachine then makes an accept on drinkReady.
<LI> When the operation getCoffee, has been executed, the drinkMachine is again ready to accept a new operation associated with the activate port.
</UL>
<PRE CLASS=beta>
drinkMachine: system
  (# activate: @port;
     makeCoffee: activate.entry
       (# do  coffeeReady[]-&gt;drinkReady[] #);
    makeSoup: activate.entry(# do  soupReady[]-&gt;drinkReady[] #);
    coffeeReady, soupReady: @port;
    getCoffee: coffeeReady.entry(# do  exit someCoffee [] #);
    getSoup: soupReady.entry(# do  exit someSoup [] #);
    drinkReady: ^port
  do cycle(# do activate.accept; drinkReady.accept #)
  #)
</PRE>
<P> The drinkMachine may be used in the following way:</P>
<PRE CLASS=beta>
  aDrinkMachine: @| drinkMachine
  
  aDrinkMachine.makeCoffee;  aDrinkMachine.getCoffee;
  aDrinkMachine.makeSoup;  aDrinkMachine.getSoup;
</PRE>
<P> As may be seen the use of the patterns system, port and entry makes it possible to describe a concurrent program in the style of Ada tasks that synchronize their execution by means of rendezvous. A port object defines two semaphores for controlling the execution of the associated entry patterns. The actual details will not be given in this language introduction.</P>
<P> It is possible to specialize the drinkMachine into a machine that accepts further operations:</P>
<PRE CLASS=beta>
extendedDrinkMachine: drinkMachine
  (# makeTea: activate.entry(# do  teaReady[]-&gt;drinkReady[] #);
     teaReady: @port;
     getTea: teaReady.entry(#  exit someTea[] #)
  #)
</PRE>
<P> The extendedDrinkMachine inherits the operations and protocol from drinkMachine and adds new operations to the protocol.</P>
<P> The basic mechanisms in BETA for providing concurrency are component-objects (providing threads), the fork-imperative (for initiating concurrent execution) and the semaphore (for providing synchronization). As has been mentioned already, these mechanisms are inadequate for many situations. The abstraction mechanisms of BETA make it possible to define higher-level abstractions for concurrency and synchronization. </P>
<A NAME=HEADING30-24></A>
<H1> More information</H1>
<P> Please see the manual <A HREF="../bibliography/index.html#mia90-8">[MIA 90-8]</A> for details about the concurrency library.</P>












