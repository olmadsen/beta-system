<H1><INX>Basic Constructs</INX></H1>
<P> The most fundamental elements of BETA are objects and patterns. This section describes the basic patterns and values, simple assignments, control structures, variable declarations, repetitions and patterns used as composite types.</P>

<H1>Simple Types and Values</H1>
<P> The <INX>simple types</INX> (or also called basic patterns) are
integer, boolean, char, and, real. The following table shows the
simple types with examples of values, including text constant. Notice,
that text is not a simple type in BETA, but a pattern defined in the
basic BETA environment called <CODE>betaenv</CODE>.</P>

<TABLE BORDER=1><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD>
Type
</TD><TD>Value
</TD></TR><TR VALIGN=TOP><TD><INX>integer</INX>
</TD><TD>7, -4, 0x4FFC, 2x101101
</TD></TR><TR VALIGN=TOP><TD><INX>boolean</INX>
</TD><TD>true, false
</TD></TR><TR VALIGN=TOP><TD><INX>char</INX>
</TD><TD>'c'
</TD></TR><TR VALIGN=TOP><TD><INX>real</INX>
</TD><TD>3.141, -1.234E3
</TD></TR><TR VALIGN=TOP><TD>text <INX>constant</INX>
</TD><TD>'abc'
</TD></TR></TABLE>

<H1> Simple Static Variables</H1>

<P> In BETA, a <INX>static variable</INX>(also called a <INX>static
reference) is declared like:</P>

<INX HIDDEN>@</INX>
<BETA>
i: @integer;
r: @real;
</BETA>

<P> Variables of the simple types can only be declared static, see
below for dynamic references.</P>

<H1>Simple Assignments</H1>
<H1> Value assignment</H1>
<P> Simple <INX>value assignment</INX>s in BETA goes left to right:</P>

<INX HIDDEN>-></INX>
<BETA>
2 -> i         (* assign the value 2 to i *)
i -> j         (* assign the value of i to j *)
i*j -> k       (* assign the value of i*j to k *)
(i,j) -> (x,y) (* assign the value of i to x and 
                *        the value of j to y 
                *)
</BETA>






<H1>Control Structures</H1>
<P> BETA has two build-in <INX>control structures</INX>: 
<INX>if</INX> and <INX>for</INX>, both having two forms. 
The simple if imperative with one boolean expression:</P>

<H1> if</H1>

<BETA>
(if <expression> then 
    <imperatives>
 else
    <imperatives>
if)
</BETA>

<P> and the if with several alternatives:</P>

<INX HIDDEN>if</INX>
<INX HIDDEN>then</INX>
<INX HIDDEN>else</INX>
<BETA>
(if <expression>
 // <expression> then <imperatives>
 // <expression> then <imperatives>
 else
   <imperatives>
if)
</BETA>

<P> where <INX>//</INX> means equals.</P>
<P> The simple for imperative just iterates a given number of times:</P>

<H1> for</H1>

<INX HIDDEN>for</INX>
<INX HIDDEN>repeat</INX>
<BETA>
(for <expression> repeat <imperatives> for)
</BETA>

<P> but the for imperative may implicitly declare an iteration variable, only available inside the for loop, by:</P>

<BETA>
(for &lt;variable&gt;: &lt;expression&gt; repeat &lt;imperatives&gt; for)
</beta>

<P> The for loop always starts in 1 and stops at &lt;expression&gt;. The loop can be terminated or restarted using labels, see below.</P>
<P> The following BETA code is a general object-<INX>descriptor</INX> (or <INX>descriptor</INX> for short):</P>

<H1> <INX>descriptor</INX></H1>

<INX HIDDEN>enter</INX>
<INX HIDDEN>do</INX>
<INX HIDDEN>exit</INX>

<BETA>
&lt;declarations&gt;
enter &lt;enter-list&gt;
do &lt;imperatives&gt;
exit &lt;exit-list&gt;
</beta>

<P> A descriptor consists of type and variable declarations, an enter part for parameters (enter &lt;enter-list&gt;), a do-part for the action (do &lt;imperatives&gt;), and finally an exit part for the results (exit &lt;exit-list&gt;). All elements are optional.</P>
<P> A descriptor can be <INX>labeled</INX>, and the descriptor can be restarted and/or left using the label:</P>

<H1> labeled descriptor</H1>

<INX HIDDEN>leave</INX>
<INX HIDDEN>restart</INX>
<BETA>
L: (#  leave L; restart L #)
</beta>

<P> In general any imperative can have a label:</P>

<H1> labeled imperative</H1>

<BETA>
L: &lt;imperative&gt;
L: (if   leave L   if)
L: (for  leave L  for)
</beta>

<P> leave L implies that control is transferred to immediately after the labeled imperative/descriptor. restart L implies that control is transferred to immediately before the labeled imperative/descriptor.</P>











<H1>Static and Dynamic Variables</H1>

<H1> Reference attributes</H1>
<P> In BETA variables are two examples of reference <INX>attribute</INX>s&Ntilde;static <INX>reference</INX>s that constantly denote the same object, and dynamic <INX>reference</INX>s that may denote different objects.</P>

<H1> Static Reference</H1>
<P> Examples of static reference variables are:</P>

<BETA>
i: @integer (* i refers to a simple type: integer *)
p: @A       (* an instance of A is automatically generated and
             * p always refers to this object *)
s: @(#  #) (* an instance of (#  #) is automatically generated 
             * and s always refers to this singular object *)
</BETA>


<H1> Dynamic reference</H1>
<P> Examples of dynamic reference variables are:</P>

<INX HIDDEN>^</INX>
<BETA>
i: ^integerObject
p: ^A
</BETA>

<P> Assignments between dynamic references can be done using the reference <INX>operator</INX> '<INX>[]</INX>' (read <INX>box</INX>):</P>

<H1> Reference assignment</H1>
<BETA>
p1[] -> p2[]  (* reference <INX>assignment</INX> *)
</BETA>

<P> Dynamic reference variables are initially <INX>NONE</INX> i.e. refers to nothing. Objects can be created using the <INX>new</INX> operator '<INX>&amp;</INX>':</P>

<BETA>
&A[] -> p[]  (* create an instance of A and assign the reference
              * to p *)
</beta>

<P> It is illegal to declare dynamic references to simple types:</P>

<BETA>
i: ^integer (* ILLEGAL *)
r: ^real    (* ILLEGAL *)
</BETA>

<P> Instead use <INX>integerObject</INX>, <INX>charObject</INX>, <INX>booleanObject</INX>, or <INX>realObject</INX> defined in the Mj&oslash;lner System basic betaenv environment.</P>











<H1><INX>Repetitions</INX></H1>
<P> In BETA it is possible to declare a <INX>repetition</INX> of static (simple types) or dynamic references. A repetition is declared like:</P>

<INX HIDDEN>range</INX>
<INX HIDDEN>extend</INX>
<INX HIDDEN>new</INX>
<BETA>
R: [10] @integer  (* repetition of 10 static references *)
P: [10] ^A        (* repetition of 10 dynamic references *)
R[1] -> i         (* value assignment *)
P[1][] -> x[]     (* reference assignment *)
RR: [1] @integer  (* repetition of 1 static reference *)
R -> RR           (* repetition assignment:
                   * all values from R is copied into RR
                   * RR is automatically extended if needed
                   *)
R.range           (* the size of the repetition *)
n -> R.extend     (* extends the repetition with n elements *)
n -> R.new        (* allocates a new repetition with n elements *)
</BETA>

<P> The range of a repetition is 1 to R.range, thus repetitions always
start with 1.</P> 




<H1>><INX>Composite Types</INX> (Records)</H1>
<P> Using the object-descriptor it is possible to declare
<INX>composite types</INX>:</P> 

<BETA>
point:  (# x,y: @integer #) (* point is a composite type 
                             * consisting of two integers *)
p: @point    (* static declaration of a point *)
p.x          (* remote access to x *)
circle:      (* composite type using simple and composite types *)
  (# center: @point; 
     radius: @integer;
  #)
</beta>


<H1> <INX>Pattern</INX></H1>
<P> The declaration of point and circle above is in general called a
pattern declaration. The pattern will be described in details in the
following sections.</P> 











