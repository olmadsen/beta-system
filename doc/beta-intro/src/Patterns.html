<H1><INX>Patterns and Objects</INX></H1>
<P> Most object-oriented languages supporting the object-oriented perspective have constructs such as class, subclass, virtual procedure, and qualified reference variable. These constructs all originated with Simula. Eiffel and C++ include these constructs although a different terminology is used. In addition to virtual procedures BETA also has non-virtual procedures. </P>
<P> In this introduction, the BETA version of the above constructs will be described and compared to other object-oriented languages. The example used in the following is a company with different kinds of employees, including salesmen and workers. employee is an abstract superpattern describing the common properties of all employees.</P>

<H2> Pattern Employee</H2>

<BETA>
employee:
  (# name: @text;
     birthday: @date;
     dept: ^Department;
     totalHours: @integer;
     registerWork:
       (# noOfHours: @integer
       enter noOfHours
       do noOfHours + totalhours -> totalHours
       #);
     computeSalary:<
       (# salary: @integer
       do inner
       exit salary
       #);
  #);
</BETA>

<P> The elements of the employee pattern have the following meaning:</P>

<H2> Elements of Employee</H2>
<UL>
<LI> The attributes name, birthday, dept and totalHours are <INX>reference attribute</INX>s denoting instances of the patterns text, date, department and integer respectively.
<LI> Name, birthday, and totalHours refer to <INX>part-object</INX>s. A part-object is a fixed part of its enclosed object and is generated together with the enclosing object. Part-objects are also found in Eiffel and C++.
<LI> Dept is a <INX>dynamic reference</INX> that either has the value <INX>NONE</INX> or refers to a separate instance of the pattern department.
<LI> The attributes registerWork, and computeSalary are pattern attributes describing actions to be executed. They correspond to <INX>procedure</INX>s in most other languages. The enter-part describes the <INX>input parameters</INX> of a pattern and the exit-part describes its output parameters. registerWork has one input <INX>parameter</INX> noOfHours and computeSalary has one <INX>output parameter</INX>, salary.
<LI> registerWork is a <INX>non-virtual pattern attribute</INX>. This means that its complete description is given as part of the description of employee. It is similar to non-virtual functions in C++. 
<LI> computeSalary is a <INX>virtual pattern attribute</INX> (specified by using the ':&lt;<INX HIDDEN>:<</INX><!-- Cannot index &lt; -->' symbol). Only part of its description is given since the computation of the salary is different for salesmen and workers. The description of a virtual pattern may be extended in subpatterns of employee. A virtual pattern attribute is similar to a virtual function in C++.
</UL>

<H2> Class and procedure patterns</H2>
<UL>
<LI> employee, registerWork and computeSalary are all examples of patterns. employee is an example of a pattern used as a class and is therefore called a <INX>class pattern</INX>. registerWork and computeSalary are examples of patterns used as procedures and are therefore called <INX>procedure pattern</INX>s. Technically there is no difference between class patterns and procedure patterns.
</UL>
<P> The following patterns are <INX>subpattern</INX>s of employee corresponding to salesmen and workers.</P>

<H2> Subpatterns of Employee</H2>

<BETA>
worker: employee
  (# seniority: @integer;
     computeSalary::< 
       (# do totalHours*80+seniority*4->salary; 0->totalHours #)
  #);
salesman: employee
  (# noOfSoldUnits: @integer;
     computeSalary::< 
       (# do totalHours*80+noOfSoldUnits*6->salary; 
             0->noOfSoldUnits->totalHours
       #)
  #)
</BETA>

<UL>
<LI> The class pattern worker adds the attribute seniority and extends the definition of computeSalary. The salary for a worker is a function of the totalHours being worked and the seniority of the worker.
<LI> The class pattern salesman adds the attribute noOfSoldUnits and describes another extension of computeSalary. The salary for a salesman is a function of the totalHours being worked and the noOfSoldUnits.
<LI> The symbol '::&lt;<INX HIDDEN>::<</INX><!-- Cannot index ::&lt; -->' describe the fact that the definition of computeSalary from the superpattern employee is extended. 
</UL>

<H2> Part object</H2>
<P> The above examples have shown instantiation of objects from patterns in the form of <INX>part-object</INX> attributes (like birthday: @date). An instance of, say worker, may in a similar way be generated by a declaration of the form:</P>

<BETA>
mary: @worker
</BETA>


<H2> Dynamic reference</H2>
<P> The above examples have also shown a <INX>dynamic reference</INX> (like dept: ^department). Such a reference is initially <INX>NONE</INX>. A dynamic reference to instances of worker may be declared as follows:</P>

<BETA>
theForeman: ^worker
</BETA>

<P> theForeman may be assigned a reference to the object referred by mary by execution of the following imperative:</P>

<BETA>
mary[] -> theForeman[]
</BETA>

<P> Note that the opposite assignment (theForeman[]->mary[]) is not legal since mary is a static reference. An instance of worker may be generated and its reference assigned to theForeman by executing the following imperative:</P>

<BETA>
&worker[] -> theForeman[]
</BETA>

<P> A few additional comments about constructs used so far:</P>
<UL>
<LI> The symbol &amp;<INX HIDDEN>&</INX><!-- Cannot index &amp; --> 
means <INX>new</INX>.
<LI> The symbol <INX>-&gt;</INX> is used for assignment of state.
<LI> An expression <INX>R[]</INX> denotes the reference to the object referred by R, whereas an expression R denotes the object itself. The above assignment thus means that the qualified reference theForeman is assigned a reference to the generated instance of worker.
<LI> An assignment of the form mary-&gt;theForeman means that the state of the object referred by mary is enforced upon the state of the object referred by theForeman. This form of assignment is called <INX>value assignment</INX>. If X and Y are integer objects then X -&gt; Y means that the value of X is assigned to the object Y.
</UL>
<P> In this section, it was shown how the most common object-oriented constructs may be expressed in BETA. In the following sections, examples of the more unique constructs will be given.</P>











<H2><INX>Singular Objects</INX></H2>
<P> Often there is only one object of a given type. In most languages it is necessary to make a class and generate a single instance. In BETA it is possible to describe a singular object directly. There is only one president of our company and he may be described as the following singular object:</P>

<BETA>
president: @employee(# computeSalary::< (# do BIG -> salary #) #)
</BETA>

<P> The declaration president is similar to the declaration of
mary. The difference is that in the declaration of mary, a pattern
name (worker) describes the objects whereas a complete object
description is used to describe the president.</P>

<P> The president object is an example of a singular <INX>data object</INX> corresponding to an instance of a class pattern. It
is also possible to describe singular action objects corresponding to
an instance of a procedure pattern. Examples of singular action
objects are given below.</P>





<H2>Subprocedure</H2>
<P> The previous sections has shown examples of patterns used as classes and procedures. For class patterns, examples of subpatterns have been given. Subpatterns may also be used for <INX>procedure pattern</INX>s. For attributes, <INX>subpattern</INX>s may add new attributes and extend definitions of virtual patterns in the superpattern. In addition, a subpattern may specify further imperatives which have to be combined with the imperatives of the superpattern. The combination of the imperatives is handled by the <INX>inner</INX> construct. Consider the following objects:</P>

<BETA>
mutex: @semaphore; sharedVar: @integer
</BETA>

<P> The variable sharedVar is shared by a number of concurrent processes. Mutual access to the variable is handled by the semaphore mutex. Update of sharedVar should then be performed as follows:</P>

<BETA>
mutex.P; m+sharedVar -> sharedVar; mutex.V
</BETA>


<H3> Abstract procedure pattern</H3>
<P> This pattern of actions must be used whenever sharedVar and other shared objects have to be accessed. Instead of manipulating the semaphore directly it is possible to encapsulate these operations in an abstract procedure pattern. The pattern entry can describe this encapsulation:</P>

<BETA>
entry: (# do mutex.P; inner; mutex.V #)
</BETA>

<P> Execution of entry locks mutex before the inner and releases it afterwards. inner may then in subpatterns of entry be replaced by arbitrary imperatives. The subpattern updateShared of entry updates sharedVar:</P>

<BETA>
updateShared: entry
  (# m: @integer 
  enter m 
  do sharedVar+m-> sharedVar
  #)
</BETA>

<P> Execution of an imperative</P>

<BETA>
123 -> updateShared
</BETA>

<P> will then result in execution of the actions</P>

<BETA>
mutex.P; sharedVar+123->sharedVar; mutex.V
</BETA>

<P> We may now define an abstract superpattern corresponding to a monitor:</P>

<BETA>
monitor:
  (# mutex: @semaphore;
     entry: (# do mutex.P; inner; mutex.V #);
     init:< (# do mutex.V(*initially open*); inner #)
  #);
</BETA>

<P> A (singular) monitor object may now be declared like shared below:</P>

<BETA>
shared: @monitor
  (# var: @integer;
     update: entry(# m: @integer enter m do var+m->var #);
     get: entry(# v: @integer do var->v exit v #)
  #)
</BETA>

<P> Semaphores are the basic mechanism in BETA for synchronization. They can express most synchronization problems, but may be complicated to use. It is therefore mandatory that high level abstraction mechanisms like monitor can be defined. In section 9 below, further details about concurrency in BETA will be given.</P>











<H2>Control Patterns</H2>
<P> Sub (procedure) patterns are used intensively in BETA for defining
<INX>control patterns</INX> (control structures). This includes simple
control patterns like cycle, forTo, etc. It also includes so-called
iterators on data objects like list, set and register. A pattern
describing a register of objects may have the following interface:</P> 

<H3> <INX>scan</INX> is a control pattern</H3>

<BETA>
register:
  (# has: (# E: ^type; B: @boolean enter E[] do  exit B #);
     insert: (# E: ^type enter E[] do  #);
     delete: (# E: ^type enter E[] do  #);
     scan: (# current: ^type do  inner  #);
     
  #)
</BETA>

<P> A number of details have been left out from the example. These include the representation and implementation of the register. A register may include instances of the pattern type, which has not been specified. Type is an example of a virtual class pattern which will be introduced later. For the moment type is assumed to stand for the pattern object which is a superclass of all patterns, i.e. a register may include instances of all patterns. An instance of register may be declared and used as follows:</P>

<BETA>
employees: @register;

mary[]->employees.insert; 
(if boss[]->employees.has then  if)
</BETA>

<P> The control pattern scan may be used as follows:</P>

<H3> Using a control pattern</H3>

<BETA>
0->totalSalary;
employees.scan
  (# do current.computeSalary+totalSalary->totalSalary #);
totalSalary->screen.putint
</BETA>

<P> This works as follows:</P>
<UL>
<LI> The imperative employees.scan(#  #) is an example of a singular <INX>action object</INX> as mentioned in section 4. 
<LI> The do-part of scan has an inner imperative which is executed for each element in the register. The details of this are not shown, but it may be implemented as a loop that steps through the elements of the register and executes inner for each element.
<LI> The attribute current of scan is used as an index variable that for each iteration refers to the current element of the register. This may be implemented by assigning the reference of the current element to current before inner is executed.
<LI> The effect of executing the above singular action object is that current.computeSalary+totalSalary-&gt;totalSalary is executed for each element in the register.
</UL>











<H2><INX>Nested Patterns</INX></H2>

<P> One of the characteristics of Algol-like languages is
<INX>block-structure</INX>, which allows for arbitrary
<INX>nesting</INX> of procedures. The possibility of nesting has been
carried over to BETA where patterns can be arbitrarily
nested. Block-structure is a powerful mechanism that extends the
modeling capabilities of languages. However, besides Simula and BETA,
none of the mainstream object-oriented languages supports
block-structure. In most object-oriented languages, an object may be
characterized by data attributes (instance variables) and procedure
attributes. In BETA, an object may in addition be characterized by
<INX>class pattern attributes</INX>. </P> 

<H2> BETA supports general block-structure</H2>
<P> In the examples presented so far, there have been two levels of nesting. The outer level corresponds to class patterns, like employee, and the inner level corresponds to procedure patterns, like computeSalary. In procedural languages like Algol and Pascal it is common practice to define procedures with local procedures. This is also possible in BETA.</P>

<H2> Nested Class Patterns</H2>
<P> The possibility of nesting classes is a powerful feature which is not possible in languages like C++ and Eiffel. The following example shows a class pattern that describes a product of our company:</P>

<BETA>
productDescription:
  (# name: @text;
     price: @integer;
     noOfSoldUnits: @integer;
     order:
       (# orderDate: @date;
          c: ^customer;
          print:<
            (#
            do name[] -> puttext;
               'Price: '->puttext; price -> putint; ' '->put;
               ' No of units sold: '->puttext; 
               noOfSoldUnits->putint; ' '->put;
               orderDate.print;
               C.print;
               inner
            #)
       #)
  #);
</BETA>

<P> One of the attributes of a productDescription object is the class pattern order. An instance of order describes an order made on this product by some customer. The attributes of an order object include the date of the order, the number of units ordered, the customer ordering the product, and a print operation. Consider the objects:</P>

<BETA>
P1,P2: @product; o1,o2: @P1.order; o3,o4: @P2.order
</BETA>

<P> The objects o1 and o2 are instances of P1.order whereas o3 and o4 are instances of P2.order. The block-structure makes it possible to refer to global names in <INX>enclosing objects</INX>. In the above example, the print operation refers to names in the enclosing order object. This resembles most object-oriented languages where operations inside a procedure refer to names in the enclosing object. The print operation, however, also refers to names in the surrounding productDescription object. Execution of say o1.print will thus print the values of P1.name, P1.price, P1.noOfSoldUnits, o1.orderDate, and o1.c.</P>












