<H1> BETA <INX>Terminology</INX></H1>
<P> The following is a short description of important concepts used in
the BETA language.  Please note, that these descriptions are
deliberately informal.  The precise meanings of these terms must be
found in 
<A HREF="../bibliography/index.html#mmn93">[MMN 93]</A>.</P>




<DIV CLASS=toc>
<DL>
<DT><B>Contents</B>
<DD>
<DL>
<DT>
<DD>
<DT><A HREF="#Modelling">Modelling</A>
<DD>
<DT><A HREF="#Declarations and Object Descriptors">Declarations and Object Descriptors</A>
<DD>
<DT><A HREF="#Reference Attributes">Reference Attributes</A>
<DD>
<DT><A HREF="#Pattern Attributes">Pattern Attributes</A>
<DD>
<DT><A HREF="#Imperatives">Imperatives</A>
<DD>
<DT><A HREF="#Block Structure and Scoping">Block Structure and Scoping</A>
<DD>
<DT><A HREF="#Inserted Objects">Inserted Objects</A>
<DD>
<DT><A HREF="#Inheritance">Inheritance</A>
<DD>
<DT><A HREF="#Virtual Patterns">Virtual Patterns</A>
<DD>
</DL>
</DL>
</DIV>

<A NAME="Modelling"><H2><INX>Modelling</INX></H2></A>

<DL>

<DT><A NAME="Object-oriented programming"><B><INX>Object-oriented programming</INX></B></A>
<DD>
<P> A <I>program execution</I> is viewed as a <I><INX>physical model</INX></I>  or <I><INX>representation</INX></I> of part of the world.  <I><INX>Objects</INX></I> on the computer model phenomena in the world; <I><INX>attributes</INX></I> of objects model properties of phenomena.</P>
<BLOCKQUOTE>
<TABLE BORDER=1 class=opaque><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><P> Computer</P>
</TD><TD><P> Real world</P>
</TD></TR><TR VALIGN=TOP><TD><P> <I>Object</I></P>
</TD><TD><P> <I>Phenomenon</I></P>
</TD></TR><TR VALIGN=TOP><TD><P> <I>Attribute</I></P>
</TD><TD><P> <I>Property</I></P>
</TD></TR><TR VALIGN=TOP><TD><P> <I>Pattern</I></P>
</TD><TD><P> <I>Concept</I></P>
</TD></TR></TABLE>
</BLOCKQUOTE>



<DT><A NAME="BETA program execution"><B><INX>BETA program execution</INX></B></A>
<DD>
<P> A collection of <I><INX>objects</INX></I>.  Some represent phenomena while others are simply part of the implementation.</P>

<DT><A NAME="Object"><B><INX>Object</INX></B></A>
<DD>
<P> Computer representation of a real world <INX>phenomenon</INX>.  Its structure consists of <INX>attributes</INX> and <INX>actions</INX>.</P>

<DT><A NAME="Pattern"><B><INX>Pattern</INX></B></A>
<DD>
<P> Computer representation of a real world <INX>concept</INX>.  Objects defined according to the pattern are called <I><INX>instances</INX> </I>or <I><INX>pattern defined objects</INX></I>:  A pattern is to its instances as a concept is to its phenomena. </P>

<DT><A NAME="Singular object"><B><INX>Singular object</INX></B></A>
<DD>
<P> An object representing a <INX>singular</INX> "one-of-a-kind" phenomenon - the object is not defined as an instance of some pattern. </P>

<DT><A NAME="State of an object"><B><INX>State</INX> of an object</B></A>
<DD>
<P> The combined values of its <I><INX>measurable properties</INX></I> at some point in time.</P>

<DT><A NAME="Measurable property"><B><INX>Measurable property</INX></B></A>
<DD>
<P> A property which has a measurable value.  The value may vary over time.</P>

<DT><A NAME="Part object"><B><INX>Part object</INX></B></A>
<DD>
<P> An object which is part of another object.  Part objects are used to model part or aggregation hierarchies.</P>

<DT><A NAME="Separate object"><B><INX>Separate object</INX></B></A>
<DD>
<P> An autonomous self-contained object which is not a part object.</P>

<DT><A NAME="Reference to separate object"><B><INX>Reference to separate object</INX></B></A>
<DD>
<P> An attribute which is a reference to a separate object.</P>

<DT><A NAME="Kinds of actions"><B><INX>Kinds of actions</INX></B></A>
<DD>
<P> The actions of a phenomenon in a real world system often take
place <I><INX>concurrently</INX></I> (i.e. in parallel) with those of other
phenomena in the system.  A single phenomenon normally
<I><INX>alternates</INX></I> among its own actions.</P>

</DL>



<A NAME="Declarations and Object Descriptors">
<H2><INX>Declarations and Object Descriptors</INX></H2>
</A>

<DL>

<DT><A NAME="Declaration or attribute declaration"><B><INX>Declaration or attribute declaration</INX></B></A>
<DD>
<P> An association or <I><INX>binding</INX></I> of a name to some entity.  The syntactic construct used is the colon &quot;:&quot; as in, &lt;name&gt;: &lt;entity<B><INX>&gt;</INX></B>.  For attributes of an object descriptor, these are sometimes referred to as the <I><INX>attribute name</INX></I> and <I><INX>attribute description</INX></I>, respectively.</P>

<DT><A NAME="Pattern declaration"><B><INX>Pattern declaration</INX></B></A>
<DD>
<P> A declaration binding a <I><INX>pattern name</INX></I> to an object descriptor, describing the structure of <I><INX>instances of the pattern</INX></I>.  Pattern declarations serve as templates for generating objects having a given structure.  </P>
<P> Syntax is:  </P>

<PRE CLASS=BETA> &lt;name&gt;<B>:</B> &lt;object-descriptor&gt;</PRE>


<DT><A NAME="Singular object declaration"><B><INX>Singular object declaration</INX></B></A>
<DD>
<P> Declaration of a singular object binding the object name to the singular object description (an object descriptor). </P>
<P> Syntax is:  </P>

<PRE CLASS=BETA> &lt;name&gt;<B>: @</B>&lt;object-descriptor&gt;</PRE>


<DT><A NAME="Attribute reference"><B><INX>Attribute reference</INX></B></A>
<DD>
<P> An occurrence of an attribute's name in an object descriptor.</P>

<DT><A NAME="Local attribute reference of a pattern"><B><INX>Local attribute reference of a pattern</INX></B></A>
<DD>
<P> A reference from within a pattern's object descriptor to an attribute declared inside the same object descriptor.</P>

<DT><A NAME="Global attribute reference"><B><INX>Global attribute reference</INX></B></A>
<DD>
<P> Any attribute reference which is not local.</P>

<DT><A NAME="Object-descriptor"><B><INX>Object-descriptor</INX></B></A>
<DD>
<P> Used to describe the structure of objects and consists of a <I><INX>prefix part</INX></I> and a <I><INX>main part</INX></I>.</P>

<DT><A NAME="Prefix part"><B><INX>Prefix part</INX></B></A>
<DD>
<P> Part of object descriptor used to specify the superpattern of the descriptor.   The prefix part is specified by a pattern name (or is empty).</P>

<DT><A NAME="Main part"><B><INX>Main part</INX></B></A>
<DD>
<P> Used to describe the additional structure of objects.  Has the syntactic form(# E #) and consists of an <I><INX>attribute part and an action part.</INX></I></P>

<DT><A NAME="Attribute part"><B><INX>Attribute part</INX></B></A>
<DD>
<P> Part of object descriptor used to describe the object's attributes.  Consists of a list of <I><INX>attribute declarations</INX></I>.</P>

<DT><A NAME="Action part"><B><INX>Action part</INX></B></A>
<DD>
<P> Part of object descriptor used to describe the actions to be performed when the object is executed.  Consists of three parts: <I><INX>enter-part</INX></I>, <I><INX>do-part</INX></I>, <I><INX>exit-part</INX></I>.</P>

<DT><A NAME="Enter part"><B><INX>Enter part</INX></B></A>
<DD>
<P> Part of <I><INX>action part</INX></I> describing the <I><INX>enter parameters</INX></I>.</P>

<DT><A NAME="Do part"><B><INX>Do part</INX></B></A>
<DD>
<P> Part of <I><INX>action part</INX></I> consisting of a list of <I><INX>imperatives</INX></I>.  </P>

<DT><A NAME="Exit part"><B><INX>Exit part</INX></B></A>
<DD>
<P> Part of <I><INX>action part</INX></I> describing the exit <I><INX>parameters</INX></I>.</P>

<DT><A NAME="Program"><B><INX>Program</INX></B></A>
<DD>
<P>   An object descriptor that can be compiled and executed.</P>


</DL>

<A NAME="Reference Attributes"><H2><INX>Reference Attributes</INX></H2></A>


<DL>


<DT><A NAME="Reference attribute"><B><INX>Reference attribute</INX></B></A>
<DD>
<P> An attribute that denotes an object.  Reference attributes can be either <I><INX>static references</INX></I> or <I><INX>dynamic references</INX></I>.</P>

<DT><A NAME="Static reference"><B><INX>Static reference</INX></B></A>
<DD>
<P> A reference attribute that constantly denotes the same object.  Such objects are often referred to as <I><INX>static objects</INX></I>.  In cases where these objects are used to model part (or aggregation) hierarchies, they are referred to as <I><INX>part objects</INX></I>, that is, they are part of an <I><INX>enclosing object</INX></I>.  </P>

<DT><A NAME="Static reference declaration"><B><INX>Static reference declaration</INX></B></A>
<DD>
<P> Used to define static reference attributes.  </P>
<P> Syntax is: </P>

<PRE CLASS=BETA> &lt;name&gt;<B>: @</B>&lt;ptn.name or
obj.descriptor&gt;</PRE>


<DT><A NAME="Dynamic reference"><B><INX>Dynamic reference</INX></B></A>
<DD>
<P> A reference attribute that denotes a object.  The reference is variable in that it may denote different objects over time.  Initially it denotes <I><INX>NONE</INX></I> which represents &quot;no object.&quot;</P>

<DT><A NAME="Dynamic reference declaration"><B><INX>Dynamic reference declaration</INX></B></A>
<DD>
<P> Used to define dynamic reference attributes.  </P>
<P> Syntax is: </P>

<PRE CLASS=BETA> &lt;name&gt;<B>: ^</B>&lt;pattern name&gt;</PRE>


<DT><A NAME="Indexed collection of static / dynamic references"><B><INX>Indexed collection of static / dynamic references</INX></B></A>
<DD>
<P> A repetition (or <I><INX>array</INX></I>) of object references referred to by a single name plus an index.  The size of a repetition A is denoted by A.range.  A[1] refers to the first element in the repetition, A[A.range] to the last.</P>
<P> Syntax is:</P>

<PRE CLASS=BETA> Name<B>: [</B>eval] <B>@</B>&lt;ptn.name or obj.descriptor&gt;
 Name<B>: [</B>eval] <B>^</B>&lt;ptn.name&gt;</PRE>

<P> The size of the repetition can be dynamically extended by:</P>

<PRE CLASS=BETA> &lt;number&gt; -&gt; A.<B>extend</B></PRE>


<DT><A NAME="Qualification or qualifying pattern"><B>Qualification or qualifying pattern</B></A>
<DD>
<P> The pattern name appearing in a reference attribute declaration.  It restricts the set of objects that can be denoted by the reference.</P>

<DT><A NAME="Remote access"><B><INX>Remote access</INX></B></A>
<DD>
<P> Used to denote attributes within an enclosing object.  </P>
<P> Syntax is:</P>

<PRE CLASS=BETA> reference<B>.</B>attribute</PRE>


<DT><A NAME="Computed Remote access"><B><INX>Computed Remote access</INX></B></A>
<DD>
<P> Used to denote attributes within objects that are returned as the result of evaluations.  </P>
<P> Syntax is:</P>

<PRE CLASS=BETA> <B>(</B>evaluation<B>).</B>attribute</PRE>



</DL>

<A NAME="Pattern Attributes"><H2><INX>Pattern Attributes</INX></H2></A>


<DL>
<DT><A NAME="Pattern reference"><B><INX>Pattern reference</INX></B></A>
<DD>
<P> A reference attribute that denotes a pattern.  The structure of the pattern is represented locally using a <I><INX>structure object</INX></I>.  Such objects include a reference back to the object of which the pattern is an attribute.  This reference is called the <I><INX>origin</INX></I> of the pattern.</P>

<DT><A NAME="Pattern reference declaration"><B><INX>Pattern reference declaration</INX></B></A>
<DD>
<P> Used to define a pattern.  </P>
<P> Syntax is:</P>

<PRE CLASS=BETA> &lt;name&gt;<B>:</B> &lt;object descriptor&gt;</PRE>


<DT><A NAME="Pattern variable declaration"><B><INX>Pattern variable declaration</INX></B></A>
<DD>
<P> Used to define pattern variable attributes.  A pattern variable may denote different patterns during the execution.  The qualification restricts the set of patterns which may be denoted by the pattern variable.</P>
<P> Syntax is: </P>

<PRE CLASS=BETA> &lt;name&gt;<B>: ##</B>&lt;pattern name&gt;</PRE>


<DT><A NAME="Class pattern"><B><INX>Class pattern</INX></B></A>
<DD>
<P> Generally, a pattern used to model physical objects.</P>

<DT><A NAME="Procedure pattern"><B><INX>Procedure pattern</INX></B></A>
<DD>
<P> Generally, a pattern used to model action sequences.</P>

<DT><A NAME="Function pattern"><B><INX>Function pattern</INX></B></A>
<DD>
<P> A procedure pattern which computes and returns a value.  Such patterns always have an exit part.</P>

<DT><A NAME="Basic pattern"><B><INX>Basic pattern</INX></B></A>
<DD>
<P> A pattern that is predefined within the BETA language.  Examples are integer, real, boolean, and char.  Relevant operations include: +, -, *, div, mod, and, or, not, true, false, =, &lt;, &gt;, &lt;&gt;, &lt;=, &gt;=.</P>


</DL>

<A NAME="Imperatives"><H2><INX>Imperatives</INX></H2></A>


<DL>
<DT><A NAME="Imperative"><B><INX>Imperative</INX></B></A>
<DD>
<P> Describes an action; <I><INX>executing</INX></I> the imperative causes the action.  Imperatives appear in the do-part of an object.  Kinds of imperatives include <I><INX>evaluations</INX></I>, <I><INX>reference assignments</INX></I>, <I><INX>dynamic object creation</INX></I>, and <I><INX>control structures</INX></I>.</P>

<DT><A NAME="Evaluation imperative"><B><INX>Evaluation imperative</INX></B></A>
<DD>
<P> An imperative that can cause state changes and may produce a value when executed.</P>

<DT><A NAME="Value assignment"><B><INX>Value assignment</INX></B></A>
<DD>
<P> An evaluation imperative that sets (changes) the value of an attribute.</P>
<P> Syntax is:</P>

<PRE CLASS=BETA> 3 <B>-&gt;</B> I</PRE>


<DT><A NAME="Reference assignment"><B><INX>Reference assignment</INX></B></A>
<DD>
<P> An <I><INX>imperative</INX></I> used to change the value of a dynamic reference. </P>
<P> Syntax is: </P>

<PRE CLASS=BETA> objRef<B>[] -&gt;</B> dynObjRef<B>[]</B> </PRE>

<P> objRef  may be any object reference but dynObjRef <I><INX>must be a dynamic object reference.</INX></I></P>

<DT><A NAME="Pattern assignment"><B><INX>Pattern assignment</INX></B></A>
<DD>
<P> An <I><INX>imperative</INX></I> used to change the pattern denoted by a pattern variable.</P>
<P> Syntax is:</P>

<PRE CLASS=BETA> ref<B>## -&gt;</B> dynPatRef<B>##</B></PRE>

<P> Ref may be the name of a pattern variable, the name of an object, or the name of a pattern but dynPatRef <I><INX>must be a dynamic pattern reference.</INX></I></P>

<DT><A NAME="Multiple assignment"><B><INX>Multiple assignment</INX></B></A>
<DD>
<P> An evaluation imperative that causes several assignments.</P>
<P> Syntax is:</P>

<PRE CLASS=BETA> 3 -&gt; I -&gt; J</PRE>


<DT><A NAME="Dynamic object creation / generation"><B><INX>Dynamic object creation / generation</INX></B></A>
<DD>
<P> Imperatives used to create new <I><INX>dynamic objects</INX></I>. </P>
<P> Syntax is:</P>

<PRE CLASS=BETA> <B>&amp;</B>Pat   or   <B>&amp;</B>Pat<B>[]</B></PRE>


<DT><A NAME="Value equality"><B><INX>Value equality</INX></B></A>
<DD>
<P> True when two references denote objects that have the same state. </P>
<P> Syntax is: </P>

<PRE CLASS=BETA> A <B>=</B> B</PRE>


<DT><A NAME="Reference equality"><B><INX>Reference equality</INX></B></A>
<DD>
<P> True when two references denote the same object.</P>
<P> Syntax is:</P>

<PRE CLASS=BETA> A<B>[] =</B> B<B>[]</B></PRE>


<DT><A NAME="Pattern equality"><B><INX>Pattern equality</INX></B></A>
<DD>
<P> True when two pattern references denote the same pattern. </P>
<P> Syntax is:</P>

<PRE CLASS=BETA> A<B>## =</B> B<B>##</B></PRE>

<P> Note that &lt; and &lt;= are also defined for pattern comparisons based on the inheritance hierarchy.</P>

<DT><A NAME="Procedure call "><B><INX>Procedure call </INX></B></A>
<DD>
<P> An evaluation imperative that causes invocation of a procedure pattern.</P>
<P> Syntax is:</P>

<PRE CLASS=BETA> <B>&amp;</B>ProcPat</PRE>

<P>  or</P>

<PRE CLASS=BETA> (arg1,arg2) -&gt; &amp;ProcPat</PRE>


<DT><A NAME="Function call"><B><INX>Function call</INX></B></A>
<DD>
<P> An evaluation imperative that causes invocation of a function pattern.</P>
<P> Syntax is:</P>

<PRE CLASS=BETA> (arg1,arg2) -&gt; <B>&amp;</B>FuncPat -&gt;
result</PRE>


<DT><A NAME="Control structure"><B><INX>Control structure</INX></B></A>
<DD>
<P> An imperative that controls the flow of executions.</P>

<DT><A NAME="For imperative"><B><INX>For imperative</INX></B></A>
<DD>
<P> A control structure used to support <I><INX>iteration</INX></I>.  A list of imperatives are executed repeatedly while an index steps from 1 up to the number of iterations.</P>
<P> Syntax is:</P>

<PRE CLASS=BETA> <B>(for</B> Index: Range <B>repeat</B>
      Imperative-list
<P> <B>for)</B></PRE>


<DT><A NAME="General-if imperative"><B><INX>General-if imperative</INX></B></A>
<DD>
<P> A control structure used to support <I><INX>selection</INX></I>.  Based on evaluating a condition evaluation and comparing it to the values of a number of selection evaluations, one of a set of imperative-lists is executed. </P>
<P> Syntax is:</P>

<PRE CLASS=BETA> <B>(if</B> E0
  <B>//</B> E1 <B>then</B> I1
  <B>//</B> E2 <B>then</B> I2
  E
  <B>//</B> En <B>then</B> In
  <B>else</B> I
  <B>if)</B></PRE>


<DT><A NAME="Simple-if imperative"><B><INX>Simple-if imperative</INX></B></A>
<DD>
<P> A control structure used to support boolean <I><INX>selection</INX></I>.  Based on evaluating a condition evaluation and testing if it is true or false, one of two imperative-lists is executed. </P>
<P> Syntax is:</P>

<PRE CLASS=BETA> <B>(if</B> E <B>then</B>
     I1
  <B>else</B> I2
 <B>if)</B></PRE>


<DT><A NAME="Labelled imperative"><B><INX>Labelled imperative</INX></B></A>
<DD>
<P> A means of naming an imperative.  References to the label (via <I><INX>jump imperatives</INX></I>) can be made from within the imperative.</P>
<P> Syntax is:</P>

<PRE CLASS=BETA> L: Imperative</PRE>

<P>or</P>

<PRE CLASS=BETA> L: <B>(#</B> ... <B>do</B> ... <B>#)</B></PRE>


<DT><A NAME="Jump imperative"><B><INX>Jump imperative</INX></B></A>
<DD>
<P> Causes flow of control to &quot;jump&quot; to another location.  A jump imperative is one of a <I><INX>Leave imperative</INX></I> or a <I><INX>Restart imperative</INX></I>.</P>

<DT><A NAME="Leave imperative"><B><INX>Leave imperative</INX></B></A>
<DD>
<P> Causes termination of the execution of a labelled imperative; execution resumes after the labelled imperative.  This imperative can only appear within the labelled imperative. </P>
<P> Syntax is:</P>

<PRE CLASS=BETA> <B>leave</B> L</PRE>


<DT><A NAME="Restart imperative"><B><INX>Restart imperative</INX></B></A>
<DD>
<P> Causes restarting of the execution of a labelled imperative, that is, jump is to the start of the imperative.  Can only appear within the labelled imperative.</P>
<P> Syntax is:</P>

<PRE CLASS=BETA> <B>restart</B> L</PRE>

</DL>




<A NAME="Block Structure and Scoping"><H2><INX>Block Structure and Scoping</INX></H2></A>


<DL>
<DT><A NAME="Block structure"><B><INX>Block structure</INX></B></A>
<DD>
<P> The nesting of one structure in another in the text of a program.
In BETA, object descriptors and imperatives can be nested inside of
other object descriptors and imperatives.  It is the job of the
programmer to use <I><INX>indentation</INX></I> to make such nesting visible to
readers.  In the following example, Deposit's object descriptor is
nested inside of Account's.</P>

<PRE CLASS=BETA> Account:
   <B>(# </B>Deposit:
        <B>(#</B> E
        <B>do</B> E
        <B>#);</B>
   <B>#);</B></PRE>


<DT><A NAME="Declaration of a name"><B><INX>Declaration of a name</INX></B></A>
<DD>
<P> An association of a name with some defining expression.</P>
<P> Syntax is: </P>

<PRE CLASS=BETA> &lt;name&gt;<B>:</B> E</PRE>

<P> Recall that colon &quot;:&quot; always signals a declaration of some kind.</P>

<DT><A NAME="Application of a name"><B><INX>Application of a name</INX></B></A>
<DD>
<P> Any occurrence of a name in a program which is not a declaration.  Note that this does not include keywords of the BETA syntax (e.g. if, for, repeat, do), but does include predefined pattern and attribute names (e.g. char, putInt, stream).</P>

<DT><A NAME="Scope of a declaration"><B><INX>Scope of a declaration</INX></B></A>
<DD>
<P> The part of the program text &quot;covered&quot; by the declaration, that is, where applications of the declared name refer to the given declaration.  In BETA, the scope of a declaration is the object descriptor it appears in.  The exception to this is that the declaration may be &quot;hidden&quot; by declarations of the same name in nested object descriptors or labelled imperatives.  Note that the declared name can also be applied outside its object descriptor using remote access.  We say that a name is <I><INX>local</INX></I> to the object descriptor in which it is declared and <I><INX>global</INX></I> to any nested object descriptors (for which it is not hidden).</P>


</DL>

<A NAME="Inserted Objects"><H2><INX>Inserted Objects</INX></H2></A>



<DL>

<DT><A NAME="Inserted item"><B><INX>Inserted item</INX></B></A>
<DD>
<P> A means of generating (and executing) a procedure object allocated as part of the enclosing object.</P>
<P> Syntax is:</P>

<PRE CLASS=BETA> A <B>-&gt;</B> P <B>-&gt;</B> B</PRE>

<P>  or</P>

<PRE CLASS=BETA> A <B>-&gt;</B> P<B>(#</B> E <B>#)</B> <B>-&gt;</B> B</PRE>

<P> This differs from dynamic generation, &amp;P, in that the instance of P is generated only once rather than each time the imperative is executed.  Note that inserted items should not be used to define recursive procedures.  That is, an inserted instance of P may be specified in the action part of P.</P>

</DL>


<A NAME="Inheritance"><H2><INX>Inheritance</INX></H2></A>


<DL>
<DT><A NAME="Direct subpattern"><B><INX>Direct subpattern</INX></B></A>
<DD>
<P> A pattern P is a <I><INX>direct subpattern</INX></I> of Q if P extends (specialises) the definition of Q.  Q is called the <I><INX>direct</INX></I> <I><INX>superpattern</INX></I> of P and instances of P are also instances of Q.</P>
<P> Syntax is:</P>

<PRE CLASS=BETA> P<B>:</B> Q<B>(#</B> E <B>#)</B></PRE>

<P> Q is called the <I><INX>prefix pattern</INX></I> (or simply <I><INX>prefix</INX></I>), while the contents of (# E #) is called the <I><INX>main-part</INX></I>  of P.  The prefix Q means that P's object descriptor <I><INX>inherits</INX></I> all of Q's declarations in addition to any new ones defined in P's main-part.  </P>

<DT><A NAME="Subpattern"><B><INX>Subpattern</INX></B></A>
<DD>
<P> A pattern P is a <I><INX>subpattern</INX></I> of Q if it is either a direct subpattern of Q or a subpattern of a direct subpattern of Q.  Likewise, Q is a <I><INX>superpattern</INX></I> of P if it is either a direct superpattern of P or a superpattern of the direct superpattern of P.  A pattern can have at most one direct superpattern.</P>

<DT><A NAME="Abstract superpattern"><B><INX>Abstract superpattern</INX></B></A>
<DD>
<P> A pattern used only as a superpattern for other patterns, that is, it is not intended to be used to generate objects.  If P is declared without the use of a superpattern, P: (# E #), then P is assumed to be a subpattern of the most general abstract superpattern, Object.  Note that the basic patterns, Integer, Real, Boolean, Char and Real are not subpatterns of Object.</P>

<DT><A NAME="Superpattern as qualification"><B><INX>Superpattern as qualification</INX></B></A>
<DD>
<P> If R is a dynamic reference qualified by the pattern Q (i.e. R: ^Q) and Q is a superpattern of P, then instances of both P and Q can be assigned to R.  However, only attributes of Q (and of superpatterns of Q) can be accessed using remote access through R.  That is, if attribute A is declared in the main part of P, then the remote access R.A is illegal.</P>

<DT><A NAME="Action specialisation"><B><INX>Action specialisation</INX></B></A>
<DD>
<P> The use of a subpattern to extend the action part of a pattern.  Action specialisation can involve any or all of the enter-part, exit-part and do-part.  The enter and exit parts of instances of P (again, a subpattern of Q) consist of Q's enter and exit parameters together with those defined by P.  Extending the do-part of Q requires the use of the <B><INX>inner</INX></B> imperative in Q's action part.  Executing the do-part of an instance of P proceeds by executing Q's do-part and executing P's do-part each time inner is encountered.</P>
<P> Syntax is:</P>

<PRE CLASS=BETA> Q: <B>(#</B> E <B>do</B> E <B>inner</B> E <B>#);</B>
 P: Q<B>(#</B> E <B>do</B> E <B>#);</B></PRE>



</DL>


<A NAME="Virtual Patterns"><H2><INX>Virtual Patterns</INX></H2></A>



<DL>
<DT><A NAME="Virtual pattern"><B><INX>Virtual pattern</INX></B></A>
<DD>
<P> A pattern attribute V of a pattern Q is <I><INX>virtual</INX></I> if it is only partially defined in Q.  That is, the definition of V can be extended in subpatterns of Q.</P>
<P> Syntax is:</P>

<PRE CLASS=BETA> Q: <B>(#</B> V<B>:&lt;</B> S <B>#)</B>
 Q: <B>(#</B> V<B>:&lt;</B> S0<B>(#</B> E <B>#)</B> <B>#)</B>
 Q: <B>(#</B> V<B>:&lt;</B> <B>(#</B> E <B>#)</B> <B>#)</B></PRE>

<P> In the first of the three forms, we say that the virtual V is <I><INX>qualified</INX></I> by the pattern S, in the second and third forms, we say that V is <I><INX>directly qualified</INX></I>.</P>


<DT><A NAME="Further binding of a virtual pattern"><B><INX>Further binding of a virtual pattern</INX></B></A>
<DD>
<P> The means by which a virtual attribute V of a pattern Q is extended in a subpattern P of Q.</P>
<P> Syntax is:</P>

<PRE CLASS=BETA> P: Q<B>(#</B> V<B>::&lt;</B> S1 <B>#)</B>
 P: Q<B>(#</B> V<B>::&lt;</B> S1<B>(#</B> E <B>#)</B> <B>#)</B>
 P: Q<B>(#</B> V<B>::&lt;</B> <B>(#</B> E <B>#)</B> <B>#)</B></PRE>

<P> S1, S1(# E #), or (# E #) is called the <I><INX>extended descriptor</INX></I> of V.  If we're using either the first or second form, and if V is qualified by S in the pattern Q, then S1 must be a subpattern of S.  In the case of the third form there are no constraints on Q's declaration of V.  If X is an instance of P, then X.V specialises (that is, adds properties to) the definition of V in Q.  Note that V is now a virtual pattern in P (as well as Q) and can continue to be further bound in subpatterns of P.</P>

<DT><A NAME="Final binding of a virtual pattern"><B><INX>Final binding of a virtual pattern</INX></B></A>
<DD>
<P> The means by which a virtual attribute V of a pattern Q is extended in a subpattern P of Q, and at the same time made non-virtual.</P>
<P> Syntax is:</P>

<PRE CLASS=BETA> R: P<B>(#</B> V<B>::</B> S2 <B>#)</B>
 R: P<B>(#</B> V<B>::</B> S2<B>(#</B> E <B>#)</B> <B>#)</B>
 R: P<B>(#</B> V<B>::</B> <B>(#</B> E <B>#)</B> <B>#)</B></PRE>

<P> Final binding is identical to further binding, except that with final binding, V is no longer virtual.</P>


</DL>


