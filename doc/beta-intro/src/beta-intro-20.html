<H1> <A NAME="LINK-beta-intro-_Toc403635894"><A NAME=MARKER-9-96></A>Patterns and Objects</A></H1>
<P> Most object-oriented languages supporting the object-oriented perspective have constructs such as class, subclass, virtual procedure, and qualified reference variable. These constructs all originated with Simula. Eiffel and C++ include these constructs although a different terminology is used. In addition to virtual procedures BETA also has non-virtual procedures. </P>
<P> In this introduction, the BETA version of the above constructs will be described and compared to other object-oriented languages. The example used in the following is a company with different kinds of employees, including salesmen and workers. employee is an abstract superpattern describing the common properties of all employees.</P>
<A NAME=HEADING20-3></A>
<H1> Pattern Employee</H1>
<PRE CLASS=beta>
employee:
  (# name: @text;
     birthday: @date;
     dept: ^Department;
     totalHours: @integer;
     registerWork:
       (# noOfHours: @integer
       enter noOfHours
       do noOfHours + totalhours -&gt; totalHours
       #);
     computeSalary:&lt;
       (# salary: @integer
       do inner
       exit salary
       #);
  #);
</PRE>
<P> The elements of the employee pattern have the following meaning:</P>
<A NAME=HEADING20-6></A>
<H1> Elements of Employee</H1>
<UL>
<LI> The attributes name, birthday, dept and totalHours are reference attribute<A NAME=MARKER-2-98></A>s denoting instances of the patterns text, date, department and integer respectively.
<LI> Name, birthday, and totalHours refer to part-object<A NAME=MARKER-2-99></A>s. A part-object is a fixed part of its enclosed object and is generated together with the enclosing object. Part-objects are also found in Eiffel and C++.
<LI> Dept is a dynamic reference<A NAME=MARKER-2-100></A> that either has the value NONE<A NAME=MARKER-2-101></A> or refers to a separate instance of the pattern department.
<LI> The attributes registerWork, and computeSalary are pattern attributes describing actions to be executed. They correspond to procedure<A NAME=MARKER-2-102></A>s in most other languages. The enter-part describes the input parameters<A NAME=MARKER-2-103></A> of a pattern and the exit-part describes its output parameters. registerWork has one input parameter<A NAME=MARKER-2-104></A> noOfHours and computeSalary has one output parameter<A NAME=MARKER-2-105></A>, salary.
<LI> registerWork is a non-virtual pattern attribute<A NAME=MARKER-2-106></A>. This means that its complete description is given as part of the description of employee. It is similar to non-virtual functions in C++. 
<LI> computeSalary is a virtual pattern attribute<A NAME=MARKER-2-107></A> (specified by using the '<A NAME=MARKER-2-108>:&lt;</A>' symbol). Only part of its description is given since the computation of the salary is different for salesmen and workers. The description of a virtual pattern may be extended in subpatterns of employee. A virtual pattern attribute is similar to a virtual function in C++.
</UL>
<A NAME=HEADING20-13></A>
<H1> Class and procedure patterns</H1>
<UL>
<LI> employee, registerWork and computeSalary are all examples of patterns. employee is an example of a pattern used as a class and is therefore called a class pattern<A NAME=MARKER-2-109></A>. registerWork and computeSalary are examples of patterns used as procedures and are therefore called procedure pattern<A NAME=MARKER-2-110></A>s. Technically there is no difference between class patterns and procedure patterns.
</UL>
<P> The following patterns are subpattern<A NAME=MARKER-2-111></A>s of employee corresponding to salesmen and workers.</P>
<A NAME=HEADING20-16></A>
<H1> Subpatterns of Employee</H1>
<PRE CLASS=beta>
worker: employee
  (# seniority: @integer;
     computeSalary::&lt; 
       (# do noOfHours*80+seniority*4-&gt;salary; 0-&gt;totalHours #)
  #);
salesman: employee
  (# noOfSoldUnits: @integer;
     computeSalary::&lt; 
       (# do noOfHours*80+noOfSoldUnits*6-&gt;salary; 
             0-&gt;noOfSoldUnits-&gt;totalHours
       #)
  #)
</PRE>
<UL>
<LI> The class pattern worker adds the attribute seniority and extends the definition of computeSalary. The salary for a worker is a function of the noOfHours being worked and the seniority of the worker.
<LI> The class pattern salesman adds the attribute noOfSoldUnits and describes another extension of computeSalary. The salary for a salesman is a function of the noOfHours being worked and the noOfSoldUnits.
<LI> The symbol '<A NAME=MARKER-2-112>::&lt;</A>' describe the fact that the definition of computeSalary from the superpattern employee is extended. 
</UL>
<A NAME=HEADING20-21></A>
<H1> Part object</H1>
<P> The above examples have shown instantiation of objects from patterns in the form of part-object<A NAME=MARKER-2-113></A> attributes (like birthday: @date). An instance of, say worker, may in a similar way be generated by a declaration of the form:</P>
<PRE CLASS=beta>
mary: @worker
</PRE>
<A NAME=HEADING20-24></A>
<H1> Dynamic reference</H1>
<P> The above examples have also shown a dynamic reference<A NAME=MARKER-2-114></A> (like dept: ^department). Such a reference is initially NONE<A NAME=MARKER-2-115></A>. A dynamic reference to instances of worker may be declared as follows:</P>
<PRE CLASS=beta>
theForeman: ^worker
</PRE>
<P> theForeman may be assigned a reference to the object referred by mary by execution of the following imperative:</P>
<PRE CLASS=beta>
mary[] -&gt; theForeman[]
</PRE>
<P> Note that the opposite assignment (theForeman[]-&gt;mary[]) is not legal since mary is a static reference. An instance of worker may be generated and its reference assigned to theForeman by executing the following imperative:</P>
<PRE CLASS=beta>
&amp;worker[] -&gt; theForeman[]
</PRE>
<P> A few additional comments about constructs used so far:</P>
<UL>
<LI> The symbol <A NAME=MARKER-2-116>&amp;</A> means <A NAME=MARKER-2-117>new</A>.
<LI> The symbol <A NAME=MARKER-2-118>-&gt;</A> is used for assignment of state.
<LI> An expression <A NAME=MARKER-2-119>R[]</A> denotes the reference to the object referred by R, whereas an expression R denotes the object itself. The above assignment thus means that the qualified reference theForeman is assigned a reference to the generated instance of worker.
<LI> An assignment of the form mary-&gt;theForeman means that the state of the object referred by mary is enforced upon the state of the object referred by theForeman. This form of assignment is called value assignment<A NAME=MARKER-2-120></A>. If X and Y are integer objects then X -&gt; Y means that the value of X is assigned to the object Y.
</UL>
<P> In this section, it was shown how the most common object-oriented constructs may be expressed in BETA. In the following sections, examples of the more unique constructs will be given.</P>











