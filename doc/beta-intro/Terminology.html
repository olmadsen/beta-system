<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<LINK REL="stylesheet" HREF="../style/miadoc.css" TYPE="text/css">
<TITLE>BETA Terminology</TITLE>
<LINK REL=stylesheet HREF=../style/miadoc.css TYPE=text/css>
</HEAD>
<BODY>


<A NAME=HEADING1></A>



<P>
<A HREF=Quick-Reference-Card.html><IMG ALIGN=BOTTOM SRC=../images/next.gif ALT=Next BORDER=0></A> 
<A HREF=../beta/lowlevel.html><IMG ALIGN=BOTTOM SRC=../images/prev.gif ALT=Previous BORDER=0></A> 
<A HREF=../index.html><IMG ALIGN=BOTTOM SRC=../images/top.gif ALT=Top BORDER=0></A> 
<P>
<HR>
<!---------------------------------------------------------->



<A NAME=LINK-Terminology-firstpage></A><A NAME=HEADING1-0></A>
<H1> <A NAME="LINK-Terminology-_Toc367351303"><A NAME=MARKER-9-1></A>BETA Terminology</A></H1>
<P> The following is a short description of important concepts used in the BETA language.  Please note, that these descriptions are deliberately informal.  The precise meanings of these terms must be found in [BETA93].</P>
<A NAME=HEADING1-2></A>
<H4> Contents</H4>
<A NAME=HEADING1-3></A>
<H2> <A NAME="LINK-Terminology-_Toc367351304"><A NAME=MARKER-9-3></A>Modelling</A></H2>
<A NAME=HEADING1-4></A>
<H4> Object-oriented programming</H4>
<P> A <I>program execution</I> is viewed as a <I>physical model</I>  or <I>representation</I> of part of the world.  <I>Objects</I> on the computer model phenomena in the world; <I>attributes</I> of objects model properties of phenomena.</P>
<BLOCKQUOTE>
<TABLE BORDER=1 class=opaque><CAPTION><P> </P>
</CAPTION><TR VALIGN=TOP><TD><P> Computer</P>
</TD><TD><P> Real world</P>
</TD></TR><TR VALIGN=TOP><TD><P> <I>Object</I></P>
</TD><TD><P> <I>Phenomenon</I></P>
</TD></TR><TR VALIGN=TOP><TD><P> <I>Attribute</I></P>
</TD><TD><P> <I>Property</I></P>
</TD></TR><TR VALIGN=TOP><TD><P> <I>Pattern</I></P>
</TD><TD><P> <I>Concept</I></P>
</TD></TR></TABLE><A NAME=HEADING1-43></A>
</BLOCKQUOTE>
<H4> BETA program execution</H4>
<P> A collection of <I>objects</I>.  Some represent phenomena while others are simply part of the implementation.</P>
<A NAME=HEADING1-45></A>
<H4> Object</H4>
<P> Computer representation of a real world phenomenon.  Its structure consists of attributes and actions.</P>
<A NAME=HEADING1-47></A>
<H4> Pattern</H4>
<P> Computer representation of a real world concept.  Objects defined according to the pattern are called <I>instances </I>or <I>pattern defined objects</I>:  A pattern is to its instances as a concept is to its phenomena. </P>
<A NAME=HEADING1-49></A>
<H4> Singular object</H4>
<P> An object representing a singular &quot;one-of-a-kind&quot; phenomenon - the object is not defined as an instance of some pattern. </P>
<A NAME=HEADING1-51></A>
<H4> State of an object</H4>
<P> The combined values of its <I>measurable properties</I> at some point in time.</P>
<A NAME=HEADING1-53></A>
<H4> Measurable property</H4>
<P> A property which has a measurable value.  The value may vary over time.</P>
<A NAME=HEADING1-55></A>
<H4> Part object</H4>
<P> An object which is part of another object.  Part objects are used to model part or aggregation hierarchies.</P>
<A NAME=HEADING1-57></A>
<H4> Separate object</H4>
<P> An autonomous self-contained object which is not a part object.</P>
<A NAME=HEADING1-59></A>
<H4> Reference to separate object</H4>
<P> An attribute which is a reference to a separate object.</P>
<A NAME=HEADING1-61></A>
<H4> Kinds of actions</H4>
<P> The actions of a phenomenon in a real world system often take place <I>concurrently</I> (i.e. in parallel) with those of other phenomena in the system.  A single phenomenon normally <I>alternates</I> among its own actions.</P>
<A NAME=HEADING1-63></A>
<H2> <A NAME="LINK-Terminology-_Toc367351305"><A NAME=MARKER-9-5></A>Declarations and Object Descriptors</A></H2>
<A NAME=HEADING1-64></A>
<H4> Declaration or attribute declaration</H4>
<P> An association or <I>binding</I> of a name to some entity.  The syntactic construct used is the colon &quot;:&quot; as in, &lt;name&gt;: &lt;entity<B>&gt;</B>.  For attributes of an object descriptor, these are sometimes referred to as the <I>attribute name</I> and <I>attribute description</I>, respectively.</P>
<A NAME=HEADING1-66></A>
<H4> Pattern declaration</H4>
<P> A declaration binding a <I>pattern name</I> to an object descriptor, describing the structure of <I>instances of the pattern</I>.  Pattern declarations serve as templates for generating objects having a given structure.  </P>
<P> Syntax is:  </P>
<P> &lt;name&gt;<B>:</B> &lt;object-descriptor&gt;</P>
<A NAME=HEADING1-70></A>
<H4> Singular object declaration</H4>
<P> Declaration of a singular object binding the object name to the singular object description (an object descriptor). </P>
<P> Syntax is:  </P>
<P> &lt;name&gt;<B>: @</B>&lt;object-descriptor&gt;</P>
<A NAME=HEADING1-74></A>
<H4> Attribute reference</H4>
<P> An occurrence of an attribute's name in an object descriptor.</P>
<A NAME=HEADING1-76></A>
<H4> Local attribute reference of a pattern</H4>
<P> A reference from within a pattern's object descriptor to an attribute declared inside the same object descriptor.</P>
<A NAME=HEADING1-78></A>
<H4> Global attribute reference</H4>
<P> Any attribute reference which is not local.</P>
<A NAME=HEADING1-80></A>
<H4> Object-descriptor</H4>
<P> Used to describe the structure of objects and consists of a <I>prefix part</I> and a <I>main part</I>.</P>
<A NAME=HEADING1-82></A>
<H4> Prefix part</H4>
<P> Part of object descriptor used to specify the superpattern of the descriptor.   The prefix part is specified by a pattern name (or is empty).</P>
<A NAME=HEADING1-84></A>
<H4> Main part</H4>
<P> Used to describe the additional structure of objects.  Has the syntactic form(# E #) and consists of an <I>attribute part and an action part.</I></P>
<A NAME=HEADING1-86></A>
<H4> Attribute part</H4>
<P> Part of object descriptor used to describe the object's attributes.  Consists of a list of <I>attribute declarations</I>.</P>
<A NAME=HEADING1-88></A>
<H4> Action part</H4>
<P> Part of object descriptor used to describe the actions to be performed when the object is executed.  Consists of three parts: <I>enter-part</I>, <I>do-part</I>, <I>exit-part</I>.</P>
<A NAME=HEADING1-90></A>
<H4> Enter part</H4>
<P> Part of <I>action part</I> describing the <I>enter parameters</I>.</P>
<A NAME=HEADING1-92></A>
<H4> Do part</H4>
<P> Part of <I>action part</I> consisting of a list of <I>imperatives</I>.  </P>
<A NAME=HEADING1-94></A>
<H4> Exit part</H4>
<P> Part of <I>action part</I> describing the exit<I> parameters</I>.</P>
<A NAME=HEADING1-96></A>
<H4> Program</H4>
<P>   An object descriptor that can be compiled and executed.</P>
<A NAME=HEADING1-98></A>
<H2> <A NAME="LINK-Terminology-_Toc367351306"><A NAME=MARKER-9-7></A>Reference Attributes</A></H2>
<A NAME=HEADING1-99></A>
<H4> Reference attribute</H4>
<P> An attribute that denotes an object.  Reference attributes can be either <I>static references</I> or <I>dynamic references</I>.</P>
<A NAME=HEADING1-101></A>
<H4> Static reference</H4>
<P> A reference attribute that constantly denotes the same object.  Such objects are often referred to as <I>static objects</I>.  In cases where these objects are used to model part (or aggregation) hierarchies, they are referred to as <I>part objects</I>, that is, they are part of an <I>enclosing object</I>.  </P>
<A NAME=HEADING1-103></A>
<H4> Static reference declaration</H4>
<P> Used to define static reference attributes.  </P>
<P> Syntax is: </P>
<P> &lt;name&gt;<B>: @</B>&lt;ptn.name or obj.descriptor&gt;</P>
<A NAME=HEADING1-107></A>
<H4> Dynamic reference</H4>
<P> A reference attribute that denotes a object.  The reference is variable in that it may denote different objects over time.  Initially it denotes <I>NONE</I> which represents &quot;no object.&quot;</P>
<A NAME=HEADING1-109></A>
<H4> Dynamic reference declaration</H4>
<P> Used to define dynamic reference attributes.  </P>
<P> Syntax is: </P>
<P> &lt;name&gt;<B>: ^</B>&lt;pattern name&gt;</P>
<A NAME=HEADING1-113></A>
<H4> Indexed collection of static / dynamic references</H4>
<P> A repetition (or <I>array</I>) of object references referred to by a single name plus an index.  The size of a repetition A is denoted by <B>A.range.  A[1] refers to the first element in the repetition, A[A.range] to the last.</B></P>
<P> Syntax is:</P>
<P> Name<B>: [</B>eval] <B>@</B>&lt;ptn.name or obj.descriptor&gt;</P>
<P> Name<B>: [</B>eval] <B>^</B>&lt;ptn.name&gt;</P>
<P> The size of the repetition can be dynamically extended by:</P>
<P> &lt;number&gt; -&gt; A.<B>extend</B></P>
<A NAME=HEADING1-120></A>
<H4> Qualification or qualifying pattern</H4>
<P> The pattern name appearing in a reference attribute declaration.  It restricts the set of objects that can be denoted by the reference.</P>
<A NAME=HEADING1-122></A>
<H4> Remote access</H4>
<P> Used to denote attributes within an enclosing object.  </P>
<P> Syntax is:</P>
<P> reference<B>.</B>attribute</P>
<A NAME=HEADING1-126></A>
<H4> Computed Remote access</H4>
<P> Used to denote attributes within objects that are returned as the result of evaluations.  </P>
<P> Syntax is:</P>
<P> <B>(</B>evaluation<B>).</B>attribute</P>
<A NAME=HEADING1-130></A>
<H2> <A NAME="LINK-Terminology-_Toc367351307"><A NAME=MARKER-9-9></A>Pattern Attributes</A></H2>
<A NAME=HEADING1-131></A>
<H4> Pattern reference</H4>
<P> A reference attribute that denotes a pattern.  The structure of the pattern is represented locally using a <I>structure object</I>.  Such objects include a reference back to the object of which the pattern is an attribute.  This reference is called the <I>origin</I> of the pattern.</P>
<A NAME=HEADING1-133></A>
<H4> Pattern reference declaration</H4>
<P> Used to define a pattern.  </P>
<P> Syntax is:</P>
<P> &lt;name&gt;<B>:</B> &lt;object descriptor&gt;</P>
<A NAME=HEADING1-137></A>
<H4> Pattern variable declaration</H4>
<P> Used to define pattern variable attributes.  A pattern variable may denote different patterns during the execution.  The qualification restricts the set of patterns which may be denoted by the pattern variable.</P>
<P> Syntax is: </P>
<P> &lt;name&gt;<B>: ##</B>&lt;pattern name&gt;</P>
<A NAME=HEADING1-141></A>
<H4> Class pattern</H4>
<P> Generally, a pattern used to model physical objects.</P>
<A NAME=HEADING1-143></A>
<H4> Procedure pattern</H4>
<P> Generally, a pattern used to model action sequences.</P>
<A NAME=HEADING1-145></A>
<H4> Function pattern</H4>
<P> A procedure pattern which computes and returns a value.  Such patterns always have an exit part.</P>
<A NAME=HEADING1-147></A>
<H4> Basic pattern</H4>
<P> A pattern that is predefined within the BETA language.  Examples are <B>integer, real, boolean, and char.  Relevant operations include: +, -, *, div, mod, and, or, not, true, false, =, &lt;, &gt;, &lt;&gt;, &lt;=, &gt;=.</B></P>
<A NAME=HEADING1-149></A>
<H2> <A NAME="LINK-Terminology-_Toc367351308"><A NAME=MARKER-9-11></A>Imperatives</A></H2>
<A NAME=HEADING1-150></A>
<H4> Imperative</H4>
<P> Describes an action; <I>executing</I> the imperative causes the action.  Imperatives appear in the do-part of an object.  Kinds of imperatives include <I>evaluations</I>, <I>reference assignments</I>, <I>dynamic object creation</I>, and <I>control structures</I>.</P>
<A NAME=HEADING1-152></A>
<H4> Evaluation imperative</H4>
<P> An imperative that can cause state changes and may produce a value when executed.</P>
<A NAME=HEADING1-154></A>
<H4> Value assignment</H4>
<P> An evaluation imperative that sets (changes) the value of an attribute.</P>
<P> Syntax is:</P>
<P> 3 <B>-&gt;</B> I</P>
<A NAME=HEADING1-158></A>
<H4> Reference assignment</H4>
<P> An <I>imperative</I> used to change the value of a dynamic reference. </P>
<P> Syntax is: </P>
<P> objRef<B>[] -&gt;</B> dynObjRef<B>[]</B> </P>
<P> objRef  may be any object reference but dynObjRef <I>must be a dynamic object reference.</I></P>
<A NAME=HEADING1-163></A>
<H4> Pattern assignment</H4>
<P> An <I>imperative</I> used to change the pattern denoted by a pattern variable.</P>
<P> Syntax is:</P>
<P> ref<B>## -&gt;</B> dynPatRef<B>##</B></P>
<P> Ref may be the name of a pattern variable, the name of an object, or the name of a pattern but dynPatRef <I>must be a dynamic pattern reference.</I></P>
<A NAME=HEADING1-168></A>
<H4> Multiple assignment</H4>
<P> An evaluation imperative that causes several assignments.</P>
<P> Syntax is:</P>
<P> 3 -&gt; I -&gt; J</P>
<A NAME=HEADING1-172></A>
<H4> Dynamic object creation / generation</H4>
<P> Imperatives used to create new <I>dynamic objects</I>. </P>
<P> Syntax is:</P>
<P> <B>&amp;</B>Pat   or   <B>&amp;</B>Pat<B>[]</B></P>
<A NAME=HEADING1-176></A>
<H4> Value equality</H4>
<P> True when two references denote objects that have the same state. </P>
<P> Syntax is: </P>
<P> A <B>=</B> B</P>
<A NAME=HEADING1-180></A>
<H4> Reference equality</H4>
<P> True when two references denote the same object.</P>
<P> Syntax is:</P>
<P> A<B>[] =</B> B<B>[]</B></P>
<A NAME=HEADING1-184></A>
<H4> Pattern equality</H4>
<P> True when two pattern references denote the same pattern. </P>
<P> Syntax is:</P>
<P> A<B>## =</B> B<B>##</B></P>
<P> Note that <B>&lt; and &lt;= are also defined for pattern comparisons based on the inheritance hierarchy.</B></P>
<A NAME=HEADING1-189></A>
<H4> Procedure call </H4>
<P> An evaluation imperative that causes invocation of a procedure pattern.</P>
<P> Syntax is:</P>
<P> <B>&amp;</B>ProcPat</P>
<P>  or</P>
<P> (arg1,arg2) -&gt; &amp;ProcPat</P>
<A NAME=HEADING1-195></A>
<H4> Function call</H4>
<P> An evaluation imperative that causes invocation of a function pattern.</P>
<P> Syntax is:</P>
<P> (arg1,arg2) -&gt; <B>&amp;</B>FuncPat -&gt; result</P>
<A NAME=HEADING1-199></A>
<H4> Control structure</H4>
<P> An imperative that controls the flow of executions.</P>
<A NAME=HEADING1-201></A>
<H4> For imperative</H4>
<P> A control structure used to support <I>iteration</I>.  A list of imperatives are executed repeatedly while an index steps from 1 up to the number of iterations.</P>
<P> Syntax is:</P>
<P> <B>(for</B> Index: Range <B>repeat</B></P>
<P>      Imperative-list</P>
<P> <B>for)</B></P>
<A NAME=HEADING1-207></A>
<H4> General-if imperative</H4>
<P> A control structure used to support <I>selection</I>.  Based on evaluating a condition evaluation and comparing it to the values of a number of selection evaluations, one of a set of imperative-lists is executed. </P>
<P> Syntax is:</P>
<P> <B>(if</B> E0</P>
<P>  <B>//</B> E1 <B>then</B> I1</P>
<P>  <B>//</B> E2 <B>then</B> I2</P>
<P>  E</P>
<P>  <B>//</B> En <B>then</B> In</P>
<P>  <B>else</B> I</P>
<P> <B>if)</B></P>
<A NAME=HEADING1-217></A>
<H4> Simple-if imperative</H4>
<P> A control structure used to support boolean <I>selection</I>.  Based on evaluating a condition evaluation and testing if it is true or false, one of two imperative-lists is executed. </P>
<P> Syntax is:</P>
<P> <B>(if</B> E <B>then</B></P>
<P>     I1</P>
<P>  <B>else</B> I2</P>
<P> <B>if)</B></P>
<A NAME=HEADING1-224></A>
<H4> Labelled imperative</H4>
<P> A means of naming an imperative.  References to the label (via <I>jump imperatives</I>) can be made from within the imperative.</P>
<P> Syntax is:</P>
<P> L: Imperative  or  L: <B>(#</B> ... <B>do</B> ... <B>#)</B></P>
<A NAME=HEADING1-228></A>
<H4> Jump imperative</H4>
<P> Causes flow of control to &quot;jump&quot; to another location.  A jump imperative is one of a <I>Leave imperative</I> or a <I>Restart imperative</I>.</P>
<A NAME=HEADING1-230></A>
<H4> Leave imperative</H4>
<P> Causes termination of the execution of a labelled imperative; execution resumes after the labelled imperative.  This imperative can only appear within the labelled imperative. </P>
<P> Syntax is:</P>
<P> <B>leave</B> L</P>
<A NAME=HEADING1-234></A>
<H4> Restart imperative</H4>
<P> Causes restarting of the execution of a labelled imperative, that is, jump is to the start of the imperative.  Can only appear within the labelled imperative.</P>
<P> Syntax is:</P>
<P> <B>restart</B> L</P>
<A NAME=HEADING1-238></A>
<H2> <A NAME="LINK-Terminology-_Toc367351309"><A NAME=MARKER-9-13></A>Block Structure and Scoping</A></H2>
<A NAME=HEADING1-239></A>
<H4> Block structure</H4>
<P> The nesting of one structure in another in the text of a program.  In BETA, object descriptors and imperatives can be nested inside of other object descriptors and imperatives.  It is the job of the programmer to use <I>indentation</I> to make such nesting visible to readers.  In the following example, Deposit's object descriptor is nested inside of Account's.</P>
<P> Account:</P>
<P>   <B>(# </B>Deposit:</P>
<P>        <B>(#</B> E</P>
<P>        <B>do</B> E</P>
<P>        <B>#);</B></P>
<P>   <B>#);</B></P>
<A NAME=HEADING1-247></A>
<H4> Declaration of a name</H4>
<P> An association of a name with some defining expression.</P>
<P> Syntax is: </P>
<P> &lt;name&gt;<B>:</B> E</P>
<P> Recall that colon &quot;:&quot; always signals a declaration of some kind.</P>
<A NAME=HEADING1-252></A>
<H4> Application of a name</H4>
<P> Any occurrence of a name in a program which is not a declaration.  Note that this does not include keywords of the BETA syntax (e.g. if, for, repeat, do), but does include predefined pattern and attribute names (e.g. char, putInt, stream).</P>
<A NAME=HEADING1-254></A>
<H4> Scope of a declaration</H4>
<P> The part of the program text &quot;covered&quot; by the declaration, that is, where applications of the declared name refer to the given declaration.  In BETA, the scope of a declaration is the object descriptor it appears in.  The exception to this is that the declaration may be &quot;hidden&quot; by declarations of the same name in nested object descriptors or labelled imperatives.  Note that the declared name can also be applied outside its object descriptor using remote access.  We say that a name is <I>local</I> to the object descriptor in which it is declared and <I>global</I> to any nested object descriptors (for which it is not hidden).</P>
<A NAME=HEADING1-256></A>
<H2> <A NAME="LINK-Terminology-_Toc367351310"><A NAME=MARKER-9-15></A>Inserted Objects</A></H2>
<A NAME=HEADING1-257></A>
<H4> Inserted item</H4>
<P> A means of generating (and executing) a procedure object allocated as part of the enclosing object.</P>
<P> Syntax is:</P>
<P> A <B>-&gt;</B> P <B>-&gt;</B> B</P>
<P>  or</P>
<P> A <B>-&gt;</B> P<B>(#</B> E <B>#)</B> <B>-&gt;</B> B</P>
<P> This differs from dynamic generation,<B> &amp;P, in that the instance of P is generated only once rather than each time the imperative is executed.  Note that inserted items should not be used to define <I>recursive procedures.  That is, an inserted instance of P may be specified in the action part of P.</I></B></P>
<A NAME=HEADING1-264></A>
<H2> <A NAME="LINK-Terminology-_Toc367351311"><A NAME=MARKER-9-17></A>Inheritance</A></H2>
<A NAME=HEADING1-265></A>
<H4> Direct subpattern</H4>
<P> A pattern P is a <I>direct subpattern</I> of Q if P extends (specialises) the definition of Q.  Q is called the <I>direct</I> <I>superpattern</I> of P and instances of P are also instances of Q.</P>
<P> Syntax is:</P>
<P> P<B>:</B> Q<B>(#</B> E <B>#)</B></P>
<P> Q is called the <I>prefix pattern</I> (or simply <I>prefix</I>), while the contents of (# E #) is called the <I>main-part</I>  of P.  The prefix Q means that P's object descriptor <I>inherits</I> all of Q's declarations in addition to any new ones defined in P's main-part.  </P>
<A NAME=HEADING1-270></A>
<H4> Subpattern</H4>
<P> A pattern P is a <I>subpattern</I> of Q if it is either a direct subpattern of Q or a subpattern of a direct subpattern of Q.  Likewise, Q is a <I>superpattern</I> of P if it is either a direct superpattern of P or a superpattern of the direct superpattern of P.  A pattern can have at most one direct superpattern.</P>
<A NAME=HEADING1-272></A>
<H4> Abstract superpattern</H4>
<P> A pattern used only as a superpattern for other patterns, that is, it is not intended to be used to generate objects.  If P is declared without the use of a superpattern, P: (# E #), then P is assumed to be a subpattern of the most general abstract superpattern, Object.  Note that the basic patterns, Integer, Real, Boolean, Char and Real are not subpatterns of Object.</P>
<A NAME=HEADING1-274></A>
<H4> Superpattern as qualification</H4>
<P> If R is a dynamic reference qualified by the pattern Q (i.e. R: ^Q) and Q is a superpattern of P, then instances of both P and Q can be assigned to R.  However, only attributes of Q (and of superpatterns of Q) can be accessed using remote access through R.  That is, if attribute A is declared in the main part of P, then the remote access R.A is illegal.</P>
<A NAME=HEADING1-276></A>
<H4> Action specialisation</H4>
<P> The use of a subpattern to extend the action part of a pattern.  Action specialisation can involve any or all of the enter-part, exit-part and do-part.  The enter and exit parts of instances of P (again, a subpattern of Q) consist of Q's enter and exit parameters together with those defined by P.  Extending the do-part of Q requires the use of the <B>inner imperative in Q's action part.  Executing the do-part of an instance of P proceeds by executing Q's do-part and executing P's do-part each time inner is encountered.</B></P>
<P> Syntax is:</P>
<P> Q: <B>(#</B> E <B>do</B> E <B>inner</B> E <B>#);</B></P>
<P> P: Q<B>(#</B> E <B>do</B> E <B>#);</B></P>
<A NAME=HEADING1-281></A>
<H2> <A NAME="LINK-Terminology-_Toc367351312"><A NAME=MARKER-9-19></A>Virtual Patterns</A></H2>
<A NAME=HEADING1-282></A>
<H4> Virtual pattern</H4>
<P> A pattern attribute V of a pattern Q is <I>virtual</I> if it is only partially defined in Q.  That is, the definition of V can be extended in subpatterns of Q.</P>
<P> Syntax is:</P>
<P> Q: <B>(#</B> V<B>:&lt;</B> S <B>#)</B></P>
<P> Q: <B>(#</B> V<B>:&lt;</B> S0<B>(#</B> E <B>#)</B> <B>#)</B></P>
<P> Q: <B>(#</B> V<B>:&lt;</B> <B>(#</B> E <B>#)</B> <B>#)</B></P>
<P> In the first of the three forms, we say that the virtual V is <I>qualified</I> by the pattern S, in the second and third forms, we say that V is <I>directly qualified</I>.</P>
<A NAME=HEADING1-289></A>
<H4> Further binding of a virtual pattern</H4>
<P> The means by which a virtual attribute V of a pattern Q is extended in a subpattern P of Q.</P>
<P> Syntax is:</P>
<P> P: Q<B>(#</B> V<B>::&lt;</B> S1 <B>#)</B></P>
<P> P: Q<B>(#</B> V<B>::&lt;</B> S1<B>(#</B> E <B>#)</B> <B>#)</B></P>
<P> P: Q<B>(#</B> V<B>::&lt;</B> <B>(#</B> E <B>#)</B> <B>#)</B></P>
<P> S1, S1(# E #), or (# E #) is called the <I>extended descriptor</I> of V.  If we're using either the first or second form, and if V is qualified by S in the pattern Q, then S1 must be a subpattern of S.  In the case of the third form there are no constraints on Q's declaration of V.  If X is an instance of P, then X.V specialises (that is, adds properties to) the definition of V in Q.  Note that V is now a virtual pattern in P (as well as Q) and can continue to be further bound in subpatterns of P.</P>
<A NAME=HEADING1-296></A>
<H4> Final binding of a virtual pattern</H4>
<P> The means by which a virtual attribute V of a pattern Q is extended in a subpattern P of Q, and at the same time made non-virtual.</P>
<P> Syntax is:</P>
<P> R: P<B>(#</B> V<B>::</B> S2 <B>#)</B></P>
<P> R: P<B>(#</B> V<B>::</B> S2<B>(#</B> E <B>#)</B> <B>#)</B></P>
<P> R: P<B>(#</B> V<B>::</B> <B>(#</B> E <B>#)</B> <B>#)</B></P>
<P> Final binding is identical to further binding, except that with final binding, V is no longer virtual.</P>
<A NAME=HEADING1-303></A>
<H1> <A NAME="LINK-Terminology-_Toc367351313"><A NAME=MARKER-9-21></A>BETA Terminology - Index</A></H1>
<A NAME=LINK-Terminology-lastpage></A><A NAME=LINK-Terminology-lastpage></A>


<HR>
<P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="33%" align="left"><ADDRESS>BETA Terminology</ADDRESS></TD>
<TD width="34%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="33%" align="right"><FONT size=-1><SCRIPT LANGUAGE=JavaScript SRC="../javascript/lastmod.js"></SCRIPT></FONT></TD>
</TABLE>

<P>
<A HREF=Quick-Reference-Card.html><IMG ALIGN=BOTTOM SRC=../images/next.gif ALT=Next BORDER=0></A> 
<A HREF=../beta/lowlevel.html><IMG ALIGN=BOTTOM SRC=../images/prev.gif ALT=Previous BORDER=0></A> 
<A HREF=../index.html><IMG ALIGN=BOTTOM SRC=../images/top.gif ALT=Top BORDER=0></A> 


</BODY>
</HTML>
