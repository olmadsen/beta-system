<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Math Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="numberio.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="formatio.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Prev BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Math Interface</H1>
<PRE CLASS=interface>
ORIGIN 'betaenv';
LIB_DEF 'math' '../lib';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1984-96
 *       All rights reserved.
 *
 * Math.bet: mathematical functions
 * 
 * This library provides mathematical patterns: trigonometric,
 * hyperbolic, exponential and logarithmic, floating point
 * manipulation and miscellaneous constants.
 *)
--- LIB: Attributes ---

(* miscellaneous constants *)

<b>e</b><A name="e.1(525)"></A>:       (# Exit 2.7182818284590452354 #);
<b>log2e</b><A name="log2e.1(526)"></A>:   (# Exit 1.4426950408889634074 #);
<b>log10e</b><A name="log10e.1(527)"></A>:  (# Exit 0.43429448190325182765 #);
<b>ln2</b><A name="ln2.1(528)"></A>:     (# Exit 0.69314718055994530942 #);
<b>ln10</b><A name="ln10.1(529)"></A>:    (# Exit 2.30258509299404568402 #);
<b>pi</b><A name="pi.1(530)"></A>:      (# Exit 3.14159265358979323846 #);
<b>pihalf</b><A name="pihalf.1(531)"></A>:  (# Exit 1.57079632679489661923 #);
<b>piforth</b><A name="piforth.1(532)"></A>: (# Exit 0.78539816339744830962 #);

(* trigonometric functions *)

<b>acos</b><A name="acos.1(533)"></A><A name="external.:_subpatterns.2:acos.3"></A>: external
  (* returns the arccosine of x in radians, in the range 0 to pi.  If
   * x is a NaN (Not-a-Number) or if the absolute value of x exceeds
   * 1.0, acos(x) returns a NaN.  Invalid operation/DOMAIN error is
   * signaled if x is a NaN or if |x| &gt; 1.0.
   *)
  (# <b>x</b><A name="acos.1:x.2(534)"></A><A name="x.2(534)"></A>,<b>res</b><A name="acos.1:res.2(535)"></A><A name="res.2(535)"></A>: @Real;
  enter x
  exit res
  #);
<b>asin</b><A name="asin.1(536)"></A><A name="external.:_subpatterns.2:asin.3"></A>: external
  (* returns the arcsine of x in radians, in the range -pi/2 to pi/2.
   * If x is a NaN or if the absolute value of x exceeds 1.0, asin
   * returns a NaN.  Invalid operation/DOMAIN error is signaled if x
   * is a NaN or if |x| &gt; 1.0.
   *)
  (# <b>x</b><A name="asin.1:x.2(537)"></A><A name="x.2(537)"></A>,<b>res</b><A name="asin.1:res.2(538)"></A><A name="res.2(538)"></A>: @Real;
  enter x
  exit res
  #);
<b>atan</b><A name="atan.1(539)"></A><A name="external.:_subpatterns.2:atan.3"></A>: external
  (* returns the arctangent of x, in the range of -pi/2 to pi/2
   * radians.  If x = +-infinity, then atan(x) returns +-pi/2.  If x
   * is +- 0, then atan returns x. If x is a NaN, then atan returns a
   * NaN.  An invalid operation/DOMAIN error is signaled by atan only
   * if x is a NaN.
   *)
  (# <b>x</b><A name="atan.1:x.2(540)"></A><A name="x.2(540)"></A>,<b>res</b><A name="atan.1:res.2(541)"></A><A name="res.2(541)"></A>: @Real;
  enter x
  exit res
  #);
<b>atan2</b><A name="atan2.1(542)"></A><A name="external.:_subpatterns.2:atan2.3"></A>: external
  (* returns the arctangent of y/x in radians, in the range -pi to
   * pi, using the signs of both arguments to determine the quadrant
   * of the return value.
   * 
   * If x is a NaN or if y is a NaN or if both x and y are infinities,
   * atan2 returns a NaN.  If both x and y are zero, atan2 returns
   * zero.  Invalid operation/DOMAIN error is signaled by atan2 if
   * both x and y are infinite or if either x or y is a NaN.
   *)
  (# <b>y</b><A name="atan2.1:y.2(543)"></A><A name="y.2(543)"></A>,<b>x</b><A name="atan2.1:x.2(544)"></A><A name="x.2(544)"></A>,<b>res</b><A name="atan2.1:res.2(545)"></A><A name="res.2(545)"></A>: @Real;
  enter (y,x)
  exit res
  #);
<b>cos</b><A name="cos.1(546)"></A><A name="external.:_subpatterns.2:cos.3"></A>: external
  (* computes the cosine of x, where x is expressed in radians.
   * 
   * The cos function uses an argument reduction based on the
   * remainder function and pi.  The cos function is periodic with
   * respect to pi, so its period differs slightly from its
   * mathematical counterpart and diverges from its counterpart when
   * the argument becomes very large.
   * 
   * If x is infinite or a NaN, then cos returns a NaN and signals
   * invalid/DOMAIN error.
   *)
  (# <b>x</b><A name="cos.1:x.2(547)"></A><A name="x.2(547)"></A>,<b>res</b><A name="cos.1:res.2(548)"></A><A name="res.2(548)"></A>: @Real;
  enter x
  exit res
  #);
<b>sin</b><A name="sin.1(549)"></A><A name="external.:_subpatterns.2:sin.3"></A>: external
  (* computes the sine of x, where x is expressed in radians.
   * 
   * The sin function uses an argument reduction based on the
   * remainder function and pi.  The sin function is periodic with
   * respect to pi, so its period differs slightly from its
   * mathematical counterpart and diverges from its counterpart when
   * the argument becomes very large.
   * 
   * If x is infinite or a NaN, then sin returns a NaN and signals
   *    invalid/DOMAIN error.
   *)
  (# <b>x</b><A name="sin.1:x.2(550)"></A><A name="x.2(550)"></A>,<b>res</b><A name="sin.1:res.2(551)"></A><A name="res.2(551)"></A>: @Real;
  enter x
  exit res
  #);
<b>tan</b><A name="tan.1(552)"></A><A name="external.:_subpatterns.2:tan.3"></A>: external
  (* computes the tangent of x, where x is expressed in radians.
   * 
   * The tan function uses an argument reduction based on the
   * remainder function and pi The tan function is periodic with
   * respect to pi, so its period differs slightly from its
   * mathematical counterpart and diverges from its counterpart when
   * the argument becomes very large.
   *)
  (# <b>x</b><A name="tan.1:x.2(553)"></A><A name="x.2(553)"></A>,<b>res</b><A name="tan.1:res.2(554)"></A><A name="res.2(554)"></A>: @Real;
  enter x
  exit res
  #);

(* hyperbolic functions *)

<b>cosh</b><A name="cosh.1(555)"></A><A name="external.:_subpatterns.2:cosh.3"></A>: external
  (* returns the hyberbolic cosine of x.
   * 
   * If x is a NaN, cosh returns a NaN.
   *)
  (# <b>x</b><A name="cosh.1:x.2(556)"></A><A name="x.2(556)"></A>,<b>res</b><A name="cosh.1:res.2(557)"></A><A name="res.2(557)"></A>: @Real;
  enter x
  exit res
  #);
<b>sinh</b><A name="sinh.1(558)"></A><A name="external.:_subpatterns.2:sinh.3"></A>: external
  (* returns the hyberbolic sine of x.
   * 
   * If x is a NaN, sinh returns a NaN.
   *)
  (# <b>x</b><A name="sinh.1:x.2(559)"></A><A name="x.2(559)"></A>,<b>res</b><A name="sinh.1:res.2(560)"></A><A name="res.2(560)"></A>: @Real;
  enter x
  exit res
  #);
<b>tanh</b><A name="tanh.1(561)"></A><A name="external.:_subpatterns.2:tanh.3"></A>: external
  (* returns the hyberbolic tangent of x.
   * 
   * If x is a NaN, tanh returns a NaN.
   *)
  (# <b>x</b><A name="tanh.1:x.2(562)"></A><A name="x.2(562)"></A>,<b>res</b><A name="tanh.1:res.2(563)"></A><A name="res.2(563)"></A>: @Real;
  enter x
  exit res
  #);

(* exponential and logarithmic functions *)

<b>exp</b><A name="exp.1(564)"></A><A name="external.:_subpatterns.2:exp.3"></A>: external
  (* returns the base-e or natural exponential e^x.
   * 
   * Special cases for exp:
   * 
   * If x = +infinity, then exp returns +infinity and does not signal
   * an exception.  If x = ­infinity, then exp returns 0 and does not
   * signal an exception.  If x is a NaN, then exp returns a NaN.
   *)
  (# <b>x</b><A name="exp.1:x.2(565)"></A><A name="x.2(565)"></A>,<b>res</b><A name="exp.1:res.2(566)"></A><A name="res.2(566)"></A>: @Real;
  enter x
  exit res
  #);
<b>ldexp</b><A name="ldexp.1(567)"></A><A name="external.:_subpatterns.2:ldexp.3"></A>: external
  (* returns the quantity x * 2^exp. *)
  (# <b>x</b><A name="ldexp.1:x.2(568)"></A><A name="x.2(568)"></A>,<b>res</b><A name="ldexp.1:res.2(569)"></A><A name="res.2(569)"></A>: @Real;
     <b>exp</b><A name="ldexp.1:exp.2(570)"></A><A name="exp.2(570)"></A>: @Integer;
  enter (x,exp)
  exit res
  #);
<b>log</b><A name="log.1(571)"></A><A name="external.:_subpatterns.2:log.3"></A>: external
  (* returns the base e or natural logarithm of its argument x.
   * 
   * Special cases for log:
   * 
   * If x is +infinity, then log returns +infinity and signals no
   * exceptions.  If x is 0, then log returns -infinity and signals
   * divide-by-zero.  If x &lt; 0, then log returns a NaN and signals
   * invalid/DOMAIN error.
   *)
  (# <b>x</b><A name="log.1:x.2(572)"></A><A name="x.2(572)"></A>,<b>res</b><A name="log.1:res.2(573)"></A><A name="res.2(573)"></A>: @Real;
  enter x
  exit res
  #);
<b>log10</b><A name="log10.1(574)"></A><A name="external.:_subpatterns.2:log10.3"></A>: external
  (* returns the base 10 logarithm of x.
   * 
   * If x is a NaN or is negative, log10 returns a NaN. If x is
   * +infinity, log10(x) returns +infinity.  If x is zero, log10
   * returns -infinity and signals divide by zero/SING error.
   *)
  (# <b>x</b><A name="log10.1:x.2(575)"></A><A name="x.2(575)"></A>,<b>res</b><A name="log10.1:res.2(576)"></A><A name="res.2(576)"></A>: @Real;
  enter x
  exit res
  #);

(* floating point manipulation *)

<b>modf</b><A name="modf.1(577)"></A><A name="external.:_subpatterns.2:modf.3"></A>: external
  (* returns the fractional part of x and stores the integral part
   * indirectly in the location pointed to by ipPtr.  Both the return
   * value and the value stored in ipPtr share the same sign as x.
   * 
   * If x is infinite, modf returns a zero with the sign of x and sets
   * ipPtr to x.  If x is a NaN, mod returns a NaN and sets ipPtr to
   * the same NaN.
   *)
  (# <b>x</b><A name="modf.1:x.2(578)"></A><A name="x.2(578)"></A>,<b>res</b><A name="modf.1:res.2(579)"></A><A name="res.2(579)"></A>: @Real;
     <b>ipPtr</b><A name="modf.1:ipPtr.2(580)"></A><A name="ipPtr.2(580)"></A>: @Integer;
  enter (x,ipPtr)
  exit res
  #);
<b>pow</b><A name="pow.1(581)"></A><A name="external.:_subpatterns.2:pow.3"></A>: external
  (* returns x^y *)
  (# <b>x</b><A name="pow.1:x.2(582)"></A><A name="x.2(582)"></A>,<b>y</b><A name="pow.1:y.2(583)"></A><A name="y.2(583)"></A>,<b>res</b><A name="pow.1:res.2(584)"></A><A name="res.2(584)"></A>: @Real;
  enter (x,y)
  exit res
  #);
<b>sqrt</b><A name="sqrt.1(585)"></A><A name="external.:_subpatterns.2:sqrt.3"></A>: external
  (* computes the square root of x.
   * 
   * Special cases for sqrt:
   * 
   * If x is a NaN, sqrt returns a NaN and signals no exceptions.  If
   * x is a NaN or if x &lt; 0, sqrt returns a NaN and signals invalid
   * operation/DOMAIN error.
   *)
  (# <b>x</b><A name="sqrt.1:x.2(586)"></A><A name="x.2(586)"></A>,<b>res</b><A name="sqrt.1:res.2(587)"></A><A name="res.2(587)"></A>: @Real;
  enter x
  exit res
  #);
<b>ceil</b><A name="ceil.1(588)"></A><A name="external.:_subpatterns.2:ceil.3"></A>: external
  (* returns the smallest integer value (in real format) not less
   * than x.
   * 
   * If x is a NaN, ceil returns a NaN.  If x is infinite, ceil
   * returns x.  Invalid operation is signaled by ceil if x is a NaN.
   * If x is a non-integral finite value, ceil signals inexact
   *)
  (# <b>x</b><A name="ceil.1:x.2(589)"></A><A name="x.2(589)"></A>,<b>res</b><A name="ceil.1:res.2(590)"></A><A name="res.2(590)"></A>: @Real;
  enter x
  exit res
  #);
<b>fmin</b><A name="fmin.1(591)"></A>: (* Returns the minimum of 2 reals *)
  (# <b>a</b><A name="fmin.1:a.2(592)"></A><A name="a.2(592)"></A>,<b>b</b><A name="fmin.1:b.2(593)"></A><A name="b.2(593)"></A>: @real
  enter (a,b)
  do (if (a &lt; b) then a-&gt;b if)
  exit b
  #);
<b>fmax</b><A name="fmax.1(594)"></A>: (* Returns the maximum of 2 reals *)
  (# <b>a</b><A name="fmax.1:a.2(595)"></A><A name="a.2(595)"></A>,<b>b</b><A name="fmax.1:b.2(596)"></A><A name="b.2(596)"></A>: @real
  enter (a,b)
  do (if (a &lt; b) then b-&gt;a if)
  exit a
  #);
<b>fabs</b><A name="fabs.1(597)"></A><A name="external.:_subpatterns.2:fabs.3"></A>: external
  (* returns |x|, the absolute value of x *)
  (# <b>x</b><A name="fabs.1:x.2(598)"></A><A name="x.2(598)"></A>,<b>res</b><A name="fabs.1:res.2(599)"></A><A name="res.2(599)"></A>: @Real;
  enter x
  exit res
  #);
<b>floor</b><A name="floor.1(600)"></A><A name="external.:_subpatterns.2:floor.3"></A>: external
  (* largest integer value (in real format) not greater than x.
   * 
   * If x is a NaN, floor returns a NaN.  If x is infinite, floor
   * returns x. Invalid operation is signaled by floor if x is a NaN.
   * If x is a non-integral finite value, floor signals inexact.
   *)
  (# <b>x</b><A name="floor.1:x.2(601)"></A><A name="x.2(601)"></A>,<b>res</b><A name="floor.1:res.2(602)"></A><A name="res.2(602)"></A>: @Real;
  enter x
  exit res
  #);
<b>fmod</b><A name="fmod.1(603)"></A><A name="external.:_subpatterns.2:fmod.3"></A>: external
  (* Whenever possible, the fmod pattern returns the number f with
   * the same sign as x, such that x = i*y + f for some integer i, and
   * |f| &lt; |y|. If y is 0, fmod returns a NaN.
   *)
  (# <b>x</b><A name="fmod.1:x.2(604)"></A><A name="x.2(604)"></A>,<b>y</b><A name="fmod.1:y.2(605)"></A><A name="y.2(605)"></A>,<b>f</b><A name="fmod.1:f.2(606)"></A><A name="f.2(606)"></A>: @Real;
  enter (x,y)
  exit f
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<ADDRESS>Interface Description</ADDRESS>
<P></P>
<A HREF="numberio.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="formatio.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Prev BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
