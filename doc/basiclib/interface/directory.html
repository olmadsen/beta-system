<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Directory Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="external.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="betaenv.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Prev BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Directory Interface</H1>
<PRE CLASS=interface>
ORIGIN 'file';
LIB_DEF 'directory' '../lib';
BODY 'private/directorybody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1984-96
 *       All rights reserved.
 *
 *)
---- LIB: attributes ----
<b>directory</b><A name="directory.1(322)"></A>:
  (* Generalization of disk folder/directory.  Describes the list
   * aspects of directories and contains a DiskEntry item describing
   * the other properties of a directory.
   *)
  (#
     &lt;&lt;SLOT DirectoryLib: attributes&gt;&gt;;
     
     <b>EntryDesc</b><A name="directory.1:EntryDesc.2(323)"></A><A name="EntryDesc.2(323)"></A>:&lt; DiskEntry;
     <b>entry</b><A name="directory.1:entry.2(324)"></A><A name="entry.2(324)"></A>: @EntryDesc
       (* The item holding most characterizing attributes of
        * THIS(directory)
        *); 
     <b>name</b><A name="directory.1:name.2(325)"></A><A name="name.2(325)"></A>: @
       (* convenient interface to entry.path *)
       (# read:
            (* Reads a directory name from the Keyboard *)
            (# do ... #);
       enter entry.path
       exit entry.path
       #);
     
     (* Directory exceptions *)
     
     <b>DirException</b><A name="directory.1:DirException.2(326)"></A><A name="DirException.2(326)"></A><A name="directory.1:Exception.2:_subpatterns.3:DirException.4"></A>: Exception
       (* General directory exception *)
       (# do ...; INNER #);
     <b>EntryExistException</b><A name="directory.1:EntryExistException.2(327)"></A><A name="EntryExistException.2(327)"></A><A name="directory.1:DirException.2:_subpatterns.3:EntryExistException.4"></A>: DirException
       (* Raised on attempt to create a file or directory that
        * allready existed in THIS(directory). Message: "Directory
        * entry allready exist"
        *)
       (# do ...; INNER #);
     <b>DirScanException</b><A name="directory.1:DirScanException.2(328)"></A><A name="DirScanException.2(328)"></A><A name="directory.1:DirException.2:_subpatterns.3:DirScanException.4"></A>: DirException
       (* Raised if a scan of THIS(directory) has failed.  Message:
        * "Scan of directory failed.", and an indication of why it
        * failed.
        *)
       (# do ...; INNER #);
     <b>DirSearchException</b><A name="directory.1:DirSearchException.2(329)"></A><A name="DirSearchException.2(329)"></A><A name="directory.1:DirException.2:_subpatterns.3:DirSearchException.4"></A>: DirException
       (* Raised if a find in THIS(directory) has failed.  Message:
        * "Search of directory failed.", and an indication of why it
        * failed.
        *)
       (# do ...; INNER #);
     <b>NoSuchException</b><A name="directory.1:NoSuchException.2(330)"></A><A name="NoSuchException.2(330)"></A><A name="directory.1:DirException.2:_subpatterns.3:NoSuchException.4"></A>: DirException
       (* Raised on attempt to delete a file or directory that did
        * not exist in THIS(directory). Message: "Attempt to delete a
        * nonexisting entry."
        *)
       (# do ...; INNER #);
     <b>NotFoundException</b><A name="directory.1:NotFoundException.2(331)"></A><A name="NotFoundException.2(331)"></A><A name="directory.1:DirException.2:_subpatterns.3:NotFoundException.4"></A>: DirException
       (* Raised if findEntry.select is used in findEntry.notFound,
        * or in other situations that findEntry.found[]=NONE. Message:
        * "Attempt to use 'select' in 'findEntry' when the candidate
        * was not found."
        *)
       (# do ...; INNER #);
     
     (* Manipulations of THIS(directory) *)
     
     <b>touch</b><A name="directory.1:touch.2(332)"></A><A name="touch.2(332)"></A>: entry.touch
       (* If the disk entry does not exist, an empty directory will
        * be created.
        *)
       (# touchD: @...; 
       do touchD 
       #);
     <b>delete</b><A name="directory.1:delete.2(333)"></A><A name="delete.2(333)"></A>:
       (* Delete THIS(directory) *)
       (# nosuch:&lt; NoSuchException
            (* Raised if there was no disk entry corresponding to
             * THIS(Directory)
             *);
          error:&lt; entry.DiskEntryException
            (* Raised if other errors occurred *);
          deleteD: @...; 
       do deleteD
       #);
     <b>createFile</b><A name="directory.1:createFile.2(334)"></A><A name="createFile.2(334)"></A>:
       (* Create a file named 'name' in THIS(Directory) *)
       (# name: ^text;
          newEntry: ^EntryDesc;
          exists:&lt; EntryExistException
            (* Raised if en entry of that name already existed *);
          error:&lt; DirException
            (* Raised if other errors occurred *);
       enter name[]
       ...
       exit newEntry[]
       #);
     <b>deleteFile</b><A name="directory.1:deleteFile.2(335)"></A><A name="deleteFile.2(335)"></A>: 
       (* Delete a file named 'name' in THIS(Directory) *)
       (# name: ^text;
          nosuch:&lt; NoSuchException
            (* Raised if there was no disk entry in THIS(Directory)
             * named 'name'
             *);
          error:&lt;DirException
            (* Raised if other errors occured *)
       enter name[]
       ...
       #);
     <b>createDir</b><A name="directory.1:createDir.2(336)"></A><A name="createDir.2(336)"></A>:
       (* Create a directory named 'name' in THIS(Directory) *)
       (# name: ^text;
          newEntry: ^EntryDesc;
          exists:&lt; EntryExistException
            (* Raised if en entry of that name already existed *);
          error:&lt; DirException
            (* Raised if other errors occurred *);
       enter name[]
       ...
       exit newEntry[]
       #);
     <b>deleteDir</b><A name="directory.1:deleteDir.2(337)"></A><A name="deleteDir.2(337)"></A>:
       (* Delete a directory named 'name' in THIS(Directory) *)
       (# name: ^text;
          nosuch:&lt; NoSuchException
            (* Raised if there was no disk entry in THIS(Directory)
             * named 'name'
             *);
          error:&lt; DirException
            (* Raised if other errors occured *)
       enter name[]
       ...
       #);
     <b>noOfEntries</b><A name="directory.1:noOfEntries.2(338)"></A><A name="noOfEntries.2(338)"></A><A name="directory.1:IntegerValue.2:_subpatterns.3:noOfEntries.4"></A>: IntegerValue
       (* exit the number of entries in THIS(directory) *)
       (# error:&lt;DirException; 
       ... 
       #);
     <b>empty</b><A name="directory.1:empty.2(339)"></A><A name="empty.2(339)"></A><A name="directory.1:BooleanValue.2:_subpatterns.3:empty.4"></A>: BooleanValue
       (* TRUE iff THIS(directory) is empty. Note that this does not
        * always imply NoOfEntries=0
        *)
       (# error:&lt;DirException; 
       ... 
       #);
     <b>findEntry</b><A name="directory.1:findEntry.2(340)"></A><A name="findEntry.2(340)"></A>:
       (* Calls INNER if entry was found in THIS(directory), and
        * otherwise calls notFound
        *)
       (# &lt;&lt;SLOT DirFindLib: attributes&gt;&gt;;
          <b>candidate</b><A name="directory.1:findEntry.2:candidate.3(341)"></A><A name="candidate.3(341)"></A>: ^text;
          (* The name of the entry to search for *)
          <b>foundDesc</b><A name="directory.1:findEntry.2:foundDesc.3(342)"></A><A name="foundDesc.3(342)"></A>:&lt; DiskEntry;
          (* Qualification of "found" *)
          <b>found</b><A name="directory.1:findEntry.2:found.3(343)"></A><A name="found.3(343)"></A>: ^foundDesc;
          (* Reference to entry, if found.  Notice that 'found.path'
           * is relative to THIS(directory).  The full path may be
           * obtained by 'foundFullPath' Also 'foundFullPath -&gt;
           * found.path' may be needed before is queried for modtime
           * etc., if THIS(Directory) is not the current working
           * directory.
           *)
          <b>foundFile</b><A name="directory.1:findEntry.2:foundFile.3(344)"></A><A name="foundFile.3(344)"></A>:&lt; File; 
          (* Qualification of file generated in
           * select.whenfile.thefile
           *)
          <b>foundDir</b><A name="directory.1:findEntry.2:foundDir.3(345)"></A><A name="foundDir.3(345)"></A>:&lt; Directory;
          (* Qualification of directory generated in
           * select.whendir.thedir
           *)
          <b>foundFullPath</b><A name="directory.1:findEntry.2:foundFullPath.3(346)"></A><A name="foundFullPath.3(346)"></A>: (* Fullpath of "found" *)
            (# p: ^text do ... exit p[] #);
           
          <b>notfound</b><A name="directory.1:findEntry.2:notfound.3(347)"></A><A name="notfound.3(347)"></A>:&lt; (* Called if the entry was not found *)
            (# do INNER #);
          <b>select</b><A name="directory.1:findEntry.2:select.3(348)"></A><A name="select.3(348)"></A>:
            (* Used to distinguish between the various entries that
             * may be found
             *)
            (# <b>error</b><A name="directory.1:findEntry.2:select.3:error.4(349)"></A><A name="error.4(349)"></A>:&lt; found.DiskEntryException;
               <b>whenFile</b><A name="directory.1:findEntry.2:select.3:whenFile.4(350)"></A><A name="whenFile.4(350)"></A>:&lt;
                 (* Called when the entry found is a file *)
                 (# thefile: 
                      (* Generate an instance of foundFile
                       * corresponding to the entry found. Notice that
                       * 'found' and 'f.entry' are two distinct
                       * objects; 'f.entry' has a full path, 'found'
                       * may or may not have a path relative to
                       * THIS(Directory).
                       *)
                      (# f: ^foundFile 
                      do ...
                      exit f[]
                      #);
                 do INNER
                 #);
               <b>whenDir</b><A name="directory.1:findEntry.2:select.3:whenDir.4(351)"></A><A name="whenDir.4(351)"></A>:&lt;
                 (* Called when the entry found is a directory *)
                 (# theDir: 
                      (* Generate an instance of foundDir
                       * corresponding to the entry found. Notice that
                       * 'found' and 'd.entry' are two distinct
                       * objects; 'd.entry' has a full path, 'found'
                       * may or may not have a path relative to
                       * THIS(Directory).
                       *)
                      (# d: ^foundDir 
                      do ...
                      exit d[]
                      #);
                 do INNER
                 #);
               <b>whenOther</b><A name="directory.1:findEntry.2:select.3:whenOther.4(352)"></A><A name="whenOther.4(352)"></A>:&lt;
                 (* Called when the entry found is neither a file nor
                  * a directory
                  *)
                 (# do INNER #);
               <b>selectImpl</b><A name="directory.1:findEntry.2:select.3:selectImpl.4(353)"></A><A name="selectImpl.4(353)"></A>:&lt; (* private *)
                 (# selectedInInner: @boolean
                 do ...;
                    INNER; ...;
                 #)
            do selectImpl;
            #); (* select *)
          <b>error</b><A name="directory.1:findEntry.2:error.3(354)"></A><A name="error.3(354)"></A>:&lt; DirSearchException
            (* Raised if the search fails *);
       enter candidate[]
       do ...;
       #); (* findEntry *)
     <b>scanEntries</b><A name="directory.1:scanEntries.2(355)"></A><A name="scanEntries.2(355)"></A>:
       (* Calls INNER for each entry in THIS(directory) *)
       (# &lt;&lt;SLOT DirScanLib: attributes&gt;&gt;;
          <b>longest</b><A name="directory.1:scanEntries.2:longest.3(356)"></A><A name="longest.3(356)"></A>: @integer;
          (* The length of the longest entry-name in THIS(directory)
           *)
          <b>foundDesc</b><A name="directory.1:scanEntries.2:foundDesc.3(357)"></A><A name="foundDesc.3(357)"></A>:&lt; DiskEntry;
          (* Qualification of "found" *)
          <b>found</b><A name="directory.1:scanEntries.2:found.3(358)"></A><A name="found.3(358)"></A>: ^foundDesc;
          (* Reference to entry, if found.  Notice that 'found.path'
           * is relative to THIS(directory).  The full path may be
           * obtained by 'foundFullPath' Also 'foundFullPath -&gt;
           * found.path' may be needed before is queried for modtime
           * etc., if THIS(Directory) is not the current working
           * directory.
           *)
          <b>foundFile</b><A name="directory.1:scanEntries.2:foundFile.3(359)"></A><A name="foundFile.3(359)"></A>:&lt; File; 
          (* Qualification of file generated in
           * select.whenfile.thefile
           *)
          <b>foundDir</b><A name="directory.1:scanEntries.2:foundDir.3(360)"></A><A name="foundDir.3(360)"></A>:&lt; Directory;
          (* Qualification of directory generated in
           * select.whendir.thedir
           *)
          <b>foundFullPath</b><A name="directory.1:scanEntries.2:foundFullPath.3(361)"></A><A name="foundFullPath.3(361)"></A>: (* Fullpath of "found"  *)
            (# p: ^text do ... exit p[] #);
          <b>select</b><A name="directory.1:scanEntries.2:select.3(362)"></A><A name="select.3(362)"></A>:
            (* Used to distinguish between the various entries that
             * may be found
             *)
            (# <b>error</b><A name="directory.1:scanEntries.2:select.3:error.4(363)"></A><A name="error.4(363)"></A>:&lt; found.DiskEntryException;
               <b>whenFile</b><A name="directory.1:scanEntries.2:select.3:whenFile.4(364)"></A><A name="whenFile.4(364)"></A>:&lt;
                 (* Called when the entry found is a file *)
                 (# thefile: 
                      (* Generate an instance of foundFile
                       * corresponding to the entry found. Notice that
                       * 'found' and 'f.entry' are two distinct
                       * objects; 'f.entry' has a full path, 'found'
                       * may or may not have a path relative to
                       * THIS(Directory).
                       *)
                      (# f: ^foundFile 
                      do ...
                      exit f[]
                      #);
                 do INNER
                 #);
               <b>whenDir</b><A name="directory.1:scanEntries.2:select.3:whenDir.4(365)"></A><A name="whenDir.4(365)"></A>:&lt;
                 (* Called when the entry found is a directory *)
                 (# theDir: 
                      (* Generate an instance of foundDir
                       * corresponding to the entry found. Notice that
                       * 'found' and 'd.entry' are two distinct
                       * objects; 'd.entry' has a full path, 'found'
                       * may or may not have a path relative to
                       * THIS(Directory).
                       *)
                      (# d: ^foundDir 
                      do ...
                      exit d[]
                      #);
                 do INNER
                 #);
               <b>whenOther</b><A name="directory.1:scanEntries.2:select.3:whenOther.4(366)"></A><A name="whenOther.4(366)"></A>:&lt;
                 (* Called when the entry found is neither a file nor
                  * a directory
                  *)
                 (# do INNER #);
               <b>selectImpl</b><A name="directory.1:scanEntries.2:select.3:selectImpl.4(367)"></A><A name="selectImpl.4(367)"></A>:&lt; (* private *)
                 (# selectedInInner: @boolean
                 do ...;
                    INNER; ...;
                 #)
            do selectImpl;
            #); (* select *)
          <b>error</b><A name="directory.1:scanEntries.2:error.3(368)"></A><A name="error.3(368)"></A>:&lt; DirScanException
            (* Raised if the scan fails *);
          (* idx- *) (* idx- *)
       do ...;
       #); (* scanEntries *)
     <b>private</b><A name="directory.1:private.2(369)"></A><A name="private.2(369)"></A>: @...;
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<ADDRESS>Interface Description</ADDRESS>
<P></P>
<A HREF="external.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="betaenv.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Prev BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
