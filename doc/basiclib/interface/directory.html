<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Directory Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="basicsystemenv.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="file.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Directory Interface</H1>
<PRE CLASS=interface>
ORIGIN 'file';
LIB_DEF 'directory' '../lib';
BODY 'private/directorybody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1984-96
 *       All rights reserved.
 *
 *)
---- LIB: attributes ----
<B>directory</B><A name="directory.1(807)"></A>:
  (* Generalization of disk folder/directory.  Describes the list
   * aspects of directories and contains a DiskEntry item describing
   * the other properties of a directory.
   *)
  (#
     &lt;&lt;SLOT DirectoryLib: attributes&gt;&gt;;
     
     <B>EntryDesc</B><A name="directory.1:EntryDesc.2(808)"></A><A name="EntryDesc.2(808)"></A>:&lt; DiskEntry;
     <B>entry</B><A name="directory.1:entry.2(809)"></A><A name="entry.2(809)"></A>: @EntryDesc
       (* The item holding most characterizing attributes of
        * THIS(directory)
        *); 
     <B>name</B><A name="directory.1:name.2(810)"></A><A name="name.2(810)"></A>: @
       (* convenient interface to entry.path *)
       (# read:
            (* Reads a directory name from the Keyboard *)
            (# do ... #);
       enter entry.path
       exit entry.path
       #);
     
     (* Directory exceptions *)
     
     <B>DirException</B><A name="directory.1:DirException.2(811)"></A><A name="DirException.2(811)"></A>: Exception
       (* General directory exception *)
       (# do ...; INNER #);
     <B>EntryExistException</B><A name="directory.1:EntryExistException.2(812)"></A><A name="EntryExistException.2(812)"></A>: DirException
       (* Raised on attempt to create a file or directory that
        * allready existed in THIS(directory). Message: "Directory
        * entry allready exist"
        *)
       (# do ...; INNER #);
     <B>DirScanException</B><A name="directory.1:DirScanException.2(813)"></A><A name="DirScanException.2(813)"></A>: DirException
       (* Raised if a scan of THIS(directory) has failed.  Message:
        * "Scan of directory failed.", and an indication of why it
        * failed.
        *)
       (# do ...; INNER #);
     <B>DirSearchException</B><A name="directory.1:DirSearchException.2(814)"></A><A name="DirSearchException.2(814)"></A>: DirException
       (* Raised if a find in THIS(directory) has failed.  Message:
        * "Search of directory failed.", and an indication of why it
        * failed.
        *)
       (# do ...; INNER #);
     <B>NoSuchException</B><A name="directory.1:NoSuchException.2(815)"></A><A name="NoSuchException.2(815)"></A>: DirException
       (* Raised on attempt to delete a file or directory that did
        * not exist in THIS(directory). Message: "Attempt to delete a
        * nonexisting entry."
        *)
       (# do ...; INNER #);
     <B>NotFoundException</B><A name="directory.1:NotFoundException.2(816)"></A><A name="NotFoundException.2(816)"></A>: DirException
       (* Raised if findEntry.select is used in findEntry.notFound,
        * or in other situations that findEntry.found[]=NONE. Message:
        * "Attempt to use 'select' in 'findEntry' when the candidate
        * was not found."
        *)
       (# do ...; INNER #);
     
     (* Manipulations of THIS(directory) *)
     
     <B>touch</B><A name="directory.1:touch.2(817)"></A><A name="touch.2(817)"></A>: entry.touch
       (* If the disk entry does not exist, an empty directory will
        * be created.
        *)
       (# touchD: @...; 
       do touchD 
       #);
     <B>delete</B><A name="directory.1:delete.2(818)"></A><A name="delete.2(818)"></A>:
       (* Delete THIS(directory) *)
       (# nosuch:&lt; NoSuchException
            (* Raised if there was no disk entry corresponding to
             * THIS(Directory)
             *);
          error:&lt; entry.DiskEntryException
            (* Raised if other errors occurred *);
          deleteD: @...; 
       do deleteD
       #);
     <B>createFile</B><A name="directory.1:createFile.2(819)"></A><A name="createFile.2(819)"></A>:
       (* Create a file named 'name' in THIS(Directory) *)
       (# name: ^text;
          newEntry: ^EntryDesc;
          exists:&lt; EntryExistException
            (* Raised if en entry of that name already existed *);
          error:&lt; DirException
            (* Raised if other errors occurred *);
       enter name[]
       ...
       exit newEntry[]
       #);
     <B>deleteFile</B><A name="directory.1:deleteFile.2(820)"></A><A name="deleteFile.2(820)"></A>: 
       (* Delete a file named 'name' in THIS(Directory) *)
       (# name: ^text;
          nosuch:&lt; NoSuchException
            (* Raised if there was no disk entry in THIS(Directory)
             * named 'name'
             *);
          error:&lt;DirException
            (* Raised if other errors occured *)
       enter name[]
       ...
       #);
     <B>createDir</B><A name="directory.1:createDir.2(821)"></A><A name="createDir.2(821)"></A>:
       (* Create a directory named 'name' in THIS(Directory) *)
       (# name: ^text;
          newEntry: ^EntryDesc;
          exists:&lt; EntryExistException
            (* Raised if en entry of that name already existed *);
          error:&lt; DirException
            (* Raised if other errors occurred *);
       enter name[]
       ...
       exit newEntry[]
       #);
     <B>deleteDir</B><A name="directory.1:deleteDir.2(822)"></A><A name="deleteDir.2(822)"></A>:
       (* Delete a directory named 'name' in THIS(Directory) *)
       (# name: ^text;
          nosuch:&lt; NoSuchException
            (* Raised if there was no disk entry in THIS(Directory)
             * named 'name'
             *);
          error:&lt; DirException
            (* Raised if other errors occured *)
       enter name[]
       ...
       #);
     <B>noOfEntries</B><A name="directory.1:noOfEntries.2(823)"></A><A name="noOfEntries.2(823)"></A>: IntegerValue
       (* exit the number of entries in THIS(directory) *)
       (# error:&lt;DirException; 
       ... 
       #);
     <B>empty</B><A name="directory.1:empty.2(824)"></A><A name="empty.2(824)"></A>: BooleanValue
       (* TRUE iff THIS(directory) is empty. Note that this does not
        * always imply NoOfEntries=0
        *)
       (# error:&lt;DirException; 
       ... 
       #);
     <B>findEntry</B><A name="directory.1:findEntry.2(825)"></A><A name="findEntry.2(825)"></A>:
       (* Calls INNER if entry was found in THIS(directory), and
        * otherwise calls notFound
        *)
       (# &lt;&lt;SLOT DirFindLib: attributes&gt;&gt;;
          <B>candidate</B><A name="directory.1:findEntry.2:candidate.3(826)"></A><A name="candidate.3(826)"></A>: ^text;
          (* The name of the entry to search for *)
          <B>foundDesc</B><A name="directory.1:findEntry.2:foundDesc.3(827)"></A><A name="foundDesc.3(827)"></A>:&lt; DiskEntry;
          (* Qualification of "found" *)
          <B>found</B><A name="directory.1:findEntry.2:found.3(828)"></A><A name="found.3(828)"></A>: ^foundDesc;
          (* Reference to entry, if found.  Notice that 'found.path'
           * is relative to THIS(directory).  The full path may be
           * obtained by 'foundFullPath' Also 'foundFullPath -&gt;
           * found.path' may be needed before is queried for modtime
           * etc., if THIS(Directory) is not the current working
           * directory.
           *)
          <B>foundFile</B><A name="directory.1:findEntry.2:foundFile.3(829)"></A><A name="foundFile.3(829)"></A>:&lt; File; 
          (* Qualification of file generated in
           * select.whenfile.thefile
           *)
          <B>foundDir</B><A name="directory.1:findEntry.2:foundDir.3(830)"></A><A name="foundDir.3(830)"></A>:&lt; Directory;
          (* Qualification of directory generated in
           * select.whendir.thedir
           *)
          <B>foundFullPath</B><A name="directory.1:findEntry.2:foundFullPath.3(831)"></A><A name="foundFullPath.3(831)"></A>: (* Fullpath of "found" *)
            (# p: ^text do ... exit p[] #);
           
          <B>notfound</B><A name="directory.1:findEntry.2:notfound.3(832)"></A><A name="notfound.3(832)"></A>:&lt; (* Called if the entry was not found *)
            (# do INNER #);
          <B>select</B><A name="directory.1:findEntry.2:select.3(833)"></A><A name="select.3(833)"></A>:
            (* Used to distinguish between the various entries that
             * may be found
             *)
            (# <B>error</B><A name="directory.1:findEntry.2:select.3:error.4(834)"></A><A name="error.4(834)"></A>:&lt; found.DiskEntryException;
               <B>whenFile</B><A name="directory.1:findEntry.2:select.3:whenFile.4(835)"></A><A name="whenFile.4(835)"></A>:&lt;
                 (* Called when the entry found is a file *)
                 (# thefile: 
                      (* Generate an instance of foundFile
                       * corresponding to the entry found. Notice that
                       * 'found' and 'f.entry' are two distinct
                       * objects; 'f.entry' has a full path, 'found'
                       * may or may not have a path relative to
                       * THIS(Directory).
                       *)
                      (# f: ^foundFile 
                      do ...
                      exit f[]
                      #);
                 do INNER
                 #);
               <B>whenDir</B><A name="directory.1:findEntry.2:select.3:whenDir.4(836)"></A><A name="whenDir.4(836)"></A>:&lt;
                 (* Called when the entry found is a directory *)
                 (# theDir: 
                      (* Generate an instance of foundDir
                       * corresponding to the entry found. Notice that
                       * 'found' and 'd.entry' are two distinct
                       * objects; 'd.entry' has a full path, 'found'
                       * may or may not have a path relative to
                       * THIS(Directory).
                       *)
                      (# d: ^foundDir 
                      do ...
                      exit d[]
                      #);
                 do INNER
                 #);
               <B>whenOther</B><A name="directory.1:findEntry.2:select.3:whenOther.4(837)"></A><A name="whenOther.4(837)"></A>:&lt;
                 (* Called when the entry found is neither a file nor
                  * a directory
                  *)
                 (# do INNER #);
               <B>selectImpl</B><A name="directory.1:findEntry.2:select.3:selectImpl.4(838)"></A><A name="selectImpl.4(838)"></A>:&lt; (* private *)
                 (# selectedInInner: @boolean
                 do ...;
                    INNER; ...;
                 #)
            do selectImpl;
            #); (* select *)
          <B>error</B><A name="directory.1:findEntry.2:error.3(839)"></A><A name="error.3(839)"></A>:&lt; DirSearchException
            (* Raised if the search fails *);
       enter candidate[]
       do ...;
       #); (* findEntry *)
     <B>scanEntries</B><A name="directory.1:scanEntries.2(840)"></A><A name="scanEntries.2(840)"></A>:
       (* Calls INNER for each entry in THIS(directory) *)
       (# &lt;&lt;SLOT DirScanLib: attributes&gt;&gt;;
          <B>longest</B><A name="directory.1:scanEntries.2:longest.3(841)"></A><A name="longest.3(841)"></A>: @integer;
          (* The length of the longest entry-name in THIS(directory)
           *)
          <B>foundDesc</B><A name="directory.1:scanEntries.2:foundDesc.3(842)"></A><A name="foundDesc.3(842)"></A>:&lt; DiskEntry;
          (* Qualification of "found" *)
          <B>found</B><A name="directory.1:scanEntries.2:found.3(843)"></A><A name="found.3(843)"></A>: ^foundDesc;
          (* Reference to entry, if found.  Notice that 'found.path'
           * is relative to THIS(directory).  The full path may be
           * obtained by 'foundFullPath' Also 'foundFullPath -&gt;
           * found.path' may be needed before is queried for modtime
           * etc., if THIS(Directory) is not the current working
           * directory.
           *)
          <B>foundFile</B><A name="directory.1:scanEntries.2:foundFile.3(844)"></A><A name="foundFile.3(844)"></A>:&lt; File; 
          (* Qualification of file generated in
           * select.whenfile.thefile
           *)
          <B>foundDir</B><A name="directory.1:scanEntries.2:foundDir.3(845)"></A><A name="foundDir.3(845)"></A>:&lt; Directory;
          (* Qualification of directory generated in
           * select.whendir.thedir
           *)
          <B>foundFullPath</B><A name="directory.1:scanEntries.2:foundFullPath.3(846)"></A><A name="foundFullPath.3(846)"></A>: (* Fullpath of "found"  *)
            (# p: ^text do ... exit p[] #);
          <B>select</B><A name="directory.1:scanEntries.2:select.3(847)"></A><A name="select.3(847)"></A>:
            (* Used to distinguish between the various entries that
             * may be found
             *)
            (# <B>error</B><A name="directory.1:scanEntries.2:select.3:error.4(848)"></A><A name="error.4(848)"></A>:&lt; found.DiskEntryException;
               <B>whenFile</B><A name="directory.1:scanEntries.2:select.3:whenFile.4(849)"></A><A name="whenFile.4(849)"></A>:&lt;
                 (* Called when the entry found is a file *)
                 (# thefile: 
                      (* Generate an instance of foundFile
                       * corresponding to the entry found. Notice that
                       * 'found' and 'f.entry' are two distinct
                       * objects; 'f.entry' has a full path, 'found'
                       * may or may not have a path relative to
                       * THIS(Directory).
                       *)
                      (# f: ^foundFile 
                      do ...
                      exit f[]
                      #);
                 do INNER
                 #);
               <B>whenDir</B><A name="directory.1:scanEntries.2:select.3:whenDir.4(850)"></A><A name="whenDir.4(850)"></A>:&lt;
                 (* Called when the entry found is a directory *)
                 (# theDir: 
                      (* Generate an instance of foundDir
                       * corresponding to the entry found. Notice that
                       * 'found' and 'd.entry' are two distinct
                       * objects; 'd.entry' has a full path, 'found'
                       * may or may not have a path relative to
                       * THIS(Directory).
                       *)
                      (# d: ^foundDir 
                      do ...
                      exit d[]
                      #);
                 do INNER
                 #);
               <B>whenOther</B><A name="directory.1:scanEntries.2:select.3:whenOther.4(851)"></A><A name="whenOther.4(851)"></A>:&lt;
                 (* Called when the entry found is neither a file nor
                  * a directory
                  *)
                 (# do INNER #);
               <B>selectImpl</B><A name="directory.1:scanEntries.2:select.3:selectImpl.4(852)"></A><A name="selectImpl.4(852)"></A>:&lt; (* private *)
                 (# selectedInInner: @boolean
                 do ...;
                    INNER; ...;
                 #)
            do selectImpl;
            #); (* select *)
          <B>error</B><A name="directory.1:scanEntries.2:error.3(853)"></A><A name="error.3(853)"></A>:&lt; DirScanException
            (* Raised if the scan fails *);
          (* idx- *) (* idx- *)
       do ...;
       #); (* scanEntries *)
     <B>private</B><A name="directory.1:private.2(854)"></A><A name="private.2(854)"></A>: @...;
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="33%" align="left"><ADDRESS>Interface Description</ADDRESS></TD>
<TD width="34%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="33%" align="right"><FONT size=-1><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></FONT></TD>
</TABLE>
<P></P>
<A HREF="basicsystemenv.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="file.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
