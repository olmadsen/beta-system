<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Betaenv Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="math.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Betaenv Interface</H1>
<PRE CLASS=interface>
LIB_DEF 'betaenv' '../lib';
BODY 'private/betaenvbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1984-96
 *       All rights reserved.
 *
 * This fragment implements the very basic patterns, utilized by most
 * BETA programs
 *)
-- betaenv: descriptor --
(# &lt;&lt;SLOT lib: attributes&gt;&gt;;
   (******************************************************************)
   (* The simple patterns for simple values and variables.  These
    * simple patterns are treated special by the compiler.
    *)
   <B>integer</B><A name="betaenv.1:integer.2(1)"></A><A name="integer.2(1)"></A>: (* 32 bit signed long *) (# #);
   <B>shortInt</B><A name="betaenv.1:shortInt.2(2)"></A><A name="shortInt.2(2)"></A>: (* 16 bit unsigned half *) (# #); (* do not use shortInt anymore,
                                                * use int16u instead.
                                                *)
   <B>char</B><A name="betaenv.1:char.2(3)"></A><A name="char.2(3)"></A>: (* 8 bit unsigned byte *) (# #);
   <B>boolean</B><A name="betaenv.1:boolean.2(4)"></A><A name="boolean.2(4)"></A>: (* 8 bit unsigned byte, values 0 or 1 *) (# #);
   <B>false</B><A name="betaenv.1:false.2(5)"></A><A name="false.2(5)"></A>: boolean (* 8 bit unsigned byte with value 0 *) (# #);
   <B>true</B><A name="betaenv.1:true.2(6)"></A><A name="true.2(6)"></A>: boolean (* 8 bit unsigned byte with value 1 *) (# #);
   <B>real</B><A name="betaenv.1:real.2(7)"></A><A name="real.2(7)"></A>: (* double precision floating point number *) (# #);
   
   <B>int8</B><A name="betaenv.1:int8.2(8)"></A><A name="int8.2(8)"></A>: (* 8 bit signed integer *) (# #); 
   <B>int8u</B><A name="betaenv.1:int8u.2(9)"></A><A name="int8u.2(9)"></A>: (* 8 bit unsigned integer *) (# #);
   <B>int16</B><A name="betaenv.1:int16.2(10)"></A><A name="int16.2(10)"></A>: (* 16 bit signed integer *) (# #);
   <B>int16u</B><A name="betaenv.1:int16u.2(11)"></A><A name="int16u.2(11)"></A>: (* 16 bit unsigned integer.
            * int16u will eventually replace shortInt *) (# #);
   <B>int32</B><A name="betaenv.1:int32.2(12)"></A><A name="int32.2(12)"></A>: (* 32 bit signed integer
           * int32 is semantically identical to integer *) (# #);
   <B>int32u</B><A name="betaenv.1:int32u.2(13)"></A><A name="int32u.2(13)"></A>: (* 32 bit unsigned integer *) (# #);
   
   (* int64 and int64u are NOT yet implemented;
    * the compiler allows variables of these types,
    * but no operations, including assignment,
    * are implemented, so don't use them.
    *)
   <B>int64</B><A name="betaenv.1:int64.2(14)"></A><A name="int64.2(14)"></A>: (* 64 bit signed integer *) (# #); 
   <B>int64u</B><A name="betaenv.1:int64u.2(15)"></A><A name="int64u.2(15)"></A>: (* 64 bit unsigned integer *) (# #);
   
   (* The pattern wchar is for experimenting with implementing
    * support for the UniCode character set. The name wchar
    * is preliminary. wchar is semantically identical to int16u.
    * Patterns wcharValue and wcharObject have also been introduced below
    *)
   <B>wchar</B><A name="betaenv.1:wchar.2(16)"></A><A name="wchar.2(16)"></A>: (# #); (* 16 bit unsigend integer *)
   
   (* The pattern COM is for experimenting with implementation
    * of COM support in BETA
    *)
   <B>COM</B><A name="betaenv.1:COM.2(17)"></A><A name="COM.2(17)"></A>: (# #); (* General super pattern for COM objects *)
   
   (* Holder is general superpattern for holder-patterns used for 
    * parameters in COM.
    *)
   <B>Holder</B><A name="betaenv.1:Holder.2(18)"></A><A name="Holder.2(18)"></A>: (# adr: @integer #);  
   
   <B>object</B><A name="betaenv.1:object.2(19)"></A><A name="object.2(19)"></A>: (* General superpattern *)
     (# <B>_struc</B><A name="betaenv.1:object.2:_struc.3(20)"></A><A name="_struc.3(20)"></A>: 
          (* Exit a pattern reference for THIS(Object).
           * Is now obsolete: the new form obj## is preferred
           * to the old form obj.struc
           *)
          (#
          exit this(object)##
          #);
        <B>_new</B><A name="betaenv.1:object.2:_new.3(21)"></A><A name="_new.3(21)"></A>: 
          (* returns a new object, that is qualified exactly
           * as THIS(object)
           *)
          (# newObj: ^object; oType: ##object
          do this(object)##-&gt;oType##; &amp;oType[]-&gt;newObj[]; INNER _new
          exit newObj[]
          #);
        <B>_state</B><A name="betaenv.1:object.2:_state.3(22)"></A><A name="_state.3(22)"></A>: 
          (* Pattern _state is for experimental purpose only
           * and using it may give undefined results 
           *)
          (# S: ##object
          enter S##
          ...
          #)
     do INNER object
     #);
   (* idx *)
   
   (* The following patterns define 'real' patterns corresponding to
    * the predefined simple patterns
    *)
   <B>integerValue</B><A name="betaenv.1:integerValue.2(23)"></A><A name="integerValue.2(23)"></A>: (# <B>value</B><A name="betaenv.1:integerValue.2:value.3(24)"></A><A name="value.3(24)"></A>: @integer do INNER integerValue exit value #);
   <B>integerObject</B><A name="betaenv.1:integerObject.2(25)"></A><A name="integerObject.2(25)"></A>: integerValue(# enter value do INNER integerObject #);
   <B>charValue</B><A name="betaenv.1:charValue.2(26)"></A><A name="charValue.2(26)"></A>: (# <B>value</B><A name="betaenv.1:charValue.2:value.3(27)"></A><A name="value.3(27)"></A>: @char do INNER charValue exit value #);
   <B>charObject</B><A name="betaenv.1:charObject.2(28)"></A><A name="charObject.2(28)"></A>: charValue(# enter value do INNER charObject #);
   <B>wcharValue</B><A name="betaenv.1:wcharValue.2(29)"></A><A name="wcharValue.2(29)"></A>: (# <B>value</B><A name="betaenv.1:wcharValue.2:value.3(30)"></A><A name="value.3(30)"></A>: @wchar do INNER wcharValue exit value #);
   <B>wcharObject</B><A name="betaenv.1:wcharObject.2(31)"></A><A name="wcharObject.2(31)"></A>: wcharValue(# enter value do INNER wcharObject #);
   <B>booleanValue</B><A name="betaenv.1:booleanValue.2(32)"></A><A name="booleanValue.2(32)"></A>: (# <B>value</B><A name="betaenv.1:booleanValue.2:value.3(33)"></A><A name="value.3(33)"></A>: @boolean do INNER booleanValue exit value #);
   <B>booleanObject</B><A name="betaenv.1:booleanObject.2(34)"></A><A name="booleanObject.2(34)"></A>: booleanValue(# enter value do INNER booleanObject #);
   <B>trueObject</B><A name="betaenv.1:trueObject.2(35)"></A><A name="trueObject.2(35)"></A>: booleanObject(# do true-&gt;value; INNER trueObject #);
   <B>falseObject</B><A name="betaenv.1:falseObject.2(36)"></A><A name="falseObject.2(36)"></A>: booleanObject(# do INNER falseObject #);
   <B>realValue</B><A name="betaenv.1:realValue.2(37)"></A><A name="realValue.2(37)"></A>: (# <B>value</B><A name="betaenv.1:realValue.2:value.3(38)"></A><A name="value.3(38)"></A>: @real do INNER realValue exit value #);
   <B>realObject</B><A name="betaenv.1:realObject.2(39)"></A><A name="realObject.2(39)"></A>: realValue(# enter value do INNER realObject #);
   
   (****  Integer limits *********************************************) 
   <B>MaxInt8</B><A name="betaenv.1:MaxInt8.2(40)"></A><A name="MaxInt8.2(40)"></A>:   (# exit 0x7f #);
   <B>MinInt8</B><A name="betaenv.1:MinInt8.2(41)"></A><A name="MinInt8.2(41)"></A>:   (# exit 0x80 #);
   <B>MaxInt8u</B><A name="betaenv.1:MaxInt8u.2(42)"></A><A name="MaxInt8u.2(42)"></A>:  (# exit 0xff #);
   <B>MinInt8u</B><A name="betaenv.1:MinInt8u.2(43)"></A><A name="MinInt8u.2(43)"></A>:  (# exit 0x00 #);
   
   <B>MaxInt16</B><A name="betaenv.1:MaxInt16.2(44)"></A><A name="MaxInt16.2(44)"></A>:  (# exit 0x7fff #);
   <B>MinInt16</B><A name="betaenv.1:MinInt16.2(45)"></A><A name="MinInt16.2(45)"></A>:  (# exit 0x8000 #);
   <B>MaxInt16u</B><A name="betaenv.1:MaxInt16u.2(46)"></A><A name="MaxInt16u.2(46)"></A>: (# exit 0xffff #);
   <B>MinInt16u</B><A name="betaenv.1:MinInt16u.2(47)"></A><A name="MinInt16u.2(47)"></A>: (# exit 0x0000 #);
   
   <B>MaxInt32</B><A name="betaenv.1:MaxInt32.2(48)"></A><A name="MaxInt32.2(48)"></A>:  (# exit 0x7fffffff #);
   <B>MinInt32</B><A name="betaenv.1:MinInt32.2(49)"></A><A name="MinInt32.2(49)"></A>:  (# exit 0x80000000 #);
   <B>MaxInt32u</B><A name="betaenv.1:MaxInt32u.2(50)"></A><A name="MaxInt32u.2(50)"></A>: (# exit 0xffffffff #);
   <B>MinInt32u</B><A name="betaenv.1:MinInt32u.2(51)"></A><A name="MinInt32u.2(51)"></A>: (# exit 0x00000000 #);
   
   <B>MaxInt</B><A name="betaenv.1:MaxInt.2(52)"></A><A name="MaxInt.2(52)"></A>:    (# exit MaxInt32 #);
   <B>MinInt</B><A name="betaenv.1:MinInt.2(53)"></A><A name="MinInt.2(53)"></A>:    (# exit MinInt32 #);
   
   <B>MaxReal</B><A name="betaenv.1:MaxReal.2(54)"></A><A name="MaxReal.2(54)"></A>:   (# exit 1.797693134862315E+308 #);
   <B>MinReal</B><A name="betaenv.1:MinReal.2(55)"></A><A name="MinReal.2(55)"></A>:   (# exit 2.225073858507201E-308 #);

   (****  Implementation dependent constants *************************) 
   <B>infReal</B><A name="betaenv.1:infReal.2(56)"></A><A name="infReal.2(56)"></A>: (* Returns the real value 'Infinity' *)
     realValue(# ... #);
   
   (*****  Functional patterns ***************************************)
   <B>min</B><A name="betaenv.1:min.2(57)"></A><A name="min.2(57)"></A>: (* Returns the minimum of 2 integers *)
     (# <B>a</B><A name="betaenv.1:min.2:a.3(58)"></A><A name="a.3(58)"></A>,<B>b</B><A name="betaenv.1:min.2:b.3(59)"></A><A name="b.3(59)"></A>: @integer
     enter (a,b)
     do (if (a &lt; b) then a-&gt;b if)
     exit b
     #);
   <B>max</B><A name="betaenv.1:max.2(60)"></A><A name="max.2(60)"></A>: (* Returns the maximum of 2 integers *)
     (# <B>a</B><A name="betaenv.1:max.2:a.3(61)"></A><A name="a.3(61)"></A>,<B>b</B><A name="betaenv.1:max.2:b.3(62)"></A><A name="b.3(62)"></A>: @integer
     enter (a,b)
     do (if (a &lt; b) then b-&gt;a if)
     exit a
     #);
   <B>abs</B><A name="betaenv.1:abs.2(63)"></A><A name="abs.2(63)"></A>: (* Returns the absolute value of an integer *)
     (# <B>n</B><A name="betaenv.1:abs.2:n.3(64)"></A><A name="n.3(64)"></A>: @integer
     enter n
     do (if (n &lt; 0) then -n-&gt;n if)
     exit n
     #);
   
   (*****  Simple standard input/output patterns *********************)
   <B>keyboard</B><A name="betaenv.1:keyboard.2(65)"></A><A name="keyboard.2(65)"></A>,<B> screen</B><A name="betaenv.1:screen.2(66)"></A><A name="screen.2(66)"></A>: ^stream;
   <B>get</B><A name="betaenv.1:get.2(67)"></A><A name="get.2(67)"></A>:
     (# <B>ch</B><A name="betaenv.1:get.2:ch.3(68)"></A><A name="ch.3(68)"></A>: @char; <B>getC</B><A name="betaenv.1:get.2:getC.3(69)"></A><A name="getC.3(69)"></A>: @keyboard.get do getC-&gt;ch; INNER get exit ch #);
   <B>put</B><A name="betaenv.1:put.2(70)"></A><A name="put.2(70)"></A>:
     (# <B>ch</B><A name="betaenv.1:put.2:ch.3(71)"></A><A name="ch.3(71)"></A>: @char; <B>putC</B><A name="betaenv.1:put.2:putC.3(72)"></A><A name="putC.3(72)"></A>: @screen.put enter ch do INNER put; ch-&gt;putC #);
   <B>newline</B><A name="betaenv.1:newline.2(73)"></A><A name="newline.2(73)"></A>:
     screen.newline(# #);
   <B>putint</B><A name="betaenv.1:putint.2(74)"></A><A name="putint.2(74)"></A>:
     screen.putint(# do INNER putint #);
   <B>getint</B><A name="betaenv.1:getint.2(75)"></A><A name="getint.2(75)"></A>:
     keyBoard.getint(# do INNER getint #);
   <B>puttext</B><A name="betaenv.1:puttext.2(76)"></A><A name="puttext.2(76)"></A>:
     (# <B>t</B><A name="betaenv.1:puttext.2:t.3(77)"></A><A name="t.3(77)"></A>: ^text; <B>putT</B><A name="betaenv.1:puttext.2:putT.3(78)"></A><A name="putT.3(78)"></A>: @screen.puttext
     enter t[]
     do INNER puttext; t[]-&gt;putT
     #);
   <B>putline</B><A name="betaenv.1:putline.2(79)"></A><A name="putline.2(79)"></A>:
     screen.putline(# do INNER putline #);
   <B>getNonBlank</B><A name="betaenv.1:getNonBlank.2(80)"></A><A name="getNonBlank.2(80)"></A>:
     keyBoard.getNonBlank(# do INNER getNonBlank #);
   <B>scanAtom</B><A name="betaenv.1:scanAtom.2(81)"></A><A name="scanAtom.2(81)"></A>:
     keyBoard.scanAtom(# do INNER scanAtom #);
   <B>getAtom</B><A name="betaenv.1:getAtom.2(82)"></A><A name="getAtom.2(82)"></A>:
     (# <B>t</B><A name="betaenv.1:getAtom.2:t.3(83)"></A><A name="t.3(83)"></A>: ^text; <B>getA</B><A name="betaenv.1:getAtom.2:getA.3(84)"></A><A name="getA.3(84)"></A>: @keyBoard.getAtom
     do getA-&gt;t[]; INNER getAtom
     exit t[]
     #);
   <B>getline</B><A name="betaenv.1:getline.2(85)"></A><A name="getline.2(85)"></A>:
     (# <B>t</B><A name="betaenv.1:getline.2:t.3(86)"></A><A name="t.3(86)"></A>: ^text; <B>getL</B><A name="betaenv.1:getline.2:getL.3(87)"></A><A name="getL.3(87)"></A>: @keyBoard.getline
     do getL-&gt;t[]; INNER getline
     exit t[]
     #);
   
   (*****  Control patterns ******************************************)
   <B>forTo</B><A name="betaenv.1:forTo.2(88)"></A><A name="forTo.2(88)"></A>: (* for 'inx' in [low:high] do INNER forTo *)
     (# <B>low</B><A name="betaenv.1:forTo.2:low.3(89)"></A><A name="low.3(89)"></A>,<B> high</B><A name="betaenv.1:forTo.2:high.3(90)"></A><A name="high.3(90)"></A>,<B> inx</B><A name="betaenv.1:forTo.2:inx.3(91)"></A><A name="inx.3(91)"></A>: @integer;
     enter (low, high)
     ...  
     #);
   <B>cycle</B><A name="betaenv.1:cycle.2(92)"></A><A name="cycle.2(92)"></A>: (* Executes INNER forever *)
     (# ... #);
   <B>loop</B><A name="betaenv.1:loop.2(93)"></A><A name="loop.2(93)"></A>: 
     (# <B>while</B><A name="betaenv.1:loop.2:while.3(94)"></A><A name="while.3(94)"></A>:&lt; booleanValue(# do true-&gt;value; INNER while #);
        <B>until</B><A name="betaenv.1:loop.2:until.3(95)"></A><A name="until.3(95)"></A>:&lt; booleanValue;
        <B>whilecondition</B><A name="betaenv.1:loop.2:whilecondition.3(96)"></A><A name="whilecondition.3(96)"></A>: @while;
        <B>untilcondition</B><A name="betaenv.1:loop.2:untilcondition.3(97)"></A><A name="untilcondition.3(97)"></A>: @until;
     ...
     #);
   <B>qua</B><A name="betaenv.1:qua.2(98)"></A><A name="qua.2(98)"></A>:
     (* Pattern replacing the BETA language construct QUA.  To be
      * used as 't1[]-&gt;qua(# as::&lt; Tn #)-&gt;t2[]'.  The 'qua' pattern
      * checks, whether 't1' is qualified by 'Tn'.  If not, the
      * 'quaError' exception is invoked.  Otherwise, a reference
      * qualified by 'Tn', and referring to the same object as 't1[]'
      * is referring, is returned.
      *)
     (# <B>as</B><A name="betaenv.1:qua.2:as.3(99)"></A><A name="as.3(99)"></A>:&lt; object; <B>R</B><A name="betaenv.1:qua.2:R.3(100)"></A><A name="R.3(100)"></A>: ^object; <B>thisObj</B><A name="betaenv.1:qua.2:thisObj.3(101)"></A><A name="thisObj.3(101)"></A>: ^as;
        <B>quaError</B><A name="betaenv.1:qua.2:quaError.3(102)"></A><A name="quaError.3(102)"></A>:&lt; exception
          (# do 'Qualification error'-&gt;msg.append; INNER quaError #)
     enter R[]
     ...  
     exit thisObj[]
     #);
   
   (*****  Stream patterns *******************************************)
   <B>stream</B><A name="betaenv.1:stream.2(103)"></A><A name="stream.2(103)"></A>: 
     (# &lt;&lt;SLOT streamLib: attributes&gt;&gt;;
        <B>length</B><A name="betaenv.1:stream.2:length.3(104)"></A><A name="length.3(104)"></A>:&lt; integerValue (* returns the length of THIS(stream) *)
          (#
          do -1-&gt;value; INNER length
          #);
        <B>position</B><A name="betaenv.1:stream.2:position.3(105)"></A><A name="position.3(105)"></A>: (* current position of THIS(stream) *)
          (# 
          enter setPos
          exit getPos
          #);
        <B>eos</B><A name="betaenv.1:stream.2:eos.3(106)"></A><A name="eos.3(106)"></A>:&lt; (* returns 'true' if THIS(stream) is at end-of-stream *)
          booleanValue;
        <B>reset</B><A name="betaenv.1:stream.2:reset.3(107)"></A><A name="reset.3(107)"></A>: (* sets 'position' to zero *)
          (#
          do 0-&gt;setPos
          exit THIS(stream)[]
          #);
        <B>peek</B><A name="betaenv.1:stream.2:peek.3(108)"></A><A name="peek.3(108)"></A>:&lt; (* looks at the next character of THIS(stream) *)
          (# <B>ch</B><A name="betaenv.1:stream.2:peek.3:ch.4(109)"></A><A name="ch.4(109)"></A>: @char
          do INNER peek
          exit ch
          #);
        <B>get</B><A name="betaenv.1:stream.2:get.3(110)"></A><A name="get.3(110)"></A>:&lt; (* reads a character from THIS(stream) *)
          (# <B>ch</B><A name="betaenv.1:stream.2:get.3:ch.4(111)"></A><A name="ch.4(111)"></A>: @char
          do INNER get
          exit ch
          #);
        <B>getNonBlank</B><A name="betaenv.1:stream.2:getNonBlank.3(112)"></A><A name="getNonBlank.3(112)"></A>: 
          (* Reads first non-whitespace character from THIS(stream).
           * If called at end-of-stream the character 'ascii.fs' is
           * returned
           *)
          (# <B>ch</B><A name="betaenv.1:stream.2:getNonBlank.3:ch.4(113)"></A><A name="ch.4(113)"></A>: @char;
             <B>skipblanks</B><A name="betaenv.1:stream.2:getNonBlank.3:skipblanks.4(114)"></A><A name="skipblanks.4(114)"></A>: @scanWhiteSpace;
             <B>testEOS</B><A name="betaenv.1:stream.2:getNonBlank.3:testEOS.4(115)"></A><A name="testEOS.4(115)"></A>: @EOS;
             <B>getCh</B><A name="betaenv.1:stream.2:getNonBlank.3:getCh.4(116)"></A><A name="getCh.4(116)"></A>: @get;
          ...
          exit ch
          #);
        <B>getint</B><A name="betaenv.1:stream.2:getint.3(117)"></A><A name="getint.3(117)"></A>: integerValue
          (* Reads an integer: skips whitespace characters and
           * returns the following digits.
           * 
           * See numberio.bet for more numerical output operations
           *)
          (# <B>syntaxError</B><A name="betaenv.1:stream.2:getint.3:syntaxError.4(118)"></A><A name="syntaxError.4(118)"></A>:&lt; streamException
               (# 
               ...
               #);
             <B>geti</B><A name="betaenv.1:stream.2:getint.3:geti.4(119)"></A><A name="geti.4(119)"></A>: @... 
          do geti; INNER getint
          #);
        <B>getAtom</B><A name="betaenv.1:stream.2:getAtom.3(120)"></A><A name="getAtom.3(120)"></A>:&lt;
          (* Returns the next atom (i.e. sequence of non-white
           * characters - skipping leading blanks)
           *)
          (# <B>txt</B><A name="betaenv.1:stream.2:getAtom.3:txt.4(121)"></A><A name="txt.4(121)"></A>: ^text;
          do &amp;text[]-&gt;txt[]; INNER getAtom;
          exit txt[]
          #);
        <B>getline</B><A name="betaenv.1:stream.2:getline.3(122)"></A><A name="getline.3(122)"></A>:&lt;
          (* Reads a sequence of characters until nl-character
           * appears and returns the characters read.
           *)
          (# <B>txt</B><A name="betaenv.1:stream.2:getline.3:txt.4(123)"></A><A name="txt.4(123)"></A>: ^text;
             <B>missing_newline</B><A name="betaenv.1:stream.2:getline.3:missing_newline.4(124)"></A><A name="missing_newline.4(124)"></A>:&lt; Object
               (* Called if last line of THIS(Stream) is
                * not terminated by a newline character.
                *);
          do &amp;text[]-&gt;txt[]; INNER getline
          exit txt[]
          #);
        <B>asInt</B><A name="betaenv.1:stream.2:asInt.3(125)"></A><A name="asInt.3(125)"></A>:
          (* converts THIS(text) to an integer value, ignoring
           * leading and trailing whitespace.  See numberio.bet for
           * more numerical conversion operations.
           *)
          (# <B>i</B><A name="betaenv.1:stream.2:asInt.3:i.4(126)"></A><A name="i.4(126)"></A>: @integer;
             <B>syntaxError</B><A name="betaenv.1:stream.2:asInt.3:syntaxError.4(127)"></A><A name="syntaxError.4(127)"></A>:&lt; streamException
               (# 
               ...
               #);
          ...
          exit i
          #);
        <B>put</B><A name="betaenv.1:stream.2:put.3(128)"></A><A name="put.3(128)"></A>:&lt; (* writes a character to THIS(stream) *)
          (# <B>ch</B><A name="betaenv.1:stream.2:put.3:ch.4(129)"></A><A name="ch.4(129)"></A>: @char
          enter ch
          do INNER put
          exit THIS(stream)[]
          #);
        <B>newline</B><A name="betaenv.1:stream.2:newline.3(130)"></A><A name="newline.3(130)"></A>: (* writes the nl-character *) 
          (#
          do ascii.newline-&gt;put
          exit THIS(stream)[]
          #);
        <B>putint</B><A name="betaenv.1:stream.2:putint.3(131)"></A><A name="putint.3(131)"></A>: 
          (* Writes an integer to THIS(stream); The format may be
           * controlled by the 'signed', 'blankSign', 'width',
           * 'adjustLeft' and 'zeroPadding' variable attributes.
           * 'width' is extended if it is too small.  Examples:
           * '10-&gt;putint' yields: '10'; '10*pi-&gt;putint(# do 10-&gt;width;
           * true-&gt;adjustLeft #)' yields: '10 '; and '10-&gt;putint(# do * 10-&gt;width; true-&gt;zeroPadding #)' yields: '0000000010'.
           * 
           * See numberio.bet for more numerical output operations
           *)
          (# <B>n</B><A name="betaenv.1:stream.2:putint.3:n.4(132)"></A><A name="n.4(132)"></A>: @integer;
             <B>signed</B><A name="betaenv.1:stream.2:putint.3:signed.4(133)"></A><A name="signed.4(133)"></A>: @boolean
               (* If integer is positive, a '+' will always be
                * displayed
                *);
             <B>blankSign</B><A name="betaenv.1:stream.2:putint.3:blankSign.4(134)"></A><A name="blankSign.4(134)"></A>: @boolean 
               (* If integer is positive, a ' ' space is displayed as
                * the sign.  Ignored if 'signed=true'
                *);
             <B>width</B><A name="betaenv.1:stream.2:putint.3:width.4(135)"></A><A name="width.4(135)"></A>: @integer
               (* Minimum width *);
             <B>adjustLeft</B><A name="betaenv.1:stream.2:putint.3:adjustLeft.4(136)"></A><A name="adjustLeft.4(136)"></A>: @boolean
               (* Specifies if the number is to be aligned left or
                * right, if padding of spaces is necessary to fill up
                * the specified width.
                *);
             <B>zeroPadding</B><A name="betaenv.1:stream.2:putint.3:zeroPadding.4(137)"></A><A name="zeroPadding.4(137)"></A>: @boolean
               (* width is padded with leading zero instead of
                * spaces.  Ignored if 'adjustLeft=true'
                *);
             <B>format</B><A name="betaenv.1:stream.2:putint.3:format.4(138)"></A><A name="format.4(138)"></A>:&lt; (# do INNER format #);
             <B>puti</B><A name="betaenv.1:stream.2:putint.3:puti.4(139)"></A><A name="puti.4(139)"></A>: @...
          enter n
          do 1-&gt;width; format; INNER putint; puti
          exit THIS(stream)[]
          #);
        <B>puttext</B><A name="betaenv.1:stream.2:puttext.3(140)"></A><A name="puttext.3(140)"></A>:&lt; (* Writes a text to THIS(stream). *)
          (# <B>txt</B><A name="betaenv.1:stream.2:puttext.3:txt.4(141)"></A><A name="txt.4(141)"></A>: ^text
          enter txt[]
          do (if txt[]&lt;&gt;NONE then INNER puttext if)
          exit THIS(stream)[]
          #);
        <B>putline</B><A name="betaenv.1:stream.2:putline.3(142)"></A><A name="putline.3(142)"></A>: 
          (* 'puttext' followed by 'newline' *)
          (# <B>T</B><A name="betaenv.1:stream.2:putline.3:T.4(143)"></A><A name="T.4(143)"></A>: ^text; <B>putT</B><A name="betaenv.1:stream.2:putline.3:putT.4(144)"></A><A name="putT.4(144)"></A>: @puttext; <B>newL</B><A name="betaenv.1:stream.2:putline.3:newL.4(145)"></A><A name="newL.4(145)"></A>: @newline
          enter T[]
          do INNER putline; T[]-&gt;putT; newL
          exit THIS(stream)[]
          #);
        <B>scan</B><A name="betaenv.1:stream.2:scan.3(146)"></A><A name="scan.3(146)"></A>: 
          (* Scan chars from current position in THIS(stream) while
           * '(ch-&gt;while)=true'; perform INNER for each char being
           * scanned
           *)
          (# <B>while</B><A name="betaenv.1:stream.2:scan.3:while.4(147)"></A><A name="while.4(147)"></A>:&lt;
               (# ch: @char; value: @boolean
               enter ch
               do true-&gt;value; INNER while
               exit value
               #);
             <B>ch</B><A name="betaenv.1:stream.2:scan.3:ch.4(148)"></A><A name="ch.4(148)"></A>: @char;
             <B>whilecondition</B><A name="betaenv.1:stream.2:scan.3:whilecondition.4(149)"></A><A name="whilecondition.4(149)"></A>: @while;
             <B>testEOS</B><A name="betaenv.1:stream.2:scan.3:testEOS.4(150)"></A><A name="testEOS.4(150)"></A>: @EOS;
             <B>getPeek</B><A name="betaenv.1:stream.2:scan.3:getPeek.4(151)"></A><A name="getPeek.4(151)"></A>: @peek;
             <B>getCh</B><A name="betaenv.1:stream.2:scan.3:getCh.4(152)"></A><A name="getCh.4(152)"></A>: @get;
          ...
          exit THIS(stream)[]
          #);
        <B>scanWhiteSpace</B><A name="betaenv.1:stream.2:scanWhiteSpace.3(153)"></A><A name="scanWhiteSpace.3(153)"></A>: scan 
          (* Scan whitespace characters *)
          (# <B>while</B><A name="betaenv.1:stream.2:scanWhiteSpace.3:while.4(154)"></A><A name="while.4(154)"></A>::&lt; (# do ch-&gt;ascii.isWhiteSpace-&gt;value #);
          do INNER scanWhiteSpace
          exit THIS(stream)[]
          #);
        <B>scanAtom</B><A name="betaenv.1:stream.2:scanAtom.3(155)"></A><A name="scanAtom.3(155)"></A>: 
          (* Scan until first non-whitespace char.  Scan the next
           * sequence of non-whitespace chars.  Stop at first
           * whitespace char.  For each non-whitespace char an INNER
           * is performed. Usage: 'scanAtom(# do ch-&gt;&lt;destination&gt; #)'
           *)
          (# <B>ch</B><A name="betaenv.1:stream.2:scanAtom.3:ch.4(156)"></A><A name="ch.4(156)"></A>: @char;
          ...
          exit THIS(stream)[]
          #);
        <B>scanToNl</B><A name="betaenv.1:stream.2:scanToNl.3(157)"></A><A name="scanToNl.3(157)"></A>: 
          (* Scan all chars in current line including newline char *)
          (# <B>ch</B><A name="betaenv.1:stream.2:scanToNl.3:ch.4(158)"></A><A name="ch.4(158)"></A>: @char; <B>getCh</B><A name="betaenv.1:stream.2:scanToNl.3:getCh.4(159)"></A><A name="getCh.4(159)"></A>: @get;
             <B>missing_newline</B><A name="betaenv.1:stream.2:scanToNl.3:missing_newline.4(160)"></A><A name="missing_newline.4(160)"></A>:&lt; Object
               (* Called if last line of THIS(Stream) is
                * not terminated by a newline character.
                *);
          ...
          exit THIS(stream)[]
          #);
        <B>streamException</B><A name="betaenv.1:stream.2:streamException.3(161)"></A><A name="streamException.3(161)"></A>: exception
          (# do INNER streamException #);
        <B>EOSerror</B><A name="betaenv.1:stream.2:EOSerror.3(162)"></A><A name="EOSerror.3(162)"></A>:&lt; streamException
          (* Raised from 'get' and 'peek' when attempted to read past
           * the end of the stream.
           *)
          (# 
          do 'Attempt to read past end-of-stream'-&gt;msg.putline; 
             INNER EOSerror
          #);
        <B>otherError</B><A name="betaenv.1:stream.2:otherError.3(163)"></A><A name="otherError.3(163)"></A>:&lt; streamException
          (* Raised when some other kind of stream error apart from
           * the one mentioned above occurs.
           *);
        <B>getPos</B><A name="betaenv.1:stream.2:getPos.3(164)"></A><A name="getPos.3(164)"></A>:&lt; (* returns current position of THIS(Stream) *)
          integerValue;
        <B>setPos</B><A name="betaenv.1:stream.2:setPos.3(165)"></A><A name="setPos.3(165)"></A>:&lt; (* sets current position in THIS(stream) to 'p' *)
          (# <B>p</B><A name="betaenv.1:stream.2:setPos.3:p.4(166)"></A><A name="p.4(166)"></A>: @integer
          enter p
          do INNER setPos
          exit THIS(stream)[]
          #)
     #); (* pattern stream *)
   
   (*****  Text pattern **********************************************)
   <B>text</B><A name="betaenv.1:text.2(167)"></A><A name="text.2(167)"></A>: stream
     (* A text is a sequence of characters.  Let 'T: @text'. The
      * range of 'T' is '[1,T.length]'.  A text can be initialized by
      * executing 'T.clear' or by assigning it another (initialized)
      * text.  A text-constant has the form 'foo'.  The 'text' pattern
      * is primarily intended for small texts but there is no upper
      * limit in the size. However, most of the operations becomes
      * less efficient with larger texts.
      *)
     (# &lt;&lt;SLOT textLib: attributes&gt;&gt;;
        <B>length</B><A name="betaenv.1:text.2:length.3(168)"></A><A name="length.3(168)"></A>::&lt; (* Returns the length of THIS(text) *) 
          (# do lgth-&gt;value; INNER length #);
        <B>eos</B><A name="betaenv.1:text.2:eos.3(169)"></A><A name="eos.3(169)"></A>::&lt;(# ... #);
        <B>empty</B><A name="betaenv.1:text.2:empty.3(170)"></A><A name="empty.3(170)"></A>: 
          (# exit (lgth = 0) #);
        <B>clear</B><A name="betaenv.1:text.2:clear.3(171)"></A><A name="clear.3(171)"></A>: (* Sets the length and position of THIS(text) to zero *)
          (#
          do 0-&gt;pos-&gt;lgth
          exit THIS(text)[]
          #);
        <B>equal</B><A name="betaenv.1:text.2:equal.3(172)"></A><A name="equal.3(172)"></A>: booleanValue
          (* Tests if THIS(text) is equal to the entered text.  If
           * 'NCS' is further bound to 'trueObject', the comparison
           * will be done Non Case Sensitive.
           *)
          (# <B>txt</B><A name="betaenv.1:text.2:equal.3:txt.4(173)"></A><A name="txt.4(173)"></A>: ^text;
             <B>NCS</B><A name="betaenv.1:text.2:equal.3:NCS.4(174)"></A><A name="NCS.4(174)"></A>:&lt; booleanObject
          enter txt[]
          ...
          #);
        <B>equalNCS</B><A name="betaenv.1:text.2:equalNCS.3(175)"></A><A name="equalNCS.3(175)"></A>: equal
          (* As 'equal', except the the comparison will be done Non
           * Case Sensitive
           *)
          (# <B>NCS</B><A name="betaenv.1:text.2:equalNCS.3:NCS.4(176)"></A><A name="NCS.4(176)"></A>:: trueObject #);
        <B>less</B><A name="betaenv.1:text.2:less.3(177)"></A><A name="less.3(177)"></A>: booleanValue
          (* Tests whether the entered text 'T1[1: length]' is less
           * than 'THIS(text)[1: T1.length]'.  The lexicographical
           * ordering is used.
           *)
          (# <B>T1</B><A name="betaenv.1:text.2:less.3:T1.4(178)"></A><A name="T1.4(178)"></A>: ^text
          enter T1[]
          ...
          #);
        <B>greater</B><A name="betaenv.1:text.2:greater.3(179)"></A><A name="greater.3(179)"></A>: booleanValue
          (* Tests whether the entered text 'T1[1: length]' is
           * greater than 'THIS(text)[1: T1.length]'.  The
           * lexicographical ordering is used.
           *)
          (# <B>T1</B><A name="betaenv.1:text.2:greater.3:T1.4(180)"></A><A name="T1.4(180)"></A>: ^text
          enter T1[]
          ...
          #);
        <B>peek</B><A name="betaenv.1:text.2:peek.3(181)"></A><A name="peek.3(181)"></A>::&lt;
          (* Returns the character at current position; does not
           * update 'position'
           *)
          (# ... #);
        <B>get</B><A name="betaenv.1:text.2:get.3(182)"></A><A name="get.3(182)"></A>::&lt;
          (* Returns the character at current position; increments
           * 'position'
           *) 
          (# ... #);
        <B>inxGet</B><A name="betaenv.1:text.2:inxGet.3(183)"></A><A name="inxGet.3(183)"></A>: charValue
          (* Returns the character at position 'i' *)
          (# <B>i</B><A name="betaenv.1:text.2:inxGet.3:i.4(184)"></A><A name="i.4(184)"></A>: @integer;
             <B>iget</B><A name="betaenv.1:text.2:inxGet.3:iget.4(185)"></A><A name="iget.4(185)"></A>: @...
          enter i
          do iget
          #);
        <B>getAtom</B><A name="betaenv.1:text.2:getAtom.3(186)"></A><A name="getAtom.3(186)"></A>::&lt;
          (* Returns the next atom (i.e. sequence of non-white
           * characters - skipping leading blanks)
           *)
          (# ... #);
        <B>getline</B><A name="betaenv.1:text.2:getline.3(187)"></A><A name="getline.3(187)"></A>::&lt;
          (* Reads a sequence of characters until nl-character
           * appears and returns the characters read.
           *)
          (# ... #);
        <B>put</B><A name="betaenv.1:text.2:put.3(188)"></A><A name="put.3(188)"></A>::&lt;
          (* writes the character 'ch' at current position in
           * THIS(text); increments 'position'
           *) 
          (# ... #);
        <B>inxPut</B><A name="betaenv.1:text.2:inxPut.3(189)"></A><A name="inxPut.3(189)"></A>: 
          (* Replaces the character at position 'i' *)
          (# <B>ch</B><A name="betaenv.1:text.2:inxPut.3:ch.4(190)"></A><A name="ch.4(190)"></A>: @char;
             <B>i</B><A name="betaenv.1:text.2:inxPut.3:i.4(191)"></A><A name="i.4(191)"></A>: @integer;
             <B>iput</B><A name="betaenv.1:text.2:inxPut.3:iput.4(192)"></A><A name="iput.4(192)"></A>: @...
          enter (ch,i)
          do iput
          exit THIS(text)[]
          #);
        <B>puttext</B><A name="betaenv.1:text.2:puttext.3(193)"></A><A name="puttext.3(193)"></A>::&lt;(# ... #);
        <B>append</B><A name="betaenv.1:text.2:append.3(194)"></A><A name="append.3(194)"></A>: 
          (* Appends a text to THIS(text); does not change 'position'
           *)
          (# <B>T1</B><A name="betaenv.1:text.2:append.3:T1.4(195)"></A><A name="T1.4(195)"></A>: ^text
          enter T1[]
          ...
          exit THIS(text)[]
          #);
        <B>prepend</B><A name="betaenv.1:text.2:prepend.3(196)"></A><A name="prepend.3(196)"></A>: 
          (* Inserts the text in 'T1' in front of THIS(text); updates
           * current position to 'position+T1.length' if 'position&gt;0'
           *)
          (# <B>T1</B><A name="betaenv.1:text.2:prepend.3:T1.4(197)"></A><A name="T1.4(197)"></A>: ^text
          enter T1[]
          ...
          exit THIS(text)[]
          #);
        <B>insert</B><A name="betaenv.1:text.2:insert.3(198)"></A><A name="insert.3(198)"></A>: 
          (* Inserts a text before the character at position 'inx'.
           * Note: inx&lt;1 means inx=1; inx&gt;length means inx=length+1.
           * If 'position&gt;=inx' then 'position+T1.length-&gt;position'.
           *)
          (# <B>T1</B><A name="betaenv.1:text.2:insert.3:T1.4(199)"></A><A name="T1.4(199)"></A>: ^text;
             <B>inx</B><A name="betaenv.1:text.2:insert.3:inx.4(200)"></A><A name="inx.4(200)"></A>: @integer
          enter (T1[],inx)
          ...
          exit THIS(text)[]
          #);
        <B>delete</B><A name="betaenv.1:text.2:delete.3(201)"></A><A name="delete.3(201)"></A>: 
          (* Deletes THIS(text)[i: j]; updates current position:
           *      i&lt;=position&lt;j =&gt; i-1-&gt;position
           *      j&lt;=position   =&gt; position-(j-i+1)-&gt;position
           *)
          (# <B>i</B><A name="betaenv.1:text.2:delete.3:i.4(202)"></A><A name="i.4(202)"></A>,<B>j</B><A name="betaenv.1:text.2:delete.3:j.4(203)"></A><A name="j.4(203)"></A>: @integer; 
             <B>deleteT</B><A name="betaenv.1:text.2:delete.3:deleteT.4(204)"></A><A name="deleteT.4(204)"></A>: @...
          enter (i,j)
          do deleteT
          exit THIS(text)[]
          #);
        <B>makeLC</B><A name="betaenv.1:text.2:makeLC.3(205)"></A><A name="makeLC.3(205)"></A>: (* Converts all characters to lower case *)
          (# ...
          exit THIS(text)[]
          #);
        <B>makeUC</B><A name="betaenv.1:text.2:makeUC.3(206)"></A><A name="makeUC.3(206)"></A>: 
          (* Converts all characters to upper case *)
          (# ...
          exit THIS(text)[]
          #);
        <B>sub</B><A name="betaenv.1:text.2:sub.3(207)"></A><A name="sub.3(207)"></A>:
          (* Returns a copy of THIS(text)[i:j].  If 'i&lt;1', 'i' is
           * adjusted to 1. If 'j&gt;length', 'j' is adjusted to
           * 'length'.  If (after adjustment) 'i&gt;j', an empty text is
           * returned.
           *)
          (# <B>i</B><A name="betaenv.1:text.2:sub.3:i.4(208)"></A><A name="i.4(208)"></A>,<B>j</B><A name="betaenv.1:text.2:sub.3:j.4(209)"></A><A name="j.4(209)"></A>: @integer; <B>T1</B><A name="betaenv.1:text.2:sub.3:T1.4(210)"></A><A name="T1.4(210)"></A>: ^text;
             <B>subI</B><A name="betaenv.1:text.2:sub.3:subI.4(211)"></A><A name="subI.4(211)"></A>: @...
          enter (i,j)
          do subI
          exit T1[]
          #);
        <B>copy</B><A name="betaenv.1:text.2:copy.3(212)"></A><A name="copy.3(212)"></A>: 
          (# <B>T1</B><A name="betaenv.1:text.2:copy.3:T1.4(213)"></A><A name="T1.4(213)"></A>: ^text;
             <B>copyI</B><A name="betaenv.1:text.2:copy.3:copyI.4(214)"></A><A name="copyI.4(214)"></A>: @...
          do copyI
          exit T1[]
          #);
        <B>scanAll</B><A name="betaenv.1:text.2:scanAll.3(215)"></A><A name="scanAll.3(215)"></A>: 
          (* Scans all the elements in THIS(text).  For 'ch' in '[1:
           * THIS(text).length]' do INNER
           *)
          (# <B>ch</B><A name="betaenv.1:text.2:scanAll.3:ch.4(216)"></A><A name="ch.4(216)"></A>: @char
          do (<B>for i</B><A name="betaenv.1:text.2:scanAll.3:for.4(217)"></A><A name="for.4(217)"></A>: lgth repeat T[i]-&gt;ch; INNER scanAll for)
          exit THIS(text)[]
          #);
        <B>find</B><A name="betaenv.1:text.2:find.3(218)"></A><A name="find.3(218)"></A>:
          (* find all occurrences of the character 'ch' in
           * THIS(text), executing INNER for each occurrence found,
           * beginning at 'THIS(text).position'.  'inx' will contain
           * the position of each 'ch' in THIS(text).  If 'NCS' is
           * further bound to 'trueObject', the comparison will be
           * done Non Case Sensitive.  If 'from' is further bound, the
           * search will begin at position 'from'.
           *)
          (# <B>ch</B><A name="betaenv.1:text.2:find.3:ch.4(219)"></A><A name="ch.4(219)"></A>: @char;
             <B>inx</B><A name="betaenv.1:text.2:find.3:inx.4(220)"></A><A name="inx.4(220)"></A>: @integer;
             <B>NCS</B><A name="betaenv.1:text.2:find.3:NCS.4(221)"></A><A name="NCS.4(221)"></A>:&lt; booleanObject;
             <B>from</B><A name="betaenv.1:text.2:find.3:from.4(222)"></A><A name="from.4(222)"></A>:&lt; integerObject(# do pos-&gt;value; INNER from #)
          enter ch
          ...
          exit THIS(text)[]
          #);
        <B>findAll</B><A name="betaenv.1:text.2:findAll.3(223)"></A><A name="findAll.3(223)"></A>: find
          (* As 'find', except that the entire text will be searched.
           * Replaces 'findCh' in previous versions of betaenv (v1.4
           * and earlier)
           *)
          (# <B>from</B><A name="betaenv.1:text.2:findAll.3:from.4(224)"></A><A name="from.4(224)"></A>:: (# do 0-&gt;value #)
          do INNER findAll
          #);
        <B>findText</B><A name="betaenv.1:text.2:findText.3(225)"></A><A name="findText.3(225)"></A>:
          (* find all occurrences of the 'txt' in THIS(text),
           * executing INNER for each occurrence found, beginning at
           * 'THIS(text).position'.  'inx' will contain the position
           * of the first character of each occurrence found
           * THIS(text).  If 'NCS' is further bound to 'trueObject',
           * the comparison will be done Non Case Sensitive.  If
           * 'from' is further bound, the search will begin at
           * position 'from'.
           *)
          (# <B>txt</B><A name="betaenv.1:text.2:findText.3:txt.4(226)"></A><A name="txt.4(226)"></A>: ^text;
             <B>inx</B><A name="betaenv.1:text.2:findText.3:inx.4(227)"></A><A name="inx.4(227)"></A>: @integer;
             <B>NCS</B><A name="betaenv.1:text.2:findText.3:NCS.4(228)"></A><A name="NCS.4(228)"></A>:&lt; booleanObject;
             <B>from</B><A name="betaenv.1:text.2:findText.3:from.4(229)"></A><A name="from.4(229)"></A>:&lt; integerObject(# do pos-&gt;value; INNER from #)
          enter txt[]
          ...
          exit THIS(text)[]
          #);
        <B>findTextAll</B><A name="betaenv.1:text.2:findTextAll.3(230)"></A><A name="findTextAll.3(230)"></A>: findText
          (* As 'findText', except that the entire text will be
           * searched
           *)
          (# <B>from</B><A name="betaenv.1:text.2:findTextAll.3:from.4(231)"></A><A name="from.4(231)"></A>:: (# do 0-&gt;value #)
          do INNER findTextAll
          #);
        <B>extend</B><A name="betaenv.1:text.2:extend.3(232)"></A><A name="extend.3(232)"></A>: 
          (* Extend THIS(text) with 'L' (undefined) chars. Notice
           * that it is only the representation of the THIS(text),
           * that is extended, the 'length' and 'position' are not
           * changed.
           *)
          (# <B>L</B><A name="betaenv.1:text.2:extend.3:L.4(233)"></A><A name="L.4(233)"></A>: @integer
          enter L do L-&gt;T.extend
          exit THIS(text)[]
          #);
        <B>indexError</B><A name="betaenv.1:text.2:indexError.3(234)"></A><A name="indexError.3(234)"></A>:&lt; streamException
          (* Raised from 'Check' when the index goes outside the
           * range of the text. Message: "Index error in text!".
           *)
          (# <B>inx</B><A name="betaenv.1:text.2:indexError.3:inx.4(235)"></A><A name="inx.4(235)"></A>: @integer 
          enter inx
          ...
          #);
        <B>EOSerror</B><A name="betaenv.1:text.2:EOSerror.3(236)"></A><A name="EOSerror.3(236)"></A>::&lt;
          (* Raised from 'get' and 'peek' when the end of the stream is
           * passed.
           *) 
          (# ... #);
        <B>otherError</B><A name="betaenv.1:text.2:otherError.3(237)"></A><A name="otherError.3(237)"></A>::&lt;
          (* Raised when an error other than the Index-/EOSerror
           * occurs.
           *) 
          (# ... #);
        <B>setPos</B><A name="betaenv.1:text.2:setPos.3(238)"></A><A name="setPos.3(238)"></A>::&lt;(# ... #);
        <B>getPos</B><A name="betaenv.1:text.2:getPos.3(239)"></A><A name="getPos.3(239)"></A>::&lt;(# do pos-&gt;value; INNER getPos #);
        (* Private attributes: !!OBS!! The 3 attributes 'T', 'lgth'
         * and 'pos' declared below MUST be the first data items
         * declared in 'stream' and 'text' since their addresses are
         * hardcoded into the compiler.
         *)
        <B>T</B><A name="betaenv.1:text.2:T.3(240)"></A><A name="T.3(240)"></A>: [16] @char;
        <B>lgth</B><A name="betaenv.1:text.2:lgth.3(241)"></A><A name="lgth.3(241)"></A>,<B>pos</B><A name="betaenv.1:text.2:pos.3(242)"></A><A name="pos.3(242)"></A>: (* 16 is default size *) @integer;
        <B>setT</B><A name="betaenv.1:text.2:setT.3(243)"></A><A name="setT.3(243)"></A>: (# enter T do T.range-&gt;lgth-&gt;pos #)
     enter setT
     exit T[1<A name="betaenv.1:text.2:1.3(244)"></A><A name="1.3(244)"></A>: lgth]
     #) (* Pattern text *); 
   
   (*****  ASCII character constants and attributes ******************)
   <B>ascii</B><A name="betaenv.1:ascii.2(245)"></A><A name="ascii.2(245)"></A>: @
     (# &lt;&lt;SLOT asciiLib: attributes&gt;&gt;;
        <B>nul</B><A name="betaenv.1:ascii.2:nul.3(246)"></A><A name="nul.3(246)"></A>: (# exit 0 #);
        <B>soh</B><A name="betaenv.1:ascii.2:soh.3(247)"></A><A name="soh.3(247)"></A>: (# exit 1 #);
        <B>stx</B><A name="betaenv.1:ascii.2:stx.3(248)"></A><A name="stx.3(248)"></A>: (# exit 2 #);
        <B>etx</B><A name="betaenv.1:ascii.2:etx.3(249)"></A><A name="etx.3(249)"></A>: (# exit 3 #);
        <B>eot</B><A name="betaenv.1:ascii.2:eot.3(250)"></A><A name="eot.3(250)"></A>: (# exit 4 #);
        <B>enq</B><A name="betaenv.1:ascii.2:enq.3(251)"></A><A name="enq.3(251)"></A>: (# exit 5 #);
        <B>ack</B><A name="betaenv.1:ascii.2:ack.3(252)"></A><A name="ack.3(252)"></A>: (# exit 6 #);
        <B>bel</B><A name="betaenv.1:ascii.2:bel.3(253)"></A><A name="bel.3(253)"></A>: (# exit 7 #);
        <B>bs</B><A name="betaenv.1:ascii.2:bs.3(254)"></A><A name="bs.3(254)"></A>: (# exit 8 #);
        <B>ht</B><A name="betaenv.1:ascii.2:ht.3(255)"></A><A name="ht.3(255)"></A>: (# exit 9 #);
        <B>nl</B><A name="betaenv.1:ascii.2:nl.3(256)"></A><A name="nl.3(256)"></A>: (# exit 10 #);
        <B>vt</B><A name="betaenv.1:ascii.2:vt.3(257)"></A><A name="vt.3(257)"></A>: (# exit 11 #);
        <B>np</B><A name="betaenv.1:ascii.2:np.3(258)"></A><A name="np.3(258)"></A>: (# exit 12 #);
        <B>cr</B><A name="betaenv.1:ascii.2:cr.3(259)"></A><A name="cr.3(259)"></A>: (# exit 13 #);
        <B>so</B><A name="betaenv.1:ascii.2:so.3(260)"></A><A name="so.3(260)"></A>: (# exit 14 #);
        <B>si</B><A name="betaenv.1:ascii.2:si.3(261)"></A><A name="si.3(261)"></A>: (# exit 15 #);
        <B>dle</B><A name="betaenv.1:ascii.2:dle.3(262)"></A><A name="dle.3(262)"></A>: (# exit 16 #);
        <B>dc1</B><A name="betaenv.1:ascii.2:dc1.3(263)"></A><A name="dc1.3(263)"></A>: (# exit 17 #);
        <B>dc2</B><A name="betaenv.1:ascii.2:dc2.3(264)"></A><A name="dc2.3(264)"></A>: (# exit 18 #);
        <B>dc3</B><A name="betaenv.1:ascii.2:dc3.3(265)"></A><A name="dc3.3(265)"></A>: (# exit 19 #);
        <B>dc4</B><A name="betaenv.1:ascii.2:dc4.3(266)"></A><A name="dc4.3(266)"></A>: (# exit 20 #);
        <B>nak</B><A name="betaenv.1:ascii.2:nak.3(267)"></A><A name="nak.3(267)"></A>: (# exit 21 #);
        <B>syn</B><A name="betaenv.1:ascii.2:syn.3(268)"></A><A name="syn.3(268)"></A>: (# exit 22 #);
        <B>etb</B><A name="betaenv.1:ascii.2:etb.3(269)"></A><A name="etb.3(269)"></A>: (# exit 23 #);
        <B>can</B><A name="betaenv.1:ascii.2:can.3(270)"></A><A name="can.3(270)"></A>: (# exit 24 #);
        <B>em</B><A name="betaenv.1:ascii.2:em.3(271)"></A><A name="em.3(271)"></A>: (# exit 25 #);
        <B>sub</B><A name="betaenv.1:ascii.2:sub.3(272)"></A><A name="sub.3(272)"></A>: (# exit 26 #);
        <B>esc</B><A name="betaenv.1:ascii.2:esc.3(273)"></A><A name="esc.3(273)"></A>: (# exit 27 #);
        <B>fs</B><A name="betaenv.1:ascii.2:fs.3(274)"></A><A name="fs.3(274)"></A>: (# exit 28 #);
        <B>gs</B><A name="betaenv.1:ascii.2:gs.3(275)"></A><A name="gs.3(275)"></A>: (# exit 29 #);
        <B>rs</B><A name="betaenv.1:ascii.2:rs.3(276)"></A><A name="rs.3(276)"></A>: (# exit 30 #);
        <B>us</B><A name="betaenv.1:ascii.2:us.3(277)"></A><A name="us.3(277)"></A>: (# exit 31 #);
        <B>sp</B><A name="betaenv.1:ascii.2:sp.3(278)"></A><A name="sp.3(278)"></A>: (# exit 32 #);
        <B>capA</B><A name="betaenv.1:ascii.2:capA.3(279)"></A><A name="capA.3(279)"></A>: (# exit 65 #);
        <B>smalla</B><A name="betaenv.1:ascii.2:smalla.3(280)"></A><A name="smalla.3(280)"></A>: (# exit 97 #);
        <B>del</B><A name="betaenv.1:ascii.2:del.3(281)"></A><A name="del.3(281)"></A>: (# exit 127 #);
        <B>newline</B><A name="betaenv.1:ascii.2:newline.3(282)"></A><A name="newline.3(282)"></A>: @char; (* either 'lf' or 'cr' *)
        
        <B>init</B><A name="betaenv.1:ascii.2:init.3(283)"></A><A name="init.3(283)"></A>: ...;
        <B>upCase</B><A name="betaenv.1:ascii.2:upCase.3(284)"></A><A name="upCase.3(284)"></A>: @charObject
          (# ... #);
        <B>lowCase</B><A name="betaenv.1:ascii.2:lowCase.3(285)"></A><A name="lowCase.3(285)"></A>: @charObject
          (# ... #);
        <B>testChar</B><A name="betaenv.1:ascii.2:testChar.3(286)"></A><A name="testChar.3(286)"></A>: booleanValue
          (# <B>ch</B><A name="betaenv.1:ascii.2:testChar.3:ch.4(287)"></A><A name="ch.4(287)"></A>: @char
          enter ch
          do INNER testchar
          #);
        <B>isUpper</B><A name="betaenv.1:ascii.2:isUpper.3(288)"></A><A name="isUpper.3(288)"></A>: @testChar
          (# ... #);
        <B>isLower</B><A name="betaenv.1:ascii.2:isLower.3(289)"></A><A name="isLower.3(289)"></A>: @testChar
          (# ... #);
        <B>isDigit</B><A name="betaenv.1:ascii.2:isDigit.3(290)"></A><A name="isDigit.3(290)"></A>: @testChar
          (# ... #);
        <B>isLetter</B><A name="betaenv.1:ascii.2:isLetter.3(291)"></A><A name="isLetter.3(291)"></A>: @testChar
          (# ... #);
        <B>isSpace</B><A name="betaenv.1:ascii.2:isSpace.3(292)"></A><A name="isSpace.3(292)"></A>: @testChar
          (* True if 'ch' in {sp,cr,nl,np,ht,vt} *) 
          (# ... #);
        <B>isWhiteSpace</B><A name="betaenv.1:ascii.2:isWhiteSpace.3(293)"></A><A name="isWhiteSpace.3(293)"></A>: @testChar
          (* True if 'ch' is a whitespace char *) 
          (# ... #);
        <B>private</B><A name="betaenv.1:ascii.2:private.3(294)"></A><A name="private.3(294)"></A>: @...
     #);
   (*****  Exception Patterns ****************************************)
   <B>stop</B><A name="betaenv.1:stop.2(295)"></A><A name="stop.2(295)"></A>: 
     (* Terminates program execution: 'termCode=normal': normal
      * termination; 'termCode=failure': abnormal termination;
      * 'termCode=failureTrace': abnormal termination with trace of
      * run-time stack on dump-file; 'T' will be printed on the
      * screen.
      *)
     (# <B>termCode</B><A name="betaenv.1:stop.2:termCode.3(296)"></A><A name="termCode.3(296)"></A>: @integer; <B>T</B><A name="betaenv.1:stop.2:T.3(297)"></A><A name="T.3(297)"></A>: ^text
     enter (termCode,T[])
     do ...
     #);
   <B>normal</B><A name="betaenv.1:normal.2(298)"></A><A name="normal.2(298)"></A>: (# exit 0 #);
   <B>failure</B><A name="betaenv.1:failure.2(299)"></A><A name="failure.2(299)"></A>: (# exit -1 #);
   <B>failureTrace</B><A name="betaenv.1:failureTrace.2(300)"></A><A name="failureTrace.2(300)"></A>: (# exit -2 #);
   <B>exception</B><A name="betaenv.1:exception.2(301)"></A><A name="exception.2(301)"></A>:
     (# &lt;&lt;SLOT exceptionLib: attributes&gt;&gt;;
        <B>msg</B><A name="betaenv.1:exception.2:msg.3(302)"></A><A name="msg.3(302)"></A>:
          (* append text to this 'msg' vatiable to specify the
           * exception error message for this(exception)
           *)
          @text;
        <B>continue</B><A name="betaenv.1:exception.2:continue.3(303)"></A><A name="continue.3(303)"></A>: @boolean
          (* the valur of this variable determines the control-flow
           * behaviour of this(exception): 
           *    true:  continue execution after exception
           *    false: terminate execution by calling 'stop'; default
           *);
        <B>propagate</B><A name="betaenv.1:exception.2:propagate.3(304)"></A><A name="propagate.3(304)"></A>:&lt;
          (* if further bound to trueObject, this(exception) allows
           * propagation (i.e. this(exception will _not_ terminate)
           *)
          booleanValue;
        <B>error</B><A name="betaenv.1:exception.2:error.3(305)"></A><A name="error.3(305)"></A>:
          (* used to define local exception conditions which can be
           * handled separately.  All 'error's that are not handled
           * separately will be handled by this(exception)
           *)
          (# &lt;&lt;SLOT errorLib: attributes&gt;&gt;
          do false-&gt;continue;
             INNER;
             '**** Error processing\n'-&gt;msg.prepend;
             (if not propagate and not continue then this(exception) if)
          exit propagate
          #);
        <B>notify</B><A name="betaenv.1:exception.2:notify.3(306)"></A><A name="notify.3(306)"></A>: error
          (* used to define local notification conditions which can be
           * handled separately.  All 'notify's that are not handled
           * separately will be handled by this(exception)
           *)
          (# do true-&gt;continue; INNER #);
        <B>termCode</B><A name="betaenv.1:exception.2:termCode.3(307)"></A><A name="termCode.3(307)"></A>: @integer
          (* Arg. to pattern 'stop'; initial failureTrace *);
     do failureTrace-&gt;termCode;
        INNER exception;
        (if not continue and not propagate then
            '**** Exception processing\n'-&gt;msg.prepend;
            (termCode,msg[])-&gt;stop
        if)
     #);
   <B>notification</B><A name="betaenv.1:notification.2(308)"></A><A name="notification.2(308)"></A>: exception
     (# do true-&gt;continue; INNER notification #);
   (*****  Object Pool ***********************************************)
   <B>objectPool</B><A name="betaenv.1:objectPool.2(309)"></A><A name="objectPool.2(309)"></A>: @
     (# &lt;&lt;SLOT objectPoolLib: attributes&gt;&gt;;
        <B>get</B><A name="betaenv.1:objectPool.2:get.3(310)"></A><A name="get.3(310)"></A>: 
          (# type:&lt; object;
             obj: ^type;
             exact:&lt; booleanValue;
             init:&lt; object(* Called if an object was created *)
          ...
          exit obj[]
          #);
        <B>strucGet</B><A name="betaenv.1:objectPool.2:strucGet.3(311)"></A><A name="strucGet.3(311)"></A>: 
          (# type: ##object;
             obj: ^object;
             exact:&lt; booleanValue;
             init:&lt; object(* Called if an object was created *);
          enter type##
          ...
          exit obj[]
          #);
        <B>scan</B><A name="betaenv.1:objectPool.2:scan.3(312)"></A><A name="scan.3(312)"></A>: 
          (* Scan through all objects in 'objectPool', (at least)
           * qualified by 'type'.
           *)
          (# type:&lt; object;
             current: ^type;
             exact:&lt; booleanValue;
          ...
          #);
        <B>strucScan</B><A name="betaenv.1:objectPool.2:strucScan.3(313)"></A><A name="strucScan.3(313)"></A>: 
          (* Scan through all objects in 'objectPool', (at least)
           * qualified by 'type'
           *)
          (# type: ##object;
             current: ^object;
             exact:&lt; booleanValue
          enter type##
          ...
          #);
        <B>put</B><A name="betaenv.1:objectPool.2:put.3(314)"></A><A name="put.3(314)"></A>: 
          (* Puts a given object into 'objectPool'. If an object with
           * (at least) the qualification of the given object is
           * already present in 'objectPool', the exception
           * 'alreadyThere' is raised.
           *)
          (# obj: ^object;
             exact:&lt; booleanValue;
             alreadyThere:&lt; exception;
             putObj: @...
          enter obj[]
          do putObj
          #);
        <B>private</B><A name="betaenv.1:objectPool.2:private.3(315)"></A><A name="private.3(315)"></A>: @...;
     #);
   
   (*****  Command line arguments ************************************)
   <B>argumentHandlerType</B><A name="betaenv.1:argumentHandlerType.2(316)"></A><A name="argumentHandlerType.2(316)"></A>:
     (# 
        <B>noOfArguments</B><A name="betaenv.1:argumentHandlerType.2:noOfArguments.3(317)"></A><A name="noOfArguments.3(317)"></A>:&lt; 
          (* Return the number of arguments on command line.
           * The number includes the program name.
           *)
          integervalue;
        
        <B>getArgByNumber</B><A name="betaenv.1:argumentHandlerType.2:getArgByNumber.3(318)"></A><A name="getArgByNumber.3(318)"></A>:&lt;
          (* Returns argument number argNo.  
           * Number 1 is the program name, 
           * number 2 is the first program argument, etc.
           *)
          (# argNo: @integer; theArg: ^text;
          enter argNo
          do INNER
          exit theArg[]
          #);
     #);
   
   <B>rawArgumentHandler</B><A name="betaenv.1:rawArgumentHandler.2(319)"></A><A name="rawArgumentHandler.2(319)"></A>: argumentHandlerType
     (# 
        <B>noOfArguments</B><A name="betaenv.1:rawArgumentHandler.2:noOfArguments.3(320)"></A><A name="noOfArguments.3(320)"></A>::
          (# ... #);
        <B>getArgByNumber</B><A name="betaenv.1:rawArgumentHandler.2:getArgByNumber.3(321)"></A><A name="getArgByNumber.3(321)"></A>::
          (# ... #);
     #);
   
   <B>expandWildcardsArgumentHandler</B><A name="betaenv.1:expandWildcardsArgumentHandler.2(322)"></A><A name="expandWildcardsArgumentHandler.2(322)"></A>: argumentHandlerType
     (# <B>private</B><A name="betaenv.1:expandWildcardsArgumentHandler.2:private.3(323)"></A><A name="private.3(323)"></A>: @...;
        <B>noOfArguments</B><A name="betaenv.1:expandWildcardsArgumentHandler.2:noOfArguments.3(324)"></A><A name="noOfArguments.3(324)"></A>::
          (# ... #);
        <B>getArgByNumber</B><A name="betaenv.1:expandWildcardsArgumentHandler.2:getArgByNumber.3(325)"></A><A name="getArgByNumber.3(325)"></A>::
          (# ... #);
     #);
   
   <B>argumentHandler</B><A name="betaenv.1:argumentHandler.2(326)"></A><A name="argumentHandler.2(326)"></A>: ^argumentHandlerType;
   
   (* Backwards compatible interface *)
   <B>noOfArguments</B><A name="betaenv.1:noOfArguments.2(327)"></A><A name="noOfArguments.2(327)"></A>: integervalue(# do argumentHandler.noOfArguments -&gt; value #);
   <B>arguments</B><A name="betaenv.1:arguments.2(328)"></A><A name="arguments.2(328)"></A>: 
     (# <B>argNo</B><A name="betaenv.1:arguments.2:argNo.3(329)"></A><A name="argNo.3(329)"></A>: @integer; <B>theArg</B><A name="betaenv.1:arguments.2:theArg.3(330)"></A><A name="theArg.3(330)"></A>: ^text;
     enter argNo
     do argNo -&gt; argumentHandler.getArgByNumber -&gt; theArg[]
     exit theArg[]
     #);
   (******************************************************************)
   (* External language interface: See file 'external.bet' for further
    * patterns.
    *)
   <B>External</B><A name="betaenv.1:External.2(331)"></A><A name="External.2(331)"></A>:
     (* Is only meaningful with interface to externals *)
     (# <B>callC</B><A name="betaenv.1:External.2:callC.3(332)"></A><A name="callC.3(332)"></A>,<B>callPascal</B><A name="betaenv.1:External.2:callPascal.3(333)"></A><A name="callPascal.3(333)"></A>,<B>pascal</B><A name="betaenv.1:External.2:pascal.3(334)"></A><A name="pascal.3(334)"></A>,<B>pascalTrap</B><A name="betaenv.1:External.2:pascalTrap.3(335)"></A><A name="pascalTrap.3(335)"></A>,<B>callStd</B><A name="betaenv.1:External.2:callStd.3(336)"></A><A name="callStd.3(336)"></A>,<B>
        cExternalEntry</B><A name="betaenv.1:External.2:cExternalEntry.3(337)"></A><A name="cExternalEntry.3(337)"></A>,<B>pascalExternalEntry</B><A name="betaenv.1:External.2:pascalExternalEntry.3(338)"></A><A name="pascalExternalEntry.3(338)"></A>,<B>stdExternalEntry</B><A name="betaenv.1:External.2:stdExternalEntry.3(339)"></A><A name="stdExternalEntry.3(339)"></A>: @text
     #);
   <B>cStruct</B><A name="betaenv.1:cStruct.2(340)"></A><A name="cStruct.2(340)"></A>: 
     (* Super-pattern for describing structures which can be given
      * 'by refererence' (using the usual [] notation) to an external
      * function (e.g. a C function described as a specialization
      * of the above External pattern). See file external.bet for
      * supported operations on cStruct.
      *)
     (# &lt;&lt;SLOT cStructLib: attributes&gt;&gt;;
        (* 'R' is the bytestream containing THIS(cStruct).  
         * MUST be declared as the first attribute
         *);
        <B>R</B><A name="betaenv.1:cStruct.2:R.3(341)"></A><A name="R.3(341)"></A>: [(byteSize-1) div 4 + 1] @integer;
        <B>byteSize</B><A name="betaenv.1:cStruct.2:byteSize.3(342)"></A><A name="byteSize.3(342)"></A>:&lt; 
          (* Number of bytes in THIS(cStruct) *)
          IntegerObject;
          
        <B>BoundsExceeded</B><A name="betaenv.1:cStruct.2:BoundsExceeded.3(343)"></A><A name="BoundsExceeded.3(343)"></A>:&lt; Exception
          (* Raised if indexing outside range of R *)
          (# <B>inx</B><A name="betaenv.1:cStruct.2:BoundsExceeded.3:inx.4(344)"></A><A name="inx.4(344)"></A>: @integer; 
          enter inx
          ...
          #);
        <B>chk</B><A name="betaenv.1:cStruct.2:chk.3(345)"></A><A name="chk.3(345)"></A>: @(# <B>inx</B><A name="betaenv.1:cStruct.2:chk.3:inx.4(346)"></A><A name="inx.4(346)"></A>: @integer enter inx ... #);
     #);
   <B>data</B><A name="betaenv.1:data.2(347)"></A><A name="data.2(347)"></A>:
     (* The 'data' pattern may be used for definining simple data
      * objects.  Data-objects have no 'type' information. They can
      * thus NOT be allocated dynamically in the BETA heap. They do * not have the overhead of extra attributes used for virtual
      * dispatch and garbage collection. One main use of data-objects
      * is as interface to external data such as 'cstruct'.  For
      * details see the manuals
      *)
     (# #);
   <B>doGC</B><A name="betaenv.1:doGC.2(348)"></A><A name="doGC.2(348)"></A>: (* will force a garbage collection to happen *)
     (# ... #);
   <B>machine_type</B><A name="betaenv.1:machine_type.2(349)"></A><A name="machine_type.2(349)"></A>:
     (* Exits a reference to a copy of a text indicating the machine
      * type in lowercase, e.g. 'sun4s', 'linux', 'nti'.
      *)
     (# <B>T</B><A name="betaenv.1:machine_type.2:T.3(350)"></A><A name="T.3(350)"></A>: @Text;
     do machine_typeexternal-&gt;T;
     exit T.copy
     #);
   <B>machine_typeexternal</B><A name="betaenv.1:machine_typeexternal.2(351)"></A><A name="machine_typeexternal.2(351)"></A>: external
     (# <B>T</B><A name="betaenv.1:machine_typeexternal.2:T.3(352)"></A><A name="T.3(352)"></A>: [1]@Char; do 'machine_type'-&gt;callC; exit T #);
   <B>program</B><A name="betaenv.1:program.2(353)"></A><A name="program.2(353)"></A>: (* descriptor executed by this environment *)
     ...;
   <B>theProgram</B><A name="betaenv.1:theProgram.2(354)"></A><A name="theProgram.2(354)"></A>: ^|program;
   <B>theScheduler</B><A name="betaenv.1:theScheduler.2(355)"></A><A name="theScheduler.2(355)"></A>: ^|object
     (* Scheduler installed by 'basicSystemEnv' (if used in program) *);
   (******************************************************************)
   (* The following patterns are only used by the compiler and should
    * NOT be used for other purposes.
    *)
   <B>repetition</B><A name="betaenv.1:repetition.2(356)"></A><A name="repetition.2(356)"></A>: 
     (# <B>range</B><A name="betaenv.1:repetition.2:range.3(357)"></A><A name="range.3(357)"></A>: (* Returns the range of THIS(repetition) *)
          (# n: @integer
          exit n
          #);
        <B>new</B><A name="betaenv.1:repetition.2:new.3(358)"></A><A name="new.3(358)"></A>: 
          (* Allocates a new repetition of 'n' elements. The previous
           * elements in THIS(repetition) become inaccessible
           * hereafter
           *)
          (# n: @integer
          enter n
          #);
        <B>extend</B><A name="betaenv.1:repetition.2:extend.3(359)"></A><A name="extend.3(359)"></A>:
          (* Extends THIS(repetition) by 'n' elements.  The existing
           * elements are retained.  The new elements are allocated
           * after the existing elements (i.e. with index from the
           * 'range+1')
           *)
          (# n: @integer
          enter n
          #)
     #);
   <B>state</B><A name="betaenv.1:state.2(360)"></A><A name="state.2(360)"></A>: (# #); (* Pattern STATE is for experimental purpose only
                  * and using it may give undefined results 
                  *)
   <B>errorName</B><A name="betaenv.1:errorName.2(361)"></A><A name="errorName.2(361)"></A>: (# #)
   
   (******************************************************************)
do ...;
   &amp;|program[]-&gt;theProgram[];
   theProgram;
   (if theScheduler[]&lt;&gt;NONE then theScheduler if);
   ... ;
#)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="33%" align="left"><ADDRESS>Interface Description</ADDRESS></TD>
<TD width="34%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="33%" align="right"><FONT size=-1><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></FONT></TD>
</TABLE>
<P></P>
<A HREF="math.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
