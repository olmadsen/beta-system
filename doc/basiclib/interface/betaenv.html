<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Betaenv Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="math.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Betaenv Interface</H1>
<PRE CLASS=interface>
LIB_DEF 'betaenv' '../lib';
BODY 'private/betaenvbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1984-96
 *       All rights reserved.
 *
 * This fragment implements the very basic patterns, utilized by most
 * BETA programs
 *)
-- betaenv: descriptor --
(# &lt;&lt;SLOT lib: attributes&gt;&gt;;
   (******************************************************************)
   (* The simple patterns for simple values and variables.  These
    * simple patterns are treated special by the compiler.
    *)
   <B>integer</B><A name="ANONYMOUS.1:integer.2(1)"></A><A name="integer.2(1)"></A>: (* 32 bit signed long *) (# #);
   <B>shortInt</B><A name="ANONYMOUS.1:shortInt.2(2)"></A><A name="shortInt.2(2)"></A>: (* 16 bit unsigned half *) (# #); (* do not use shortInt anymore,
                                                * use int16u instead.
                                                *)
   <B>char</B><A name="ANONYMOUS.1:char.2(3)"></A><A name="char.2(3)"></A>: (* 8 bit unsigned byte *) (# #);
   <B>boolean</B><A name="ANONYMOUS.1:boolean.2(4)"></A><A name="boolean.2(4)"></A>: (* 8 bit unsigned byte, values 0 or 1 *) (# #);
   <B>false</B><A name="ANONYMOUS.1:false.2(5)"></A><A name="false.2(5)"></A>: boolean (* 8 bit unsigned byte with value 0 *) (# #);
   <B>true</B><A name="ANONYMOUS.1:true.2(6)"></A><A name="true.2(6)"></A>: boolean (* 8 bit unsigned byte with value 1 *) (# #);
   <B>real</B><A name="ANONYMOUS.1:real.2(7)"></A><A name="real.2(7)"></A>: (* double precision floating point number *) (# #);
   
   <B>int8</B><A name="ANONYMOUS.1:int8.2(8)"></A><A name="int8.2(8)"></A>: (* 8 bit signed integer *) (# #); 
   <B>int8u</B><A name="ANONYMOUS.1:int8u.2(9)"></A><A name="int8u.2(9)"></A>: (* 8 bit unsigned integer *) (# #);
   <B>int16</B><A name="ANONYMOUS.1:int16.2(10)"></A><A name="int16.2(10)"></A>: (* 16 bit signed integer *) (# #);
   <B>int16u</B><A name="ANONYMOUS.1:int16u.2(11)"></A><A name="int16u.2(11)"></A>: (* 16 bit unsigned integer.
            * int16u will eventually replace shortInt *) (# #);
   <B>int32</B><A name="ANONYMOUS.1:int32.2(12)"></A><A name="int32.2(12)"></A>: (* 32 bit signed integer
           * int32 is semantically identical to integer *) (# #);
   <B>int32u</B><A name="ANONYMOUS.1:int32u.2(13)"></A><A name="int32u.2(13)"></A>: (* 32 bit unsigned integer *) (# #);
   
   (* int64 and int64u are NOT yet implemented;
    * the compiler allows variables of these types,
    * but no operations, including assignment,
    * are implemented, so don't use them.
    *)
   <B>int64</B><A name="ANONYMOUS.1:int64.2(14)"></A><A name="int64.2(14)"></A>: (* 64 bit signed integer *) (# #); 
   <B>int64u</B><A name="ANONYMOUS.1:int64u.2(15)"></A><A name="int64u.2(15)"></A>: (* 64 bit unsigned integer *) (# #);
   
   (* The pattern wchar is for experimenting with implementing
    * support for the UniCode character set. The name wchar
    * is preliminary. wchar is semantically identical to int16u.
    * Patterns wcharValue and wcharObject have also been introduced below
    *)
   <B>wchar</B><A name="ANONYMOUS.1:wchar.2(16)"></A><A name="wchar.2(16)"></A>: (# #); (* 16 bit unsigend integer *)
   
   (* The pattern COM is for experimenting with implementation
    * of COM support in BETA
    *)
   <B>COM</B><A name="ANONYMOUS.1:COM.2(17)"></A><A name="COM.2(17)"></A>: (# #); (* General super pattern for COM objects *)
   
   (* Holder is general superpattern for holder-patterns used for 
    * parameters in COM.
    *)
   <B>Holder</B><A name="ANONYMOUS.1:Holder.2(18)"></A><A name="Holder.2(18)"></A>: (# adr: @integer #);  
   
   <B>object</B><A name="ANONYMOUS.1:object.2(19)"></A><A name="object.2(19)"></A>: (* General superpattern *)
     (# _struc: 
          (* Exit a pattern reference for THIS(Object).
           * Is now obsolete: the new form obj## is preferred
           * to the old form obj.struc
           *)
          (#
          exit this(object)##
          #);
        _new: 
          (* returns a new object, that is qualified exactly
           * as THIS(object)
           *)
          (# newObj: ^object; oType: ##object
          do this(object)##-&gt;oType##; &amp;oType[]-&gt;newObj[]; INNER _new
          exit newObj[]
          #);
        _state: 
          (* Pattern _state is for experimental purpose only
           * and using it may give undefined results 
           *)
          (# S: ##object
          enter S##
          ...
          #)
     do INNER object
     #);
   
   (* The following patterns define 'real' patterns corresponding to
    * the predefined simple patterns
    *)
   <B>integerValue</B><A name="ANONYMOUS.1:integerValue.2(20)"></A><A name="integerValue.2(20)"></A>: (# value: @integer do INNER integerValue exit value #);
   <B>integerObject</B><A name="ANONYMOUS.1:integerObject.2(21)"></A><A name="integerObject.2(21)"></A>: integerValue(# enter value do INNER integerObject #);
   <B>charValue</B><A name="ANONYMOUS.1:charValue.2(22)"></A><A name="charValue.2(22)"></A>: (# value: @char do INNER charValue exit value #);
   <B>charObject</B><A name="ANONYMOUS.1:charObject.2(23)"></A><A name="charObject.2(23)"></A>: charValue(# enter value do INNER charObject #);
   <B>wcharValue</B><A name="ANONYMOUS.1:wcharValue.2(24)"></A><A name="wcharValue.2(24)"></A>: (# value: @wchar do INNER wcharValue exit value #);
   <B>wcharObject</B><A name="ANONYMOUS.1:wcharObject.2(25)"></A><A name="wcharObject.2(25)"></A>: wcharValue(# enter value do INNER wcharObject #);
   <B>booleanValue</B><A name="ANONYMOUS.1:booleanValue.2(26)"></A><A name="booleanValue.2(26)"></A>: (# value: @boolean do INNER booleanValue exit value #);
   <B>booleanObject</B><A name="ANONYMOUS.1:booleanObject.2(27)"></A><A name="booleanObject.2(27)"></A>: booleanValue(# enter value do INNER booleanObject #);
   <B>trueObject</B><A name="ANONYMOUS.1:trueObject.2(28)"></A><A name="trueObject.2(28)"></A>: booleanObject(# do true-&gt;value; INNER trueObject #);
   <B>falseObject</B><A name="ANONYMOUS.1:falseObject.2(29)"></A><A name="falseObject.2(29)"></A>: booleanObject(# do INNER falseObject #);
   <B>realValue</B><A name="ANONYMOUS.1:realValue.2(30)"></A><A name="realValue.2(30)"></A>: (# value: @real do INNER realValue exit value #);
   <B>realObject</B><A name="ANONYMOUS.1:realObject.2(31)"></A><A name="realObject.2(31)"></A>: realValue(# enter value do INNER realObject #);
   
   (****  Integer limits *********************************************) 
   <B>MaxInt8</B><A name="ANONYMOUS.1:MaxInt8.2(32)"></A><A name="MaxInt8.2(32)"></A>:   (# exit 0x7f #);
   <B>MinInt8</B><A name="ANONYMOUS.1:MinInt8.2(33)"></A><A name="MinInt8.2(33)"></A>:   (# exit 0x80 #);
   <B>MaxInt8u</B><A name="ANONYMOUS.1:MaxInt8u.2(34)"></A><A name="MaxInt8u.2(34)"></A>:  (# exit 0xff #);
   <B>MinInt8u</B><A name="ANONYMOUS.1:MinInt8u.2(35)"></A><A name="MinInt8u.2(35)"></A>:  (# exit 0x00 #);
   
   <B>MaxInt16</B><A name="ANONYMOUS.1:MaxInt16.2(36)"></A><A name="MaxInt16.2(36)"></A>:  (# exit 0x7fff #);
   <B>MinInt16</B><A name="ANONYMOUS.1:MinInt16.2(37)"></A><A name="MinInt16.2(37)"></A>:  (# exit 0x8000 #);
   <B>MaxInt16u</B><A name="ANONYMOUS.1:MaxInt16u.2(38)"></A><A name="MaxInt16u.2(38)"></A>: (# exit 0xffff #);
   <B>MinInt16u</B><A name="ANONYMOUS.1:MinInt16u.2(39)"></A><A name="MinInt16u.2(39)"></A>: (# exit 0x0000 #);
   
   <B>MaxInt32</B><A name="ANONYMOUS.1:MaxInt32.2(40)"></A><A name="MaxInt32.2(40)"></A>:  (# exit 0x7fffffff #);
   <B>MinInt32</B><A name="ANONYMOUS.1:MinInt32.2(41)"></A><A name="MinInt32.2(41)"></A>:  (# exit 0x80000000 #);
   <B>MaxInt32u</B><A name="ANONYMOUS.1:MaxInt32u.2(42)"></A><A name="MaxInt32u.2(42)"></A>: (# exit 0xffffffff #);
   <B>MinInt32u</B><A name="ANONYMOUS.1:MinInt32u.2(43)"></A><A name="MinInt32u.2(43)"></A>: (# exit 0x00000000 #);
   
   <B>MaxInt</B><A name="ANONYMOUS.1:MaxInt.2(44)"></A><A name="MaxInt.2(44)"></A>:    (# exit MaxInt32 #);
   <B>MinInt</B><A name="ANONYMOUS.1:MinInt.2(45)"></A><A name="MinInt.2(45)"></A>:    (# exit MinInt32 #);
   
   <B>MaxReal</B><A name="ANONYMOUS.1:MaxReal.2(46)"></A><A name="MaxReal.2(46)"></A>:   (# exit 1.797693134862315E+308 #);
   <B>MinReal</B><A name="ANONYMOUS.1:MinReal.2(47)"></A><A name="MinReal.2(47)"></A>:   (# exit 2.225073858507201E-308 #);

   (****  Implementation dependent constants *************************) 
   <B>infReal</B><A name="ANONYMOUS.1:infReal.2(48)"></A><A name="infReal.2(48)"></A>: (* Returns the real value 'Infinity' *)
     realValue(# ... #);
   
   (*****  Functional patterns ***************************************)
   <B>min</B><A name="ANONYMOUS.1:min.2(49)"></A><A name="min.2(49)"></A>: (* Returns the minimum of 2 integers *)
     (# a,b: @integer
     enter (a,b)
     do (if (a &lt; b) then a-&gt;b if)
     exit b
     #);
   <B>max</B><A name="ANONYMOUS.1:max.2(50)"></A><A name="max.2(50)"></A>: (* Returns the maximum of 2 integers *)
     (# a,b: @integer
     enter (a,b)
     do (if (a &lt; b) then b-&gt;a if)
     exit a
     #);
   <B>abs</B><A name="ANONYMOUS.1:abs.2(51)"></A><A name="abs.2(51)"></A>: (* Returns the absolute value of an integer *)
     (# n: @integer
     enter n
     do (if (n &lt; 0) then -n-&gt;n if)
     exit n
     #);
   
   (*****  Simple standard input/output patterns *********************)
   <B>keyboard</B><A name="ANONYMOUS.1:keyboard.2(52)"></A><A name="keyboard.2(52)"></A>,<B> screen</B><A name="ANONYMOUS.1:screen.2(53)"></A><A name="screen.2(53)"></A>: ^stream;
   <B>get</B><A name="ANONYMOUS.1:get.2(54)"></A><A name="get.2(54)"></A>:
     (# ch: @char; getC: @keyboard.get do getC-&gt;ch; INNER get exit ch #);
   <B>put</B><A name="ANONYMOUS.1:put.2(55)"></A><A name="put.2(55)"></A>:
     (# ch: @char; putC: @screen.put enter ch do INNER put; ch-&gt;putC #);
   <B>newline</B><A name="ANONYMOUS.1:newline.2(56)"></A><A name="newline.2(56)"></A>:
     screen.newline(# #);
   <B>putint</B><A name="ANONYMOUS.1:putint.2(57)"></A><A name="putint.2(57)"></A>:
     screen.putint(# do INNER putint #);
   <B>getint</B><A name="ANONYMOUS.1:getint.2(58)"></A><A name="getint.2(58)"></A>:
     keyBoard.getint(# do INNER getint #);
   <B>puttext</B><A name="ANONYMOUS.1:puttext.2(59)"></A><A name="puttext.2(59)"></A>:
     (# t: ^text; putT: @screen.puttext
     enter t[]
     do INNER puttext; t[]-&gt;putT
     #);
   <B>putline</B><A name="ANONYMOUS.1:putline.2(60)"></A><A name="putline.2(60)"></A>:
     screen.putline(# do INNER putline #);
   <B>getNonBlank</B><A name="ANONYMOUS.1:getNonBlank.2(61)"></A><A name="getNonBlank.2(61)"></A>:
     keyBoard.getNonBlank(# do INNER getNonBlank #);
   <B>scanAtom</B><A name="ANONYMOUS.1:scanAtom.2(62)"></A><A name="scanAtom.2(62)"></A>:
     keyBoard.scanAtom(# do INNER scanAtom #);
   <B>getAtom</B><A name="ANONYMOUS.1:getAtom.2(63)"></A><A name="getAtom.2(63)"></A>:
     (# t: ^text; getA: @keyBoard.getAtom
     do getA-&gt;t[]; INNER getAtom
     exit t[]
     #);
   <B>getline</B><A name="ANONYMOUS.1:getline.2(64)"></A><A name="getline.2(64)"></A>:
     (# t: ^text; getL: @keyBoard.getline
     do getL-&gt;t[]; INNER getline
     exit t[]
     #);
   
   (*****  Control patterns ******************************************)
   <B>forTo</B><A name="ANONYMOUS.1:forTo.2(65)"></A><A name="forTo.2(65)"></A>: (* for 'inx' in [low:high] do INNER forTo *)
     (# low, high, inx: @integer;
     enter (low, high)
     ...  
     #);
   <B>cycle</B><A name="ANONYMOUS.1:cycle.2(66)"></A><A name="cycle.2(66)"></A>: (* Executes INNER forever *)
     (# ... #);
   <B>loop</B><A name="ANONYMOUS.1:loop.2(67)"></A><A name="loop.2(67)"></A>: 
     (# <B>while</B><A name="ANONYMOUS.1:loop.2:while.3(68)"></A><A name="while.3(68)"></A>:&lt; booleanValue(# do true-&gt;value; INNER while #);
        <B>until</B><A name="ANONYMOUS.1:loop.2:until.3(69)"></A><A name="until.3(69)"></A>:&lt; booleanValue;
        <B>whilecondition</B><A name="ANONYMOUS.1:loop.2:whilecondition.3(70)"></A><A name="whilecondition.3(70)"></A>: @while;
        <B>untilcondition</B><A name="ANONYMOUS.1:loop.2:untilcondition.3(71)"></A><A name="untilcondition.3(71)"></A>: @until;
     ...
     #);
   <B>qua</B><A name="ANONYMOUS.1:qua.2(72)"></A><A name="qua.2(72)"></A>:
     (* Pattern replacing the BETA language construct QUA.  To be
      * used as 't1[]-&gt;qua(# as::&lt; Tn #)-&gt;t2[]'.  The 'qua' pattern
      * checks, whether 't1' is qualified by 'Tn'.  If not, the
      * 'quaError' exception is invoked.  Otherwise, a reference
      * qualified by 'Tn', and referring to the same object as 't1[]'
      * is referring, is returned.
      *)
     (# <B>as</B><A name="ANONYMOUS.1:qua.2:as.3(73)"></A><A name="as.3(73)"></A>:&lt; object; <B>R</B><A name="ANONYMOUS.1:qua.2:R.3(74)"></A><A name="R.3(74)"></A>: ^object; <B>thisObj</B><A name="ANONYMOUS.1:qua.2:thisObj.3(75)"></A><A name="thisObj.3(75)"></A>: ^as;
        <B>quaError</B><A name="ANONYMOUS.1:qua.2:quaError.3(76)"></A><A name="quaError.3(76)"></A>:&lt; exception
          (# do 'Qualification error'-&gt;msg.append; INNER quaError #)
     enter R[]
     ...  
     exit thisObj[]
     #);
   
   (*****  Stream patterns *******************************************)
   <B>stream</B><A name="ANONYMOUS.1:stream.2(77)"></A><A name="stream.2(77)"></A>: 
     (# &lt;&lt;SLOT streamLib: attributes&gt;&gt;;
        <B>length</B><A name="ANONYMOUS.1:stream.2:length.3(78)"></A><A name="length.3(78)"></A>:&lt; integerValue (* returns the length of THIS(stream) *)
          (#
          do -1-&gt;value; INNER length
          #);
        <B>position</B><A name="ANONYMOUS.1:stream.2:position.3(79)"></A><A name="position.3(79)"></A>: (* current position of THIS(stream) *)
          (# 
          enter setPos
          exit getPos
          #);
        <B>eos</B><A name="ANONYMOUS.1:stream.2:eos.3(80)"></A><A name="eos.3(80)"></A>:&lt; (* returns 'true' if THIS(stream) is at end-of-stream *)
          booleanValue;
        <B>reset</B><A name="ANONYMOUS.1:stream.2:reset.3(81)"></A><A name="reset.3(81)"></A>: (* sets 'position' to zero *)
          (#
          do 0-&gt;setPos
          exit THIS(stream)[]
          #);
        <B>peek</B><A name="ANONYMOUS.1:stream.2:peek.3(82)"></A><A name="peek.3(82)"></A>:&lt; (* looks at the next character of THIS(stream) *)
          (# ch: @char
          do INNER peek
          exit ch
          #);
        <B>get</B><A name="ANONYMOUS.1:stream.2:get.3(83)"></A><A name="get.3(83)"></A>:&lt; (* reads a character from THIS(stream) *)
          (# ch: @char
          do INNER get
          exit ch
          #);
        <B>getNonBlank</B><A name="ANONYMOUS.1:stream.2:getNonBlank.3(84)"></A><A name="getNonBlank.3(84)"></A>: 
          (* Reads first non-whitespace character from THIS(stream).
           * If called at end-of-stream the character 'ascii.fs' is
           * returned
           *)
          (# ch: @char;
             skipblanks: @scanWhiteSpace;
             testEOS: @EOS;
             getCh: @get;
          ...
          exit ch
          #);
        <B>getint</B><A name="ANONYMOUS.1:stream.2:getint.3(85)"></A><A name="getint.3(85)"></A>: integerValue
          (* Reads an integer: skips whitespace characters and
           * returns the following digits.
           * 
           * See numberio.bet for more numerical output operations
           *)
          (# syntaxError:&lt; streamException
               (# 
               ...
               #);
             geti: @... 
          do geti; INNER getint
          #);
        <B>getAtom</B><A name="ANONYMOUS.1:stream.2:getAtom.3(86)"></A><A name="getAtom.3(86)"></A>:&lt;
          (* Returns the next atom (i.e. sequence of non-white
           * characters - skipping leading blanks)
           *)
          (# txt: ^text;
          do &amp;text[]-&gt;txt[]; INNER getAtom;
          exit txt[]
          #);
        <B>getline</B><A name="ANONYMOUS.1:stream.2:getline.3(87)"></A><A name="getline.3(87)"></A>:&lt;
          (* Reads a sequence of characters until nl-character
           * appears and returns the characters read.
           *)
          (# txt: ^text;
          do &amp;text[]-&gt;txt[]; INNER getline
          exit txt[]
          #);
        <B>asInt</B><A name="ANONYMOUS.1:stream.2:asInt.3(88)"></A><A name="asInt.3(88)"></A>:
          (* converts THIS(text) to an integer value, ignoring
           * leading and trailing whitespace.  See numberio.bet for
           * more numerical conversion operations.
           *)
          (# i: @integer;
             syntaxError:&lt; streamException
               (# peekCh: @char
               enter peekCh
               do 'asInt: syntax error - looking at: "'-&gt;msg.append;
                  peekCh-&gt;msg.put; '"'-&gt;msg.put;
                  INNER syntaxError
               #)
          ...
          exit i
          #);
        <B>put</B><A name="ANONYMOUS.1:stream.2:put.3(89)"></A><A name="put.3(89)"></A>:&lt; (* writes a character to THIS(stream) *)
          (# ch: @char
          enter ch
          do INNER put
          exit THIS(stream)[]
          #);
        <B>newline</B><A name="ANONYMOUS.1:stream.2:newline.3(90)"></A><A name="newline.3(90)"></A>: (* writes the nl-character *) 
          (#
          do ascii.newline-&gt;put
          exit THIS(stream)[]
          #);
        <B>putint</B><A name="ANONYMOUS.1:stream.2:putint.3(91)"></A><A name="putint.3(91)"></A>: 
          (* Writes an integer to THIS(stream); The format may be
           * controlled by the 'signed', 'blankSign', 'width',
           * 'adjustLeft' and 'zeroPadding' variable attributes.
           * 'width' is extended if it is too small.  Examples:
           * '10-&gt;putint' yields: '10'; '10*pi-&gt;putint(# do 10-&gt;width;
           * true-&gt;adjustLeft #)' yields: '10 '; and '10-&gt;putint(# do * 10-&gt;width; true-&gt;zeroPadding #)' yields: '0000000010'.
           * 
           * See numberio.bet for more numerical output operations
           *)
          (# n: @integer;
             signed: @boolean
               (* If integer is positive, a '+' will always be
                * displayed
                *);
             blankSign: @boolean 
               (* If integer is positive, a ' ' space is displayed as
                * the sign.  Ignored if 'signed=true'
                *);
             width: @integer
               (* Minimum width *);
             adjustLeft: @boolean
               (* Specifies if the number is to be aligned left or
                * right, if padding of spaces is necessary to fill up
                * the specified width.
                *);
             zeroPadding: @boolean
               (* width is padded with leading zero instead of
                * spaces.  Ignored if 'adjustLeft=true'
                *);
             format:&lt; (# do INNER format #);
             puti: @...
          enter n
          do 1-&gt;width; format; INNER putint; puti
          exit THIS(stream)[]
          #);
        <B>puttext</B><A name="ANONYMOUS.1:stream.2:puttext.3(92)"></A><A name="puttext.3(92)"></A>:&lt; (* Writes a text to THIS(stream). *)
          (# txt: ^text
          enter txt[]
          do (if txt[]&lt;&gt;NONE then INNER puttext if)
          exit THIS(stream)[]
          #);
        <B>putline</B><A name="ANONYMOUS.1:stream.2:putline.3(93)"></A><A name="putline.3(93)"></A>: 
          (* 'puttext' followed by 'newline' *)
          (# T: ^text; putT: @puttext; newL: @newline
          enter T[]
          do INNER putline; T[]-&gt;putT; newL
          exit THIS(stream)[]
          #);
        <B>scan</B><A name="ANONYMOUS.1:stream.2:scan.3(94)"></A><A name="scan.3(94)"></A>: 
          (* Scan chars from current position in THIS(stream) while
           * '(ch-&gt;while)=true'; perform INNER for each char being
           * scanned
           *)
          (# while:&lt;
               (# ch: @char; value: @boolean
               enter ch
               do true-&gt;value; INNER while
               exit value
               #);
             ch: @char;
             whilecondition: @while;
             testEOS: @EOS;
             getPeek: @peek;
             getCh: @get;
          ...
          exit THIS(stream)[]
          #);
        <B>scanWhiteSpace</B><A name="ANONYMOUS.1:stream.2:scanWhiteSpace.3(95)"></A><A name="scanWhiteSpace.3(95)"></A>: scan 
          (* Scan whitespace characters *)
          (# while::&lt; (# do ch-&gt;ascii.isWhiteSpace-&gt;value #);
          do INNER scanWhiteSpace
          exit THIS(stream)[]
          #);
        <B>scanAtom</B><A name="ANONYMOUS.1:stream.2:scanAtom.3(96)"></A><A name="scanAtom.3(96)"></A>: 
          (* Scan until first non-whitespace char.  Scan the next
           * sequence of non-whitespace chars.  Stop at first
           * whitespace char.  For each non-whitespace char an INNER
           * is performed. Usage: 'scanAtom(# do ch-&gt;&lt;destination&gt; #)'
           *)
          (# ch: @char;
          ...
          exit THIS(stream)[]
          #);
        <B>scanToNl</B><A name="ANONYMOUS.1:stream.2:scanToNl.3(97)"></A><A name="scanToNl.3(97)"></A>: 
          (* Scan all chars in current line including newline char *)
          (# ch: @char; getCh: @get;
          ...
          exit THIS(stream)[]
          #);
        <B>streamException</B><A name="ANONYMOUS.1:stream.2:streamException.3(98)"></A><A name="streamException.3(98)"></A>: exception
          (# do INNER streamException #);
        <B>EOSerror</B><A name="ANONYMOUS.1:stream.2:EOSerror.3(99)"></A><A name="EOSerror.3(99)"></A>:&lt; streamException
          (* Raised from 'get' and 'peek' when attempted to read past
           * the end of the stream.
           *)
          (# 
          do 'Attempt to read past end-of-stream'-&gt;msg.putline; 
             INNER EOSerror
          #);
        <B>otherError</B><A name="ANONYMOUS.1:stream.2:otherError.3(100)"></A><A name="otherError.3(100)"></A>:&lt; streamException
          (* Raised when some other kind of stream error apart from
           * the one mentioned above occurs.
           *);
        <B>getPos</B><A name="ANONYMOUS.1:stream.2:getPos.3(101)"></A><A name="getPos.3(101)"></A>:&lt; (* returns current position of THIS(Stream) *)
          integerValue;
        <B>setPos</B><A name="ANONYMOUS.1:stream.2:setPos.3(102)"></A><A name="setPos.3(102)"></A>:&lt; (* sets current position in THIS(stream) to 'p' *)
          (# p: @integer
          enter p
          do INNER setPos
          exit THIS(stream)[]
          #)
     #); (* pattern stream *)
   
   (*****  Text pattern **********************************************)
   <B>text</B><A name="ANONYMOUS.1:text.2(103)"></A><A name="text.2(103)"></A>: stream
     (* A text is a sequence of characters.  Let 'T: @text'. The
      * range of 'T' is '[1,T.length]'.  A text can be initialized by
      * executing 'T.clear' or by assigning it another (initialized)
      * text.  A text-constant has the form 'foo'.  The 'text' pattern
      * is primarily intended for small texts but there is no upper
      * limit in the size. However, most of the operations becomes
      * less efficient with larger texts.
      *)
     (# &lt;&lt;SLOT textLib: attributes&gt;&gt;;
        <B>length</B><A name="ANONYMOUS.1:text.2:length.3(104)"></A><A name="length.3(104)"></A>::&lt; (* Returns the length of THIS(text) *) 
          (# do lgth-&gt;value; INNER length #);
        <B>eos</B><A name="ANONYMOUS.1:text.2:eos.3(105)"></A><A name="eos.3(105)"></A>::&lt;(# ... #);
        <B>empty</B><A name="ANONYMOUS.1:text.2:empty.3(106)"></A><A name="empty.3(106)"></A>: 
          (# exit (lgth = 0) #);
        <B>clear</B><A name="ANONYMOUS.1:text.2:clear.3(107)"></A><A name="clear.3(107)"></A>: (* Sets the length and position of THIS(text) to zero *)
          (#
          do 0-&gt;pos-&gt;lgth
          exit THIS(text)[]
          #);
        <B>equal</B><A name="ANONYMOUS.1:text.2:equal.3(108)"></A><A name="equal.3(108)"></A>: booleanValue
          (* Tests if THIS(text) is equal to the entered text.  If
           * 'NCS' is further bound to 'trueObject', the comparison
           * will be done Non Case Sensitive.
           *)
          (# txt: ^text;
             NCS:&lt; booleanObject
          enter txt[]
          ...
          #);
        <B>equalNCS</B><A name="ANONYMOUS.1:text.2:equalNCS.3(109)"></A><A name="equalNCS.3(109)"></A>: equal
          (* As 'equal', except the the comparison will be done Non
           * Case Sensitive
           *)
          (# NCS:: trueObject #);
        <B>less</B><A name="ANONYMOUS.1:text.2:less.3(110)"></A><A name="less.3(110)"></A>: booleanValue
          (* Tests whether the entered text 'T1[1: length]' is less
           * than 'THIS(text)[1: T1.length]'.  The lexicographical
           * ordering is used.
           *)
          (# T1: ^text
          enter T1[]
          ...
          #);
        <B>greater</B><A name="ANONYMOUS.1:text.2:greater.3(111)"></A><A name="greater.3(111)"></A>: booleanValue
          (* Tests whether the entered text 'T1[1: length]' is
           * greater than 'THIS(text)[1: T1.length]'.  The
           * lexicographical ordering is used.
           *)
          (# T1: ^text
          enter T1[]
          ...
          #);
        <B>peek</B><A name="ANONYMOUS.1:text.2:peek.3(112)"></A><A name="peek.3(112)"></A>::&lt;
          (* Returns the character at current position; does not
           * update 'position'
           *)
          (# ... #);
        <B>get</B><A name="ANONYMOUS.1:text.2:get.3(113)"></A><A name="get.3(113)"></A>::&lt;
          (* Returns the character at current position; increments
           * 'position'
           *) 
          (# ... #);
        <B>inxGet</B><A name="ANONYMOUS.1:text.2:inxGet.3(114)"></A><A name="inxGet.3(114)"></A>: charValue
          (* Returns the character at position 'i' *)
          (# i: @integer;
             iget: @...
          enter i
          do iget
          #);
        <B>getAtom</B><A name="ANONYMOUS.1:text.2:getAtom.3(115)"></A><A name="getAtom.3(115)"></A>::&lt;
          (* Returns the next atom (i.e. sequence of non-white
           * characters - skipping leading blanks)
           *)
          (# ... #);
        <B>getline</B><A name="ANONYMOUS.1:text.2:getline.3(116)"></A><A name="getline.3(116)"></A>::&lt;
          (* Reads a sequence of characters until nl-character
           * appears and returns the characters read.
           *)
          (# ... #);
        <B>put</B><A name="ANONYMOUS.1:text.2:put.3(117)"></A><A name="put.3(117)"></A>::&lt;
          (* writes the character 'ch' at current position in
           * THIS(text); increments 'position'
           *) 
          (# ... #);
        <B>inxPut</B><A name="ANONYMOUS.1:text.2:inxPut.3(118)"></A><A name="inxPut.3(118)"></A>: 
          (* Replaces the character at position 'i' *)
          (# ch: @char;
             i: @integer;
             iput: @...
          enter (ch,i)
          do iput
          exit THIS(text)[]
          #);
        <B>puttext</B><A name="ANONYMOUS.1:text.2:puttext.3(119)"></A><A name="puttext.3(119)"></A>::&lt;(# ... #);
        <B>append</B><A name="ANONYMOUS.1:text.2:append.3(120)"></A><A name="append.3(120)"></A>: 
          (* Appends a text to THIS(text); does not change 'position'
           *)
          (# T1: ^text
          enter T1[]
          ...
          exit THIS(text)[]
          #);
        <B>prepend</B><A name="ANONYMOUS.1:text.2:prepend.3(121)"></A><A name="prepend.3(121)"></A>: 
          (* Inserts the text in 'T1' in front of THIS(text); updates
           * current position to 'position+T1.length' if 'position&gt;0'
           *)
          (# T1: ^text
          enter T1[]
          ...
          exit THIS(text)[]
          #);
        <B>insert</B><A name="ANONYMOUS.1:text.2:insert.3(122)"></A><A name="insert.3(122)"></A>: 
          (* Inserts a text before the character at position 'inx'.
           * Note: inx&lt;1 means inx=1; inx&gt;length means inx=length+1.
           * If 'position&gt;=inx' then 'position+T1.length-&gt;position'.
           *)
          (# T1: ^text;
             inx: @integer
          enter (T1[],inx)
          ...
          exit THIS(text)[]
          #);
        <B>delete</B><A name="ANONYMOUS.1:text.2:delete.3(123)"></A><A name="delete.3(123)"></A>: 
          (* Deletes THIS(text)[i: j]; updates current position:
           *      i&lt;=position&lt;j =&gt; i-1-&gt;position
           *      j&lt;=position   =&gt; position-(j-i+1)-&gt;position
           *)
          (# i,j: @integer; 
             deleteT: @...
          enter (i,j)
          do deleteT
          exit THIS(text)[]
          #);
        <B>makeLC</B><A name="ANONYMOUS.1:text.2:makeLC.3(124)"></A><A name="makeLC.3(124)"></A>: (* Converts all characters to lower case *)
          (# ...
          exit THIS(text)[]
          #);
        <B>makeUC</B><A name="ANONYMOUS.1:text.2:makeUC.3(125)"></A><A name="makeUC.3(125)"></A>: 
          (* Converts all characters to upper case *)
          (# ...
          exit THIS(text)[]
          #);
        <B>sub</B><A name="ANONYMOUS.1:text.2:sub.3(126)"></A><A name="sub.3(126)"></A>:
          (* Returns a copy of THIS(text)[i:j].  If 'i&lt;1', 'i' is
           * adjusted to 1. If 'j&gt;length', 'j' is adjusted to
           * 'length'.  If (after adjustment) 'i&gt;j', an empty text is
           * returned.
           *)
          (# i,j: @integer; T1: ^text;
             subI: @...
          enter (i,j)
          do subI
          exit T1[]
          #);
        <B>copy</B><A name="ANONYMOUS.1:text.2:copy.3(127)"></A><A name="copy.3(127)"></A>: 
          (# T1: ^text;
             copyI: @...
          do copyI
          exit T1[]
          #);
        <B>scanAll</B><A name="ANONYMOUS.1:text.2:scanAll.3(128)"></A><A name="scanAll.3(128)"></A>: 
          (* Scans all the elements in THIS(text).  For 'ch' in '[1:
           * THIS(text).length]' do INNER
           *)
          (# ch: @char
          do (for i: lgth repeat T[i]-&gt;ch; INNER scanAll for)
          exit THIS(text)[]
          #);
        <B>find</B><A name="ANONYMOUS.1:text.2:find.3(129)"></A><A name="find.3(129)"></A>:
          (* find all occurrences of the character 'ch' in
           * THIS(text), executing INNER for each occurrence found,
           * beginning at 'THIS(text).position'.  'inx' will contain
           * the position of each 'ch' in THIS(text).  If 'NCS' is
           * further bound to 'trueObject', the comparison will be
           * done Non Case Sensitive.  If 'from' is further bound, the
           * search will begin at position 'from'.
           *)
          (# ch: @char;
             inx: @integer;
             NCS:&lt; booleanObject;
             from:&lt; integerObject(# do pos-&gt;value; INNER from #)
          enter ch
          ...
          exit THIS(text)[]
          #);
        <B>findAll</B><A name="ANONYMOUS.1:text.2:findAll.3(130)"></A><A name="findAll.3(130)"></A>: find
          (* As 'find', except that the entire text will be searched.
           * Replaces 'findCh' in previous versions of betaenv (v1.4
           * and earlier)
           *)
          (# from:: (# do 0-&gt;value #)
          do INNER findAll
          #);
        <B>findText</B><A name="ANONYMOUS.1:text.2:findText.3(131)"></A><A name="findText.3(131)"></A>:
          (* find all occurrences of the 'txt' in THIS(text),
           * executing INNER for each occurrence found, beginning at
           * 'THIS(text).position'.  'inx' will contain the position
           * of the first character of each occurrence found
           * THIS(text).  If 'NCS' is further bound to 'trueObject',
           * the comparison will be done Non Case Sensitive.  If
           * 'from' is further bound, the search will begin at
           * position 'from'.
           *)
          (# txt: ^text;
             inx: @integer;
             NCS:&lt; booleanObject;
             from:&lt; integerObject(# do pos-&gt;value; INNER from #)
          enter txt[]
          ...
          exit THIS(text)[]
          #);
        <B>findTextAll</B><A name="ANONYMOUS.1:text.2:findTextAll.3(132)"></A><A name="findTextAll.3(132)"></A>: findText
          (* As 'findText', except that the entire text will be
           * searched
           *)
          (# from:: (# do 0-&gt;value #)
          do INNER findTextAll
          #);
        <B>extend</B><A name="ANONYMOUS.1:text.2:extend.3(133)"></A><A name="extend.3(133)"></A>: 
          (* Extend THIS(text) with 'L' (undefined) chars. Notice
           * that it is only the representation of the THIS(text),
           * that is extended, the 'length' and 'position' are not
           * changed.
           *)
          (# L: @integer
          enter L do L-&gt;T.extend
          exit THIS(text)[]
          #);
        <B>indexError</B><A name="ANONYMOUS.1:text.2:indexError.3(134)"></A><A name="indexError.3(134)"></A>:&lt; streamException
          (* Raised from 'Check' when the index goes outside the
           * range of the text. Message: "Index error in text!".
           *)
          (# inx: @integer 
          enter inx
          ...
          #);
        <B>EOSerror</B><A name="ANONYMOUS.1:text.2:EOSerror.3(135)"></A><A name="EOSerror.3(135)"></A>::&lt;
          (* Raised from 'get' and 'peek' when the end of the stream is
           * passed.
           *) 
          (# ... #);
        <B>otherError</B><A name="ANONYMOUS.1:text.2:otherError.3(136)"></A><A name="otherError.3(136)"></A>::&lt;
          (* Raised when an error other than the Index-/EOSerror
           * occurs.
           *) 
          (# ... #);
        <B>setPos</B><A name="ANONYMOUS.1:text.2:setPos.3(137)"></A><A name="setPos.3(137)"></A>::&lt;(# ... #);
        <B>getPos</B><A name="ANONYMOUS.1:text.2:getPos.3(138)"></A><A name="getPos.3(138)"></A>::&lt;(# do pos-&gt;value; INNER getPos #);
        (* Private attributes: !!OBS!! The 3 attributes 'T', 'lgth'
         * and 'pos' declared below MUST be the first data items
         * declared in 'stream' and 'text' since their addresses are
         * hardcoded into the compiler.
         *)
        <B>T</B><A name="ANONYMOUS.1:text.2:T.3(139)"></A><A name="T.3(139)"></A>: [16] @char;
        <B>lgth</B><A name="ANONYMOUS.1:text.2:lgth.3(140)"></A><A name="lgth.3(140)"></A>,<B>pos</B><A name="ANONYMOUS.1:text.2:pos.3(141)"></A><A name="pos.3(141)"></A>: (* 16 is default size *) @integer;
        <B>setT</B><A name="ANONYMOUS.1:text.2:setT.3(142)"></A><A name="setT.3(142)"></A>: (# enter T do T.range-&gt;lgth-&gt;pos #)
     enter setT
     exit T[1<A name="ANONYMOUS.1:text.2:1.3(143)"></A><A name="1.3(143)"></A>: lgth]
     #) (* Pattern text *); 
   
   (*****  ASCII character constants and attributes ******************)
   <B>ascii</B><A name="ANONYMOUS.1:ascii.2(144)"></A><A name="ascii.2(144)"></A>: @
     (# &lt;&lt;SLOT asciiLib: attributes&gt;&gt;;
        <B>nul</B><A name="ANONYMOUS.1:ascii.2:nul.3(145)"></A><A name="nul.3(145)"></A>: (# exit 0 #);
        <B>soh</B><A name="ANONYMOUS.1:ascii.2:soh.3(146)"></A><A name="soh.3(146)"></A>: (# exit 1 #);
        <B>stx</B><A name="ANONYMOUS.1:ascii.2:stx.3(147)"></A><A name="stx.3(147)"></A>: (# exit 2 #);
        <B>etx</B><A name="ANONYMOUS.1:ascii.2:etx.3(148)"></A><A name="etx.3(148)"></A>: (# exit 3 #);
        <B>eot</B><A name="ANONYMOUS.1:ascii.2:eot.3(149)"></A><A name="eot.3(149)"></A>: (# exit 4 #);
        <B>enq</B><A name="ANONYMOUS.1:ascii.2:enq.3(150)"></A><A name="enq.3(150)"></A>: (# exit 5 #);
        <B>ack</B><A name="ANONYMOUS.1:ascii.2:ack.3(151)"></A><A name="ack.3(151)"></A>: (# exit 6 #);
        <B>bel</B><A name="ANONYMOUS.1:ascii.2:bel.3(152)"></A><A name="bel.3(152)"></A>: (# exit 7 #);
        <B>bs</B><A name="ANONYMOUS.1:ascii.2:bs.3(153)"></A><A name="bs.3(153)"></A>: (# exit 8 #);
        <B>ht</B><A name="ANONYMOUS.1:ascii.2:ht.3(154)"></A><A name="ht.3(154)"></A>: (# exit 9 #);
        <B>nl</B><A name="ANONYMOUS.1:ascii.2:nl.3(155)"></A><A name="nl.3(155)"></A>: (# exit 10 #);
        <B>vt</B><A name="ANONYMOUS.1:ascii.2:vt.3(156)"></A><A name="vt.3(156)"></A>: (# exit 11 #);
        <B>np</B><A name="ANONYMOUS.1:ascii.2:np.3(157)"></A><A name="np.3(157)"></A>: (# exit 12 #);
        <B>cr</B><A name="ANONYMOUS.1:ascii.2:cr.3(158)"></A><A name="cr.3(158)"></A>: (# exit 13 #);
        <B>so</B><A name="ANONYMOUS.1:ascii.2:so.3(159)"></A><A name="so.3(159)"></A>: (# exit 14 #);
        <B>si</B><A name="ANONYMOUS.1:ascii.2:si.3(160)"></A><A name="si.3(160)"></A>: (# exit 15 #);
        <B>dle</B><A name="ANONYMOUS.1:ascii.2:dle.3(161)"></A><A name="dle.3(161)"></A>: (# exit 16 #);
        <B>dc1</B><A name="ANONYMOUS.1:ascii.2:dc1.3(162)"></A><A name="dc1.3(162)"></A>: (# exit 17 #);
        <B>dc2</B><A name="ANONYMOUS.1:ascii.2:dc2.3(163)"></A><A name="dc2.3(163)"></A>: (# exit 18 #);
        <B>dc3</B><A name="ANONYMOUS.1:ascii.2:dc3.3(164)"></A><A name="dc3.3(164)"></A>: (# exit 19 #);
        <B>dc4</B><A name="ANONYMOUS.1:ascii.2:dc4.3(165)"></A><A name="dc4.3(165)"></A>: (# exit 20 #);
        <B>nak</B><A name="ANONYMOUS.1:ascii.2:nak.3(166)"></A><A name="nak.3(166)"></A>: (# exit 21 #);
        <B>syn</B><A name="ANONYMOUS.1:ascii.2:syn.3(167)"></A><A name="syn.3(167)"></A>: (# exit 22 #);
        <B>etb</B><A name="ANONYMOUS.1:ascii.2:etb.3(168)"></A><A name="etb.3(168)"></A>: (# exit 23 #);
        <B>can</B><A name="ANONYMOUS.1:ascii.2:can.3(169)"></A><A name="can.3(169)"></A>: (# exit 24 #);
        <B>em</B><A name="ANONYMOUS.1:ascii.2:em.3(170)"></A><A name="em.3(170)"></A>: (# exit 25 #);
        <B>sub</B><A name="ANONYMOUS.1:ascii.2:sub.3(171)"></A><A name="sub.3(171)"></A>: (# exit 26 #);
        <B>esc</B><A name="ANONYMOUS.1:ascii.2:esc.3(172)"></A><A name="esc.3(172)"></A>: (# exit 27 #);
        <B>fs</B><A name="ANONYMOUS.1:ascii.2:fs.3(173)"></A><A name="fs.3(173)"></A>: (# exit 28 #);
        <B>gs</B><A name="ANONYMOUS.1:ascii.2:gs.3(174)"></A><A name="gs.3(174)"></A>: (# exit 29 #);
        <B>rs</B><A name="ANONYMOUS.1:ascii.2:rs.3(175)"></A><A name="rs.3(175)"></A>: (# exit 30 #);
        <B>us</B><A name="ANONYMOUS.1:ascii.2:us.3(176)"></A><A name="us.3(176)"></A>: (# exit 31 #);
        <B>sp</B><A name="ANONYMOUS.1:ascii.2:sp.3(177)"></A><A name="sp.3(177)"></A>: (# exit 32 #);
        <B>capA</B><A name="ANONYMOUS.1:ascii.2:capA.3(178)"></A><A name="capA.3(178)"></A>: (# exit 65 #);
        <B>smalla</B><A name="ANONYMOUS.1:ascii.2:smalla.3(179)"></A><A name="smalla.3(179)"></A>: (# exit 97 #);
        <B>del</B><A name="ANONYMOUS.1:ascii.2:del.3(180)"></A><A name="del.3(180)"></A>: (# exit 127 #);
        <B>newline</B><A name="ANONYMOUS.1:ascii.2:newline.3(181)"></A><A name="newline.3(181)"></A>: @char; (* either 'lf' or 'cr' *)
        
        <B>init</B><A name="ANONYMOUS.1:ascii.2:init.3(182)"></A><A name="init.3(182)"></A>: ...;
        <B>upCase</B><A name="ANONYMOUS.1:ascii.2:upCase.3(183)"></A><A name="upCase.3(183)"></A>: @charObject
          (# ... #);
        <B>lowCase</B><A name="ANONYMOUS.1:ascii.2:lowCase.3(184)"></A><A name="lowCase.3(184)"></A>: @charObject
          (# ... #);
        <B>testChar</B><A name="ANONYMOUS.1:ascii.2:testChar.3(185)"></A><A name="testChar.3(185)"></A>: booleanValue
          (# ch: @char
          enter ch
          do INNER testchar
          #);
        <B>isUpper</B><A name="ANONYMOUS.1:ascii.2:isUpper.3(186)"></A><A name="isUpper.3(186)"></A>: @testChar
          (# ... #);
        <B>isLower</B><A name="ANONYMOUS.1:ascii.2:isLower.3(187)"></A><A name="isLower.3(187)"></A>: @testChar
          (# ... #);
        <B>isDigit</B><A name="ANONYMOUS.1:ascii.2:isDigit.3(188)"></A><A name="isDigit.3(188)"></A>: @testChar
          (# ... #);
        <B>isLetter</B><A name="ANONYMOUS.1:ascii.2:isLetter.3(189)"></A><A name="isLetter.3(189)"></A>: @testChar
          (# ... #);
        <B>isSpace</B><A name="ANONYMOUS.1:ascii.2:isSpace.3(190)"></A><A name="isSpace.3(190)"></A>: @testChar
          (* True if 'ch' in {sp,cr,nl,np,ht,vt} *) 
          (# ... #);
        <B>isWhiteSpace</B><A name="ANONYMOUS.1:ascii.2:isWhiteSpace.3(191)"></A><A name="isWhiteSpace.3(191)"></A>: @testChar
          (* True if 'ch' is a whitespace char *) 
          (# ... #);
        <B>private</B><A name="ANONYMOUS.1:ascii.2:private.3(192)"></A><A name="private.3(192)"></A>: @...
     #);
   (*****  Exception Patterns ****************************************)
   <B>stop</B><A name="ANONYMOUS.1:stop.2(193)"></A><A name="stop.2(193)"></A>: 
     (* Terminates program execution: 'termCode=normal': normal
      * termination; 'termCode=failure': abnormal termination;
      * 'termCode=failureTrace': abnormal termination with trace of
      * run-time stack on dump-file; 'T' will be printed on the
      * screen.
      *)
     (# termCode: @integer; T: ^text
     enter (termCode,T[])
     do ...
     #);
   <B>normal</B><A name="ANONYMOUS.1:normal.2(194)"></A><A name="normal.2(194)"></A>: (# exit 0 #);
   <B>failure</B><A name="ANONYMOUS.1:failure.2(195)"></A><A name="failure.2(195)"></A>: (# exit -1 #);
   <B>failureTrace</B><A name="ANONYMOUS.1:failureTrace.2(196)"></A><A name="failureTrace.2(196)"></A>: (# exit -2 #);
   <B>exception</B><A name="ANONYMOUS.1:exception.2(197)"></A><A name="exception.2(197)"></A>:
     (# &lt;&lt;SLOT exceptionLib: attributes&gt;&gt;;
        <B>msg</B><A name="ANONYMOUS.1:exception.2:msg.3(198)"></A><A name="msg.3(198)"></A>:
          (* append text to this 'msg' vatiable to specify the
           * exception error message for this(exception)
           *)
          @text;
        <B>continue</B><A name="ANONYMOUS.1:exception.2:continue.3(199)"></A><A name="continue.3(199)"></A>: @boolean
          (* the valur of this variable determines the control-flow
           * behaviour of this(exception): 
           *    true:  continue execution after exception
           *    false: terminate execution by calling 'stop'; default
           *);
        <B>propagate</B><A name="ANONYMOUS.1:exception.2:propagate.3(200)"></A><A name="propagate.3(200)"></A>:&lt;
          (* if further bound to trueObject, this(exception) allows
           * propagation (i.e. this(exception will _not_ terminate)
           *)
          booleanValue;
        <B>error</B><A name="ANONYMOUS.1:exception.2:error.3(201)"></A><A name="error.3(201)"></A>:
          (* used to define local exception conditions which can be
           * handled separately.  All 'error's that are not handled
           * separately will be handled by this(exception)
           *)
          (# &lt;&lt;SLOT errorLib: attributes&gt;&gt;
          do false-&gt;continue;
             INNER;
             '**** Error processing\n'-&gt;msg.prepend;
             (if not propagate and not continue then this(exception) if)
          exit propagate
          #);
        <B>notify</B><A name="ANONYMOUS.1:exception.2:notify.3(202)"></A><A name="notify.3(202)"></A>: error
          (* used to define local notification conditions which can be
           * handled separately.  All 'notify's that are not handled
           * separately will be handled by this(exception)
           *)
          (# do true-&gt;continue; INNER #);
        <B>termCode</B><A name="ANONYMOUS.1:exception.2:termCode.3(203)"></A><A name="termCode.3(203)"></A>: @integer
          (* Arg. to pattern 'stop'; initial failureTrace *);
     do failureTrace-&gt;termCode;
        INNER exception;
        (if not continue and not propagate then
            '**** Exception processing\n'-&gt;msg.prepend;
            (termCode,msg[])-&gt;stop
        if)
     #);
   <B>notification</B><A name="ANONYMOUS.1:notification.2(204)"></A><A name="notification.2(204)"></A>: exception
     (# do true-&gt;continue; INNER notification #);
   (*****  Object Pool ***********************************************)
   <B>objectPool</B><A name="ANONYMOUS.1:objectPool.2(205)"></A><A name="objectPool.2(205)"></A>: @
     (# &lt;&lt;SLOT objectPoolLib: attributes&gt;&gt;;
        get: 
          (# type:&lt; object;
             obj: ^type;
             exact:&lt; booleanValue;
             init:&lt; object(* Called if an object was created *)
          ...
          exit obj[]
          #);
        strucGet: 
          (# type: ##object;
             obj: ^object;
             exact:&lt; booleanValue;
             init:&lt; object(* Called if an object was created *);
          enter type##
          ...
          exit obj[]
          #);
        scan: 
          (* Scan through all objects in 'objectPool', (at least)
           * qualified by 'type'.
           *)
          (# type:&lt; object;
             current: ^type;
             exact:&lt; booleanValue;
          ...
          #);
        strucScan: 
          (* Scan through all objects in 'objectPool', (at least)
           * qualified by 'type'
           *)
          (# type: ##object;
             current: ^object;
             exact:&lt; booleanValue
          enter type##
          ...
          #);
        put: 
          (* Puts a given object into 'objectPool'. If an object with
           * (at least) the qualification of the given object is
           * already present in 'objectPool', the exception
           * 'alreadyThere' is raised.
           *)
          (# obj: ^object;
             exact:&lt; booleanValue;
             alreadyThere:&lt; exception;
             putObj: @...
          enter obj[]
          do putObj
          #);
        private: @...;
     #);
   
   (*****  Command line arguments ************************************)
   <B>argumentHandlerType</B><A name="ANONYMOUS.1:argumentHandlerType.2(206)"></A><A name="argumentHandlerType.2(206)"></A>:
     (# 
        noOfArguments:&lt; 
          (* Return the number of arguments on command line.
           * The number includes the program name.
           *)
          integervalue;
        
        getArgByNumber:&lt;
          (* Returns argument number argNo.  
           * Number 1 is the program name, 
           * number 2 is the first program argument, etc.
           *)
          (# argNo: @integer; theArg: ^text;
          enter argNo
          do INNER
          exit theArg[]
          #);
     #);
   
   <B>rawArgumentHandler</B><A name="ANONYMOUS.1:rawArgumentHandler.2(207)"></A><A name="rawArgumentHandler.2(207)"></A>: argumentHandlerType
     (# 
        noOfArguments::
          (# ... #);
        getArgByNumber::
          (# ... #);
     #);
   
   <B>expandWildcardsArgumentHandler</B><A name="ANONYMOUS.1:expandWildcardsArgumentHandler.2(208)"></A><A name="expandWildcardsArgumentHandler.2(208)"></A>: argumentHandlerType
     (# private: @...;
        noOfArguments::
          (# ... #);
        getArgByNumber::
          (# ... #);
     #);
   
   <B>argumentHandler</B><A name="ANONYMOUS.1:argumentHandler.2(209)"></A><A name="argumentHandler.2(209)"></A>: ^argumentHandlerType;
   
   (* Backwards compatible interface *)
   <B>noOfArguments</B><A name="ANONYMOUS.1:noOfArguments.2(210)"></A><A name="noOfArguments.2(210)"></A>: integervalue(# do argumentHandler.noOfArguments -&gt; value #);
   <B>arguments</B><A name="ANONYMOUS.1:arguments.2(211)"></A><A name="arguments.2(211)"></A>: 
     (# argNo: @integer; theArg: ^text;
     enter argNo
     do argNo -&gt; argumentHandler.getArgByNumber -&gt; theArg[]
     exit theArg[]
     #);
   (******************************************************************)
   (* External language interface: See file 'external.bet' for further
    * patterns.
    *)
   <B>External</B><A name="ANONYMOUS.1:External.2(212)"></A><A name="External.2(212)"></A>:
     (* Is only meaningful with interface to externals *)
     (# <B>callC</B><A name="ANONYMOUS.1:External.2:callC.3(213)"></A><A name="callC.3(213)"></A>,<B>callPascal</B><A name="ANONYMOUS.1:External.2:callPascal.3(214)"></A><A name="callPascal.3(214)"></A>,<B>pascal</B><A name="ANONYMOUS.1:External.2:pascal.3(215)"></A><A name="pascal.3(215)"></A>,<B>pascalTrap</B><A name="ANONYMOUS.1:External.2:pascalTrap.3(216)"></A><A name="pascalTrap.3(216)"></A>,<B>callStd</B><A name="ANONYMOUS.1:External.2:callStd.3(217)"></A><A name="callStd.3(217)"></A>,<B>
        cExternalEntry</B><A name="ANONYMOUS.1:External.2:cExternalEntry.3(218)"></A><A name="cExternalEntry.3(218)"></A>,<B>pascalExternalEntry</B><A name="ANONYMOUS.1:External.2:pascalExternalEntry.3(219)"></A><A name="pascalExternalEntry.3(219)"></A>,<B>stdExternalEntry</B><A name="ANONYMOUS.1:External.2:stdExternalEntry.3(220)"></A><A name="stdExternalEntry.3(220)"></A>: @text
     #);
   <B>cStruct</B><A name="ANONYMOUS.1:cStruct.2(221)"></A><A name="cStruct.2(221)"></A>: 
     (* Super-pattern for describing structures which can be given
      * 'by refererence' (using the usual [] notation) to an external
      * function (e.g. a C function described as a specialization
      * of the above External pattern). See file external.bet for
      * supported operations on cStruct.
      *)
     (# &lt;&lt;SLOT cStructLib: attributes&gt;&gt;;
        (* 'R' is the bytestream containing THIS(cStruct).  
         * MUST be declared as the first attribute
         *);
        <B>R</B><A name="ANONYMOUS.1:cStruct.2:R.3(222)"></A><A name="R.3(222)"></A>: [(byteSize-1) div 4 + 1] @integer;
        <B>byteSize</B><A name="ANONYMOUS.1:cStruct.2:byteSize.3(223)"></A><A name="byteSize.3(223)"></A>:&lt; 
          (* Number of bytes in THIS(cStruct) *)
          IntegerObject;
          
        <B>BoundsExceeded</B><A name="ANONYMOUS.1:cStruct.2:BoundsExceeded.3(224)"></A><A name="BoundsExceeded.3(224)"></A>:&lt; Exception
          (* Raised if indexing outside range of R *)
          (# inx: @integer; 
          enter inx
          ...
          #);
        <B>chk</B><A name="ANONYMOUS.1:cStruct.2:chk.3(225)"></A><A name="chk.3(225)"></A>: @(# inx: @integer enter inx ... #);
     #);
   <B>data</B><A name="ANONYMOUS.1:data.2(226)"></A><A name="data.2(226)"></A>:
     (* The 'data' pattern may be used for definining simple data
      * objects.  Data-objects have no 'type' information. They can
      * thus NOT be allocated dynamically in the BETA heap. They do * not have the overhead of extra attributes used for virtual
      * dispatch and garbage collection. One main use of data-objects
      * is as interface to external data such as 'cstruct'.  For
      * details see the manuals
      *)
     (# #);
   <B>doGC</B><A name="ANONYMOUS.1:doGC.2(227)"></A><A name="doGC.2(227)"></A>: (* will force a garbage collection to happen *)
     (# ... #);
   <B>machine_type</B><A name="ANONYMOUS.1:machine_type.2(228)"></A><A name="machine_type.2(228)"></A>:
     (* Exits a reference to a copy of a text indicating the machine
      * type in lowercase, e.g. 'sun4s', 'linux', 'nti'.
      *)
     (# <B>T</B><A name="ANONYMOUS.1:machine_type.2:T.3(229)"></A><A name="T.3(229)"></A>: @Text;
     do machine_typeexternal-&gt;T;
     exit T.copy
     #);
   <B>machine_typeexternal</B><A name="ANONYMOUS.1:machine_typeexternal.2(230)"></A><A name="machine_typeexternal.2(230)"></A>: external
     (# <B>T</B><A name="ANONYMOUS.1:machine_typeexternal.2:T.3(231)"></A><A name="T.3(231)"></A>: [1]@Char; do 'machine_type'-&gt;callC; exit T #);
   <B>program</B><A name="ANONYMOUS.1:program.2(232)"></A><A name="program.2(232)"></A>: (* descriptor executed by this environment *)
     ...;
   <B>theProgram</B><A name="ANONYMOUS.1:theProgram.2(233)"></A><A name="theProgram.2(233)"></A>: ^|program;
   <B>theScheduler</B><A name="ANONYMOUS.1:theScheduler.2(234)"></A><A name="theScheduler.2(234)"></A>: ^|object
     (* Scheduler installed by 'basicSystemEnv' (if used in program) *);
   (******************************************************************)
   (* The following patterns are only used by the compiler and should
    * NOT be used for other purposes.
    *)
   <B>repetition</B><A name="ANONYMOUS.1:repetition.2(235)"></A><A name="repetition.2(235)"></A>: 
     (# range: (* Returns the range of THIS(repetition) *)
          (# n: @integer
          exit n
          #);
        new: 
          (* Allocates a new repetition of 'n' elements. The previous
           * elements in THIS(repetition) become inaccessible
           * hereafter
           *)
          (# n: @integer
          enter n
          #);
        extend:
          (* Extends THIS(repetition) by 'n' elements.  The existing
           * elements are retained.  The new elements are allocated
           * after the existing elements (i.e. with index from the
           * 'range+1')
           *)
          (# n: @integer
          enter n
          #)
     #);
   <B>state</B><A name="ANONYMOUS.1:state.2(236)"></A><A name="state.2(236)"></A>: (# #); (* Pattern STATE is for experimental purpose only
                  * and using it may give undefined results 
                  *)
   <B>errorName</B><A name="ANONYMOUS.1:errorName.2(237)"></A><A name="errorName.2(237)"></A>: (# #)
   
   (******************************************************************)
do ...;
   &amp;|program[]-&gt;theProgram[];
   theProgram;
   (if theScheduler[]&lt;&gt;NONE then theScheduler if);
   ... ;
#)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE border=0 width=100%>
<TR><TD><ADDRESS>Interface Description</ADDRESS></TD>
<SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT>
</TABLE>
<P></P>
<A HREF="math.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
