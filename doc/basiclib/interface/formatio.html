<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<TITLE>Formatio Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="random.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="numberio.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Formatio Interface</H1>
<PRE CLASS=interface>
ORIGIN 'betaenv';
LIB_DEF 'formatio' '../lib';
BODY 'private/formatioBody'
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1984-96
 *       All rights reserved.
 *
 *)
--- streamLib: attributes ---
<B>getFormat</B><A name="getFormat.1(573)"></A>: formatter
  (* getFormat accepts the following syntax for markers:
   * 
   *      %[width][.[precision]]{dioxXrRbBfeEgGcsn%}
   * 
   * where width is a (unsigned) decimal number (or '*'), and
   *   precision is a (unsigned) decimal number (or '*'),
   * 
   * and where
   *     [ ... ] means that the enclodes is optional,
   * and { ... } means one if the enclosed characters.
   * 
   * Width is only interpreted in conjunction with the 's' marker.
   * Precision is only interpreted in conjunction with the
   * 'r' and 'R' markers.
   * 
   * For all but the 'c' marker, leading white space are skipped.
   * 
   * The '%' marker means that a '%' is expected on the input stream.
   * 
   * Actually, getFormat accepts the same syntax as putFormat (see
   * later):
   * 
   *      %{-+ }[[0]width][.[[0]precision]]{dioxXrRbBfeEgGcsn%}
   * 
   * but only the above part of that syntax is actually interpreted by
   * getFormat.  The reason for accepting the same syntax is to allow
   * a format string to be used both for getFormat and putFormat.
   *)
  (# <B>width</B><A name="getFormat.1:width.2(574)"></A><A name="width.2(574)"></A>:
       (* sets the default precision to be used in future '*' width
        * specifications
        *)
       (# w: @integer enter w ... #);
     <B>precision</B><A name="getFormat.1:precision.2(575)"></A><A name="precision.2(575)"></A>:
       (* sets the default precision to be used in future '*'
        * precision specifications
        *)
       (# p: @integer enter p ... #);
     <B>marker</B><A name="getFormat.1:marker.2(576)"></A><A name="marker.2(576)"></A>: scanForMarker
       (# formatEOS:: (# do mark-&gt;missingMarker #)
       ...
       #);
     <B>d</B><A name="getFormat.1:d.2(577)"></A><A name="d.2(577)"></A>: marker (* read a decimal number *)
       (# mark:: (# do 'd'-&gt;value #);
          value: @integer
       ...    
       exit value
       #);
     <B>i</B><A name="getFormat.1:i.2(578)"></A><A name="i.2(578)"></A>: marker
       (* read a number, either decimal, octal or hexadecimal using C
        * conventions: 0nnn implies octal, 0xnnn implies hexadecimal,
        * decimal otherwise.
        *)
       (# mark:: (# do 'i'-&gt;value #);
          value: @integer
       ...    
       exit value
       #);
     <B>o</B><A name="getFormat.1:o.2(579)"></A><A name="o.2(579)"></A>: marker (* read an octal number *)
       (# mark:: (# do 'o'-&gt;value #);
          value: @integer
       ...    
       exit value
       #);
     <B>x</B><A name="getFormat.1:x.2(580)"></A><A name="x.2(580)"></A>: marker (* read a hexadecimal number *)
       (# mark:: (# do 'x'-&gt;value #);
          value: @integer
       ...   
       exit value
       #);
     <B>uX</B><A name="getFormat.1:uX.2(581)"></A><A name="uX.2(581)"></A>: marker (* read a hexadecimal number.  Identical to 'x' *)
       (# mark:: (# do 'X'-&gt;value #);
          value: @integer
       ...    
       exit value
       #);
     <B>r</B><A name="getFormat.1:r.2(582)"></A><A name="r.2(582)"></A>: marker
       (* read a number in radix given by precision *)
       (# mark:: (# do 'r'-&gt;value #);
          value: @integer
       ...  
       exit value
       #);
     <B>uR</B><A name="getFormat.1:uR.2(583)"></A><A name="uR.2(583)"></A>: marker
       (* read a number in radix given by precision.  Identical to
        * 'r'
        *)
       (# mark:: (# do 'R'-&gt;value #);
          value: @integer
       ...  
       exit value
       #);
     <B>b</B><A name="getFormat.1:b.2(584)"></A><A name="b.2(584)"></A>: marker
       (* read a number as based number (i.e. in the bbxnnn format) *)
       (# mark:: (# do 'b'-&gt;value #);
          base, value: @integer
       ...  
       exit (base,value)
       #);
     <B>uB</B><A name="getFormat.1:uB.2(585)"></A><A name="uB.2(585)"></A>: marker
       (* read a number as based number (i.e. in the bbxnnn format).
        * Identical to 'b'
        *)
       (# mark:: (# do 'B'-&gt;value #);
          base, value: @integer
       ...  
       exit (base,value)
       #);
     <B>f</B><A name="getFormat.1:f.2(586)"></A><A name="f.2(586)"></A>: marker (* read a real *)
       (# mark:: (# do 'f'-&gt;value #);
          value: @real
       ...    
       exit value
       #);
     <B>e</B><A name="getFormat.1:e.2(587)"></A><A name="e.2(587)"></A>: marker (* read a real.  Identical to 'f' *)
       (# mark:: (# do 'e'-&gt;value #);
          value: @real
       ...    
       exit value
       #);
     <B>uE</B><A name="getFormat.1:uE.2(588)"></A><A name="uE.2(588)"></A>: marker (* read a real.  Identical to 'f' *)
       (# mark:: (# do 'E'-&gt;value #);
          value: @real
       ...    
       exit value
       #);
     <B>g</B><A name="getFormat.1:g.2(589)"></A><A name="g.2(589)"></A>: marker (* read a real.  Identical to 'f' *)
       (# mark:: (# do 'g'-&gt;value #);
          value: @real
       ...    
       exit value
       #);
     <B>uG</B><A name="getFormat.1:uG.2(590)"></A><A name="uG.2(590)"></A>: marker (* read a real.  Identical to 'f' *)
       (# mark:: (# do 'G'-&gt;value #);
          value: @real
       ...    
       exit value
       #);
     <B>c</B><A name="getFormat.1:c.2(591)"></A><A name="c.2(591)"></A>: marker (* read a single character *)
       (# mark:: (# do 'c'-&gt;value #);
          value: @char
       ...    
       exit value
       #);
     <B>s</B><A name="getFormat.1:s.2(592)"></A><A name="s.2(592)"></A>: marker 
       (* read a text atom (i.e. a sequence of non-white space
        * characters, terminated by a white space character - similar
        * to getAtom).  If width is non-zero, at most width characters
        * are read.  Otherwise, characters are read until next
        * whitespace character
        *)
       (# mark:: (# do 's'-&gt;value #);
          value: ^text
       ...  
       exit value[]
       #);
     <B>n</B><A name="getFormat.1:n.2(593)"></A><A name="n.2(593)"></A>: marker
       (* return the number of characters read until this point *)
       (# mark:: (# do 'n'-&gt;value #);
          value: @integer
       ...  
       exit value
       #);
     <B>match</B><A name="getFormat.1:match.2(594)"></A><A name="match.2(594)"></A>:: (* private *)
       (# ... #)
  do INNER getFormat
  #);

<B>putFormat</B><A name="putFormat.1(595)"></A>: formatter
  (* putFormat accepts the following syntax for markers:
   * 
   *      %{-+ }[[0]width][.[[0]precision]]{dioxXrRbBfeEgGcsn%}
   * 
   * where width is a (unsigned) decimal number (or '*'), and
   *   precision is a (unsigned) decimal number (or '*') and where
   * 
   *     [ ... ] means that the enclodes is optional,
   * and { ... } means one if the enclosed characters.
   * 
   * '-' implies output leftjustified in field
   * '+' implies output numbers signed (always with leading '+' or
   *                                    '-')
   * ' ' implies output numbers with blank sign (i.e. leading ' ' if
   *                                             positive)
   * '0' in front of either width or precision implies zero padding
   * width specifies the minimun width of the output field.
   * precision is interpreted for various things in the 'rRbBfeEgG'
   *     markers.
   * 
   * The '%' marker means that a '%' is put on the output stream.
   *)
  (# <B>width</B><A name="putFormat.1:width.2(596)"></A><A name="width.2(596)"></A>:
       (* sets the default precision to be used in future '*' width
        * specifications
        *)
       (# w: @integer enter w ... #);
     <B>precision</B><A name="putFormat.1:precision.2(597)"></A><A name="precision.2(597)"></A>:
       (* sets the default precision to be used in future '*'
        * precision specifications
        *)
       (# p: @integer enter p ... #);
     <B>marker</B><A name="putFormat.1:marker.2(598)"></A><A name="marker.2(598)"></A>: scanForMarker
       (# formatEOS:: (# do mark-&gt;missingMarker #)
       ...
       #);
     <B>d</B><A name="putFormat.1:d.2(599)"></A><A name="d.2(599)"></A>: marker (* insert the integer *)
       (# mark:: (# do 'd'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>i</B><A name="putFormat.1:i.2(600)"></A><A name="i.2(600)"></A>: marker (* insert the integer. Identical to 'd' *)
       (# mark:: (# do 'i'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>y</B><A name="putFormat.1:y.2(601)"></A><A name="y.2(601)"></A>: marker (* insert the integer in binary *)
       (# mark:: (# do 'y'-&gt;value #);
          value: @integer
       enter value
       ...
       #);
     <B>o</B><A name="putFormat.1:o.2(602)"></A><A name="o.2(602)"></A>: marker (* insert the integer in octal, at least 10 ciffers *)
       (# mark:: (# do 'o'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>x</B><A name="putFormat.1:x.2(603)"></A><A name="x.2(603)"></A>: marker (* insert the integer in hexadecimal, at least 8 ciffers *)
       (# mark:: (# do 'x'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>uX</B><A name="putFormat.1:uX.2(604)"></A><A name="uX.2(604)"></A>: marker
       (* insert the integer in hexadecimal, using uppercase letters
        *)
       (# mark:: (# do 'X'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>r</B><A name="putFormat.1:r.2(605)"></A><A name="r.2(605)"></A>: marker
       (* insert the integer in radix given by precision *)
       (# mark:: (# do 'r'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>uR</B><A name="putFormat.1:uR.2(606)"></A><A name="uR.2(606)"></A>: marker
       (* insert the integer in radix given by precision, using
        * uppercase letters if radix&gt;10
        *)
       (# mark:: (# do 'R'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>b</B><A name="putFormat.1:b.2(607)"></A><A name="b.2(607)"></A>: marker
       (* insert the integer as based number (i.e. in the bbxnnn
        * format) with base given by precision
        *)
       (# mark:: (# do 'b'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>uB</B><A name="putFormat.1:uB.2(608)"></A><A name="uB.2(608)"></A>: marker
       (* insert the integer as based number (i.e. in the bbxnnn
        * format) with base given by precision, using uppercase
        * letters if base&gt;10
        *)
       (# mark:: (# do 'B'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>f</B><A name="putFormat.1:f.2(609)"></A><A name="f.2(609)"></A>: marker (* insert the real in noexp style *)
       (# mark:: (# do 'f'-&gt;value #);
          value: @real
       enter value
       ...  
       #);
     <B>e</B><A name="putFormat.1:e.2(610)"></A><A name="e.2(610)"></A>: marker (* insert the real in exp style *)
       (# mark:: (# do 'e'-&gt;value #);
          value: @real
       enter value
       ...  
       #);
     <B>uE</B><A name="putFormat.1:uE.2(611)"></A><A name="uE.2(611)"></A>: marker (* insert the real in exp style and upcase 'E' *)
       (# mark:: (# do 'E'-&gt;value #);
          value: @real
       enter value
       ...  
       #);
     <B>g</B><A name="putFormat.1:g.2(612)"></A><A name="g.2(612)"></A>: marker (* insert the real in plain style *)
       (# mark:: (# do 'g'-&gt;value #);
          value: @real
       enter value
       ...  
       #);
     <B>uG</B><A name="putFormat.1:uG.2(613)"></A><A name="uG.2(613)"></A>: marker (* insert the real in plain style and upcase 'E' *)
       (# mark:: (# do 'G'-&gt;value #);
          value: @real
       enter value
       ...  
       #);
     <B>c</B><A name="putFormat.1:c.2(614)"></A><A name="c.2(614)"></A>: marker (* insert the char *)
       (# mark:: (# do 'c'-&gt;value #);
          value: @char;
          putc: @(* Private *)...  
       enter value
       do putc
       #);
     <B>s</B><A name="putFormat.1:s.2(615)"></A><A name="s.2(615)"></A>: marker (* insert the text *)
       (# mark:: (# do 's'-&gt;value #);
          value: ^text;
          puts: @(* Private *)...
       enter value[]
       do puts
       #);
     <B>n</B><A name="putFormat.1:n.2(616)"></A><A name="n.2(616)"></A>: marker
       (* return the length of the result string until this point *)
       (# mark:: (# do 'n'-&gt;value #);
          value: @integer
       ...  
       exit value
       #);
     <B>match</B><A name="putFormat.1:match.2(617)"></A><A name="match.2(617)"></A>:: (* private *)
       (# ... #)
  do INNER putFormat
  #);

<B>formatter</B><A name="formatter.1(618)"></A>: (* superpattern for putFormat and getFormat *)
  (# <B>illegalFormat</B><A name="formatter.1:illegalFormat.2(619)"></A><A name="illegalFormat.2(619)"></A>:&lt; exception
       (# mark: @char
       enter mark
       ...
       #);
     <B>missingMarker</B><A name="formatter.1:missingMarker.2(620)"></A><A name="missingMarker.2(620)"></A>:&lt; exception
       (# mark: @char
       enter mark
       ...
       #);
     <B>missingField</B><A name="formatter.1:missingField.2(621)"></A><A name="missingField.2(621)"></A>:&lt; exception
       (# ... #);
     <B>inputError</B><A name="formatter.1:inputError.2(622)"></A><A name="inputError.2(622)"></A>:&lt; exception
       (# chFound, chExpected: @char
       enter (chFound, chExpected)
       ...
       #);
     <B>scanForMarker</B><A name="formatter.1:scanForMarker.2(623)"></A><A name="scanForMarker.2(623)"></A>: (* Private *)
       (# mark:&lt; charValue;
          formatEOS:&lt; exception;
          fieldWidth, precisionSpec: @integer;
          leftFlag, signedFlag, blankFlag,
          alternativeFlag, zeroFlag, longFlag: @boolean
       ...
       #);
     <B>match</B><A name="formatter.1:match.2(624)"></A><A name="match.2(624)"></A>:&lt; (* private *)
       (# ch: @char
       enter ch
       do INNER match
       #);
     <B>private</B><A name="formatter.1:private.2(625)"></A><A name="private.2(625)"></A>: @...;
     <B>formatStr</B><A name="formatter.1:formatStr.2(626)"></A><A name="formatStr.2(626)"></A>: ^text
  enter formatStr[]
  ...
  exit this(stream)[]
  #);

--- lib: attributes ---
   
<B>getFormat</B><A name="getFormat.1(627)"></A>: keyboard.getFormat(# do INNER getFormat #);

<B>putFormat</B><A name="putFormat.1(628)"></A>: screen.putFormat(# do INNER putFormat #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="33%" align="left"><ADDRESS>Interface Description</ADDRESS></TD>
<TD width="34%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="33%" align="right"><FONT size=-1><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></FONT></TD>
</TABLE>
<P></P>
<A HREF="random.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="numberio.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
