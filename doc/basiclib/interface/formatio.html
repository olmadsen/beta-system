<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Formatio Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="random.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="numberio.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Formatio Interface</H1>
<PRE CLASS=interface>
ORIGIN 'betaenv';
LIB_DEF 'formatio' '../lib';
BODY 'private/formatioBody'
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1984-96
 *       All rights reserved.
 *
 *)
--- streamLib: attributes ---
<B>getFormat</B><A name="getFormat.1(449)"></A>: formatter
  (* getFormat accepts the following syntax for markers:
   * 
   *      %[width][.[precision]]{dioxXrRbBfeEgGcsn%}
   * 
   * where width is a (unsigned) decimal number (or '*'), and
   *   precision is a (unsigned) decimal number (or '*'),
   * 
   * and where
   *     [ ... ] means that the enclodes is optional,
   * and { ... } means one if the enclosed characters.
   * 
   * Width is only interpreted in conjunction with the 's' marker.
   * Precision is only interpreted in conjunction with the
   * 'r' and 'R' markers.
   * 
   * For all but the 'c' marker, leading white space are skipped.
   * 
   * The '%' marker means that a '%' is expected on the input stream.
   * 
   * Actually, getFormat accepts the same syntax as putFormat (see
   * later):
   * 
   *      %{-+ }[[0]width][.[[0]precision]]{dioxXrRbBfeEgGcsn%}
   * 
   * but only the above part of that syntax is actually interpreted by
   * getFormat.  The reason for accepting the same syntax is to allow
   * a format string to be used both for getFormat and putFormat.
   *)
  (# <B>width</B><A name="getFormat.1:width.2(450)"></A><A name="width.2(450)"></A>:
       (* sets the default precision to be used in future '*' width
        * specifications
        *)
       (# w: @integer enter w ... #);
     <B>precision</B><A name="getFormat.1:precision.2(451)"></A><A name="precision.2(451)"></A>:
       (* sets the default precision to be used in future '*'
        * precision specifications
        *)
       (# p: @integer enter p ... #);
     <B>marker</B><A name="getFormat.1:marker.2(452)"></A><A name="marker.2(452)"></A>: scanForMarker
       (# formatEOS:: (# do mark-&gt;missingMarker #)
       ...
       #);
     <B>d</B><A name="getFormat.1:d.2(453)"></A><A name="d.2(453)"></A>: marker (* read a decimal number *)
       (# mark:: (# do 'd'-&gt;value #);
          value: @integer
       ...    
       exit value
       #);
     <B>i</B><A name="getFormat.1:i.2(454)"></A><A name="i.2(454)"></A>: marker
       (* read a number, either decimal, octal or hexadecimal using C
        * conventions: 0nnn implies octal, 0xnnn implies hexadecimal,
        * decimal otherwise.
        *)
       (# mark:: (# do 'i'-&gt;value #);
          value: @integer
       ...    
       exit value
       #);
     <B>o</B><A name="getFormat.1:o.2(455)"></A><A name="o.2(455)"></A>: marker (* read an octal number *)
       (# mark:: (# do 'o'-&gt;value #);
          value: @integer
       ...    
       exit value
       #);
     <B>x</B><A name="getFormat.1:x.2(456)"></A><A name="x.2(456)"></A>: marker (* read a hexadecimal number *)
       (# mark:: (# do 'x'-&gt;value #);
          value: @integer
       ...   
       exit value
       #);
     <B>uX</B><A name="getFormat.1:uX.2(457)"></A><A name="uX.2(457)"></A>: marker (* read a hexadecimal number.  Identical to 'x' *)
       (# mark:: (# do 'X'-&gt;value #);
          value: @integer
       ...    
       exit value
       #);
     <B>r</B><A name="getFormat.1:r.2(458)"></A><A name="r.2(458)"></A>: marker
       (* read a number in radix given by precision *)
       (# mark:: (# do 'r'-&gt;value #);
          value: @integer
       ...  
       exit value
       #);
     <B>uR</B><A name="getFormat.1:uR.2(459)"></A><A name="uR.2(459)"></A>: marker
       (* read a number in radix given by precision.  Identical to
        * 'r'
        *)
       (# mark:: (# do 'R'-&gt;value #);
          value: @integer
       ...  
       exit value
       #);
     <B>b</B><A name="getFormat.1:b.2(460)"></A><A name="b.2(460)"></A>: marker
       (* read a number as based number (i.e. in the bbxnnn format) *)
       (# mark:: (# do 'b'-&gt;value #);
          base, value: @integer
       ...  
       exit (base,value)
       #);
     <B>uB</B><A name="getFormat.1:uB.2(461)"></A><A name="uB.2(461)"></A>: marker
       (* read a number as based number (i.e. in the bbxnnn format).
        * Identical to 'b'
        *)
       (# mark:: (# do 'B'-&gt;value #);
          base, value: @integer
       ...  
       exit (base,value)
       #);
     <B>f</B><A name="getFormat.1:f.2(462)"></A><A name="f.2(462)"></A>: marker (* read a real *)
       (# mark:: (# do 'f'-&gt;value #);
          value: @real
       ...    
       exit value
       #);
     <B>e</B><A name="getFormat.1:e.2(463)"></A><A name="e.2(463)"></A>: marker (* read a real.  Identical to 'f' *)
       (# mark:: (# do 'e'-&gt;value #);
          value: @real
       ...    
       exit value
       #);
     <B>uE</B><A name="getFormat.1:uE.2(464)"></A><A name="uE.2(464)"></A>: marker (* read a real.  Identical to 'f' *)
       (# mark:: (# do 'E'-&gt;value #);
          value: @real
       ...    
       exit value
       #);
     <B>g</B><A name="getFormat.1:g.2(465)"></A><A name="g.2(465)"></A>: marker (* read a real.  Identical to 'f' *)
       (# mark:: (# do 'g'-&gt;value #);
          value: @real
       ...    
       exit value
       #);
     <B>uG</B><A name="getFormat.1:uG.2(466)"></A><A name="uG.2(466)"></A>: marker (* read a real.  Identical to 'f' *)
       (# mark:: (# do 'G'-&gt;value #);
          value: @real
       ...    
       exit value
       #);
     <B>c</B><A name="getFormat.1:c.2(467)"></A><A name="c.2(467)"></A>: marker (* read a single character *)
       (# mark:: (# do 'c'-&gt;value #);
          value: @char
       ...    
       exit value
       #);
     <B>s</B><A name="getFormat.1:s.2(468)"></A><A name="s.2(468)"></A>: marker 
       (* read a text atom (i.e. a sequence of non-white space
        * characters, terminated by a white space character - similar
        * to getAtom).  If width is non-zero, at most width characters
        * are read.  Otherwise, characters are read until next
        * whitespace character
        *)
       (# mark:: (# do 's'-&gt;value #);
          value: ^text
       ...  
       exit value[]
       #);
     <B>n</B><A name="getFormat.1:n.2(469)"></A><A name="n.2(469)"></A>: marker
       (* return the number of characters read until this point *)
       (# mark:: (# do 'n'-&gt;value #);
          value: @integer
       ...  
       exit value
       #);
     <B>match</B><A name="getFormat.1:match.2(470)"></A><A name="match.2(470)"></A>:: (* private *)
       (# ... #)
  do INNER getFormat
  #);

<B>putFormat</B><A name="putFormat.1(471)"></A>: formatter
  (* putFormat accepts the following syntax for markers:
   * 
   *      %{-+ }[[0]width][.[[0]precision]]{dioxXrRbBfeEgGcsn%}
   * 
   * where width is a (unsigned) decimal number (or '*'), and
   *   precision is a (unsigned) decimal number (or '*') and where
   * 
   *     [ ... ] means that the enclodes is optional,
   * and { ... } means one if the enclosed characters.
   * 
   * '-' implies output leftjustified in field
   * '+' implies output numbers signed (always with leading '+' or
   *                                    '-')
   * ' ' implies output numbers with blank sign (i.e. leading ' ' if
   *                                             positive)
   * '0' in front of either width or precision implies zero padding
   * width specifies the minimun width of the output field.
   * precision is interpreted for various things in the 'rRbBfeEgG'
   *     markers.
   * 
   * The '%' marker means that a '%' is put on the output stream.
   *)
  (# <B>width</B><A name="putFormat.1:width.2(472)"></A><A name="width.2(472)"></A>:
       (* sets the default precision to be used in future '*' width
        * specifications
        *)
       (# w: @integer enter w ... #);
     <B>precision</B><A name="putFormat.1:precision.2(473)"></A><A name="precision.2(473)"></A>:
       (* sets the default precision to be used in future '*'
        * precision specifications
        *)
       (# p: @integer enter p ... #);
     <B>marker</B><A name="putFormat.1:marker.2(474)"></A><A name="marker.2(474)"></A>: scanForMarker
       (# formatEOS:: (# do mark-&gt;missingMarker #)
       ...
       #);
     <B>d</B><A name="putFormat.1:d.2(475)"></A><A name="d.2(475)"></A>: marker (* insert the integer *)
       (# mark:: (# do 'd'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>i</B><A name="putFormat.1:i.2(476)"></A><A name="i.2(476)"></A>: marker (* insert the integer. Identical to 'd' *)
       (# mark:: (# do 'i'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>y</B><A name="putFormat.1:y.2(477)"></A><A name="y.2(477)"></A>: marker (* insert the integer in binary *)
       (# mark:: (# do 'y'-&gt;value #);
          value: @integer
       enter value
       ...
       #);
     <B>o</B><A name="putFormat.1:o.2(478)"></A><A name="o.2(478)"></A>: marker (* insert the integer in octal, at least 10 ciffers *)
       (# mark:: (# do 'o'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>x</B><A name="putFormat.1:x.2(479)"></A><A name="x.2(479)"></A>: marker (* insert the integer in hexadecimal, at least 8 ciffers *)
       (# mark:: (# do 'x'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>uX</B><A name="putFormat.1:uX.2(480)"></A><A name="uX.2(480)"></A>: marker
       (* insert the integer in hexadecimal, using uppercase letters
        *)
       (# mark:: (# do 'X'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>r</B><A name="putFormat.1:r.2(481)"></A><A name="r.2(481)"></A>: marker
       (* insert the integer in radix given by precision *)
       (# mark:: (# do 'r'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>uR</B><A name="putFormat.1:uR.2(482)"></A><A name="uR.2(482)"></A>: marker
       (* insert the integer in radix given by precision, using
        * uppercase letters if radix&gt;10
        *)
       (# mark:: (# do 'R'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>b</B><A name="putFormat.1:b.2(483)"></A><A name="b.2(483)"></A>: marker
       (* insert the integer as based number (i.e. in the bbxnnn
        * format) with base given by precision
        *)
       (# mark:: (# do 'b'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>uB</B><A name="putFormat.1:uB.2(484)"></A><A name="uB.2(484)"></A>: marker
       (* insert the integer as based number (i.e. in the bbxnnn
        * format) with base given by precision, using uppercase
        * letters if base&gt;10
        *)
       (# mark:: (# do 'B'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>f</B><A name="putFormat.1:f.2(485)"></A><A name="f.2(485)"></A>: marker (* insert the real in noexp style *)
       (# mark:: (# do 'f'-&gt;value #);
          value: @real
       enter value
       ...  
       #);
     <B>e</B><A name="putFormat.1:e.2(486)"></A><A name="e.2(486)"></A>: marker (* insert the real in exp style *)
       (# mark:: (# do 'e'-&gt;value #);
          value: @real
       enter value
       ...  
       #);
     <B>uE</B><A name="putFormat.1:uE.2(487)"></A><A name="uE.2(487)"></A>: marker (* insert the real in exp style and upcase 'E' *)
       (# mark:: (# do 'E'-&gt;value #);
          value: @real
       enter value
       ...  
       #);
     <B>g</B><A name="putFormat.1:g.2(488)"></A><A name="g.2(488)"></A>: marker (* insert the real in plain style *)
       (# mark:: (# do 'g'-&gt;value #);
          value: @real
       enter value
       ...  
       #);
     <B>uG</B><A name="putFormat.1:uG.2(489)"></A><A name="uG.2(489)"></A>: marker (* insert the real in plain style and upcase 'E' *)
       (# mark:: (# do 'G'-&gt;value #);
          value: @real
       enter value
       ...  
       #);
     <B>c</B><A name="putFormat.1:c.2(490)"></A><A name="c.2(490)"></A>: marker (* insert the char *)
       (# mark:: (# do 'c'-&gt;value #);
          value: @char;
          putc: @(* Private *)...  
       enter value
       do putc
       #);
     <B>s</B><A name="putFormat.1:s.2(491)"></A><A name="s.2(491)"></A>: marker (* insert the text *)
       (# mark:: (# do 's'-&gt;value #);
          value: ^text;
          puts: @(* Private *)...
       enter value[]
       do puts
       #);
     <B>n</B><A name="putFormat.1:n.2(492)"></A><A name="n.2(492)"></A>: marker
       (* return the length of the result string until this point *)
       (# mark:: (# do 'n'-&gt;value #);
          value: @integer
       ...  
       exit value
       #);
     <B>match</B><A name="putFormat.1:match.2(493)"></A><A name="match.2(493)"></A>:: (* private *)
       (# ... #)
  do INNER putFormat
  #);

<B>formatter</B><A name="formatter.1(494)"></A>: (* superpattern for putFormat and getFormat *)
  (# <B>illegalFormat</B><A name="formatter.1:illegalFormat.2(495)"></A><A name="illegalFormat.2(495)"></A>:&lt; exception
       (# mark: @char
       enter mark
       ...
       #);
     <B>missingMarker</B><A name="formatter.1:missingMarker.2(496)"></A><A name="missingMarker.2(496)"></A>:&lt; exception
       (# mark: @char
       enter mark
       ...
       #);
     <B>missingField</B><A name="formatter.1:missingField.2(497)"></A><A name="missingField.2(497)"></A>:&lt; exception
       (# ... #);
     <B>inputError</B><A name="formatter.1:inputError.2(498)"></A><A name="inputError.2(498)"></A>:&lt; exception
       (# chFound, chExpected: @char
       enter (chFound, chExpected)
       ...
       #);
     <B>scanForMarker</B><A name="formatter.1:scanForMarker.2(499)"></A><A name="scanForMarker.2(499)"></A>: (* Private *)
       (# mark:&lt; charValue;
          formatEOS:&lt; exception;
          fieldWidth, precisionSpec: @integer;
          leftFlag, signedFlag, blankFlag,
          alternativeFlag, zeroFlag, longFlag: @boolean
       ...
       #);
     <B>match</B><A name="formatter.1:match.2(500)"></A><A name="match.2(500)"></A>:&lt; (* private *)
       (# ch: @char
       enter ch
       do INNER match
       #);
     <B>private</B><A name="formatter.1:private.2(501)"></A><A name="private.2(501)"></A>: @...;
     <B>formatStr</B><A name="formatter.1:formatStr.2(502)"></A><A name="formatStr.2(502)"></A>: ^text
  enter formatStr[]
  ...
  exit this(stream)[]
  #);

--- lib: attributes ---
   
<B>getFormat</B><A name="getFormat.1(503)"></A>: keyboard.getFormat(# do INNER getFormat #);

<B>putFormat</B><A name="putFormat.1(504)"></A>: screen.putFormat(# do INNER putFormat #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE border=0 width=100%>
<TR><TD><ADDRESS>Interface Description</ADDRESS></TD>
<SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT>
</TABLE>
<P></P>
<A HREF="random.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="numberio.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
