<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>File Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="file">File Interface</A></H1>

<PRE CLASS=interface>
ORIGIN 'betaenv';
LIB_DEF 'file' '../lib';
BODY 'private/filebody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1984-96
 *       All rights reserved.
 *
 * The BETA interface to disk-entries in a hierarchic file system
 * files, and directories is organised as follows:
 * 
 *   DiskEntry:     Machine independent interface to entries like
 *                  file and directories on the disk 
 *                  (file 'file.bet').
 *   UnixEntry:     Unix specific specialization of DiskEntry 
 *                  (file 'unixfile.bet').
 *   MacEntry:      Macintosh specific specialization of DiskEntry 
 *                  (file 'macfile.bet').
 * 
 *   File:          Machine independent interface to disk files. Is  
 *                  a specialization of Stream (file 'betaenv.bet'),
 *                  and contains a DiskEntry (file 'file.bet').
 *   UnixFile:      Unix specific specialization of File, which 
 *                  contains a UnixEntry (file 'unixfile.bet').
 *   MacFile:       Macintosh  specific specialization of File,
 *                   which contains a MacEntry (file 'macfile.bet').
 *    
 *   Directory:     Machine independent interface to 
 *                  directories/folders. Contains a DiskEntry 
 *                  (file 'directory.bet').
 *   UnixDirectory: Unix specific specialization of Directory, 
 *                  which contains a UnixEntry 
 *                  (file 'unixdirectory.bet').
 *   MacDirectory:  Macintosh specific specialization of Directory,
 *                  which contains a MacEntry 
 *                  (file 'macdirectory.bet').
 *)
-- LIB: Attributes --
<B>DiskEntry</B><A name="DiskEntry.1(550)"></A>:
  (* Pattern describing various attributes of disk-entries like files
   * and directories in a hierarchic file system
   *)
  (# &lt;&lt;SLOT DiskEntryLib: attributes&gt;&gt;;
     
     (* DISK ENTRY EXCEPTIONS *)
     <B>DiskEntryException</B><A name="DiskEntry.1.DiskEntryException.2(551)"></A><A name="DiskEntryException.2(551)"></A>: Exception
       (* General exception for disk entries *)
       (# ... #);
     <B>DiskEntryExistsException</B><A name="DiskEntry.1.DiskEntryExistsException.2(552)"></A><A name="DiskEntryExistsException.2(552)"></A>: DiskEntryException
       (* Raised if a test for disk entry existence has
        * failed. Message: "Test for disk entry existence failed.",
        * and an indication of why it failed.
        *)
       (# ... #);
     <B>DiskEntryModtimeException</B><A name="DiskEntry.1.DiskEntryModtimeException.2(553)"></A><A name="DiskEntryModtimeException.2(553)"></A>: DiskEntryException
       (* Raised if examination or setting of disk entry modtime has failed.
        * Message: "Examination/setting of disk entry modtime failed.", and an
        * indication of why it failed.
        *)
       (# ... #);
     <B>DiskEntryTouchException</B><A name="DiskEntry.1.DiskEntryTouchException.2(554)"></A><A name="DiskEntryTouchException.2(554)"></A>: DiskEntryException
       (* Raised if touch of a disk entry has failed. Message: "Touch
        * of disk entry failed.", and an indication of why it failed.
        *)
       (# ... #);
     <B>DiskEntryRenameException</B><A name="DiskEntry.1.DiskEntryRenameException.2(555)"></A><A name="DiskEntryRenameException.2(555)"></A>: DiskEntryException
       (* Raised if rename of a disk entry has failed. Message:
        * "Rename of disk entry failed.", and an indication of why it
        * failed.
        *)
       (# ... #);
     <B>pathDesc</B><A name="DiskEntry.1.pathDesc.2(556)"></A><A name="pathDesc.2(556)"></A>:&lt;
       (* A virtual descriptor for the full or relative path of
        * THIS(DiskEntry)
        *)
       (# <B>head</B><A name="DiskEntry.1.pathDesc.2.head.3(557)"></A><A name="head.3(557)"></A>:&lt;
            (* The head of the path, e.g. head of '/usr/smith/foo.bet'
             * is '/usr/smith'
             *)
            (# h: ^text
            ... 
            exit h[] 
            #);
          <B>nameDesc</B><A name="DiskEntry.1.pathDesc.2.nameDesc.3(558)"></A><A name="nameDesc.3(558)"></A>:&lt; 
            (* The actual name-part of the path, e.g. name part of
             * '/usr/smith/foo.bet' is 'foo.bet'
             *) 
            (# <B>prefix</B><A name="DiskEntry.1.pathDesc.2.nameDesc.3.prefix.4(559)"></A><A name="prefix.4(559)"></A>:&lt;
                 (* exits the prefix part of the name, i.e. what is
                  * before the last dot (.), e.g 'foo' for 'foo.bet'
                  *)
                 (# p: ^text 
                 ... 
                 exit p[]
                 #);
               <B>extension</B><A name="DiskEntry.1.pathDesc.2.nameDesc.3.extension.4(560)"></A><A name="extension.4(560)"></A>:&lt;
                 (* exits the extension part of the name, i.e. what
                  * is after the last dot (.), e.g. 'bet' for 'foo.bet'
                  *)
                 (# e: ^text 
                 ... 
                 exit e[]
                 #);
               <B>suffix</B><A name="DiskEntry.1.pathDesc.2.nameDesc.3.suffix.4(561)"></A><A name="suffix.4(561)"></A>:&lt;
                 (* like extension, but includes the dot (.),
                  * e.g. '.bet' for 'foo.bet'
                  *)
                 (# s: ^text
                 ...
                 exit s[]
                 #);
               <B>get</B><A name="DiskEntry.1.pathDesc.2.nameDesc.3.get.4(562)"></A><A name="get.4(562)"></A>:&lt;
                 (* exits "prefix.extension" *)
                 (# n: ^text 
                 ... 
                 exit n[]
                 #);
            exit get
            #);
          <B>name</B><A name="DiskEntry.1.pathDesc.2.name.3(563)"></A><A name="name.3(563)"></A>: @nameDesc;
          <B>set</B><A name="DiskEntry.1.pathDesc.2.set.3(564)"></A><A name="set.3(564)"></A>:&lt; 
            (* set the entire path *)
            (# p: ^text 
            enter p[]
            ... 
            #);
          <B>get</B><A name="DiskEntry.1.pathDesc.2.get.3(565)"></A><A name="get.3(565)"></A>:&lt; 
            (* get the entire path *)
            (# p: ^text 
            ... 
            exit p[]
            #);
       enter set
       do INNER
       exit get
       #);
     <B>path</B><A name="DiskEntry.1.path.2(566)"></A><A name="path.2(566)"></A>: @pathDesc;
     <B>exists</B><A name="DiskEntry.1.exists.2(567)"></A><A name="exists.2(567)"></A>: BooleanValue
       (* exits a boolean indicating whether the disk entry
        * corresponding to the current setting of path actually exists
        *)
       (# error:&lt; DiskEntryExistsException;
       ...
       #);
     <B>modtime</B><A name="DiskEntry.1.modtime.2(568)"></A><A name="modtime.2(568)"></A>: 
       (* exits an integer denoting the (system) time of the last
        *         modification
        *)
       (# time: @integer;
          error:&lt;DiskEntryModTimeException;
       enter (# enter time ... #)
       exit (# ... exit time #)
       #); 
     <B>touch</B><A name="DiskEntry.1.touch.2(569)"></A><A name="touch.2(569)"></A>:
       (* Updates the modtime to the current (system) time. *)
       (# error:&lt; DiskEntryTouchException;
       ...
       #);
     <B>rename</B><A name="DiskEntry.1.rename.2(570)"></A><A name="rename.2(570)"></A>:
       (* Rename the disk entry. Changes the physical disk entry and
        * updates THIS(DiskEntry).path
        *)
       (# newpath: ^text;
          error:&lt; DiskEntryRenameException;
       enter newpath[]
       ...
       #);
     <B>size</B><A name="DiskEntry.1.size.2(571)"></A><A name="size.2(571)"></A>: IntegerValue
       (* exits the size of THIS(DiskEntry) in bytes *)
       (# error:&lt;DiskEntryException;
       ... 
       #);
     <B>readable</B><A name="DiskEntry.1.readable.2(572)"></A><A name="readable.2(572)"></A>: BooleanValue
       (* exits true if THIS(DiskEntry) can be read *)
       (# error:&lt; DiskEntryException;
       ... 
       #);
     <B>writeable</B><A name="DiskEntry.1.writeable.2(573)"></A><A name="writeable.2(573)"></A>: BooleanValue
       (* exits true if THIS(DiskEntry) can be written to *)
       (# error:&lt; DiskEntryException;
          checkwrite: @...; 
       do checkwrite
       #);
     <B>isFile</B><A name="DiskEntry.1.isFile.2(574)"></A><A name="isFile.2(574)"></A>: BooleanValue
       (* True if THIS(DiskEntry) is a regular file *)
       (# error:&lt; DiskEntryException;
       ...
       #);
     <B>isDirectory</B><A name="DiskEntry.1.isDirectory.2(575)"></A><A name="isDirectory.2(575)"></A>: BooleanValue
       (* True if THIS(DiskEntry) is a directory *)
       (# error:&lt;DiskEntryException;
       ...
       #);
     
     <B>private</B><A name="DiskEntry.1.private.2(576)"></A><A name="private.2(576)"></A>: @...
  do INNER
  #); (* DiskEntry *)

(* Constants used for specifying mode to File.SetPos. *)
<B>FromBeginning</B><A name="FromBeginning.1(577)"></A>:   
  (* Seeks relative to the beginning of a file.  Corresponds to
   * absolute positions in File[0:File.Length-1].
   *)
  (# exit 0 #);
<B>FromCurrent</B><A name="FromCurrent.1(578)"></A>:  
  (* Seeks relative to the current position.   *)
  (# exit 1 #); 
<B>FromEnd</B><A name="FromEnd.1(579)"></A>:          
  (* Seeks relative to the end of a file. *)
  (# exit 2 #);

<B>File</B><A name="File.1(580)"></A>: Stream
  (* Generalization of disk file.  Describes the stream aspects of
   * files, providing buffered I/O, and contains a DiskEntry object
   * describing the other properties of a file.
   *)
  (# &lt;&lt;SLOT FileLib: attributes&gt;&gt;;
     
     <B>EntryDesc</B><A name="File.1.EntryDesc.2(581)"></A><A name="EntryDesc.2(581)"></A>:&lt; DiskEntry;
     <B>Entry</B><A name="File.1.Entry.2(582)"></A><A name="Entry.2(582)"></A>: @EntryDesc
       (* The item holding most characterizing attributes of
        * THIS(file)
        *);
     <B>name</B><A name="File.1.name.2(583)"></A><A name="name.2(583)"></A>: @
       (* convenient interface to entry.path *)
       (# read:
            (* Reads the file name from the Keyboard *)
            (# ... #);
       enter entry.path
       exit entry.path
       #);
     <B>Put</B><A name="File.1.Put.2(584)"></A><A name="Put.2(584)"></A>::&lt;  (# ... #);
     <B>Get</B><A name="File.1.Get.2(585)"></A><A name="Get.2(585)"></A>::&lt;  (# ... #);
     <B>Peek</B><A name="File.1.Peek.2(586)"></A><A name="Peek.2(586)"></A>::&lt; (# ... #);
     <B>PutText</B><A name="File.1.PutText.2(587)"></A><A name="PutText.2(587)"></A>::&lt; (# ... #);
     <B>GetAtom</B><A name="File.1.GetAtom.2(588)"></A><A name="GetAtom.2(588)"></A>::&lt; (# ... #);
     <B>GetLine</B><A name="File.1.GetLine.2(589)"></A><A name="GetLine.2(589)"></A>::&lt; (# ... #);
     <B>Length</B><A name="File.1.Length.2(590)"></A><A name="Length.2(590)"></A>::&lt;
       (* Returns the byte size of THIS(file). Notice that this is
        * not always the same as entry.size, which is how many bytes
        * THIS(file) occupies on the disk
        *)
       (# ... #);
     <B>GetPos</B><A name="File.1.GetPos.2(591)"></A><A name="GetPos.2(591)"></A>::&lt;
       (* Returns current position of THIS(File) *)
       (# ... #);
     <B>SetPos</B><A name="File.1.SetPos.2(592)"></A><A name="SetPos.2(592)"></A>::&lt;
       (* Sets position on THIS(file).  Enters position and mode. See
        * above for definition of constants to use as mode,
        * FromBeginning, FromCurrent, FromEnd.  Returns the absolute
        * position seeked to [0..File.Length-1].
        *)
       (# mode,newpos: @integer
       enter mode
       ... 
       exit newpos
       #);
     <B>Eos</B><A name="File.1.Eos.2(593)"></A><A name="Eos.2(593)"></A>::&lt; (# ... #);
     <B>touch</B><A name="File.1.touch.2(594)"></A><A name="touch.2(594)"></A>: entry.touch
       (* If the disk entry does not exist, an empty file will be
        * created.
        *)
       (# ... #);
     <B>delete</B><A name="File.1.delete.2(595)"></A><A name="delete.2(595)"></A>:
       (* Deletes THIS(File) *)
       (# ... #);
     <B>binary</B><A name="File.1.binary.2(596)"></A><A name="binary.2(596)"></A>:&lt; booleanvalue
       (* THIS(File) is binary if value is true. On some systems a
        * non-binary (e.g. textual) file may behave differently, than
        * a binary file. A binary file is always treated as raw bytes,
        * whereas a non-binary file may treat some characters, notably
        * the end-of-line marker, differently.
        *);
     <B>openRead</B><A name="File.1.openRead.2(597)"></A><A name="openRead.2(597)"></A>:
       (* opens THIS(File) for reading, starting at the beginning *)
       (# ... #);
     <B>openWrite</B><A name="File.1.openWrite.2(598)"></A><A name="openWrite.2(598)"></A>:
       (* Opens THIS(File) for writing.  truncates the contents of
        * the disk file if it already existed, and creates the disk
        * file if not
        *)
       (# ... #);
     <B>openAppend</B><A name="File.1.openAppend.2(599)"></A><A name="openAppend.2(599)"></A>:
       (* Opens THIS(File) for writing at the end.  Setpos cannot be
        * used to write other places than at the end.  Creates the
        * file if it did not exist.
        *)
       (# ... #);
     <B>openReadWrite</B><A name="File.1.openReadWrite.2(600)"></A><A name="openReadWrite.2(600)"></A>:
       (* Opens THIS(File) for both reading and writing.  The file is
        * positioned at the beginning. To switch between writing and
        * reading an intermediate setpos may be necessary.
        *)
       (# ... #);
     <B>openReadAppend</B><A name="File.1.openReadAppend.2(601)"></A><A name="openReadAppend.2(601)"></A>:
       (* Like OpenReadWrite, but positiones at the end *)
       (# ... #);
     <B>flush</B><A name="File.1.flush.2(602)"></A><A name="flush.2(602)"></A>: 
       (* Flushes THIS(File). Affects only files opened for output *)
       (# ... #);
     <B>close</B><A name="File.1.close.2(603)"></A><A name="close.2(603)"></A>:  (* Closes THIS(File) *)
       (# ... #);    
     
     (* FILE EXCEPTIONS *)
     
     <B>FileException</B><A name="File.1.FileException.2(604)"></A><A name="FileException.2(604)"></A>: StreamException
       (* General File exception *)
       (# m: ^text
       enter m[]
       ...
       #);
     <B>OpenException</B><A name="File.1.OpenException.2(605)"></A><A name="OpenException.2(605)"></A>: FileException
       (* Raised if opening of a file has failed. Message: "Cannot
        *         open file".
        *)
       (# ... #);
     <B>AccessError</B><A name="File.1.AccessError.2(606)"></A><A name="AccessError.2(606)"></A>:&lt; OpenException
       (* Raised on attempt to access a file with insufficient
        * privilegies.  Message: "Insufficient access privilegies".
        *)
       (# ... #);
     <B>WriteError</B><A name="File.1.WriteError.2(607)"></A><A name="WriteError.2(607)"></A>:&lt; FileException
       (* Raised from Put, PutText and Flush on attempt to write on a
        * non-existing block. Message: "Write block error".
        *)
       (# ... #);
     <B>ReadError</B><A name="File.1.ReadError.2(608)"></A><A name="ReadError.2(608)"></A>:&lt; FileException
       (* Raised from Get and Peek on attempt to read a non-existing
        * block. Message: "Read block error".
        *)
       (# ... #);
     <B>EOSerror</B><A name="File.1.EOSerror.2(609)"></A><A name="EOSerror.2(609)"></A>::&lt; (# ... #);
     <B>NoSuchFileError</B><A name="File.1.NoSuchFileError.2(610)"></A><A name="NoSuchFileError.2(610)"></A>:&lt; FileException
       (* Raised on attempt to open a non-existing file. Message:
        * "File does not exist"
        *)
       (# ... #);
     <B>FileExistsError</B><A name="File.1.FileExistsError.2(611)"></A><A name="FileExistsError.2(611)"></A>:&lt; FileException
       (* Raised when creating an already existing file. Message:
        * "File does already exist".
        *)
       (# ... #);
     <B>NoSpaceError</B><A name="File.1.NoSpaceError.2(612)"></A><A name="NoSpaceError.2(612)"></A>:&lt; FileException
       (* Raised when the file system is full. Message: "File system
        * is full".
        *)
       (# ... #);
     <B>OtherError</B><A name="File.1.OtherError.2(613)"></A><A name="OtherError.2(613)"></A>:&lt; FileException
       (* Raised when errors other than the above occur *)
       (# ... #);
     <B>private</B><A name="File.1.private.2(614)"></A><A name="private.2(614)"></A>: @ ...; 
     <B>getRep</B><A name="File.1.getRep.2(615)"></A><A name="getRep.2(615)"></A>:
       (* OBSOLETE - only supplied for compatibility. 
        * The operation getBytes from binfile should be used instead.
        *)
       (# repAdr (* @@ rep[inx]: start address *),
          length (* max. no. of elements to read *): @integer;
       enter(repAdr,length)
       ...
       exit(length div 4)
       #);
     <B>putRep</B><A name="File.1.putRep.2(616)"></A><A name="putRep.2(616)"></A>:
       (* OBSOLETE - only supplied for compatibility. 
        * The operation putBytes from binfile should be used instead.
        *)
       (# repAdr (* @@rep[inx]: start address *),
          length (* no. of rep-elements to be and was written
                  *): @integer;
       enter(repAdr,length)
       ...
       exit (length div 4)
       #);
  #)
</PRE>
<TABLE BORDER=0 ALIGN=RIGHT>
<TR>
<TD>
<A HREF="http://validator.w3.org/check/referer">
<IMG BORDER=0 SRC="../../images/vh40.gif" ALT="Valid HTML 4.0!" HEIGHT=31 WIDTH=88>
</A>
</TD>
</TR>
</TABLE>
<BR CLEAR=right>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>File Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size=-1>&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
