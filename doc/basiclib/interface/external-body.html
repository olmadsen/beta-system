<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>External Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript">
<!--
    CheckParent("external");
//-->
</SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="external">External Interface</A></H1>

<PRE CLASS=interface>
ORIGIN 'betaenv';
LIB_DEF 'external' '../lib';
-- CStructLib: attributes---
(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-99
 *       All rights reserved.
 *
 ****** Patterns for external interface *****
 * 
 * In CStructLib, the operations on a cStruct are defined.
 * The pattern ExternalRecord is an interface to e.g. CStruct objects
 * allocated from C or other external languages.
 *)
<B>GetByte</B><A name="GetByte.1(518)"></A>: 
  (# byteno: @int32;
  enter byteno-&gt;chk
  exit byteNo -&gt; R.%getByte
  #);
<B>PutByte</B><A name="PutByte.1(519)"></A>: 
  (# val: @int8;
     byteno: @int32;
  enter(byteno,val) 
  do byteno-&gt;chk;
     (val,byteno) -&gt;R.%putbyte
  #);
<B>GetShort</B><A name="GetShort.1(520)"></A>: 
  (# byteno: @int32;
  enter byteno-&gt;chk 
  exit (byteno div 2) -&gt;R.%getShort
  #);
<B>PutShort</B><A name="PutShort.1(521)"></A>: 
  (# val: @int16;
     byteno: @int32;
  enter (byteno,val) 
  do byteno-&gt;chk;
     (val,byteno div 2) -&gt; R.%putShort
  #);
<B>GetSignedShort</B><A name="GetSignedShort.1(522)"></A>: 
  (# byteno: @int32;
  enter byteno-&gt;chk 
  exit (byteno div 2) -&gt;R.%getSignedShort
  #);
<B>GetLong</B><A name="GetLong.1(523)"></A>: 
  (# byteno: @int32;
  enter byteno-&gt;chk
  exit (byteno div 4) -&gt;R.%getLong
  #);
<B>PutLong</B><A name="PutLong.1(524)"></A>: 
  (# val: @int32;
     byteno: @int32
  enter (byteno,val)
  do byteno-&gt;chk; 
     (val,byteno div 4) -&gt;R.%putLong
  #);

<B>CStructField</B><A name="CStructField.1(525)"></A>: 
  (* Used for declaring CStruct fields *)
  (# pos:&lt; IntegerObject; 
     p: @pos; 
  #);
<B>Byte</B><A name="Byte.1(526)"></A>: CStructField
  (# set: @(# val: @int8 enter val do (val,p) -&gt;R.%putByte #);
  enter set
  exit p -&gt;R.%getByte
  #);
<B>Short</B><A name="Short.1(527)"></A>: CStructField
  (# set: @(# val: @int16 enter val do (val,p div 2) -&gt;R.%putShort #);
  enter set
  exit (p div 2) -&gt;R.%getShort
  #);
<B>SignedShort</B><A name="SignedShort.1(528)"></A>: CStructField
  (# set: @(# val: @int16 enter val do (val,p div 2) -&gt;R.%putShort #);
  enter set
  exit (p div 2) -&gt;R.%getSignedShort
  #);
<B>Long</B><A name="Long.1(529)"></A>: CStructField
  (# set: @(# val: @int32 enter val do (val,p div 4) -&gt;R.%putLong #);
  enter set
  exit (p div 4)-&gt;R.%getLong
  #);

--LIB: attributes--

(* Various C functions *)
<B>malloc</B><A name="malloc.1(530)"></A>: External
  (# <B>size</B><A name="malloc.1.size.2(531)"></A><A name="size.2(531)"></A>: @integer;
     <B>ptr</B><A name="malloc.1.ptr.2(532)"></A><A name="ptr.2(532)"></A>: @integer;
  enter size
  exit ptr
  #);
<B>memcpy</B><A name="memcpy.1(533)"></A>: external
  (# <B>s1</B><A name="memcpy.1.s1.2(534)"></A><A name="s1.2(534)"></A>,<B> s2</B><A name="memcpy.1.s2.2(535)"></A><A name="s2.2(535)"></A>,<B> nbytes</B><A name="memcpy.1.nbytes.2(536)"></A><A name="nbytes.2(536)"></A>: @int32;
  enter (s1, s2, nbytes)
  exit s1
  #);

<B>ExternalRecord</B><A name="ExternalRecord.1(537)"></A>: 
  (* Super-pattern for describing externally allocated record-structures.
   * A call to e.g. a C routine may often return a pointer to a CStruct.
   * By assigning such a pointer to the ptr-field of an externalRecord 
   * object it is possible to interface to such an external CStruct.
   * Notice the difference to the CStruct pattern, which is typically used
   * to *provide* external code with a structure allocated in BETA.
   *)
  (# <B>ptr</B><A name="ExternalRecord.1.ptr.2(538)"></A><A name="ptr.2(538)"></A>: @int32; (* pointer to the externally allocated record *)
     <B>GetByte</B><A name="ExternalRecord.1.GetByte.2(539)"></A><A name="GetByte.2(539)"></A>: 
       (# byteno: @int32;
       enter byteno
       exit %getByteAt (ptr+byteno)
       #);
     <B>PutByte</B><A name="ExternalRecord.1.PutByte.2(540)"></A><A name="PutByte.2(540)"></A>: 
       (# val: @int8;
          byteno: @int32;
       enter(byteno,val)
       do val %putByteAt (ptr+byteno)
       #);
     <B>GetShort</B><A name="ExternalRecord.1.GetShort.2(541)"></A><A name="GetShort.2(541)"></A>: 
       (# byteno: @int32;
       enter byteno
       exit %getShortAt (ptr+byteno)
       #);
     <B>GetSignedShort</B><A name="ExternalRecord.1.GetSignedShort.2(542)"></A><A name="GetSignedShort.2(542)"></A>: 
       (# byteno: @int32;
       enter byteno
       exit %getSignedShortAt (ptr+byteno)
       #);
     <B>PutShort</B><A name="ExternalRecord.1.PutShort.2(543)"></A><A name="PutShort.2(543)"></A>: 
       (# val: @int16;
          byteno: @int32;
       enter(byteno,val)
       do val %putShortAt (ptr+byteno)
       #);
     <B>GetLong</B><A name="ExternalRecord.1.GetLong.2(544)"></A><A name="GetLong.2(544)"></A>: 
       (# byteno: @int32
       enter byteno
       exit %getLongAt (ptr+byteno)
       #);
     <B>PutLong</B><A name="ExternalRecord.1.PutLong.2(545)"></A><A name="PutLong.2(545)"></A>: 
       (# val: @int32;
          byteno: @int32
       enter(byteno,val)
       do val %putLongAt (ptr+byteno)
       #);
     
     <B>ExternalRecordField</B><A name="ExternalRecord.1.ExternalRecordField.2(546)"></A><A name="ExternalRecordField.2(546)"></A>: 
       (* For declaring fields in ExternalRecords *)
       (# pos:&lt; IntegerValue; 
          p: @pos;
       #);
     <B>Byte</B><A name="ExternalRecord.1.Byte.2(547)"></A><A name="Byte.2(547)"></A>: ExternalRecordField
       (# set: @(# val: @int8 enter val do val %putByteAt (ptr+p) #)
       enter set
       exit %getByteAt (ptr+p)
       #);
     <B>Short</B><A name="ExternalRecord.1.Short.2(548)"></A><A name="Short.2(548)"></A>: ExternalRecordField
       (# set: @(# val: @int16 enter val do val %putShortAt (ptr+p) #);
       enter set
       exit %getShortAt (ptr+p)
       #);
     <B>SignedShort</B><A name="ExternalRecord.1.SignedShort.2(549)"></A><A name="SignedShort.2(549)"></A>: ExternalRecordField
       (# set: @(# val: @int16 enter val do val %putShortAt (ptr+p) #);
       enter set
       exit %getSignedShortAt (ptr+p)
       #);
     <B>Long</B><A name="ExternalRecord.1.Long.2(550)"></A><A name="Long.2(550)"></A>: ExternalRecordField
       (# val: @int32;
          set: @(# enter val do val %putLongAt (ptr+p) #);
       enter set
       exit %getLongAt (ptr+p)
       #);
     <B>DoubleLong</B><A name="ExternalRecord.1.DoubleLong.2(551)"></A><A name="DoubleLong.2(551)"></A>: ExternalRecordField
       (# v1,v2: @int32; 
          set: @(# enter(v1,v2) 
                do v1 %putLongAt (ptr+p);
                   v2 %putLongAt (ptr+p+4);
                #);
       enter set
       exit (%getLongAt (ptr+p), %getLongAt (ptr+p+4))
       #);
  enter ptr
  do INNER
  exit ptr
  #) (* ExternalRecord *);

<B>ExternalRepetition</B><A name="ExternalRepetition.1(552)"></A>: ExternalRecord
  (# <B>elementSize</B><A name="ExternalRepetition.1.elementSize.2(553)"></A><A name="elementSize.2(553)"></A>:&lt;integerValue;
     <B>init</B><A name="ExternalRepetition.1.init.2(554)"></A><A name="init.2(554)"></A>:
       (# enter new #);
     <B>new</B><A name="ExternalRepetition.1.new.2(555)"></A><A name="new.2(555)"></A>: 
       (# newrange: @int32
       enter newrange
       do free;
          newrange-&gt;range;
       #);
     <B>extend</B><A name="ExternalRepetition.1.extend.2(556)"></A><A name="extend.2(556)"></A>:
       (# extra: @int32;
          newptr, newrange, size: @int32;
          
       enter extra
       do (* is realloc available on all platforms? *)
          elementSize-&gt;size;
          (*'EXTEND: elementsize: ' -&gt; puttext;
           * elementsize -&gt; putint; ', range.r: ' -&gt; puttext;
           * range.r-&gt;putint; newline;
           *)
          range.r+extra -&gt; newrange;
          size*newrange -&gt; malloc -&gt; newptr;
          (if newPtr=0 then
              'ExternalRepetition.extend: malloc failed' -&gt; screen.putline;
           else
              (if ptr&lt;&gt;0 then
                  (* 'memcpy ' -&gt; puttext; size*range.r-&gt;putint; 
                   * ' bytes.'-&gt;putline;
                   *)
                  (newptr, ptr, size*range.r) -&gt; memcpy;
                  free;
              if);
              newptr-&gt;ptr;
              newrange -&gt; range.r;
          if);
       #);
     <B>range</B><A name="ExternalRepetition.1.range.2(557)"></A><A name="range.2(557)"></A>: @
       (# r: @int32;
       enter (# r2: @int32 enter r2 do r2-r-&gt;extend #)
       exit r
       #);
     <B>free</B><A name="ExternalRepetition.1.free.2(558)"></A><A name="free.2(558)"></A>:
       (# cfree: External
            (# ptr: @integer
            enter ptr
            do 'free' -&gt; callC;
            #);
       do (if ptr&lt;&gt;0 then ptr -&gt; cfree; 0-&gt;ptr; if);
          0 -&gt; range.r;
       #);
     <B>inxPut</B><A name="ExternalRepetition.1.inxPut.2(559)"></A><A name="inxPut.2(559)"></A>:
       (* Only for elementSize in {1,2,4}. Inx zero based. No index check *)
       (# elm, inx: @int32;
       enter (elm, inx)
       do (if elementSize
           // 1 then elm %putByteAt (ptr+inx) 
           // 2 then elm %putShortAt (ptr+2*inx) 
           // 4 then elm %putLongAt (ptr+4*inx) 
           else
              'ExternalRepetition.inxPut: Not for elementSize='-&gt;screen.puttext;
              elementSize-&gt;screen.putInt; 
              screen.newline;
          if);
       #);
     <B>inxCopy</B><A name="ExternalRepetition.1.inxCopy.2(560)"></A><A name="inxCopy.2(560)"></A>:
       (* Copy elementSize bytes from "element" (which is assumed to 
        * point to data of the same type as the external repetition elements)
        * to index number inx (counting from zero) in the external 
        * repetition. 
        * Can be used for any elementSize.
        *)
       (# inx: @int32;
          element: ^data;
          n: @integer;
       enter (inx, element[])
       do elementSize -&gt; n;
          (ptr+inx*n, %getLongAt(@@element), n) -&gt; memcpy
       #);
     <B>inxGet</B><A name="ExternalRepetition.1.inxGet.2(561)"></A><A name="inxGet.2(561)"></A>:
       (* Only for elementSize in {1,2,4}. Inx zero based. No index check *)
       (# elm, inx: @int32;
       enter (inx)
       do (if elementSize
           // 1 then (%getByteAt (ptr+inx)) -&gt; elm
           // 2 then (%getShortAt (ptr+2*inx)) -&gt; elm;
           // 4 then (%getLongAt (ptr+4*inx)) -&gt; elm;
           else
              'ExternalRepetition.inxGet: Not for elementSize='-&gt;screen.puttext;
              elementSize-&gt;screen.putInt; 
              screen.newline;
          if);
       exit elm
       #);
  #);

<B>makeCBF</B><A name="makeCBF.1(562)"></A>: External
  (* Call this external to install a callback and get
   * an int32 pointer to it.
   *)
  (# <B>pat</B><A name="makeCBF.1.pat.2(563)"></A><A name="pat.2(563)"></A>: ##External;
     <B>cb</B><A name="makeCBF.1.cb.2(564)"></A><A name="cb.2(564)"></A>: @int32;
  enter pat##
  exit cb
  #);

<B>freeCBF</B><A name="freeCBF.1(565)"></A>: External
  (* Call this external with an int32 pointer to an installed
   * callback (obtained via MakeCBF) when it is certain that the
   * callback will NOT be called again.
   * This will free BETA heap space associated with the callback.
   *)
  (# <B>cbf</B><A name="freeCBF.1.cbf.2(566)"></A><A name="cbf.2(566)"></A>: @int32;
  enter cbf
  #)
</PRE>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>External Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
