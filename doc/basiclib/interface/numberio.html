<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Numberio Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="random.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="math.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Prev BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Numberio Interface</H1>
<PRE CLASS=interface>
ORIGIN 'betaenv';
LIB_DEF 'numberio' '../lib';
BODY 'private/numberioBody'
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1992-96
 *       All rights reserved.
 *
 * This fragment implements the following stream operations:
 *    getNumber  * reads a number from THIS(stream).
 *               * The number may be either an integer, 
 *               * a based number or a real number
 *    getBased   * reads a based number from THIS(stream)
 *    getRadix   * reads a based number from THIS(stream), 
 *               * without the 'bbx' part
 *    getInteger * reads an integer number from THIS(stream)
 *    getReal    * reads a real number from THIS(stream)
 *    putReal    * appends a textual rep. of a real value to 
 *               * THIS(stream)
 *    putBased   * appends a textual rep. of a integer value in a 
 *               * particular to THIS(stream).  The textual
 *               * representation in in the given base
 *    putRadix   * as putBased, except that the 'bbx' part is
 *               * not printed
 *    getHex     * similar to getRadix with radix 16, but more efficient.
 *    putHex     * similar to putBased with base 16, but more efficient.
 *    getOctal   * similar to getOctal with base 8, but more efficient.
 *    putOctal   * similar to putBased with base 8, but more efficient.
 *    getBinary  * similar to getRadix with radix 2, but more efficient.
 *    putBinary  * similar to putBased with base 2, but more efficient.
 *    putByteHex    * like putHex, except that it only prints one byte.
 *    putByteBinary * like putBinary, except that it only prints one byte.
 * 
 *    asNumber   * abstract pattern for the following asBased,
 *               * asRadix, and asReal operations
 *    asBased    * returns the based number present in
 *               * THIS(stream)
 *    asRadix    * returns the based number present in
 *               * THIS(stream), without the 'bbx' part
 *    asReal     * returns the real number present in
 *               * THIS(stream)
 * 
 * The corresponding short-cuts for keyboard.getNumber, etc, and 
 * screen.putReal, etc. are also included in this fragment.
 * 
 * Since the asNumber operations does not make sence for keyboard,
 * no short-cuts are defined for these.
 *)
--- StreamLib: attributes ---
<b>getNumber</b><A name="getNumber.1(607)"></A>:  
  (* getNumber reads a number from the current position of 
   * this(stream).
   * The number is either an integer (in base 10), an integer with a
   *  given base, or a real.
   * Integer examples:  10, 0, 123
   * A based integer has the form &lt;base&gt;X&lt;number&gt;. Examples are:
   *    2X101          base=2, number= 4*1 + 2*0 + 1*1 = 5
   *    8X12           base=8, number= 8*1 + 1*2 = 10
   *    16x2A1         base=16, number= 256*2 + 16*10 + 1*1  = 673
   *     0x2A1         base=16, i.e. base=0 is interpreted as base=16
   * Examples of reals are:
   *   3.14, 3.14E-8, 3E+8
   * The following grammar defines the exact syntax of the numbers:
   *
   * N ::= {D}+                        Int             314
   *    |  {D}+ '.' {D}+               real            3.14
   *    |  {D}+ '.' {D}+ 'E' E         real            3.14E8
   *                                   real            3.14E+8
   *                                   real            3.14E-8
   *
   *    |  {D}+  'E' E                 real            3E8
   *                                   real            3E+8
   *                                   real            3E-8
   *    |  'X' {D | L}+                based           2X0101
   *                                   based           8x0845
   *                                   based           16xAF12
   * D ::= {'0' | ... | '9' }
   * L ::= {'A' | ... | 'Z'}
   * E ::= {D}+
   *    |  {D}+ '+' {D}+               
   *    |  {D}+ '-' {D}+
   *    
   * All letters may be in lower or upper case.
   * After the call, the stream is positioned
   * after the first char not in the number.
   *)
  (# <b>integerValue</b><A name="getNumber.1:integerValue.2(608)"></A><A name="integerValue.2(608)"></A>:&lt;
       (* the number has the form
        *     x
        * value contains the integer value
        *)
       integerValuePtn;
     <b>integerValuePtn</b><A name="getNumber.1:integerValuePtn.2(609)"></A><A name="integerValuePtn.2(609)"></A>:
       (# value: @integer enter value do INNER #);
     <b>basedValue</b><A name="getNumber.1:basedValue.2(610)"></A><A name="basedValue.2(610)"></A>:&lt;
       (* the number has the form
        *     bXy
        * base contains the base number
        * value contains the integer value (in base 10)
        *)
       basedValuePtn;
     <b>basedValuePtn</b><A name="getNumber.1:basedValuePtn.2(611)"></A><A name="basedValuePtn.2(611)"></A>:
       (# base,value: @integer enter (base,value) do INNER #);
     <b>realValue</b><A name="getNumber.1:realValue.2(612)"></A><A name="realValue.2(612)"></A>:&lt;
       (* the  number has the form 
        *       x.yEz
        *       l is the number of leading zero's in y. i.e. in
        *       3.0017E-12, x=3, y=17,l=2 and z=-12
        * value contains the real value
        *)
       realValuePtn;
     <b>realValuePtn</b><A name="getNumber.1:realValuePtn.2(613)"></A><A name="realValuePtn.2(613)"></A>:
       (# x,y,l,z: @real; value: @real enter(x,y,l,z,value)
       do INNER #);
     <b>syntaxError</b><A name="getNumber.1:syntaxError.2(614)"></A><A name="syntaxError.2(614)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'getNumber: Syntax error - looking at: "'-&gt;msg.append;
          (if peekCh = ascii.nul then 'NUL'-&gt;msg.puttext
           else peekCh-&gt;msg.put if);
          '"'-&gt;msg.put; INNER #);
     <b>baseError</b><A name="getNumber.1:baseError.2(615)"></A><A name="baseError.2(615)"></A>:&lt; streamException
       (# base: @integer
       enter base
       do 'getNumber: Error in base - looking at: "'-&gt;msg.append; 
          base-&gt;msg.putInt; '"'-&gt;msg.put; INNER #);
     <b>valueError</b><A name="getNumber.1:valueError.2(616)"></A><A name="valueError.2(616)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'getNumber: Illegal value type - looking at: "'-&gt;msg.append;
          peekCh-&gt;msg.put; '"'-&gt;msg.put; INNER #);
     <b>overflow</b><A name="getNumber.1:overflow.2(617)"></A><A name="overflow.2(617)"></A>:&lt; streamException
       (# value: @integer
       do 'getNumber: Overflow in integer- or based-value'-&gt;msg.append;
          INNER
       exit value
       #);
     <b>underflow</b><A name="getNumber.1:underflow.2(618)"></A><A name="underflow.2(618)"></A>:&lt; streamException
       (# value: @integer
       do 'getNumber: Underflow in integer- or based-value'-&gt;msg.append;
          INNER
       exit value
       #);
     <b>getn</b><A name="getNumber.1:getn.2(619)"></A><A name="getn.2(619)"></A>: @...
  do getn;
     INNER getNumber
  #);
<b>getReal</b><A name="getReal.1(620)"></A><A name="getNumber.:_subpatterns.2:getReal.3"></A>: getNumber
  (# <b>r</b><A name="getReal.1:r.2(621)"></A><A name="r.2(621)"></A>: @real;
     <b>realValue</b><A name="getReal.1:realValue.2(622)"></A><A name="realValue.2(622)"></A>::&lt; (# do value-&gt;r #);
  do INNER getReal
  exit r
  #);
<b>getBased</b><A name="getBased.1(623)"></A><A name="getNumber.:_subpatterns.2:getBased.3"></A>: getNumber
  (# <b>i</b><A name="getBased.1:i.2(624)"></A><A name="i.2(624)"></A>,<b> b</b><A name="getBased.1:b.2(625)"></A><A name="b.2(625)"></A>: @integer;
     <b>basedValue</b><A name="getBased.1:basedValue.2(626)"></A><A name="basedValue.2(626)"></A>::&lt; (# do value-&gt;i; base-&gt;b #);
  do INNER getBased
  exit (b,i)
  #);
<b>getInteger</b><A name="getInteger.1(627)"></A><A name="getNumber.:_subpatterns.2:getInteger.3"></A>: getNumber
  (# <b>i</b><A name="getInteger.1:i.2(628)"></A><A name="i.2(628)"></A>: @integer;
     <b>integerValue</b><A name="getInteger.1:integerValue.2(629)"></A><A name="integerValue.2(629)"></A>::&lt; (# do value-&gt;i #);
  do INNER getInteger
  exit i
  #);
<b>getRadix</b><A name="getRadix.1(630)"></A>:
  (* gets a number in the specified radix.  GetRadix is similar to
   * getBased, except that is does NOT expect the 'bbx' prefix
   *)
  (# <b>radix</b><A name="getRadix.1:radix.2(631)"></A><A name="radix.2(631)"></A>,<b> value</b><A name="getRadix.1:value.2(632)"></A><A name="value.2(632)"></A>: @integer;
     <b>radixError</b><A name="getRadix.1:radixError.2(633)"></A><A name="radixError.2(633)"></A>:&lt; streamException
       (# radix: @integer
       enter radix
       ...
       #);
     <b>getr</b><A name="getRadix.1:getr.2(634)"></A><A name="getr.2(634)"></A>: (* private *) @...
  enter radix
  do getr;
     INNER getRadix
  exit value
  #);

<b>putBased</b><A name="putBased.1(635)"></A>:
  (* Takes a number and a base, and prints the number in that base.
   * If base is 0, base 16 is assumed, and the format "0xnnn" is used.
   * If base is negative, 1 or greater that 126, the baseError
   * exception is invoked.
   * 
   * The format is default "bbxnnnn", where "bb" is the base (in
   * decimal), and "nnnn" is the number, printed in the base. "x"
   * separates the two parts.  The format may be controlled by the
   * signed, blankSign, upcase, uppercase, width, adjustLeft,
   * zeroPadding, noBasePrefix, baseWidth and baseZeroPadding variable
   * attributes. If noBasePrefix is true, the "bbx" part is omitted.
   *)
  (# <b>value</b><A name="putBased.1:value.2(636)"></A><A name="value.2(636)"></A>,<b> base</b><A name="putBased.1:base.2(637)"></A><A name="base.2(637)"></A>: @integer;
     <b>baseError</b><A name="putBased.1:baseError.2(638)"></A><A name="baseError.2(638)"></A>:&lt; streamException
       (# base: @integer
       enter base
       do 'putBased: Illegal base: "'-&gt;msg.append; 
          base-&gt;msg.putInt; '"'-&gt;msg.put; INNER #);
     (* The format may be further controlled by the signed, blankSign,
      * width, adjustLeft and zeroPadding variable attributes.  
      * width is extended if it is too small.
      *
      * Examples:
      *   (10,10)-&gt;putBased
      *      yields: '10x10'
      *   (2,5)-&gt;putBased(# do 10-&gt;width; true-&gt;adjustLeft #);
      *      yields: '2x101     '
      *   (2,5)-&gt;putBased(# do 10-&gt;width; true-&gt;zeroPadding #);
      *      yields: '2x00000101'
      *)
     <b>signed</b><A name="putBased.1:signed.2(639)"></A><A name="signed.2(639)"></A>:
       (* If the number is positive, a '+' will always be displayed
        *)
       @boolean;
     <b>blankSign</b><A name="putBased.1:blankSign.2(640)"></A><A name="blankSign.2(640)"></A>:
       (* If the number is positive, a ' ' space is displayed as the
        * sign.  Ignored if signed=true
        *)
       @boolean;
     <b>upcase</b><A name="putBased.1:upcase.2(641)"></A><A name="upcase.2(641)"></A>: @boolean
       (* Specifies whether an upcase 'X' or a lowcase 'x' is the
        * be used in the 'bbx' part.
        *);
     <b>uppercase</b><A name="putBased.1:uppercase.2(642)"></A><A name="uppercase.2(642)"></A>: @boolean
       (* Specifies whether uppercase letters or lowercase letters
        * are used in the 'nnnn' part (for base&gt;9).
        *);
     <b>width</b><A name="putBased.1:width.2(643)"></A><A name="width.2(643)"></A>: (* Minimum width *) @integer;
     <b>adjustLeft</b><A name="putBased.1:adjustLeft.2(644)"></A><A name="adjustLeft.2(644)"></A>: @boolean
       (* Specifies if the number is to be aligned left or right,
        * if padding of spaces is necessary to fill up the specified
        * width.
        *);
     <b>zeroPadding</b><A name="putBased.1:zeroPadding.2(645)"></A><A name="zeroPadding.2(645)"></A>:
       (* width is padded with leading zero instead of spaces.
        * Ignored if adjustLeft=true
        *)
       @boolean;
     <b>noBasePrefix</b><A name="putBased.1:noBasePrefix.2(646)"></A><A name="noBasePrefix.2(646)"></A>: (* If true, the 'bbx' part is omitted *)
       @boolean;
     <b>baseWidth</b><A name="putBased.1:baseWidth.2(647)"></A><A name="baseWidth.2(647)"></A>: (* minimun width for the 'bbx' part *)
       @integer;
     <b>baseZeroPadding</b><A name="putBased.1:baseZeroPadding.2(648)"></A><A name="baseZeroPadding.2(648)"></A>:
       (* baseWidth is padded with leading zero instead of spaces *)
       @boolean;
     <b>format</b><A name="putBased.1:format.2(649)"></A><A name="format.2(649)"></A>:&lt; (# do INNER #);
     <b>putb</b><A name="putBased.1:putb.2(650)"></A><A name="putb.2(650)"></A>: @...
  enter (base, value)
  do INNER putBased; putb
  #);
<b>putReal</b><A name="putReal.1(651)"></A>:
  (* Append a real to THIS(stream). The format may be controlled by
   * the style, signed, blankSign, precision, upcase, width,
   * adjustLeft and zeroPadding variable attributes
   *)
  (# <b>r</b><A name="putReal.1:r.2(652)"></A><A name="r.2(652)"></A>: @real;
     <b>style</b><A name="putReal.1:style.2(653)"></A><A name="style.2(653)"></A>: @integer
       (* Controls the style, and may be one of plain, exp and noexp
        * (noexp is the default)
        *);
     <b>noexp</b><A name="putReal.1:noexp.2(654)"></A><A name="noexp.2(654)"></A>: (* The notation [-]mmm.dddddd is used *)
       (# exit 0 #);
     <b>exp</b><A name="putReal.1:exp.2(655)"></A><A name="exp.2(655)"></A>: (* The notation [-]m.ddddddE[+|-]xx is used *)
       (# exit 1 #);
     <b>plain</b><A name="putReal.1:plain.2(656)"></A><A name="plain.2(656)"></A>:
       (* In this style, precision is the total number of digits in
        * the printed real (not the number of digits in the fraction,
        * as in the other styles).
        * 
        * The exp or noexp style is used, dependent on the value being
        * printed.  Exp style is used only if the exponent is less
        * than -4 or greater than or equal to the precision; otherwise
        * the noexp notation is used.  Trailing zeros are not printed
        * as part of the fractional part and a decimal point is
        * printed if not followed by a digit
        *)
       (# exit 2 #);
     <b>signed</b><A name="putReal.1:signed.2(657)"></A><A name="signed.2(657)"></A>: (* If real is positive, a '+' will always be displayed *)
       @boolean;
     <b>blankSign</b><A name="putReal.1:blankSign.2(658)"></A><A name="blankSign.2(658)"></A>:
       (* If real is positive, a ' ' space is displayed as the sign.
        * Ignored if signed=true
        *)
       @boolean;
     <b>precision</b><A name="putReal.1:precision.2(659)"></A><A name="precision.2(659)"></A>: @integer
       (* The number of d's in the expressions above, default 6 *);
     <b>upcase</b><A name="putReal.1:upcase.2(660)"></A><A name="upcase.2(660)"></A>: @boolean
       (* Specifies whether an upcase 'E' or a lowcase 'e' is the
        * be used in the exp style.
        *);
     <b>width</b><A name="putReal.1:width.2(661)"></A><A name="width.2(661)"></A>: (* Minimum width *)
       @integer;
     <b>adjustLeft</b><A name="putReal.1:adjustLeft.2(662)"></A><A name="adjustLeft.2(662)"></A>: @boolean
       (* Specifies if the number is to be aligned left or right,
        * if padding of spaces is necessary to fill up the specified
        * width.
        *);
     <b>zeroPadding</b><A name="putReal.1:zeroPadding.2(663)"></A><A name="zeroPadding.2(663)"></A>:
       (* width is padded with leading zero instead of spaces.
        * Ignored if adjustLeft=true
        *)
       @boolean;
     (* Examples:
      *   10*pi -&gt; putreal;
      *      yields: '31.415926'
      *   10*pi -&gt; putreal(# do 10-&gt;width; true-&gt;adjustLeft #);
      *      yields: '31.415926   '
      *   10*pi -&gt; putreal(# do exp-&gt;style; true-&gt;upcase #);
      *      yields: '3.1415926E+01'
      *   10*pi -&gt; putreal(# do exp-&gt;style; 2-&gt;precision #);
      *      yields: '3.14e+01'
      *)
     <b>format</b><A name="putReal.1:format.2(664)"></A><A name="format.2(664)"></A>:&lt; (# do INNER #);
     <b>putr</b><A name="putReal.1:putr.2(665)"></A><A name="putr.2(665)"></A>: @...
  enter r
  do 1-&gt;width; 6-&gt;precision; format; INNER putReal; putr
  #);
<b>putRadix</b><A name="putRadix.1(666)"></A><A name="putBased.:_subpatterns.2:putRadix.3"></A>: putBased
  (#
  do true-&gt;noBasePrefix; INNER putRadix 
  #);

<b>putHex</b><A name="putHex.1(667)"></A>:
  (* prints a hexadecimal representation of x (as unsigned word) on
   * this(stream). Similar to
   * (16,x)-&gt;putRadix(# do true-&gt;zeroPadding; 8-&gt;width #)
   * but more efficient.
   *) 
  (# <b>uppercase</b><A name="putHex.1:uppercase.2(668)"></A><A name="uppercase.2(668)"></A>: @boolean;
     <b>width</b><A name="putHex.1:width.2(669)"></A><A name="width.2(669)"></A>: @integer;
     <b>zeroPadding</b><A name="putHex.1:zeroPadding.2(670)"></A><A name="zeroPadding.2(670)"></A>: @boolean;
     <b>x</b><A name="putHex.1:x.2(671)"></A><A name="x.2(671)"></A>: @integer;
     <b>format</b><A name="putHex.1:format.2(672)"></A><A name="format.2(672)"></A>:&lt; (# do INNER #);
     <b>putH</b><A name="putHex.1:putH.2(673)"></A><A name="putH.2(673)"></A>: (*private*)@...
  enter x
  do format; INNER putHex; putH
  #);

<b>putByteHex</b><A name="putByteHex.1(674)"></A>:
  (* prints a hexadecimal representation of byte 'byte' in x (as
   * unsigned word) on this(stream)
   *)
  (# <b>x</b><A name="putByteHex.1:x.2(675)"></A><A name="x.2(675)"></A>: @integer;
     <b>byte</b><A name="putByteHex.1:byte.2(676)"></A><A name="byte.2(676)"></A>: @integer;
     <b>putBH</b><A name="putByteHex.1:putBH.2(677)"></A><A name="putBH.2(677)"></A>: (*private*)@...
  enter (x,byte)
  do INNER putByteHex; putBH
  #);

<b>putOctal</b><A name="putOctal.1(678)"></A>:
  (* prints a octal representation of x (as unsigned word) on
   * this (stream). Similar to
   * (8,x)-&gt;putRadix(# do true-&gt;zeroPadding;  #)
   * but more efficient.
   *)
  (# <b>width</b><A name="putOctal.1:width.2(679)"></A><A name="width.2(679)"></A>: @integer;
     <b>zeroPadding</b><A name="putOctal.1:zeroPadding.2(680)"></A><A name="zeroPadding.2(680)"></A>: @boolean;
     <b>x</b><A name="putOctal.1:x.2(681)"></A><A name="x.2(681)"></A>: @integer;
     <b>format</b><A name="putOctal.1:format.2(682)"></A><A name="format.2(682)"></A>:&lt; (# do INNER #);
     <b>putO</b><A name="putOctal.1:putO.2(683)"></A><A name="putO.2(683)"></A>:(*private*)@...
  enter x
  do format; INNER putOctal; putO;
  #);

<b>putBinary</b><A name="putBinary.1(684)"></A>:
  (* prints a binary representation of x (as unsigned word) on
   * this(stream). Similar to
   * (2,x)-&gt;putRadix(# do true-&gt;zeroPadding; #)
   * but more efficient.
   *)
  (# <b>width</b><A name="putBinary.1:width.2(685)"></A><A name="width.2(685)"></A>: @integer;
     <b>zeroPadding</b><A name="putBinary.1:zeroPadding.2(686)"></A><A name="zeroPadding.2(686)"></A>: @boolean;
     <b>x</b><A name="putBinary.1:x.2(687)"></A><A name="x.2(687)"></A>: @integer;
     <b>format</b><A name="putBinary.1:format.2(688)"></A><A name="format.2(688)"></A>:&lt; (# do INNER #);
     <b>putB</b><A name="putBinary.1:putB.2(689)"></A><A name="putB.2(689)"></A>: (*private*)@...
  enter x
  do format; INNER putBinary; putB
  #);

<b>putByteBinary</b><A name="putByteBinary.1(690)"></A>:
  (* prints a binary representation of byte 'byte' of x (as unsigned
   * word) on this(stream)
   *)
  (# <b>x</b><A name="putByteBinary.1:x.2(691)"></A><A name="x.2(691)"></A>: @integer;
     <b>byte</b><A name="putByteBinary.1:byte.2(692)"></A><A name="byte.2(692)"></A>: @integer;
     <b>putBB</b><A name="putByteBinary.1:putBB.2(693)"></A><A name="putBB.2(693)"></A>: (*private*)@...
  enter (x, byte)
  do INNER putByteBinary; putBB
  #);

<b>getHex</b><A name="getHex.1(694)"></A>:
  (* reads a hexadecimal number from this(stream) and returns the
   * value in x (as unsigned word). Similar to 16-&gt;getRadix but more
   * efficient.
   *)
  (# <b>x</b><A name="getHex.1:x.2(695)"></A><A name="x.2(695)"></A>: @integer;
     <b>noNumberError</b><A name="getHex.1:noNumberError.2(696)"></A><A name="noNumberError.2(696)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'getHex: the number begins with: "'-&gt;msg.append;
          (if peekCh = ascii.nul then 'NUL'-&gt;msg.puttext
           else peekCh-&gt;msg.put if);
          '".  Not a legal hexadecimal digit'-&gt;msg.puttext;
          INNER noNumberError
       #);
     <b>getH</b><A name="getHex.1:getH.2(697)"></A><A name="getH.2(697)"></A>: (*private*)...
  do INNER getHex; getH
  exit x
  #);

<b>getOctal</b><A name="getOctal.1(698)"></A>:
  (* reads a hexadecimal number from this(stream) and returns the
   * value in x (as unsigned word). Similar to 16-&gt;getRadix but more
   * efficient.
   *) 
  (# <b>x</b><A name="getOctal.1:x.2(699)"></A><A name="x.2(699)"></A>: @integer;
    <b>noNumberError</b><A name="getOctal.1:noNumberError.2(700)"></A><A name="noNumberError.2(700)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'getHex: the number begins with: "'-&gt;msg.append;
          (if peekCh = ascii.nul then 'NUL'-&gt;msg.puttext
           else peekCh-&gt;msg.put if);
          '".  Not a legal hexadecimal digit'-&gt;msg.puttext;
          INNER noNumberError
       #);
     <b>getO</b><A name="getOctal.1:getO.2(701)"></A><A name="getO.2(701)"></A>: (*private*)...
  do INNER getOctal; getO
  exit x
  #);

<b>getBinary</b><A name="getBinary.1(702)"></A>:
  (* reads a binary number from this(stream) and returns the value in
   * x (as unsigned word). Similar to 2-&gt;getRadix but more efficient.
   *)
  (# <b>x</b><A name="getBinary.1:x.2(703)"></A><A name="x.2(703)"></A>: @integer;
     <b>noNumberError</b><A name="getBinary.1:noNumberError.2(704)"></A><A name="noNumberError.2(704)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'getBinary: the number begins with: "'-&gt;msg.append;
          (if peekCh = ascii.nul then 'NUL'-&gt;msg.puttext
           else peekCh-&gt;msg.put if);
          '".  Not a legal binary digit'-&gt;msg.puttext;
          INNER noNumberError
       #);
     <b>getB</b><A name="getBinary.1:getB.2(705)"></A><A name="getB.2(705)"></A>: (*private*)...
  do INNER getBinary; getB
  exit x
  #);

<b>asNumber</b><A name="asNumber.1(706)"></A>:
  (# <b>syntaxError</b><A name="asNumber.1:syntaxError.2(707)"></A><A name="syntaxError.2(707)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'asNumber: Syntax error - looking at: "'-&gt;msg.append;
          peekCh-&gt;msg.put; '"'-&gt;msg.put;
          INNER syntaxError
       #);
     <b>baseError</b><A name="asNumber.1:baseError.2(708)"></A><A name="baseError.2(708)"></A>:&lt; streamException
       (# base: @integer
       enter base
       do 'asNumber: Error in base - looking at: "'-&gt;msg.append;
          base-&gt;msg.putInt; '"'-&gt;msg.put;
          INNER baseError
       #);
     <b>valueError</b><A name="asNumber.1:valueError.2(709)"></A><A name="valueError.2(709)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'asNumber: Illegal value type - looking at: "'-&gt;msg.append;
          peekCh-&gt;msg.put; '"'-&gt;msg.put;
          INNER valueError
       #);
  do reset;
     INNER asNumber;
     ScanWhiteSpace; (if not eos then peek-&gt;syntaxError if)
  #);

<b>asReal</b><A name="asReal.1(710)"></A><A name="asNumber.:_subpatterns.2:asReal.3"></A>: asNumber
  (# <b>r</b><A name="asReal.1:r.2(711)"></A><A name="r.2(711)"></A>: @real
    ...
  exit r
  #);
<b>asBased</b><A name="asBased.1(712)"></A><A name="asNumber.:_subpatterns.2:asBased.3"></A>: asNumber
  (# <b>i</b><A name="asBased.1:i.2(713)"></A><A name="i.2(713)"></A>,<b> b</b><A name="asBased.1:b.2(714)"></A><A name="b.2(714)"></A>: @integer
    ...
  exit (b,i)
  #);
<b>asRadix</b><A name="asRadix.1(715)"></A><A name="asNumber.:_subpatterns.2:asRadix.3"></A>: asNumber
  (# <b>radix</b><A name="asRadix.1:radix.2(716)"></A><A name="radix.2(716)"></A>,<b> value</b><A name="asRadix.1:value.2(717)"></A><A name="value.2(717)"></A>: @integer
  enter radix
  ...
  exit value
  #);
<b>asInteger</b><A name="asInteger.1(718)"></A><A name="asNumber.:_subpatterns.2:asInteger.3"></A>: asNumber
  (# <b>i</b><A name="asInteger.1:i.2(719)"></A><A name="i.2(719)"></A>: @integer
    ...
  exit i
  #)

--- lib: attributes ---

<b>getNumber</b><A name="getNumber.1(720)"></A>: keyboard.getNumber
  (# do INNER getNumber #);
<b>getReal</b><A name="getReal.1(721)"></A>: keyboard.getReal
  (# do INNER getReal #);
<b>getBased</b><A name="getBased.1(722)"></A>: keyboard.getBased
  (# do INNER getbased #);
<b>getRadix</b><A name="getRadix.1(723)"></A>: keyboard.getRadix
  (# do INNER getRadix #);
<b>getInteger</b><A name="getInteger.1(724)"></A>: keyboard.getInteger
  (# do INNER getInteger #);

<b>putReal</b><A name="putReal.1(725)"></A>: screen.putReal
  (# do INNER putReal #);
<b>putBased</b><A name="putBased.1(726)"></A>: screen.putBased
  (# do INNER putBased #);
<b>putRadix</b><A name="putRadix.1(727)"></A>: screen.putRadix
  (# do INNER putRadix #);

<b>getHex</b><A name="getHex.1(728)"></A>: keyboard.getHex
  (# do INNER getHex #);
<b>getOctal</b><A name="getOctal.1(729)"></A>: keyboard.getOctal
  (# do INNER getOctal #);
<b>getBinary</b><A name="getBinary.1(730)"></A>: keyboard.getBinary
  (# do INNER getBinary #);

<b>putHex</b><A name="putHex.1(731)"></A>: screen.putHex
  (# do INNER putHex #);
<b>putByteHex</b><A name="putByteHex.1(732)"></A>: screen.putByteHex
  (# do INNER putByteHex #);
<b>putOctal</b><A name="putOctal.1(733)"></A>:screen.putOctal
  (# do INNER putOctal #);
<b>putBinary</b><A name="putBinary.1(734)"></A>: screen.putBinary
  (# do INNER putBinary #);
<b>putByteBinary</b><A name="putByteBinary.1(735)"></A>: screen.putByteBinary
  (# do INNER putByteBinary #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<ADDRESS>Interface Description</ADDRESS>
<P></P>
<A HREF="random.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="math.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Prev BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
