<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Numberio Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="formatio.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="math.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Numberio Interface</H1>
<PRE CLASS=interface>
ORIGIN 'betaenv';
LIB_DEF 'numberio' '../lib';
BODY 'private/numberioBody'
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1992-96
 *       All rights reserved.
 *
 * This fragment implements the following stream operations:
 *    getNumber  * reads a number from THIS(stream).
 *               * The number may be either an integer, 
 *               * a based number or a real number
 *    getBased   * reads a based number from THIS(stream)
 *    getRadix   * reads a based number from THIS(stream), 
 *               * without the 'bbx' part
 *    getInteger * reads an integer number from THIS(stream)
 *    getReal    * reads a real number from THIS(stream)
 *    putReal    * appends a textual rep. of a real value to 
 *               * THIS(stream)
 *    putBased   * appends a textual rep. of a integer value in a 
 *               * particular to THIS(stream).  The textual
 *               * representation in in the given base
 *    putRadix   * as putBased, except that the 'bbx' part is
 *               * not printed
 *    getHex     * similar to getRadix with radix 16, but more efficient.
 *    putHex     * similar to putBased with base 16, but more efficient.
 *    getOctal   * similar to getOctal with base 8, but more efficient.
 *    putOctal   * similar to putBased with base 8, but more efficient.
 *    getBinary  * similar to getRadix with radix 2, but more efficient.
 *    putBinary  * similar to putBased with base 2, but more efficient.
 *    putByteHex    * like putHex, except that it only prints one byte.
 *    putByteBinary * like putBinary, except that it only prints one byte.
 * 
 *    asNumber   * abstract pattern for the following asBased,
 *               * asRadix, and asReal operations
 *    asBased    * returns the based number present in
 *               * THIS(stream)
 *    asRadix    * returns the based number present in
 *               * THIS(stream), without the 'bbx' part
 *    asReal     * returns the real number present in
 *               * THIS(stream)
 * 
 * The corresponding short-cuts for keyboard.getNumber, etc, and 
 * screen.putReal, etc. are also included in this fragment.
 * 
 * Since the asNumber operations does not make sence for keyboard,
 * no short-cuts are defined for these.
 *)
--- StreamLib: attributes ---
<B>getNumber</B><A name="getNumber.1(442)"></A>:  
  (* getNumber reads a number from the current position of 
   * this(stream).
   * The number is either an integer (in base 10), an integer with a
   *  given base, or a real.
   * Integer examples:  10, 0, 123
   * A based integer has the form &lt;base&gt;X&lt;number&gt;. Examples are:
   *    2X101          base=2, number= 4*1 + 2*0 + 1*1 = 5
   *    8X12           base=8, number= 8*1 + 1*2 = 10
   *    16x2A1         base=16, number= 256*2 + 16*10 + 1*1  = 673
   *     0x2A1         base=16, i.e. base=0 is interpreted as base=16
   * Examples of reals are:
   *   3.14, 3.14E-8, 3E+8
   * The following grammar defines the exact syntax of the numbers:
   *
   * N ::= {D}+                        Int             314
   *    |  {D}+ '.' {D}+               real            3.14
   *    |  {D}+ '.' {D}+ 'E' E         real            3.14E8
   *                                   real            3.14E+8
   *                                   real            3.14E-8
   *
   *    |  {D}+  'E' E                 real            3E8
   *                                   real            3E+8
   *                                   real            3E-8
   *    |  'X' {D | L}+                based           2X0101
   *                                   based           8x0845
   *                                   based           16xAF12
   * D ::= {'0' | ... | '9' }
   * L ::= {'A' | ... | 'Z'}
   * E ::= {D}+
   *    |  {D}+ '+' {D}+               
   *    |  {D}+ '-' {D}+
   *    
   * All letters may be in lower or upper case.
   * After the call, the stream is positioned
   * after the first char not in the number.
   *)
  (# <B>integerValue</B><A name="getNumber.1:integerValue.2(443)"></A><A name="integerValue.2(443)"></A>:&lt;
       (* the number has the form
        *     x
        * value contains the integer value
        *)
       integerValuePtn;
     <B>integerValuePtn</B><A name="getNumber.1:integerValuePtn.2(444)"></A><A name="integerValuePtn.2(444)"></A>:
       (# value: @integer enter value do INNER #);
     <B>basedValue</B><A name="getNumber.1:basedValue.2(445)"></A><A name="basedValue.2(445)"></A>:&lt;
       (* the number has the form
        *     bXy
        * base contains the base number
        * value contains the integer value (in base 10)
        *)
       basedValuePtn;
     <B>basedValuePtn</B><A name="getNumber.1:basedValuePtn.2(446)"></A><A name="basedValuePtn.2(446)"></A>:
       (# base,value: @integer enter (base,value) do INNER #);
     <B>realValue</B><A name="getNumber.1:realValue.2(447)"></A><A name="realValue.2(447)"></A>:&lt;
       (* the  number has the form 
        *       x.yEz
        *       l is the number of leading zero's in y. i.e. in
        *       3.0017E-12, x=3, y=17,l=2 and z=-12
        * value contains the real value
        *)
       realValuePtn;
     <B>realValuePtn</B><A name="getNumber.1:realValuePtn.2(448)"></A><A name="realValuePtn.2(448)"></A>:
       (# x,y,l,z: @real; value: @real enter(x,y,l,z,value)
       do INNER #);
     <B>syntaxError</B><A name="getNumber.1:syntaxError.2(449)"></A><A name="syntaxError.2(449)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'getNumber: Syntax error - looking at: "'-&gt;msg.append;
          (if peekCh = ascii.nul then 'NUL'-&gt;msg.puttext
           else peekCh-&gt;msg.put if);
          '"'-&gt;msg.put; INNER #);
     <B>baseError</B><A name="getNumber.1:baseError.2(450)"></A><A name="baseError.2(450)"></A>:&lt; streamException
       (# base: @integer
       enter base
       do 'getNumber: Error in base - looking at: "'-&gt;msg.append; 
          base-&gt;msg.putInt; '"'-&gt;msg.put; INNER #);
     <B>valueError</B><A name="getNumber.1:valueError.2(451)"></A><A name="valueError.2(451)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'getNumber: Illegal value type - looking at: "'-&gt;msg.append;
          peekCh-&gt;msg.put; '"'-&gt;msg.put; INNER #);
     <B>overflow</B><A name="getNumber.1:overflow.2(452)"></A><A name="overflow.2(452)"></A>:&lt; streamException
       (# value: @integer
       do 'getNumber: Overflow in integer- or based-value'-&gt;msg.append;
          INNER
       exit value
       #);
     <B>underflow</B><A name="getNumber.1:underflow.2(453)"></A><A name="underflow.2(453)"></A>:&lt; streamException
       (# value: @integer
       do 'getNumber: Underflow in integer- or based-value'-&gt;msg.append;
          INNER
       exit value
       #);
     <B>getn</B><A name="getNumber.1:getn.2(454)"></A><A name="getn.2(454)"></A>: @...
  do getn;
     INNER getNumber
  #);
<B>getReal</B><A name="getReal.1(455)"></A>: getNumber
  (# <B>r</B><A name="getReal.1:r.2(456)"></A><A name="r.2(456)"></A>: @real;
     <B>realValue</B><A name="getReal.1:realValue.2(457)"></A><A name="realValue.2(457)"></A>::&lt; (# do value-&gt;r #);
  do INNER getReal
  exit r
  #);
<B>getBased</B><A name="getBased.1(458)"></A>: getNumber
  (# <B>i</B><A name="getBased.1:i.2(459)"></A><A name="i.2(459)"></A>,<B> b</B><A name="getBased.1:b.2(460)"></A><A name="b.2(460)"></A>: @integer;
     <B>basedValue</B><A name="getBased.1:basedValue.2(461)"></A><A name="basedValue.2(461)"></A>::&lt; (# do value-&gt;i; base-&gt;b #);
  do INNER getBased
  exit (b,i)
  #);
<B>getInteger</B><A name="getInteger.1(462)"></A>: getNumber
  (# <B>i</B><A name="getInteger.1:i.2(463)"></A><A name="i.2(463)"></A>: @integer;
     <B>integerValue</B><A name="getInteger.1:integerValue.2(464)"></A><A name="integerValue.2(464)"></A>::&lt; (# do value-&gt;i #);
  do INNER getInteger
  exit i
  #);
<B>getRadix</B><A name="getRadix.1(465)"></A>:
  (* gets a number in the specified radix.  GetRadix is similar to
   * getBased, except that is does NOT expect the 'bbx' prefix
   *)
  (# <B>radix</B><A name="getRadix.1:radix.2(466)"></A><A name="radix.2(466)"></A>,<B> value</B><A name="getRadix.1:value.2(467)"></A><A name="value.2(467)"></A>: @integer;
     <B>radixError</B><A name="getRadix.1:radixError.2(468)"></A><A name="radixError.2(468)"></A>:&lt; streamException
       (# radix: @integer
       enter radix
       ...
       #);
     <B>getr</B><A name="getRadix.1:getr.2(469)"></A><A name="getr.2(469)"></A>: (* private *) @...
  enter radix
  do getr;
     INNER getRadix
  exit value
  #);

<B>putBased</B><A name="putBased.1(470)"></A>:
  (* Takes a number and a base, and prints the number in that base.
   * If base is 0, base 16 is assumed, and the format "0xnnn" is used.
   * If base is negative, 1 or greater that 126, the baseError
   * exception is invoked.
   * 
   * The format is default "bbxnnnn", where "bb" is the base (in
   * decimal), and "nnnn" is the number, printed in the base. "x"
   * separates the two parts.  The format may be controlled by the
   * signed, blankSign, upcase, uppercase, width, adjustLeft,
   * zeroPadding, noBasePrefix, baseWidth and baseZeroPadding variable
   * attributes. If noBasePrefix is true, the "bbx" part is omitted.
   *)
  (# <B>value</B><A name="putBased.1:value.2(471)"></A><A name="value.2(471)"></A>,<B> base</B><A name="putBased.1:base.2(472)"></A><A name="base.2(472)"></A>: @integer;
     <B>baseError</B><A name="putBased.1:baseError.2(473)"></A><A name="baseError.2(473)"></A>:&lt; streamException
       (# base: @integer
       enter base
       do 'putBased: Illegal base: "'-&gt;msg.append; 
          base-&gt;msg.putInt; '"'-&gt;msg.put; INNER #);
     (* The format may be further controlled by the signed, blankSign,
      * width, adjustLeft and zeroPadding variable attributes.  
      * width is extended if it is too small.
      *
      * Examples:
      *   (10,10)-&gt;putBased
      *      yields: '10x10'
      *   (2,5)-&gt;putBased(# do 10-&gt;width; true-&gt;adjustLeft #);
      *      yields: '2x101     '
      *   (2,5)-&gt;putBased(# do 10-&gt;width; true-&gt;zeroPadding #);
      *      yields: '2x00000101'
      *)
     <B>signed</B><A name="putBased.1:signed.2(474)"></A><A name="signed.2(474)"></A>:
       (* If the number is positive, a '+' will always be displayed
        *)
       @boolean;
     <B>blankSign</B><A name="putBased.1:blankSign.2(475)"></A><A name="blankSign.2(475)"></A>:
       (* If the number is positive, a ' ' space is displayed as the
        * sign.  Ignored if signed=true
        *)
       @boolean;
     <B>upcase</B><A name="putBased.1:upcase.2(476)"></A><A name="upcase.2(476)"></A>: @boolean
       (* Specifies whether an upcase 'X' or a lowcase 'x' is the
        * be used in the 'bbx' part.
        *);
     <B>uppercase</B><A name="putBased.1:uppercase.2(477)"></A><A name="uppercase.2(477)"></A>: @boolean
       (* Specifies whether uppercase letters or lowercase letters
        * are used in the 'nnnn' part (for base&gt;9).
        *);
     <B>width</B><A name="putBased.1:width.2(478)"></A><A name="width.2(478)"></A>: (* Minimum width *) @integer;
     <B>adjustLeft</B><A name="putBased.1:adjustLeft.2(479)"></A><A name="adjustLeft.2(479)"></A>: @boolean
       (* Specifies if the number is to be aligned left or right,
        * if padding of spaces is necessary to fill up the specified
        * width.
        *);
     <B>zeroPadding</B><A name="putBased.1:zeroPadding.2(480)"></A><A name="zeroPadding.2(480)"></A>:
       (* width is padded with leading zero instead of spaces.
        * Ignored if adjustLeft=true
        *)
       @boolean;
     <B>noBasePrefix</B><A name="putBased.1:noBasePrefix.2(481)"></A><A name="noBasePrefix.2(481)"></A>: (* If true, the 'bbx' part is omitted *)
       @boolean;
     <B>baseWidth</B><A name="putBased.1:baseWidth.2(482)"></A><A name="baseWidth.2(482)"></A>: (* minimun width for the 'bbx' part *)
       @integer;
     <B>baseZeroPadding</B><A name="putBased.1:baseZeroPadding.2(483)"></A><A name="baseZeroPadding.2(483)"></A>:
       (* baseWidth is padded with leading zero instead of spaces *)
       @boolean;
     <B>format</B><A name="putBased.1:format.2(484)"></A><A name="format.2(484)"></A>:&lt; (# do INNER #);
     <B>putb</B><A name="putBased.1:putb.2(485)"></A><A name="putb.2(485)"></A>: @...
  enter (base, value)
  do INNER putBased; putb
  #);
<B>putReal</B><A name="putReal.1(486)"></A>:
  (* Append a real to THIS(stream). The format may be controlled by
   * the style, signed, blankSign, precision, upcase, width,
   * adjustLeft and zeroPadding variable attributes
   *)
  (# <B>r</B><A name="putReal.1:r.2(487)"></A><A name="r.2(487)"></A>: @real;
     <B>style</B><A name="putReal.1:style.2(488)"></A><A name="style.2(488)"></A>: @integer
       (* Controls the style, and may be one of plain, exp and noexp
        * (noexp is the default)
        *);
     <B>noexp</B><A name="putReal.1:noexp.2(489)"></A><A name="noexp.2(489)"></A>: (* The notation [-]mmm.dddddd is used *)
       (# exit 0 #);
     <B>exp</B><A name="putReal.1:exp.2(490)"></A><A name="exp.2(490)"></A>: (* The notation [-]m.ddddddE[+|-]xx is used *)
       (# exit 1 #);
     <B>plain</B><A name="putReal.1:plain.2(491)"></A><A name="plain.2(491)"></A>:
       (* In this style, precision is the total number of digits in
        * the printed real (not the number of digits in the fraction,
        * as in the other styles).
        * 
        * The exp or noexp style is used, dependent on the value being
        * printed.  Exp style is used only if the exponent is less
        * than -4 or greater than or equal to the precision; otherwise
        * the noexp notation is used.  Trailing zeros are not printed
        * as part of the fractional part and a decimal point is
        * printed if not followed by a digit
        *)
       (# exit 2 #);
     <B>signed</B><A name="putReal.1:signed.2(492)"></A><A name="signed.2(492)"></A>: (* If real is positive, a '+' will always be displayed *)
       @boolean;
     <B>blankSign</B><A name="putReal.1:blankSign.2(493)"></A><A name="blankSign.2(493)"></A>:
       (* If real is positive, a ' ' space is displayed as the sign.
        * Ignored if signed=true
        *)
       @boolean;
     <B>precision</B><A name="putReal.1:precision.2(494)"></A><A name="precision.2(494)"></A>: @integer
       (* The number of d's in the expressions above, default 6 *);
     <B>upcase</B><A name="putReal.1:upcase.2(495)"></A><A name="upcase.2(495)"></A>: @boolean
       (* Specifies whether an upcase 'E' or a lowcase 'e' is the
        * be used in the exp style.
        *);
     <B>width</B><A name="putReal.1:width.2(496)"></A><A name="width.2(496)"></A>: (* Minimum width *)
       @integer;
     <B>adjustLeft</B><A name="putReal.1:adjustLeft.2(497)"></A><A name="adjustLeft.2(497)"></A>: @boolean
       (* Specifies if the number is to be aligned left or right,
        * if padding of spaces is necessary to fill up the specified
        * width.
        *);
     <B>zeroPadding</B><A name="putReal.1:zeroPadding.2(498)"></A><A name="zeroPadding.2(498)"></A>:
       (* width is padded with leading zero instead of spaces.
        * Ignored if adjustLeft=true
        *)
       @boolean;
     (* Examples:
      *   10*pi -&gt; putreal;
      *      yields: '31.415926'
      *   10*pi -&gt; putreal(# do 10-&gt;width; true-&gt;adjustLeft #);
      *      yields: '31.415926   '
      *   10*pi -&gt; putreal(# do exp-&gt;style; true-&gt;upcase #);
      *      yields: '3.1415926E+01'
      *   10*pi -&gt; putreal(# do exp-&gt;style; 2-&gt;precision #);
      *      yields: '3.14e+01'
      *)
     <B>format</B><A name="putReal.1:format.2(499)"></A><A name="format.2(499)"></A>:&lt; (# do INNER #);
     <B>putr</B><A name="putReal.1:putr.2(500)"></A><A name="putr.2(500)"></A>: @...
  enter r
  do 1-&gt;width; 6-&gt;precision; format; INNER putReal; putr
  #);
<B>putRadix</B><A name="putRadix.1(501)"></A>: putBased
  (#
  do true-&gt;noBasePrefix; INNER putRadix 
  #);

<B>putHex</B><A name="putHex.1(502)"></A>:
  (* prints a hexadecimal representation of x (as unsigned word) on
   * this(stream). Similar to
   * (16,x)-&gt;putRadix(# do true-&gt;zeroPadding; 8-&gt;width #)
   * but more efficient.
   *) 
  (# <B>uppercase</B><A name="putHex.1:uppercase.2(503)"></A><A name="uppercase.2(503)"></A>: @boolean;
     <B>width</B><A name="putHex.1:width.2(504)"></A><A name="width.2(504)"></A>: @integer;
     <B>zeroPadding</B><A name="putHex.1:zeroPadding.2(505)"></A><A name="zeroPadding.2(505)"></A>: @boolean;
     <B>x</B><A name="putHex.1:x.2(506)"></A><A name="x.2(506)"></A>: @integer;
     <B>format</B><A name="putHex.1:format.2(507)"></A><A name="format.2(507)"></A>:&lt; (# do INNER #);
     <B>putH</B><A name="putHex.1:putH.2(508)"></A><A name="putH.2(508)"></A>: (*private*)@...
  enter x
  do format; INNER putHex; putH
  #);

<B>putByteHex</B><A name="putByteHex.1(509)"></A>:
  (* prints a hexadecimal representation of byte 'byte' in x (as
   * unsigned word) on this(stream)
   *)
  (# <B>x</B><A name="putByteHex.1:x.2(510)"></A><A name="x.2(510)"></A>: @integer;
     <B>byte</B><A name="putByteHex.1:byte.2(511)"></A><A name="byte.2(511)"></A>: @integer;
     <B>putBH</B><A name="putByteHex.1:putBH.2(512)"></A><A name="putBH.2(512)"></A>: (*private*)@...
  enter (x,byte)
  do INNER putByteHex; putBH
  #);

<B>putOctal</B><A name="putOctal.1(513)"></A>:
  (* prints a octal representation of x (as unsigned word) on
   * this (stream). Similar to
   * (8,x)-&gt;putRadix(# do true-&gt;zeroPadding;  #)
   * but more efficient.
   *)
  (# <B>width</B><A name="putOctal.1:width.2(514)"></A><A name="width.2(514)"></A>: @integer;
     <B>zeroPadding</B><A name="putOctal.1:zeroPadding.2(515)"></A><A name="zeroPadding.2(515)"></A>: @boolean;
     <B>x</B><A name="putOctal.1:x.2(516)"></A><A name="x.2(516)"></A>: @integer;
     <B>format</B><A name="putOctal.1:format.2(517)"></A><A name="format.2(517)"></A>:&lt; (# do INNER #);
     <B>putO</B><A name="putOctal.1:putO.2(518)"></A><A name="putO.2(518)"></A>:(*private*)@...
  enter x
  do format; INNER putOctal; putO;
  #);

<B>putBinary</B><A name="putBinary.1(519)"></A>:
  (* prints a binary representation of x (as unsigned word) on
   * this(stream). Similar to
   * (2,x)-&gt;putRadix(# do true-&gt;zeroPadding; #)
   * but more efficient.
   *)
  (# <B>width</B><A name="putBinary.1:width.2(520)"></A><A name="width.2(520)"></A>: @integer;
     <B>zeroPadding</B><A name="putBinary.1:zeroPadding.2(521)"></A><A name="zeroPadding.2(521)"></A>: @boolean;
     <B>x</B><A name="putBinary.1:x.2(522)"></A><A name="x.2(522)"></A>: @integer;
     <B>format</B><A name="putBinary.1:format.2(523)"></A><A name="format.2(523)"></A>:&lt; (# do INNER #);
     <B>putB</B><A name="putBinary.1:putB.2(524)"></A><A name="putB.2(524)"></A>: (*private*)@...
  enter x
  do format; INNER putBinary; putB
  #);

<B>putByteBinary</B><A name="putByteBinary.1(525)"></A>:
  (* prints a binary representation of byte 'byte' of x (as unsigned
   * word) on this(stream)
   *)
  (# <B>x</B><A name="putByteBinary.1:x.2(526)"></A><A name="x.2(526)"></A>: @integer;
     <B>byte</B><A name="putByteBinary.1:byte.2(527)"></A><A name="byte.2(527)"></A>: @integer;
     <B>putBB</B><A name="putByteBinary.1:putBB.2(528)"></A><A name="putBB.2(528)"></A>: (*private*)@...
  enter (x, byte)
  do INNER putByteBinary; putBB
  #);

<B>getHex</B><A name="getHex.1(529)"></A>:
  (* reads a hexadecimal number from this(stream) and returns the
   * value in x (as unsigned word). Similar to 16-&gt;getRadix but more
   * efficient.
   *)
  (# <B>x</B><A name="getHex.1:x.2(530)"></A><A name="x.2(530)"></A>: @integer;
     <B>noNumberError</B><A name="getHex.1:noNumberError.2(531)"></A><A name="noNumberError.2(531)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'getHex: the number begins with: "'-&gt;msg.append;
          (if peekCh = ascii.nul then 'NUL'-&gt;msg.puttext
           else peekCh-&gt;msg.put if);
          '".  Not a legal hexadecimal digit'-&gt;msg.puttext;
          INNER noNumberError
       #);
     <B>getH</B><A name="getHex.1:getH.2(532)"></A><A name="getH.2(532)"></A>: (*private*)...
  do INNER getHex; getH
  exit x
  #);

<B>getOctal</B><A name="getOctal.1(533)"></A>:
  (* reads a hexadecimal number from this(stream) and returns the
   * value in x (as unsigned word). Similar to 16-&gt;getRadix but more
   * efficient.
   *) 
  (# <B>x</B><A name="getOctal.1:x.2(534)"></A><A name="x.2(534)"></A>: @integer;
    <B>noNumberError</B><A name="getOctal.1:noNumberError.2(535)"></A><A name="noNumberError.2(535)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'getHex: the number begins with: "'-&gt;msg.append;
          (if peekCh = ascii.nul then 'NUL'-&gt;msg.puttext
           else peekCh-&gt;msg.put if);
          '".  Not a legal hexadecimal digit'-&gt;msg.puttext;
          INNER noNumberError
       #);
     <B>getO</B><A name="getOctal.1:getO.2(536)"></A><A name="getO.2(536)"></A>: (*private*)...
  do INNER getOctal; getO
  exit x
  #);

<B>getBinary</B><A name="getBinary.1(537)"></A>:
  (* reads a binary number from this(stream) and returns the value in
   * x (as unsigned word). Similar to 2-&gt;getRadix but more efficient.
   *)
  (# <B>x</B><A name="getBinary.1:x.2(538)"></A><A name="x.2(538)"></A>: @integer;
     <B>noNumberError</B><A name="getBinary.1:noNumberError.2(539)"></A><A name="noNumberError.2(539)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'getBinary: the number begins with: "'-&gt;msg.append;
          (if peekCh = ascii.nul then 'NUL'-&gt;msg.puttext
           else peekCh-&gt;msg.put if);
          '".  Not a legal binary digit'-&gt;msg.puttext;
          INNER noNumberError
       #);
     <B>getB</B><A name="getBinary.1:getB.2(540)"></A><A name="getB.2(540)"></A>: (*private*)...
  do INNER getBinary; getB
  exit x
  #);

<B>asNumber</B><A name="asNumber.1(541)"></A>:
  (# <B>syntaxError</B><A name="asNumber.1:syntaxError.2(542)"></A><A name="syntaxError.2(542)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'asNumber: Syntax error - looking at: "'-&gt;msg.append;
          peekCh-&gt;msg.put; '"'-&gt;msg.put;
          INNER syntaxError
       #);
     <B>baseError</B><A name="asNumber.1:baseError.2(543)"></A><A name="baseError.2(543)"></A>:&lt; streamException
       (# base: @integer
       enter base
       do 'asNumber: Error in base - looking at: "'-&gt;msg.append;
          base-&gt;msg.putInt; '"'-&gt;msg.put;
          INNER baseError
       #);
     <B>valueError</B><A name="asNumber.1:valueError.2(544)"></A><A name="valueError.2(544)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'asNumber: Illegal value type - looking at: "'-&gt;msg.append;
          peekCh-&gt;msg.put; '"'-&gt;msg.put;
          INNER valueError
       #);
  do reset;
     INNER asNumber;
     ScanWhiteSpace; (if not eos then peek-&gt;syntaxError if)
  #);

<B>asReal</B><A name="asReal.1(545)"></A>: asNumber
  (# <B>r</B><A name="asReal.1:r.2(546)"></A><A name="r.2(546)"></A>: @real
    ...
  exit r
  #);
<B>asBased</B><A name="asBased.1(547)"></A>: asNumber
  (# <B>i</B><A name="asBased.1:i.2(548)"></A><A name="i.2(548)"></A>,<B> b</B><A name="asBased.1:b.2(549)"></A><A name="b.2(549)"></A>: @integer
    ...
  exit (b,i)
  #);
<B>asRadix</B><A name="asRadix.1(550)"></A>: asNumber
  (# <B>radix</B><A name="asRadix.1:radix.2(551)"></A><A name="radix.2(551)"></A>,<B> value</B><A name="asRadix.1:value.2(552)"></A><A name="value.2(552)"></A>: @integer
  enter radix
  ...
  exit value
  #);
<B>asInteger</B><A name="asInteger.1(553)"></A>: asNumber
  (# <B>i</B><A name="asInteger.1:i.2(554)"></A><A name="i.2(554)"></A>: @integer
    ...
  exit i
  #)

--- lib: attributes ---

<B>getNumber</B><A name="getNumber.1(555)"></A>: keyboard.getNumber
  (# do INNER getNumber #);
<B>getReal</B><A name="getReal.1(556)"></A>: keyboard.getReal
  (# do INNER getReal #);
<B>getBased</B><A name="getBased.1(557)"></A>: keyboard.getBased
  (# do INNER getbased #);
<B>getRadix</B><A name="getRadix.1(558)"></A>: keyboard.getRadix
  (# do INNER getRadix #);
<B>getInteger</B><A name="getInteger.1(559)"></A>: keyboard.getInteger
  (# do INNER getInteger #);

<B>putReal</B><A name="putReal.1(560)"></A>: screen.putReal
  (# do INNER putReal #);
<B>putBased</B><A name="putBased.1(561)"></A>: screen.putBased
  (# do INNER putBased #);
<B>putRadix</B><A name="putRadix.1(562)"></A>: screen.putRadix
  (# do INNER putRadix #);

<B>getHex</B><A name="getHex.1(563)"></A>: keyboard.getHex
  (# do INNER getHex #);
<B>getOctal</B><A name="getOctal.1(564)"></A>: keyboard.getOctal
  (# do INNER getOctal #);
<B>getBinary</B><A name="getBinary.1(565)"></A>: keyboard.getBinary
  (# do INNER getBinary #);

<B>putHex</B><A name="putHex.1(566)"></A>: screen.putHex
  (# do INNER putHex #);
<B>putByteHex</B><A name="putByteHex.1(567)"></A>: screen.putByteHex
  (# do INNER putByteHex #);
<B>putOctal</B><A name="putOctal.1(568)"></A>:screen.putOctal
  (# do INNER putOctal #);
<B>putBinary</B><A name="putBinary.1(569)"></A>: screen.putBinary
  (# do INNER putBinary #);
<B>putByteBinary</B><A name="putByteBinary.1(570)"></A>: screen.putByteBinary
  (# do INNER putByteBinary #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="33%" align="left"><ADDRESS>Interface Description</ADDRESS></TD>
<TD width="34%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="33%" align="right"><FONT size=-1><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></FONT></TD>
</TABLE>
<P></P>
<A HREF="formatio.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="math.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
