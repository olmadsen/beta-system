<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Basicsystemenv Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript">
<!--
    CheckParent("basicsystemenv");
//-->
</SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="basicsystemenv">Basicsystemenv Interface</A></H1>

<PRE CLASS=interface>
ORIGIN 'betaenv';
LIB_DEF 'basicsystemenv' '../lib';
BODY 'private/basicsystemenvbody'
---LIB:attributes---
(*
 * COPYRIGHT 
 *       Copyright Mjolner Informatics, 1992-96 
 *       All rights reserved.
 * 
 * This fragment contains abstract superpatterns for describing the
 * BETA concepts of concurrent systems.
 * 
 * The basic ideas are
 * 
 *      A. Components (coroutines) can be executed concurrently
 * 
 *      B. A primitive semaphore pattern is available for
 *         syncronization.
 * 
 *      C. An abstract pattern 'Monitor' similar to the monitor
 *         proposed by Hoare and Brinch-Hansen
 * 
 *      D. An abstract pattern 'System' is defined. System defines
 *         communication between systems by means of synchronized
 *         rendezvous.  A concurreny imperative 'conc' is defined for
 *         systems.
 * 
 * The abstractions defined here are identical to the ones described
 * in chapter 12 of the BETA book except for the following points:
 * 
 * 1. The syntax of 'fork' is
 *      S[]-&gt;fork
 *    and NOT S.fork
 * 
 * 2. The syntax of 'conc' is
 *      conc(# do S1[]-&gt;start; S2[]-&gt;start; S3[]-&gt;start #)
 *    and NOT conc(# do S1.start; S2.start; S3.start #)
 * 
 * 4. THE CONCURRENCY IS SIMULATED In order to implement real
 *    concurreny, an interrupt mechanism must be implemented. This is
 *    currently NOT done. A component/system will thus keep the
 *    control until it makes an explicit or implicit SUSPEND.  An
 *    implicit SUSPEND is made when a component must wait for a
 *    semaphore, executes the pause pattern, executes the sleep
 *    pattern, or performs a blocking communication using the shellEnv
 *    distribution abstractions.  As the concurrency is simulated,
 *    there is no difference between the implementation of the alt and
 *    conc imperatives.
 * 
 * 5. A program using concurrency must have the form:
 *      systemenv(# ... do ... #)
 * 
 * 6. Concurrency and X-Windows/macenv/guienv
 *    User interface environments are usually event-driven in the
 *    sense that actions in the program are executed as a response to
 *    user input events.  To handle this, a number of separate
 *    implementations of SystemEnv exists for different user interface
 *    libraries:
 * 
 *    Use systemenv.bet as origin for programs not using event-driven
 *    user-interface libraries.
 * 
 *    Use ~beta/Xt/current/xsystemenv.bet as origin for programs using
 *    XtEnv, AwEnv or MotifEnv.
 * 
 *    Use ~beta/guienv/current/guienvsystemenv.bet as origin for
 *    programs using GUIenv (Lidskvjalv).
 * 
 *    See xsystemenv and guienvsystemenv for a description of using
 *    systemenv in conjunction with X and GUIenv programs,
 *    respectively.
 * 
 *    See ~beta/macenv/current/macsystemenv for a description of using
 *    systemenv and macenv.
 * 
 * For examples of using SystemEnv see the demo directory.
 *)
<B>getSystemEnv</B><A name="getSystemEnv.1(1)"></A>: 
  (* Returns the unique systemEnv instance running *)
  (# <B>systemEnvType</B><A name="getSystemEnv.1.systemEnvType.2(2)"></A><A name="systemEnvType.2(2)"></A>:&lt; systemEnv;
     <B>theSystemEnv</B><A name="getSystemEnv.1.theSystemEnv.2(3)"></A><A name="theSystemEnv.2(3)"></A>: ^systemEnvType;
  do (* SystemEnv## -&gt; objectPool.strucGet 
     (# init::&lt; 
          (# 
          do (failure, 
             'Program:descriptor must be a subpattern of systemEnv')
               -&gt; stop
     #)#) -&gt; theSystemEnv[]; *)
     objectPool.get
     (# type::systemEnvType;
        init::
          (# 
          do (failure,'Illegal use of systemenv. You may have precisely one systemenv instance!')
               -&gt;stop;
          #)
     #)-&gt;theSystemEnv[];
  exit theSystemEnv[]
  #);
<B>SystemEnv</B><A name="SystemEnv.1(4)"></A>: SysHead
  (# &lt;&lt;SLOT systemlib:attributes &gt;&gt;;
     <B>semaphore</B><A name="SystemEnv.1.semaphore.2(5)"></A><A name="semaphore.2(5)"></A>:
       (* P and V are the usual semaphore operations.
        * 
        * tryP returns true if the P operation succeded. Returns false
        * if a P would block the caller. In that case the P operation
        * is not performed.
        * 
        * Count returns the number of components waiting for the
        *         semaphore.
        *)
       (# P: @...;
          V: @...;
          tryP: @BooleanValue
            (# ... #);
          Count: @
            (# value: @Integer;
            ...
            exit value
            #);
          semRep: @...
       #);
     <B>fork</B><A name="SystemEnv.1.fork.2(6)"></A><A name="fork.2(6)"></A>: @
       (* S is put into the queue of scheduled systems. The calling
        * system keeps control, i.e. is not preempted.
        *)
       (# first:  @...;
          second: @...;
          S: ^|SysHead 
       enter S[] 
       do first; second; none -&gt; s[];
       #);
     <B>kill</B><A name="SystemEnv.1.kill.2(7)"></A><A name="kill.2(7)"></A>: @
       (* Kills S. If S is the active system, this is equivalent to a
        * direct suspend.
        *)
       (# S: ^|SysHead; doKill: @...
       enter S[] 
       do doKill
       #);
     <B>pause</B><A name="SystemEnv.1.pause.2(8)"></A><A name="pause.2(8)"></A>: @
       (* Moves the calling system to the end of the queue of
        * scheduled systems.
        *)
       ...;
     <B>sleep</B><A name="SystemEnv.1.sleep.2(9)"></A><A name="sleep.2(9)"></A>: @
       (* Makes the calling system sleep at least time seconds.  If
        * time is 0 or negative, sleep has no effect.
        *)
       (# time: @Real
       enter time 
       ... 
       #);
     <B>sleepUntil</B><A name="SystemEnv.1.sleepUntil.2(10)"></A><A name="sleepUntil.2(10)"></A>:
       (* Makes the calling system sleep until at least time.  If
        * time is less than the current time, sleepUntil has no effect.
        *)
       (# time: @Real
       enter time 
       ... 
       #);
     <B>timeStamp</B><A name="SystemEnv.1.timeStamp.2(11)"></A><A name="timeStamp.2(11)"></A>:
       (# value: @Real;
       ...
       exit value
       #);
     <B>Monitor</B><A name="SystemEnv.1.Monitor.2(12)"></A><A name="Monitor.2(12)"></A>:
       (# (* idx+ *)
          <B>Condition</B><A name="SystemEnv.1.Monitor.2.Condition.3(13)"></A><A name="Condition.3(13)"></A>:
            (# q: @Semaphore;
               Wait: ...;
               Signal: ...;
            #);
          <B>Wait</B><A name="SystemEnv.1.Monitor.2.Wait.3(14)"></A><A name="Wait.3(14)"></A>:
            (# cond: @boolean 
            do INNER;
               (if not cond then 
                   return; (* exit monitor *)
                   pause;
                   mutex.P; (* reentry of monitor *)
                   restart Wait
               if)
            #);
          Entry: (# do mutex.P; INNER; return #);
          init:&lt; (# do INNER; mutex.V; #);
          (* private:
           * 
           * mutex controls entry to the Monitor.  urgent delays a
           * signalling process.
           * 
           * return is executed by processes leaving the monitor.
           * Reactivates possible processes waiting for entry: delayed
           * signalling processes (urgent) have first priority
           *)
          mutex: @semaphore;
          urgent: @semaphore; 
          return: @...;
       #);
     <B>System</B><A name="SystemEnv.1.System.2(15)"></A><A name="System.2(15)"></A>: SysHead
       (# <B>Port</B><A name="SystemEnv.1.System.2.Port.3(16)"></A><A name="Port.3(16)"></A>:
            (# mx,m: @Semaphore;
               entry: (# do m.P; INNER; mx.V #);
               accept: (# do m.V; mx.P #)
            #);
          <B>RestrictedPort</B><A name="SystemEnv.1.System.2.RestrictedPort.3(17)"></A><A name="RestrictedPort.3(17)"></A>:
            (# mx, am: @Semaphore;
               delayed: @...;
               accept:&lt;(# ... #);
               acceptable:&lt;(# OK: @Boolean; s: ^|sysHead enter s[] do INNER exit OK #);
               restrictedEntry:
                 (# ... #);
            #);
          <B>ObjectPort</B><A name="SystemEnv.1.System.2.ObjectPort.3(18)"></A><A name="ObjectPort.3(18)"></A>: RestrictedPort
            (# accept::&lt; (# enter sender[] do none-&gt;sender[] #);
               acceptable::&lt; (# ... #);
               entry: RestrictedEntry (# do INNER #);
               sender: ^|sysHead
            #);
          <B>QualifiedPort</B><A name="SystemEnv.1.System.2.QualifiedPort.3(19)"></A><A name="QualifiedPort.3(19)"></A>: RestrictedPort
            (# accept::&lt; (# enter sender## do none-&gt;sender## #);
               acceptable::&lt; (# ... #);
               entry: RestrictedEntry(# do INNER #);
               sender: ##sysHead
            #);
          <B>conc</B><A name="SystemEnv.1.System.2.conc.3(20)"></A><A name="conc.3(20)"></A>:
            (# start:
                 (# s: ^|system
                 enter s[]
                 ...
                 #);
               concPriv: @...
            do INNER; ...; 
            #);
          <B>alt</B><A name="SystemEnv.1.System.2.alt.3(21)"></A><A name="alt.3(21)"></A>: conc (# do INNER #);
          <B>onKilled</B><A name="SystemEnv.1.System.2.onKilled.3(22)"></A><A name="onKilled.3(22)"></A>:&lt;
            (* Called before this system terminates. *)
            (# 
            do (if caller[]&lt;&gt;NONE then (* not the outermost system *)
                   caller.dec; NONE -&gt; caller[]
               if);
               INNER;
            #);
          <B>caller</B><A name="SystemEnv.1.System.2.caller.3(23)"></A><A name="caller.3(23)"></A>: ^protectedInt;
       do INNER;
       #);
     <B>deadLocked</B><A name="SystemEnv.1.deadLocked.2(24)"></A><A name="deadLocked.2(24)"></A>:&lt; Exception
       (* This exception is called when all coroutines are blocked
        * and none are waiting for I/O.
        *)
       (# 
       do INNER;
          (if not continue then
              '<B>BasicSystemEnv</B><A name="SystemEnv.1.deadLocked.2.BasicSystemEnv.3(25)"></A><A name="BasicSystemEnv.3(25)"></A>: All coroutines blocked on semaphores.'
                -&gt; msg.append;
          if);
       #);
     <B>conc</B><A name="SystemEnv.1.conc.2(26)"></A><A name="conc.2(26)"></A>:
       (# <B>start</B><A name="SystemEnv.1.conc.2.start.3(27)"></A><A name="start.3(27)"></A>:
            (# s: ^|system
            enter s[]
            ...
            #);
          <B>concPriv</B><A name="SystemEnv.1.conc.2.concPriv.3(28)"></A><A name="concPriv.3(28)"></A>: @...
       do INNER; ...; 
       #);
     <B>alt</B><A name="SystemEnv.1.alt.2(29)"></A><A name="alt.2(29)"></A>: 
       (* Same as conc as a consequence of non-preemtive scheduling.
        *)
       conc (# #);
     
     (* ATTRIBUTES FOR EVENT-DRIVEN WINDOWING ENVIRONMENTS
      * 
      * These attributes are only used when combining SystemEnv with
      * an event-driven windowing environment. This demands an
      * alternative implementation than the standard SystemEnv
      * implementation. See the file: xsystemenv.bet
      *)
     <B>windowEnvType</B><A name="SystemEnv.1.windowEnvType.2(30)"></A><A name="windowEnvType.2(30)"></A>:&lt; Object;
     <B>theWindowEnv</B><A name="SystemEnv.1.theWindowEnv.2(31)"></A><A name="theWindowEnv.2(31)"></A>: ^windowEnvType;
     <B>setWindowEnv</B><A name="SystemEnv.1.setWindowEnv.2(32)"></A><A name="setWindowEnv.2(32)"></A>:&lt; Object;
     
     (* PRIVATE
      * 
      * Everything below is in principle private implementation stuff.
      *)
     <B>private</B><A name="SystemEnv.1.private.2(33)"></A><A name="private.2(33)"></A>: @ ...;
     <B>BasicScheduler</B><A name="SystemEnv.1.BasicScheduler.2(34)"></A><A name="BasicScheduler.2(34)"></A>: ...; 
     <B>theActive</B><A name="SystemEnv.1.theActive.2(35)"></A><A name="theActive.2(35)"></A>: ^|sysHead;
     <B>ProtectedInt</B><A name="SystemEnv.1.ProtectedInt.2(36)"></A><A name="ProtectedInt.2(36)"></A>: IntegerObject
       (* Used in implementation of conc. *)
       (# <B>mutex</B><A name="SystemEnv.1.ProtectedInt.2.mutex.3(37)"></A><A name="mutex.3(37)"></A>: @semaphore;
          <B>atZero</B><A name="SystemEnv.1.ProtectedInt.2.atZero.3(38)"></A><A name="atZero.3(38)"></A>: @semaphore;
          <B>dec</B><A name="SystemEnv.1.ProtectedInt.2.dec.3(39)"></A><A name="dec.3(39)"></A>:
            (# 
            do mutex.P; (if (value-1-&gt;value)=0 then atZero.V if); mutex.V;
            #);
          <B>waitForZero</B><A name="SystemEnv.1.ProtectedInt.2.waitForZero.3(40)"></A><A name="waitForZero.3(40)"></A>: (# do atZero.P #);
          <B>init</B><A name="SystemEnv.1.ProtectedInt.2.init.3(41)"></A><A name="init.3(41)"></A>: (# enter value do mutex.V #);
       #);
     <B>initBeforeScheduler</B><A name="SystemEnv.1.initBeforeScheduler.2(42)"></A><A name="initBeforeScheduler.2(42)"></A>:&lt; 
       (* Called before the scheduler is activated and before
        * setWindowEnv and the systemenv INNER is called.
        *)
       Object;
  do ...;
     INNER
  #);

<B>cyclicElm</B><A name="cyclicElm.1(43)"></A>:
  (# <B>s</B><A name="cyclicElm.1.s.2(44)"></A><A name="s.2(44)"></A>: ^|SysHead;
     <B>next</B><A name="cyclicElm.1.next.2(45)"></A><A name="next.2(45)"></A>,<B> prev</B><A name="cyclicElm.1.prev.2(46)"></A><A name="prev.2(46)"></A>: ^cyclicElm;
     <B>due</B><A name="cyclicElm.1.due.2(47)"></A><A name="due.2(47)"></A>: @Real
       (* due is used by sleepingQueue. If zero, this element is
        * currently not in a sleepingQueue.
        *)
  #);
<B>cyclicQueue</B><A name="cyclicQueue.1(48)"></A>:
  (# <B>onDelete</B><A name="cyclicQueue.1.onDelete.2(49)"></A><A name="onDelete.2(49)"></A>:&lt; Object;
     <B>onDel</B><A name="cyclicQueue.1.onDel.2(50)"></A><A name="onDel.2(50)"></A>: @onDelete;
     <B>onInsert</B><A name="cyclicQueue.1.onInsert.2(51)"></A><A name="onInsert.2(51)"></A>:&lt; Object;
     <B>onIns</B><A name="cyclicQueue.1.onIns.2(52)"></A><A name="onIns.2(52)"></A>: @onInsert;
     <B>first</B><A name="cyclicQueue.1.first.2(53)"></A><A name="first.2(53)"></A>,<B> freeList</B><A name="cyclicQueue.1.freeList.2(54)"></A><A name="freeList.2(54)"></A>: ^cyclicElm;
     <B>insert</B><A name="cyclicQueue.1.insert.2(55)"></A><A name="insert.2(55)"></A>: @
       (# <B>s</B><A name="cyclicQueue.1.insert.2.s.3(56)"></A><A name="s.3(56)"></A>: ^|sysHead; <B>new</B><A name="cyclicQueue.1.insert.2.new.3(57)"></A><A name="new.3(57)"></A>: ^cyclicElm;
       enter s[]
       ...
       exit new[]
       #);
     <B>append</B><A name="cyclicQueue.1.append.2(58)"></A><A name="append.2(58)"></A>: @
       (# <B>elm</B><A name="cyclicQueue.1.append.2.elm.3(59)"></A><A name="elm.3(59)"></A>: ^cyclicElm;
       enter elm[]
       ...
       #);
     <B>prepend</B><A name="cyclicQueue.1.prepend.2(60)"></A><A name="prepend.2(60)"></A>: @
       (# <B>elm</B><A name="cyclicQueue.1.prepend.2.elm.3(61)"></A><A name="elm.3(61)"></A>: ^cyclicElm;
       enter elm[] 
       ...
       #);
     <B>insertBefore</B><A name="cyclicQueue.1.insertBefore.2(62)"></A><A name="insertBefore.2(62)"></A>: @
       (# <B>new</B><A name="cyclicQueue.1.insertBefore.2.new.3(63)"></A><A name="new.3(63)"></A>,<B> old</B><A name="cyclicQueue.1.insertBefore.2.old.3(64)"></A><A name="old.3(64)"></A>: ^cyclicElm;
       enter (new[],old[])
       ...
       #);
     <B>getFirst</B><A name="cyclicQueue.1.getFirst.2(65)"></A><A name="getFirst.2(65)"></A>: @
       (# <B>elm</B><A name="cyclicQueue.1.getFirst.2.elm.3(66)"></A><A name="elm.3(66)"></A>: ^cyclicElm;
       ...
       exit elm[]
       #);
     <B>delete</B><A name="cyclicQueue.1.delete.2(67)"></A><A name="delete.2(67)"></A>: @
       (# <B>elm</B><A name="cyclicQueue.1.delete.2.elm.3(68)"></A><A name="elm.3(68)"></A>: ^cyclicElm;
       enter elm[]
       ...
       exit elm[]
       #);
     <B>remove</B><A name="cyclicQueue.1.remove.2(69)"></A><A name="remove.2(69)"></A>: @ 
       (* elm should not be reused after remove. Use delete instead.
        *)
       (# <B>elm</B><A name="cyclicQueue.1.remove.2.elm.3(70)"></A><A name="elm.3(70)"></A>: ^cyclicElm; <B>s</B><A name="cyclicQueue.1.remove.2.s.3(71)"></A><A name="s.3(71)"></A>: ^|sysHead;
       enter elm[]
       ...
       exit s[]
       #);
     <B>scan</B><A name="cyclicQueue.1.scan.2(72)"></A><A name="scan.2(72)"></A>:
       (# <B>current</B><A name="cyclicQueue.1.scan.2.current.3(73)"></A><A name="current.3(73)"></A>: ^cyclicElm;
       ...
       #);
     <B>size</B><A name="cyclicQueue.1.size.2(74)"></A><A name="size.2(74)"></A>: @Integer;
  #);
<B>SysHead</B><A name="SysHead.1(75)"></A>: 
  (# <B>shstatus</B><A name="SysHead.1.shstatus.2(76)"></A><A name="shstatus.2(76)"></A>: @Integer; 
     <B>lc</B><A name="SysHead.1.lc.2(77)"></A><A name="lc.2(77)"></A>: ^Object;     (* Last errorCatcher for distribution errors. *)
     <B>ce</B><A name="SysHead.1.ce.2(78)"></A><A name="ce.2(78)"></A>: ^cyclicElm;  (* ce,q &lt;&gt; none =&gt; this(sysHead) is ce in q.  *)
     <B>q</B><A name="SysHead.1.q.2(79)"></A><A name="q.2(79)"></A>: ^cyclicQueue;
  do INNER
  #);
(* SysHead.shstatus values: *)
<B>SE_RUNNING</B><A name="SE_RUNNING.1(80)"></A>:  (# exit 1 #);  (* Current system.       *)
<B>SE_WAITING</B><A name="SE_WAITING.1(81)"></A>:  (# exit 2 #);  (* Blocked on semaphore. *)
<B>SE_READY</B><A name="SE_READY.1(82)"></A>:    (# exit 3 #);  (* Ready to run.         *)
<B>SE_SLEEPING</B><A name="SE_SLEEPING.1(83)"></A>: (# exit 4 #);  (* Sleeping.             *)
<B>SE_KILLED</B><A name="SE_KILLED.1(84)"></A>:   (# exit 5 #)
</PRE>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Basicsystemenv Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
