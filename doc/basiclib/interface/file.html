<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>File Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="directory.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="regexp.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>File Interface</H1>
<PRE CLASS=interface>
ORIGIN 'betaenv';
LIB_DEF 'file' '../lib';
BODY 'private/filebody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1984-96
 *       All rights reserved.
 *
 * The BETA interface to disk-entries in a hierarchic file system
 * files, and directories is organised as follows:
 * 
 *   DiskEntry:     Machine independent interface to entries like
 *                  file and directories on the disk 
 *                  (file 'file.bet').
 *   UnixEntry:     Unix specific specialization of DiskEntry 
 *                  (file 'unixfile.bet').
 *   MacEntry:      Macintosh specific specialization of DiskEntry 
 *                  (file 'macfile.bet').
 * 
 *   File:          Machine independent interface to disk files. Is  
 *                  a specialization of Stream (file 'betaenv.bet'),
 *                  and contains a DiskEntry (file 'file.bet').
 *   UnixFile:      Unix specific specialization of File, which 
 *                  contains a UnixEntry (file 'unixfile.bet').
 *   MacFile:       Macintosh  specific specialization of File,
 *                   which contains a MacEntry (file 'macfile.bet').
 *    
 *   Directory:     Machine independent interface to 
 *                  directories/folders. Contains a DiskEntry 
 *                  (file 'directory.bet').
 *   UnixDirectory: Unix specific specialization of Directory, 
 *                  which contains a UnixEntry 
 *                  (file 'unixdirectory.bet').
 *   MacDirectory:  Macintosh specific specialization of Directory,
 *                  which contains a MacEntry 
 *                  (file 'macdirectory.bet').
 *)
-- LIB: Attributes --
<B>DiskEntry</B><A name="DiskEntry.1(740)"></A>:
  (* Pattern describing various attributes of disk-entries like files
   * and directories in a hierarchic file system
   *)
  (# &lt;&lt;SLOT DiskEntryLib: attributes&gt;&gt;;
     
     (* DISK ENTRY EXCEPTIONS *)
     <B>DiskEntryException</B><A name="DiskEntry.1:DiskEntryException.2(741)"></A><A name="DiskEntryException.2(741)"></A>: Exception
       (* General exception for disk entries *)
       (# ... #);
     <B>DiskEntryExistsException</B><A name="DiskEntry.1:DiskEntryExistsException.2(742)"></A><A name="DiskEntryExistsException.2(742)"></A>: DiskEntryException
       (* Raised if a test for disk entry existence has
        * failed. Message: "Test for disk entry existence failed.",
        * and an indication of why it failed.
        *)
       (# ... #);
     <B>DiskEntryModtimeException</B><A name="DiskEntry.1:DiskEntryModtimeException.2(743)"></A><A name="DiskEntryModtimeException.2(743)"></A>: DiskEntryException
       (* Raised if examination or setting of disk entry modtime has failed.
        * Message: "Examination/setting of disk entry modtime failed.", and an
        * indication of why it failed.
        *)
       (# ... #);
     <B>DiskEntryTouchException</B><A name="DiskEntry.1:DiskEntryTouchException.2(744)"></A><A name="DiskEntryTouchException.2(744)"></A>: DiskEntryException
       (* Raised if touch of a disk entry has failed. Message: "Touch
        * of disk entry failed.", and an indication of why it failed.
        *)
       (# ... #);
     <B>DiskEntryRenameException</B><A name="DiskEntry.1:DiskEntryRenameException.2(745)"></A><A name="DiskEntryRenameException.2(745)"></A>: DiskEntryException
       (* Raised if rename of a disk entry has failed. Message:
        * "Rename of disk entry failed.", and an indication of why it
        * failed.
        *)
       (# ... #);
     <B>pathDesc</B><A name="DiskEntry.1:pathDesc.2(746)"></A><A name="pathDesc.2(746)"></A>:&lt;
       (* A virtual descriptor for the full or relative path of
        * THIS(DiskEntry)
        *)
       (# <B>head</B><A name="DiskEntry.1:pathDesc.2:head.3(747)"></A><A name="head.3(747)"></A>:&lt;
            (* The head of the path, e.g. head of '/usr/smith/foo.bet'
             * is '/usr/smith'
             *)
            (# h: ^text
            ... 
            exit h[] 
            #);
          <B>nameDesc</B><A name="DiskEntry.1:pathDesc.2:nameDesc.3(748)"></A><A name="nameDesc.3(748)"></A>:&lt; 
            (* The actual name-part of the path, e.g. name part of
             * '/usr/smith/foo.bet' is 'foo.bet'
             *) 
            (# <B>prefix</B><A name="DiskEntry.1:pathDesc.2:nameDesc.3:prefix.4(749)"></A><A name="prefix.4(749)"></A>:&lt;
                 (* exits the prefix part of the name, i.e. what is
                  * before the last dot (.), e.g 'foo' for 'foo.bet'
                  *)
                 (# p: ^text 
                 ... 
                 exit p[]
                 #);
               <B>extension</B><A name="DiskEntry.1:pathDesc.2:nameDesc.3:extension.4(750)"></A><A name="extension.4(750)"></A>:&lt;
                 (* exits the extension part of the name, i.e. what
                  * is after the last dot (.), e.g. 'bet' for 'foo.bet'
                  *)
                 (# e: ^text 
                 ... 
                 exit e[]
                 #);
               <B>suffix</B><A name="DiskEntry.1:pathDesc.2:nameDesc.3:suffix.4(751)"></A><A name="suffix.4(751)"></A>:&lt;
                 (* like extension, but includes the dot (.),
                  * e.g. '.bet' for 'foo.bet'
                  *)
                 (# s: ^text
                 ...
                 exit s[]
                 #);
               <B>get</B><A name="DiskEntry.1:pathDesc.2:nameDesc.3:get.4(752)"></A><A name="get.4(752)"></A>:&lt;
                 (* exits "prefix.extension" *)
                 (# n: ^text 
                 ... 
                 exit n[]
                 #);
            exit get
            #);
          <B>name</B><A name="DiskEntry.1:pathDesc.2:name.3(753)"></A><A name="name.3(753)"></A>: @nameDesc;
          <B>set</B><A name="DiskEntry.1:pathDesc.2:set.3(754)"></A><A name="set.3(754)"></A>:&lt; 
            (* set the entire path *)
            (# p: ^text 
            enter p[]
            ... 
            #);
          <B>get</B><A name="DiskEntry.1:pathDesc.2:get.3(755)"></A><A name="get.3(755)"></A>:&lt; 
            (* get the entire path *)
            (# p: ^text 
            ... 
            exit p[]
            #);
       enter set
       do INNER
       exit get
       #);
     <B>path</B><A name="DiskEntry.1:path.2(756)"></A><A name="path.2(756)"></A>: @pathDesc;
     <B>exists</B><A name="DiskEntry.1:exists.2(757)"></A><A name="exists.2(757)"></A>: BooleanValue
       (* exits a boolean indicating whether the disk entry
        * corresponding to the current setting of path actually exists
        *)
       (# error:&lt; DiskEntryExistsException;
       ...
       #);
     <B>modtime</B><A name="DiskEntry.1:modtime.2(758)"></A><A name="modtime.2(758)"></A>: 
       (* exits an integer denoting the (system) time of the last
        *         modification
        *)
       (# time: @integer;
          error:&lt;DiskEntryModTimeException;
       enter (# enter time ... #)
       exit (# ... exit time #)
       #); 
     <B>touch</B><A name="DiskEntry.1:touch.2(759)"></A><A name="touch.2(759)"></A>:
       (* Updates the modtime to the current (system) time. *)
       (# error:&lt; DiskEntryTouchException;
       ...
       #);
     <B>rename</B><A name="DiskEntry.1:rename.2(760)"></A><A name="rename.2(760)"></A>:
       (* Rename the disk entry. Changes the physical disk entry and
        * updates THIS(DiskEntry).path
        *)
       (# newpath: ^text;
          error:&lt; DiskEntryRenameException;
       enter newpath[]
       ...
       #);
     <B>size</B><A name="DiskEntry.1:size.2(761)"></A><A name="size.2(761)"></A>: IntegerValue
       (* exits the size of THIS(DiskEntry) in bytes *)
       (# error:&lt;DiskEntryException;
       ... 
       #);
     <B>readable</B><A name="DiskEntry.1:readable.2(762)"></A><A name="readable.2(762)"></A>: BooleanValue
       (* exits true if THIS(DiskEntry) can be read *)
       (# error:&lt; DiskEntryException;
       ... 
       #);
     <B>writeable</B><A name="DiskEntry.1:writeable.2(763)"></A><A name="writeable.2(763)"></A>: BooleanValue
       (* exits true if THIS(DiskEntry) can be written to *)
       (# error:&lt; DiskEntryException;
          checkwrite: @...; 
       do checkwrite
       #);
     <B>isFile</B><A name="DiskEntry.1:isFile.2(764)"></A><A name="isFile.2(764)"></A>: BooleanValue
       (* True if THIS(DiskEntry) is a regular file *)
       (# error:&lt; DiskEntryException;
       ...
       #);
     <B>isDirectory</B><A name="DiskEntry.1:isDirectory.2(765)"></A><A name="isDirectory.2(765)"></A>: BooleanValue
       (* True if THIS(DiskEntry) is a directory *)
       (# error:&lt;DiskEntryException;
       ...
       #);
     
     <B>private</B><A name="DiskEntry.1:private.2(766)"></A><A name="private.2(766)"></A>: @...
  do INNER
  #); (* DiskEntry *)

(* Constants used for specifying mode to File.SetPos. *)
<B>FromBeginning</B><A name="FromBeginning.1(767)"></A>:   
  (* Seeks relative to the beginning of a file.  Corresponds to
   * absolute positions in File[0:File.Length-1].
   *)
  (# exit 0 #);
<B>FromCurrent</B><A name="FromCurrent.1(768)"></A>:  
  (* Seeks relative to the current position.   *)
  (# exit 1 #); 
<B>FromEnd</B><A name="FromEnd.1(769)"></A>:          
  (* Seeks relative to the end of a file. *)
  (# exit 2 #);

<B>File</B><A name="File.1(770)"></A>: Stream
  (* Generalization of disk file.  Describes the stream aspects of
   * files, providing buffered I/O, and contains a DiskEntry object
   * describing the other properties of a file.
   *)
  (# &lt;&lt;SLOT FileLib: attributes&gt;&gt;;
     
     <B>EntryDesc</B><A name="File.1:EntryDesc.2(771)"></A><A name="EntryDesc.2(771)"></A>:&lt; DiskEntry;
     <B>Entry</B><A name="File.1:Entry.2(772)"></A><A name="Entry.2(772)"></A>: @EntryDesc
       (* The item holding most characterizing attributes of
        * THIS(file)
        *);
     <B>name</B><A name="File.1:name.2(773)"></A><A name="name.2(773)"></A>: @
       (* convenient interface to entry.path *)
       (# read:
            (* Reads the file name from the Keyboard *)
            (# ... #);
       enter entry.path
       exit entry.path
       #);
     <B>Put</B><A name="File.1:Put.2(774)"></A><A name="Put.2(774)"></A>::&lt;  (# ... #);
     <B>Get</B><A name="File.1:Get.2(775)"></A><A name="Get.2(775)"></A>::&lt;  (# ... #);
     <B>Peek</B><A name="File.1:Peek.2(776)"></A><A name="Peek.2(776)"></A>::&lt; (# ... #);
     <B>PutText</B><A name="File.1:PutText.2(777)"></A><A name="PutText.2(777)"></A>::&lt; (# ... #);
     <B>GetAtom</B><A name="File.1:GetAtom.2(778)"></A><A name="GetAtom.2(778)"></A>::&lt; (# ... #);
     <B>GetLine</B><A name="File.1:GetLine.2(779)"></A><A name="GetLine.2(779)"></A>::&lt; (# ... #);
     <B>Length</B><A name="File.1:Length.2(780)"></A><A name="Length.2(780)"></A>::&lt;
       (* Returns the byte size of THIS(file). Notice that this is
        * not always the same as entry.size, which is how many bytes
        * THIS(file) occupies on the disk
        *)
       (# ... #);
     <B>GetPos</B><A name="File.1:GetPos.2(781)"></A><A name="GetPos.2(781)"></A>::&lt;
       (* Returns current position of THIS(File) *)
       (# ... #);
     <B>SetPos</B><A name="File.1:SetPos.2(782)"></A><A name="SetPos.2(782)"></A>::&lt;
       (* Sets position on THIS(file).  Enters position and mode. See
        * above for definition of constants to use as mode,
        * FromBeginning, FromCurrent, FromEnd.  Returns the absolute
        * position seeked to [0..File.Length-1].
        *)
       (# mode,newpos: @integer
       enter mode
       ... 
       exit newpos
       #);
     <B>Eos</B><A name="File.1:Eos.2(783)"></A><A name="Eos.2(783)"></A>::&lt; (# ... #);
     <B>touch</B><A name="File.1:touch.2(784)"></A><A name="touch.2(784)"></A>: entry.touch
       (* If the disk entry does not exist, an empty file will be
        * created.
        *)
       (# ... #);
     <B>delete</B><A name="File.1:delete.2(785)"></A><A name="delete.2(785)"></A>:
       (* Deletes THIS(File) *)
       (# ... #);
     <B>binary</B><A name="File.1:binary.2(786)"></A><A name="binary.2(786)"></A>:&lt; booleanvalue
       (* THIS(File) is binary if value is true. On some systems a
        * non-binary (e.g. textual) file may behave differently, than
        * a binary file. A binary file is always treated as raw bytes,
        * whereas a non-binary file may treat some characters, notably
        * the end-of-line marker, differently.
        *);
     <B>openRead</B><A name="File.1:openRead.2(787)"></A><A name="openRead.2(787)"></A>:
       (* opens THIS(File) for reading, starting at the beginning *)
       (# ... #);
     <B>openWrite</B><A name="File.1:openWrite.2(788)"></A><A name="openWrite.2(788)"></A>:
       (* Opens THIS(File) for writing.  truncates the contents of
        * the disk file if it already existed, and creates the disk
        * file if not
        *)
       (# ... #);
     <B>openAppend</B><A name="File.1:openAppend.2(789)"></A><A name="openAppend.2(789)"></A>:
       (* Opens THIS(File) for writing at the end.  Setpos cannot be
        * used to write other places than at the end.  Creates the
        * file if it did not exist.
        *)
       (# ... #);
     <B>openReadWrite</B><A name="File.1:openReadWrite.2(790)"></A><A name="openReadWrite.2(790)"></A>:
       (* Opens THIS(File) for both reading and writing.  The file is
        * positioned at the beginning. To switch between writing and
        * reading an intermediate setpos may be necessary.
        *)
       (# ... #);
     <B>openReadAppend</B><A name="File.1:openReadAppend.2(791)"></A><A name="openReadAppend.2(791)"></A>:
       (* Like OpenReadWrite, but positiones at the end *)
       (# ... #);
     <B>flush</B><A name="File.1:flush.2(792)"></A><A name="flush.2(792)"></A>: 
       (* Flushes THIS(File). Affects only files opened for output *)
       (# ... #);
     <B>close</B><A name="File.1:close.2(793)"></A><A name="close.2(793)"></A>:  (* Closes THIS(File) *)
       (# ... #);    
     
     (* FILE EXCEPTIONS *)
     
     <B>FileException</B><A name="File.1:FileException.2(794)"></A><A name="FileException.2(794)"></A>: StreamException
       (* General File exception *)
       (# m: ^text
       enter m[]
       ...
       #);
     <B>OpenException</B><A name="File.1:OpenException.2(795)"></A><A name="OpenException.2(795)"></A>: FileException
       (* Raised if opening of a file has failed. Message: "Cannot
        *         open file".
        *)
       (# ... #);
     <B>AccessError</B><A name="File.1:AccessError.2(796)"></A><A name="AccessError.2(796)"></A>:&lt; OpenException
       (* Raised on attempt to access a file with insufficient
        * privilegies.  Message: "Insufficient access privilegies".
        *)
       (# ... #);
     <B>WriteError</B><A name="File.1:WriteError.2(797)"></A><A name="WriteError.2(797)"></A>:&lt; FileException
       (* Raised from Put, PutText and Flush on attempt to write on a
        * non-existing block. Message: "Write block error".
        *)
       (# ... #);
     <B>ReadError</B><A name="File.1:ReadError.2(798)"></A><A name="ReadError.2(798)"></A>:&lt; FileException
       (* Raised from Get and Peek on attempt to read a non-existing
        * block. Message: "Read block error".
        *)
       (# ... #);
     <B>EOSerror</B><A name="File.1:EOSerror.2(799)"></A><A name="EOSerror.2(799)"></A>::&lt; (# ... #);
     <B>NoSuchFileError</B><A name="File.1:NoSuchFileError.2(800)"></A><A name="NoSuchFileError.2(800)"></A>:&lt; FileException
       (* Raised on attempt to open a non-existing file. Message:
        * "File does not exist"
        *)
       (# ... #);
     <B>FileExistsError</B><A name="File.1:FileExistsError.2(801)"></A><A name="FileExistsError.2(801)"></A>:&lt; FileException
       (* Raised when creating an already existing file. Message:
        * "File does already exist".
        *)
       (# ... #);
     <B>NoSpaceError</B><A name="File.1:NoSpaceError.2(802)"></A><A name="NoSpaceError.2(802)"></A>:&lt; FileException
       (* Raised when the file system is full. Message: "File system
        * is full".
        *)
       (# ... #);
     <B>OtherError</B><A name="File.1:OtherError.2(803)"></A><A name="OtherError.2(803)"></A>:&lt; FileException
       (* Raised when errors other than the above occur *)
       (# ... #);
     <B>private</B><A name="File.1:private.2(804)"></A><A name="private.2(804)"></A>: @ ...; 
     <B>getRep</B><A name="File.1:getRep.2(805)"></A><A name="getRep.2(805)"></A>:
       (* OBSOLETE - only supplied for compatibility. 
        * The operation getBytes from binfile should be used instead.
        *)
       (# repAdr (* @@ rep[inx]: start address *),
          length (* max. no. of elements to read *): @integer;
       enter(repAdr,length)
       ...
       exit(length div 4)
       #);
     <B>putRep</B><A name="File.1:putRep.2(806)"></A><A name="putRep.2(806)"></A>:
       (* OBSOLETE - only supplied for compatibility. 
        * The operation putBytes from binfile should be used instead.
        *)
       (# repAdr (* @@rep[inx]: start address *),
          length (* no. of rep-elements to be and was written
                  *): @integer;
       enter(repAdr,length)
       ...
       exit (length div 4)
       #);
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="33%" align="left"><ADDRESS>Interface Description</ADDRESS></TD>
<TD width="34%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="33%" align="right"><FONT size=-1><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></FONT></TD>
</TABLE>
<P></P>
<A HREF="directory.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="regexp.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
