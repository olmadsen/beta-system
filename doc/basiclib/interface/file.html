<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>File Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="formatio.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="external.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Prev BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>File Interface</H1>
<PRE CLASS=interface>
ORIGIN 'betaenv';
LIB_DEF 'file' '../lib';
BODY 'private/filebody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1984-96
 *       All rights reserved.
 *
 * The BETA interface to disk-entries in a hierarchic file system
 * files, and directories is organised as follows:
 * 
 *   DiskEntry:     Machine independent interface to entries like
 *                  file and directories on the disk 
 *                  (file 'file.bet').
 *   UnixEntry:     Unix specific specialization of DiskEntry 
 *                  (file 'unixfile.bet').
 *   MacEntry:      Macintosh specific specialization of DiskEntry 
 *                  (file 'macfile.bet').
 * 
 *   File:          Machine independent interface to disk files. Is  
 *                  a specialization of Stream (file 'betaenv.bet'),
 *                  and contains a DiskEntry (file 'file.bet').
 *   UnixFile:      Unix specific specialization of File, which 
 *                  contains a UnixEntry (file 'unixfile.bet').
 *   MacFile:       Macintosh  specific specialization of File,
 *                   which contains a MacEntry (file 'macfile.bet').
 *    
 *   Directory:     Machine independent interface to 
 *                  directories/folders. Contains a DiskEntry 
 *                  (file 'directory.bet').
 *   UnixDirectory: Unix specific specialization of Directory, 
 *                  which contains a UnixEntry 
 *                  (file 'unixdirectory.bet').
 *   MacDirectory:  Macintosh specific specialization of Directory,
 *                  which contains a MacEntry 
 *                  (file 'macdirectory.bet').
 *)
-- LIB: Attributes --
<b>DiskEntry</b><A name="DiskEntry.1(402)"></A>:
  (* Pattern describing various attributes of disk-entries like files
   * and directories in a hierarchic file system
   *)
  (# &lt;&lt;SLOT DiskEntryLib: attributes&gt;&gt;;
     
     (* DISK ENTRY EXCEPTIONS *)
     <b>DiskEntryException</b><A name="DiskEntry.1:DiskEntryException.2(403)"></A><A name="DiskEntryException.2(403)"></A><A name="DiskEntry.1:Exception.2:_subpatterns.3:DiskEntryException.4"></A>: Exception
       (* General exception for disk entries *)
       (# ... #);
     <b>DiskEntryExistsException</b><A name="DiskEntry.1:DiskEntryExistsException.2(404)"></A><A name="DiskEntryExistsException.2(404)"></A><A name="DiskEntry.1:DiskEntryException.2:_subpatterns.3:DiskEntryExistsException.4"></A>: DiskEntryException
       (* Raised if a test for disk entry existence has
        * failed. Message: "Test for disk entry existence failed.",
        * and an indication of why it failed.
        *)
       (# ... #);
     <b>DiskEntryModtimeException</b><A name="DiskEntry.1:DiskEntryModtimeException.2(405)"></A><A name="DiskEntryModtimeException.2(405)"></A><A name="DiskEntry.1:DiskEntryException.2:_subpatterns.3:DiskEntryModtimeException.4"></A>: DiskEntryException
       (* Raised if examination or setting of disk entry modtime has failed.
        * Message: "Examination/setting of disk entry modtime failed.", and an
        * indication of why it failed.
        *)
       (# ... #);
     <b>DiskEntryTouchException</b><A name="DiskEntry.1:DiskEntryTouchException.2(406)"></A><A name="DiskEntryTouchException.2(406)"></A><A name="DiskEntry.1:DiskEntryException.2:_subpatterns.3:DiskEntryTouchException.4"></A>: DiskEntryException
       (* Raised if touch of a disk entry has failed. Message: "Touch
        * of disk entry failed.", and an indication of why it failed.
        *)
       (# ... #);
     <b>DiskEntryRenameException</b><A name="DiskEntry.1:DiskEntryRenameException.2(407)"></A><A name="DiskEntryRenameException.2(407)"></A><A name="DiskEntry.1:DiskEntryException.2:_subpatterns.3:DiskEntryRenameException.4"></A>: DiskEntryException
       (* Raised if rename of a disk entry has failed. Message:
        * "Rename of disk entry failed.", and an indication of why it
        * failed.
        *)
       (# ... #);
     <b>pathDesc</b><A name="DiskEntry.1:pathDesc.2(408)"></A><A name="pathDesc.2(408)"></A>:&lt;
       (* A virtual descriptor for the full or relative path of
        * THIS(DiskEntry)
        *)
       (# <b>head</b><A name="DiskEntry.1:pathDesc.2:head.3(409)"></A><A name="head.3(409)"></A>:&lt;
            (* The head of the path, e.g. head of '/usr/smith/foo.bet'
             * is '/usr/smith'
             *)
            (# h: ^text
            ... 
            exit h[] 
            #);
          <b>nameDesc</b><A name="DiskEntry.1:pathDesc.2:nameDesc.3(410)"></A><A name="nameDesc.3(410)"></A>:&lt; 
            (* The actual name-part of the path, e.g. name part of
             * '/usr/smith/foo.bet' is 'foo.bet'
             *) 
            (# <b>prefix</b><A name="DiskEntry.1:pathDesc.2:nameDesc.3:prefix.4(411)"></A><A name="prefix.4(411)"></A>:&lt;
                 (* exits the prefix part of the name, i.e. what is
                  * before the last dot (.), e.g 'foo' for 'foo.bet'
                  *)
                 (# p: ^text 
                 ... 
                 exit p[]
                 #);
               <b>extension</b><A name="DiskEntry.1:pathDesc.2:nameDesc.3:extension.4(412)"></A><A name="extension.4(412)"></A>:&lt;
                 (* exits the extension part of the name, i.e. what
                  * is after the last dot (.), e.g. 'bet' for 'foo.bet'
                  *)
                 (# e: ^text 
                 ... 
                 exit e[]
                 #);
               <b>suffix</b><A name="DiskEntry.1:pathDesc.2:nameDesc.3:suffix.4(413)"></A><A name="suffix.4(413)"></A>:&lt;
                 (* like extension, but includes the dot (.),
                  * e.g. '.bet' for 'foo.bet'
                  *)
                 (# s: ^text
                 ...
                 exit s[]
                 #);
               <b>get</b><A name="DiskEntry.1:pathDesc.2:nameDesc.3:get.4(414)"></A><A name="get.4(414)"></A>:&lt;
                 (* exits "prefix.extension" *)
                 (# n: ^text 
                 ... 
                 exit n[]
                 #);
            exit get
            #);
          <b>name</b><A name="DiskEntry.1:pathDesc.2:name.3(415)"></A><A name="name.3(415)"></A>: @nameDesc;
          <b>set</b><A name="DiskEntry.1:pathDesc.2:set.3(416)"></A><A name="set.3(416)"></A>:&lt; 
            (* set the entire path *)
            (# p: ^text 
            enter p[]
            ... 
            #);
          <b>get</b><A name="DiskEntry.1:pathDesc.2:get.3(417)"></A><A name="get.3(417)"></A>:&lt; 
            (* get the entire path *)
            (# p: ^text 
            ... 
            exit p[]
            #);
       enter set
       do INNER
       exit get
       #);
     <b>path</b><A name="DiskEntry.1:path.2(418)"></A><A name="path.2(418)"></A>: @pathDesc;
     <b>exists</b><A name="DiskEntry.1:exists.2(419)"></A><A name="exists.2(419)"></A><A name="DiskEntry.1:BooleanValue.2:_subpatterns.3:exists.4"></A>: BooleanValue
       (* exits a boolean indicating whether the disk entry
        * corresponding to the current setting of path actually exists
        *)
       (# error:&lt; DiskEntryExistsException;
       ...
       #);
     <b>modtime</b><A name="DiskEntry.1:modtime.2(420)"></A><A name="modtime.2(420)"></A>: 
       (* exits an integer denoting the (system) time of the last
        *         modification
        *)
       (# time: @integer;
          error:&lt;DiskEntryModTimeException;
       enter (# enter time ... #)
       exit (# ... exit time #)
       #); 
     <b>touch</b><A name="DiskEntry.1:touch.2(421)"></A><A name="touch.2(421)"></A>:
       (* Updates the modtime to the current (system) time. *)
       (# error:&lt; DiskEntryTouchException;
       ...
       #);
     <b>rename</b><A name="DiskEntry.1:rename.2(422)"></A><A name="rename.2(422)"></A>:
       (* Rename the disk entry. Changes the physical disk entry and
        * updates THIS(DiskEntry).path
        *)
       (# newpath: ^text;
          error:&lt; DiskEntryRenameException;
       enter newpath[]
       ...
       #);
     <b>size</b><A name="DiskEntry.1:size.2(423)"></A><A name="size.2(423)"></A><A name="DiskEntry.1:IntegerValue.2:_subpatterns.3:size.4"></A>: IntegerValue
       (* exits the size of THIS(DiskEntry) in bytes *)
       (# error:&lt;DiskEntryException;
       ... 
       #);
     <b>readable</b><A name="DiskEntry.1:readable.2(424)"></A><A name="readable.2(424)"></A><A name="DiskEntry.1:BooleanValue.2:_subpatterns.3:readable.4"></A>: BooleanValue
       (* exits true if THIS(DiskEntry) can be read *)
       (# error:&lt; DiskEntryException;
       ... 
       #);
     <b>writeable</b><A name="DiskEntry.1:writeable.2(425)"></A><A name="writeable.2(425)"></A><A name="DiskEntry.1:BooleanValue.2:_subpatterns.3:writeable.4"></A>: BooleanValue
       (* exits true if THIS(DiskEntry) can be written to *)
       (# error:&lt; DiskEntryException;
          checkwrite: @...; 
       do checkwrite
       #);
     <b>isFile</b><A name="DiskEntry.1:isFile.2(426)"></A><A name="isFile.2(426)"></A><A name="DiskEntry.1:BooleanValue.2:_subpatterns.3:isFile.4"></A>: BooleanValue
       (* True if THIS(DiskEntry) is a regular file *)
       (# error:&lt; DiskEntryException;
       ...
       #);
     <b>isDirectory</b><A name="DiskEntry.1:isDirectory.2(427)"></A><A name="isDirectory.2(427)"></A><A name="DiskEntry.1:BooleanValue.2:_subpatterns.3:isDirectory.4"></A>: BooleanValue
       (* True if THIS(DiskEntry) is a directory *)
       (# error:&lt;DiskEntryException;
       ...
       #);
     
     <b>private</b><A name="DiskEntry.1:private.2(428)"></A><A name="private.2(428)"></A>: @...
  do INNER
  #); (* DiskEntry *)

(* Constants used for specifying mode to File.SetPos. *)
<b>FromBeginning</b><A name="FromBeginning.1(429)"></A>:   
  (* Seeks relative to the beginning of a file.  Corresponds to
   * absolute positions in File[0:File.Length-1].
   *)
  (# exit 0 #);
<b>FromCurrent</b><A name="FromCurrent.1(430)"></A>:  
  (* Seeks relative to the current position.   *)
  (# exit 1 #); 
<b>FromEnd</b><A name="FromEnd.1(431)"></A>:          
  (* Seeks relative to the end of a file. *)
  (# exit 2 #);

<b>File</b><A name="File.1(432)"></A><A name="Stream.:_subpatterns.2:File.3"></A>: Stream
  (* Generalization of disk file.  Describes the stream aspects of
   * files, providing buffered I/O, and contains a DiskEntry object
   * describing the other properties of a file.
   *)
  (# &lt;&lt;SLOT FileLib: attributes&gt;&gt;;
     
     <b>EntryDesc</b><A name="File.1:EntryDesc.2(433)"></A><A name="EntryDesc.2(433)"></A>:&lt; DiskEntry;
     <b>Entry</b><A name="File.1:Entry.2(434)"></A><A name="Entry.2(434)"></A>: @EntryDesc
       (* The item holding most characterizing attributes of
        * THIS(file)
        *);
     <b>name</b><A name="File.1:name.2(435)"></A><A name="name.2(435)"></A>: @
       (* convenient interface to entry.path *)
       (# read:
            (* Reads the file name from the Keyboard *)
            (# ... #);
       enter entry.path
       exit entry.path
       #);
     <b>Put</b><A name="File.1:Put.2(436)"></A><A name="Put.2(436)"></A>::&lt;  (# ... #);
     <b>Get</b><A name="File.1:Get.2(437)"></A><A name="Get.2(437)"></A>::&lt;  (# ... #);
     <b>Peek</b><A name="File.1:Peek.2(438)"></A><A name="Peek.2(438)"></A>::&lt; (# ... #);
     <b>PutText</b><A name="File.1:PutText.2(439)"></A><A name="PutText.2(439)"></A>::&lt; (# ... #);
     <b>GetAtom</b><A name="File.1:GetAtom.2(440)"></A><A name="GetAtom.2(440)"></A>::&lt; (# ... #);
     <b>GetLine</b><A name="File.1:GetLine.2(441)"></A><A name="GetLine.2(441)"></A>::&lt; (# ... #);
     <b>Length</b><A name="File.1:Length.2(442)"></A><A name="Length.2(442)"></A>::&lt;
       (* Returns the byte size of THIS(file). Notice that this is
        * not always the same as entry.size, which is how many bytes
        * THIS(file) occupies on the disk
        *)
       (# ... #);
     <b>GetPos</b><A name="File.1:GetPos.2(443)"></A><A name="GetPos.2(443)"></A>::&lt;
       (* Returns current position of THIS(File) *)
       (# ... #);
     <b>SetPos</b><A name="File.1:SetPos.2(444)"></A><A name="SetPos.2(444)"></A>::&lt;
       (* Sets position on THIS(file).  Enters position and mode. See
        * above for definition of constants to use as mode,
        * FromBeginning, FromCurrent, FromEnd.  Returns the absolute
        * position seeked to [0..File.Length-1].
        *)
       (# mode,newpos: @integer
       enter mode
       ... 
       exit newpos
       #);
     <b>Eos</b><A name="File.1:Eos.2(445)"></A><A name="Eos.2(445)"></A>::&lt; (# ... #);
     <b>touch</b><A name="File.1:touch.2(446)"></A><A name="touch.2(446)"></A>: entry.touch
       (* If the disk entry does not exist, an empty file will be
        * created.
        *)
       (# ... #);
     <b>delete</b><A name="File.1:delete.2(447)"></A><A name="delete.2(447)"></A>:
       (* Deletes THIS(File) *)
       (# ... #);
     <b>binary</b><A name="File.1:binary.2(448)"></A><A name="binary.2(448)"></A>:&lt; booleanvalue
       (* THIS(File) is binary if value is true. On some systems a
        * non-binary (e.g. textual) file may behave differently, than
        * a binary file. A binary file is always treated as raw bytes,
        * whereas a non-binary file may treat some characters, notably
        * the end-of-line marker, differently.
        *);
     <b>openRead</b><A name="File.1:openRead.2(449)"></A><A name="openRead.2(449)"></A>:
       (* opens THIS(File) for reading, starting at the beginning *)
       (# ... #);
     <b>openWrite</b><A name="File.1:openWrite.2(450)"></A><A name="openWrite.2(450)"></A>:
       (* Opens THIS(File) for writing.  truncates the contents of
        * the disk file if it already existed, and creates the disk
        * file if not
        *)
       (# ... #);
     <b>openAppend</b><A name="File.1:openAppend.2(451)"></A><A name="openAppend.2(451)"></A>:
       (* Opens THIS(File) for writing at the end.  Setpos cannot be
        * used to write other places than at the end.  Creates the
        * file if it did not exist.
        *)
       (# ... #);
     <b>openReadWrite</b><A name="File.1:openReadWrite.2(452)"></A><A name="openReadWrite.2(452)"></A>:
       (* Opens THIS(File) for both reading and writing.  The file is
        * positioned at the beginning. To switch between writing and
        * reading an intermediate setpos may be necessary.
        *)
       (# ... #);
     <b>openReadAppend</b><A name="File.1:openReadAppend.2(453)"></A><A name="openReadAppend.2(453)"></A>:
       (* Like OpenReadWrite, but positiones at the end *)
       (# ... #);
     <b>flush</b><A name="File.1:flush.2(454)"></A><A name="flush.2(454)"></A>: 
       (* Flushes THIS(File). Affects only files opened for output *)
       (# ... #);
     <b>close</b><A name="File.1:close.2(455)"></A><A name="close.2(455)"></A>:  (* Closes THIS(File) *)
       (# ... #);    
     
     (* FILE EXCEPTIONS *)
     
     <b>FileException</b><A name="File.1:FileException.2(456)"></A><A name="FileException.2(456)"></A><A name="File.1:StreamException.2:_subpatterns.3:FileException.4"></A>: StreamException
       (* General File exception *)
       (# m: ^text
       enter m[]
       ...
       #);
     <b>OpenException</b><A name="File.1:OpenException.2(457)"></A><A name="OpenException.2(457)"></A><A name="File.1:FileException.2:_subpatterns.3:OpenException.4"></A>: FileException
       (* Raised if opening of a file has failed. Message: "Cannot
        *         open file".
        *)
       (# ... #);
     <b>AccessError</b><A name="File.1:AccessError.2(458)"></A><A name="AccessError.2(458)"></A>:&lt; OpenException
       (* Raised on attempt to access a file with insufficient
        * privilegies.  Message: "Insufficient access privilegies".
        *)
       (# ... #);
     <b>WriteError</b><A name="File.1:WriteError.2(459)"></A><A name="WriteError.2(459)"></A>:&lt; FileException
       (* Raised from Put, PutText and Flush on attempt to write on a
        * non-existing block. Message: "Write block error".
        *)
       (# ... #);
     <b>ReadError</b><A name="File.1:ReadError.2(460)"></A><A name="ReadError.2(460)"></A>:&lt; FileException
       (* Raised from Get and Peek on attempt to read a non-existing
        * block. Message: "Read block error".
        *)
       (# ... #);
     <b>EOSerror</b><A name="File.1:EOSerror.2(461)"></A><A name="EOSerror.2(461)"></A>::&lt; (# ... #);
     <b>NoSuchFileError</b><A name="File.1:NoSuchFileError.2(462)"></A><A name="NoSuchFileError.2(462)"></A>:&lt; FileException
       (* Raised on attempt to open a non-existing file. Message:
        * "File does not exist"
        *)
       (# ... #);
     <b>FileExistsError</b><A name="File.1:FileExistsError.2(463)"></A><A name="FileExistsError.2(463)"></A>:&lt; FileException
       (* Raised when creating an already existing file. Message:
        * "File does already exist".
        *)
       (# ... #);
     <b>NoSpaceError</b><A name="File.1:NoSpaceError.2(464)"></A><A name="NoSpaceError.2(464)"></A>:&lt; FileException
       (* Raised when the file system is full. Message: "File system
        * is full".
        *)
       (# ... #);
     <b>OtherError</b><A name="File.1:OtherError.2(465)"></A><A name="OtherError.2(465)"></A>:&lt; FileException
       (* Raised when errors other than the above occur *)
       (# ... #);
     <b>private</b><A name="File.1:private.2(466)"></A><A name="private.2(466)"></A>: @ ...; 
     <b>getRep</b><A name="File.1:getRep.2(467)"></A><A name="getRep.2(467)"></A>:
       (* OBSOLETE - only supplied for compatibility. 
        * The operation getBytes from binfile should be used instead.
        *)
       (# repAdr (* @@ rep[inx]: start address *),
          length (* max. no. of elements to read *): @integer;
       enter(repAdr,length)
       ...
       exit(length div 4)
       #);
     <b>putRep</b><A name="File.1:putRep.2(468)"></A><A name="putRep.2(468)"></A>:
       (* OBSOLETE - only supplied for compatibility. 
        * The operation putBytes from binfile should be used instead.
        *)
       (# repAdr (* @@rep[inx]: start address *),
          length (* no. of rep-elements to be and was written
                  *): @integer;
       enter(repAdr,length)
       ...
       exit (length div 4)
       #);
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<ADDRESS>Interface Description</ADDRESS>
<P></P>
<A HREF="formatio.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="external.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Prev BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
