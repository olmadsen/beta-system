<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Numberio Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent("numberio")'>
<H1><A name="numberio">Numberio Interface</A></H1>

<PRE CLASS=interface>
ORIGIN 'betaenv';
LIB_DEF 'numberio' '../lib';
BODY 'private/numberioBody'
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1992-96
 *       All rights reserved.
 *
 * This fragment implements the following stream operations:
 *    getNumber  * reads a number from THIS(stream).
 *               * The number may be either an integer, 
 *               * a based number or a real number
 *    getBased   * reads a based number from THIS(stream)
 *    getRadix   * reads a based number from THIS(stream), 
 *               * without the 'bbx' part
 *    getInteger * reads an integer number from THIS(stream)
 *    getReal    * reads a real number from THIS(stream)
 *    putReal    * appends a textual rep. of a real value to 
 *               * THIS(stream)
 *    putBased   * appends a textual rep. of a integer value in a 
 *               * particular to THIS(stream).  The textual
 *               * representation in in the given base
 *    putRadix   * as putBased, except that the 'bbx' part is
 *               * not printed
 *    getHex     * similar to getRadix with radix 16, but more efficient.
 *    putHex     * similar to putBased with base 16, but more efficient.
 *    getOctal   * similar to getOctal with base 8, but more efficient.
 *    putOctal   * similar to putBased with base 8, but more efficient.
 *    getBinary  * similar to getRadix with radix 2, but more efficient.
 *    putBinary  * similar to putBased with base 2, but more efficient.
 *    putByteHex    * like putHex, except that it only prints one byte.
 *    putByteBinary * like putBinary, except that it only prints one byte.
 * 
 *    asNumber   * abstract pattern for the following asBased,
 *               * asRadix, and asReal operations
 *    asBased    * returns the based number present in
 *               * THIS(stream)
 *    asRadix    * returns the based number present in
 *               * THIS(stream), without the 'bbx' part
 *    asReal     * returns the real number present in
 *               * THIS(stream)
 * 
 * The corresponding short-cuts for keyboard.getNumber, etc, and 
 * screen.putReal, etc. are also included in this fragment.
 * 
 * Since the asNumber operations does not make sence for keyboard,
 * no short-cuts are defined for these.
 *)
--- StreamLib: attributes ---
<B>getNumber</B><A name="getNumber.1(768)"></A>:  
  (* getNumber reads a number from the current position of 
   * this(stream).
   * The number is either an integer (in base 10), an integer with a
   *  given base, or a real.
   * Integer examples:  10, 0, 123
   * A based integer has the form &lt;base&gt;X&lt;number&gt;. Examples are:
   *    2X101          base=2, number= 4*1 + 2*0 + 1*1 = 5
   *    8X12           base=8, number= 8*1 + 1*2 = 10
   *    16x2A1         base=16, number= 256*2 + 16*10 + 1*1  = 673
   *     0x2A1         base=16, i.e. base=0 is interpreted as base=16
   * Examples of reals are:
   *   3.14, 3.14E-8, 3E+8
   * The following grammar defines the exact syntax of the numbers:
   *
   * N ::= {D}+                        Int             314
   *    |  {D}+ '.' {D}+               real            3.14
   *    |  {D}+ '.' {D}+ 'E' E         real            3.14E8
   *                                   real            3.14E+8
   *                                   real            3.14E-8
   *
   *    |  {D}+  'E' E                 real            3E8
   *                                   real            3E+8
   *                                   real            3E-8
   *    |  'X' {D | L}+                based           2X0101
   *                                   based           8x0845
   *                                   based           16xAF12
   * D ::= {'0' | ... | '9' }
   * L ::= {'A' | ... | 'Z'}
   * E ::= {D}+
   *    |  {D}+ '+' {D}+               
   *    |  {D}+ '-' {D}+
   *    
   * All letters may be in lower or upper case.
   * After the call, the stream is positioned
   * after the first char not in the number.
   *)
  (# <B>integerValue</B><A name="getNumber.1.integerValue.2(769)"></A><A name="integerValue.2(769)"></A>:&lt;
       (* the number has the form
        *     x
        * value contains the integer value
        *)
       integerValuePtn;
     <B>integerValuePtn</B><A name="getNumber.1.integerValuePtn.2(770)"></A><A name="integerValuePtn.2(770)"></A>:
       (# value: @integer enter value do INNER #);
     <B>basedValue</B><A name="getNumber.1.basedValue.2(771)"></A><A name="basedValue.2(771)"></A>:&lt;
       (* the number has the form
        *     bXy
        * base contains the base number
        * value contains the integer value (in base 10)
        *)
       basedValuePtn;
     <B>basedValuePtn</B><A name="getNumber.1.basedValuePtn.2(772)"></A><A name="basedValuePtn.2(772)"></A>:
       (# base,value: @integer enter (base,value) do INNER #);
     <B>realValue</B><A name="getNumber.1.realValue.2(773)"></A><A name="realValue.2(773)"></A>:&lt;
       (* the  number has the form 
        *       x.yEz
        *       l is the number of leading zero's in y. i.e. in
        *       3.0017E-12, x=3, y=17,l=2 and z=-12
        * value contains the real value
        *)
       realValuePtn;
     <B>realValuePtn</B><A name="getNumber.1.realValuePtn.2(774)"></A><A name="realValuePtn.2(774)"></A>:
       (# x,y,l,z: @real; value: @real enter(x,y,l,z,value)
       do INNER #);
     <B>syntaxError</B><A name="getNumber.1.syntaxError.2(775)"></A><A name="syntaxError.2(775)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'getNumber: Syntax error - looking at: "'-&gt;msg.append;
          (if peekCh = ascii.nul then 'NUL'-&gt;msg.puttext
           else peekCh-&gt;msg.put if);
          '"'-&gt;msg.put; INNER #);
     <B>baseError</B><A name="getNumber.1.baseError.2(776)"></A><A name="baseError.2(776)"></A>:&lt; streamException
       (# base: @integer
       enter base
       do 'getNumber: Error in base - looking at: "'-&gt;msg.append; 
          base-&gt;msg.putInt; '"'-&gt;msg.put; INNER #);
     <B>valueError</B><A name="getNumber.1.valueError.2(777)"></A><A name="valueError.2(777)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'getNumber: Illegal value type - looking at: "'-&gt;msg.append;
          peekCh-&gt;msg.put; '"'-&gt;msg.put; INNER #);
     <B>overflow</B><A name="getNumber.1.overflow.2(778)"></A><A name="overflow.2(778)"></A>:&lt; streamException
       (# value: @integer
       do 'getNumber: Overflow in integer- or based-value'-&gt;msg.append;
          INNER
       exit value
       #);
     <B>underflow</B><A name="getNumber.1.underflow.2(779)"></A><A name="underflow.2(779)"></A>:&lt; streamException
       (# value: @integer
       do 'getNumber: Underflow in integer- or based-value'-&gt;msg.append;
          INNER
       exit value
       #);
     <B>getn</B><A name="getNumber.1.getn.2(780)"></A><A name="getn.2(780)"></A>: @...
  do getn;
     INNER getNumber
  #);
<B>getReal</B><A name="getReal.1(781)"></A>: getNumber
  (# <B>r</B><A name="getReal.1.r.2(782)"></A><A name="r.2(782)"></A>: @real;
     <B>realValue</B><A name="getReal.1.realValue.2(783)"></A><A name="realValue.2(783)"></A>::&lt; (# do value-&gt;r #);
  do INNER getReal
  exit r
  #);
<B>getBased</B><A name="getBased.1(784)"></A>: getNumber
  (# <B>i</B><A name="getBased.1.i.2(785)"></A><A name="i.2(785)"></A>,<B> b</B><A name="getBased.1.b.2(786)"></A><A name="b.2(786)"></A>: @integer;
     <B>basedValue</B><A name="getBased.1.basedValue.2(787)"></A><A name="basedValue.2(787)"></A>::&lt; (# do value-&gt;i; base-&gt;b #);
  do INNER getBased
  exit (b,i)
  #);
<B>getInteger</B><A name="getInteger.1(788)"></A>: getNumber
  (# <B>i</B><A name="getInteger.1.i.2(789)"></A><A name="i.2(789)"></A>: @integer;
     <B>integerValue</B><A name="getInteger.1.integerValue.2(790)"></A><A name="integerValue.2(790)"></A>::&lt; (# do value-&gt;i #);
  do INNER getInteger
  exit i
  #);
<B>getRadix</B><A name="getRadix.1(791)"></A>:
  (* gets a number in the specified radix.  GetRadix is similar to
   * getBased, except that is does NOT expect the 'bbx' prefix
   *)
  (# <B>radix</B><A name="getRadix.1.radix.2(792)"></A><A name="radix.2(792)"></A>,<B> value</B><A name="getRadix.1.value.2(793)"></A><A name="value.2(793)"></A>: @integer;
     <B>radixError</B><A name="getRadix.1.radixError.2(794)"></A><A name="radixError.2(794)"></A>:&lt; streamException
       (# radix: @integer
       enter radix
       ...
       #);
     <B>getr</B><A name="getRadix.1.getr.2(795)"></A><A name="getr.2(795)"></A>: (* private *) @...
  enter radix
  do getr;
     INNER getRadix
  exit value
  #);

<B>putBased</B><A name="putBased.1(796)"></A>:
  (* Takes a number and a base, and prints the number in that base.
   * If base is 0, base 16 is assumed, and the format "0xnnn" is used.
   * If base is negative, 1 or greater that 126, the baseError
   * exception is invoked.
   * 
   * The format is default "bbxnnnn", where "bb" is the base (in
   * decimal), and "nnnn" is the number, printed in the base. "x"
   * separates the two parts.  The format may be controlled by the
   * signed, blankSign, upcase, uppercase, width, adjustLeft,
   * zeroPadding, noBasePrefix, baseWidth and baseZeroPadding variable
   * attributes. If noBasePrefix is true, the "bbx" part is omitted.
   *)
  (# <B>value</B><A name="putBased.1.value.2(797)"></A><A name="value.2(797)"></A>,<B> base</B><A name="putBased.1.base.2(798)"></A><A name="base.2(798)"></A>: @integer;
     <B>baseError</B><A name="putBased.1.baseError.2(799)"></A><A name="baseError.2(799)"></A>:&lt; streamException
       (# base: @integer
       enter base
       do 'putBased: Illegal base: "'-&gt;msg.append; 
          base-&gt;msg.putInt; '"'-&gt;msg.put; INNER #);
     (* The format may be further controlled by the signed, blankSign,
      * width, adjustLeft and zeroPadding variable attributes.  
      * width is extended if it is too small.
      *
      * Examples:
      *   (10,10)-&gt;putBased
      *      yields: '10x10'
      *   (2,5)-&gt;putBased(# do 10-&gt;width; true-&gt;adjustLeft #);
      *      yields: '2x101     '
      *   (2,5)-&gt;putBased(# do 10-&gt;width; true-&gt;zeroPadding #);
      *      yields: '2x00000101'
      *)
     <B>signed</B><A name="putBased.1.signed.2(800)"></A><A name="signed.2(800)"></A>:
       (* If the number is positive, a '+' will always be displayed
        *)
       @boolean;
     <B>blankSign</B><A name="putBased.1.blankSign.2(801)"></A><A name="blankSign.2(801)"></A>:
       (* If the number is positive, a ' ' space is displayed as the
        * sign.  Ignored if signed=true
        *)
       @boolean;
     <B>upcase</B><A name="putBased.1.upcase.2(802)"></A><A name="upcase.2(802)"></A>: @boolean
       (* Specifies whether an upcase 'X' or a lowcase 'x' is the
        * be used in the 'bbx' part.
        *);
     <B>uppercase</B><A name="putBased.1.uppercase.2(803)"></A><A name="uppercase.2(803)"></A>: @boolean
       (* Specifies whether uppercase letters or lowercase letters
        * are used in the 'nnnn' part (for base&gt;9).
        *);
     <B>width</B><A name="putBased.1.width.2(804)"></A><A name="width.2(804)"></A>: (* Minimum width *) @integer;
     <B>adjustLeft</B><A name="putBased.1.adjustLeft.2(805)"></A><A name="adjustLeft.2(805)"></A>: @boolean
       (* Specifies if the number is to be aligned left or right,
        * if padding of spaces is necessary to fill up the specified
        * width.
        *);
     <B>zeroPadding</B><A name="putBased.1.zeroPadding.2(806)"></A><A name="zeroPadding.2(806)"></A>:
       (* width is padded with leading zero instead of spaces.
        * Ignored if adjustLeft=true
        *)
       @boolean;
     <B>noBasePrefix</B><A name="putBased.1.noBasePrefix.2(807)"></A><A name="noBasePrefix.2(807)"></A>: (* If true, the 'bbx' part is omitted *)
       @boolean;
     <B>baseWidth</B><A name="putBased.1.baseWidth.2(808)"></A><A name="baseWidth.2(808)"></A>: (* minimun width for the 'bbx' part *)
       @integer;
     <B>baseZeroPadding</B><A name="putBased.1.baseZeroPadding.2(809)"></A><A name="baseZeroPadding.2(809)"></A>:
       (* baseWidth is padded with leading zero instead of spaces *)
       @boolean;
     <B>format</B><A name="putBased.1.format.2(810)"></A><A name="format.2(810)"></A>:&lt; (# do INNER #);
     <B>putb</B><A name="putBased.1.putb.2(811)"></A><A name="putb.2(811)"></A>: @...
  enter (base, value)
  do INNER putBased; putb
  #);
<B>putReal</B><A name="putReal.1(812)"></A>:
  (* Append a real to THIS(stream). The format may be controlled by
   * the style, signed, blankSign, precision, upcase, width,
   * adjustLeft and zeroPadding variable attributes
   *)
  (# <B>r</B><A name="putReal.1.r.2(813)"></A><A name="r.2(813)"></A>: @real;
     <B>style</B><A name="putReal.1.style.2(814)"></A><A name="style.2(814)"></A>: @integer
       (* Controls the style, and may be one of plain, exp and noexp
        * (noexp is the default)
        *);
     <B>noexp</B><A name="putReal.1.noexp.2(815)"></A><A name="noexp.2(815)"></A>: (* The notation [-]mmm.dddddd is used *)
       (# exit 0 #);
     <B>exp</B><A name="putReal.1.exp.2(816)"></A><A name="exp.2(816)"></A>: (* The notation [-]m.ddddddE[+|-]xx is used *)
       (# exit 1 #);
     <B>plain</B><A name="putReal.1.plain.2(817)"></A><A name="plain.2(817)"></A>:
       (* In this style, precision is the total number of digits in
        * the printed real (not the number of digits in the fraction,
        * as in the other styles).
        * 
        * The exp or noexp style is used, dependent on the value being
        * printed.  Exp style is used only if the exponent is less
        * than -4 or greater than or equal to the precision; otherwise
        * the noexp notation is used.  Trailing zeros are not printed
        * as part of the fractional part and a decimal point is
        * printed if not followed by a digit
        *)
       (# exit 2 #);
     <B>signed</B><A name="putReal.1.signed.2(818)"></A><A name="signed.2(818)"></A>: (* If real is positive, a '+' will always be displayed *)
       @boolean;
     <B>blankSign</B><A name="putReal.1.blankSign.2(819)"></A><A name="blankSign.2(819)"></A>:
       (* If real is positive, a ' ' space is displayed as the sign.
        * Ignored if signed=true
        *)
       @boolean;
     <B>precision</B><A name="putReal.1.precision.2(820)"></A><A name="precision.2(820)"></A>: @integer
       (* The number of d's in the expressions above, default 6 *);
     <B>upcase</B><A name="putReal.1.upcase.2(821)"></A><A name="upcase.2(821)"></A>: @boolean
       (* Specifies whether an upcase 'E' or a lowcase 'e' is the
        * be used in the exp style.
        *);
     <B>width</B><A name="putReal.1.width.2(822)"></A><A name="width.2(822)"></A>: (* Minimum width *)
       @integer;
     <B>adjustLeft</B><A name="putReal.1.adjustLeft.2(823)"></A><A name="adjustLeft.2(823)"></A>: @boolean
       (* Specifies if the number is to be aligned left or right,
        * if padding of spaces is necessary to fill up the specified
        * width.
        *);
     <B>zeroPadding</B><A name="putReal.1.zeroPadding.2(824)"></A><A name="zeroPadding.2(824)"></A>:
       (* width is padded with leading zero instead of spaces.
        * Ignored if adjustLeft=true
        *)
       @boolean;
     (* Examples:
      *   10*pi -&gt; putreal;
      *      yields: '31.415926'
      *   10*pi -&gt; putreal(# do 10-&gt;width; true-&gt;adjustLeft #);
      *      yields: '31.415926   '
      *   10*pi -&gt; putreal(# do exp-&gt;style; true-&gt;upcase #);
      *      yields: '3.1415926E+01'
      *   10*pi -&gt; putreal(# do exp-&gt;style; 2-&gt;precision #);
      *      yields: '3.14e+01'
      *)
     <B>format</B><A name="putReal.1.format.2(825)"></A><A name="format.2(825)"></A>:&lt; (# do INNER #);
     <B>putr</B><A name="putReal.1.putr.2(826)"></A><A name="putr.2(826)"></A>: @...
  enter r
  do 1-&gt;width; 6-&gt;precision; format; INNER putReal; putr
  #);
<B>putRadix</B><A name="putRadix.1(827)"></A>: putBased
  (#
  do true-&gt;noBasePrefix; INNER putRadix 
  #);

<B>putHex</B><A name="putHex.1(828)"></A>:
  (* prints a hexadecimal representation of x (as unsigned word) on
   * this(stream). Similar to
   * (16,x)-&gt;putRadix(# do true-&gt;zeroPadding; 8-&gt;width #)
   * but more efficient.
   *) 
  (# <B>uppercase</B><A name="putHex.1.uppercase.2(829)"></A><A name="uppercase.2(829)"></A>: @boolean;
     <B>width</B><A name="putHex.1.width.2(830)"></A><A name="width.2(830)"></A>: @integer;
     <B>zeroPadding</B><A name="putHex.1.zeroPadding.2(831)"></A><A name="zeroPadding.2(831)"></A>: @boolean;
     <B>x</B><A name="putHex.1.x.2(832)"></A><A name="x.2(832)"></A>: @integer;
     <B>format</B><A name="putHex.1.format.2(833)"></A><A name="format.2(833)"></A>:&lt; (# do INNER #);
     <B>putH</B><A name="putHex.1.putH.2(834)"></A><A name="putH.2(834)"></A>: (*private*)@...
  enter x
  do format; INNER putHex; putH
  #);

<B>putByteHex</B><A name="putByteHex.1(835)"></A>:
  (* prints a hexadecimal representation of byte 'byte' in x (as
   * unsigned word) on this(stream)
   *)
  (# <B>x</B><A name="putByteHex.1.x.2(836)"></A><A name="x.2(836)"></A>: @integer;
     <B>byte</B><A name="putByteHex.1.byte.2(837)"></A><A name="byte.2(837)"></A>: @integer;
     <B>putBH</B><A name="putByteHex.1.putBH.2(838)"></A><A name="putBH.2(838)"></A>: (*private*)@...
  enter (x,byte)
  do INNER putByteHex; putBH
  #);

<B>putOctal</B><A name="putOctal.1(839)"></A>:
  (* prints a octal representation of x (as unsigned word) on
   * this (stream). Similar to
   * (8,x)-&gt;putRadix(# do true-&gt;zeroPadding;  #)
   * but more efficient.
   *)
  (# <B>width</B><A name="putOctal.1.width.2(840)"></A><A name="width.2(840)"></A>: @integer;
     <B>zeroPadding</B><A name="putOctal.1.zeroPadding.2(841)"></A><A name="zeroPadding.2(841)"></A>: @boolean;
     <B>x</B><A name="putOctal.1.x.2(842)"></A><A name="x.2(842)"></A>: @integer;
     <B>format</B><A name="putOctal.1.format.2(843)"></A><A name="format.2(843)"></A>:&lt; (# do INNER #);
     <B>putO</B><A name="putOctal.1.putO.2(844)"></A><A name="putO.2(844)"></A>:(*private*)@...
  enter x
  do format; INNER putOctal; putO;
  #);

<B>putBinary</B><A name="putBinary.1(845)"></A>:
  (* prints a binary representation of x (as unsigned word) on
   * this(stream). Similar to
   * (2,x)-&gt;putRadix(# do true-&gt;zeroPadding; #)
   * but more efficient.
   *)
  (# <B>width</B><A name="putBinary.1.width.2(846)"></A><A name="width.2(846)"></A>: @integer;
     <B>zeroPadding</B><A name="putBinary.1.zeroPadding.2(847)"></A><A name="zeroPadding.2(847)"></A>: @boolean;
     <B>x</B><A name="putBinary.1.x.2(848)"></A><A name="x.2(848)"></A>: @integer;
     <B>format</B><A name="putBinary.1.format.2(849)"></A><A name="format.2(849)"></A>:&lt; (# do INNER #);
     <B>putB</B><A name="putBinary.1.putB.2(850)"></A><A name="putB.2(850)"></A>: (*private*)@...
  enter x
  do format; INNER putBinary; putB
  #);

<B>putByteBinary</B><A name="putByteBinary.1(851)"></A>:
  (* prints a binary representation of byte 'byte' of x (as unsigned
   * word) on this(stream)
   *)
  (# <B>x</B><A name="putByteBinary.1.x.2(852)"></A><A name="x.2(852)"></A>: @integer;
     <B>byte</B><A name="putByteBinary.1.byte.2(853)"></A><A name="byte.2(853)"></A>: @integer;
     <B>putBB</B><A name="putByteBinary.1.putBB.2(854)"></A><A name="putBB.2(854)"></A>: (*private*)@...
  enter (x, byte)
  do INNER putByteBinary; putBB
  #);

<B>getHex</B><A name="getHex.1(855)"></A>:
  (* reads a hexadecimal number from this(stream) and returns the
   * value in x (as unsigned word). Similar to 16-&gt;getRadix but more
   * efficient.
   *)
  (# <B>x</B><A name="getHex.1.x.2(856)"></A><A name="x.2(856)"></A>: @integer;
     <B>noNumberError</B><A name="getHex.1.noNumberError.2(857)"></A><A name="noNumberError.2(857)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'getHex: the number begins with: "'-&gt;msg.append;
          (if peekCh = ascii.nul then 'NUL'-&gt;msg.puttext
           else peekCh-&gt;msg.put if);
          '".  Not a legal hexadecimal digit'-&gt;msg.puttext;
          INNER noNumberError
       #);
     <B>getH</B><A name="getHex.1.getH.2(858)"></A><A name="getH.2(858)"></A>: (*private*)...
  do INNER getHex; getH
  exit x
  #);

<B>getOctal</B><A name="getOctal.1(859)"></A>:
  (* reads a hexadecimal number from this(stream) and returns the
   * value in x (as unsigned word). Similar to 16-&gt;getRadix but more
   * efficient.
   *) 
  (# <B>x</B><A name="getOctal.1.x.2(860)"></A><A name="x.2(860)"></A>: @integer;
    <B>noNumberError</B><A name="getOctal.1.noNumberError.2(861)"></A><A name="noNumberError.2(861)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'getHex: the number begins with: "'-&gt;msg.append;
          (if peekCh = ascii.nul then 'NUL'-&gt;msg.puttext
           else peekCh-&gt;msg.put if);
          '".  Not a legal hexadecimal digit'-&gt;msg.puttext;
          INNER noNumberError
       #);
     <B>getO</B><A name="getOctal.1.getO.2(862)"></A><A name="getO.2(862)"></A>: (*private*)...
  do INNER getOctal; getO
  exit x
  #);

<B>getBinary</B><A name="getBinary.1(863)"></A>:
  (* reads a binary number from this(stream) and returns the value in
   * x (as unsigned word). Similar to 2-&gt;getRadix but more efficient.
   *)
  (# <B>x</B><A name="getBinary.1.x.2(864)"></A><A name="x.2(864)"></A>: @integer;
     <B>noNumberError</B><A name="getBinary.1.noNumberError.2(865)"></A><A name="noNumberError.2(865)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'getBinary: the number begins with: "'-&gt;msg.append;
          (if peekCh = ascii.nul then 'NUL'-&gt;msg.puttext
           else peekCh-&gt;msg.put if);
          '".  Not a legal binary digit'-&gt;msg.puttext;
          INNER noNumberError
       #);
     <B>getB</B><A name="getBinary.1.getB.2(866)"></A><A name="getB.2(866)"></A>: (*private*)...
  do INNER getBinary; getB
  exit x
  #);

<B>asNumber</B><A name="asNumber.1(867)"></A>:
  (# <B>syntaxError</B><A name="asNumber.1.syntaxError.2(868)"></A><A name="syntaxError.2(868)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'asNumber: Syntax error - looking at: "'-&gt;msg.append;
          peekCh-&gt;msg.put; '"'-&gt;msg.put;
          INNER syntaxError
       #);
     <B>baseError</B><A name="asNumber.1.baseError.2(869)"></A><A name="baseError.2(869)"></A>:&lt; streamException
       (# base: @integer
       enter base
       do 'asNumber: Error in base - looking at: "'-&gt;msg.append;
          base-&gt;msg.putInt; '"'-&gt;msg.put;
          INNER baseError
       #);
     <B>valueError</B><A name="asNumber.1.valueError.2(870)"></A><A name="valueError.2(870)"></A>:&lt; streamException
       (# peekCh: @char
       enter peekCh
       do 'asNumber: Illegal value type - looking at: "'-&gt;msg.append;
          peekCh-&gt;msg.put; '"'-&gt;msg.put;
          INNER valueError
       #);
  do reset;
     INNER asNumber;
     ScanWhiteSpace; (if not eos then peek-&gt;syntaxError if)
  #);

<B>asReal</B><A name="asReal.1(871)"></A>: asNumber
  (# <B>r</B><A name="asReal.1.r.2(872)"></A><A name="r.2(872)"></A>: @real
    ...
  exit r
  #);
<B>asBased</B><A name="asBased.1(873)"></A>: asNumber
  (# <B>i</B><A name="asBased.1.i.2(874)"></A><A name="i.2(874)"></A>,<B> b</B><A name="asBased.1.b.2(875)"></A><A name="b.2(875)"></A>: @integer
    ...
  exit (b,i)
  #);
<B>asRadix</B><A name="asRadix.1(876)"></A>: asNumber
  (# <B>radix</B><A name="asRadix.1.radix.2(877)"></A><A name="radix.2(877)"></A>,<B> value</B><A name="asRadix.1.value.2(878)"></A><A name="value.2(878)"></A>: @integer
  enter radix
  ...
  exit value
  #);
<B>asInteger</B><A name="asInteger.1(879)"></A>: asNumber
  (# <B>i</B><A name="asInteger.1.i.2(880)"></A><A name="i.2(880)"></A>: @integer
    ...
  exit i
  #)

--- lib: attributes ---

<B>getNumber</B><A name="getNumber.1(881)"></A>: keyboard.getNumber
  (# do INNER getNumber #);
<B>getReal</B><A name="getReal.1(882)"></A>: keyboard.getReal
  (# do INNER getReal #);
<B>getBased</B><A name="getBased.1(883)"></A>: keyboard.getBased
  (# do INNER getbased #);
<B>getRadix</B><A name="getRadix.1(884)"></A>: keyboard.getRadix
  (# do INNER getRadix #);
<B>getInteger</B><A name="getInteger.1(885)"></A>: keyboard.getInteger
  (# do INNER getInteger #);

<B>putReal</B><A name="putReal.1(886)"></A>: screen.putReal
  (# do INNER putReal #);
<B>putBased</B><A name="putBased.1(887)"></A>: screen.putBased
  (# do INNER putBased #);
<B>putRadix</B><A name="putRadix.1(888)"></A>: screen.putRadix
  (# do INNER putRadix #);

<B>getHex</B><A name="getHex.1(889)"></A>: keyboard.getHex
  (# do INNER getHex #);
<B>getOctal</B><A name="getOctal.1(890)"></A>: keyboard.getOctal
  (# do INNER getOctal #);
<B>getBinary</B><A name="getBinary.1(891)"></A>: keyboard.getBinary
  (# do INNER getBinary #);

<B>putHex</B><A name="putHex.1(892)"></A>: screen.putHex
  (# do INNER putHex #);
<B>putByteHex</B><A name="putByteHex.1(893)"></A>: screen.putByteHex
  (# do INNER putByteHex #);
<B>putOctal</B><A name="putOctal.1(894)"></A>:screen.putOctal
  (# do INNER putOctal #);
<B>putBinary</B><A name="putBinary.1(895)"></A>: screen.putBinary
  (# do INNER putBinary #);
<B>putByteBinary</B><A name="putByteBinary.1(896)"></A>: screen.putByteBinary
  (# do INNER putByteBinary #)
</PRE>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Numberio Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
