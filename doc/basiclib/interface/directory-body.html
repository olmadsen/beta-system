<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Directory Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="directory">Directory Interface</A></H1>

<PRE CLASS=interface>
ORIGIN 'file';
LIB_DEF 'directory' '../lib';
BODY 'private/directorybody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1984-96
 *       All rights reserved.
 *
 *)
---- LIB: attributes ----
<B>directory</B><A name="directory.1(470)"></A>:
  (* Generalization of disk folder/directory.  Describes the list
   * aspects of directories and contains a DiskEntry item describing
   * the other properties of a directory.
   *)
  (#
     &lt;&lt;SLOT DirectoryLib: attributes&gt;&gt;;
     
     <B>EntryDesc</B><A name="directory.1.EntryDesc.2(471)"></A><A name="EntryDesc.2(471)"></A>:&lt; DiskEntry;
     <B>entry</B><A name="directory.1.entry.2(472)"></A><A name="entry.2(472)"></A>: @EntryDesc
       (* The item holding most characterizing attributes of
        * THIS(directory)
        *); 
     <B>name</B><A name="directory.1.name.2(473)"></A><A name="name.2(473)"></A>: @
       (* convenient interface to entry.path *)
       (# read:
            (* Reads a directory name from the Keyboard *)
            (# do ... #);
       enter entry.path
       exit entry.path
       #);
     
     (* Directory exceptions *)
     
     <B>DirException</B><A name="directory.1.DirException.2(474)"></A><A name="DirException.2(474)"></A>: Exception
       (* General directory exception *)
       (# do ...; INNER #);
     <B>EntryExistException</B><A name="directory.1.EntryExistException.2(475)"></A><A name="EntryExistException.2(475)"></A>: DirException
       (* Raised on attempt to create a file or directory that
        * allready existed in THIS(directory). Message: "Directory
        * entry allready exist"
        *)
       (# do ...; INNER #);
     <B>DirScanException</B><A name="directory.1.DirScanException.2(476)"></A><A name="DirScanException.2(476)"></A>: DirException
       (* Raised if a scan of THIS(directory) has failed.  Message:
        * "Scan of directory failed.", and an indication of why it
        * failed.
        *)
       (# do ...; INNER #);
     <B>DirSearchException</B><A name="directory.1.DirSearchException.2(477)"></A><A name="DirSearchException.2(477)"></A>: DirException
       (* Raised if a find in THIS(directory) has failed.  Message:
        * "Search of directory failed.", and an indication of why it
        * failed.
        *)
       (# do ...; INNER #);
     <B>NoSuchException</B><A name="directory.1.NoSuchException.2(478)"></A><A name="NoSuchException.2(478)"></A>: DirException
       (* Raised on attempt to delete a file or directory that did
        * not exist in THIS(directory). Message: "Attempt to delete a
        * nonexisting entry."
        *)
       (# do ...; INNER #);
     <B>NotFoundException</B><A name="directory.1.NotFoundException.2(479)"></A><A name="NotFoundException.2(479)"></A>: DirException
       (* Raised if findEntry.select is used in findEntry.notFound,
        * or in other situations that findEntry.found[]=NONE. Message:
        * "Attempt to use 'select' in 'findEntry' when the candidate
        * was not found."
        *)
       (# do ...; INNER #);
     
     (* Manipulations of THIS(directory) *)
     
     <B>touch</B><A name="directory.1.touch.2(480)"></A><A name="touch.2(480)"></A>: entry.touch
       (* If the disk entry does not exist, an empty directory will
        * be created.
        *)
       (# touchD: @...; 
       do touchD 
       #);
     <B>delete</B><A name="directory.1.delete.2(481)"></A><A name="delete.2(481)"></A>:
       (* Delete THIS(directory) *)
       (# nosuch:&lt; NoSuchException
            (* Raised if there was no disk entry corresponding to
             * THIS(Directory)
             *);
          error:&lt; entry.DiskEntryException
            (* Raised if other errors occurred *);
          deleteD: @...; 
       do deleteD
       #);
     <B>createFile</B><A name="directory.1.createFile.2(482)"></A><A name="createFile.2(482)"></A>:
       (* Create a file named 'name' in THIS(Directory) *)
       (# name: ^text;
          newEntry: ^EntryDesc;
          exists:&lt; EntryExistException
            (* Raised if en entry of that name already existed *);
          error:&lt; DirException
            (* Raised if other errors occurred *);
       enter name[]
       ...
       exit newEntry[]
       #);
     <B>deleteFile</B><A name="directory.1.deleteFile.2(483)"></A><A name="deleteFile.2(483)"></A>: 
       (* Delete a file named 'name' in THIS(Directory) *)
       (# name: ^text;
          nosuch:&lt; NoSuchException
            (* Raised if there was no disk entry in THIS(Directory)
             * named 'name'
             *);
          error:&lt;DirException
            (* Raised if other errors occured *)
       enter name[]
       ...
       #);
     <B>createDir</B><A name="directory.1.createDir.2(484)"></A><A name="createDir.2(484)"></A>:
       (* Create a directory named 'name' in THIS(Directory) *)
       (# name: ^text;
          newEntry: ^EntryDesc;
          exists:&lt; EntryExistException
            (* Raised if en entry of that name already existed *);
          error:&lt; DirException
            (* Raised if other errors occurred *);
       enter name[]
       ...
       exit newEntry[]
       #);
     <B>deleteDir</B><A name="directory.1.deleteDir.2(485)"></A><A name="deleteDir.2(485)"></A>:
       (* Delete a directory named 'name' in THIS(Directory) *)
       (# name: ^text;
          nosuch:&lt; NoSuchException
            (* Raised if there was no disk entry in THIS(Directory)
             * named 'name'
             *);
          error:&lt; DirException
            (* Raised if other errors occured *)
       enter name[]
       ...
       #);
     <B>noOfEntries</B><A name="directory.1.noOfEntries.2(486)"></A><A name="noOfEntries.2(486)"></A>: IntegerValue
       (* exit the number of entries in THIS(directory) *)
       (# error:&lt;DirException; 
       ... 
       #);
     <B>empty</B><A name="directory.1.empty.2(487)"></A><A name="empty.2(487)"></A>: BooleanValue
       (* TRUE iff THIS(directory) is empty. Note that this does not
        * always imply NoOfEntries=0
        *)
       (# error:&lt;DirException; 
       ... 
       #);
     <B>findEntry</B><A name="directory.1.findEntry.2(488)"></A><A name="findEntry.2(488)"></A>:
       (* Calls INNER if entry was found in THIS(directory), and
        * otherwise calls notFound
        *)
       (# &lt;&lt;SLOT DirFindLib: attributes&gt;&gt;;
          <B>candidate</B><A name="directory.1.findEntry.2.candidate.3(489)"></A><A name="candidate.3(489)"></A>: ^text;
          (* The name of the entry to search for *)
          <B>foundDesc</B><A name="directory.1.findEntry.2.foundDesc.3(490)"></A><A name="foundDesc.3(490)"></A>:&lt; DiskEntry;
          (* Qualification of "found" *)
          <B>found</B><A name="directory.1.findEntry.2.found.3(491)"></A><A name="found.3(491)"></A>: ^foundDesc;
          (* Reference to entry, if found.  Notice that 'found.path'
           * is relative to THIS(directory).  The full path may be
           * obtained by 'foundFullPath' Also 'foundFullPath -&gt;
           * found.path' may be needed before is queried for modtime
           * etc., if THIS(Directory) is not the current working
           * directory.
           *)
          <B>foundFile</B><A name="directory.1.findEntry.2.foundFile.3(492)"></A><A name="foundFile.3(492)"></A>:&lt; File; 
          (* Qualification of file generated in
           * select.whenfile.thefile
           *)
          <B>foundDir</B><A name="directory.1.findEntry.2.foundDir.3(493)"></A><A name="foundDir.3(493)"></A>:&lt; Directory;
          (* Qualification of directory generated in
           * select.whendir.thedir
           *)
          <B>foundFullPath</B><A name="directory.1.findEntry.2.foundFullPath.3(494)"></A><A name="foundFullPath.3(494)"></A>: (* Fullpath of "found" *)
            (# p: ^text do ... exit p[] #);
           
          <B>notfound</B><A name="directory.1.findEntry.2.notfound.3(495)"></A><A name="notfound.3(495)"></A>:&lt; (* Called if the entry was not found *)
            (# do INNER #);
          <B>select</B><A name="directory.1.findEntry.2.select.3(496)"></A><A name="select.3(496)"></A>:
            (* Used to distinguish between the various entries that
             * may be found
             *)
            (# <B>error</B><A name="directory.1.findEntry.2.select.3.error.4(497)"></A><A name="error.4(497)"></A>:&lt; found.DiskEntryException;
               <B>whenFile</B><A name="directory.1.findEntry.2.select.3.whenFile.4(498)"></A><A name="whenFile.4(498)"></A>:&lt;
                 (* Called when the entry found is a file *)
                 (# thefile: 
                      (* Generate an instance of foundFile
                       * corresponding to the entry found. Notice that
                       * 'found' and 'f.entry' are two distinct
                       * objects; 'f.entry' has a full path, 'found'
                       * may or may not have a path relative to
                       * THIS(Directory).
                       *)
                      (# f: ^foundFile 
                      do ...
                      exit f[]
                      #);
                 do INNER
                 #);
               <B>whenDir</B><A name="directory.1.findEntry.2.select.3.whenDir.4(499)"></A><A name="whenDir.4(499)"></A>:&lt;
                 (* Called when the entry found is a directory *)
                 (# theDir: 
                      (* Generate an instance of foundDir
                       * corresponding to the entry found. Notice that
                       * 'found' and 'd.entry' are two distinct
                       * objects; 'd.entry' has a full path, 'found'
                       * may or may not have a path relative to
                       * THIS(Directory).
                       *)
                      (# d: ^foundDir 
                      do ...
                      exit d[]
                      #);
                 do INNER
                 #);
               <B>whenOther</B><A name="directory.1.findEntry.2.select.3.whenOther.4(500)"></A><A name="whenOther.4(500)"></A>:&lt;
                 (* Called when the entry found is neither a file nor
                  * a directory
                  *)
                 (# do INNER #);
               <B>selectImpl</B><A name="directory.1.findEntry.2.select.3.selectImpl.4(501)"></A><A name="selectImpl.4(501)"></A>:&lt; (* private *)
                 (# selectedInInner: @boolean
                 do ...;
                    INNER; ...;
                 #)
            do selectImpl;
            #); (* select *)
          <B>error</B><A name="directory.1.findEntry.2.error.3(502)"></A><A name="error.3(502)"></A>:&lt; DirSearchException
            (* Raised if the search fails *);
       enter candidate[]
       do ...;
       #); (* findEntry *)
     <B>scanEntries</B><A name="directory.1.scanEntries.2(503)"></A><A name="scanEntries.2(503)"></A>:
       (* Calls INNER for each entry in THIS(directory) *)
       (# &lt;&lt;SLOT DirScanLib: attributes&gt;&gt;;
          <B>longest</B><A name="directory.1.scanEntries.2.longest.3(504)"></A><A name="longest.3(504)"></A>: @integer;
          (* The length of the longest entry-name in THIS(directory)
           *)
          <B>foundDesc</B><A name="directory.1.scanEntries.2.foundDesc.3(505)"></A><A name="foundDesc.3(505)"></A>:&lt; DiskEntry;
          (* Qualification of "found" *)
          <B>found</B><A name="directory.1.scanEntries.2.found.3(506)"></A><A name="found.3(506)"></A>: ^foundDesc;
          (* Reference to entry, if found.  Notice that 'found.path'
           * is relative to THIS(directory).  The full path may be
           * obtained by 'foundFullPath' Also 'foundFullPath -&gt;
           * found.path' may be needed before is queried for modtime
           * etc., if THIS(Directory) is not the current working
           * directory.
           *)
          <B>foundFile</B><A name="directory.1.scanEntries.2.foundFile.3(507)"></A><A name="foundFile.3(507)"></A>:&lt; File; 
          (* Qualification of file generated in
           * select.whenfile.thefile
           *)
          <B>foundDir</B><A name="directory.1.scanEntries.2.foundDir.3(508)"></A><A name="foundDir.3(508)"></A>:&lt; Directory;
          (* Qualification of directory generated in
           * select.whendir.thedir
           *)
          <B>foundFullPath</B><A name="directory.1.scanEntries.2.foundFullPath.3(509)"></A><A name="foundFullPath.3(509)"></A>: (* Fullpath of "found"  *)
            (# p: ^text do ... exit p[] #);
          <B>select</B><A name="directory.1.scanEntries.2.select.3(510)"></A><A name="select.3(510)"></A>:
            (* Used to distinguish between the various entries that
             * may be found
             *)
            (# <B>error</B><A name="directory.1.scanEntries.2.select.3.error.4(511)"></A><A name="error.4(511)"></A>:&lt; found.DiskEntryException;
               <B>whenFile</B><A name="directory.1.scanEntries.2.select.3.whenFile.4(512)"></A><A name="whenFile.4(512)"></A>:&lt;
                 (* Called when the entry found is a file *)
                 (# thefile: 
                      (* Generate an instance of foundFile
                       * corresponding to the entry found. Notice that
                       * 'found' and 'f.entry' are two distinct
                       * objects; 'f.entry' has a full path, 'found'
                       * may or may not have a path relative to
                       * THIS(Directory).
                       *)
                      (# f: ^foundFile 
                      do ...
                      exit f[]
                      #);
                 do INNER
                 #);
               <B>whenDir</B><A name="directory.1.scanEntries.2.select.3.whenDir.4(513)"></A><A name="whenDir.4(513)"></A>:&lt;
                 (* Called when the entry found is a directory *)
                 (# theDir: 
                      (* Generate an instance of foundDir
                       * corresponding to the entry found. Notice that
                       * 'found' and 'd.entry' are two distinct
                       * objects; 'd.entry' has a full path, 'found'
                       * may or may not have a path relative to
                       * THIS(Directory).
                       *)
                      (# d: ^foundDir 
                      do ...
                      exit d[]
                      #);
                 do INNER
                 #);
               <B>whenOther</B><A name="directory.1.scanEntries.2.select.3.whenOther.4(514)"></A><A name="whenOther.4(514)"></A>:&lt;
                 (* Called when the entry found is neither a file nor
                  * a directory
                  *)
                 (# do INNER #);
               <B>selectImpl</B><A name="directory.1.scanEntries.2.select.3.selectImpl.4(515)"></A><A name="selectImpl.4(515)"></A>:&lt; (* private *)
                 (# selectedInInner: @boolean
                 do ...;
                    INNER; ...;
                 #)
            do selectImpl;
            #); (* select *)
          <B>error</B><A name="directory.1.scanEntries.2.error.3(516)"></A><A name="error.3(516)"></A>:&lt; DirScanException
            (* Raised if the scan fails *);
          (* idx- *) (* idx- *)
       do ...;
       #); (* scanEntries *)
     <B>private</B><A name="directory.1.private.2(517)"></A><A name="private.2(517)"></A>: @...;
  #)
</PRE>
<TABLE BORDER=0 ALIGN=RIGHT>
<TR>
<TD>
<A HREF="http://validator.w3.org/check/referer">
<IMG BORDER=0 SRC="../../images/vh40.gif" ALT="Valid HTML 4.0!" HEIGHT=31 WIDTH=88>
</A>
</TD>
</TR>
</TABLE>
<BR CLEAR=right>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Directory Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
