<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Betaenv Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="betaenv">Betaenv Interface</A></H1>

<PRE CLASS=interface>
LIB_DEF 'betaenv' '../lib';
BODY 'private/betaenvbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1984-96
 *       All rights reserved.
 *
 * This fragment implements the very basic patterns, utilized by most
 * BETA programs
 *)
-- betaenv: descriptor --
(# &lt;&lt;SLOT lib: attributes&gt;&gt;;
   (******************************************************************)
   (* The simple patterns for simple values and variables.  These
    * simple patterns are treated special by the compiler.
    *)
   <B>integer</B><A name="betaenv.1.integer.2(85)"></A><A name="integer.2(85)"></A>: (* 32 bit signed long *) (# #);
   <B>shortInt</B><A name="betaenv.1.shortInt.2(86)"></A><A name="shortInt.2(86)"></A>: (* 16 bit unsigned half *) (# #); (* do not use shortInt anymore,
                                                * use int16u instead.
                                                *)
   <B>char</B><A name="betaenv.1.char.2(87)"></A><A name="char.2(87)"></A>: (* 8 bit unsigned byte *) (# #);
   <B>boolean</B><A name="betaenv.1.boolean.2(88)"></A><A name="boolean.2(88)"></A>: (* 8 bit unsigned byte, values 0 or 1 *) (# #);
   <B>false</B><A name="betaenv.1.false.2(89)"></A><A name="false.2(89)"></A>: boolean (* 8 bit unsigned byte with value 0 *) (# #);
   <B>true</B><A name="betaenv.1.true.2(90)"></A><A name="true.2(90)"></A>: boolean (* 8 bit unsigned byte with value 1 *) (# #);
   <B>real</B><A name="betaenv.1.real.2(91)"></A><A name="real.2(91)"></A>: (* double precision floating point number *) (# #);
   
   <B>int8</B><A name="betaenv.1.int8.2(92)"></A><A name="int8.2(92)"></A>: (* 8 bit signed integer *) (# #); 
   <B>int8u</B><A name="betaenv.1.int8u.2(93)"></A><A name="int8u.2(93)"></A>: (* 8 bit unsigned integer *) (# #);
   <B>int16</B><A name="betaenv.1.int16.2(94)"></A><A name="int16.2(94)"></A>: (* 16 bit signed integer *) (# #);
   <B>int16u</B><A name="betaenv.1.int16u.2(95)"></A><A name="int16u.2(95)"></A>: (* 16 bit unsigned integer.
            * int16u will eventually replace shortInt *) (# #);
   <B>int32</B><A name="betaenv.1.int32.2(96)"></A><A name="int32.2(96)"></A>: (* 32 bit signed integer
           * int32 is semantically identical to integer *) (# #);
   <B>int32u</B><A name="betaenv.1.int32u.2(97)"></A><A name="int32u.2(97)"></A>: (* 32 bit unsigned integer *) (# #);
   
   (* int64 and int64u are NOT yet implemented;
    * the compiler allows variables of these types,
    * but no operations, including assignment,
    * are implemented, so don't use them.
    *)
   <B>int64</B><A name="betaenv.1.int64.2(98)"></A><A name="int64.2(98)"></A>: (* 64 bit signed integer *) (# #); 
   <B>int64u</B><A name="betaenv.1.int64u.2(99)"></A><A name="int64u.2(99)"></A>: (* 64 bit unsigned integer *) (# #);
   
   (* The pattern wchar is for experimenting with implementing
    * support for the UniCode character set. The name wchar
    * is preliminary. wchar is semantically identical to int16u.
    * Patterns wcharValue and wcharObject have also been introduced below
    *)
   <B>wchar</B><A name="betaenv.1.wchar.2(100)"></A><A name="wchar.2(100)"></A>: (# #); (* 16 bit unsigend integer *)
   
   (* The pattern COM is for experimenting with implementation
    * of COM support in BETA
    *)
   <B>COM</B><A name="betaenv.1.COM.2(101)"></A><A name="COM.2(101)"></A>: (# #); (* General super pattern for COM objects *)
   
   (* Holder is general superpattern for holder-patterns used for 
    * parameters in COM.
    *)
   <B>Holder</B><A name="betaenv.1.Holder.2(102)"></A><A name="Holder.2(102)"></A>: (# adr: @integer #);  
   
   <B>object</B><A name="betaenv.1.object.2(103)"></A><A name="object.2(103)"></A>: (* General superpattern *)
     (# <B>_struc</B><A name="betaenv.1.object.2._struc.3(104)"></A><A name="_struc.3(104)"></A>: 
          (* Exit a pattern reference for THIS(Object).
           * Is now obsolete: the new form obj## is preferred
           * to the old form obj.struc
           *)
          (#
          exit this(object)##
          #);
        <B>_new</B><A name="betaenv.1.object.2._new.3(105)"></A><A name="_new.3(105)"></A>: 
          (* returns a new object, that is qualified exactly
           * as THIS(object)
           *)
          (# newObj: ^object; oType: ##object
          do this(object)##-&gt;oType##; &amp;oType[]-&gt;newObj[]; INNER _new
          exit newObj[]
          #);
        <B>_state</B><A name="betaenv.1.object.2._state.3(106)"></A><A name="_state.3(106)"></A>: 
          (* Pattern _state is for experimental purpose only
           * and using it may give undefined results 
           *)
          (# S: ##object
          enter S##
          ...
          #)
     do INNER object
     #);
   (* idx *)
   
   (* The following patterns define 'real' patterns corresponding to
    * the predefined simple patterns
    *)
   <B>integerValue</B><A name="betaenv.1.integerValue.2(107)"></A><A name="integerValue.2(107)"></A>: (# <B>value</B><A name="betaenv.1.integerValue.2.value.3(108)"></A><A name="value.3(108)"></A>: @integer do INNER integerValue exit value #);
   <B>integerObject</B><A name="betaenv.1.integerObject.2(109)"></A><A name="integerObject.2(109)"></A>: integerValue(# enter value do INNER integerObject #);
   <B>charValue</B><A name="betaenv.1.charValue.2(110)"></A><A name="charValue.2(110)"></A>: (# <B>value</B><A name="betaenv.1.charValue.2.value.3(111)"></A><A name="value.3(111)"></A>: @char do INNER charValue exit value #);
   <B>charObject</B><A name="betaenv.1.charObject.2(112)"></A><A name="charObject.2(112)"></A>: charValue(# enter value do INNER charObject #);
   <B>wcharValue</B><A name="betaenv.1.wcharValue.2(113)"></A><A name="wcharValue.2(113)"></A>: (# <B>value</B><A name="betaenv.1.wcharValue.2.value.3(114)"></A><A name="value.3(114)"></A>: @wchar do INNER wcharValue exit value #);
   <B>wcharObject</B><A name="betaenv.1.wcharObject.2(115)"></A><A name="wcharObject.2(115)"></A>: wcharValue(# enter value do INNER wcharObject #);
   <B>booleanValue</B><A name="betaenv.1.booleanValue.2(116)"></A><A name="booleanValue.2(116)"></A>: (# <B>value</B><A name="betaenv.1.booleanValue.2.value.3(117)"></A><A name="value.3(117)"></A>: @boolean do INNER booleanValue exit value #);
   <B>booleanObject</B><A name="betaenv.1.booleanObject.2(118)"></A><A name="booleanObject.2(118)"></A>: booleanValue(# enter value do INNER booleanObject #);
   <B>trueObject</B><A name="betaenv.1.trueObject.2(119)"></A><A name="trueObject.2(119)"></A>: booleanObject(# do true-&gt;value; INNER trueObject #);
   <B>falseObject</B><A name="betaenv.1.falseObject.2(120)"></A><A name="falseObject.2(120)"></A>: booleanObject(# do INNER falseObject #);
   <B>realValue</B><A name="betaenv.1.realValue.2(121)"></A><A name="realValue.2(121)"></A>: (# <B>value</B><A name="betaenv.1.realValue.2.value.3(122)"></A><A name="value.3(122)"></A>: @real do INNER realValue exit value #);
   <B>realObject</B><A name="betaenv.1.realObject.2(123)"></A><A name="realObject.2(123)"></A>: realValue(# enter value do INNER realObject #);
   
   (****  Integer limits *********************************************) 
   <B>MaxInt8</B><A name="betaenv.1.MaxInt8.2(124)"></A><A name="MaxInt8.2(124)"></A>:   (# exit 0x7f #);
   <B>MinInt8</B><A name="betaenv.1.MinInt8.2(125)"></A><A name="MinInt8.2(125)"></A>:   (# exit 0x80 #);
   <B>MaxInt8u</B><A name="betaenv.1.MaxInt8u.2(126)"></A><A name="MaxInt8u.2(126)"></A>:  (# exit 0xff #);
   <B>MinInt8u</B><A name="betaenv.1.MinInt8u.2(127)"></A><A name="MinInt8u.2(127)"></A>:  (# exit 0x00 #);
   
   <B>MaxInt16</B><A name="betaenv.1.MaxInt16.2(128)"></A><A name="MaxInt16.2(128)"></A>:  (# exit 0x7fff #);
   <B>MinInt16</B><A name="betaenv.1.MinInt16.2(129)"></A><A name="MinInt16.2(129)"></A>:  (# exit 0x8000 #);
   <B>MaxInt16u</B><A name="betaenv.1.MaxInt16u.2(130)"></A><A name="MaxInt16u.2(130)"></A>: (# exit 0xffff #);
   <B>MinInt16u</B><A name="betaenv.1.MinInt16u.2(131)"></A><A name="MinInt16u.2(131)"></A>: (# exit 0x0000 #);
   
   <B>MaxInt32</B><A name="betaenv.1.MaxInt32.2(132)"></A><A name="MaxInt32.2(132)"></A>:  (# exit 0x7fffffff #);
   <B>MinInt32</B><A name="betaenv.1.MinInt32.2(133)"></A><A name="MinInt32.2(133)"></A>:  (# exit 0x80000000 #);
   <B>MaxInt32u</B><A name="betaenv.1.MaxInt32u.2(134)"></A><A name="MaxInt32u.2(134)"></A>: (# exit 0xffffffff #);
   <B>MinInt32u</B><A name="betaenv.1.MinInt32u.2(135)"></A><A name="MinInt32u.2(135)"></A>: (# exit 0x00000000 #);
   
   <B>MaxInt</B><A name="betaenv.1.MaxInt.2(136)"></A><A name="MaxInt.2(136)"></A>:    (# exit MaxInt32 #);
   <B>MinInt</B><A name="betaenv.1.MinInt.2(137)"></A><A name="MinInt.2(137)"></A>:    (# exit MinInt32 #);
   
   <B>MaxReal</B><A name="betaenv.1.MaxReal.2(138)"></A><A name="MaxReal.2(138)"></A>:   (# exit 1.797693134862315E+308 #);
   <B>MinReal</B><A name="betaenv.1.MinReal.2(139)"></A><A name="MinReal.2(139)"></A>:   (# exit 2.225073858507201E-308 #);

   (****  Implementation dependent constants *************************) 
   <B>infReal</B><A name="betaenv.1.infReal.2(140)"></A><A name="infReal.2(140)"></A>: (* Returns the real value 'Infinity' *)
     realValue(# ... #);
   
   (*****  Functional patterns ***************************************)
   <B>min</B><A name="betaenv.1.min.2(141)"></A><A name="min.2(141)"></A>: (* Returns the minimum of 2 integers *)
     (# <B>a</B><A name="betaenv.1.min.2.a.3(142)"></A><A name="a.3(142)"></A>,<B>b</B><A name="betaenv.1.min.2.b.3(143)"></A><A name="b.3(143)"></A>: @integer
     enter (a,b)
     do (if (a &lt; b) then a-&gt;b if)
     exit b
     #);
   <B>max</B><A name="betaenv.1.max.2(144)"></A><A name="max.2(144)"></A>: (* Returns the maximum of 2 integers *)
     (# <B>a</B><A name="betaenv.1.max.2.a.3(145)"></A><A name="a.3(145)"></A>,<B>b</B><A name="betaenv.1.max.2.b.3(146)"></A><A name="b.3(146)"></A>: @integer
     enter (a,b)
     do (if (a &lt; b) then b-&gt;a if)
     exit a
     #);
   <B>abs</B><A name="betaenv.1.abs.2(147)"></A><A name="abs.2(147)"></A>: (* Returns the absolute value of an integer *)
     (# <B>n</B><A name="betaenv.1.abs.2.n.3(148)"></A><A name="n.3(148)"></A>: @integer
     enter n
     do (if (n &lt; 0) then -n-&gt;n if)
     exit n
     #);
   
   (*****  Simple standard input/output patterns *********************)
   <B>keyboard</B><A name="betaenv.1.keyboard.2(149)"></A><A name="keyboard.2(149)"></A>,<B> screen</B><A name="betaenv.1.screen.2(150)"></A><A name="screen.2(150)"></A>: ^stream;
   <B>get</B><A name="betaenv.1.get.2(151)"></A><A name="get.2(151)"></A>:
     (# <B>ch</B><A name="betaenv.1.get.2.ch.3(152)"></A><A name="ch.3(152)"></A>: @char; <B>getC</B><A name="betaenv.1.get.2.getC.3(153)"></A><A name="getC.3(153)"></A>: @keyboard.get do getC-&gt;ch; INNER get exit ch #);
   <B>put</B><A name="betaenv.1.put.2(154)"></A><A name="put.2(154)"></A>:
     (# <B>ch</B><A name="betaenv.1.put.2.ch.3(155)"></A><A name="ch.3(155)"></A>: @char; <B>putC</B><A name="betaenv.1.put.2.putC.3(156)"></A><A name="putC.3(156)"></A>: @screen.put enter ch do INNER put; ch-&gt;putC #);
   <B>newline</B><A name="betaenv.1.newline.2(157)"></A><A name="newline.2(157)"></A>:
     screen.newline(# #);
   <B>putint</B><A name="betaenv.1.putint.2(158)"></A><A name="putint.2(158)"></A>:
     screen.putint(# do INNER putint #);
   <B>getint</B><A name="betaenv.1.getint.2(159)"></A><A name="getint.2(159)"></A>:
     keyBoard.getint(# do INNER getint #);
   <B>puttext</B><A name="betaenv.1.puttext.2(160)"></A><A name="puttext.2(160)"></A>:
     (# <B>t</B><A name="betaenv.1.puttext.2.t.3(161)"></A><A name="t.3(161)"></A>: ^text; <B>putT</B><A name="betaenv.1.puttext.2.putT.3(162)"></A><A name="putT.3(162)"></A>: @screen.puttext
     enter t[]
     do INNER puttext; t[]-&gt;putT
     #);
   <B>putline</B><A name="betaenv.1.putline.2(163)"></A><A name="putline.2(163)"></A>:
     screen.putline(# do INNER putline #);
   <B>getNonBlank</B><A name="betaenv.1.getNonBlank.2(164)"></A><A name="getNonBlank.2(164)"></A>:
     keyBoard.getNonBlank(# do INNER getNonBlank #);
   <B>scanAtom</B><A name="betaenv.1.scanAtom.2(165)"></A><A name="scanAtom.2(165)"></A>:
     keyBoard.scanAtom(# do INNER scanAtom #);
   <B>getAtom</B><A name="betaenv.1.getAtom.2(166)"></A><A name="getAtom.2(166)"></A>:
     (# <B>t</B><A name="betaenv.1.getAtom.2.t.3(167)"></A><A name="t.3(167)"></A>: ^text; <B>getA</B><A name="betaenv.1.getAtom.2.getA.3(168)"></A><A name="getA.3(168)"></A>: @keyBoard.getAtom
     do getA-&gt;t[]; INNER getAtom
     exit t[]
     #);
   <B>getline</B><A name="betaenv.1.getline.2(169)"></A><A name="getline.2(169)"></A>:
     (# <B>t</B><A name="betaenv.1.getline.2.t.3(170)"></A><A name="t.3(170)"></A>: ^text; <B>getL</B><A name="betaenv.1.getline.2.getL.3(171)"></A><A name="getL.3(171)"></A>: @keyBoard.getline
     do getL-&gt;t[]; INNER getline
     exit t[]
     #);
   
   (*****  Control patterns ******************************************)
   <B>forTo</B><A name="betaenv.1.forTo.2(172)"></A><A name="forTo.2(172)"></A>: (* for 'inx' in [low:high] do INNER forTo *)
     (# <B>low</B><A name="betaenv.1.forTo.2.low.3(173)"></A><A name="low.3(173)"></A>,<B> high</B><A name="betaenv.1.forTo.2.high.3(174)"></A><A name="high.3(174)"></A>,<B> inx</B><A name="betaenv.1.forTo.2.inx.3(175)"></A><A name="inx.3(175)"></A>: @integer;
     enter (low, high)
     ...  
     #);
   <B>cycle</B><A name="betaenv.1.cycle.2(176)"></A><A name="cycle.2(176)"></A>: (* Executes INNER forever *)
     (# ... #);
   <B>loop</B><A name="betaenv.1.loop.2(177)"></A><A name="loop.2(177)"></A>: 
     (# <B>while</B><A name="betaenv.1.loop.2.while.3(178)"></A><A name="while.3(178)"></A>:&lt; booleanValue(# do true-&gt;value; INNER while #);
        <B>until</B><A name="betaenv.1.loop.2.until.3(179)"></A><A name="until.3(179)"></A>:&lt; booleanValue;
        <B>whilecondition</B><A name="betaenv.1.loop.2.whilecondition.3(180)"></A><A name="whilecondition.3(180)"></A>: @while;
        <B>untilcondition</B><A name="betaenv.1.loop.2.untilcondition.3(181)"></A><A name="untilcondition.3(181)"></A>: @until;
     ...
     #);
   <B>qua</B><A name="betaenv.1.qua.2(182)"></A><A name="qua.2(182)"></A>:
     (* Pattern replacing the BETA language construct QUA.  To be
      * used as 't1[]-&gt;qua(# as::&lt; Tn #)-&gt;t2[]'.  The 'qua' pattern
      * checks, whether 't1' is qualified by 'Tn'.  If not, the
      * 'quaError' exception is invoked.  Otherwise, a reference
      * qualified by 'Tn', and referring to the same object as 't1[]'
      * is referring, is returned.
      *)
     (# <B>as</B><A name="betaenv.1.qua.2.as.3(183)"></A><A name="as.3(183)"></A>:&lt; object; <B>R</B><A name="betaenv.1.qua.2.R.3(184)"></A><A name="R.3(184)"></A>: ^object; <B>thisObj</B><A name="betaenv.1.qua.2.thisObj.3(185)"></A><A name="thisObj.3(185)"></A>: ^as;
        <B>quaError</B><A name="betaenv.1.qua.2.quaError.3(186)"></A><A name="quaError.3(186)"></A>:&lt; exception
          (# do 'Qualification error'-&gt;msg.append; INNER quaError #)
     enter R[]
     ...  
     exit thisObj[]
     #);
   
   (*****  Stream patterns *******************************************)
   <B>stream</B><A name="betaenv.1.stream.2(187)"></A><A name="stream.2(187)"></A>: 
     (# &lt;&lt;SLOT streamLib: attributes&gt;&gt;;
        <B>length</B><A name="betaenv.1.stream.2.length.3(188)"></A><A name="length.3(188)"></A>:&lt; integerValue (* returns the length of THIS(stream) *)
          (#
          do -1-&gt;value; INNER length
          #);
        <B>position</B><A name="betaenv.1.stream.2.position.3(189)"></A><A name="position.3(189)"></A>: (* current position of THIS(stream) *)
          (# 
          enter setPos
          exit getPos
          #);
        <B>eos</B><A name="betaenv.1.stream.2.eos.3(190)"></A><A name="eos.3(190)"></A>:&lt; (* returns 'true' if THIS(stream) is at end-of-stream *)
          booleanValue;
        <B>reset</B><A name="betaenv.1.stream.2.reset.3(191)"></A><A name="reset.3(191)"></A>: (* sets 'position' to zero *)
          (#
          do 0-&gt;setPos
          exit THIS(stream)[]
          #);
        <B>peek</B><A name="betaenv.1.stream.2.peek.3(192)"></A><A name="peek.3(192)"></A>:&lt; (* looks at the next character of THIS(stream) *)
          (# <B>ch</B><A name="betaenv.1.stream.2.peek.3.ch.4(193)"></A><A name="ch.4(193)"></A>: @char
          do INNER peek
          exit ch
          #);
        <B>get</B><A name="betaenv.1.stream.2.get.3(194)"></A><A name="get.3(194)"></A>:&lt; (* reads a character from THIS(stream) *)
          (# <B>ch</B><A name="betaenv.1.stream.2.get.3.ch.4(195)"></A><A name="ch.4(195)"></A>: @char
          do INNER get
          exit ch
          #);
        <B>getNonBlank</B><A name="betaenv.1.stream.2.getNonBlank.3(196)"></A><A name="getNonBlank.3(196)"></A>: 
          (* Reads first non-whitespace character from THIS(stream).
           * If called at end-of-stream the character 'ascii.fs' is
           * returned
           *)
          (# <B>ch</B><A name="betaenv.1.stream.2.getNonBlank.3.ch.4(197)"></A><A name="ch.4(197)"></A>: @char;
             <B>skipblanks</B><A name="betaenv.1.stream.2.getNonBlank.3.skipblanks.4(198)"></A><A name="skipblanks.4(198)"></A>: @scanWhiteSpace;
             <B>testEOS</B><A name="betaenv.1.stream.2.getNonBlank.3.testEOS.4(199)"></A><A name="testEOS.4(199)"></A>: @EOS;
             <B>getCh</B><A name="betaenv.1.stream.2.getNonBlank.3.getCh.4(200)"></A><A name="getCh.4(200)"></A>: @get;
          ...
          exit ch
          #);
        <B>getint</B><A name="betaenv.1.stream.2.getint.3(201)"></A><A name="getint.3(201)"></A>: integerValue
          (* Reads an integer: skips whitespace characters and
           * returns the following digits.
           * 
           * See numberio.bet for more numerical output operations
           *)
          (# <B>syntaxError</B><A name="betaenv.1.stream.2.getint.3.syntaxError.4(202)"></A><A name="syntaxError.4(202)"></A>:&lt; streamException
               (# 
               ...
               #);
             <B>geti</B><A name="betaenv.1.stream.2.getint.3.geti.4(203)"></A><A name="geti.4(203)"></A>: @... 
          do geti; INNER getint
          #);
        <B>getAtom</B><A name="betaenv.1.stream.2.getAtom.3(204)"></A><A name="getAtom.3(204)"></A>:&lt;
          (* Returns the next atom (i.e. sequence of non-white
           * characters - skipping leading blanks)
           *)
          (# <B>txt</B><A name="betaenv.1.stream.2.getAtom.3.txt.4(205)"></A><A name="txt.4(205)"></A>: ^text;
          do &amp;text[]-&gt;txt[]; INNER getAtom;
          exit txt[]
          #);
        <B>getline</B><A name="betaenv.1.stream.2.getline.3(206)"></A><A name="getline.3(206)"></A>:&lt;
          (* Reads a sequence of characters until nl-character
           * appears and returns the characters read.
           *)
          (# <B>txt</B><A name="betaenv.1.stream.2.getline.3.txt.4(207)"></A><A name="txt.4(207)"></A>: ^text;
             <B>missing_newline</B><A name="betaenv.1.stream.2.getline.3.missing_newline.4(208)"></A><A name="missing_newline.4(208)"></A>:&lt; Object
               (* Called if last line of THIS(Stream) is
                * not terminated by a newline character.
                *);
          do &amp;text[]-&gt;txt[]; INNER getline
          exit txt[]
          #);
        <B>asInt</B><A name="betaenv.1.stream.2.asInt.3(209)"></A><A name="asInt.3(209)"></A>:
          (* converts THIS(text) to an integer value, ignoring
           * leading and trailing whitespace.  See numberio.bet for
           * more numerical conversion operations.
           *)
          (# <B>i</B><A name="betaenv.1.stream.2.asInt.3.i.4(210)"></A><A name="i.4(210)"></A>: @integer;
             <B>syntaxError</B><A name="betaenv.1.stream.2.asInt.3.syntaxError.4(211)"></A><A name="syntaxError.4(211)"></A>:&lt; streamException
               (# 
               ...
               #);
          ...
          exit i
          #);
        <B>put</B><A name="betaenv.1.stream.2.put.3(212)"></A><A name="put.3(212)"></A>:&lt; (* writes a character to THIS(stream) *)
          (# <B>ch</B><A name="betaenv.1.stream.2.put.3.ch.4(213)"></A><A name="ch.4(213)"></A>: @char
          enter ch
          do INNER put
          exit THIS(stream)[]
          #);
        <B>newline</B><A name="betaenv.1.stream.2.newline.3(214)"></A><A name="newline.3(214)"></A>: (* writes the nl-character *) 
          (#
          do ascii.newline-&gt;put
          exit THIS(stream)[]
          #);
        <B>putint</B><A name="betaenv.1.stream.2.putint.3(215)"></A><A name="putint.3(215)"></A>: 
          (* Writes an integer to THIS(stream); The format may be
           * controlled by the 'signed', 'blankSign', 'width',
           * 'adjustLeft' and 'zeroPadding' variable attributes.
           * 'width' is extended if it is too small.  Examples:
           * '10-&gt;putint' yields: '10'; '10*pi-&gt;putint(# do 10-&gt;width;
           * true-&gt;adjustLeft #)' yields: '10 '; and '10-&gt;putint(# do * 10-&gt;width; true-&gt;zeroPadding #)' yields: '0000000010'.
           * 
           * See numberio.bet for more numerical output operations
           *)
          (# <B>n</B><A name="betaenv.1.stream.2.putint.3.n.4(216)"></A><A name="n.4(216)"></A>: @integer;
             <B>signed</B><A name="betaenv.1.stream.2.putint.3.signed.4(217)"></A><A name="signed.4(217)"></A>: @boolean
               (* If integer is positive, a '+' will always be
                * displayed
                *);
             <B>blankSign</B><A name="betaenv.1.stream.2.putint.3.blankSign.4(218)"></A><A name="blankSign.4(218)"></A>: @boolean 
               (* If integer is positive, a ' ' space is displayed as
                * the sign.  Ignored if 'signed=true'
                *);
             <B>width</B><A name="betaenv.1.stream.2.putint.3.width.4(219)"></A><A name="width.4(219)"></A>: @integer
               (* Minimum width *);
             <B>adjustLeft</B><A name="betaenv.1.stream.2.putint.3.adjustLeft.4(220)"></A><A name="adjustLeft.4(220)"></A>: @boolean
               (* Specifies if the number is to be aligned left or
                * right, if padding of spaces is necessary to fill up
                * the specified width.
                *);
             <B>zeroPadding</B><A name="betaenv.1.stream.2.putint.3.zeroPadding.4(221)"></A><A name="zeroPadding.4(221)"></A>: @boolean
               (* width is padded with leading zero instead of
                * spaces.  Ignored if 'adjustLeft=true'
                *);
             <B>format</B><A name="betaenv.1.stream.2.putint.3.format.4(222)"></A><A name="format.4(222)"></A>:&lt; (# do INNER format #);
             <B>puti</B><A name="betaenv.1.stream.2.putint.3.puti.4(223)"></A><A name="puti.4(223)"></A>: @...
          enter n
          do 1-&gt;width; format; INNER putint; puti
          exit THIS(stream)[]
          #);
        <B>puttext</B><A name="betaenv.1.stream.2.puttext.3(224)"></A><A name="puttext.3(224)"></A>:&lt; (* Writes a text to THIS(stream). *)
          (# <B>txt</B><A name="betaenv.1.stream.2.puttext.3.txt.4(225)"></A><A name="txt.4(225)"></A>: ^text
          enter txt[]
          do (if txt[]&lt;&gt;NONE then INNER puttext if)
          exit THIS(stream)[]
          #);
        <B>putline</B><A name="betaenv.1.stream.2.putline.3(226)"></A><A name="putline.3(226)"></A>: 
          (* 'puttext' followed by 'newline' *)
          (# <B>T</B><A name="betaenv.1.stream.2.putline.3.T.4(227)"></A><A name="T.4(227)"></A>: ^text; <B>putT</B><A name="betaenv.1.stream.2.putline.3.putT.4(228)"></A><A name="putT.4(228)"></A>: @puttext; <B>newL</B><A name="betaenv.1.stream.2.putline.3.newL.4(229)"></A><A name="newL.4(229)"></A>: @newline
          enter T[]
          do INNER putline; T[]-&gt;putT; newL
          exit THIS(stream)[]
          #);
        <B>scan</B><A name="betaenv.1.stream.2.scan.3(230)"></A><A name="scan.3(230)"></A>: 
          (* Scan chars from current position in THIS(stream) while
           * '(ch-&gt;while)=true'; perform INNER for each char being
           * scanned
           *)
          (# <B>while</B><A name="betaenv.1.stream.2.scan.3.while.4(231)"></A><A name="while.4(231)"></A>:&lt;
               (# ch: @char; value: @boolean
               enter ch
               do true-&gt;value; INNER while
               exit value
               #);
             <B>ch</B><A name="betaenv.1.stream.2.scan.3.ch.4(232)"></A><A name="ch.4(232)"></A>: @char;
             <B>whilecondition</B><A name="betaenv.1.stream.2.scan.3.whilecondition.4(233)"></A><A name="whilecondition.4(233)"></A>: @while;
             <B>testEOS</B><A name="betaenv.1.stream.2.scan.3.testEOS.4(234)"></A><A name="testEOS.4(234)"></A>: @EOS;
             <B>getPeek</B><A name="betaenv.1.stream.2.scan.3.getPeek.4(235)"></A><A name="getPeek.4(235)"></A>: @peek;
             <B>getCh</B><A name="betaenv.1.stream.2.scan.3.getCh.4(236)"></A><A name="getCh.4(236)"></A>: @get;
          ...
          exit THIS(stream)[]
          #);
        <B>scanWhiteSpace</B><A name="betaenv.1.stream.2.scanWhiteSpace.3(237)"></A><A name="scanWhiteSpace.3(237)"></A>: scan 
          (* Scan whitespace characters *)
          (# <B>while</B><A name="betaenv.1.stream.2.scanWhiteSpace.3.while.4(238)"></A><A name="while.4(238)"></A>::&lt; (# do ch-&gt;ascii.isWhiteSpace-&gt;value #);
          do INNER scanWhiteSpace
          exit THIS(stream)[]
          #);
        <B>scanAtom</B><A name="betaenv.1.stream.2.scanAtom.3(239)"></A><A name="scanAtom.3(239)"></A>: 
          (* Scan until first non-whitespace char.  Scan the next
           * sequence of non-whitespace chars.  Stop at first
           * whitespace char.  For each non-whitespace char an INNER
           * is performed. Usage: 'scanAtom(# do ch-&gt;&lt;destination&gt; #)'
           *)
          (# <B>ch</B><A name="betaenv.1.stream.2.scanAtom.3.ch.4(240)"></A><A name="ch.4(240)"></A>: @char;
          ...
          exit THIS(stream)[]
          #);
        <B>scanToNl</B><A name="betaenv.1.stream.2.scanToNl.3(241)"></A><A name="scanToNl.3(241)"></A>: 
          (* Scan all chars in current line including newline char *)
          (# <B>ch</B><A name="betaenv.1.stream.2.scanToNl.3.ch.4(242)"></A><A name="ch.4(242)"></A>: @char; <B>getCh</B><A name="betaenv.1.stream.2.scanToNl.3.getCh.4(243)"></A><A name="getCh.4(243)"></A>: @get;
             <B>missing_newline</B><A name="betaenv.1.stream.2.scanToNl.3.missing_newline.4(244)"></A><A name="missing_newline.4(244)"></A>:&lt; Object
               (* Called if last line of THIS(Stream) is
                * not terminated by a newline character.
                *);
          ...
          exit THIS(stream)[]
          #);
        <B>streamException</B><A name="betaenv.1.stream.2.streamException.3(245)"></A><A name="streamException.3(245)"></A>: exception
          (# do INNER streamException #);
        <B>EOSerror</B><A name="betaenv.1.stream.2.EOSerror.3(246)"></A><A name="EOSerror.3(246)"></A>:&lt; streamException
          (* Raised from 'get' and 'peek' when attempted to read past
           * the end of the stream.
           *)
          (# 
          do 'Attempt to read past end-of-stream'-&gt;msg.putline; 
             INNER EOSerror
          #);
        <B>otherError</B><A name="betaenv.1.stream.2.otherError.3(247)"></A><A name="otherError.3(247)"></A>:&lt; streamException
          (* Raised when some other kind of stream error apart from
           * the one mentioned above occurs.
           *);
        <B>getPos</B><A name="betaenv.1.stream.2.getPos.3(248)"></A><A name="getPos.3(248)"></A>:&lt; (* returns current position of THIS(Stream) *)
          integerValue;
        <B>setPos</B><A name="betaenv.1.stream.2.setPos.3(249)"></A><A name="setPos.3(249)"></A>:&lt; (* sets current position in THIS(stream) to 'p' *)
          (# <B>p</B><A name="betaenv.1.stream.2.setPos.3.p.4(250)"></A><A name="p.4(250)"></A>: @integer
          enter p
          do INNER setPos
          exit THIS(stream)[]
          #)
     #); (* pattern stream *)
   
   (*****  Text pattern **********************************************)
   <B>text</B><A name="betaenv.1.text.2(251)"></A><A name="text.2(251)"></A>: stream
     (* A text is a sequence of characters.  Let 'T: @text'. The
      * range of 'T' is '[1,T.length]'.  A text can be initialized by
      * executing 'T.clear' or by assigning it another (initialized)
      * text.  A text-constant has the form 'foo'.  The 'text' pattern
      * is primarily intended for small texts but there is no upper
      * limit in the size. However, most of the operations becomes
      * less efficient with larger texts.
      *)
     (# &lt;&lt;SLOT textLib: attributes&gt;&gt;;
        <B>length</B><A name="betaenv.1.text.2.length.3(252)"></A><A name="length.3(252)"></A>::&lt; (* Returns the length of THIS(text) *) 
          (# do lgth-&gt;value; INNER length #);
        <B>eos</B><A name="betaenv.1.text.2.eos.3(253)"></A><A name="eos.3(253)"></A>::&lt;(# ... #);
        <B>empty</B><A name="betaenv.1.text.2.empty.3(254)"></A><A name="empty.3(254)"></A>: 
          (# exit (lgth = 0) #);
        <B>clear</B><A name="betaenv.1.text.2.clear.3(255)"></A><A name="clear.3(255)"></A>: (* Sets the length and position of THIS(text) to zero *)
          (#
          do 0-&gt;pos-&gt;lgth
          exit THIS(text)[]
          #);
        <B>equal</B><A name="betaenv.1.text.2.equal.3(256)"></A><A name="equal.3(256)"></A>: booleanValue
          (* Tests if THIS(text) is equal to the entered text.  If
           * 'NCS' is further bound to 'trueObject', the comparison
           * will be done Non Case Sensitive.
           *)
          (# <B>txt</B><A name="betaenv.1.text.2.equal.3.txt.4(257)"></A><A name="txt.4(257)"></A>: ^text;
             <B>NCS</B><A name="betaenv.1.text.2.equal.3.NCS.4(258)"></A><A name="NCS.4(258)"></A>:&lt; booleanObject
          enter txt[]
          ...
          #);
        <B>equalNCS</B><A name="betaenv.1.text.2.equalNCS.3(259)"></A><A name="equalNCS.3(259)"></A>: equal
          (* As 'equal', except the the comparison will be done Non
           * Case Sensitive
           *)
          (# <B>NCS</B><A name="betaenv.1.text.2.equalNCS.3.NCS.4(260)"></A><A name="NCS.4(260)"></A>:: trueObject #);
        <B>less</B><A name="betaenv.1.text.2.less.3(261)"></A><A name="less.3(261)"></A>: booleanValue
          (* Tests whether the entered text 'T1[1: length]' is less
           * than 'THIS(text)[1: T1.length]'.  The lexicographical
           * ordering is used.
           *)
          (# <B>T1</B><A name="betaenv.1.text.2.less.3.T1.4(262)"></A><A name="T1.4(262)"></A>: ^text
          enter T1[]
          ...
          #);
        <B>greater</B><A name="betaenv.1.text.2.greater.3(263)"></A><A name="greater.3(263)"></A>: booleanValue
          (* Tests whether the entered text 'T1[1: length]' is
           * greater than 'THIS(text)[1: T1.length]'.  The
           * lexicographical ordering is used.
           *)
          (# <B>T1</B><A name="betaenv.1.text.2.greater.3.T1.4(264)"></A><A name="T1.4(264)"></A>: ^text
          enter T1[]
          ...
          #);
        <B>peek</B><A name="betaenv.1.text.2.peek.3(265)"></A><A name="peek.3(265)"></A>::&lt;
          (* Returns the character at current position; does not
           * update 'position'
           *)
          (# ... #);
        <B>get</B><A name="betaenv.1.text.2.get.3(266)"></A><A name="get.3(266)"></A>::&lt;
          (* Returns the character at current position; increments
           * 'position'
           *) 
          (# ... #);
        <B>inxGet</B><A name="betaenv.1.text.2.inxGet.3(267)"></A><A name="inxGet.3(267)"></A>: charValue
          (* Returns the character at position 'i' *)
          (# <B>i</B><A name="betaenv.1.text.2.inxGet.3.i.4(268)"></A><A name="i.4(268)"></A>: @integer;
             <B>iget</B><A name="betaenv.1.text.2.inxGet.3.iget.4(269)"></A><A name="iget.4(269)"></A>: @...
          enter i
          do iget
          #);
        <B>getAtom</B><A name="betaenv.1.text.2.getAtom.3(270)"></A><A name="getAtom.3(270)"></A>::&lt;
          (* Returns the next atom (i.e. sequence of non-white
           * characters - skipping leading blanks)
           *)
          (# ... #);
        <B>getline</B><A name="betaenv.1.text.2.getline.3(271)"></A><A name="getline.3(271)"></A>::&lt;
          (* Reads a sequence of characters until nl-character
           * appears and returns the characters read.
           *)
          (# ... #);
        <B>put</B><A name="betaenv.1.text.2.put.3(272)"></A><A name="put.3(272)"></A>::&lt;
          (* writes the character 'ch' at current position in
           * THIS(text); increments 'position'
           *) 
          (# ... #);
        <B>inxPut</B><A name="betaenv.1.text.2.inxPut.3(273)"></A><A name="inxPut.3(273)"></A>: 
          (* Replaces the character at position 'i' *)
          (# <B>ch</B><A name="betaenv.1.text.2.inxPut.3.ch.4(274)"></A><A name="ch.4(274)"></A>: @char;
             <B>i</B><A name="betaenv.1.text.2.inxPut.3.i.4(275)"></A><A name="i.4(275)"></A>: @integer;
             <B>iput</B><A name="betaenv.1.text.2.inxPut.3.iput.4(276)"></A><A name="iput.4(276)"></A>: @...
          enter (ch,i)
          do iput
          exit THIS(text)[]
          #);
        <B>puttext</B><A name="betaenv.1.text.2.puttext.3(277)"></A><A name="puttext.3(277)"></A>::&lt;(# ... #);
        <B>append</B><A name="betaenv.1.text.2.append.3(278)"></A><A name="append.3(278)"></A>: 
          (* Appends a text to THIS(text); does not change 'position'
           *)
          (# <B>T1</B><A name="betaenv.1.text.2.append.3.T1.4(279)"></A><A name="T1.4(279)"></A>: ^text
          enter T1[]
          ...
          exit THIS(text)[]
          #);
        <B>prepend</B><A name="betaenv.1.text.2.prepend.3(280)"></A><A name="prepend.3(280)"></A>: 
          (* Inserts the text in 'T1' in front of THIS(text); updates
           * current position to 'position+T1.length' if 'position&gt;0'
           *)
          (# <B>T1</B><A name="betaenv.1.text.2.prepend.3.T1.4(281)"></A><A name="T1.4(281)"></A>: ^text
          enter T1[]
          ...
          exit THIS(text)[]
          #);
        <B>insert</B><A name="betaenv.1.text.2.insert.3(282)"></A><A name="insert.3(282)"></A>: 
          (* Inserts a text before the character at position 'inx'.
           * Note: inx&lt;1 means inx=1; inx&gt;length means inx=length+1.
           * If 'position&gt;=inx' then 'position+T1.length-&gt;position'.
           *)
          (# <B>T1</B><A name="betaenv.1.text.2.insert.3.T1.4(283)"></A><A name="T1.4(283)"></A>: ^text;
             <B>inx</B><A name="betaenv.1.text.2.insert.3.inx.4(284)"></A><A name="inx.4(284)"></A>: @integer
          enter (T1[],inx)
          ...
          exit THIS(text)[]
          #);
        <B>delete</B><A name="betaenv.1.text.2.delete.3(285)"></A><A name="delete.3(285)"></A>: 
          (* Deletes THIS(text)[i: j]; updates current position:
           *      i&lt;=position&lt;j =&gt; i-1-&gt;position
           *      j&lt;=position   =&gt; position-(j-i+1)-&gt;position
           *)
          (# <B>i</B><A name="betaenv.1.text.2.delete.3.i.4(286)"></A><A name="i.4(286)"></A>,<B>j</B><A name="betaenv.1.text.2.delete.3.j.4(287)"></A><A name="j.4(287)"></A>: @integer; 
             <B>deleteT</B><A name="betaenv.1.text.2.delete.3.deleteT.4(288)"></A><A name="deleteT.4(288)"></A>: @...
          enter (i,j)
          do deleteT
          exit THIS(text)[]
          #);
        <B>makeLC</B><A name="betaenv.1.text.2.makeLC.3(289)"></A><A name="makeLC.3(289)"></A>: (* Converts all characters to lower case *)
          (# ...
          exit THIS(text)[]
          #);
        <B>makeUC</B><A name="betaenv.1.text.2.makeUC.3(290)"></A><A name="makeUC.3(290)"></A>: 
          (* Converts all characters to upper case *)
          (# ...
          exit THIS(text)[]
          #);
        <B>sub</B><A name="betaenv.1.text.2.sub.3(291)"></A><A name="sub.3(291)"></A>:
          (* Returns a copy of THIS(text)[i:j].  If 'i&lt;1', 'i' is
           * adjusted to 1. If 'j&gt;length', 'j' is adjusted to
           * 'length'.  If (after adjustment) 'i&gt;j', an empty text is
           * returned.
           *)
          (# <B>i</B><A name="betaenv.1.text.2.sub.3.i.4(292)"></A><A name="i.4(292)"></A>,<B>j</B><A name="betaenv.1.text.2.sub.3.j.4(293)"></A><A name="j.4(293)"></A>: @integer; <B>T1</B><A name="betaenv.1.text.2.sub.3.T1.4(294)"></A><A name="T1.4(294)"></A>: ^text;
             <B>subI</B><A name="betaenv.1.text.2.sub.3.subI.4(295)"></A><A name="subI.4(295)"></A>: @...
          enter (i,j)
          do subI
          exit T1[]
          #);
        <B>copy</B><A name="betaenv.1.text.2.copy.3(296)"></A><A name="copy.3(296)"></A>: 
          (# <B>T1</B><A name="betaenv.1.text.2.copy.3.T1.4(297)"></A><A name="T1.4(297)"></A>: ^text;
             <B>copyI</B><A name="betaenv.1.text.2.copy.3.copyI.4(298)"></A><A name="copyI.4(298)"></A>: @...
          do copyI
          exit T1[]
          #);
        <B>scanAll</B><A name="betaenv.1.text.2.scanAll.3(299)"></A><A name="scanAll.3(299)"></A>: 
          (* Scans all the elements in THIS(text).  For 'ch' in '[1:
           * THIS(text).length]' do INNER
           *)
          (# <B>ch</B><A name="betaenv.1.text.2.scanAll.3.ch.4(300)"></A><A name="ch.4(300)"></A>: @char
          do (<B>for i</B><A name="betaenv.1.text.2.scanAll.3.for.4(301)"></A><A name="for.4(301)"></A>: lgth repeat T[i]-&gt;ch; INNER scanAll for)
          exit THIS(text)[]
          #);
        <B>find</B><A name="betaenv.1.text.2.find.3(302)"></A><A name="find.3(302)"></A>:
          (* find all occurrences of the character 'ch' in
           * THIS(text), executing INNER for each occurrence found,
           * beginning at 'THIS(text).position'.  'inx' will contain
           * the position of each 'ch' in THIS(text).  If 'NCS' is
           * further bound to 'trueObject', the comparison will be
           * done Non Case Sensitive.  If 'from' is further bound, the
           * search will begin at position 'from'.
           *)
          (# <B>ch</B><A name="betaenv.1.text.2.find.3.ch.4(303)"></A><A name="ch.4(303)"></A>: @char;
             <B>inx</B><A name="betaenv.1.text.2.find.3.inx.4(304)"></A><A name="inx.4(304)"></A>: @integer;
             <B>NCS</B><A name="betaenv.1.text.2.find.3.NCS.4(305)"></A><A name="NCS.4(305)"></A>:&lt; booleanObject;
             <B>from</B><A name="betaenv.1.text.2.find.3.from.4(306)"></A><A name="from.4(306)"></A>:&lt; integerObject(# do pos-&gt;value; INNER from #)
          enter ch
          ...
          exit THIS(text)[]
          #);
        <B>findAll</B><A name="betaenv.1.text.2.findAll.3(307)"></A><A name="findAll.3(307)"></A>: find
          (* As 'find', except that the entire text will be searched.
           * Replaces 'findCh' in previous versions of betaenv (v1.4
           * and earlier)
           *)
          (# <B>from</B><A name="betaenv.1.text.2.findAll.3.from.4(308)"></A><A name="from.4(308)"></A>:: (# do 0-&gt;value #)
          do INNER findAll
          #);
        <B>findText</B><A name="betaenv.1.text.2.findText.3(309)"></A><A name="findText.3(309)"></A>:
          (* find all occurrences of the 'txt' in THIS(text),
           * executing INNER for each occurrence found, beginning at
           * 'THIS(text).position'.  'inx' will contain the position
           * of the first character of each occurrence found
           * THIS(text).  If 'NCS' is further bound to 'trueObject',
           * the comparison will be done Non Case Sensitive.  If
           * 'from' is further bound, the search will begin at
           * position 'from'.
           *)
          (# <B>txt</B><A name="betaenv.1.text.2.findText.3.txt.4(310)"></A><A name="txt.4(310)"></A>: ^text;
             <B>inx</B><A name="betaenv.1.text.2.findText.3.inx.4(311)"></A><A name="inx.4(311)"></A>: @integer;
             <B>NCS</B><A name="betaenv.1.text.2.findText.3.NCS.4(312)"></A><A name="NCS.4(312)"></A>:&lt; booleanObject;
             <B>from</B><A name="betaenv.1.text.2.findText.3.from.4(313)"></A><A name="from.4(313)"></A>:&lt; integerObject(# do pos-&gt;value; INNER from #)
          enter txt[]
          ...
          exit THIS(text)[]
          #);
        <B>findTextAll</B><A name="betaenv.1.text.2.findTextAll.3(314)"></A><A name="findTextAll.3(314)"></A>: findText
          (* As 'findText', except that the entire text will be
           * searched
           *)
          (# <B>from</B><A name="betaenv.1.text.2.findTextAll.3.from.4(315)"></A><A name="from.4(315)"></A>:: (# do 0-&gt;value #)
          do INNER findTextAll
          #);
        <B>extend</B><A name="betaenv.1.text.2.extend.3(316)"></A><A name="extend.3(316)"></A>: 
          (* Extend THIS(text) with 'L' (undefined) chars. Notice
           * that it is only the representation of the THIS(text),
           * that is extended, the 'length' and 'position' are not
           * changed.
           *)
          (# <B>L</B><A name="betaenv.1.text.2.extend.3.L.4(317)"></A><A name="L.4(317)"></A>: @integer
          enter L do L-&gt;T.extend
          exit THIS(text)[]
          #);
        <B>indexError</B><A name="betaenv.1.text.2.indexError.3(318)"></A><A name="indexError.3(318)"></A>:&lt; streamException
          (* Raised from 'Check' when the index goes outside the
           * range of the text. Message: "Index error in text!".
           *)
          (# <B>inx</B><A name="betaenv.1.text.2.indexError.3.inx.4(319)"></A><A name="inx.4(319)"></A>: @integer 
          enter inx
          ...
          #);
        <B>EOSerror</B><A name="betaenv.1.text.2.EOSerror.3(320)"></A><A name="EOSerror.3(320)"></A>::&lt;
          (* Raised from 'get' and 'peek' when the end of the stream is
           * passed.
           *) 
          (# ... #);
        <B>otherError</B><A name="betaenv.1.text.2.otherError.3(321)"></A><A name="otherError.3(321)"></A>::&lt;
          (* Raised when an error other than the Index-/EOSerror
           * occurs.
           *) 
          (# ... #);
        <B>setPos</B><A name="betaenv.1.text.2.setPos.3(322)"></A><A name="setPos.3(322)"></A>::&lt;(# ... #);
        <B>getPos</B><A name="betaenv.1.text.2.getPos.3(323)"></A><A name="getPos.3(323)"></A>::&lt;(# do pos-&gt;value; INNER getPos #);
        (* Private attributes: !!OBS!! The 3 attributes 'T', 'lgth'
         * and 'pos' declared below MUST be the first data items
         * declared in 'stream' and 'text' since their addresses are
         * hardcoded into the compiler.
         *)
        <B>T</B><A name="betaenv.1.text.2.T.3(324)"></A><A name="T.3(324)"></A>: [16] @char;
        <B>lgth</B><A name="betaenv.1.text.2.lgth.3(325)"></A><A name="lgth.3(325)"></A>,<B>pos</B><A name="betaenv.1.text.2.pos.3(326)"></A><A name="pos.3(326)"></A>: (* 16 is default size *) @integer;
        <B>setT</B><A name="betaenv.1.text.2.setT.3(327)"></A><A name="setT.3(327)"></A>: (# enter T do T.range-&gt;lgth-&gt;pos #)
     enter setT
     exit T[1<A name="betaenv.1.text.2.1.3(328)"></A><A name="1.3(328)"></A>: lgth]
     #) (* Pattern text *); 
   
   (*****  ASCII character constants and attributes ******************)
   <B>ascii</B><A name="betaenv.1.ascii.2(329)"></A><A name="ascii.2(329)"></A>: @
     (# &lt;&lt;SLOT asciiLib: attributes&gt;&gt;;
        <B>nul</B><A name="betaenv.1.ascii.2.nul.3(330)"></A><A name="nul.3(330)"></A>: (# exit 0 #);
        <B>soh</B><A name="betaenv.1.ascii.2.soh.3(331)"></A><A name="soh.3(331)"></A>: (# exit 1 #);
        <B>stx</B><A name="betaenv.1.ascii.2.stx.3(332)"></A><A name="stx.3(332)"></A>: (# exit 2 #);
        <B>etx</B><A name="betaenv.1.ascii.2.etx.3(333)"></A><A name="etx.3(333)"></A>: (# exit 3 #);
        <B>eot</B><A name="betaenv.1.ascii.2.eot.3(334)"></A><A name="eot.3(334)"></A>: (# exit 4 #);
        <B>enq</B><A name="betaenv.1.ascii.2.enq.3(335)"></A><A name="enq.3(335)"></A>: (# exit 5 #);
        <B>ack</B><A name="betaenv.1.ascii.2.ack.3(336)"></A><A name="ack.3(336)"></A>: (# exit 6 #);
        <B>bel</B><A name="betaenv.1.ascii.2.bel.3(337)"></A><A name="bel.3(337)"></A>: (# exit 7 #);
        <B>bs</B><A name="betaenv.1.ascii.2.bs.3(338)"></A><A name="bs.3(338)"></A>: (# exit 8 #);
        <B>ht</B><A name="betaenv.1.ascii.2.ht.3(339)"></A><A name="ht.3(339)"></A>: (# exit 9 #);
        <B>nl</B><A name="betaenv.1.ascii.2.nl.3(340)"></A><A name="nl.3(340)"></A>: (# exit 10 #);
        <B>vt</B><A name="betaenv.1.ascii.2.vt.3(341)"></A><A name="vt.3(341)"></A>: (# exit 11 #);
        <B>np</B><A name="betaenv.1.ascii.2.np.3(342)"></A><A name="np.3(342)"></A>: (# exit 12 #);
        <B>cr</B><A name="betaenv.1.ascii.2.cr.3(343)"></A><A name="cr.3(343)"></A>: (# exit 13 #);
        <B>so</B><A name="betaenv.1.ascii.2.so.3(344)"></A><A name="so.3(344)"></A>: (# exit 14 #);
        <B>si</B><A name="betaenv.1.ascii.2.si.3(345)"></A><A name="si.3(345)"></A>: (# exit 15 #);
        <B>dle</B><A name="betaenv.1.ascii.2.dle.3(346)"></A><A name="dle.3(346)"></A>: (# exit 16 #);
        <B>dc1</B><A name="betaenv.1.ascii.2.dc1.3(347)"></A><A name="dc1.3(347)"></A>: (# exit 17 #);
        <B>dc2</B><A name="betaenv.1.ascii.2.dc2.3(348)"></A><A name="dc2.3(348)"></A>: (# exit 18 #);
        <B>dc3</B><A name="betaenv.1.ascii.2.dc3.3(349)"></A><A name="dc3.3(349)"></A>: (# exit 19 #);
        <B>dc4</B><A name="betaenv.1.ascii.2.dc4.3(350)"></A><A name="dc4.3(350)"></A>: (# exit 20 #);
        <B>nak</B><A name="betaenv.1.ascii.2.nak.3(351)"></A><A name="nak.3(351)"></A>: (# exit 21 #);
        <B>syn</B><A name="betaenv.1.ascii.2.syn.3(352)"></A><A name="syn.3(352)"></A>: (# exit 22 #);
        <B>etb</B><A name="betaenv.1.ascii.2.etb.3(353)"></A><A name="etb.3(353)"></A>: (# exit 23 #);
        <B>can</B><A name="betaenv.1.ascii.2.can.3(354)"></A><A name="can.3(354)"></A>: (# exit 24 #);
        <B>em</B><A name="betaenv.1.ascii.2.em.3(355)"></A><A name="em.3(355)"></A>: (# exit 25 #);
        <B>sub</B><A name="betaenv.1.ascii.2.sub.3(356)"></A><A name="sub.3(356)"></A>: (# exit 26 #);
        <B>esc</B><A name="betaenv.1.ascii.2.esc.3(357)"></A><A name="esc.3(357)"></A>: (# exit 27 #);
        <B>fs</B><A name="betaenv.1.ascii.2.fs.3(358)"></A><A name="fs.3(358)"></A>: (# exit 28 #);
        <B>gs</B><A name="betaenv.1.ascii.2.gs.3(359)"></A><A name="gs.3(359)"></A>: (# exit 29 #);
        <B>rs</B><A name="betaenv.1.ascii.2.rs.3(360)"></A><A name="rs.3(360)"></A>: (# exit 30 #);
        <B>us</B><A name="betaenv.1.ascii.2.us.3(361)"></A><A name="us.3(361)"></A>: (# exit 31 #);
        <B>sp</B><A name="betaenv.1.ascii.2.sp.3(362)"></A><A name="sp.3(362)"></A>: (# exit 32 #);
        <B>capA</B><A name="betaenv.1.ascii.2.capA.3(363)"></A><A name="capA.3(363)"></A>: (# exit 65 #);
        <B>smalla</B><A name="betaenv.1.ascii.2.smalla.3(364)"></A><A name="smalla.3(364)"></A>: (# exit 97 #);
        <B>del</B><A name="betaenv.1.ascii.2.del.3(365)"></A><A name="del.3(365)"></A>: (# exit 127 #);
        <B>newline</B><A name="betaenv.1.ascii.2.newline.3(366)"></A><A name="newline.3(366)"></A>: @char; (* either 'lf' or 'cr' *)
        
        <B>init</B><A name="betaenv.1.ascii.2.init.3(367)"></A><A name="init.3(367)"></A>: ...;
        <B>upCase</B><A name="betaenv.1.ascii.2.upCase.3(368)"></A><A name="upCase.3(368)"></A>: @charObject
          (# ... #);
        <B>lowCase</B><A name="betaenv.1.ascii.2.lowCase.3(369)"></A><A name="lowCase.3(369)"></A>: @charObject
          (# ... #);
        <B>testChar</B><A name="betaenv.1.ascii.2.testChar.3(370)"></A><A name="testChar.3(370)"></A>: booleanValue
          (# <B>ch</B><A name="betaenv.1.ascii.2.testChar.3.ch.4(371)"></A><A name="ch.4(371)"></A>: @char
          enter ch
          do INNER testchar
          #);
        <B>isUpper</B><A name="betaenv.1.ascii.2.isUpper.3(372)"></A><A name="isUpper.3(372)"></A>: @testChar
          (# ... #);
        <B>isLower</B><A name="betaenv.1.ascii.2.isLower.3(373)"></A><A name="isLower.3(373)"></A>: @testChar
          (# ... #);
        <B>isDigit</B><A name="betaenv.1.ascii.2.isDigit.3(374)"></A><A name="isDigit.3(374)"></A>: @testChar
          (# ... #);
        <B>isLetter</B><A name="betaenv.1.ascii.2.isLetter.3(375)"></A><A name="isLetter.3(375)"></A>: @testChar
          (# ... #);
        <B>isSpace</B><A name="betaenv.1.ascii.2.isSpace.3(376)"></A><A name="isSpace.3(376)"></A>: @testChar
          (* True if 'ch' in {sp,cr,nl,np,ht,vt} *) 
          (# ... #);
        <B>isWhiteSpace</B><A name="betaenv.1.ascii.2.isWhiteSpace.3(377)"></A><A name="isWhiteSpace.3(377)"></A>: @testChar
          (* True if 'ch' is a whitespace char *) 
          (# ... #);
        <B>private</B><A name="betaenv.1.ascii.2.private.3(378)"></A><A name="private.3(378)"></A>: @...
     #);
   (*****  Exception Patterns ****************************************)
   <B>stop</B><A name="betaenv.1.stop.2(379)"></A><A name="stop.2(379)"></A>: 
     (* Terminates program execution: 'termCode=normal': normal
      * termination; 'termCode=failure': abnormal termination;
      * 'termCode=failureTrace': abnormal termination with trace of
      * run-time stack on dump-file; 'T' will be printed on the
      * screen.
      *)
     (# <B>termCode</B><A name="betaenv.1.stop.2.termCode.3(380)"></A><A name="termCode.3(380)"></A>: @integer; <B>T</B><A name="betaenv.1.stop.2.T.3(381)"></A><A name="T.3(381)"></A>: ^text
     enter (termCode,T[])
     ...
     #);
   <B>normal</B><A name="betaenv.1.normal.2(382)"></A><A name="normal.2(382)"></A>: (# exit 0 #);
   <B>failure</B><A name="betaenv.1.failure.2(383)"></A><A name="failure.2(383)"></A>: (# exit -1 #);
   <B>failureTrace</B><A name="betaenv.1.failureTrace.2(384)"></A><A name="failureTrace.2(384)"></A>: (# exit -2 #);
   <B>exception</B><A name="betaenv.1.exception.2(385)"></A><A name="exception.2(385)"></A>:
     (# &lt;&lt;SLOT exceptionLib: attributes&gt;&gt;;
        <B>msg</B><A name="betaenv.1.exception.2.msg.3(386)"></A><A name="msg.3(386)"></A>:
          (* append text to this 'msg' vatiable to specify the
           * exception error message for this(exception)
           *)
          @text;
        <B>continue</B><A name="betaenv.1.exception.2.continue.3(387)"></A><A name="continue.3(387)"></A>: @boolean
          (* the valur of this variable determines the control-flow
           * behaviour of this(exception): 
           *    true:  continue execution after exception
           *    false: terminate execution by calling 'stop'; default
           *);
        <B>propagate</B><A name="betaenv.1.exception.2.propagate.3(388)"></A><A name="propagate.3(388)"></A>:&lt;
          (* if further bound to trueObject, this(exception) allows
           * propagation (i.e. this(exception will _not_ terminate)
           *)
          booleanValue;
        <B>error</B><A name="betaenv.1.exception.2.error.3(389)"></A><A name="error.3(389)"></A>:
          (* used to define local exception conditions which can be
           * handled separately.  All 'error's that are not handled
           * separately will be handled by this(exception)
           *)
          (# &lt;&lt;SLOT errorLib: attributes&gt;&gt;
          do false-&gt;continue;
             INNER;
             '**** Error processing\n'-&gt;msg.prepend;
             (if not propagate and not continue then this(exception) if)
          exit propagate
          #);
        <B>notify</B><A name="betaenv.1.exception.2.notify.3(390)"></A><A name="notify.3(390)"></A>: error
          (* used to define local notification conditions which can be
           * handled separately.  All 'notify's that are not handled
           * separately will be handled by this(exception)
           *)
          (# do true-&gt;continue; INNER #);
        <B>termCode</B><A name="betaenv.1.exception.2.termCode.3(391)"></A><A name="termCode.3(391)"></A>: @integer
          (* Arg. to pattern 'stop'; initial failureTrace *);
     do failureTrace-&gt;termCode;
        INNER exception;
        (if not continue and not propagate then
            '**** Exception processing\n'-&gt;msg.prepend;
            (termCode,msg[])-&gt;stop
        if)
     #);
   <B>notification</B><A name="betaenv.1.notification.2(392)"></A><A name="notification.2(392)"></A>: exception
     (# do true-&gt;continue; INNER notification #);
   (*****  Object Pool ***********************************************)
   <B>objectPool</B><A name="betaenv.1.objectPool.2(393)"></A><A name="objectPool.2(393)"></A>: @
     (# &lt;&lt;SLOT objectPoolLib: attributes&gt;&gt;;
        <B>get</B><A name="betaenv.1.objectPool.2.get.3(394)"></A><A name="get.3(394)"></A>: 
          (# type:&lt; object;
             obj: ^type;
             exact:&lt; booleanValue;
             init:&lt; object(* Called if an object was created *)
          ...
          exit obj[]
          #);
        <B>strucGet</B><A name="betaenv.1.objectPool.2.strucGet.3(395)"></A><A name="strucGet.3(395)"></A>: 
          (# type: ##object;
             obj: ^object;
             exact:&lt; booleanValue;
             init:&lt; object(* Called if an object was created *);
          enter type##
          ...
          exit obj[]
          #);
        <B>scan</B><A name="betaenv.1.objectPool.2.scan.3(396)"></A><A name="scan.3(396)"></A>: 
          (* Scan through all objects in 'objectPool', (at least)
           * qualified by 'type'.
           *)
          (# type:&lt; object;
             current: ^type;
             exact:&lt; booleanValue;
          ...
          #);
        <B>strucScan</B><A name="betaenv.1.objectPool.2.strucScan.3(397)"></A><A name="strucScan.3(397)"></A>: 
          (* Scan through all objects in 'objectPool', (at least)
           * qualified by 'type'
           *)
          (# type: ##object;
             current: ^object;
             exact:&lt; booleanValue
          enter type##
          ...
          #);
        <B>put</B><A name="betaenv.1.objectPool.2.put.3(398)"></A><A name="put.3(398)"></A>: 
          (* Puts a given object into 'objectPool'. If an object with
           * (at least) the qualification of the given object is
           * already present in 'objectPool', the exception
           * 'alreadyThere' is raised.
           *)
          (# obj: ^object;
             exact:&lt; booleanValue;
             alreadyThere:&lt; exception;
             putObj: @...
          enter obj[]
          do putObj
          #);
        <B>private</B><A name="betaenv.1.objectPool.2.private.3(399)"></A><A name="private.3(399)"></A>: @...;
     #);
   
   (*****  Command line arguments ************************************)
   <B>argumentHandlerType</B><A name="betaenv.1.argumentHandlerType.2(400)"></A><A name="argumentHandlerType.2(400)"></A>:
     (# 
        <B>noOfArguments</B><A name="betaenv.1.argumentHandlerType.2.noOfArguments.3(401)"></A><A name="noOfArguments.3(401)"></A>:&lt; 
          (* Return the number of arguments on command line.
           * The number includes the program name.
           *)
          integervalue;
        
        <B>getArgByNumber</B><A name="betaenv.1.argumentHandlerType.2.getArgByNumber.3(402)"></A><A name="getArgByNumber.3(402)"></A>:&lt;
          (* Returns argument number argNo.  
           * Number 1 is the program name, 
           * number 2 is the first program argument, etc.
           *)
          (# argNo: @integer; theArg: ^text;
          enter argNo
          do INNER
          exit theArg[]
          #);
     #);
   
   <B>rawArgumentHandler</B><A name="betaenv.1.rawArgumentHandler.2(403)"></A><A name="rawArgumentHandler.2(403)"></A>: argumentHandlerType
     (# 
        <B>noOfArguments</B><A name="betaenv.1.rawArgumentHandler.2.noOfArguments.3(404)"></A><A name="noOfArguments.3(404)"></A>::
          (# ... #);
        <B>getArgByNumber</B><A name="betaenv.1.rawArgumentHandler.2.getArgByNumber.3(405)"></A><A name="getArgByNumber.3(405)"></A>::
          (# ... #);
     #);
   
   <B>expandWildcardsArgumentHandler</B><A name="betaenv.1.expandWildcardsArgumentHandler.2(406)"></A><A name="expandWildcardsArgumentHandler.2(406)"></A>: argumentHandlerType
     (# <B>private</B><A name="betaenv.1.expandWildcardsArgumentHandler.2.private.3(407)"></A><A name="private.3(407)"></A>: @...;
        <B>noOfArguments</B><A name="betaenv.1.expandWildcardsArgumentHandler.2.noOfArguments.3(408)"></A><A name="noOfArguments.3(408)"></A>::
          (# ... #);
        <B>getArgByNumber</B><A name="betaenv.1.expandWildcardsArgumentHandler.2.getArgByNumber.3(409)"></A><A name="getArgByNumber.3(409)"></A>::
          (# ... #);
     #);
   
   <B>argumentHandler</B><A name="betaenv.1.argumentHandler.2(410)"></A><A name="argumentHandler.2(410)"></A>: ^argumentHandlerType;
   
   (* Backwards compatible interface *)
   <B>noOfArguments</B><A name="betaenv.1.noOfArguments.2(411)"></A><A name="noOfArguments.2(411)"></A>: integervalue(# do argumentHandler.noOfArguments -&gt; value #);
   <B>arguments</B><A name="betaenv.1.arguments.2(412)"></A><A name="arguments.2(412)"></A>: 
     (# <B>argNo</B><A name="betaenv.1.arguments.2.argNo.3(413)"></A><A name="argNo.3(413)"></A>: @integer; <B>theArg</B><A name="betaenv.1.arguments.2.theArg.3(414)"></A><A name="theArg.3(414)"></A>: ^text;
     enter argNo
     do argNo -&gt; argumentHandler.getArgByNumber -&gt; theArg[]
     exit theArg[]
     #);
   (******************************************************************)
   (* External language interface: See file 'external.bet' for further
    * patterns.
    *)
   <B>External</B><A name="betaenv.1.External.2(415)"></A><A name="External.2(415)"></A>:
     (* Is only meaningful with interface to externals *)
     (# <B>callC</B><A name="betaenv.1.External.2.callC.3(416)"></A><A name="callC.3(416)"></A>,<B>callPascal</B><A name="betaenv.1.External.2.callPascal.3(417)"></A><A name="callPascal.3(417)"></A>,<B>pascal</B><A name="betaenv.1.External.2.pascal.3(418)"></A><A name="pascal.3(418)"></A>,<B>pascalTrap</B><A name="betaenv.1.External.2.pascalTrap.3(419)"></A><A name="pascalTrap.3(419)"></A>,<B>callStd</B><A name="betaenv.1.External.2.callStd.3(420)"></A><A name="callStd.3(420)"></A>,<B>
        cExternalEntry</B><A name="betaenv.1.External.2.cExternalEntry.3(421)"></A><A name="cExternalEntry.3(421)"></A>,<B>pascalExternalEntry</B><A name="betaenv.1.External.2.pascalExternalEntry.3(422)"></A><A name="pascalExternalEntry.3(422)"></A>,<B>stdExternalEntry</B><A name="betaenv.1.External.2.stdExternalEntry.3(423)"></A><A name="stdExternalEntry.3(423)"></A>: @text
     #);
   <B>cStruct</B><A name="betaenv.1.cStruct.2(424)"></A><A name="cStruct.2(424)"></A>: 
     (* Super-pattern for describing structures which can be given
      * 'by refererence' (using the usual [] notation) to an external
      * function (e.g. a C function described as a specialization
      * of the above External pattern). See file external.bet for
      * supported operations on cStruct.
      *)
     (# &lt;&lt;SLOT cStructLib: attributes&gt;&gt;;
        (* 'R' is the bytestream containing THIS(cStruct).  
         * MUST be declared as the first attribute
         *);
        <B>R</B><A name="betaenv.1.cStruct.2.R.3(425)"></A><A name="R.3(425)"></A>: [(byteSize-1) div 4 + 1] @integer;
        <B>byteSize</B><A name="betaenv.1.cStruct.2.byteSize.3(426)"></A><A name="byteSize.3(426)"></A>:&lt; 
          (* Number of bytes in THIS(cStruct) *)
          IntegerObject;
          
        <B>BoundsExceeded</B><A name="betaenv.1.cStruct.2.BoundsExceeded.3(427)"></A><A name="BoundsExceeded.3(427)"></A>:&lt; Exception
          (* Raised if indexing outside range of R *)
          (# <B>inx</B><A name="betaenv.1.cStruct.2.BoundsExceeded.3.inx.4(428)"></A><A name="inx.4(428)"></A>: @integer; 
          enter inx
          ...
          #);
        <B>chk</B><A name="betaenv.1.cStruct.2.chk.3(429)"></A><A name="chk.3(429)"></A>: @(# <B>inx</B><A name="betaenv.1.cStruct.2.chk.3.inx.4(430)"></A><A name="inx.4(430)"></A>: @integer enter inx ... #);
     #);
   <B>data</B><A name="betaenv.1.data.2(431)"></A><A name="data.2(431)"></A>:
     (* The 'data' pattern may be used for definining simple data
      * objects.  Data-objects have no 'type' information. They can
      * thus NOT be allocated dynamically in the BETA heap. They do * not have the overhead of extra attributes used for virtual
      * dispatch and garbage collection. One main use of data-objects
      * is as interface to external data such as 'cstruct'.  For
      * details see the manuals
      *)
     (# #);
   <B>doGC</B><A name="betaenv.1.doGC.2(432)"></A><A name="doGC.2(432)"></A>: (* will force a garbage collection to happen *)
     (# ... #);
   <B>machine_type</B><A name="betaenv.1.machine_type.2(433)"></A><A name="machine_type.2(433)"></A>:
     (* Exits a reference to a copy of a text indicating the machine
      * type in lowercase, e.g. 'sun4s', 'linux', 'nti'.
      *)
     (# <B>T</B><A name="betaenv.1.machine_type.2.T.3(434)"></A><A name="T.3(434)"></A>: @Text;
     do machine_typeexternal-&gt;T;
     exit T.copy
     #);
   <B>machine_typeexternal</B><A name="betaenv.1.machine_typeexternal.2(435)"></A><A name="machine_typeexternal.2(435)"></A>: external
     (# <B>T</B><A name="betaenv.1.machine_typeexternal.2.T.3(436)"></A><A name="T.3(436)"></A>: [1]@Char; do 'machine_type'-&gt;callC; exit T #);
   <B>program</B><A name="betaenv.1.program.2(437)"></A><A name="program.2(437)"></A>: (* descriptor executed by this environment *)
     ...;
   <B>theProgram</B><A name="betaenv.1.theProgram.2(438)"></A><A name="theProgram.2(438)"></A>: ^|program;
   <B>theScheduler</B><A name="betaenv.1.theScheduler.2(439)"></A><A name="theScheduler.2(439)"></A>: ^|object
     (* Scheduler installed by 'basicSystemEnv' (if used in program) *);
   (******************************************************************)
   (* The following patterns are only used by the compiler and should
    * NOT be used for other purposes.
    *)
   <B>repetition</B><A name="betaenv.1.repetition.2(440)"></A><A name="repetition.2(440)"></A>: 
     (# <B>range</B><A name="betaenv.1.repetition.2.range.3(441)"></A><A name="range.3(441)"></A>: (* Returns the range of THIS(repetition) *)
          (# n: @integer
          exit n
          #);
        <B>new</B><A name="betaenv.1.repetition.2.new.3(442)"></A><A name="new.3(442)"></A>: 
          (* Allocates a new repetition of 'n' elements. The previous
           * elements in THIS(repetition) become inaccessible
           * hereafter
           *)
          (# n: @integer
          enter n
          #);
        <B>extend</B><A name="betaenv.1.repetition.2.extend.3(443)"></A><A name="extend.3(443)"></A>:
          (* Extends THIS(repetition) by 'n' elements.  The existing
           * elements are retained.  The new elements are allocated
           * after the existing elements (i.e. with index from the
           * 'range+1')
           *)
          (# n: @integer
          enter n
          #)
     #);
   <B>state</B><A name="betaenv.1.state.2(444)"></A><A name="state.2(444)"></A>: (# #); (* Pattern STATE is for experimental purpose only
                  * and using it may give undefined results 
                  *)
   <B>errorName</B><A name="betaenv.1.errorName.2(445)"></A><A name="errorName.2(445)"></A>: (# #)
   
   (******************************************************************)
do ...;
   &amp;|program[]-&gt;theProgram[];
   theProgram;
   (if theScheduler[]&lt;&gt;NONE then theScheduler if);
   ... ;
#)
</PRE>
<TABLE BORDER=0 ALIGN=RIGHT>
<TR>
<TD>
<A HREF="http://validator.w3.org/check/referer">
<IMG BORDER=0 SRC="../../images/vh40.gif" ALT="Valid HTML 4.0!" HEIGHT=31 WIDTH=88>
</A>
</TD>
</TR>
</TABLE>
<BR CLEAR=right>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Betaenv Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
