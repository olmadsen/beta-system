<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Formatio Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript">
<!--
    CheckParent("formatio");
//-->
</SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="formatio">Formatio Interface</A></H1>

<PRE CLASS=interface>
ORIGIN 'betaenv';
LIB_DEF 'formatio' '../lib';
BODY 'private/formatioBody'
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1984-96
 *       All rights reserved.
 *
 *)
--- streamLib: attributes ---
<B>getFormat</B><A name="getFormat.1(640)"></A>: formatter
  (* getFormat accepts the following syntax for markers:
   * 
   *      %[width][.[precision]]{dioxXrRbBfeEgGcsn%}
   * 
   * where width is a (unsigned) decimal number (or '*'), and
   *   precision is a (unsigned) decimal number (or '*'),
   * 
   * and where
   *     [ ... ] means that the enclodes is optional,
   * and { ... } means one if the enclosed characters.
   * 
   * Width is only interpreted in conjunction with the 's' marker.
   * Precision is only interpreted in conjunction with the
   * 'r' and 'R' markers.
   * 
   * For all but the 'c' marker, leading white space are skipped.
   * 
   * The '%' marker means that a '%' is expected on the input stream.
   * 
   * Actually, getFormat accepts the same syntax as putFormat (see
   * later):
   * 
   *      %{-+ }[[0]width][.[[0]precision]]{dioxXrRbBfeEgGcsn%}
   * 
   * but only the above part of that syntax is actually interpreted by
   * getFormat.  The reason for accepting the same syntax is to allow
   * a format string to be used both for getFormat and putFormat.
   *)
  (# <B>width</B><A name="getFormat.1.width.2(641)"></A><A name="width.2(641)"></A>:
       (* sets the default precision to be used in future '*' width
        * specifications
        *)
       (# w: @integer enter w ... #);
     <B>precision</B><A name="getFormat.1.precision.2(642)"></A><A name="precision.2(642)"></A>:
       (* sets the default precision to be used in future '*'
        * precision specifications
        *)
       (# p: @integer enter p ... #);
     <B>marker</B><A name="getFormat.1.marker.2(643)"></A><A name="marker.2(643)"></A>: scanForMarker
       (# formatEOS:: (# do mark-&gt;missingMarker #)
       ...
       #);
     <B>d</B><A name="getFormat.1.d.2(644)"></A><A name="d.2(644)"></A>: marker (* read a decimal number *)
       (# mark:: (# do 'd'-&gt;value #);
          value: @integer
       ...    
       exit value
       #);
     <B>i</B><A name="getFormat.1.i.2(645)"></A><A name="i.2(645)"></A>: marker
       (* read a number, either decimal, octal or hexadecimal using C
        * conventions: 0nnn implies octal, 0xnnn implies hexadecimal,
        * decimal otherwise.
        *)
       (# mark:: (# do 'i'-&gt;value #);
          value: @integer
       ...    
       exit value
       #);
     <B>o</B><A name="getFormat.1.o.2(646)"></A><A name="o.2(646)"></A>: marker (* read an octal number *)
       (# mark:: (# do 'o'-&gt;value #);
          value: @integer
       ...    
       exit value
       #);
     <B>x</B><A name="getFormat.1.x.2(647)"></A><A name="x.2(647)"></A>: marker (* read a hexadecimal number *)
       (# mark:: (# do 'x'-&gt;value #);
          value: @integer
       ...   
       exit value
       #);
     <B>uX</B><A name="getFormat.1.uX.2(648)"></A><A name="uX.2(648)"></A>: marker (* read a hexadecimal number.  Identical to 'x' *)
       (# mark:: (# do 'X'-&gt;value #);
          value: @integer
       ...    
       exit value
       #);
     <B>r</B><A name="getFormat.1.r.2(649)"></A><A name="r.2(649)"></A>: marker
       (* read a number in radix given by precision *)
       (# mark:: (# do 'r'-&gt;value #);
          value: @integer
       ...  
       exit value
       #);
     <B>uR</B><A name="getFormat.1.uR.2(650)"></A><A name="uR.2(650)"></A>: marker
       (* read a number in radix given by precision.  Identical to
        * 'r'
        *)
       (# mark:: (# do 'R'-&gt;value #);
          value: @integer
       ...  
       exit value
       #);
     <B>b</B><A name="getFormat.1.b.2(651)"></A><A name="b.2(651)"></A>: marker
       (* read a number as based number (i.e. in the bbxnnn format) *)
       (# mark:: (# do 'b'-&gt;value #);
          base, value: @integer
       ...  
       exit (base,value)
       #);
     <B>uB</B><A name="getFormat.1.uB.2(652)"></A><A name="uB.2(652)"></A>: marker
       (* read a number as based number (i.e. in the bbxnnn format).
        * Identical to 'b'
        *)
       (# mark:: (# do 'B'-&gt;value #);
          base, value: @integer
       ...  
       exit (base,value)
       #);
     <B>f</B><A name="getFormat.1.f.2(653)"></A><A name="f.2(653)"></A>: marker (* read a real *)
       (# mark:: (# do 'f'-&gt;value #);
          value: @real
       ...    
       exit value
       #);
     <B>e</B><A name="getFormat.1.e.2(654)"></A><A name="e.2(654)"></A>: marker (* read a real.  Identical to 'f' *)
       (# mark:: (# do 'e'-&gt;value #);
          value: @real
       ...    
       exit value
       #);
     <B>uE</B><A name="getFormat.1.uE.2(655)"></A><A name="uE.2(655)"></A>: marker (* read a real.  Identical to 'f' *)
       (# mark:: (# do 'E'-&gt;value #);
          value: @real
       ...    
       exit value
       #);
     <B>g</B><A name="getFormat.1.g.2(656)"></A><A name="g.2(656)"></A>: marker (* read a real.  Identical to 'f' *)
       (# mark:: (# do 'g'-&gt;value #);
          value: @real
       ...    
       exit value
       #);
     <B>uG</B><A name="getFormat.1.uG.2(657)"></A><A name="uG.2(657)"></A>: marker (* read a real.  Identical to 'f' *)
       (# mark:: (# do 'G'-&gt;value #);
          value: @real
       ...    
       exit value
       #);
     <B>c</B><A name="getFormat.1.c.2(658)"></A><A name="c.2(658)"></A>: marker (* read a single character *)
       (# mark:: (# do 'c'-&gt;value #);
          value: @char
       ...    
       exit value
       #);
     <B>s</B><A name="getFormat.1.s.2(659)"></A><A name="s.2(659)"></A>: marker 
       (* read a text atom (i.e. a sequence of non-white space
        * characters, terminated by a white space character - similar
        * to getAtom).  If width is non-zero, at most width characters
        * are read.  Otherwise, characters are read until next
        * whitespace character
        *)
       (# mark:: (# do 's'-&gt;value #);
          value: ^text
       ...  
       exit value[]
       #);
     <B>n</B><A name="getFormat.1.n.2(660)"></A><A name="n.2(660)"></A>: marker
       (* return the number of characters read until this point *)
       (# mark:: (# do 'n'-&gt;value #);
          value: @integer
       ...  
       exit value
       #);
     <B>match</B><A name="getFormat.1.match.2(661)"></A><A name="match.2(661)"></A>:: (* private *)
       (# ... #)
  do INNER getFormat
  #);

<B>putFormat</B><A name="putFormat.1(662)"></A>: formatter
  (* putFormat accepts the following syntax for markers:
   * 
   *      %{-+ }[[0]width][.[[0]precision]]{dioxXrRbBfeEgGcsnt%}
   * 
   * where width is a (unsigned) decimal number (or '*'), and
   *   precision is a (unsigned) decimal number (or '*') and where
   * 
   *     [ ... ] means that the enclodes is optional,
   * and { ... } means one if the enclosed characters.
   * 
   * '-' implies output leftjustified in field
   * '+' implies output numbers signed (always with leading '+' or
   *                                    '-')
   * ' ' implies output numbers with blank sign (i.e. leading ' ' if
   *                                             positive)
   * '0' in front of either width or precision implies zero padding
   * width specifies the minimun width of the output field.
   * precision is interpreted for various things in the 'rRbBfeEgG'
   *     markers.
   * 
   * The '%' marker means that a '%' is put on the output stream.
   * 
   * The '%t' marker prints booleans, use it with tv.
   *)
  (# <B>width</B><A name="putFormat.1.width.2(663)"></A><A name="width.2(663)"></A>:
       (* sets the default precision to be used in future '*' width
        * specifications
        *)
       (# w: @integer enter w ... #);
     <B>precision</B><A name="putFormat.1.precision.2(664)"></A><A name="precision.2(664)"></A>:
       (* sets the default precision to be used in future '*'
        * precision specifications
        *)
       (# p: @integer enter p ... #);
     <B>marker</B><A name="putFormat.1.marker.2(665)"></A><A name="marker.2(665)"></A>: scanForMarker
       (# formatEOS:: (# do mark-&gt;missingMarker #)
       ...
       #);
     <B>d</B><A name="putFormat.1.d.2(666)"></A><A name="d.2(666)"></A>: marker (* insert the integer *)
       (# mark:: (# do 'd'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>i</B><A name="putFormat.1.i.2(667)"></A><A name="i.2(667)"></A>: marker (* insert the integer. Identical to 'd' *)
       (# mark:: (# do 'i'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>y</B><A name="putFormat.1.y.2(668)"></A><A name="y.2(668)"></A>: marker (* insert the integer in binary *)
       (# mark:: (# do 'y'-&gt;value #);
          value: @integer
       enter value
       ...
       #);
     <B>o</B><A name="putFormat.1.o.2(669)"></A><A name="o.2(669)"></A>: marker (* insert the integer in octal, at least 10 ciffers *)
       (# mark:: (# do 'o'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>x</B><A name="putFormat.1.x.2(670)"></A><A name="x.2(670)"></A>: marker (* insert the integer in hexadecimal, at least 8 ciffers *)
       (# mark:: (# do 'x'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>uX</B><A name="putFormat.1.uX.2(671)"></A><A name="uX.2(671)"></A>: marker
       (* insert the integer in hexadecimal, using uppercase letters
        *)
       (# mark:: (# do 'X'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>r</B><A name="putFormat.1.r.2(672)"></A><A name="r.2(672)"></A>: marker
       (* insert the integer in radix given by precision *)
       (# mark:: (# do 'r'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>uR</B><A name="putFormat.1.uR.2(673)"></A><A name="uR.2(673)"></A>: marker
       (* insert the integer in radix given by precision, using
        * uppercase letters if radix&gt;10
        *)
       (# mark:: (# do 'R'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>b</B><A name="putFormat.1.b.2(674)"></A><A name="b.2(674)"></A>: marker
       (* insert the integer as based number (i.e. in the bbxnnn
        * format) with base given by precision
        *)
       (# mark:: (# do 'b'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>uB</B><A name="putFormat.1.uB.2(675)"></A><A name="uB.2(675)"></A>: marker
       (* insert the integer as based number (i.e. in the bbxnnn
        * format) with base given by precision, using uppercase
        * letters if base&gt;10
        *)
       (# mark:: (# do 'B'-&gt;value #);
          value: @integer
       enter value
       ...  
       #);
     <B>f</B><A name="putFormat.1.f.2(676)"></A><A name="f.2(676)"></A>: marker (* insert the real in noexp style *)
       (# mark:: (# do 'f'-&gt;value #);
          value: @real
       enter value
       ...  
       #);
     <B>e</B><A name="putFormat.1.e.2(677)"></A><A name="e.2(677)"></A>: marker (* insert the real in exp style *)
       (# mark:: (# do 'e'-&gt;value #);
          value: @real
       enter value
       ...  
       #);
     <B>uE</B><A name="putFormat.1.uE.2(678)"></A><A name="uE.2(678)"></A>: marker (* insert the real in exp style and upcase 'E' *)
       (# mark:: (# do 'E'-&gt;value #);
          value: @real
       enter value
       ...  
       #);
     <B>g</B><A name="putFormat.1.g.2(679)"></A><A name="g.2(679)"></A>: marker (* insert the real in plain style *)
       (# mark:: (# do 'g'-&gt;value #);
          value: @real
       enter value
       ...  
       #);
     <B>uG</B><A name="putFormat.1.uG.2(680)"></A><A name="uG.2(680)"></A>: marker (* insert the real in plain style and upcase 'E' *)
       (# mark:: (# do 'G'-&gt;value #);
          value: @real
       enter value
       ...  
       #);
     <B>c</B><A name="putFormat.1.c.2(681)"></A><A name="c.2(681)"></A>: marker (* insert the char *)
       (# mark:: (# do 'c'-&gt;value #);
          value: @char;
          putc: @(* Private *)...  
       enter value
       do putc
       #);
     <B>s</B><A name="putFormat.1.s.2(682)"></A><A name="s.2(682)"></A>: marker (* insert the text *)
       (# mark:: (# do 's'-&gt;value #);
          value: ^text;
          puts: @(* Private *)...
       enter value[]
       do puts
       #);
     <B>n</B><A name="putFormat.1.n.2(683)"></A><A name="n.2(683)"></A>: marker
       (* return the length of the result string until this point *)
       (# mark:: (# do 'n'-&gt;value #);
          value: @integer
       ...  
       exit value
       #);
     <B>trueText</B><A name="putFormat.1.trueText.2(684)"></A><A name="trueText.2(684)"></A>:&lt;(# t:^text; do 'true'-&gt;t[]; INNER exit t[] #);
     <B>falseText</B><A name="putFormat.1.falseText.2(685)"></A><A name="falseText.2(685)"></A>:&lt;(# t:^text; do 'false'-&gt;t[]; INNER exit t[] #);     
     <B>tv</B><A name="putFormat.1.tv.2(686)"></A><A name="tv.2(686)"></A>: marker (* Truth-value, prints trueText of falseText *)
       (# mark:: (# do 't'-&gt;value #);
          localTrueText:&lt;(# t:^text; enter t[] do INNER exit t[] #);   
          localFalseText:&lt;(# t:^text; enter t[] do INNER exit t[] #);   
          value:@boolean
       enter value
       ...
       #);
     <B>match</B><A name="putFormat.1.match.2(687)"></A><A name="match.2(687)"></A>:: (* private *)
       (# ... #)
  do INNER putFormat
  #);

<B>formatter</B><A name="formatter.1(688)"></A>: (* superpattern for putFormat and getFormat *)
  (# <B>illegalFormat</B><A name="formatter.1.illegalFormat.2(689)"></A><A name="illegalFormat.2(689)"></A>:&lt; exception
       (# mark: @char
       enter mark
       ...
       #);
     <B>missingMarker</B><A name="formatter.1.missingMarker.2(690)"></A><A name="missingMarker.2(690)"></A>:&lt; exception
       (# mark: @char
       enter mark
       ...
       #);
     <B>missingField</B><A name="formatter.1.missingField.2(691)"></A><A name="missingField.2(691)"></A>:&lt; exception
       (# ... #);
     <B>inputError</B><A name="formatter.1.inputError.2(692)"></A><A name="inputError.2(692)"></A>:&lt; exception
       (# chFound, chExpected: @char
       enter (chFound, chExpected)
       ...
       #);
     <B>scanForMarker</B><A name="formatter.1.scanForMarker.2(693)"></A><A name="scanForMarker.2(693)"></A>: (* Private *)
       (# mark:&lt; charValue;
          formatEOS:&lt; exception;
          fieldWidth, precisionSpec: @integer;
          leftFlag, signedFlag, blankFlag,
          alternativeFlag, zeroFlag, longFlag: @boolean
       ...
       #);
     <B>match</B><A name="formatter.1.match.2(694)"></A><A name="match.2(694)"></A>:&lt; (* private *)
       (# ch: @char
       enter ch
       do INNER match
       #);
     <B>private</B><A name="formatter.1.private.2(695)"></A><A name="private.2(695)"></A>: @...;
     <B>formatStr</B><A name="formatter.1.formatStr.2(696)"></A><A name="formatStr.2(696)"></A>: ^text
  enter formatStr[]
  ...
  exit this(stream)[]
  #);

--- lib: attributes ---
   
<B>getFormat</B><A name="getFormat.1(697)"></A>: keyboard.getFormat(# do INNER getFormat #);

<B>putFormat</B><A name="putFormat.1(698)"></A>: screen.putFormat(# do INNER putFormat #)
</PRE>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Formatio Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
