<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Wtext Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent()'>
<H1><A name="wtext">Wtext Interface</A></H1>

<PRE CLASS=interface>
ORIGIN 'betaenv';
BODY 'private/wtextbody'
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1997-98
 *       All rights reserved.
 *
 * This fragment implements a UniCode stream and text concept
 *)

---lib:attributes---
<B>wStream</B><A name="wStream.1(1175)"></A>: 
  (# &lt;&lt;SLOT wStreamLib: attributes&gt;&gt;;
     <B>length</B><A name="wStream.1.length.2(1176)"></A><A name="length.2(1176)"></A>:&lt; integerValue (* returns the length of THIS(wStream) *)
       (#
       do -1-&gt;value; INNER length
       #);
     <B>position</B><A name="wStream.1.position.2(1177)"></A><A name="position.2(1177)"></A>: (* current position of THIS(wStream) *)
       (# 
       enter setPos
       exit getPos
       #);
     <B>eos</B><A name="wStream.1.eos.2(1178)"></A><A name="eos.2(1178)"></A>:&lt; (* returns 'true' if THIS(wStream) is at end-of-wStream *)
       booleanValue;
     <B>reset</B><A name="wStream.1.reset.2(1179)"></A><A name="reset.2(1179)"></A>: (* sets 'position' to zero *)
       (#
       do 0-&gt;setPos
       exit THIS(wStream)[]
       #);
     <B>peek</B><A name="wStream.1.peek.2(1180)"></A><A name="peek.2(1180)"></A>:&lt; (* looks at the next character of THIS(wStream) *)
       (# ch: @wchar
       do INNER peek
       exit ch
       #);
     <B>get</B><A name="wStream.1.get.2(1181)"></A><A name="get.2(1181)"></A>:&lt; (* reads a character from THIS(wStream) *)
       (# ch: @wchar
       do INNER get
       exit ch
       #);
     <B>getNonBlank</B><A name="wStream.1.getNonBlank.2(1182)"></A><A name="getNonBlank.2(1182)"></A>: 
       (* Reads first non-whitespace character from THIS(wStream).
        * If called at end-of-wStream the character 'ascii.fs' is
        * returned
        *)
       (# ch: @wchar;
          skipblanks: @scanWhiteSpace;
          testEOS: @EOS;
          getCh: @get;
       ...
       exit ch
       #);
     <B>getint</B><A name="wStream.1.getint.2(1183)"></A><A name="getint.2(1183)"></A>: integerValue
       (* Reads an integer: skips whitespace characters and
        * returns the following digits. 
        * 
        * See numberio.bet for more numerical output operations
        *)
       (# syntaxError:&lt; wStreamException
            (# 
            do 'getint: syntax error - looking at: "'-&gt;msg.append;
               peek-&gt;msg.put; '"'-&gt;msg.putline; INNER syntaxError
            #);
          geti: @... 
       do geti; INNER getint
       #);
     <B>getAtom</B><A name="wStream.1.getAtom.2(1184)"></A><A name="getAtom.2(1184)"></A>:&lt;
       (* Returns the next atom (i.e. sequence of non-white
        * characters - skipping leading blanks)
        *)
       (# txt: ^wtext;
       do &amp;wText[]-&gt;txt[]; INNER getAtom;
       exit txt[]
       #);
     <B>getline</B><A name="wStream.1.getline.2(1185)"></A><A name="getline.2(1185)"></A>:&lt;
       (* Reads a sequence of characters until nl-character
        * appears and returns the characters read.
        *)
       (# txt: ^wText;
       do &amp;wText[]-&gt;txt[]; INNER getline
       exit txt[]
       #);
     <B>asInt</B><A name="wStream.1.asInt.2(1186)"></A><A name="asInt.2(1186)"></A>:
       (* converts THIS(wText) to an integer value, ignoring
        * leading and trailing whitespace.  See numberio.bet for
        * more numerical conversion operations.
        *)
       (# i: @integer;
          syntaxError:&lt; wStreamException
            (# peekCh: @wchar
            enter peekCh
            do 'asInt: syntax error - looking at: "'-&gt;msg.append;
               peekCh-&gt;msg.put; '"'-&gt;msg.put;
               INNER syntaxError
            #)
       ...
       exit i
       #);
     <B>put</B><A name="wStream.1.put.2(1187)"></A><A name="put.2(1187)"></A>:&lt; (* writes a character to THIS(wStream) *)
       (# ch: @wchar
       enter ch
       do INNER put
       exit THIS(wStream)[]
       #);
     <B>newline</B><A name="wStream.1.newline.2(1188)"></A><A name="newline.2(1188)"></A>: (* writes the nl-character *) 
       (#
       do ascii.newline-&gt;put
       exit THIS(wStream)[]
       #);
     <B>putint</B><A name="wStream.1.putint.2(1189)"></A><A name="putint.2(1189)"></A>: 
       (* Writes an integer to THIS(wStream); The format may be
        * controlled by the 'signed', 'blankSign', 'width',
        * 'adjustLeft' and 'zeroPadding' variable attributes.
        * 'width' is extended if it is too small.  Examples:
        * '10-&gt;putint' yields: '10'; '10*pi-&gt;putint(# do 10-&gt;width;
        * true-&gt;adjustLeft #)' yields: '10 '; and '10-&gt;putint(# do * 10-&gt;width; true-&gt;zeroPadding #)' yields: '0000000010'.
        * 
        * See numberio.bet for more numerical output operations
        *)
       (# n: @integer;
          signed: @boolean
            (* If integer is positive, a '+' will always be
             * displayed
             *);
          blankSign: @boolean 
            (* If integer is positive, a ' ' space is displayed as
             * the sign.  Ignored if 'signed=true'
             *);
          width: @integer
            (* Minimum width *);
          adjustLeft: @boolean
            (* Specifies if the number is to be aligned left or
             * right, if padding of spaces is necessary to fill up
             * the specified width.
             *);
          zeroPadding: @boolean
            (* width is padded with leading zero instead of
             * spaces.  Ignored if 'adjustLeft=true'
             *);
          format:&lt; (# do INNER format #);
          puti: @...
       enter n
       do 1-&gt;width; format; INNER putint; puti
       exit THIS(wStream)[]
       #);
     <B>putText</B><A name="wStream.1.putText.2(1190)"></A><A name="putText.2(1190)"></A>:&lt; (* Writes a wText to THIS(wStream). *)
       (# txt: ^wText
       enter txt[]
       do (if txt[]&lt;&gt;NONE then INNER puttext if)
       exit THIS(wStream)[]
       #);
     <B>putline</B><A name="wStream.1.putline.2(1191)"></A><A name="putline.2(1191)"></A>: 
       (* 'puttext' followed by 'newline' *)
       (# T: ^wText; putT: @puttext; newL: @newline
       enter T[]
       do INNER putline; T[]-&gt;putT; newL
       exit THIS(wStream)[]
       #);
     <B>scan</B><A name="wStream.1.scan.2(1192)"></A><A name="scan.2(1192)"></A>: 
       (* Scan chars from current position in THIS(wStream) while
        * '(ch-&gt;while)=true'; perform INNER for each char being
        * scanned
        *)
       (# while:&lt;
            (# ch: @wchar; value: @boolean
            enter ch
            do true-&gt;value; INNER while
            exit value
            #);
          ch: @wchar;
          whilecondition: @while;
          testEOS: @EOS;
          getPeek: @peek;
          getCh: @get;
       ...
       exit THIS(wStream)[]
       #);
     <B>scanWhiteSpace</B><A name="wStream.1.scanWhiteSpace.2(1193)"></A><A name="scanWhiteSpace.2(1193)"></A>: scan 
       (* Scan whitespace characters *)
       (# while::&lt; (# do ch-&gt;ascii.isWhiteSpace-&gt;value #);
       do INNER scanWhiteSpace
       exit THIS(wStream)[]
       #);
     <B>scanAtom</B><A name="wStream.1.scanAtom.2(1194)"></A><A name="scanAtom.2(1194)"></A>: 
       (* Scan until first non-whitespace char.  Scan the next
        * sequence of non-whitespace chars.  Stop at first
        * whitespace char.  For each non-whitespace char an INNER
        * is performed. Usage: 'scanAtom(# do ch-&gt;&lt;destination&gt; #)'
        *)
       (# ch: @wchar;
       ...
       exit THIS(wStream)[]
       #);
     <B>scanToNl</B><A name="wStream.1.scanToNl.2(1195)"></A><A name="scanToNl.2(1195)"></A>: 
       (* Scan all chars in current line including newline char *)
       (# ch: @wchar; getCh: @get;
       ...
       exit THIS(wStream)[]
       #);
     <B>wStreamException</B><A name="wStream.1.wStreamException.2(1196)"></A><A name="wStreamException.2(1196)"></A>: exception
       (# do INNER wStreamException #);
     <B>EOSerror</B><A name="wStream.1.EOSerror.2(1197)"></A><A name="EOSerror.2(1197)"></A>:&lt; wStreamException
       (* Raised from 'get' and 'peek' when attempted to read past
        * the end of the wStream.
        *)
       (# 
       do 'Attempt to read past end-of-wStream'-&gt;msg.putline; 
          INNER EOSerror
       #);
     <B>otherError</B><A name="wStream.1.otherError.2(1198)"></A><A name="otherError.2(1198)"></A>:&lt; wStreamException
       (* Raised when some other kind of wStream error apart from
        * the one mentioned above occurs.
        *);
     <B>getPos</B><A name="wStream.1.getPos.2(1199)"></A><A name="getPos.2(1199)"></A>:&lt; (* returns current position of THIS(wStream) *)
       integerValue;
     <B>setPos</B><A name="wStream.1.setPos.2(1200)"></A><A name="setPos.2(1200)"></A>:&lt; (* sets current position in THIS(wStream) to 'p' *)
       (# p: @integer
       enter p
       do INNER setPos
       exit THIS(wStream)[]
       #)
  #); (* pattern wStream *)

(*****  wText pattern **********************************************)
<B>wText</B><A name="wText.1(1201)"></A>: wStream
  (* A wText is a sequence of characters.  Let 'T: @wText'. The
   * range of 'T' is '[1,T.length]'.  A wText can be initialized by
   * executing 'T.clear' or by assigning it another (initialized)
   * wText.  A wText-constant has the form 'foo'.  The 'wText' pattern
   * is primarily intended for small wTexts but there is no upper
   * limit in the size. However, most of the operations becomes
   * less efficient with larger wTexts.
   *)
  (# &lt;&lt;SLOT wTextLib: attributes&gt;&gt;;
     <B>length</B><A name="wText.1.length.2(1202)"></A><A name="length.2(1202)"></A>::&lt; (* Returns the length of THIS(wText) *) 
       (# do lgth-&gt;value; INNER length #);
     <B>eos</B><A name="wText.1.eos.2(1203)"></A><A name="eos.2(1203)"></A>::&lt;(# ... #);
     <B>empty</B><A name="wText.1.empty.2(1204)"></A><A name="empty.2(1204)"></A>: 
       (# exit (lgth = 0) #);
     <B>clear</B><A name="wText.1.clear.2(1205)"></A><A name="clear.2(1205)"></A>: (* Sets the length and position of THIS(wText) to zero *)
       (#
       do 0-&gt;pos-&gt;lgth
       exit THIS(wText)[]
       #);
     <B>equal</B><A name="wText.1.equal.2(1206)"></A><A name="equal.2(1206)"></A>: booleanValue
       (* Tests if THIS(wText) is equal to the entered wText.  If
        * 'NCS' is further bound to 'trueObject', the comparison
        * will be done Non Case Sensitive.
        *)
       (# txt: ^wText;
          NCS:&lt; booleanObject
       enter txt[]
       ...
       #);
     <B>equalNCS</B><A name="wText.1.equalNCS.2(1207)"></A><A name="equalNCS.2(1207)"></A>: equal
       (* As 'equal', except the the comparison will be done Non
        * Case Sensitive
        *)
       (# NCS:: trueObject #);
     <B>less</B><A name="wText.1.less.2(1208)"></A><A name="less.2(1208)"></A>: booleanValue
       (* Tests whether the entered wText 'T1[1: length]' is less
        * than 'THIS(wText)[1: T1.length]'.  The lexicographical
        * ordering is used.
        *)
       (# T1: ^wText
       enter T1[]
       ...
       #);
     <B>greater</B><A name="wText.1.greater.2(1209)"></A><A name="greater.2(1209)"></A>: booleanValue
       (* Tests whether the entered wText 'T1[1: length]' is
        * greater than 'THIS(wText)[1: T1.length]'.  The
        * lexicographical ordering is used.
        *)
       (# T1: ^wText
       enter T1[]
       ...
       #);
     <B>peek</B><A name="wText.1.peek.2(1210)"></A><A name="peek.2(1210)"></A>::&lt;
       (* Returns the character at current position; does not
        * update 'position'
        *)
       (# ... #);
     <B>get</B><A name="wText.1.get.2(1211)"></A><A name="get.2(1211)"></A>::&lt;
       (* Returns the character at current position; increments
        * 'position'
        *) 
       (# ... #);
     <B>inxGet</B><A name="wText.1.inxGet.2(1212)"></A><A name="inxGet.2(1212)"></A>: wcharValue
       (* Returns the character at position 'i' *)
       (# i: @integer;
          iget: @...
       enter i
       do iget
       #);
     <B>getAtom</B><A name="wText.1.getAtom.2(1213)"></A><A name="getAtom.2(1213)"></A>::&lt;
       (* Returns the next atom (i.e. sequence of non-white
        * characters - skipping leading blanks)
        *)
       (# ... #);
     <B>getline</B><A name="wText.1.getline.2(1214)"></A><A name="getline.2(1214)"></A>::&lt;
       (* Reads a sequence of characters until nl-character
        * appears and returns the characters read.
        *)
       (# ... #);
     <B>put</B><A name="wText.1.put.2(1215)"></A><A name="put.2(1215)"></A>::&lt;
       (* writes the character 'ch' at current position in
        * THIS(wText); increments 'position'
        *) 
       (# ... #);
     <B>inxPut</B><A name="wText.1.inxPut.2(1216)"></A><A name="inxPut.2(1216)"></A>: 
       (* Replaces the character at position 'i' *)
       (# ch: @wchar;
          i: @integer;
          iput: @...
       enter (ch,i)
       do iput
       exit THIS(wText)[]
       #);
     <B>puttext</B><A name="wText.1.puttext.2(1217)"></A><A name="puttext.2(1217)"></A>::&lt;(# ... #);
     <B>append</B><A name="wText.1.append.2(1218)"></A><A name="append.2(1218)"></A>: 
       (* Appends a wText to THIS(wText); does not change 'position'
        *)
       (# T1: ^wText
       enter T1[]
       ...
       exit THIS(wText)[]
       #);
     <B>prepend</B><A name="wText.1.prepend.2(1219)"></A><A name="prepend.2(1219)"></A>: 
       (* Inserts the wText in 'T1' in front of THIS(wText); updates
        * current position to 'position+T1.length' if 'position&gt;0'
        *)
       (# T1: ^wText
       enter T1[]
       ...
       exit THIS(wText)[]
       #);
     <B>insert</B><A name="wText.1.insert.2(1220)"></A><A name="insert.2(1220)"></A>: 
       (* Inserts a wText before the character at position 'inx'.
        * Note: inx&lt;1 means inx=1; inx&gt;length means inx=length+1.
        * If 'position&gt;=inx' then 'position+T1.length-&gt;position'.
        *)
       (# T1: ^wText;
          inx: @integer
       enter (T1[],inx)
       ...
       exit THIS(wText)[]
       #);
     <B>delete</B><A name="wText.1.delete.2(1221)"></A><A name="delete.2(1221)"></A>: 
       (* Deletes THIS(wText)[i: j]; updates current position:
        *      i&lt;=position&lt;j =&gt; i-1-&gt;position
        *      j&lt;=position   =&gt; position-(j-i+1)-&gt;position
        *)
       (# i,j: @integer; 
          deleteT: @...
       enter (i,j)
       do deleteT
       exit THIS(wText)[]
       #);
     <B>makeLC</B><A name="wText.1.makeLC.2(1222)"></A><A name="makeLC.2(1222)"></A>: (* Converts all characters to lower case *)
       (# ...
       exit THIS(wText)[]
       #);
     <B>makeUC</B><A name="wText.1.makeUC.2(1223)"></A><A name="makeUC.2(1223)"></A>: 
       (* Converts all characters to upper case *)
       (# ...
       exit THIS(wText)[]
       #);
     <B>sub</B><A name="wText.1.sub.2(1224)"></A><A name="sub.2(1224)"></A>:
       (* Returns a copy of THIS(wText)[i:j].  If 'i&lt;1', 'i' is
        * adjusted to 1. If 'j&gt;length', 'j' is adjusted to
        * 'length'.  If (after adjustment) 'i&gt;j', an empty wText is
        * returned.
        *)
       (# i,j: @integer; T1: ^wText;
          subI: @...
       enter (i,j)
       do subI
       exit T1[]
       #);
     <B>copy</B><A name="wText.1.copy.2(1225)"></A><A name="copy.2(1225)"></A>: 
       (# T1: ^wText;
          copyI: @...
       do copyI
       exit T1[]
       #);
     <B>scanAll</B><A name="wText.1.scanAll.2(1226)"></A><A name="scanAll.2(1226)"></A>: 
       (* Scans all the elements in THIS(wText).  For 'ch' in '[1:
        * THIS(wText).length]' do INNER
        *)
       (# ch: @wchar
       do (for i: lgth repeat T[i]-&gt;ch; INNER scanAll for)
       exit THIS(wText)[]
       #);
     <B>find</B><A name="wText.1.find.2(1227)"></A><A name="find.2(1227)"></A>:
       (* find all occurrences of the character 'ch' in
        * THIS(wText), executing INNER for each occurrence found,
        * beginning at 'THIS(wText).position'.  'inx' will contain
        * the position of each 'ch' in THIS(wText).  If 'NCS' is
        * further bound to 'trueObject', the comparison will be
        * done Non Case Sensitive.  If 'from' is further bound, the
        * search will begin at position 'from'.
        *)
       (# ch: @wchar;
          inx: @integer;
          NCS:&lt; booleanObject;
          from:&lt; integerObject(# do pos-&gt;value; INNER from #)
       enter ch
       ...
       exit THIS(wText)[]
       #);
     <B>findAll</B><A name="wText.1.findAll.2(1228)"></A><A name="findAll.2(1228)"></A>: find
       (* As 'find', except that the entire wText will be searched.
        * Replaces 'findCh' in previous versions of betaenv (v1.4
        * and earlier)
        *)
       (# from:: (# do 0-&gt;value #)
       do INNER findAll
       #);
     <B>findwText</B><A name="wText.1.findwText.2(1229)"></A><A name="findwText.2(1229)"></A>:
       (* find all occurrences of the 'txt' in THIS(wText),
        * executing INNER for each occurrence found, beginning at
        * 'THIS(wText).position'.  'inx' will contain the position
        * of the first character of each occurrence found
        * THIS(wText).  If 'NCS' is further bound to 'trueObject',
        * the comparison will be done Non Case Sensitive.  If
        * 'from' is further bound, the search will begin at
        * position 'from'.
        *)
       (# txt: ^wText;
          inx: @integer;
          NCS:&lt; booleanObject;
          from:&lt; integerObject(# do pos-&gt;value; INNER from #)
       enter txt[]
       ...
       exit THIS(wText)[]
       #);
     <B>findwTextAll</B><A name="wText.1.findwTextAll.2(1230)"></A><A name="findwTextAll.2(1230)"></A>: findwText
       (* As 'findwText', except that the entire wText will be
        * searched
        *)
       (# from:: (# do 0-&gt;value #)
       do INNER findwTextAll
       #);
     <B>extend</B><A name="wText.1.extend.2(1231)"></A><A name="extend.2(1231)"></A>: 
       (* Extend THIS(wText) with 'L' (undefined) chars. Notice
        * that it is only the representation of the THIS(wText),
        * that is extended, the 'length' and 'position' are not
        * changed.
        *)
       (# L: @integer
       enter L do L-&gt;T.extend
       exit THIS(wText)[]
       #);
     <B>indexError</B><A name="wText.1.indexError.2(1232)"></A><A name="indexError.2(1232)"></A>:&lt; wStreamException
       (* Raised from 'Check' when the index goes outside the
        * range of the wText. Message: "Index error in wText!".
        *)
       (# inx: @integer 
       enter inx
       ...
       #);
     <B>EOSerror</B><A name="wText.1.EOSerror.2(1233)"></A><A name="EOSerror.2(1233)"></A>::&lt;
       (* Raised from 'get' and 'peek' when the end of the wStream is
        * passed.
        *) 
       (# ... #);
     <B>otherError</B><A name="wText.1.otherError.2(1234)"></A><A name="otherError.2(1234)"></A>::&lt;
       (* Raised when an error other than the Index-/EOSerror
        * occurs.
        *) 
       (# ... #);
     <B>setPos</B><A name="wText.1.setPos.2(1235)"></A><A name="setPos.2(1235)"></A>::&lt;(# ... #);
     <B>getPos</B><A name="wText.1.getPos.2(1236)"></A><A name="getPos.2(1236)"></A>::&lt;(# do pos-&gt;value; INNER getPos #);
     (* Private attributes: !!OBS!! The 3 attributes 'T', 'lgth'
      * and 'pos' declared below MUST be the first data items
      * declared in 'wStream' and 'wText' since their addresses are
      * hardcoded into the compiler.
      *)
     <B>T</B><A name="wText.1.T.2(1237)"></A><A name="T.2(1237)"></A>: [16] @wchar;
     <B>lgth</B><A name="wText.1.lgth.2(1238)"></A><A name="lgth.2(1238)"></A>,<B>pos</B><A name="wText.1.pos.2(1239)"></A><A name="pos.2(1239)"></A>: (* 16 is default size *) @integer;
     <B>setT</B><A name="wText.1.setT.2(1240)"></A><A name="setT.2(1240)"></A>: (# enter T do T.range-&gt;lgth-&gt;pos #);
     <B>setAscii</B><A name="wText.1.setAscii.2(1241)"></A><A name="setAscii.2(1241)"></A>:
       (# t: ^ text
       enter T[]
       do T.scanAll(#do ch -&gt; put #)
       #);
     <B>asAscii</B><A name="wText.1.asAscii.2(1242)"></A><A name="asAscii.2(1242)"></A>:
       (# T: @text
       do scanAll(#do ch -&gt; T.put #)
       exit T[]
       #)
  enter setT
  exit T[1<A name="wText.1.1.2(1243)"></A><A name="1.2(1243)"></A>: lgth]
  #) (* Pattern wText *); 

<B>ascii2wText</B><A name="ascii2wText.1(1244)"></A>:
  (# <B>T1</B><A name="ascii2wText.1.T1.2(1245)"></A><A name="T1.2(1245)"></A>: ^text; <B>T2</B><A name="ascii2wText.1.T2.2(1246)"></A><A name="T2.2(1246)"></A>: @wText
  enter T1[]
  do T1.scanAll(#do ch -&gt; T2.put #);  
  exit T2[]
  #);
---textLib:attributes---
<B>aswText</B><A name="aswText.1(1247)"></A>:
  (# <B>UT</B><A name="aswText.1.UT.2(1248)"></A><A name="UT.2(1248)"></A>: @wText
  do scanAll(#do ch -&gt; UT.put #)
  exit UT[]
  #)
</PRE>
<TABLE BORDER=0 ALIGN=RIGHT>
<TR>
<TD>
<A HREF="http://validator.w3.org/check/referer">
<IMG BORDER=0 SRC="../../images/vh40.gif" ALT="Valid HTML 4.01!" HEIGHT=31 WIDTH=88>
</A>
</TD>
</TR>
</TABLE>
<BR CLEAR=right>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Wtext Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
