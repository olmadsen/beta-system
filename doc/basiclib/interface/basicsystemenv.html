<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Basicsystemenv Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="systemenv.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="directory.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Basicsystemenv Interface</H1>
<PRE CLASS=interface>
ORIGIN 'betaenv';
LIB_DEF 'basicsystemenv' '../lib';
BODY 'private/basicsystemenvbody'
---LIB:attributes---
(*
 * COPYRIGHT 
 *       Copyright Mjolner Informatics, 1992-96 
 *       All rights reserved.
 * 
 * This fragment contains abstract superpatterns for describing the
 * BETA concepts of concurrent systems.
 * 
 * The basic ideas are
 * 
 *      A. Components (coroutines) can be executed concurrently
 * 
 *      B. A primitive semaphore pattern is available for
 *         syncronization.
 * 
 *      C. An abstract pattern 'Monitor' similar to the monitor
 *         proposed by Hoare and Brinch-Hansen
 * 
 *      D. An abstract pattern 'System' is defined. System defines
 *         communication between systems by means of synchronized
 *         rendezvous.  A concurreny imperative 'conc' is defined for
 *         systems.
 * 
 * The abstractions defined here are identical to the ones described
 * in chapter 12 of the BETA book except for the following points:
 * 
 * 1. The syntax of 'fork' is
 *      S[]-&gt;fork
 *    and NOT S.fork
 * 
 * 2. The syntax of 'conc' is
 *      conc(# do S1[]-&gt;start; S2[]-&gt;start; S3[]-&gt;start #)
 *    and NOT conc(# do S1.start; S2.start; S3.start #)
 * 
 * 4. THE CONCURRENCY IS SIMULATED In order to implement real
 *    concurreny, an interrupt mechanism must be implemented. This is
 *    currently NOT done. A component/system will thus keep the
 *    control until it makes an explicit or implicit SUSPEND.  An
 *    implicit SUSPEND is made when a component must wait for a
 *    semaphore, executes the pause pattern, executes the sleep
 *    pattern, or performs a blocking communication using the shellEnv
 *    distribution abstractions.  As the concurrency is simulated,
 *    there is no difference between the implementation of the alt and
 *    conc imperatives.
 * 
 * 5. A program using concurrency must have the form:
 *      systemenv(# ... do ... #)
 * 
 * 6. Concurrency and X-Windows/macenv/guienv
 *    User interface environments are usually event-driven in the
 *    sense that actions in the program are executed as a response to
 *    user input events.  To handle this, a number of separate
 *    implementations of SystemEnv exists for different user interface
 *    libraries:
 * 
 *    Use systemenv.bet as origin for programs not using event-driven
 *    user-interface libraries.
 * 
 *    Use ~beta/Xt/current/xsystemenv.bet as origin for programs using
 *    XtEnv, AwEnv or MotifEnv.
 * 
 *    Use ~beta/guienv/current/guienvsystemenv.bet as origin for
 *    programs using GUIenv (Lidskvjalv).
 * 
 *    See xsystemenv and guienvsystemenv for a description of using
 *    systemenv in conjunction with X and GUIenv programs,
 *    respectively.
 * 
 *    See ~beta/macenv/current/macsystemenv for a description of using
 *    systemenv and macenv.
 * 
 * For examples of using SystemEnv see the demo directory.
 *)
<B>getSystemEnv</B><A name="getSystemEnv.1(857)"></A>: 
  (* Returns the unique systemEnv instance running *)
  (# <B>systemEnvType</B><A name="getSystemEnv.1:systemEnvType.2(858)"></A><A name="systemEnvType.2(858)"></A>:&lt; systemEnv;
     <B>theSystemEnv</B><A name="getSystemEnv.1:theSystemEnv.2(859)"></A><A name="theSystemEnv.2(859)"></A>: ^systemEnvType;
  do (* SystemEnv## -&gt; objectPool.strucGet 
     (# init::&lt; 
          (# 
          do (failure, 
             'Program:descriptor must be a subpattern of systemEnv')
               -&gt; stop
     #)#) -&gt; theSystemEnv[]; *)
     objectPool.get
     (# type::systemEnvType;
        init::
          (# 
          do (failure,'Illegal use of systemenv. You may have precisely one systemenv instance!')
               -&gt;stop;
          #)
     #)-&gt;theSystemEnv[];
  exit theSystemEnv[]
  #);
<B>SystemEnv</B><A name="SystemEnv.1(860)"></A>: SysHead
  (# &lt;&lt;SLOT systemlib:attributes &gt;&gt;;
     <B>semaphore</B><A name="SystemEnv.1:semaphore.2(861)"></A><A name="semaphore.2(861)"></A>:
       (* P and V are the usual semaphore operations.
        * 
        * tryP returns true if the P operation succeded. Returns false
        * if a P would block the caller. In that case the P operation
        * is not performed.
        * 
        * Count returns the number of components waiting for the
        *         semaphore.
        *)
       (# P: @...;
          V: @...;
          tryP: @BooleanValue
            (# ... #);
          Count: @
            (# value: @Integer;
            ...
            exit value
            #);
          semRep: @...
       #);
     <B>fork</B><A name="SystemEnv.1:fork.2(862)"></A><A name="fork.2(862)"></A>: @
       (* S is put into the queue of scheduled systems. The calling
        * system keeps control, i.e. is not preempted.
        *)
       (# first:  @...;
          second: @...;
          S: ^|SysHead 
       enter S[] 
       do first; second; none -&gt; s[];
       #);
     <B>kill</B><A name="SystemEnv.1:kill.2(863)"></A><A name="kill.2(863)"></A>: @
       (* Kills S. If S is the active system, this is equivalent to a
        * direct suspend.
        *)
       (# S: ^|SysHead; doKill: @...
       enter S[] 
       do doKill
       #);
     <B>pause</B><A name="SystemEnv.1:pause.2(864)"></A><A name="pause.2(864)"></A>: @
       (* Moves the calling system to the end of the queue of
        * scheduled systems.
        *)
       ...;
     <B>sleep</B><A name="SystemEnv.1:sleep.2(865)"></A><A name="sleep.2(865)"></A>: @
       (* Makes the calling system sleep at least time seconds.  If
        * time is 0 or negative, sleep has no effect.
        *)
       (# time: @Real
       enter time 
       ... 
       #);
     <B>sleepUntil</B><A name="SystemEnv.1:sleepUntil.2(866)"></A><A name="sleepUntil.2(866)"></A>:
       (* Makes the calling system sleep until at least time.  If
        * time is less than the current time, sleepUntil has no effect.
        *)
       (# time: @Real
       enter time 
       ... 
       #);
     <B>timeStamp</B><A name="SystemEnv.1:timeStamp.2(867)"></A><A name="timeStamp.2(867)"></A>:
       (# value: @Real;
       ...
       exit value
       #);
     <B>Monitor</B><A name="SystemEnv.1:Monitor.2(868)"></A><A name="Monitor.2(868)"></A>:
       (# (* idx+ *)
          <B>Condition</B><A name="SystemEnv.1:Monitor.2:Condition.3(869)"></A><A name="Condition.3(869)"></A>:
            (# q: @Semaphore;
               Wait: ...;
               Signal: ...;
            #);
          <B>Wait</B><A name="SystemEnv.1:Monitor.2:Wait.3(870)"></A><A name="Wait.3(870)"></A>:
            (# cond: @boolean 
            do INNER;
               (if not cond then 
                   return; (* exit monitor *)
                   pause;
                   mutex.P; (* reentry of monitor *)
                   restart Wait
               if)
            #);
          Entry: (# do mutex.P; INNER; return #);
          init:&lt; (# do INNER; mutex.V; #);
          (* private:
           * 
           * mutex controls entry to the Monitor.  urgent delays a
           * signalling process.
           * 
           * return is executed by processes leaving the monitor.
           * Reactivates possible processes waiting for entry: delayed
           * signalling processes (urgent) have first priority
           *)
          mutex: @semaphore;
          urgent: @semaphore; 
          return: @...;
       #);
     <B>System</B><A name="SystemEnv.1:System.2(871)"></A><A name="System.2(871)"></A>: SysHead
       (# <B>Port</B><A name="SystemEnv.1:System.2:Port.3(872)"></A><A name="Port.3(872)"></A>:
            (# mx,m: @Semaphore;
               entry: (# do m.P; INNER; mx.V #);
               accept: (# do m.V; mx.P #)
            #);
          <B>RestrictedPort</B><A name="SystemEnv.1:System.2:RestrictedPort.3(873)"></A><A name="RestrictedPort.3(873)"></A>:
            (# mx, am: @Semaphore;
               delayed: @...;
               accept:&lt;(# ... #);
               acceptable:&lt;(# OK: @Boolean; s: ^|sysHead enter s[] do INNER exit OK #);
               restrictedEntry:
                 (# ... #);
            #);
          <B>ObjectPort</B><A name="SystemEnv.1:System.2:ObjectPort.3(874)"></A><A name="ObjectPort.3(874)"></A>: RestrictedPort
            (# accept::&lt; (# enter sender[] do none-&gt;sender[] #);
               acceptable::&lt; (# ... #);
               entry: RestrictedEntry (# do INNER #);
               sender: ^|sysHead
            #);
          <B>QualifiedPort</B><A name="SystemEnv.1:System.2:QualifiedPort.3(875)"></A><A name="QualifiedPort.3(875)"></A>: RestrictedPort
            (# accept::&lt; (# enter sender## do none-&gt;sender## #);
               acceptable::&lt; (# ... #);
               entry: RestrictedEntry(# do INNER #);
               sender: ##sysHead
            #);
          <B>conc</B><A name="SystemEnv.1:System.2:conc.3(876)"></A><A name="conc.3(876)"></A>:
            (# start:
                 (# s: ^|system
                 enter s[]
                 ...
                 #);
               concPriv: @...
            do INNER; ...; 
            #);
          <B>alt</B><A name="SystemEnv.1:System.2:alt.3(877)"></A><A name="alt.3(877)"></A>: conc (# do INNER #);
          <B>onKilled</B><A name="SystemEnv.1:System.2:onKilled.3(878)"></A><A name="onKilled.3(878)"></A>:&lt;
            (* Called before this system terminates. *)
            (# 
            do (if caller[]&lt;&gt;NONE then (* not the outermost system *)
                   caller.dec; NONE -&gt; caller[]
               if);
               INNER;
            #);
          <B>caller</B><A name="SystemEnv.1:System.2:caller.3(879)"></A><A name="caller.3(879)"></A>: ^protectedInt;
       do INNER;
       #);
     <B>deadLocked</B><A name="SystemEnv.1:deadLocked.2(880)"></A><A name="deadLocked.2(880)"></A>:&lt; Exception
       (* This exception is called when all coroutines are blocked
        * and none are waiting for I/O.
        *)
       (# 
       do INNER;
          (if not continue then
              '<B>BasicSystemEnv</B><A name="SystemEnv.1:deadLocked.2:BasicSystemEnv.3(881)"></A><A name="BasicSystemEnv.3(881)"></A>: All coroutines blocked on semaphores.'
                -&gt; msg.append;
          if);
       #);
     <B>conc</B><A name="SystemEnv.1:conc.2(882)"></A><A name="conc.2(882)"></A>:
       (# <B>start</B><A name="SystemEnv.1:conc.2:start.3(883)"></A><A name="start.3(883)"></A>:
            (# s: ^|system
            enter s[]
            ...
            #);
          <B>concPriv</B><A name="SystemEnv.1:conc.2:concPriv.3(884)"></A><A name="concPriv.3(884)"></A>: @...
       do INNER; ...; 
       #);
     <B>alt</B><A name="SystemEnv.1:alt.2(885)"></A><A name="alt.2(885)"></A>: 
       (* Same as conc as a consequence of non-preemtive scheduling.
        *)
       conc (# #);
     
     (* ATTRIBUTES FOR EVENT-DRIVEN WINDOWING ENVIRONMENTS
      * 
      * These attributes are only used when combining SystemEnv with
      * an event-driven windowing environment. This demands an
      * alternative implementation than the standard SystemEnv
      * implementation. See the file: xsystemenv.bet
      *)
     <B>windowEnvType</B><A name="SystemEnv.1:windowEnvType.2(886)"></A><A name="windowEnvType.2(886)"></A>:&lt; Object;
     <B>theWindowEnv</B><A name="SystemEnv.1:theWindowEnv.2(887)"></A><A name="theWindowEnv.2(887)"></A>: ^windowEnvType;
     <B>setWindowEnv</B><A name="SystemEnv.1:setWindowEnv.2(888)"></A><A name="setWindowEnv.2(888)"></A>:&lt; Object;
     
     (* PRIVATE
      * 
      * Everything below is in principle private implementation stuff.
      *)
     <B>private</B><A name="SystemEnv.1:private.2(889)"></A><A name="private.2(889)"></A>: @ ...;
     <B>BasicScheduler</B><A name="SystemEnv.1:BasicScheduler.2(890)"></A><A name="BasicScheduler.2(890)"></A>: ...; 
     <B>theActive</B><A name="SystemEnv.1:theActive.2(891)"></A><A name="theActive.2(891)"></A>: ^|sysHead;
     <B>ProtectedInt</B><A name="SystemEnv.1:ProtectedInt.2(892)"></A><A name="ProtectedInt.2(892)"></A>: IntegerObject
       (* Used in implementation of conc. *)
       (# <B>mutex</B><A name="SystemEnv.1:ProtectedInt.2:mutex.3(893)"></A><A name="mutex.3(893)"></A>: @semaphore;
          <B>atZero</B><A name="SystemEnv.1:ProtectedInt.2:atZero.3(894)"></A><A name="atZero.3(894)"></A>: @semaphore;
          <B>dec</B><A name="SystemEnv.1:ProtectedInt.2:dec.3(895)"></A><A name="dec.3(895)"></A>:
            (# 
            do mutex.P; (if (value-1-&gt;value)=0 then atZero.V if); mutex.V;
            #);
          <B>waitForZero</B><A name="SystemEnv.1:ProtectedInt.2:waitForZero.3(896)"></A><A name="waitForZero.3(896)"></A>: (# do atZero.P #);
          <B>init</B><A name="SystemEnv.1:ProtectedInt.2:init.3(897)"></A><A name="init.3(897)"></A>: (# enter value do mutex.V #);
       #);
     <B>initBeforeScheduler</B><A name="SystemEnv.1:initBeforeScheduler.2(898)"></A><A name="initBeforeScheduler.2(898)"></A>:&lt; 
       (* Called before the scheduler is activated and before
        * setWindowEnv and the systemenv INNER is called.
        *)
       Object;
  do ...;
     INNER
  #);

<B>cyclicElm</B><A name="cyclicElm.1(899)"></A>:
  (# <B>s</B><A name="cyclicElm.1:s.2(900)"></A><A name="s.2(900)"></A>: ^|SysHead;
     <B>next</B><A name="cyclicElm.1:next.2(901)"></A><A name="next.2(901)"></A>,<B> prev</B><A name="cyclicElm.1:prev.2(902)"></A><A name="prev.2(902)"></A>: ^cyclicElm;
     <B>due</B><A name="cyclicElm.1:due.2(903)"></A><A name="due.2(903)"></A>: @Real
       (* due is used by sleepingQueue. If zero, this element is
        * currently not in a sleepingQueue.
        *)
  #);
<B>cyclicQueue</B><A name="cyclicQueue.1(904)"></A>:
  (# <B>onDelete</B><A name="cyclicQueue.1:onDelete.2(905)"></A><A name="onDelete.2(905)"></A>:&lt; Object;
     <B>onDel</B><A name="cyclicQueue.1:onDel.2(906)"></A><A name="onDel.2(906)"></A>: @onDelete;
     <B>onInsert</B><A name="cyclicQueue.1:onInsert.2(907)"></A><A name="onInsert.2(907)"></A>:&lt; Object;
     <B>onIns</B><A name="cyclicQueue.1:onIns.2(908)"></A><A name="onIns.2(908)"></A>: @onInsert;
     <B>first</B><A name="cyclicQueue.1:first.2(909)"></A><A name="first.2(909)"></A>,<B> freeList</B><A name="cyclicQueue.1:freeList.2(910)"></A><A name="freeList.2(910)"></A>: ^cyclicElm;
     <B>insert</B><A name="cyclicQueue.1:insert.2(911)"></A><A name="insert.2(911)"></A>: @
       (# <B>s</B><A name="cyclicQueue.1:insert.2:s.3(912)"></A><A name="s.3(912)"></A>: ^|sysHead; <B>new</B><A name="cyclicQueue.1:insert.2:new.3(913)"></A><A name="new.3(913)"></A>: ^cyclicElm;
       enter s[]
       ...
       exit new[]
       #);
     <B>append</B><A name="cyclicQueue.1:append.2(914)"></A><A name="append.2(914)"></A>: @
       (# <B>elm</B><A name="cyclicQueue.1:append.2:elm.3(915)"></A><A name="elm.3(915)"></A>: ^cyclicElm;
       enter elm[]
       ...
       #);
     <B>prepend</B><A name="cyclicQueue.1:prepend.2(916)"></A><A name="prepend.2(916)"></A>: @
       (# <B>elm</B><A name="cyclicQueue.1:prepend.2:elm.3(917)"></A><A name="elm.3(917)"></A>: ^cyclicElm;
       enter elm[] 
       ...
       #);
     <B>insertBefore</B><A name="cyclicQueue.1:insertBefore.2(918)"></A><A name="insertBefore.2(918)"></A>: @
       (# <B>new</B><A name="cyclicQueue.1:insertBefore.2:new.3(919)"></A><A name="new.3(919)"></A>,<B> old</B><A name="cyclicQueue.1:insertBefore.2:old.3(920)"></A><A name="old.3(920)"></A>: ^cyclicElm;
       enter (new[],old[])
       ...
       #);
     <B>getFirst</B><A name="cyclicQueue.1:getFirst.2(921)"></A><A name="getFirst.2(921)"></A>: @
       (# <B>elm</B><A name="cyclicQueue.1:getFirst.2:elm.3(922)"></A><A name="elm.3(922)"></A>: ^cyclicElm;
       ...
       exit elm[]
       #);
     <B>delete</B><A name="cyclicQueue.1:delete.2(923)"></A><A name="delete.2(923)"></A>: @
       (# <B>elm</B><A name="cyclicQueue.1:delete.2:elm.3(924)"></A><A name="elm.3(924)"></A>: ^cyclicElm;
       enter elm[]
       ...
       exit elm[]
       #);
     <B>remove</B><A name="cyclicQueue.1:remove.2(925)"></A><A name="remove.2(925)"></A>: @ 
       (* elm should not be reused after remove. Use delete instead.
        *)
       (# <B>elm</B><A name="cyclicQueue.1:remove.2:elm.3(926)"></A><A name="elm.3(926)"></A>: ^cyclicElm; <B>s</B><A name="cyclicQueue.1:remove.2:s.3(927)"></A><A name="s.3(927)"></A>: ^|sysHead;
       enter elm[]
       ...
       exit s[]
       #);
     <B>scan</B><A name="cyclicQueue.1:scan.2(928)"></A><A name="scan.2(928)"></A>:
       (# <B>current</B><A name="cyclicQueue.1:scan.2:current.3(929)"></A><A name="current.3(929)"></A>: ^cyclicElm;
       ...
       #);
     <B>size</B><A name="cyclicQueue.1:size.2(930)"></A><A name="size.2(930)"></A>: @Integer;
  #);
<B>SysHead</B><A name="SysHead.1(931)"></A>: 
  (# <B>shstatus</B><A name="SysHead.1:shstatus.2(932)"></A><A name="shstatus.2(932)"></A>: @Integer; 
     <B>lc</B><A name="SysHead.1:lc.2(933)"></A><A name="lc.2(933)"></A>: ^Object;     (* Last errorCatcher for distribution errors. *)
     <B>ce</B><A name="SysHead.1:ce.2(934)"></A><A name="ce.2(934)"></A>: ^cyclicElm;  (* ce,q &lt;&gt; none =&gt; this(sysHead) is ce in q.  *)
     <B>q</B><A name="SysHead.1:q.2(935)"></A><A name="q.2(935)"></A>: ^cyclicQueue;
  do INNER
  #);
(* SysHead.shstatus values: *)
<B>SE_RUNNING</B><A name="SE_RUNNING.1(936)"></A>:  (# exit 1 #);  (* Current system.       *)
<B>SE_WAITING</B><A name="SE_WAITING.1(937)"></A>:  (# exit 2 #);  (* Blocked on semaphore. *)
<B>SE_READY</B><A name="SE_READY.1(938)"></A>:    (# exit 3 #);  (* Ready to run.         *)
<B>SE_SLEEPING</B><A name="SE_SLEEPING.1(939)"></A>: (# exit 4 #);  (* Sleeping.             *)
<B>SE_KILLED</B><A name="SE_KILLED.1(940)"></A>:   (# exit 5 #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE cols=3 border=0 width=100%>
<TR>
<TD width="33%" align="left"><ADDRESS>Interface Description</ADDRESS></TD>
<TD width="34%" align="center"><FONT size=-1>&COPY; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="33%" align="right"><FONT size=-1><SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></FONT></TD>
</TABLE>
<P></P>
<A HREF="systemenv.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="directory.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
