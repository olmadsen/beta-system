<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Basicsystemenv Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="systemenv.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="directory.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>Basicsystemenv Interface</H1>
<PRE CLASS=interface>
ORIGIN 'betaenv';
LIB_DEF 'basicsystemenv' '../lib';
BODY 'private/basicsystemenvbody'
---LIB:attributes---
(*
 * COPYRIGHT 
 *       Copyright Mjolner Informatics, 1992-96 
 *       All rights reserved.
 * 
 * This fragment contains abstract superpatterns for describing the
 * BETA concepts of concurrent systems.
 * 
 * The basic ideas are
 * 
 *      A. Components (coroutines) can be executed concurrently
 * 
 *      B. A primitive semaphore pattern is available for
 *         syncronization.
 * 
 *      C. An abstract pattern 'Monitor' similar to the monitor
 *         proposed by Hoare and Brinch-Hansen
 * 
 *      D. An abstract pattern 'System' is defined. System defines
 *         communication between systems by means of synchronized
 *         rendezvous.  A concurreny imperative 'conc' is defined for
 *         systems.
 * 
 * The abstractions defined here are identical to the ones described
 * in chapter 12 of the BETA book except for the following points:
 * 
 * 1. The syntax of 'fork' is
 *      S[]-&gt;fork
 *    and NOT S.fork
 * 
 * 2. The syntax of 'conc' is
 *      conc(# do S1[]-&gt;start; S2[]-&gt;start; S3[]-&gt;start #)
 *    and NOT conc(# do S1.start; S2.start; S3.start #)
 * 
 * 4. THE CONCURRENCY IS SIMULATED In order to implement real
 *    concurreny, an interrupt mechanism must be implemented. This is
 *    currently NOT done. A component/system will thus keep the
 *    control until it makes an explicit or implicit SUSPEND.  An
 *    implicit SUSPEND is made when a component must wait for a
 *    semaphore, executes the pause pattern, executes the sleep
 *    pattern, or performs a blocking communication using the shellEnv
 *    distribution abstractions.  As the concurrency is simulated,
 *    there is no difference between the implementation of the alt and
 *    conc imperatives.
 * 
 * 5. A program using concurrency must have the form:
 *      systemenv(# ... do ... #)
 * 
 * 6. Concurrency and X-Windows/macenv/guienv
 *    User interface environments are usually event-driven in the
 *    sense that actions in the program are executed as a response to
 *    user input events.  To handle this, a number of separate
 *    implementations of SystemEnv exists for different user interface
 *    libraries:
 * 
 *    Use systemenv.bet as origin for programs not using event-driven
 *    user-interface libraries.
 * 
 *    Use ~beta/Xt/current/xsystemenv.bet as origin for programs using
 *    XtEnv, AwEnv or MotifEnv.
 * 
 *    Use ~beta/guienv/current/guienvsystemenv.bet as origin for
 *    programs using GUIenv (Lidskvjalv).
 * 
 *    See xsystemenv and guienvsystemenv for a description of using
 *    systemenv in conjunction with X and GUIenv programs,
 *    respectively.
 * 
 *    See ~beta/macenv/current/macsystemenv for a description of using
 *    systemenv and macenv.
 * 
 * For examples of using SystemEnv see the demo directory.
 *)
<B>getSystemEnv</B><A name="getSystemEnv.1(733)"></A>: 
  (* Returns the unique systemEnv instance running *)
  (# <B>systemEnvType</B><A name="getSystemEnv.1:systemEnvType.2(734)"></A><A name="systemEnvType.2(734)"></A>:&lt; systemEnv;
     <B>theSystemEnv</B><A name="getSystemEnv.1:theSystemEnv.2(735)"></A><A name="theSystemEnv.2(735)"></A>: ^systemEnvType;
  do (* SystemEnv## -&gt; objectPool.strucGet 
     (# init::&lt; 
          (# 
          do (failure, 
             'Program:descriptor must be a subpattern of systemEnv')
               -&gt; stop
     #)#) -&gt; theSystemEnv[]; *)
     objectPool.get
     (# type::systemEnvType;
        init::
          (# 
          do (failure,'Illegal use of systemenv. You may have precisely one systemenv instance!')
               -&gt;stop;
          #)
     #)-&gt;theSystemEnv[];
  exit theSystemEnv[]
  #);
<B>SystemEnv</B><A name="SystemEnv.1(736)"></A>: SysHead
  (# &lt;&lt;SLOT systemlib:attributes &gt;&gt;;
     <B>semaphore</B><A name="SystemEnv.1:semaphore.2(737)"></A><A name="semaphore.2(737)"></A>:
       (* P and V are the usual semaphore operations.
        * 
        * tryP returns true if the P operation succeded. Returns false
        * if a P would block the caller. In that case the P operation
        * is not performed.
        * 
        * Count returns the number of components waiting for the
        *         semaphore.
        *)
       (# P: @...;
          V: @...;
          tryP: @BooleanValue
            (# ... #);
          Count: @
            (# value: @Integer;
            ...
            exit value
            #);
          semRep: @...
       #);
     <B>fork</B><A name="SystemEnv.1:fork.2(738)"></A><A name="fork.2(738)"></A>: @
       (* S is put into the queue of scheduled systems. The calling
        * system keeps control, i.e. is not preempted.
        *)
       (# first:  @...;
          second: @...;
          S: ^|SysHead 
       enter S[] 
       do first; second; none -&gt; s[];
       #);
     <B>kill</B><A name="SystemEnv.1:kill.2(739)"></A><A name="kill.2(739)"></A>: @
       (* Kills S. If S is the active system, this is equivalent to a
        * direct suspend.
        *)
       (# S: ^|SysHead; doKill: @...
       enter S[] 
       do doKill
       #);
     <B>pause</B><A name="SystemEnv.1:pause.2(740)"></A><A name="pause.2(740)"></A>: @
       (* Moves the calling system to the end of the queue of
        * scheduled systems.
        *)
       ...;
     <B>sleep</B><A name="SystemEnv.1:sleep.2(741)"></A><A name="sleep.2(741)"></A>: @
       (* Makes the calling system sleep at least time seconds.  If
        * time is 0 or negative, sleep has no effect.
        *)
       (# time: @Real
       enter time 
       ... 
       #);
     <B>sleepUntil</B><A name="SystemEnv.1:sleepUntil.2(742)"></A><A name="sleepUntil.2(742)"></A>:
       (* Makes the calling system sleep until at least time.  If
        * time is less than the current time, sleepUntil has no effect.
        *)
       (# time: @Real
       enter time 
       ... 
       #);
     <B>timeStamp</B><A name="SystemEnv.1:timeStamp.2(743)"></A><A name="timeStamp.2(743)"></A>:
       (# value: @Real;
       ...
       exit value
       #);
     <B>Monitor</B><A name="SystemEnv.1:Monitor.2(744)"></A><A name="Monitor.2(744)"></A>:
       (# (* idx+ *)
          <B>Condition</B><A name="SystemEnv.1:Monitor.2:Condition.3(745)"></A><A name="Condition.3(745)"></A>:
            (# q: @Semaphore;
               Wait: ...;
               Signal: ...;
            #);
          <B>Wait</B><A name="SystemEnv.1:Monitor.2:Wait.3(746)"></A><A name="Wait.3(746)"></A>:
            (# cond: @boolean 
            do INNER;
               (if not cond then 
                   return; (* exit monitor *)
                   pause;
                   mutex.P; (* reentry of monitor *)
                   restart Wait
               if)
            #);
          Entry: (# do mutex.P; INNER; return #);
          init:&lt; (# do INNER; mutex.V; #);
          (* private:
           * 
           * mutex controls entry to the Monitor.  urgent delays a
           * signalling process.
           * 
           * return is executed by processes leaving the monitor.
           * Reactivates possible processes waiting for entry: delayed
           * signalling processes (urgent) have first priority
           *)
          mutex: @semaphore;
          urgent: @semaphore; 
          return: @...;
       #);
     <B>System</B><A name="SystemEnv.1:System.2(747)"></A><A name="System.2(747)"></A>: SysHead
       (# <B>Port</B><A name="SystemEnv.1:System.2:Port.3(748)"></A><A name="Port.3(748)"></A>:
            (# mx,m: @Semaphore;
               entry: (# do m.P; INNER; mx.V #);
               accept: (# do m.V; mx.P #)
            #);
          <B>RestrictedPort</B><A name="SystemEnv.1:System.2:RestrictedPort.3(749)"></A><A name="RestrictedPort.3(749)"></A>:
            (# mx, am: @Semaphore;
               delayed: @...;
               accept:&lt;(# ... #);
               acceptable:&lt;(# OK: @Boolean; s: ^|sysHead enter s[] do INNER exit OK #);
               restrictedEntry:
                 (# ... #);
            #);
          <B>ObjectPort</B><A name="SystemEnv.1:System.2:ObjectPort.3(750)"></A><A name="ObjectPort.3(750)"></A>: RestrictedPort
            (# accept::&lt; (# enter sender[] do none-&gt;sender[] #);
               acceptable::&lt; (# ... #);
               entry: RestrictedEntry (# do INNER #);
               sender: ^|sysHead
            #);
          <B>QualifiedPort</B><A name="SystemEnv.1:System.2:QualifiedPort.3(751)"></A><A name="QualifiedPort.3(751)"></A>: RestrictedPort
            (# accept::&lt; (# enter sender## do none-&gt;sender## #);
               acceptable::&lt; (# ... #);
               entry: RestrictedEntry(# do INNER #);
               sender: ##sysHead
            #);
          <B>conc</B><A name="SystemEnv.1:System.2:conc.3(752)"></A><A name="conc.3(752)"></A>:
            (# start:
                 (# s: ^|system
                 enter s[]
                 ...
                 #);
               concPriv: @...
            do INNER; ...; 
            #);
          <B>alt</B><A name="SystemEnv.1:System.2:alt.3(753)"></A><A name="alt.3(753)"></A>: conc (# do INNER #);
          <B>onKilled</B><A name="SystemEnv.1:System.2:onKilled.3(754)"></A><A name="onKilled.3(754)"></A>:&lt;
            (* Called before this system terminates. *)
            (# 
            do (if caller[]&lt;&gt;NONE then (* not the outermost system *)
                   caller.dec; NONE -&gt; caller[]
               if);
               INNER;
            #);
          <B>caller</B><A name="SystemEnv.1:System.2:caller.3(755)"></A><A name="caller.3(755)"></A>: ^protectedInt;
       do INNER;
       #);
     <B>deadLocked</B><A name="SystemEnv.1:deadLocked.2(756)"></A><A name="deadLocked.2(756)"></A>:&lt; Exception
       (* This exception is called when all coroutines are blocked
        * and none are waiting for I/O.
        *)
       (# 
       do INNER;
          (if not continue then
              '<B>BasicSystemEnv</B><A name="SystemEnv.1:deadLocked.2:BasicSystemEnv.3(757)"></A><A name="BasicSystemEnv.3(757)"></A>: All coroutines blocked on semaphores.'
                -&gt; msg.append;
          if);
       #);
     <B>conc</B><A name="SystemEnv.1:conc.2(758)"></A><A name="conc.2(758)"></A>:
       (# <B>start</B><A name="SystemEnv.1:conc.2:start.3(759)"></A><A name="start.3(759)"></A>:
            (# s: ^|system
            enter s[]
            ...
            #);
          <B>concPriv</B><A name="SystemEnv.1:conc.2:concPriv.3(760)"></A><A name="concPriv.3(760)"></A>: @...
       do INNER; ...; 
       #);
     <B>alt</B><A name="SystemEnv.1:alt.2(761)"></A><A name="alt.2(761)"></A>: 
       (* Same as conc as a consequence of non-preemtive scheduling.
        *)
       conc (# #);
     
     (* ATTRIBUTES FOR EVENT-DRIVEN WINDOWING ENVIRONMENTS
      * 
      * These attributes are only used when combining SystemEnv with
      * an event-driven windowing environment. This demands an
      * alternative implementation than the standard SystemEnv
      * implementation. See the file: xsystemenv.bet
      *)
     <B>windowEnvType</B><A name="SystemEnv.1:windowEnvType.2(762)"></A><A name="windowEnvType.2(762)"></A>:&lt; Object;
     <B>theWindowEnv</B><A name="SystemEnv.1:theWindowEnv.2(763)"></A><A name="theWindowEnv.2(763)"></A>: ^windowEnvType;
     <B>setWindowEnv</B><A name="SystemEnv.1:setWindowEnv.2(764)"></A><A name="setWindowEnv.2(764)"></A>:&lt; Object;
     
     (* PRIVATE
      * 
      * Everything below is in principle private implementation stuff.
      *)
     <B>private</B><A name="SystemEnv.1:private.2(765)"></A><A name="private.2(765)"></A>: @ ...;
     <B>BasicScheduler</B><A name="SystemEnv.1:BasicScheduler.2(766)"></A><A name="BasicScheduler.2(766)"></A>: ...; 
     <B>theActive</B><A name="SystemEnv.1:theActive.2(767)"></A><A name="theActive.2(767)"></A>: ^|sysHead;
     <B>ProtectedInt</B><A name="SystemEnv.1:ProtectedInt.2(768)"></A><A name="ProtectedInt.2(768)"></A>: IntegerObject
       (* Used in implementation of conc. *)
       (# <B>mutex</B><A name="SystemEnv.1:ProtectedInt.2:mutex.3(769)"></A><A name="mutex.3(769)"></A>: @semaphore;
          <B>atZero</B><A name="SystemEnv.1:ProtectedInt.2:atZero.3(770)"></A><A name="atZero.3(770)"></A>: @semaphore;
          <B>dec</B><A name="SystemEnv.1:ProtectedInt.2:dec.3(771)"></A><A name="dec.3(771)"></A>:
            (# 
            do mutex.P; (if (value-1-&gt;value)=0 then atZero.V if); mutex.V;
            #);
          <B>waitForZero</B><A name="SystemEnv.1:ProtectedInt.2:waitForZero.3(772)"></A><A name="waitForZero.3(772)"></A>: (# do atZero.P #);
          <B>init</B><A name="SystemEnv.1:ProtectedInt.2:init.3(773)"></A><A name="init.3(773)"></A>: (# enter value do mutex.V #);
       #);
     <B>initBeforeScheduler</B><A name="SystemEnv.1:initBeforeScheduler.2(774)"></A><A name="initBeforeScheduler.2(774)"></A>:&lt; 
       (* Called before the scheduler is activated and before
        * setWindowEnv and the systemenv INNER is called.
        *)
       Object;
  do ...;
     INNER
  #);

<B>cyclicElm</B><A name="cyclicElm.1(775)"></A>:
  (# <B>s</B><A name="cyclicElm.1:s.2(776)"></A><A name="s.2(776)"></A>: ^|SysHead;
     <B>next</B><A name="cyclicElm.1:next.2(777)"></A><A name="next.2(777)"></A>,<B> prev</B><A name="cyclicElm.1:prev.2(778)"></A><A name="prev.2(778)"></A>: ^cyclicElm;
     <B>due</B><A name="cyclicElm.1:due.2(779)"></A><A name="due.2(779)"></A>: @Real
       (* due is used by sleepingQueue. If zero, this element is
        * currently not in a sleepingQueue.
        *)
  #);
<B>cyclicQueue</B><A name="cyclicQueue.1(780)"></A>:
  (# <B>onDelete</B><A name="cyclicQueue.1:onDelete.2(781)"></A><A name="onDelete.2(781)"></A>:&lt; Object;
     <B>onDel</B><A name="cyclicQueue.1:onDel.2(782)"></A><A name="onDel.2(782)"></A>: @onDelete;
     <B>onInsert</B><A name="cyclicQueue.1:onInsert.2(783)"></A><A name="onInsert.2(783)"></A>:&lt; Object;
     <B>onIns</B><A name="cyclicQueue.1:onIns.2(784)"></A><A name="onIns.2(784)"></A>: @onInsert;
     <B>first</B><A name="cyclicQueue.1:first.2(785)"></A><A name="first.2(785)"></A>,<B> freeList</B><A name="cyclicQueue.1:freeList.2(786)"></A><A name="freeList.2(786)"></A>: ^cyclicElm;
     <B>insert</B><A name="cyclicQueue.1:insert.2(787)"></A><A name="insert.2(787)"></A>: @
       (# <B>s</B><A name="cyclicQueue.1:insert.2:s.3(788)"></A><A name="s.3(788)"></A>: ^|sysHead; <B>new</B><A name="cyclicQueue.1:insert.2:new.3(789)"></A><A name="new.3(789)"></A>: ^cyclicElm;
       enter s[]
       ...
       exit new[]
       #);
     <B>append</B><A name="cyclicQueue.1:append.2(790)"></A><A name="append.2(790)"></A>: @
       (# <B>elm</B><A name="cyclicQueue.1:append.2:elm.3(791)"></A><A name="elm.3(791)"></A>: ^cyclicElm;
       enter elm[]
       ...
       #);
     <B>prepend</B><A name="cyclicQueue.1:prepend.2(792)"></A><A name="prepend.2(792)"></A>: @
       (# <B>elm</B><A name="cyclicQueue.1:prepend.2:elm.3(793)"></A><A name="elm.3(793)"></A>: ^cyclicElm;
       enter elm[] 
       ...
       #);
     <B>insertBefore</B><A name="cyclicQueue.1:insertBefore.2(794)"></A><A name="insertBefore.2(794)"></A>: @
       (# <B>new</B><A name="cyclicQueue.1:insertBefore.2:new.3(795)"></A><A name="new.3(795)"></A>,<B> old</B><A name="cyclicQueue.1:insertBefore.2:old.3(796)"></A><A name="old.3(796)"></A>: ^cyclicElm;
       enter (new[],old[])
       ...
       #);
     <B>getFirst</B><A name="cyclicQueue.1:getFirst.2(797)"></A><A name="getFirst.2(797)"></A>: @
       (# <B>elm</B><A name="cyclicQueue.1:getFirst.2:elm.3(798)"></A><A name="elm.3(798)"></A>: ^cyclicElm;
       ...
       exit elm[]
       #);
     <B>delete</B><A name="cyclicQueue.1:delete.2(799)"></A><A name="delete.2(799)"></A>: @
       (# <B>elm</B><A name="cyclicQueue.1:delete.2:elm.3(800)"></A><A name="elm.3(800)"></A>: ^cyclicElm;
       enter elm[]
       ...
       exit elm[]
       #);
     <B>remove</B><A name="cyclicQueue.1:remove.2(801)"></A><A name="remove.2(801)"></A>: @ 
       (* elm should not be reused after remove. Use delete instead.
        *)
       (# <B>elm</B><A name="cyclicQueue.1:remove.2:elm.3(802)"></A><A name="elm.3(802)"></A>: ^cyclicElm; <B>s</B><A name="cyclicQueue.1:remove.2:s.3(803)"></A><A name="s.3(803)"></A>: ^|sysHead;
       enter elm[]
       ...
       exit s[]
       #);
     <B>scan</B><A name="cyclicQueue.1:scan.2(804)"></A><A name="scan.2(804)"></A>:
       (# <B>current</B><A name="cyclicQueue.1:scan.2:current.3(805)"></A><A name="current.3(805)"></A>: ^cyclicElm;
       ...
       #);
     <B>size</B><A name="cyclicQueue.1:size.2(806)"></A><A name="size.2(806)"></A>: @Integer;
  #);
<B>SysHead</B><A name="SysHead.1(807)"></A>: 
  (# <B>shstatus</B><A name="SysHead.1:shstatus.2(808)"></A><A name="shstatus.2(808)"></A>: @Integer; 
     <B>lc</B><A name="SysHead.1:lc.2(809)"></A><A name="lc.2(809)"></A>: ^Object;     (* Last errorCatcher for distribution errors. *)
     <B>ce</B><A name="SysHead.1:ce.2(810)"></A><A name="ce.2(810)"></A>: ^cyclicElm;  (* ce,q &lt;&gt; none =&gt; this(sysHead) is ce in q.  *)
     <B>q</B><A name="SysHead.1:q.2(811)"></A><A name="q.2(811)"></A>: ^cyclicQueue;
  do INNER
  #);
(* SysHead.shstatus values: *)
<B>SE_RUNNING</B><A name="SE_RUNNING.1(812)"></A>:  (# exit 1 #);  (* Current system.       *)
<B>SE_WAITING</B><A name="SE_WAITING.1(813)"></A>:  (# exit 2 #);  (* Blocked on semaphore. *)
<B>SE_READY</B><A name="SE_READY.1(814)"></A>:    (# exit 3 #);  (* Ready to run.         *)
<B>SE_SLEEPING</B><A name="SE_SLEEPING.1(815)"></A>: (# exit 4 #);  (* Sleeping.             *)
<B>SE_KILLED</B><A name="SE_KILLED.1(816)"></A>:   (# exit 5 #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<TABLE border=0 width=100%>
<TR><TD><ADDRESS>Interface Description</ADDRESS></TD>
<SCRIPT LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT>
</TABLE>
<P></P>
<A HREF="systemenv.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="directory.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
