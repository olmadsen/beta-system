<H1> The Streams Patterns</H1>
<P> A stream<A NAME=MARKER-2-43></A> is a generalization of internal and external text objects. An internal text object (text<A NAME=MARKER-2-44></A>) is a sequence (repetition) of chars. An external text object (file) corresponds to a traditional text file. Stream, text and file<A NAME=MARKER-2-45></A> are organized in the following hierarchy:</P>
<P> Stream, text, and file</P>
<PRE CLASS=beta>
stream: (# ... #);
text: stream(# ... #);
file: stream(# ... #);    (* described in a later chapter *)
unixFile: file(# ... #);(* described in a later chapter *)
macFile: file(# ... #); (* described in the Macintosh
                             * Library manual *)
</PRE>
<A NAME=HEADING8-9></A>
<H1> The Stream Pattern</H1>
<P> The stream<A NAME=MARKER-2-46></A> pattern is an abstract superpattern: which provides general stream manipulating procedure patterns: getPos, setPos, eos, length, reset, newline, put, get, peek, putint, getint, puttext, gettext, putline, getNonBlank, getline, getAtom, scan, scanBlanks, scanToNL and scanAtom. The stream pattern also defines exception patterns (e.g. EOSerror).  See the interface of stream for more details.</P>
<A NAME=HEADING8-11></A>
<H2> Substreams</H2>
<A NAME=substreams.bet><H4 CLASS=betacaption>substreams.bet</H4></A>
<P> There is an additional library called substreams.bet, which implements a substrems concept (and a subtext concept).  A substream refers to a (consequtive) portion of  another stream.  Manipulations on the substream will thereby actually change that portion of this other stream.  All usual stream operations applies to a substream.  See the interface of substream for more details.</P>
<A NAME=HEADING8-14></A>
<H1> The Text Pattern</H1>
<P> The text<A NAME=MARKER-2-47></A> concept is intended for 'small' texts, but there is no size limit. Some of the operations might however be inefficient on large text objects. </P>
<P> A text is a sequence of characters. The range of a text object T is [1,T.length]. A text can be initialized by executing T.clear or by assigning it with another (initialized) text. Like the predefined patterns integer, real, char and boolean, Text objects are self-assignable. A text constant has the form 'foo' or 'a'. The ' character may by specified as part of a text constant by repeating it, e.g. 'is''s like this' is the text constant: is's like this.</P>
<P> Besides defining the implementations of the abstract stream operations (e.g. put and get), the text pattern defines the following patterns: empty, clear, inxGet, inxPut, append, prepend, scanAll, sub, insert, delete, equal, equalNCS, less, greater, makeLC, makeUC, find, findAll, findText, findTextAll, copy, and asInt.</P>
<P> All error messages from exceptions originating from text objects are followed by the text lines: </P>
<PRE CLASS=beta>
Error in text which begins as follows:
&lt;THIS(text)&gt;.....
</PRE>
<P> where &lt;THIS(text)&gt; is the text where the error occurred.</P>
<A NAME=HEADING8-24></A>
<H2> Text utilities</H2>
<P> The library <A NAME=TextUtils.bet>textUtils.bet</A> contains a number of additional text attributes, such as getBoolean<A NAME=MARKER-2-48></A>, putBoolean<A NAME=MARKER-2-49></A>, set<A NAME=MARKER-2-50></A>, setText<A NAME=MARKER-2-51></A>, setInt<A NAME=MARKER-2-52></A>, setBased<A NAME=MARKER-2-53></A>, setReal<A NAME=MARKER-2-54></A>, and setBoolean<A NAME=MARKER-2-55></A>.  See the interface of textUtils for more details.</P>
<P> The library <A NAME=Texthash.bet>texthash.bet</A> contains a single operation: honeyman<A NAME=MARKER-2-56></A>, which is an efficient and nearly optimal hash-function for text hash keys.  See the interface of texthash for more details.</P>
<A NAME=HEADING8-29></A>
<H2> Using Text</H2>
<P> This example gives examples of how to use the text pattern. The text object Records consists of a sequence of records. Each record has the form:</P>
<PRE CLASS=beta>
name Job:aJob Salary:aSalary /
</PRE>
<P> The program shows various patterns for manipulating the Records text:</P>

<A NAME=textRecords.bet><H4 CLASS=betacaption>textRecords.bet</H4></A>
<PRE CLASS=beta>
ORIGIN '~beta/basiclib/betaenv';

--- program: descriptor --
(* Demo example shwoing examples of how to use the text concept from betaenv.
 * The text object Records, consists of a sequence of records. Each record
 * has the form:
 *    name Job:aJob Salary:aSalary /
 * The program shows various patterns for manipulating the Records text.
 *)
(# GetName: (* read next name from T *)
     (# T: ^text; T1: @text
     enter T[]
     do (* scan and skip until a letter is met *)
        T.scan(# while::&lt;(#do NOT (ch-&gt;Ascii.isLetter)-&gt;value #)#);
        (* scan and read while letters in T *)
        T.scan
        (# while::&lt;(#do ch-&gt;Ascii.isLetter-&gt;value #)
        do ch-&gt;T1.put
        #)
     exit T1
     #);
   GetRecord: 
     (* Get the record with the name N  and return name and dat part *)
     (# N: ^Text; name,data: @Text
     enter N[]
     do Records.reset;
        FindName:
          (if not Records.eos then
              Records[]-&gt;getName-&gt;name;
              data.clear;
              (* scan and read until '/' is met *)
              Records.scan(# while::&lt;(#do (ch&lt;&gt;'/')-&gt;value#) do ch-&gt;data.put #);
            (if not (N[]-&gt;name.equal) then restart FindName 
        if)if)
     exit(name,data)
     #); 
   GetJobAndSalary: 
     (* get the  job and salary from data part, which is the part after name *)
     (# Data: ^Text; Job: @Text; Salary: @integer
     enter Data[]
     do Data.reset;
        Data[]-&gt;GetName; Data.get (* skip ':' *); Data[]-&gt;GetName-&gt;Job;
        Data[]-&gt;GetName; Data.get; Data.GetInt-&gt;Salary
     exit(Job,Salary)
     #);

   Records: @Text;
do '----------1:'-&gt;putLine; 
   (*  initialize Records *)
   'John Job:Programmer salary:120000 / '-&gt;Records.append;
   'Joan Job:Doctor salary:130000 / '-&gt;Records.append;
   'Mary Job:Boss salary:140000 / '-&gt;Records.append;
   Records[]-&gt;putLine;
   
   '----------2:'-&gt;putLine;
   (* split Records into atoms *)
   Records.reset;
   scan:
   cycle
     (# 
     do Records.getAtom-&gt;putline; 
        (if Records.eos then leave scan
     if)#);
   '----------3:'-&gt;putLine;
   (* Find record with name Joan and decode data part *)
   (# Name,Data,Job: @ text; Salary: @Integer
   do 'Joan'-&gt;GetRecord-&gt;(Name,Data);
      'Ms. '-&gt;Name.prePend; 
      ' II'-&gt;name.append;
      Name[]-&gt;putText; ' has the data: '-&gt;putText;
      Data[]-&gt;GetJobAndSalary-&gt;(Job,Salary);
      'Job='-&gt;putText; Job.makeUC;  Job[]-&gt;putText;
      ' Salary='-&gt;putText; Salary-&gt;putInt; newline;
   #)
   
#)
</PRE>

<A NAME=HEADING8-30></A>
<H2> UniCode Text</H2>

This release contains an experimental implementation of an UniCode
stream and UniCode text.  The fragment is called wtext.bet, and a
UniCode stream is realized by the wstream pattern and a UniCode text
is realized by the wtext pattern. 
<p>

Besides these two patterns, this fragment defines a conversion pattern
ascii2wtext, which takes a regular BETA text and converts it into a
UniCode text (a wtext instance).  Furthermere, this fragment extends
the text interface with one additional operation aswtext, which
converts the text instance to a wtext instance.
<P>

See the interface file for wtext for further details.




<HR>
<P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left">
<ADDRESS>Basic Libraries</ADDRESS>
</TD>
<TD width="20%" align="center"><FONT SIZE="-1">&#169; <A HREF="http://www.mjolner.com">Mj&oslash;lner Informatics</A></FONT></TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
<P>
<P><A HREF=basiclib-9.html><IMG ALIGN=BOTTOM SRC="../images/next.gif" ALT=Next BORDER=0></A>
<A HREF=basiclib-7.html><IMG ALIGN=BOTTOM SRC="../images/prev.gif" ALT=Previous BORDER=0></A>
<A HREF=basiclib-3.html><IMG ALIGN=BOTTOM SRC="../images/up.gif" ALT=Up BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html#_toc"><IMG ALIGN=BOTTOM SRC="../images/content.gif" ALT=Contents BORDER=0></A>
<A HREF=inx.html><IMG ALIGN=BOTTOM SRC="../images/index.gif" ALT=Index BORDER=0></A></P>

</BODY>
</HTML>
