<H2> The Streams Patterns</H2>
<P> A <INX>stream</INX> is a generalization of internal and external text objects. An internal text object (<INX>text</INX>) is a sequence (repetition) of chars. An external text object (file) corresponds to a traditional text file. Stream, text and <INX>file</INX> are organized in the following hierarchy:</P>
<P> Stream, text, and file</P>
<BETA>
stream: (# ... #);
text: stream(# ... #);
file: stream(# ... #);    (* described in a later chapter *)
unixFile: file(# ... #);(* described in a later chapter *)
macFile: file(# ... #); (* described in the Macintosh
                             * Library manual *)
</BETA>
<A NAME=HEADING8-9></A>
<H3> The Stream Pattern</H3>
<P> The <INX>stream</INX> pattern is an abstract superpattern: which provides general stream manipulating procedure patterns: getPos, setPos, eos, length, reset, newline, put, get, peek, putint, getint, puttext, gettext, putline, getNonBlank, getline, getAtom, scan, scanBlanks, scanToNL and scanAtom. The stream pattern also defines exception patterns (e.g. EOSerror).  See the interface of stream for more details.</P>
<A NAME=HEADING8-11></A>
<H3> Substreams</H3>

<P> There is an additional library called substreams.bet, which implements a substrems concept (and a subtext concept).  A substream refers to a (consequtive) portion of  another stream.  Manipulations on the substream will thereby actually change that portion of this other stream.  All usual stream operations applies to a substream.  See the interface of substream for more details.</P>
<A NAME=HEADING8-14></A>
<H3> The Text Pattern</H3>
<P> The <INX>text</INX> concept is intended for 'small' texts, but there is no size limit. Some of the operations might however be inefficient on large text objects. </P>
<P> A text is a sequence of characters. The range of a text object T is [1,T.length]. A text can be initialized by executing T.clear or by assigning it with another (initialized) text. Like the predefined patterns integer, real, char and boolean, Text objects are self-assignable. A text constant has the form 'foo' or 'a'. The ' character may by specified as part of a text constant by repeating it, e.g. 'is''s like this' is the text constant: is's like this.</P>
<P> Besides defining the implementations of the abstract stream operations (e.g. put and get), the text pattern defines the following patterns: empty, clear, inxGet, inxPut, append, prepend, scanAll, sub, insert, delete, equal, equalNCS, less, greater, makeLC, makeUC, find, findAll, findText, findTextAll, copy, and asInt.</P>
<P> All error messages from exceptions originating from text objects are followed by the text lines: </P>
<BETA>
Error in text which begins as follows:
<THIS(text)>.....
</BETA>
<P> where &lt;THIS(text)&gt; is the text where the error occurred.</P>
<A NAME=HEADING8-24></A>
<H3> Text utilities</H3>
<P> The library <A NAME=TextUtils.bet>textUtils.bet</A> contains a number of additional text attributes, such as <INX>getBoolean</INX>, <INX>putBoolean</INX>, <INX>set</INX>, <INX>setText</INX>, <INX>setInt</INX>, <INX>setBased</INX>, <INX>setReal</INX>, and <INX>setBoolean</INX>.  See the interface of textUtils for more details.</P>
<P> The library <A NAME=Texthash.bet>texthash.bet</A> contains a single operation: <INX>honeyman</INX>, which is an efficient and nearly optimal hash-function for text hash keys.  See the interface of texthash for more details.</P>
<A NAME=HEADING8-29></A>
<H3> Using Text</H3>
<P> This example gives examples of how to use the text pattern. The text object Records consists of a sequence of records. Each record has the form:</P>
<BETA>
name Job:aJob Salary:aSalary /
</BETA>
<P> The program shows various patterns for manipulating the Records text:</P>

<BETA SRC="$BETALIB/basiclib/demo/betaenv/textRecords.bet" LIST="textRecords.bet">

<A NAME=HEADING8-30></A>
<H3> UniCode Text</H3>

This release contains an experimental implementation of an UniCode
stream and UniCode text.  The fragment is called wtext.bet, and a
UniCode stream is realized by the wstream pattern and a UniCode text
is realized by the wtext pattern. 
<p>

Besides these two patterns, this fragment defines a conversion pattern
ascii2wtext, which takes a regular BETA text and converts it into a
UniCode text (a wtext instance).  Furthermere, this fragment extends
the text interface with one additional operation aswtext, which
converts the text instance to a wtext instance.
<P>

See the interface file for wtext for further details.





