<H1> The Streams Patterns</H1>
<P> A <INX>stream</INX> is a generalization of internal and external text objects. An internal text object (<INX>text</INX>) is a sequence (repetition) of chars. An external text object (file) corresponds to a traditional text file. Stream, text and <INX>file</INX> are organized in the following hierarchy:</P>
<P> Stream, text, and file</P>
<BETA>
stream: (# ... #);
text: stream(# ... #);
file: stream(# ... #);    (* described in a later chapter *)
unixFile: file(# ... #);(* described in a later chapter *)
macFile: file(# ... #); (* described in the Macintosh
                             * Library manual *)
</BETA>
<A NAME=HEADING8-9></A>
<H1> The Stream Pattern</H1>
<P> The <INX>stream</INX> pattern is an abstract superpattern: which provides general stream manipulating procedure patterns: getPos, setPos, eos, length, reset, newline, put, get, peek, putint, getint, puttext, gettext, putline, getNonBlank, getline, getAtom, scan, scanBlanks, scanToNL and scanAtom. The stream pattern also defines exception patterns (e.g. EOSerror).  See the interface of stream for more details.</P>
<A NAME=HEADING8-11></A>
<H2> Substreams</H2>
<A NAME=substreams.bet><H4 CLASS=betacaption>substreams.bet</H4></A>
<P> There is an additional library called substreams.bet, which implements a substrems concept (and a subtext concept).  A substream refers to a (consequtive) portion of  another stream.  Manipulations on the substream will thereby actually change that portion of this other stream.  All usual stream operations applies to a substream.  See the interface of substream for more details.</P>
<A NAME=HEADING8-14></A>
<H1> The Text Pattern</H1>
<P> The <INX>text</INX> concept is intended for 'small' texts, but there is no size limit. Some of the operations might however be inefficient on large text objects. </P>
<P> A text is a sequence of characters. The range of a text object T is [1,T.length]. A text can be initialized by executing T.clear or by assigning it with another (initialized) text. Like the predefined patterns integer, real, char and boolean, Text objects are self-assignable. A text constant has the form 'foo' or 'a'. The ' character may by specified as part of a text constant by repeating it, e.g. 'is''s like this' is the text constant: is's like this.</P>
<P> Besides defining the implementations of the abstract stream operations (e.g. put and get), the text pattern defines the following patterns: empty, clear, inxGet, inxPut, append, prepend, scanAll, sub, insert, delete, equal, equalNCS, less, greater, makeLC, makeUC, find, findAll, findText, findTextAll, copy, and asInt.</P>
<P> All error messages from exceptions originating from text objects are followed by the text lines: </P>
<BETA>
Error in text which begins as follows:
&lt;THIS(text)&gt;.....
</BETA>
<P> where &lt;THIS(text)&gt; is the text where the error occurred.</P>
<A NAME=HEADING8-24></A>
<H2> Text utilities</H2>
<P> The library <A NAME=TextUtils.bet>textUtils.bet</A> contains a number of additional text attributes, such as <INX>getBoolean</INX>, <INX>putBoolean</INX>, <INX>set</INX>, <INX>setText</INX>, <INX>setInt</INX>, <INX>setBased</INX>, <INX>setReal</INX>, and <INX>setBoolean</INX>.  See the interface of textUtils for more details.</P>
<P> The library <A NAME=Texthash.bet>texthash.bet</A> contains a single operation: <INX>honeyman</INX>, which is an efficient and nearly optimal hash-function for text hash keys.  See the interface of texthash for more details.</P>
<A NAME=HEADING8-29></A>
<H2> Using Text</H2>
<P> This example gives examples of how to use the text pattern. The text object Records consists of a sequence of records. Each record has the form:</P>
<BETA>
name Job:aJob Salary:aSalary /
</BETA>
<P> The program shows various patterns for manipulating the Records text:</P>
###
<A NAME=textRecords.bet><H4 CLASS=betacaption>textRecords.bet</H4></A>
<PRE CLASS=beta>
ORIGIN '~beta/basiclib/betaenv';

--- program: descriptor --
(* Demo example shwoing examples of how to use the text concept from betaenv.
 * The text object Records, consists of a sequence of records. Each record
 * has the form:
 *    name Job:aJob Salary:aSalary /
 * The program shows various patterns for manipulating the Records text.
 *)
(# GetName: (* read next name from T *)
     (# T: ^text; T1: @text
     enter T[]
     do (* scan and skip until a letter is met *)
        T.scan(# while::&lt;(#do NOT (ch-&gt;Ascii.isLetter)-&gt;value #)#);
        (* scan and read while letters in T *)
        T.scan
        (# while::&lt;(#do ch-&gt;Ascii.isLetter-&gt;value #)
        do ch-&gt;T1.put
        #)
     exit T1
     #);
   GetRecord: 
     (* Get the record with the name N  and return name and dat part *)
     (# N: ^Text; name,data: @Text
     enter N[]
     do Records.reset;
        FindName:
          (if not Records.eos then
              Records[]-&gt;getName-&gt;name;
              data.clear;
              (* scan and read until '/' is met *)
              Records.scan(# while::&lt;(#do (ch&lt;&gt;'/')-&gt;value#) do ch-&gt;data.put #);
            (if not (N[]-&gt;name.equal) then restart FindName 
        if)if)
     exit(name,data)
     #); 
   GetJobAndSalary: 
     (* get the  job and salary from data part, which is the part after name *)
     (# Data: ^Text; Job: @Text; Salary: @integer
     enter Data[]
     do Data.reset;
        Data[]-&gt;GetName; Data.get (* skip ':' *); Data[]-&gt;GetName-&gt;Job;
        Data[]-&gt;GetName; Data.get; Data.GetInt-&gt;Salary
     exit(Job,Salary)
     #);

   Records: @Text;
do '----------1:'-&gt;putLine; 
   (*  initialize Records *)
   'John Job:Programmer salary:120000 / '-&gt;Records.append;
   'Joan Job:Doctor salary:130000 / '-&gt;Records.append;
   'Mary Job:Boss salary:140000 / '-&gt;Records.append;
   Records[]-&gt;putLine;
   
   '----------2:'-&gt;putLine;
   (* split Records into atoms *)
   Records.reset;
   scan:
   cycle
     (# 
     do Records.getAtom-&gt;putline; 
        (if Records.eos then leave scan
     if)#);
   '----------3:'-&gt;putLine;
   (* Find record with name Joan and decode data part *)
   (# Name,Data,Job: @ text; Salary: @Integer
   do 'Joan'-&gt;GetRecord-&gt;(Name,Data);
      'Ms. '-&gt;Name.prePend; 
      ' II'-&gt;name.append;
      Name[]-&gt;putText; ' has the data: '-&gt;putText;
      Data[]-&gt;GetJobAndSalary-&gt;(Job,Salary);
      'Job='-&gt;putText; Job.makeUC;  Job[]-&gt;putText;
      ' Salary='-&gt;putText; Salary-&gt;putInt; newline;
   #)
   
#)
</PRE>

<A NAME=HEADING8-30></A>
<H2> UniCode Text</H2>

This release contains an experimental implementation of an UniCode
stream and UniCode text.  The fragment is called wtext.bet, and a
UniCode stream is realized by the wstream pattern and a UniCode text
is realized by the wtext pattern. 
<p>

Besides these two patterns, this fragment defines a conversion pattern
ascii2wtext, which takes a regular BETA text and converts it into a
UniCode text (a wtext instance).  Furthermere, this fragment extends
the text interface with one additional operation aswtext, which
converts the text instance to a wtext instance.
<P>

See the interface file for wtext for further details.





