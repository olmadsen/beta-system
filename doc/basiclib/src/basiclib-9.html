<H1> Exceptions and Program Termination</H1>
<P> The pattern <INX>exception</INX> is used as a superpattern: for all exceptions in the system. The default action of an exception is to stop the program execution and print an informative error message on the stream screen. In addition, the file <INX>&lt;programname&gt;.dump</INX> contains a dump of the call stack. Exception uses the pattern <INX>Stop</INX> for termination. Specific error messages can be defined by specializing the exception pattern. The attribute msg of exception is a text object that is used to accumulate error messages in the classification hierarchy of exceptions. If the programmer wishes to prevent the program execution from being stopped in order to handle the exception himself, the boolean attribute <INX>continue</INX> of exception must be set to true. </P>
<P> The exceptions are often defined as virtual procedure patterns of other patterns (such as the file pattern, discussed below). At the appropriate levels in the pattern hierarchy, the virtual patterns are bound so that the error messages are tailored to the specific context. The user can augment these error messages by means of the msg text object or choose to ignore the exception and continue execution. </P>
<P> In order to differentiate between potential fatal exceptions and more harmless exceptions, the <INX>notification</INX> pattern is defined as:</P>
<BETA>
notification: exception(# do true->continue; INNER #);
</BETA>
<A NAME=HEADING9-6></A>
<H1> Examples Using Exception</H1>
<P> In order to illustrate the use of exceptions, let us return to the previous file exception example. Without using the exception handling facilities an attempt to open a non-existing file will produce the following error messages: </P>
<BETA>
**** Exception processing
Error in file 'in.bet'
No such file
</BETA>
<P> Now let us see what can be done by using exceptions.</P>
<P> The binding of noSpaceError shows that a message can be added to msg. Msg could also have been overwritten, by first clearing msg (msg.clear). The binding of noSuchFileError shows how to prevent the system from stopping the execution when the program attempts to open a non-existing file. Instead the user is prompted for another file name. In fact there exists a procedure pattern (exists) that tests for the existence of a file, but this has not been used in this example. </P>
<BETA>
(# outFile: @file
(# noSpaceError::
     (# do 'It is time to delete garbage!'->msg.putline #)#);     
   inFile: @file 
     (# noSuchFileError:: (# do true->continue; false->OK #)#);
   OK: @ boolean; 

do 'in.bet' -> inFile.name;
   true -> OK;
   openFile: 
   (# 
   do inFile.openRead;
      (if not OK then
          'File does not exist!' ->  screen.putline;
          'Type input file name: ' ->  screen.puttext;
          inFile.readFileName;
          true -> OK;
          restart openFile
      if)
   #);

   'out.bet' -> outFile.name;
   outFile.openWrite;
   readFile: 
     (# 
     do (if not inFile.eos then 
            false -> inFile.gettext -> outFile.puttext;
            outFile.newline;
            restart readFile
        else 
            leave readFile
        if)
     #);
   inFile.close;
   outFile.close;
#)
</BETA>
<P> In case of disk space exhausted, the following message will be printed on the screen before the program execution is stopped: </P>
<BETA>
**** Exception processing
Error in file 'in.bet'
File system is full
It is time to delete garbage!
</BETA>
<P> The first line is from the general pattern exception, the second and the third lines are from the binding of noSpaceError in file and the fourth line is from the binding above, i.e. at the user level. </P>
<P> An attempt to open a non-existing file will produce the following error messages: </P>
<BETA>
File does not exist!
Type input file name:
</BETA>
<P> It gives the programmer the possibility to proceed with another file name. </P>





