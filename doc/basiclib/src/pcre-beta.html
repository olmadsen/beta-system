<H1>The Perl Compatible Regular Expression Library</H1>

The Perl Compatible Regular Expression Library (PCRE) implements the pcre
pattern with the method attributes

<PRE CLASS=beta>
<a href="#init">init</a>
<a href="#options">options</a>
<a href="#match">match</a>
<a href="#matchAll">matchAll</a>
<a href="#replace">replace</a>
<a href="#replaceAll">replaceAll</a>
</PRE>

the value attribute

<PRE CLASS=beta>
<a href="#subPatterns">subPatterns</a>
</PRE>

the exception attribute

<PRE CLASS=beta>
<a href="#compilationError">compilationError</a>
</PRE>

<H2>Regular Expressions</H2>

<p>A regular expression (regexp, for
short) is a pattern that denotes a set of strings, possibly
an infinite set. Searching for matches for a regexp is a
very powerful operation that editors and scripting languages
on Unix systems have traditionally offered.</p>

<p>This implementation of regular expressions implements a regular
expression syntax that is compatible with that in the language Perl.
It is based on Philip Hazel's PCRE
library.   Most of <a href="pcre.html">Philip Hazel's documentation</a>
also applies to the
BETA version.</p>

<H2>pcre</H2>

<p>The pcre pattern encapsulates a regular expression.  It takes a
<a href="basiclib-8.html#text">Text</a> reference as an 
enter parameter.  The enter parameter is given to the <a href="#init">
Init</a> method.</p>

<p>The pcre pattern has an empty do-part</p>

<p>The pcre pattern exits a reference to itself</p>

<p>You can use the pcre pattern as in the following example</p>

<PRE CLASS=beta> 
   re: ^Pcre;
do 'trigger' -&gt; pcre -&gt; re[];
   (filename[], re[]) -&gt; myGrep;
</PRE>

<H2><a name="init"></a>init</H2>

<p>The init method takes a <a href="basiclib-8.html#text">Text</a>
reference as an enter parameter.  This string describes the regular
expression according to the syntax described in <a href="pcre.html#SEC13">
the pcre documentation</a>.  Init compiles the regular expression into an
internal format suitable for matching against strings.  This operation
takes some CPU time, so the result (stored in the pcre object) should be
kept if the same pattern is to be used many times.</p>

<p>When compiling the regular expression the options defined by the
<a href="#options">options</a> method are used.</p>

<p>You can call init several times if you want to change the regular
expression matched by the pcre object.</p>

<H2><a name="options"></a>options</H2>

<p>The options method is a virtual pattern, which you can specialise.  Put the
options you need into the do part.  For example:</p>

<PRE CLASS=beta> 
   re: @Pcre (# options:: (# do <a href="pcre.html#PCRE_CASELESS">CASELESS</a>; <a href="#PCRE_DO_STUDY">DO_STUDY</a>; #); #)
do 'tRiGgEr' -&gt; re;
   (filename[], re[]) -&gt; myGrep;
</PRE>

<p>There is an alternative way to specify certain options, which involves
placing them in the textual representation of the regular expression.
For example the option <a href="pcre.html#PCRE_CASELESS">CASELESS</a> can
be specified by prepending the string '<?i>' to the regular expression.</p>

<p>The following options are supported</p>

<table>
<tr>
<td>Option</td> <td>Text version</td> <td>Used in</td> <td>Description</td>
</tr>
<tr>
<td> <a name="PCRE_CASELESS"></a>CASELESS</td>
    <td>(?i)</td>   <td>init</td>
    <td><a href="pcre.html#PCRE_CASELESS">Ignore case when matching</a></td>
</tr>
<tr>
<td> <a name="PCRE_MULTILINE"></a>MULTILINE</td>
    <td>(?m)</td>   <td>init</td>
    <td><a href="pcre.html#PCRE_MULTILINE">^ and $ match after/before newlines</a></td>
</tr>
<tr>
<td> <a name="PCRE_DOTALL"></a>DOTALL</td>
    <td>(?s)</td>   <td>init</td>
    <td><a href="pcre.html#PCRE_DOTALL">. matches newlines</a></td>
</tr>
<tr>
<td> <a name="PCRE_EXTENDED"></a>EXTENDED</td>
    <td>(?x)</td>   <td>init</td>
    <td><a href="pcre.html#PCRE_EXTENDED">Extended regexp syntax</a></td>
</tr>
<tr>
<td> <a name="PCRE_ANCHORED"></a>ANCHORED</td>
    <td>^</td>   <td>init</td>
    <td><a href="pcre.html#PCRE_ANCHORED">Match only at start of string</a></td>
</tr>
<tr>
<td> <a name="PCRE_DOLLAR_ENDONLY"></a>DOLLAR_ENDONLY</td>
    <td></td>   <td>init</td>
    <td><a href="pcre.html#PCRE_DOLLAR_ENDONLY">$ doesn't match before terminal newline</a></td>
</tr>
<tr>
<td> <a name="PCRE_EXTRA"></a>EXTRA</td>
    <td>(?X)</td>   <td>init</td>
    <td><a href="pcre.html#PCRE_EXTRA">Support PCRE extensions to Perl regexps</a></td>
</tr>
<tr>
<td> <a name="PCRE_NOTBOL"></a>NOTBOL</td>
    <td></td>   <td>init or match</td>
    <td><a href="pcre.html#PCRE_NOTBOL">Do not match ^ at start of string</a></td>
</tr>
<tr>
<td> <a name="PCRE_NOTEOL"></a>NOTEOL</td>
    <td></td>   <td>init or match</td>
    <td><a href="pcre.html#PCRE_NOTEOL">Do not match $ at end of string</a></td>
</tr>
<tr>
<td> <a name="PCRE_UNGREEDY"></a>UNGREEDY</td>
    <td>(?U)</td>   <td>init</td>
    <td><a href="pcre.html#PCRE_UNGREEDY">Quantifiers not greedy by default</a></td>
</tr>
<tr>
<td> <a name="PCRE_NOTEMPTY"></a>NOTEMPTY</td>
    <td></td>   <td>init or match</td>
    <td><a href="pcre.html#PCRE_NOTEMPTY">Empty string cannot match entire expression</a></td>
</tr>
<tr>
<td> <a name="PCRE_C_LOCALE"></a>C_LOCALE</td>
    <td></td>   <td>init</td>
    <td><a href="#PCRE_C_LOCALE_note">Use C locale instead of default localei</a></td>
</tr>
<tr>
<td> <a name="PCRE_DO_STUDY"></a>DO_STUDY</td>
    <td></td>   <td>init</td>
    <td><a href="#PCRE_DO_STUDY_note">Study regexp after compiling it</a></td>
</tr>
<tr>
<td> <a name="PCRE_RETURN_NONE"></a>RETURN_NONE</td>
    <td></td>   <td>init or match</td>
    <td><a href="#PCRE_RETURN_NONE_note">Return NONE for subpatterns that didn't match</a></td>
</tr>
</table>

<p><strong>Notes:</strong></p>

<ul>
<li><strong>More information</strong><br>
More details are available <a href="pcre.html">in the documentation of
the pcre library</a>.

<li><a name=init_match_note></a><strong>When to set options</strong><br>
Some options are only used in the init method, while others are set to
a default in the init method, but may be overridden in the options
method of match (inherited by matchAll, replace and replaceAll).

<li><a name=PCRE_C_LOCALE_note></a><strong>C_LOCALE</strong><br>
Normally pcre will use the locale defined by your C library to determine
whether a given character is a letter, etc.  If you set this option, then
pcre will use the C locale, ie only the characters a-z are letters.  Most
of the time this option will make no difference.

<li><a name=PCRE_DO_STUDY_note></a><strong>DO_STUDY</strong><br>
If you are going to be using a pattern many times, then this option may
improve performance.  See more about this <a href="pcre.html#SEC6">in the documentation of the pcre library</a>.

<li><a name=PCRE_RETURN_NONE_note></a><strong>RETURN_NONE</strong><br>
Normally the subMatchText methods and similar will exit an empty string
in the case where the subpattern didn't match at all.  This helps prevent
unexpected ref-NONE exceptions in your code.  Unfortunately it also makes
it difficult to tell the difference between a subpattern that matched an
empty string and a subpattern that didn't match at all (because it was in
an alternation that wasn't used).  If you set this option then you risk
getting NONE back from an invocation of subMatchText and your program must
be able to cope with that.

<li><a name=clear_options></a><strong>Clearing options</strong><br>
In some cases you may want to clear an option that has been set by a
superpattern.  You do this by prefixing the option name with
<tt>clear</tt>.  For example:

<PRE CLASS=beta>
(* p is a perl regexp with my favourite options, including case
 * insensitivity, but just this once I want a case sensitive
 * regexp.
 *)
p: @PcreWithMyFavouriteOptions (# options:: (# do clearCASELESS #) #);
</PRE CLASS=beta>

</ul>

<H2><a name="match"></a>match</H2>

<p>The match method takes a <a href="basiclib-8.html#text">Text</a>
reference and exits true or false, depending on whether the text matched
the expression.  It also contains a set of methods that can be overridden
to provide much more information about the match.</p>

<p>The INNER part of the match method is only called in the case of a
match.</p>

<PRE CLASS=beta>
<a href="#matchoptions">options</a>
<a href="#pre">pre</a>
<a href="#matchPos">matchPos</a>
<a href="#matchText">matchText</a>
<a href="#prePostMatchText">preMatchText</a>
<a href="#prePostMatchText">postMatchText</a>
<a href="#subMatchPos">subMatchPos</a>
<a href="#subMatchText">subMatchText</a>
<a href="#subn">sub1, sub2, sub3...</a>
<a href="#noMatch">noMatch</a>
<a href="#position">position</a>
</PRE>

<H2><a name="matchoptions"></a>match.options</H2>

<p>This method can be overridden in much the same way as
<a href="#options">the options method in the pcre pattern</a>
in order to pass options to the matching stage of the regular
expression engine.</p>

<H2><a name="pre"></a>match.pre</H2>

<p>This method is called before any matching takes place.  It does nothing,
but you can specialise it in your own subclasses.</p>

<H2><a name="matchPos"></a>match.matchPos</H2>

<p>This method can be called from the inner part of the match method.
It exits an integer pair, indicating the start and end positions of
the matched text in the original text.  See the example below.</p>

<H2><a name="matchText"></a>match.matchText</H2>

<p>This method can be called from the inner part of the match method.
It exits a <a href="basiclib-8.html#text">Text</a> reference
indicating the text that matched the regular expression.   See the
example below.</p>

<H2><a name="prePostMatchText"></a>match.preMatchText and match.postMatchText</H2>

<p>These methods can be called from the inner part of the match method.
They exit a <a href="basiclib-8.html#text">Text</a> reference
indicating the text that preceeded (or followed) the text that matched
the regular expression.</p>

<p>For example:</p>

<PRE CLASS=beta>
(# t1: ^Text;
   t2: ^Text;
   r3: ^Text;
   s: @Integer;
   e: @Integer;
do 'abc123def' -&gt; ('\\d+' -&gt; pcre).match
   (#
   do preMatchText -&gt; t1[];
      matchText -&gt; t2[];
      postMatchText -&gt; t3[];
      matchPos -&gt; (s, e);
   #);
   ...
#);
</PRE>

<p>Will put 'abc' in t1, '123' in t2 and 'def' in t3.  It also puts 4 in
s and 6 in e.</p>

<H2><a name="subMatchPos"></a>match.subMatchPos</H2>

<p>This method can be called from the inner part of the match method.
It enters an integer and exits an integer pair, indicating the start
and end positions of the nth subpattern in the original text.
See the example below.</p>

<H2><a name="subMatchText"></a>match.subMatchText</H2>

<p>This method can be called from the inner part of the match method.
It enters an integer and exits a text, indicating the text matched
by the nth subpattern.
See the example below.</p>

<H2><a name="subn"></a>match.sub1, match.sub2, match.sub3...</H2>

<p>These methods can be called from the inner part of the match method.
They exit a text, indicating the text matched by the nth subpattern.  They
are simply a shorthand method of invoking
<a href="#subMatchText">subMatchText</a>.  See the example below:</p>

<PRE CLASS=beta>
(# t1: ^Text;
   t2: ^Text;
   r3: ^Text;
   s: @Integer;
   e: @Integer;
do 'abc123def' -&gt; ('([a-z])(\\d+)([a-z]+)' -&gt; pcre).match
   (#
   do sub1 -&gt; t1[];
      sub2 -&gt; t2[];
      3 -&gt; subMatchText -&gt; t3[];
      3 -&gt; subMatchPos -&gt; (s, e);
   #);
   ...
#);
</PRE>

<p>Will put 'c' in t1, '123' in t2 and 'def' in t3.  It also puts 7 in s and
9 in e.</p>

<H2><a name=noMatch></a>match.noMatch</H2>

<p>This method is called by match when no match is found.  You can
specialise it to specify an action if no match is found.

<H2><a name=position></a>match.position</H2>

<p>This method controls where in the input string the search for a 
regular expression match starts.  You can specialise it, putting a
different number into the variable 'value'.

<H2><a name="replace"></a>replace</H2>

<p>The replace method inherits from the <a href="#match">match</a>
method.  It takes two inputs, firstly a
<a href="basiclib-8.html#text">Text</a>
reference to a search string, and secondly a text reference to a
default replacement string.  It exits two values, firstly
a boolean (true or false),
depending on whether the text matched
the expression.  Secondly the a text reference to the new text with the
replacement carried out.  If no replacement is carried out then the text
exited is a copy of the search string entered.  Replace also contains a set of
methods that can be overridden
to provide much more information about the match and to control the
replacement text more accurately.   See the example below.</p>

<p>The INNER part of the replace method is only called in the case of a
match.</p>

<PRE CLASS=beta>
<a href="#matchoptions">options</a>
<a href="#pre">pre</a>
<a href="#matchPos">matchPos</a>
<a href="#matchText">matchText</a>
<a href="#prePostMatchText">preMatchText</a>
<a href="#prePostMatchText">postMatchText</a>
<a href="#subMatchPos">subMatchPos</a>
<a href="#subMatchText">subMatchText</a>
<a href="#subn">sub1, sub2, sub3...</a>
<a href="#noMatch">noMatch</a>
<a href="#position">position</a>
<a href="#rep">rep</a>
</PRE>

<H2><a name=rep></a>replace.rep</H2>

<p>This method controls the replacement string.  The 'value' variable
is a reference to the default replacement text.  By assigning a new
reference to 'value' you can dynamically choose another replacement
string, based on information gleaned from the other methods available
in replace.</p>

<PRE CLASS=beta>
(# t1: ^Text;
do ('The y2k problem', 'year 2000' -&gt;
      ('\\by2k\\b' -&gt; pcre).replace -&gt;
      (p, t1[]);
   ...
#);
</PRE>

<p>Will put 'The year 2000 problem' in t1.  (The
<a href="pcre.html#SEC14">escape sequence</a> '\b' in a
regular expression matches a word boundary.  In a BETA
string you have to double the backslash.)

<PRE CLASS=beta>
(# t1: ^Text;
do ('The y3k problem', '' -&gt;
      ('\\by([0-9]+)k\\b' -&gt; pcre).replace
      (# rep::
         (#
         do 'year %s000' -&gt; <a href="basiclib-16.html#formatio">putFormat</a> (# do <a href="#subn">sub1</a> -&gt; s #) -&gt; value[];
         #);
      #) -&gt; (p, t1[]);
   ...
#);
</PRE>

<H2><a name=matchAll></a>matchAll</H2>

<p>This method is similar to <a href="#match">match</a>, but calls
INNER several times, once for each match.  It is not yet
fully documented.  Please see pcre.bet comments and demo
programs.</p>

<H2><a name=replaceAll></a>replaceAll</H2>

<p>This method is similar to <a href="#replace">replace</a>, but calls
INNER several times, once for each match.  It is not yet
fully documented.  Please see pcre.bet comments and demo
programs.</p>

<H2><a name=subPatterns></a>subPatterns</H2>

This is a readonly integer pattern, which tells you how many subpatterns your
pattern has.  Only useful if you are reading regular expressions from
a config file or from the user, since otherwise you should know this
figure already.

<H2><a name=compilationError></a>compilationError</H2>

This pattern is executed if your regular expression contains syntax
errors.  In this case it is not a good idea to call match or replace
on that pattern.
