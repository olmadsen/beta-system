<H1> Using the SystemEnv Fragment</H1>
<P> A program using the systemEnv fragment will have the following structure:</P>
<PRE CLASS=beta>
INCLUDE '~beta/basiclib/systemenv'
--- program: descriptor ---
systemenv
(# process: @ |system(# ... #);
do ...
   process[] -&gt; fork;
   ...
#)
</PRE>
<A NAME=HEADING31-11></A>
<H1> The Monitor Example</H1>
<P> The following is an example of a producer/consumer system with a shared buffer (implemented as a 20 element character buffer, protected as a monitor. The producer and consumer are concurrent objects:</P>

<A NAME=buffer.bet><H4 CLASS=betacaption>buffer.bet</H4></A>
<PRE CLASS=beta>
ORIGIN '~beta/basiclib/systemenv';

---program: descriptor---
SystemEnv
(# buffer: @Monitor
     (# R: [20] @char; in,out: @integer;
        full,empty: @Condition;
        
        put: Entry
          (# ch: @char
          enter ch
          do (if in = out then full.wait if);
             ch-&gt;R[in]; (in mod R.range)+1 -&gt;in;
             empty.signal; 
          #);
        get: Entry
          (# ch: @char
          do (if in = (out mod R.range)+1 then empty.wait if);
             R[(out mod R.range)+1-&gt;out]-&gt;ch; 
             full.signal; 
          exit ch
          #);
        init::&lt; (# do 1-&gt;in; R.range-&gt;out #)
     #);
   
   prod: @| System(# do cycle(# do keyboard.get-&gt;buffer.put #) #);
   cons: @| System(# do cycle(# do buffer.get-&gt;screen.put #) #);
   
do buffer.init;
   conc(# do prod[]-&gt;start; cons[]-&gt;start #)
#)
</PRE>
<A NAME=HEADING31-49></A>
<H1> The Monitor with Wait Example</H1>
<P> This example is similar to the previous, except that wait is used instead of condition to control the medium-term scheduling of access to the buffer. </P>

<A NAME=Ocbuf.bet><H4 CLASS=betacaption>Ocbuf.bet</H4></A>
<PRE CLASS=beta>
ORIGIN '~beta/basiclib/systemenv';

---program: descriptor--
systemenv
(# buffer: @Monitor
     (# R: [4] @char; in,out: @integer;
        full: (# exit in=out #);
        empty: (#exit (in = (out mod R.range)+1) #);
        Put: Entry
          (# ch: @char
          enter ch
          do wait(# do (not full)-&gt;cond #);
             ch-&gt;R[in]; (in mod R.range)+1 -&gt;in;
          #);
        get: Entry
          (# ch: @char
          do wait(# do (not empty)-&gt;cond #);
             R[(out mod R.range)+1-&gt;out]-&gt;ch; 
          exit ch
          #);
        init::&lt; (# do 1-&gt;in; R.range-&gt;out #)
     #);
   
   prod: @| System(# do cycle(# do keyboard.get-&gt;buffer.put #) #);
   cons: @| System(# do cycle(# do buffer.get-&gt;screen.put #) #);
   
do buffer.init;
   conc(# do prod[]-&gt;start; cons[]-&gt;start #)
#)
</PRE>
<A NAME=HEADING31-85></A>
<H1> The Ports Example</H1>
<P> The following is an example of three communicating objects: S, R1 and R2. R1 and R2 are similar (instances of the same Rtype pattern). </P>
<P> Rtype defines two ports: p1 and p2, with a get entry in p1 and a put entry in p2. The get entry prints the value of the x attribute on standard output, and put prints the y attribute. Rtype objects repeatedly accepts p1 communications followed by p2 communications (i.e. since in this example, only get is define in p1, and only put in p2, this implies get followed by put). Note that the use of ports, allows specializations of Rtype to define new entries in p1 and/or p2, such that these communications follow the same communication structure. </P>
<P> The S object defines two internal objects, C1 and C2, which are executed alternating. C1 is responsible for the communication with R1 and C2 is responsible with the communication with R2. It is in this way ensured that the communication pattern between S and R1 follows the get followed by put pattern (the same for S and R2), but these two communication patterns may be non-deterministically interleaved.</P>

<A NAME=altex1.bet><H4 CLASS=betacaption>altex1.bet</H4></A>
<PRE CLASS=beta>
ORIGIN '~beta/basiclib/systemenv';

---program: descriptor--
SystemEnv
(# S: @| System
     (# C1: @| System
          (#
          do cycle(# do '1'-&gt;put; R1.get; '2'-&gt;put; R1.put #);
          #);
        C2: @| System
          (#
          do cycle(# do 'a'-&gt;put; R2.get; 'b'-&gt;put; R2.put #)
          #)
     do alt(# do C1[]-&gt;start; C2[]-&gt;start #)
     #);
   
   Rtype: System
     (# get: p1.entry(# do x-&gt;screen.put; #); p1: @port;
        put: p2.entry(# do y-&gt;screen.put; #); p2: @port;
	x,y: @char
     do cycle(# do p1.accept; p2.accept #)
     #);
   R1: @| Rtype;
   R2: @| Rtype;
   
do '('-&gt;R1.x; ')'-&gt;R1.y; '['-&gt;R2.x; ']'-&gt;R2.y;
   conc(# do S[]-&gt;start; R1[]-&gt;start; R2[]-&gt;start #)
#)
</PRE>
<A NAME=HEADING31-121></A>
<H1> The ObjectPort Example</H1>
<P> This example illustrates the use of the ObjectPort facility. The S object defines f1, f2, and f3 communication entries, where f1 is controlled by an objectPort. This enables S to control exactly which object which is allowed to communicate f3's in an accept. Note, that initially, R.R1 is allowed, and later R.R3 is allowed:</P>

<A NAME=sys1.bet><H4 CLASS=betacaption>sys1.bet</H4></A>
<PRE CLASS=beta>
ORIGIN '~beta/basiclib/systemenv'; 

---program: descriptor--      
SystemEnv 
(# S: @| System
     (# P1: @ObjectPort;
        f1: P1.entry(# do 'f1 called' -&gt;putline #);
	P2: @Port;
        f2: P2.entry(# do 'f2 called' -&gt;putline #);
	P3: @Port;
        f3: P3.entry(# do 'f3 called' -&gt;putline #);
     do R.R1[]-&gt;P1.accept; 
        P2.accept; 
        P3.accept; 
        R.R3[]-&gt;P1.accept
     #);
   
   R: @| System
     (# R1: @| System(# do S.f1; S.f3 #);
        R2: @| System(# do S.f2; #);
        R3: @| System(# do S.f1 #);
     do 'Start R'-&gt;putLine;
        conc(# do R1[]-&gt;start;  R2[]-&gt;start; R3[]-&gt;start #);
        'End R'-&gt;putLine
     #);
   
do 'Start'-&gt;putLine;
   conc(# do R[]-&gt;start; S[]-&gt;start  #);
   'End'-&gt;putLine
#)
</PRE>
<P> </P>





