<H2> Basic Patterns</H2>
<H3> Simple types</H3>
<P> Betaenv contains definitions of the basic patterns char, integer, real, boolean, true and false that are predefined in the BETA language (i.e. built-in data types). These patterns are self-assignable. This means an integer object can be assigned to another integer object, a char object can be assigned to another char object etc. </P>
<P> For efficiency reasons, the usage of the basic patterns <INX>char</INX>, <INX>integer</INX>, <INX>real</INX>, <INX>boolean</INX>, <INX>true</INX> and <INX>false</INX> is somewhat restricted, compared with all other patterns in the system. These restrictions are: </P>
<UL>
<LI> They cannot be used as superpatterns to other patterns. E.g. subInteger: integer(# ... #) is illegal.
<LI> Dynamic references to instances of these basic types cannot be obtained.  E.g. var[] -> ... is illegal if var is an instance of one of these basic patterns.
<LI> Dynamic references to basic patterns cannot be declared.    E.g. var: ^integer is illegal.
</UL>
<P> True object oriented patterns for integers, characters, reals and booleans are also part of the system (see later). However, using those patterns impose an execution overhead compared with the basic patterns. </P>

<H3> The Integer Pattern</H3>
<H3> Arithmetical operators</H3>
<P> Besides the arithmetical operations: +, -, *, div, and mod and the relational operations: =, <&gt;, &gt;, &gt;=, &lt; and &lt;=, the Min, Max and Abs patterns are defined for integers. The patterns MaxInt and MinInt returns the largest (respectively smallest) <INX>integer</INX> on the machine.</P>
<BETA>
(# i,j,k: @integer
do 3 -> i; 
   '? '->puttext; getint->j; (* read an integer from keyboard *)
   ((i,j) -> Max, j+5)  -> Min -> k;
   'k is '-> puttext; k -> putint; newline;
   (if k-1
    // 5 then ...
    // 17 then ...
   if)
#)</BETA>


<H3> The Boolean Pattern</H3>
<H4> Logical operators</H4>
<P> In the current implementation, true and false return respectively the values 1 and 0. The unary operator not and the binary operators and, xor, and or can be applied to booleans. </P>
<P> Booleans are used in the traditional way: </P>
<BETA>
(# aBoolean, anotherBoolean: @boolean;
   a: @integer
do ...
   (if aBoolean then 
       ...
   else
     (a>7) and (a<17) -> anotherBoolean
   if)
#)</BETA>


<H3> The Real Pattern</H3>
<H4> Arithmetical operations</H4>
<P> The arithmetical operations: +, -, *, div (or /), and the relational operations: =, &lt;&gt;, &gt;, &gt;=, &lt; and &lt;= are defined for reals. The patterns MaxReal and MinReal (defined in math.bet) returns the largest (respectively smallest) real on the machine. </P>
<P> The following example shows how to use reals. The pattern putreal is described later.</P>
<BETA>
(# x,y: @real;
do ... -> x;
   'Print the number 1.23:' -> putline;
   y -> putreal; 
   newline;
   x -> y;
   (if x=y then 'x and y are equal!' -> putline if);
   '3.0*7.0 = ' -> puttext;
   3.0 * 7.0 -> putreal;
   newline;
   '(-4.0)*(-3.0) = ' -> puttext;
   -4.0 * (-3.0) -> putreal;
   newline;
   '(-4.0)/8.0 = ' -> puttext;
   -4.0 div 8.0 -> putreal;
   newline;
#)
</BETA>

<H3> The Char Pattern</H3>
<H4> ASCII</H4>
<P> The char pattern enables the manipulation of characters. Characters can be expressed as literals or as the corresponding ASCII values. The pattern Ascii defines all non-printable characters as constants (such as null, nl, cr, esc, del). Newline however, is a variable containing either nl or cr depending on the computer. </P>
<P> <INX>Ascii</INX> also contains local patterns for various conversions and testings of characters. E.g. the patterns IsDigit, IsLetter, IsUpper and IsLower are provided for determining the kind of a character. IsSpace testes whether the character is sp, cr, nl, np, ht or vt. Conversion is available through the upCase and lowCase patterns. </P>
<P> The following example shows how to use char and upCase: </P>
<BETA>
(# a,b: @char
do 'a' -> a; 
   98 -> b;
   (if a -> Ascii.upCase
    // 'A' then ...
    // 'B' then ...
    ...
    if)
#)  
</BETA>

<H3> The Repetition Pattern</H3>
<P> The BETA compiler also implements repetitions. Betaenv contains the repetition pattern, defining the available operations on repetitions (apart from the lookup operation: []). These operations are <INX>range</INX>, <INX>new</INX> and <INX>extend</INX>. Range returns the number of <INX>repetition</INX> positions, new makes it possible to allocate an entire new repetition, and extend is used for dynamically extension of the repetition. Note that the repetition pattern cannot be used as a superpattern:. Also note, that it is only allowed to make repetitions of integer, boolean, char, real, and object references.</P>





