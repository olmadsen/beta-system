<H1> The regexp Library</H1>
<P> The <INX>regexp</INX> library augments the text pattern in betaenv with four new attributes:</P>
<BETA>
regexp_match
regexp_search
regexp_replace
regexp_replace_literally
</BETA>
<P> All four operations give facilities for working with regular expressions in text strings.</P>
<H2> Regular expression</H2>
<P> A <INX>regular expression</INX> (regexp, for short) is a pattern that denotes a set of strings, possibly an infinite set. Searching for matches for a regexp is a very powerful operation that editors on Unix systems have traditionally offered.</P>
<P> Regular expressions are used to locate occurrences of substrings in text, where the substring is expected to be of a certain structure. E.g. the regexp '[Ww]ord' will match the substring 'word' or 'Word'. The four operations offer slightly different possibilities, described below:</P>
<A NAME=HEADING20-10></A>
<H2> <INX>regexp_match</INX></H2>
<P> Takes a regexp as enter parameter (in the form of a reference to a text, containing the regexp. Matches THIS(text) against the regexp. INNER is executed if THIS(text) matches the regexp, and the virtual notification noMatch is invoked otherwise. Returns true if a match is found, false otherwise. The regexp must be found starting at the current position of THIS(text). </P>
<A NAME=HEADING20-12></A>
<H2> regexp_search</H2>
<P>  Like regexp_match, except that the match is allowed to be found anywhere between the current position and the end of THIS(text).</P>
<A NAME=HEADING20-14></A>
<H2><INX>regexp_replace</INX></H2>
<P>  Like regexp_search, except that it takes a second enter parameter, replacement_string. Regexp_replace searches for the regexp, and replaces the matched substring of THIS(text) with the replacement string. The replacement string may contain \0, \1, ..., \9, representing the substring matched by the i'th parenthesis in the regexp. \0 represents the entire substring matched. INNER is executed after the replace has taken place. </P>
<A NAME=HEADING20-16></A>
<H2> <INX>regexp_replace_literally</INX></H2>
<P>  Like regexp_replace, except that the replacement string is taken literally (i.e. \0, \1, etc. are not representing any matched substrings) </P>
<P> </P>
<P> All four regexp operations defines the same local attributes:</P>
<UL>
<LI>start: start position for search in THIS(text). Default: pos
<LI>limit: end position for search in THIS(text). Default: length 
<LI>posToMatchEnd: if true, move THIS(text).pos to the end of the matched substring. Default: false 
<LI>regs: structure for getting access to the matched substring. noMatch: invoked if no matches are found.
<LI>regexpError: is invoked if error occurs in the regexp implementation.
<LI>value: true, if any match is found.
</UL>
<P> Regexp_string are compiled implicitly by the operations to ensure efficient matching in all operations. If the same regexp_string is to be used several times, the repetition of this compilation can be avoided by generating an instance of the operation (say regexp_search), and then use that instance repeatedly (as is illustrated in the following example):</P>
<P> </P>
<BETA>
(# regexp_s: @mytext.regexp_search(# ... #);
do ...
regexp_string[]->regexp_s;(* first search, implicit regexp
compilation *)
...
regexp_s; (* repeating the search with the same regexp.
No regexp compilation *)
...
regexp_s; (* repeating the search with the same regexp.
No regexp compilation *)
...
#)
</BETA>
<A NAME=HEADING20-40></A>
<H2> Syntax of Regular Expressions</H2>
<P> The syntax of regular expressions in this library follows the syntax of Emacs regular expressions.  Some of the documentation below is from the interactive Emacs Info system.</P>
<P> Regular expressions have a syntax in which a few characters are special constructs and the rest are ordinary. An ordinary character is a simple regular expression which matches that character and nothing else. The special characters are '$', '^', '.', '*', '+', '?', '[', ']' and '\'; no new special characters will be defined. Any other character appearing in a regular expression is ordinary, unless a '\' precedes it.</P>
<P> For example, 'f' is not a special character, so it is ordinary, and therefore 'f' is a regular expression that matches the string 'f' and no other string. (It does not match the string 'ff'.) Likewise, 'o' is a regular expression that matches only 'o'.</P>
<P> Any two regular expressions A and B can be concatenated. The result is a regular expression which matches a string if A matches some amount of the beginning of that string and B matches the rest of the string.</P>
<P> As a simple example, we can concatenate the regular expressions 'f' and 'o' to get the regular expression 'fo', which matches only the string 'fo'. Still trivial. To do something nontrivial, you need to use one of the special characters. Here is a list of them.</P>
<H2> List of special characters</H2>
<UL>
<LI>'.' is a special character that matches any single character except a newline. Using concatenation, we can make regular expressions like 'a.b' which matches any three-character string which begins with 'a' and ends with 'b'.
<LI>'*' is not a construct by itself; it is a suffix, which means the preceding regular expression is to be repeated as many times as possible. In 'fo*', the '*' applies to the 'o', so 'fo*' matches one 'f' followed by any number of 'o's. The case of zero 'o's is allowed: 'fo*' does match 'f'.
<LI>'*'  always applies to the smallest possible preceding expression. Thus, 'fo*' has a repeating 'o', not a repeating 'fo'.
<LI>The matcher processes a '*' construct by matching, immediately, as many repetitions as can be found. Then it continues with the rest of the pattern. If that fails, backtracking occurs, discarding some of the matches of the '*'-modified construct in case that makes it possible to match the rest of the pattern. For example, matching 'ca*ar' against the string 'caaar', the 'a*' first tries to match all three 'a's; but the rest of the pattern is 'ar' and there is only 'r' left to match, so this try fails. The next alternative is for 'a*' to match only two 'a's. With this choice, the rest of the regexp matches successfully.
<LI>'+'  Is a suffix character similar to '*' except that it requires that the preceding expression be matched at least once. So, for example, 'ca+r' will match the strings 'car' and 'caaaar' but not the string 'cr', whereas 'ca*r' would match all three strings.
<LI>'?'  Is a suffix character similar to '*' except that it can match the preceding expression either once or not at all. For example, 'ca?r' will match 'car' or 'cr'; nothing else.
<LI>'[...]'  '[' begins a character set, which is terminated by a ']'. In the simplest case, the characters between the two form the set. Thus, '[ad]' matches either one 'a' or one 'd', and '[ad]*' matches any string composed of just 'a's and 'd's (including the empty string), from which it follows that 'c[ad]*r' matches 'cr', 'car', 'cdr', 'caddaar', etc.
<LI>Character ranges can also be included in a character set, by writing two characters with a '-' between them. Thus, '[a-z]' matches any lower-case letter. Ranges may be intermixed freely with individual characters, as in '[a-z$%.]', which matches any lower case letter or '$', '%' or period.
<LI>Note that the usual special characters are not special any more inside a character set. A completely different set of special characters exists inside character sets: ']', '-' and '^'.
<LI>To include a ']' in a character set, you must make it the first character. For example, '[]a]' matches ']' or 'a'. To include a '-', write '--', which is a range containing only '-'. To include '^', make it other than the first character in the set.
<LI>'[^...]' '[^' begins a complement character set, which matches any character except the ones specified. Thus, '[^a-z0-9A-Z]' matches all characters except letters and digits.
<LI>'^' is not special in a character set unless it is the first character. The character following the '^' is treated as if it were first ('-' and ']' are not special there).
<LI>Note that a complement character set can match a newline, unless newline is mentioned as one of the characters not to match.
<LI>'^' is a special character that matches the empty string, but only if at the beginning of a line in the text being matched. Otherwise it fails to match anything. Thus, '^foo' matches a 'foo' which occurs at the beginning of a line.
<LI>'$' is similar to '^' but matches only at the end of a line. Thus, 'xx*$' matches a string of one 'x' or more at the end of a line.
<LI>'\' has two functions: it quotes the special characters (including '\'), and it introduces additional special constructs.
<LI>Because '\' quotes special characters, '\$' is a regular expression which matches only '$', and '\[' is a regular expression which matches only '[', and so on.
<LI>Note, that '\' is also a special character in BETA literals.  This implies, that in order to specify a '\' regexp special character in a BETA string literal, you have to type it twice, e.g. 'US\\$'.
</UL>
<P> Note: for historical compatibility, special characters are treated as ordinary ones if they are in contexts where their special meanings make no sense. For example, '*foo' treats '*' as ordinary since there is no preceding expression on which the '*' can act. It is poor practice to depend on this behavior; better to quote the special character anyway, regardless of where is appears.</P>
<P> For the most part, '\' followed by any character matches only that character. However, there are several exceptions: characters which, when preceded by '\', are special constructs. Such characters are always ordinary when encountered on their own. Here is a table of '\' constructs.</P>
<H2> Table of '\' constructs</H2>
<UL>
<LI>'\|' specifies an alternative. Two regular expressions A and B with '\|' in between form an expression that matches anything that either A or B will match.
<LI>Thus, 'foo\|bar' matches either 'foo' or 'bar' but no other string.
<LI>'\|' applies to the largest possible surrounding expressions. Only a surrounding '\( ... \)' grouping can limit the grouping power of '\|'.
<LI>Full backtracking capability exists to handle multiple uses of '\|'.
<LI>'\(...\)' is a grouping construct that serves three purposes:
<UL>
<LI>To enclose a set of '\|' alternatives for other operations. Thus, '\(foo\|bar\)x' matches either 'foox' or 'barx'.
<LI>To enclose a complicated expression for the postfix '*' to operate on. Thus, 'ba\(na\)*' matches 'bananana', etc., with any (zero or more) number of 'na' strings.
<LI>To mark a matched substring for future reference.
</UL>
<LI>This last application is not a consequence of the idea of a parenthetical grouping; it is a separate feature which happens to be assigned as a second meaning to the same '\( ... \)' construct because there is no conflict in practice between the two meanings. Here is an explanation of this feature:
<LI>'\DIGIT' after the end of a '\( ... \)' construct, the matcher remembers the beginning and end of the text matched by that construct. Then, later on in the regular expression, you can use '\' followed by DIGIT to mean 'match the same text matched the DIGIT'th time by the '\( ... \)' construct.'
<LI>The strings matching the first nine '\( ... \)' constructs appearing in a regular expression are assigned numbers 1 through 9 in order that the open-parentheses appear in the regular expression. '\1' through '\9' may be used to refer to the text matched by the corresponding '\( ... \)' construct.
<LI>For example, '\(.*\)\1' matches any newline-free string that is composed of two identical halves. The '\(.*\)' matches the first half, which may be anything, but the '\1' that follows must match the same exact text.
<LI>'\'' matches the empty string, provided it is at the beginning of the buffer.
<LI>'\'' matches the empty string, provided it is at the end of the buffer.
<LI>'\b' matches the empty string, provided it is at the beginning or end of a word. Thus, '\bfoo\b' matches any occurrence of 'foo' as a separate word. '\bballs?\b' matches 'ball' or 'balls' as a separate word.
<LI>'\B' matches the empty string, provided it is not at the beginning or end of a word.
<LI>'\&lt;' matches the empty string, provided it is at the beginning of a word.
<LI>'\&gt;' matches the empty string, provided it is at the end of a word.
<LI>'\w' matches any word-constituent character. The editor syntax table determines which characters these are.
<LI>'\W'  matches any character that is not a word-constituent.
<LI>'\sCODE' matches any character whose syntax is CODE. CODE is a character which represents a syntax code: thus, 'w' for word constituent, '-' for whitespace, '(' for open-parenthesis, etc.
<LI>'\SCODE' matches any character whose syntax is not CODE.
</UL>
<H2> A complicated regexp</H2>
<P> Here is a complicated regexp, used to recognize the end of a sentence together with any whitespace that follows. It is given in BETA text string syntax to enable you to distinguish the spaces from the tab characters. In BETA text string syntax, the string constant begins and ends with a double-quote. '&quot;&quot;' stands for a double-quote as part of the regexp, '\\' for a backslash as part of the regexp, '\t' for a tab and '\n' for a newline.</P>
<BETA>
"[.?!][]""')]*\\($\\|\t\\| \\)[ \t\n]*"
</BETA>
<P> This contains four parts in succession: a character set matching period, '?' or '!'; a character set matching close-brackets, quotes or parentheses, repeated any number of times; an alternative in backslash-parentheses that matches end-of-line, a tab or two spaces; and a character set matching whitespace characters, repeated any number of times.</P>





