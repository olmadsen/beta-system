<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd"
>
<HTML>
<!-- Autogenerated file - do not edit -->
<HEAD>
<META http-equiv="Content-Type" CONTENT="text/html; CHARSET=ISO-8859-1">
<TITLE>Bifrost Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">

<SCRIPT TYPE="text/javascript" LANGUAGE="JavaScript" SRC="../../javascript/hashfromparent.js"></SCRIPT>
<BASE TARGET="_parent">
</HEAD>
<BODY onLoad='HashFromParent("Bifrost")'>
<H1><A name="Bifrost">Bifrost Interface</A></H1>

<PRE CLASS=interface>
ORIGIN '~beta/guienv/guienv';
LIB_DEF 'bifrost' '../lib';
BODY 'private/Impl/BifrostImpl';
INCLUDE '~beta/containers/list';
INCLUDE '~beta/basiclib/math';

(* Bifrost - An Interactive Object Oriented Device 
 * Independent Graphics System
 *
 * Refer to   DAIMI IR-100 - Internal Report
 *            Computer Science Department
 *            Aarhus University, Denmark
 *                                      
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1990-94
 *       All rights reserved.
 *)

</PRE><P><HR><P><H2><A name="Various Simple Definitions">Various Simple Definitions</A></H2><PRE CLASS=interface>
-- BifrostAttributes: attributes --
(* Specifications used to test for key and/or pointer modification *)
<B>Modifier</B><A name="Modifier.1(1)"></A>: 
  (# m: @Integer; enter m do INNER exit m #);
<B>NoModifier</B><A name="NoModifier.1(2)"></A>: Modifier
  (# ... #);
<B>ShiftModifier</B><A name="ShiftModifier.1(3)"></A>: Modifier
  (# ... #);
<B>ControlModifier</B><A name="ControlModifier.1(4)"></A>: Modifier
  (# ... #);
<B>LockModifier</B><A name="LockModifier.1(5)"></A>: Modifier
  (# ... #);
<B>MetaModifier</B><A name="MetaModifier.1(6)"></A>: Modifier
  (# ... #);
<B>CommandModifier</B><A name="CommandModifier.1(7)"></A>: Modifier
  (# ... #);

(* Constants used to specify fill rules *)
<B>EvenOddRule</B><A name="EvenOddRule.1(8)"></A>: (# exit 0 #);
<B>WindingRule</B><A name="WindingRule.1(9)"></A>: (# exit 1 #);

(* Cap styles *)
<B>CapStyleDesc</B><A name="CapStyleDesc.1(10)"></A>: (# s: @integer; enter s do INNER exit s #);

<B>CapButt</B><A name="CapButt.1(11)"></A>: CapStyleDesc(# ... #);
<B>CapRounded</B><A name="CapRounded.1(12)"></A>: CapStyleDesc(# ... #);
<B>CapSquare</B><A name="CapSquare.1(13)"></A>: CapStyleDesc(# ... #);

(* Join styles *)
<B>JoinStyleDesc</B><A name="JoinStyleDesc.1(14)"></A>: (# s: @integer; enter s do INNER exit s #);
<B>JoinMiter</B><A name="JoinMiter.1(15)"></A>: JoinStyleDesc(# ... #);
<B>JoinRound</B><A name="JoinRound.1(16)"></A>: JoinStyleDesc(# ... #);
<B>JoinBevel</B><A name="JoinBevel.1(17)"></A>: JoinStyleDesc(# ... #);

(* Fontnames to use in TextShape and GraphicText *)
<B>fontName</B><A name="fontName.1(18)"></A>: integerObject(# do INNER #);
<B>Courier</B><A name="Courier.1(19)"></A>: fontname(# ... #);
<B>Times</B><A name="Times.1(20)"></A>: fontname(# ... #);
<B>Helvetica</B><A name="Helvetica.1(21)"></A>: fontname(# ... #);

(* Styles to use in TextShape and GraphicText *)
<B>Style</B><A name="Style.1(22)"></A>: integerObject(# do INNER #);
<B>Plain</B><A name="Plain.1(23)"></A>: Style(# ... #);
<B>Italic</B><A name="Italic.1(24)"></A>: Style(# ... #);
<B>Bold</B><A name="Bold.1(25)"></A>: Style(# ... #);

<B>MaxRGB</B><A name="MaxRGB.1(26)"></A>: (* The upper limit for the range of RGB values *)
  (# max: @Integer
    ... (* Device dependent *)
  exit max
  #);

(* Constants specifying the range for hue, saturation and value *)
<B>DefaultMaxHue</B><A name="DefaultMaxHue.1(27)"></A>: (# exit 360 #);
<B>DefaultMaxSat</B><A name="DefaultMaxSat.1(28)"></A>: (# exit 32768 #); (* (2^15) *)
<B>DefaultMaxVal</B><A name="DefaultMaxVal.1(29)"></A>: (# exit 32768 #); (* (2^15) *)

<B>UnImplemented</B><A name="UnImplemented.1(30)"></A>:
  (* Used to notify the user on features, that are not yet 
   * implemented in Bifrost.
   *)
  (# feature: ^text
  enter feature[]
  ...
  #);
<B>DebugGraphic</B><A name="DebugGraphic.1(31)"></A>: (# exit false #);

</PRE><P><HR><P><H2><A name="Mathematics">Mathematics</A></H2><PRE CLASS=interface>
<B>Point</B><A name="Point.1(32)"></A>: 
  (# <B>x</B><A name="Point.1.x.2(33)"></A><A name="x.2(33)"></A>,<B> y</B><A name="Point.1.y.2(34)"></A><A name="y.2(34)"></A>: @integer;
  enter (x,y)
  exit (x,y)
  #);
<B>Vector</B><A name="Vector.1(35)"></A>: 
  (# <B>x</B><A name="Vector.1.x.2(36)"></A><A name="x.2(36)"></A>,<B>y</B><A name="Vector.1.y.2(37)"></A><A name="y.2(37)"></A>: @Real;
  enter (x,y)
  exit (x,y)
  #);
<B>Rectangle</B><A name="Rectangle.1(38)"></A>: 
  (# <B>x</B><A name="Rectangle.1.x.2(39)"></A><A name="x.2(39)"></A>,<B>y</B><A name="Rectangle.1.y.2(40)"></A><A name="y.2(40)"></A>: @Integer (* Upper left *);
     <B>width</B><A name="Rectangle.1.width.2(41)"></A><A name="width.2(41)"></A>,<B>height</B><A name="Rectangle.1.height.2(42)"></A><A name="height.2(42)"></A>: @Integer
  enter (x,y,width,height)
  exit (x,y,width,height)
  #);
<B>EqualPoint</B><A name="EqualPoint.1(43)"></A>: 
  (# p1,p2: @Point;
  enter (p1,p2)
  exit (p1.x=p2.x) and (p1.y=p2.y)
  #);
<B>AddPoints</B><A name="AddPoints.1(44)"></A>: 
  (# p1,p2: @Point;
  enter (p1,p2)
  exit (p1.x+p2.x,p1.y+p2.y)
  #);
<B>SubPoints</B><A name="SubPoints.1(45)"></A>: 
  (# p1,p2: @Point;
  enter (p1,p2)
  exit (p1.x-p2.x,p1.y-p2.y)
  #);
<B>ExpandRectangle</B><A name="ExpandRectangle.1(46)"></A>: 
  (# r: @rectangle;
     e: @integer;
  enter (r,e)
  exit (r.x-e, r.y+e, r.width+2*e, r.height+2*e)
  #);
<B>PointInRect</B><A name="PointInRect.1(47)"></A>: 
  (# p: @Point;
     r: @Rectangle;
  enter (p,r)
  exit   ((r.x &lt;= p.x) and (p.x &lt;= r.x+r.width) and
     (r.y &gt;= p.y) and (p.y &gt;= r.y-r.height))
  #);
<B>Matrix</B><A name="Matrix.1(48)"></A>: 
  (# <B>a</B><A name="Matrix.1.a.2(49)"></A><A name="a.2(49)"></A>,<B>b</B><A name="Matrix.1.b.2(50)"></A><A name="b.2(50)"></A>,<B>c</B><A name="Matrix.1.c.2(51)"></A><A name="c.2(51)"></A>,<B>d</B><A name="Matrix.1.d.2(52)"></A><A name="d.2(52)"></A>,<B>tx</B><A name="Matrix.1.tx.2(53)"></A><A name="tx.2(53)"></A>,<B>ty</B><A name="Matrix.1.ty.2(54)"></A><A name="ty.2(54)"></A>: @Real;
     (*   a  b  0
      *   c  d  0
      *   tx ty 1
      *)
     <B>set</B><A name="Matrix.1.set.2(55)"></A><A name="set.2(55)"></A>: 
       (# enter (a,b,c,d,tx,ty) #);
     <B>invalidate</B><A name="Matrix.1.invalidate.2(56)"></A><A name="invalidate.2(56)"></A>:
       (* Call invalidate if you manipulate a, b, c, d, tx, or ty *)
       ...;
     <B>transformPoint</B><A name="Matrix.1.transformPoint.2(57)"></A><A name="transformPoint.2(57)"></A>: @
       (# p,result: @Point;
       enter p
       ...
       exit result
       #);
     <B>inverseTransformPoint</B><A name="Matrix.1.inverseTransformPoint.2(58)"></A><A name="inverseTransformPoint.2(58)"></A>: @
       (# p1,p2: @Point;
       enter p1
       ...
       exit p2
       #);
     <B>transformRectangle</B><A name="Matrix.1.transformRectangle.2(59)"></A><A name="transformRectangle.2(59)"></A>: @
       (# r,result: @Rectangle;
       enter r
       do ...
       exit result
       #);
     <B>inverseTransformRectangle</B><A name="Matrix.1.inverseTransformRectangle.2(60)"></A><A name="inverseTransformRectangle.2(60)"></A>: 
       (# r,result: @Rectangle;
       enter r
       ...
       exit result
       #);
     <B>getInverse</B><A name="Matrix.1.getInverse.2(61)"></A><A name="getInverse.2(61)"></A>: @
       (# get: @...;
          inverse: ^Matrix;
       do get;
       exit inverse[]
       #);
     <B>private</B><A name="Matrix.1.private.2(62)"></A><A name="private.2(62)"></A>: @...;
  do INNER;
  exit (a,b,c,d,tx,ty)
  #);
<B>IDMatrix</B><A name="IDMatrix.1(63)"></A>:
  (* Exit an identity matrix *)
  (# ID: ^Matrix 
  ...
  exit ID[]
  #);
<B>MoveMatrix</B><A name="MoveMatrix.1(64)"></A>: Matrix   (* A matrix specifying a translation *)
  (# itx,ity: @Integer;
  enter (itx,ity)
  ...
  #);
<B>ScaleMatrix</B><A name="ScaleMatrix.1(65)"></A>: Matrix  (* A matrix specifying a scaling *)
  (# 
  enter (a,d)
  ...
  #);
<B>RotateMatrix</B><A name="RotateMatrix.1(66)"></A>: Matrix (* A matrix specifying a rotation *)
  (# theta: @Real;
  enter theta
  ...
  #);
<B>MatrixMul</B><A name="MatrixMul.1(67)"></A>: (* Multiply two matrices *)
  (# A,B,res: ^Matrix;
  enter (A[],B[])
  ...
  exit res[]
  #);
<B>EllipseAngle</B><A name="EllipseAngle.1(68)"></A>: 
  (* Returns the angle a (in radians) and cos(a), sin(a), 
   * assuming that (x,y) is a point on the ellipse with center in
   * (cx,cy) and horizontal radius hr and verticalradius vr,
   * i.e. (x,y) = (cx,cy) + (hr*cos(a),vr*sin(a))
   *)
  (# cx, cy, hr, vr, x, y: @integer;
     a, cos_a, sin_a: @real;
     angle: @...;
  enter (cx, cy, hr, vr, x, y)
  do angle
  exit (a, cos_a, sin_a)
  #);
<B>CircleAngle</B><A name="CircleAngle.1(69)"></A>: 
  (* Returns the angle a (in radians) and cos(a), sin(a), 
   * assuming that (x,y) is a point on the circle with center in
   * (cx,cy) and radius r, for some r
   * i.e. (x,y) = (cx,cy) + (r*cos(a),r*sin(a))
   *)
  (# cx, cy, x, y: @integer;
     a, cos_a, sin_a: @real;
     angle: @...;
  enter (cx, cy, x, y)
  do angle
  exit (a, cos_a, sin_a)
  #);
</PRE><P><HR><P><H2><A name="Datatypes">Datatypes</A></H2><PRE CLASS=interface>
<B>PointArray</B><A name="PointArray.1(70)"></A>: (* Array of points, extended when needed *)
  (# &lt;&lt;SLOT PointArrayAttributes: Attributes &gt;&gt;;
     
     <B>npoints</B><A name="PointArray.1.npoints.2(71)"></A><A name="npoints.2(71)"></A>: @Integer
       (* Number of points currently in THIS(PointArray) *);
     
     <B>initPoints</B><A name="PointArray.1.initPoints.2(72)"></A><A name="initPoints.2(72)"></A>: (* Must be called first *)
       (# initialsize: @integer;
       enter initialsize
       do ...;
       #);
     <B>copy</B><A name="PointArray.1.copy.2(73)"></A><A name="copy.2(73)"></A>: (* Return a deep copy of THIS(PointArray) *)
       (# p: ^PointArray;
       ...
       exit p[]
       #);
     <B>scanPoints</B><A name="PointArray.1.scanPoints.2(74)"></A><A name="scanPoints.2(74)"></A>:
       (* scan the points in THIS(PointArray).  Inx will be the index
        * of current
        *)
       (# current: ^Point; inx: @integer
         ...
       #);
     <B>addPoint</B><A name="PointArray.1.addPoint.2(75)"></A><A name="addPoint.2(75)"></A>: @(* Add p as the last point in THIS(PointArray) *)
       (# p: @Point; 
       enter p
       do ...;
       #);
     <B>deletePoint</B><A name="PointArray.1.deletePoint.2(76)"></A><A name="deletePoint.2(76)"></A>: @(* delete the i'th point in THIS(PointArray) *)
       (# i: @Integer; 
       enter i
       do ...;
       #);
     <B>insertPoint</B><A name="PointArray.1.insertPoint.2(77)"></A><A name="insertPoint.2(77)"></A>: @(* insert p between the i'th and i+1'th point in THIS(PointArray) *)
       (# i: @Integer; p: @Point; 
       enter (p, i)
       do ...;
       #);
     <B>getPoint</B><A name="PointArray.1.getPoint.2(78)"></A><A name="getPoint.2(78)"></A>: @
       (* Return point no i in THIS(PointArray); 1&lt;=i&lt;=npoints *)
       (# i: @Integer;
          p: @Point;
       enter i
       ...
       exit p
       #);
     <B>setPoint</B><A name="PointArray.1.setPoint.2(79)"></A><A name="setPoint.2(79)"></A>: @
       (* Change the value of point no i to p; 1&lt;=i&lt;=npoints *)
       (# i: @Integer;
          p: @Point;
       enter (p,i)
       do ...;
       #);
     <B>firstPoint</B><A name="PointArray.1.firstPoint.2(80)"></A><A name="firstPoint.2(80)"></A>: @(* Return first point of THIS(PointArray) *)
       (# exitPoint: @Point;
       ...
       exit exitPoint
       #);
     <B>lastPoint</B><A name="PointArray.1.lastPoint.2(81)"></A><A name="lastPoint.2(81)"></A>: @(* Return last point of THIS(PointArray) *)
       (# exitPoint: @Point;
       ...
       exit exitPoint
       #);
     
     <B>private</B><A name="PointArray.1.private.2(82)"></A><A name="private.2(82)"></A>: @...;
  #);

<B>TextList</B><A name="TextList.1(83)"></A>: list
  (# <B>element</B><A name="TextList.1.element.2(84)"></A><A name="element.2(84)"></A>:: Text;
     <B>copy</B><A name="TextList.1.copy.2(85)"></A><A name="copy.2(85)"></A>:&lt;
       (# c: ^TextList;
       ...
       exit c[]
       #);
  do INNER;
  #);

<B>IntegerList</B><A name="IntegerList.1(86)"></A>: list
  (# <B>IntegerElement</B><A name="IntegerList.1.IntegerElement.2(87)"></A><A name="IntegerElement.2(87)"></A>: (# i: @integer #);
     <B>element</B><A name="IntegerList.1.element.2(88)"></A><A name="element.2(88)"></A>:: IntegerElement;
  #);

<B>PointArrayList</B><A name="PointArrayList.1(89)"></A>: (* List of PointArrays, used internally *)
  (#
     <B>private</B><A name="PointArrayList.1.private.2(90)"></A><A name="private.2(90)"></A>: @...;
     <B>appendPointArray</B><A name="PointArrayList.1.appendPointArray.2(91)"></A><A name="appendPointArray.2(91)"></A>: 
       (# p: ^PointArray;
       enter p[]
       ... 
       #);
     <B>scanPointArrays</B><A name="PointArrayList.1.scanPointArrays.2(92)"></A><A name="scanPointArrays.2(92)"></A>: 
       (# p: ^PointArray;
       ... 
       #);
     <B>empty</B><A name="PointArrayList.1.empty.2(93)"></A><A name="empty.2(93)"></A>: booleanValue 
       (# ... #);
  #);

</PRE><P><HR><P><H2><A name="Segment">Segment</A></H2><PRE CLASS=interface>
<B>Segment</B><A name="Segment.1(94)"></A>: 
  (# &lt;&lt;SLOT SegmentAttributes: attributes&gt;&gt;;
     
     <B>firstPoint</B><A name="Segment.1.firstPoint.2(95)"></A><A name="firstPoint.2(95)"></A>:&lt; (# p: @Point do INNER exit p #);
     <B>lastPoint</B><A name="Segment.1.lastPoint.2(96)"></A><A name="lastPoint.2(96)"></A>:&lt; (# p: @Point do INNER exit p#);
     <B>setFirstPoint</B><A name="Segment.1.setFirstPoint.2(97)"></A><A name="setFirstPoint.2(97)"></A>:&lt; (# p: @Point enter p do INNER #);
     <B>setLastPoint</B><A name="Segment.1.setLastPoint.2(98)"></A><A name="setLastPoint.2(98)"></A>:&lt; (# p: @Point enter p do INNER #);
     <B>nextToFirstPoint</B><A name="Segment.1.nextToFirstPoint.2(99)"></A><A name="nextToFirstPoint.2(99)"></A>:&lt; (# p: @Point do INNER exit p #);
     <B>nextToLastPoint</B><A name="Segment.1.nextToLastPoint.2(100)"></A><A name="nextToLastPoint.2(100)"></A>:&lt; (# p: @Point do INNER exit p #);
     <B>copy</B><A name="Segment.1.copy.2(101)"></A><A name="copy.2(101)"></A>:&lt; (* Returns a deep copy of THIS(Segment) *)
       (# aCopy: ^Segment;
       ...
       exit aCopy[]
       #);
     <B>transform</B><A name="Segment.1.transform.2(102)"></A><A name="transform.2(102)"></A>:&lt;
       (* Transform all control points in THIS(Segment) by M *)
       (# M: ^Matrix enter M[] do INNER #);
     <B>reverseOrientation</B><A name="Segment.1.reverseOrientation.2(103)"></A><A name="reverseOrientation.2(103)"></A>:&lt; object;
     
     (* INTERACTION *)
     <B>drawRubberBand</B><A name="Segment.1.drawRubberBand.2(104)"></A><A name="drawRubberBand.2(104)"></A>:&lt; 
       (* Draw an thin curve along THIS(Segment).  Useful when
        * drawing rubber feedback
        *) 
       (# theCanvas: ^BifrostCanvas
            (* The BifrostCanvas to draw the rubberband on *);
          newPoint: @Point;
          theGOToDevice: ^Matrix;
          controlIndex: @Integer;
          nextSeg: ^Segment;
       enter 
          (theCanvas[],theGOToDevice[],
          newPoint,controlIndex,nextSeg[])
       do INNER
       #);
     <B>getControls</B><A name="Segment.1.getControls.2(105)"></A><A name="getControls.2(105)"></A>:&lt; 
       (* Add all the defining points in THIS(Segment) to spots.  If
        * spots[] is NONE, a PointArray is instantiated.  canvasTM is
        * applied to all controls before they are appended to spots.
        * If canvasTM[] is NONE, IDmatrix is used.
        *)
       (# spots: ^PointArray;
          canvasTM: ^Matrix;
       enter (spots[], canvasTM[])
       ... 
       exit spots[]
       #);
     
     (* PRIVATE, but virtual and hence cannot be in slots *)
     <B>prepareReshape</B><A name="Segment.1.prepareReshape.2(106)"></A><A name="prepareReshape.2(106)"></A>:&lt; (* private *)
       (# theGOToDevice: ^Matrix;
          controlIndex: @Integer;
          nextSeg: ^Segment;
          movingp: @Point;
          theCanvas: ^BifrostCanvas;
       enter (theCanvas[],theGOToDevice[],controlIndex,nextSeg[])
       do INNER;
       #);
     <B>endReshape</B><A name="Segment.1.endReshape.2(107)"></A><A name="endReshape.2(107)"></A>:&lt; (* private *)
       (# theGOToDevice: ^Matrix;
          finalPoint: @Point;
          controlIndex: @Integer;
          nextSeg: ^Segment;
          theCanvas: ^BifrostCanvas;
       enter 
          (theCanvas[],theGOToDevice[],finalPoint,controlIndex,nextSeg[])
       do INNER;
       #);
     <B>findSegments</B><A name="Segment.1.findSegments.2(108)"></A><A name="findSegments.2(108)"></A>:&lt; (* private *)
       (# p: @point;
          s1,s2: ^Segment;
          controlIndex: @Integer;
       enter p
       do INNER
       exit (s1[],s2[],controlIndex)
       #);
     <B>calculatePoints</B><A name="Segment.1.calculatePoints.2(109)"></A><A name="calculatePoints.2(109)"></A>:&lt; (* private *)
       (# thePoints: ^PointArray;
          thePointList: ^PointArrayList;
       enter (thePoints[],thePointList[])
       do INNER;
       exit thePointList[]
       #);
     <B>makeOffset</B><A name="Segment.1.makeOffset.2(110)"></A><A name="makeOffset.2(110)"></A>:&lt; (* private *)
       (# nextPoint: @Point;
          offsets: ^PointArray;
          width: @Integer;
       enter (offsets[],nextPoint)
       do INNER;
       #);
     <B>makeSecondOffset</B><A name="Segment.1.makeSecondOffset.2(111)"></A><A name="makeSecondOffset.2(111)"></A>:&lt; (* private *)
       (# theShape: ^Shape;
          index: @Integer;
          offsets: ^PointArray;
       enter (theShape[],offsets[],index)
       do INNER;
       exit index
       #);
     <B>writePS</B><A name="Segment.1.writePS.2(112)"></A><A name="writePS.2(112)"></A>:&lt;(# out: ^stream enter out[] do INNER #);
  do INNER;
  exit THIS(Segment)[]
  #);

</PRE><P><HR><P><H2><A name="Line- and Spline Segments">Line- and Spline Segments</A></H2><PRE CLASS=interface>
<B>LineSegment</B><A name="LineSegment.1(113)"></A>: Segment
  (# 
     <B>begin</B><A name="LineSegment.1.begin.2(114)"></A><A name="begin.2(114)"></A>,<B>end</B><A name="LineSegment.1.end.2(115)"></A><A name="end.2(115)"></A>: @Point;
     <B>firstPoint</B><A name="LineSegment.1.firstPoint.2(116)"></A><A name="firstPoint.2(116)"></A>::&lt; (# do begin -&gt; p #);
     <B>lastPoint</B><A name="LineSegment.1.lastPoint.2(117)"></A><A name="lastPoint.2(117)"></A>::&lt; (# do end -&gt; p #);
     <B>setFirstPoint</B><A name="LineSegment.1.setFirstPoint.2(118)"></A><A name="setFirstPoint.2(118)"></A>::&lt; (# do p -&gt; begin #);
     <B>setLastPoint</B><A name="LineSegment.1.setLastPoint.2(119)"></A><A name="setLastPoint.2(119)"></A>::&lt; (# do p -&gt; end #);
     <B>nextToFirstPoint</B><A name="LineSegment.1.nextToFirstPoint.2(120)"></A><A name="nextToFirstPoint.2(120)"></A>::&lt; (# do end -&gt; p; #);
     <B>nextToLastPoint</B><A name="LineSegment.1.nextToLastPoint.2(121)"></A><A name="nextToLastPoint.2(121)"></A>::&lt; (# do begin -&gt; p #);
     
     <B>copy</B><A name="LineSegment.1.copy.2(122)"></A><A name="copy.2(122)"></A>::&lt; (# do INNER; ... #);
     <B>transform</B><A name="LineSegment.1.transform.2(123)"></A><A name="transform.2(123)"></A>::&lt; (# ... #);
     <B>reverseOrientation</B><A name="LineSegment.1.reverseOrientation.2(124)"></A><A name="reverseOrientation.2(124)"></A>::&lt; (# ... #);
     
     (* INTERACTION *)
     <B>drawRubberBand</B><A name="LineSegment.1.drawRubberBand.2(125)"></A><A name="drawRubberBand.2(125)"></A>::&lt; (# ... #);
     <B>getControls</B><A name="LineSegment.1.getControls.2(126)"></A><A name="getControls.2(126)"></A>::&lt;(# ... #);
     
     (* PRIVATE, but virtual and hence cannot be in slots *)
     <B>writePS</B><A name="LineSegment.1.writePS.2(127)"></A><A name="writePS.2(127)"></A>::&lt;(# do ... #);
     <B>prepareReshape</B><A name="LineSegment.1.prepareReshape.2(128)"></A><A name="prepareReshape.2(128)"></A>::&lt; (* private *)
       (# ... #);
     <B>endReshape</B><A name="LineSegment.1.endReshape.2(129)"></A><A name="endReshape.2(129)"></A>::&lt; (* private *)
       (# ... #);
     <B>findSegments</B><A name="LineSegment.1.findSegments.2(130)"></A><A name="findSegments.2(130)"></A>::&lt; (* private *)
       (# ... #);
     <B>calculatePoints</B><A name="LineSegment.1.calculatePoints.2(131)"></A><A name="calculatePoints.2(131)"></A>::&lt; (* private *)
       (# ... #);
     <B>makeOffset</B><A name="LineSegment.1.makeOffset.2(132)"></A><A name="makeOffset.2(132)"></A>::&lt; (* private *)
       (# do ... #);
     <B>makeSecondOffset</B><A name="LineSegment.1.makeSecondOffset.2(133)"></A><A name="makeSecondOffset.2(133)"></A>::&lt; (* private *)
       (# do ... #);
  #);

</PRE><P><HR><P><H2><A name="Splinesegment">Splinesegment</A></H2><PRE CLASS=interface>
<B>SplineSegment</B><A name="SplineSegment.1(134)"></A>: Segment  (* abstract pattern *)
  (# &lt;&lt;SLOT SplineAttributes: Attributes &gt;&gt;;
     
     <B>controls</B><A name="SplineSegment.1.controls.2(135)"></A><A name="controls.2(135)"></A>: ^PointArray;
     <B>smoothness</B><A name="SplineSegment.1.smoothness.2(136)"></A><A name="smoothness.2(136)"></A>: @Real 
       (* default 1.0 decrease to get a smoother spline increase to
        * get a coarser spline
        *);
     
     <B>firstPoint</B><A name="SplineSegment.1.firstPoint.2(137)"></A><A name="firstPoint.2(137)"></A>::&lt; (# ... #);
     <B>lastPoint</B><A name="SplineSegment.1.lastPoint.2(138)"></A><A name="lastPoint.2(138)"></A>::&lt; (# ... #);
     <B>setFirstPoint</B><A name="SplineSegment.1.setFirstPoint.2(139)"></A><A name="setFirstPoint.2(139)"></A>::&lt; (# ... #);
     <B>setLastPoint</B><A name="SplineSegment.1.setLastPoint.2(140)"></A><A name="setLastPoint.2(140)"></A>::&lt; (# ... #);
     <B>nextToFirstPoint</B><A name="SplineSegment.1.nextToFirstPoint.2(141)"></A><A name="nextToFirstPoint.2(141)"></A>::&lt;(# ... #);
     
     <B>open</B><A name="SplineSegment.1.open.2(142)"></A><A name="open.2(142)"></A>:&lt; 
       (* Prepare THIS(SplineSegment) for adding control points *)
       (# startPoint: @Point;
       enter startPoint
       ...
       #);
     <B>addControl</B><A name="SplineSegment.1.addControl.2(143)"></A><A name="addControl.2(143)"></A>:&lt; 
       (* Add p as a control point in THIS(SplineSegment) *)
       (# p: @Point;
       enter p ...
       #);
     <B>insert</B><A name="SplineSegment.1.insert.2(144)"></A><A name="insert.2(144)"></A>:&lt; 
       (* Insert p as a control point after the control point at
        * position index
        *) 
       (# p: @point;
          index: @integer;
       enter (p,index)
       do INNER
       #);
     <B>delete</B><A name="SplineSegment.1.delete.2(145)"></A><A name="delete.2(145)"></A>:&lt; 
       (* Delete the control point at position index *)
       (# index: @integer;
       enter index
       do INNER
       #);
     <B>copy</B><A name="SplineSegment.1.copy.2(146)"></A><A name="copy.2(146)"></A>::&lt; (# do INNER; ... #);
     <B>transform</B><A name="SplineSegment.1.transform.2(147)"></A><A name="transform.2(147)"></A>::&lt; (# ... #);
     <B>reverseOrientation</B><A name="SplineSegment.1.reverseOrientation.2(148)"></A><A name="reverseOrientation.2(148)"></A>::&lt; (# do ... #);
     
     (* PRIVATE *)
     <B>writePS</B><A name="SplineSegment.1.writePS.2(149)"></A><A name="writePS.2(149)"></A>::&lt;(# do ... #);
     <B>prepareReshape</B><A name="SplineSegment.1.prepareReshape.2(150)"></A><A name="prepareReshape.2(150)"></A>::&lt; (* private *)
       (# ... #);
     <B>endReshape</B><A name="SplineSegment.1.endReshape.2(151)"></A><A name="endReshape.2(151)"></A>::&lt; (* private *)
       (# ... #);
     <B>DrawRubberSplineDesc</B><A name="SplineSegment.1.DrawRubberSplineDesc.2(152)"></A><A name="DrawRubberSplineDesc.2(152)"></A>:&lt; (* private *)
       (# track: @Point;
          controlIndex: @Integer;
          theCanvas: ^BifrostCanvas;
       enter (theCanvas[],track,controlIndex)
       do INNER
       #);
     <B>calculatePoints</B><A name="SplineSegment.1.calculatePoints.2(153)"></A><A name="calculatePoints.2(153)"></A>::&lt; (* private *)
       (# splinePoints: ^PointArray;
       ...
       #);
     <B>splineprivate</B><A name="SplineSegment.1.splineprivate.2(154)"></A><A name="splineprivate.2(154)"></A>: @...;
     
  do INNER;
  #); (* SplineSegment *)

</PRE><P><HR><P><H2><A name="CircularSplineSegment">CircularSplineSegment</A></H2><PRE CLASS=interface>
<B>CircularSplineSegment</B><A name="CircularSplineSegment.1(155)"></A>: SplineSegment
  (# <B>nextToLastPoint</B><A name="CircularSplineSegment.1.nextToLastPoint.2(156)"></A><A name="nextToLastPoint.2(156)"></A>::&lt; (# ... #);
     <B>copy</B><A name="CircularSplineSegment.1.copy.2(157)"></A><A name="copy.2(157)"></A>::&lt;(# do ... #);
     <B>drawRubberBand</B><A name="CircularSplineSegment.1.drawRubberBand.2(158)"></A><A name="drawRubberBand.2(158)"></A>::&lt; (# ... #);
     
     (* PRIVATE *)
     <B>writePS</B><A name="CircularSplineSegment.1.writePS.2(159)"></A><A name="writePS.2(159)"></A>::&lt;(# do ... #);
     <B>DrawRubberSplineDesc</B><A name="CircularSplineSegment.1.DrawRubberSplineDesc.2(160)"></A><A name="DrawRubberSplineDesc.2(160)"></A>::&lt; (* private *)
       (# do ... #);
     <B>findSegments</B><A name="CircularSplineSegment.1.findSegments.2(161)"></A><A name="findSegments.2(161)"></A>::&lt; (* private *)
       (# ... #);
     <B>calculatePoints</B><A name="CircularSplineSegment.1.calculatePoints.2(162)"></A><A name="calculatePoints.2(162)"></A>::&lt; (* private *)
       (# ... #);
     <B>getControls</B><A name="CircularSplineSegment.1.getControls.2(163)"></A><A name="getControls.2(163)"></A>::&lt; (* private *)
       (# ... #);
     <B>makeOffset</B><A name="CircularSplineSegment.1.makeOffset.2(164)"></A><A name="makeOffset.2(164)"></A>::&lt; (* private *)
       (# do ... #);
     <B>makeSecondOffset</B><A name="CircularSplineSegment.1.makeSecondOffset.2(165)"></A><A name="makeSecondOffset.2(165)"></A>::&lt; (* private *)
       (# do ... #);
  do INNER;
  #);

</PRE><P><HR><P><H2><A name="NoncircularSplineSegment">NoncircularSplineSegment</A></H2><PRE CLASS=interface>
<B>NonCircularSplineSegment</B><A name="NonCircularSplineSegment.1(166)"></A>: SplineSegment
  (# <B>nextToLastPoint</B><A name="NonCircularSplineSegment.1.nextToLastPoint.2(167)"></A><A name="nextToLastPoint.2(167)"></A>::&lt; (# ... #);
     <B>copy</B><A name="NonCircularSplineSegment.1.copy.2(168)"></A><A name="copy.2(168)"></A>::&lt; (# do ... #);
     <B>close</B><A name="NonCircularSplineSegment.1.close.2(169)"></A><A name="close.2(169)"></A>: 
       (# ... #);
     <B>isClosed</B><A name="NonCircularSplineSegment.1.isClosed.2(170)"></A><A name="isClosed.2(170)"></A>: booleanValue
       (#  ... #);
     <B>open</B><A name="NonCircularSplineSegment.1.open.2(171)"></A><A name="open.2(171)"></A>::&lt; 
       (#
       ...
       #);
     <B>addControl</B><A name="NonCircularSplineSegment.1.addControl.2(172)"></A><A name="addControl.2(172)"></A>::&lt; 
       (#
       ... 
       #);
     <B>drawRubberBand</B><A name="NonCircularSplineSegment.1.drawRubberBand.2(173)"></A><A name="drawRubberBand.2(173)"></A>::&lt; (# ... #);
     
     (* PRIVATE *)
     <B>writePS</B><A name="NonCircularSplineSegment.1.writePS.2(174)"></A><A name="writePS.2(174)"></A>::&lt;(# do ... #);
     <B>private</B><A name="NonCircularSplineSegment.1.private.2(175)"></A><A name="private.2(175)"></A>: @...;
     <B>DrawRubberSplineDesc</B><A name="NonCircularSplineSegment.1.DrawRubberSplineDesc.2(176)"></A><A name="DrawRubberSplineDesc.2(176)"></A>::&lt; (* private *)
       (# do ... #);
     <B>findSegments</B><A name="NonCircularSplineSegment.1.findSegments.2(177)"></A><A name="findSegments.2(177)"></A>::&lt; (* private *)
       (# ... #);
     <B>calculatePoints</B><A name="NonCircularSplineSegment.1.calculatePoints.2(178)"></A><A name="calculatePoints.2(178)"></A>::&lt; (* private *)
       (# ... #);
     <B>getControls</B><A name="NonCircularSplineSegment.1.getControls.2(179)"></A><A name="getControls.2(179)"></A>::&lt; (* private *)
       (# ... #);
     <B>makeOffset</B><A name="NonCircularSplineSegment.1.makeOffset.2(180)"></A><A name="makeOffset.2(180)"></A>::&lt; (* private *)
       (# do ... #);
     <B>makeSecondOffset</B><A name="NonCircularSplineSegment.1.makeSecondOffset.2(181)"></A><A name="makeSecondOffset.2(181)"></A>::&lt; (* private *)
       (# do ...#);
  do INNER;
  #);

</PRE><P><HR><P><H2><A name="AbstractShape">AbstractShape</A></H2><PRE CLASS=interface>
<B>AbstractShape</B><A name="AbstractShape.1(182)"></A>: Segment
  (# &lt;&lt;SLOT AShapeAttributes: attributes &gt;&gt;;
     
     <B>copy</B><A name="AbstractShape.1.copy.2(183)"></A><A name="copy.2(183)"></A>::&lt; (# do INNER; ... #);
     <B>fillRule</B><A name="AbstractShape.1.fillRule.2(184)"></A><A name="fillRule.2(184)"></A>: @
       (* Rule to determine what is inside and what is outside
        * THIS(AbstractShape). Used, e.g. when filling
        * THIS(AbstractShape) with some Paint. Defaults to 
        * WindingRule.
        *)
       (# r: @Integer;
          changed: @Boolean;  (* initialized as false *)
          changeRule: (# enter r do True -&gt; changed #);
       enter changeRule
       do (if not changed then WindingRule -&gt; r if);
       exit r
       #);
     <B>invalidate</B><A name="AbstractShape.1.invalidate.2(185)"></A><A name="invalidate.2(185)"></A>:&lt; 
       (* invalidate THIS(AbstractShape), so it will be recalculated
        * next time used in fill or clip operation.
        *)
       (# ... #);
     <B>invalid</B><A name="AbstractShape.1.invalid.2(186)"></A><A name="invalid.2(186)"></A>: 
       (* Answer true if THIS(AbstractShape) has been invalidated *)
       (# b: @Boolean;
       ... 
       exit b
       #);
     <B>getBounds</B><A name="AbstractShape.1.getBounds.2(187)"></A><A name="getBounds.2(187)"></A>:&lt; 
       (* Return the bounding box of THIS(AbstractShape) *)
       (# bound: @rectangle;
       ...
       exit bound
       #);
     
     (* QUERY *)
     <B>containsPoint</B><A name="AbstractShape.1.containsPoint.2(188)"></A><A name="containsPoint.2(188)"></A>:&lt; booleanValue
       (* Answer whether thePoint is inside THIS(AbstractShape),
        * thePoint is assumed to be in coordinates relative to 
        * theCanvas.
        *)
       (# theCanvas: ^BifrostCanvas;
          thePoint: @Point;
       enter (theCanvas[],thePoint)
       ...
       #);
     <B>hotspot</B><A name="AbstractShape.1.hotspot.2(189)"></A><A name="hotspot.2(189)"></A>: @
       (* The default value of hotspot is firstpoint *)
       (# p: @Point;
          changed: @Boolean;  (* initialized as false *)
          changeHotspot: (# enter p do True -&gt; changed #);
       enter changeHotspot
       do (if not changed then firstPoint -&gt; p if);
       exit p
       #);
     
     (* HIGHLIGHTING *)
     <B>hiliteDesc</B><A name="AbstractShape.1.hiliteDesc.2(190)"></A><A name="hiliteDesc.2(190)"></A>: (* Qualification for highlighting patterns *)
       (# doneInInner: @boolean;
          theCanvas: ^BifrostCanvas
            (* The BifrostCanvas to do the highlighting on *);
          draw: @boolean
            (* Should the feedback be drawn or erased ? *);
          TM: ^Matrix
            (* TM is applied before the feedback is drawn *);
          copy:&lt; (* Return a deep copy of THIS(HiliteDesc) *)
            (# aCopy: ^hiliteDesc;
            ...
            exit aCopy[]
            #);
       enter (theCanvas[], draw, TM[])
       ...
       #);
     
     (* PREDEFINED HIGHLIGHTING PATTERNS *)
     
     <B>hiliteControls</B><A name="AbstractShape.1.hiliteControls.2(191)"></A><A name="hiliteControls.2(191)"></A>:&lt; hiliteDesc
       (* Highlight control points *)
       (# copy::&lt; (# do INNER; ... #);
       do INNER; ... #);
     <B>hiliteOutline</B><A name="AbstractShape.1.hiliteOutline.2(192)"></A><A name="hiliteOutline.2(192)"></A>:&lt; hiliteDesc
       (* Highlight outline of THIS(AbstractShape). To be further
        * bound
        *)
       (# hiliteWidth: @integer
            (* The width of the lines used when highlighting outline.
             * 0 means as thin as possible (default).  Should be the
             * same as the corresponding hilitewidth.
             *);
          copy::&lt; (# do ... #);
       do INNER
       #);
     <B>hiliteBound</B><A name="AbstractShape.1.hiliteBound.2(193)"></A><A name="hiliteBound.2(193)"></A>:&lt; hiliteDesc
       (* Highlight bounding box *)
       (# Width: @integer;
          copy::&lt; (# ... #);
       do INNER; ...;
       #);
     
     (* The actual highlight patterns used.  drawhilite points to one
      * of hc, ho, hb or some user supplied specialization of
      * hilitedesc
      *)
     <B>hc</B><A name="AbstractShape.1.hc.2(194)"></A><A name="hc.2(194)"></A>,<B> ho</B><A name="AbstractShape.1.ho.2(195)"></A><A name="ho.2(195)"></A>,<B> hb</B><A name="AbstractShape.1.hb.2(196)"></A><A name="hb.2(196)"></A>: ^hiliteDesc;
     <B>drawHilite</B><A name="AbstractShape.1.drawHilite.2(197)"></A><A name="drawHilite.2(197)"></A>: ^hiliteDesc;
     
     (* DEFINITION LANGUAGE *)
     <B>open</B><A name="AbstractShape.1.open.2(198)"></A><A name="open.2(198)"></A>:&lt; (* Must be called first *)
       (# p: @Point enter p ... #);
     
     (* INTERACTION *)
     <B>Interaction</B><A name="AbstractShape.1.Interaction.2(199)"></A><A name="Interaction.2(199)"></A>: 
       (* Prefix for interaction patterns *)
       (# theCanvas: ^BifrostCanvas;
          theModifier: @Modifier;
          startPoint: @Point;
       enter (theCanvas[], startPoint, theModifier)
       do INNER;
       #);
     <B>InteractiveCreate</B><A name="AbstractShape.1.InteractiveCreate.2(200)"></A><A name="InteractiveCreate.2(200)"></A>:&lt; Interaction 
       (* Provide feedback for creating THIS(AbstractShape)
        * interactively.  Make the feedback constrained if 
        * theModifier is on. Start the interaction in startpoint.
        *);
     <B>InteractiveCombine</B><A name="AbstractShape.1.InteractiveCombine.2(201)"></A><A name="InteractiveCombine.2(201)"></A>:&lt; Interaction
       (* Create a Shape interactively and combine that Shape with
        * THIS(AbstractShape).  Make the feedback constrained if
        * theModifier is on. Start the interaction in startpoint.
        *);
     <B>InteractiveReshape</B><A name="AbstractShape.1.InteractiveReshape.2(202)"></A><A name="InteractiveReshape.2(202)"></A>:&lt; Interaction
       (* Provide feedback for reshaping THIS(AbstractShape)
        * interactively.  Make the feedback constrained if 
        * theModifier is on. Start the interaction in startpoint.
        *);
     
     <B>transform</B><A name="AbstractShape.1.transform.2(203)"></A><A name="transform.2(203)"></A>::&lt; (# ... #);
     <B>getcontrols</B><A name="AbstractShape.1.getcontrols.2(204)"></A><A name="getcontrols.2(204)"></A>::&lt; (# ... #);
     
     (* PRIVATE *)
     <B>writePS</B><A name="AbstractShape.1.writePS.2(205)"></A><A name="writePS.2(205)"></A>::&lt;
       (# 
          invisible: @boolean;
       enter invisible
       do INNER
       #);
     <B>privatePart</B><A name="AbstractShape.1.privatePart.2(206)"></A><A name="privatePart.2(206)"></A>: @...;
     <B>calculatePoints</B><A name="AbstractShape.1.calculatePoints.2(207)"></A><A name="calculatePoints.2(207)"></A>::&lt; (* private *)
       (# do ... #);
     
  do INNER;
  #); (* Abstract Shape *)

</PRE><P><HR><P><H2><A name="Shape">Shape</A></H2><PRE CLASS=interface>
<B>Shape</B><A name="Shape.1(208)"></A>: AbstractShape
  (* For making user defined objects *)
  (# &lt;&lt;SLOT ShapeAttributes: attributes &gt;&gt;;
     <B>copy</B><A name="Shape.1.copy.2(209)"></A><A name="copy.2(209)"></A>::&lt; (# do INNER; ... #);
     <B>getBounds</B><A name="Shape.1.getBounds.2(210)"></A><A name="getBounds.2(210)"></A>::&lt; (# ... #);
     <B>containsPoint</B><A name="Shape.1.containsPoint.2(211)"></A><A name="containsPoint.2(211)"></A>::&lt; (# do ...; INNER #);
     <B>currentPoint</B><A name="Shape.1.currentPoint.2(212)"></A><A name="currentPoint.2(212)"></A>:&lt; (* The last control point added *)
       (# p: @Point;
       do ...; INNER;
       exit p
       #);
     <B>firstPoint</B><A name="Shape.1.firstPoint.2(213)"></A><A name="firstPoint.2(213)"></A>::&lt; (# do ...; INNER #);
     <B>lastPoint</B><A name="Shape.1.lastPoint.2(214)"></A><A name="lastPoint.2(214)"></A>::&lt; (# ... #);
     <B>nextToFirstPoint</B><A name="Shape.1.nextToFirstPoint.2(215)"></A><A name="nextToFirstPoint.2(215)"></A>::&lt;(# ... #);
     <B>nextToLastPoint</B><A name="Shape.1.nextToLastPoint.2(216)"></A><A name="nextToLastPoint.2(216)"></A>::&lt; (# ... #);
     <B>open</B><A name="Shape.1.open.2(217)"></A><A name="open.2(217)"></A>::&lt; (# ... #);
     
     (* DEFINITION LANGUAGE *)
     <B>addSpline</B><A name="Shape.1.addSpline.2(218)"></A><A name="addSpline.2(218)"></A>: 
       (* Add Spline beginning at currentpoint.  Spline.lastpoint
        * becomes new currentpoint
        *)
       (# Spline: ^SplineSegment;
       enter spline[]
       do ...;
       #);
     <B>lineTo</B><A name="Shape.1.lineTo.2(219)"></A><A name="lineTo.2(219)"></A>: 
       (* If currentPoint is a control point in a spline being
        * defined with splineTo, that spline is ended.  Add a
        * LineSegment beginning at currentPoint and ending at p.  p
        * becomes new currentPoint.
        *)
       (# p: @Point;
       enter p
       do ...;
       #);
     <B>splineTo</B><A name="Shape.1.splineTo.2(220)"></A><A name="splineTo.2(220)"></A>: 
       (* If currentPoint is the end point in a line segment, a new
        * spline segment is opened. That spline segment becomes the
        * "current spline segment". Add currenPoint as the first
        * control point of the current spline segment.  Add p as a
        * control point to the current spline segment.  p becomes new
        * currentPoint.
        *)
       (# p: @Point;
       enter p
       ... 
       #);
     <B>close</B><A name="Shape.1.close.2(221)"></A><A name="close.2(221)"></A>:&lt; (* Should be called after the definition is finished *)
       (# ... #);
     
     (* QUERY FUNCTIONS *)
     <B>isClosed</B><A name="Shape.1.isClosed.2(222)"></A><A name="isClosed.2(222)"></A>: booleanValue 
       (* NOTICE: an empty shape is considered closed!!*)
       (# ... #);
     <B>isEmpty</B><A name="Shape.1.isEmpty.2(223)"></A><A name="isEmpty.2(223)"></A>: booleanValue 
       (# ... #);
     <B>isFlat</B><A name="Shape.1.isFlat.2(224)"></A><A name="isFlat.2(224)"></A>: booleanValue
       (* THIS(AbstractShape) is flat iff it contains no splines *)
       (# ... #);
     
     (* MANIPULATING THE SHAPE *)
     <B>reverseOrientation</B><A name="Shape.1.reverseOrientation.2(225)"></A><A name="reverseOrientation.2(225)"></A>::&lt; (# do ...; INNER #);
     <B>stroke</B><A name="Shape.1.stroke.2(226)"></A><A name="stroke.2(226)"></A>: 
       (* Change THIS(Shape) to be the shape obtained by stroking a
        * "pen" with the witdh W along THIS(Shape).  When stroking an
        * open Shape, the look of the "ends" of the resulting shape 
        * is specified with capStyle.  At joining points the joining
        * style is specified by joinStyle.
        *)
       (# W: @Integer; 
          capstyle: @capstyledesc; 
          joinstyle: @joinstyledesc;
       enter (W, capstyle, joinstyle)
       do ...;  
       #);
     <B>insert</B><A name="Shape.1.insert.2(227)"></A><A name="insert.2(227)"></A>: (* Not Yet Implemented *)
       (* If p1 is in the neighborhood of an existing control point,
        * P2 is added as a new control point is between the neighbor
        * point and the next point.
        *)
       (# p1, p2: @point;
       enter (p1,p2)
       ... 
       #);
     <B>delete</B><A name="Shape.1.delete.2(228)"></A><A name="delete.2(228)"></A>: (* Not Yet Implemented *)
       (* If p is in the neighborhood of an existing control point,
        * this control point is deleted
        *)
       (# p: @point;
       enter p
       ... 
       #);
     
     (* COMBINING SHAPES *)
     <B>appendShape</B><A name="Shape.1.appendShape.2(229)"></A><A name="appendShape.2(229)"></A>: (* Not Yet Implemented *)
       (* Add sourceShape to THIS(Shape).  Place
        * sourceShape.firstPoint in THIS(Shape).lastPoint by
        * translating the entire sourceShape.  This is the only
        * transformation involved.  After the operation,
        * THIS(Shape).lastPoint is the translated
        * sourceShape.lastPoint.  sourceShape cannot consist of
        * circularSplines only.
        *)
       (# sourceShape: ^Shape;
       enter sourceShape[]
       ...
       #);
     <B>connectShape</B><A name="Shape.1.connectShape.2(230)"></A><A name="connectShape.2(230)"></A>: (* Not Yet Implemented *)
       (* Add sourceShape to THIS(Shape).  TM is applied to
        * sourceShape before the addition.  THIS(Shape).lastpoint is
        * connected to sourceShape.firstPoint with a line segment.
        * After the operation, THIS(Shape).lastPoint is the 
        * translated sourceShape.lastPoint.  
        * sourceShape cannot consist of circularSplines only.
        *)
       (# TM: ^Matrix;
          sourceShape: ^Shape;
       enter (TM[],sourceShape[])
       ...
       #);
     <B>connectShapeSmooth</B><A name="Shape.1.connectShapeSmooth.2(231)"></A><A name="connectShapeSmooth.2(231)"></A>: (* Not Yet Implemented *)
       (* Add sourceShape to THIS(Shape).  TM is applied to
        * sourceShape before the addition.  THIS(Shape).lastpoint is
        * connected to sourceShape.firstPoint with a spline segment
        * constructed from the last two points in THIS(Shape) and
        * sourceShape.firstPoint.  After the operation,
        * THIS(Shape).lastPoint is the translated
        * sourceShape.lastPoint.  sourceShape cannot consist of
        * circularSplines only.
        *)
       (# TM: ^Matrix;
          sourceShape: ^Shape;
       enter (TM[],sourceShape[])
       ...
       #);
     <B>combineShape</B><A name="Shape.1.combineShape.2(232)"></A><A name="combineShape.2(232)"></A>: 
       (* Add sourceShape to THIS(Shape).  TM is applied to
        * sourceShape before the addition.  sourceShape and
        * THIS(Shape) do *not* become connected.  At least one of
        * THIS(Shape) and sourceShape must be closed.  If sourceShape
        * is closed, THIS(Shape).lastPoint is unchanged.  If
        * sourceShape is open, THIS(Shape).lastPoint is
        * sourceshape.lastPoint after the operation.
        *)
       (# TM: ^Matrix;
          sourceShape: ^Shape;
       enter (TM[],sourceShape[])
       do ...;
       #);
     
     (* HIGHLIGHTING *)
     <B>hiliteOutline</B><A name="Shape.1.hiliteOutline.2(233)"></A><A name="hiliteOutline.2(233)"></A>::&lt; (# ... #);
     
     (* INTERACTION *)
     <B>InteractiveCreate</B><A name="Shape.1.InteractiveCreate.2(234)"></A><A name="InteractiveCreate.2(234)"></A>::&lt; (# do ...; INNER  #);
     <B>InteractiveCombine</B><A name="Shape.1.InteractiveCombine.2(235)"></A><A name="InteractiveCombine.2(235)"></A>::&lt; (# do ...; INNER  #);
     
     <B>InteractiveReshape</B><A name="Shape.1.InteractiveReshape.2(236)"></A><A name="InteractiveReshape.2(236)"></A>::&lt; (# do ...; INNER  #);
     <B>transform</B><A name="Shape.1.transform.2(237)"></A><A name="transform.2(237)"></A>::&lt; (# do ...; INNER  #);
     
     <B>getControls</B><A name="Shape.1.getControls.2(238)"></A><A name="getControls.2(238)"></A>::&lt;(# do ... #);
     
     (* PRIVATE *)
     <B>findSegments</B><A name="Shape.1.findSegments.2(239)"></A><A name="findSegments.2(239)"></A>::&lt; (* private *)
       (# do ... #);
     <B>writePS</B><A name="Shape.1.writePS.2(240)"></A><A name="writePS.2(240)"></A>::&lt;(# do ... #);
  do INNER;
  #);  (* Shape *)

</PRE><P><HR><P><H2><A name="PredefinedShape">PredefinedShape</A></H2><PRE CLASS=interface>
<B>PredefinedShape</B><A name="PredefinedShape.1(241)"></A>: AbstractShape
  (#
     <B>CalculateShape</B><A name="PredefinedShape.1.CalculateShape.2(242)"></A><A name="CalculateShape.2(242)"></A>:&lt; 
       (* Return (approximating) Shape, if possible *)
       (# s: ^Shape
       do INNER
       exit (# ... exit s[] #)
       #);
     <B>invalidate</B><A name="PredefinedShape.1.invalidate.2(243)"></A><A name="invalidate.2(243)"></A>::&lt;(# ... #);
     <B>containsPoint</B><A name="PredefinedShape.1.containsPoint.2(244)"></A><A name="containsPoint.2(244)"></A>::&lt;(# ... #);
     <B>transform</B><A name="PredefinedShape.1.transform.2(245)"></A><A name="transform.2(245)"></A>::&lt;(# do ...; INNER #);
     
     (* Patterns behaving like standard "types", but that have the
      * side-effect of invalidating THIS(PredefinedShape) when 
      * changed.
      *)
     <B>invalidatePoint</B><A name="PredefinedShape.1.invalidatePoint.2(246)"></A><A name="invalidatePoint.2(246)"></A>:
       (# p: @Point; enter (# enter p do Invalidate #) exit p #);
     <B>invalidateInteger</B><A name="PredefinedShape.1.invalidateInteger.2(247)"></A><A name="invalidateInteger.2(247)"></A>: integerValue
       (# enter (# enter value do Invalidate #) #);
     <B>invalidateReal</B><A name="PredefinedShape.1.invalidateReal.2(248)"></A><A name="invalidateReal.2(248)"></A>:
       (# r: @Real; enter (# enter r do Invalidate #) exit r #);
     <B>invalidateDash</B><A name="PredefinedShape.1.invalidateDash.2(249)"></A><A name="invalidateDash.2(249)"></A>:
       (* For instance {1,2,4,2} yields '=  ====  =  ====  =' etc. *)
       (# d: ^IntegerList; 
       enter (# enter d[] do invalidate #) 
       exit d[]
       #);
     <B>invalidateCapStyle</B><A name="PredefinedShape.1.invalidateCapStyle.2(250)"></A><A name="invalidateCapStyle.2(250)"></A>:
       (# c: @CapStyleDesc; 
       enter (# enter c do invalidate #) 
       exit c
       #);
     <B>invalidateJoinStyle</B><A name="PredefinedShape.1.invalidateJoinStyle.2(251)"></A><A name="invalidateJoinStyle.2(251)"></A>:
       (# j: @JoinStyleDesc; 
       enter (# enter j do invalidate #)
       exit j 
       #);
     <B>writePS</B><A name="PredefinedShape.1.writePS.2(252)"></A><A name="writePS.2(252)"></A>::&lt;(# do ... #);
     <B>prePrivate</B><A name="PredefinedShape.1.prePrivate.2(253)"></A><A name="prePrivate.2(253)"></A>: @...;
  do INNER;
  #);

</PRE><P><HR><P><H2><A name="LineShape">LineShape</A></H2><PRE CLASS=interface>
<B>LineShape</B><A name="LineShape.1(254)"></A>: PredefinedShape
  (# &lt;&lt;SLOT LineShapeAttributes: attributes&gt;&gt;;
     
     <B>firstPoint</B><A name="LineShape.1.firstPoint.2(255)"></A><A name="firstPoint.2(255)"></A>::&lt;(# do begin -&gt; p #);
     
     <B>begin</B><A name="LineShape.1.begin.2(256)"></A><A name="begin.2(256)"></A>: @InvalidatePoint;
     <B>end</B><A name="LineShape.1.end.2(257)"></A><A name="end.2(257)"></A>: @InvalidatePoint;
     <B>width</B><A name="LineShape.1.width.2(258)"></A><A name="width.2(258)"></A>: @InvalidateInteger;
     <B>dashes</B><A name="LineShape.1.dashes.2(259)"></A><A name="dashes.2(259)"></A>: @InvalidateDash; (* Not Yet Implemented *)
     <B>cap</B><A name="LineShape.1.cap.2(260)"></A><A name="cap.2(260)"></A>: @InvalidateCapStyle;
     
     <B>coordinates</B><A name="LineShape.1.coordinates.2(261)"></A><A name="coordinates.2(261)"></A>:
       (# enter (begin, end) exit (begin, end) #);
     <B>open</B><A name="LineShape.1.open.2(262)"></A><A name="open.2(262)"></A>::&lt;(# ... #);
     <B>getBounds</B><A name="LineShape.1.getBounds.2(263)"></A><A name="getBounds.2(263)"></A>::&lt; (# do ...; INNER #);
     <B>containsPoint</B><A name="LineShape.1.containsPoint.2(264)"></A><A name="containsPoint.2(264)"></A>::&lt;(# ... #);
     <B>getControls</B><A name="LineShape.1.getControls.2(265)"></A><A name="getControls.2(265)"></A>::&lt;(# ... #);
     <B>copy</B><A name="LineShape.1.copy.2(266)"></A><A name="copy.2(266)"></A>::&lt; (# do INNER; ... #);
     
     (* HIGHLIGHTING *)
     <B>hiliteOutline</B><A name="LineShape.1.hiliteOutline.2(267)"></A><A name="hiliteOutline.2(267)"></A>::&lt; (# do INNER; ... #);
     
     (* INTERACTION *)
     <B>interactiveCreate</B><A name="LineShape.1.interactiveCreate.2(268)"></A><A name="interactiveCreate.2(268)"></A>::&lt;(# do ...; INNER #);
     <B>interactiveReshape</B><A name="LineShape.1.interactiveReshape.2(269)"></A><A name="interactiveReshape.2(269)"></A>::&lt;(# do ...; INNER #);
     
     <B>writePS</B><A name="LineShape.1.writePS.2(270)"></A><A name="writePS.2(270)"></A>::&lt;(# do ... #);
     <B>transform</B><A name="LineShape.1.transform.2(271)"></A><A name="transform.2(271)"></A>::&lt;(# ... #);
     <B>CalculateShape</B><A name="LineShape.1.CalculateShape.2(272)"></A><A name="CalculateShape.2(272)"></A>::&lt;  (* private *)
       (# ... #);
     
  do INNER;
  #);

</PRE><P><HR><P><H2><A name="MultilineShape">MultilineShape</A></H2><PRE CLASS=interface>
<B>MultiLineShape</B><A name="MultiLineShape.1(273)"></A>: PredefinedShape
  (# &lt;&lt;SLOT MultiLineShapeAttributes: attributes&gt;&gt;;
     
     <B>firstPoint</B><A name="MultiLineShape.1.firstPoint.2(274)"></A><A name="firstPoint.2(274)"></A>::&lt; (# ... #);
     <B>lastPoint</B><A name="MultiLineShape.1.lastPoint.2(275)"></A><A name="lastPoint.2(275)"></A>::&lt; (# ... #);
     <B>points</B><A name="MultiLineShape.1.points.2(276)"></A><A name="points.2(276)"></A>: @
       (# p: ^PointArray;
       enter (# enter p[] do invalidate #)
       exit p[]
       #);
     <B>width</B><A name="MultiLineShape.1.width.2(277)"></A><A name="width.2(277)"></A>: @InvalidateInteger;
     <B>dashes</B><A name="MultiLineShape.1.dashes.2(278)"></A><A name="dashes.2(278)"></A>: @InvalidateDash; (* Not Yet Implemented *)
     <B>cap</B><A name="MultiLineShape.1.cap.2(279)"></A><A name="cap.2(279)"></A>: @InvalidateCapStyle;
     <B>join</B><A name="MultiLineShape.1.join.2(280)"></A><A name="join.2(280)"></A>: @InvalidateJoinStyle;
     
     <B>open</B><A name="MultiLineShape.1.open.2(281)"></A><A name="open.2(281)"></A>::&lt; (# ... #);
     <B>addPoint</B><A name="MultiLineShape.1.addPoint.2(282)"></A><A name="addPoint.2(282)"></A>: (* Add p at the end of points *)
       (# p: @point;
       enter p
       ... 
       #);
     <B>deletePoint</B><A name="MultiLineShape.1.deletePoint.2(283)"></A><A name="deletePoint.2(283)"></A>: (* Delete p at from points *)
       (# p: @point;
       enter p
       ... 
       #);
     <B>insertPoint</B><A name="MultiLineShape.1.insertPoint.2(284)"></A><A name="insertPoint.2(284)"></A>: (* Insert p in points at position i *)
       (# p: @point;
          i: @integer
       enter (p,i)
       ... 
       #);
     <B>getPoint</B><A name="MultiLineShape.1.getPoint.2(285)"></A><A name="getPoint.2(285)"></A>:
       (* Return point no i in THIS(MultiLineShape); 1&lt;=i&lt;=npoints *)
       (# i: @Integer;
          p: @Point;
       enter i
       ... 
       exit p
       #);
     <B>setPoint</B><A name="MultiLineShape.1.setPoint.2(286)"></A><A name="setPoint.2(286)"></A>:
       (* Change the value of point no i to p; 1&lt;=i&lt;=npoints *)
       (# i: @Integer;
          p: @Point;
       enter (p,i)
       ... 
       #);
     <B>closestLineSegment</B><A name="MultiLineShape.1.closestLineSegment.2(287)"></A><A name="closestLineSegment.2(287)"></A>:
       (# p: @point; i: @integer
       enter p
       do ...
       exit i
       #);
     <B>getBounds</B><A name="MultiLineShape.1.getBounds.2(288)"></A><A name="getBounds.2(288)"></A>::&lt;(# do ...; INNER #);
     <B>containsPoint</B><A name="MultiLineShape.1.containsPoint.2(289)"></A><A name="containsPoint.2(289)"></A>::&lt;(# ... #);
     <B>getControls</B><A name="MultiLineShape.1.getControls.2(290)"></A><A name="getControls.2(290)"></A>::&lt;(# ... #);
     <B>copy</B><A name="MultiLineShape.1.copy.2(291)"></A><A name="copy.2(291)"></A>::&lt; (# do INNER; ... #);
     
     (* HIGHLIGHTING *)
     <B>hiliteOutline</B><A name="MultiLineShape.1.hiliteOutline.2(292)"></A><A name="hiliteOutline.2(292)"></A>::&lt; (# do INNER; ... #);
     
     (* INTERACTION *)
     <B>interactiveCreate</B><A name="MultiLineShape.1.interactiveCreate.2(293)"></A><A name="interactiveCreate.2(293)"></A>::&lt;(# do ...; INNER #);
     <B>interactiveReshape</B><A name="MultiLineShape.1.interactiveReshape.2(294)"></A><A name="interactiveReshape.2(294)"></A>::&lt;(# do ...; INNER #);
     <B>writePS</B><A name="MultiLineShape.1.writePS.2(295)"></A><A name="writePS.2(295)"></A>::&lt;(# do ... #);
     <B>transform</B><A name="MultiLineShape.1.transform.2(296)"></A><A name="transform.2(296)"></A>::&lt;(# ... #);
     
     <B>calculateShape</B><A name="MultiLineShape.1.calculateShape.2(297)"></A><A name="calculateShape.2(297)"></A>::&lt;  (* private *)
       (# ... #);
  do INNER;
  #);

</PRE><P><HR><P><H2><A name="TextShape">TextShape</A></H2><PRE CLASS=interface>
<B>TextShape</B><A name="TextShape.1(298)"></A>: PredefinedShape
  (# &lt;&lt;SLOT TextShapeAttributes: attributes&gt;&gt;;
     
     <B>firstPoint</B><A name="TextShape.1.firstPoint.2(299)"></A><A name="firstPoint.2(299)"></A>::&lt; (# do position -&gt; p #);
     <B>initText</B><A name="TextShape.1.initText.2(300)"></A><A name="initText.2(300)"></A>: (* Specify several attributes simultaneously *)
       (# 
       enter 
          (position, theFontname, theStyle, size, underline, theText)
       #);
     <B>position</B><A name="TextShape.1.position.2(301)"></A><A name="position.2(301)"></A>: 
       (* Where to place the baseline of the first line of theText *) 
       (# p: @Point; 
       enter (# enter p ... #)
       ... 
       exit p
       #);
     <B>theFontName</B><A name="TextShape.1.theFontName.2(302)"></A><A name="theFontName.2(302)"></A>: (* one of Courier, Times, Helvetica *)
       (# nam: @fontname; 
       enter (# enter nam ... #)
       ... 
       exit nam
       #);
     <B>theStyle</B><A name="TextShape.1.theStyle.2(303)"></A><A name="theStyle.2(303)"></A>: (* Either Plain, Italic or Bold *)
       (# sty: @Style;    
       enter (# enter sty ... #)
       ... 
       exit sty
       #);
     <B>size</B><A name="TextShape.1.size.2(304)"></A><A name="size.2(304)"></A>: (* The size in points (1/72 inch) of the text drawn *)
       (# siz: @Integer; 
       enter (# enter siz ... #)
       ... 
       exit siz
       #);
     <B>underline</B><A name="TextShape.1.underline.2(305)"></A><A name="underline.2(305)"></A>: (* Specifies if the text is to be underlined *)
       (# ul: @Boolean;
       enter (# enter ul ... #)
       ... 
       exit ul
       #);
     <B>theText</B><A name="TextShape.1.theText.2(306)"></A><A name="theText.2(306)"></A>:
       (* Holds the characters of THIS(TextShape). i.e. it joins
        * the text lines in theLines into one text, where newlines 
        * are inserted for line breaks.
        *)
       (# t: ^Text;
       enter (# enter t[] ... #)
       ... 
       exit t[]
       #);
     <B>theLines</B><A name="TextShape.1.theLines.2(307)"></A><A name="theLines.2(307)"></A>: 
       (* Each text element in this list corresponds to one line
        * of text in THIS(TextShape).
        *)
       (# l: ^TextList;
       enter (# enter l[] ... #)
       ... 
       exit l[]
       #);
     <B>numberOfLines</B><A name="TextShape.1.numberOfLines.2(308)"></A><A name="numberOfLines.2(308)"></A>: integerValue
       (* Number of Texts in theLines *)
       (# ...
       #);
     <B>getBounds</B><A name="TextShape.1.getBounds.2(309)"></A><A name="getBounds.2(309)"></A>::&lt;(# do ...; INNER #);
     <B>containsPoint</B><A name="TextShape.1.containsPoint.2(310)"></A><A name="containsPoint.2(310)"></A>::&lt;(# ... #);
     <B>getControls</B><A name="TextShape.1.getControls.2(311)"></A><A name="getControls.2(311)"></A>::&lt;(# do ...; INNER #);
     <B>copy</B><A name="TextShape.1.copy.2(312)"></A><A name="copy.2(312)"></A>::&lt; (# do INNER; ... #);
     
     (* HIGHLIGHTING *) 
     <B>hiliteOutline</B><A name="TextShape.1.hiliteOutline.2(313)"></A><A name="hiliteOutline.2(313)"></A>::&lt; (# do INNER; ... #);
     
     (* INTERACTION *)
     <B>interactiveCreate</B><A name="TextShape.1.interactiveCreate.2(314)"></A><A name="interactiveCreate.2(314)"></A>::&lt;
       (# lastCh: @char; (* Last character typed in interaction *)
       do ...; INNER
       exit lastCh
       #);
     <B>interactiveReshape</B><A name="TextShape.1.interactiveReshape.2(315)"></A><A name="interactiveReshape.2(315)"></A>::&lt;
       (# lastCh: @char; (* Last character typed in interaction *)
       ... 
       exit lastCh
       #);
     
     <B>writePS</B><A name="TextShape.1.writePS.2(316)"></A><A name="writePS.2(316)"></A>::&lt;(# do ... #);
     <B>transform</B><A name="TextShape.1.transform.2(317)"></A><A name="transform.2(317)"></A>::&lt;(# ... #);
     <B>TextPrivate</B><A name="TextShape.1.TextPrivate.2(318)"></A><A name="TextPrivate.2(318)"></A>: @ ...;
     <B>calculateShape</B><A name="TextShape.1.calculateShape.2(319)"></A><A name="calculateShape.2(319)"></A>::&lt; (* private *)
       (# ... #);
     
  do INNER;
  #);

</PRE><P><HR><P><H2><A name="PieShape">PieShape</A></H2><PRE CLASS=interface>
<B>PieShape</B><A name="PieShape.1(320)"></A>: PredefinedShape
  (# &lt;&lt;SLOT PieShapeAttributes: attributes&gt;&gt;;
     
     <B>firstPoint</B><A name="PieShape.1.firstPoint.2(321)"></A><A name="firstPoint.2(321)"></A>::&lt;(# do center -&gt; p #);
     
     <B>center</B><A name="PieShape.1.center.2(322)"></A><A name="center.2(322)"></A>: @InvalidatePoint;
     <B>horizontalRadius</B><A name="PieShape.1.horizontalRadius.2(323)"></A><A name="horizontalRadius.2(323)"></A>: @InvalidateInteger;
     <B>verticalRadius</B><A name="PieShape.1.verticalRadius.2(324)"></A><A name="verticalRadius.2(324)"></A>: @InvalidateInteger;
     (* Use: 0 &lt;= angle1 &lt;= 360 a1 &lt;= angle2 &lt;= 360+angle1      *)
     <B>angle1</B><A name="PieShape.1.angle1.2(325)"></A><A name="angle1.2(325)"></A>: @InvalidateReal;
     <B>angle2</B><A name="PieShape.1.angle2.2(326)"></A><A name="angle2.2(326)"></A>: @InvalidateReal;
     
     <B>open</B><A name="PieShape.1.open.2(327)"></A><A name="open.2(327)"></A>::&lt;(# do ...; INNER #);
     <B>getBounds</B><A name="PieShape.1.getBounds.2(328)"></A><A name="getBounds.2(328)"></A>::&lt;(# do ...; INNER #);
     <B>containsPoint</B><A name="PieShape.1.containsPoint.2(329)"></A><A name="containsPoint.2(329)"></A>::&lt;(# do ...; INNER #);
     <B>getControls</B><A name="PieShape.1.getControls.2(330)"></A><A name="getControls.2(330)"></A>::&lt; (# do ...; INNER #);
     <B>copy</B><A name="PieShape.1.copy.2(331)"></A><A name="copy.2(331)"></A>::&lt; (# do INNER; ... #);
     
     (* HIGHLIGHTING *)
     <B>hiliteOutline</B><A name="PieShape.1.hiliteOutline.2(332)"></A><A name="hiliteOutline.2(332)"></A>::&lt; (# do INNER; ... #);
     
     (* INTERACTION *)
     <B>interactiveCreate</B><A name="PieShape.1.interactiveCreate.2(333)"></A><A name="interactiveCreate.2(333)"></A>::&lt;(# do ...; INNER #);
     <B>interactiveReshape</B><A name="PieShape.1.interactiveReshape.2(334)"></A><A name="interactiveReshape.2(334)"></A>::&lt;(# do ...; INNER #);
     
     <B>writePS</B><A name="PieShape.1.writePS.2(335)"></A><A name="writePS.2(335)"></A>::&lt;(# do ... #);
     <B>transform</B><A name="PieShape.1.transform.2(336)"></A><A name="transform.2(336)"></A>::&lt;(# ... #);
     <B>calculateShape</B><A name="PieShape.1.calculateShape.2(337)"></A><A name="calculateShape.2(337)"></A>::&lt; (* private *)
       (# ... #);
  do INNER
  #);

</PRE><P><HR><P><H2><A name="ArcShape">ArcShape</A></H2><PRE CLASS=interface>
<B>ArcShape</B><A name="ArcShape.1(338)"></A>: PredefinedShape
  (# &lt;&lt;SLOT ArcShapeAttributes: attributes&gt;&gt;;
     
     <B>firstPoint</B><A name="ArcShape.1.firstPoint.2(339)"></A><A name="firstPoint.2(339)"></A>::&lt;(# do center -&gt; p #);
     
     <B>center</B><A name="ArcShape.1.center.2(340)"></A><A name="center.2(340)"></A>: @InvalidatePoint;
     <B>horizontalRadius</B><A name="ArcShape.1.horizontalRadius.2(341)"></A><A name="horizontalRadius.2(341)"></A>: @InvalidateInteger;
     <B>verticalRadius</B><A name="ArcShape.1.verticalRadius.2(342)"></A><A name="verticalRadius.2(342)"></A>: @InvalidateInteger;
     (* Use: 0 &lt;= angle1 &lt;= 360 a1 &lt;= angle2 &lt;= 360+angle1      *)
     <B>angle1</B><A name="ArcShape.1.angle1.2(343)"></A><A name="angle1.2(343)"></A>: @InvalidateReal;
     <B>angle2</B><A name="ArcShape.1.angle2.2(344)"></A><A name="angle2.2(344)"></A>: @InvalidateReal;
     <B>arcWidth</B><A name="ArcShape.1.arcWidth.2(345)"></A><A name="arcWidth.2(345)"></A>: @InvalidateInteger;
     
     <B>open</B><A name="ArcShape.1.open.2(346)"></A><A name="open.2(346)"></A>::&lt;(# ... #);
     <B>getBounds</B><A name="ArcShape.1.getBounds.2(347)"></A><A name="getBounds.2(347)"></A>::&lt;(# do ...; INNER #);
     <B>containsPoint</B><A name="ArcShape.1.containsPoint.2(348)"></A><A name="containsPoint.2(348)"></A>::&lt;(# do ...; INNER #);
     <B>getControls</B><A name="ArcShape.1.getControls.2(349)"></A><A name="getControls.2(349)"></A>::&lt;(# do ...; INNER #);
     <B>copy</B><A name="ArcShape.1.copy.2(350)"></A><A name="copy.2(350)"></A>::&lt; (# do INNER; ... #);
     
     (* HIGHLIGHTING *)
     <B>hiliteOutline</B><A name="ArcShape.1.hiliteOutline.2(351)"></A><A name="hiliteOutline.2(351)"></A>::&lt; (# do INNER; ... #);
     
     (* INTERACTION *)
     <B>interactiveCreate</B><A name="ArcShape.1.interactiveCreate.2(352)"></A><A name="interactiveCreate.2(352)"></A>::&lt;(# do ...; INNER #);
     <B>interactiveReshape</B><A name="ArcShape.1.interactiveReshape.2(353)"></A><A name="interactiveReshape.2(353)"></A>::&lt;(# do ...; INNER #);
     
     <B>writePS</B><A name="ArcShape.1.writePS.2(354)"></A><A name="writePS.2(354)"></A>::&lt;(# do ... #);
     <B>transform</B><A name="ArcShape.1.transform.2(355)"></A><A name="transform.2(355)"></A>::&lt;(# ... #);
     <B>calculateShape</B><A name="ArcShape.1.calculateShape.2(356)"></A><A name="calculateShape.2(356)"></A>::&lt; (* private *)
       (# ... #);
     
  do INNER
  #);

</PRE><P><HR><P><H2><A name="StrokeableShape">StrokeableShape</A></H2><PRE CLASS=interface>
<B>StrokeableShape</B><A name="StrokeableShape.1(357)"></A>: PredefinedShape 
  (# <B>stroked</B><A name="StrokeableShape.1.stroked.2(358)"></A><A name="stroked.2(358)"></A>: @Boolean;
     <B>strokewidth</B><A name="StrokeableShape.1.strokewidth.2(359)"></A><A name="strokewidth.2(359)"></A>: @Integer;
     
     <B>writePS</B><A name="StrokeableShape.1.writePS.2(360)"></A><A name="writePS.2(360)"></A>::&lt;(# do ... #);
     <B>getBounds</B><A name="StrokeableShape.1.getBounds.2(361)"></A><A name="getBounds.2(361)"></A>::&lt;(# ... #);
     <B>copy </B><A name="StrokeableShape.1.copy.2(362)"></A><A name="copy.2(362)"></A>::&lt;(# do INNER; ... #);
  do INNER
  #);

</PRE><P><HR><P><H2><A name="RectShape">RectShape</A></H2><PRE CLASS=interface>
<B>RectShape</B><A name="RectShape.1(363)"></A>: StrokeableShape
  (# &lt;&lt;SLOT RectShapeAttributes: attributes&gt;&gt;;
     
     <B>firstPoint</B><A name="RectShape.1.firstPoint.2(364)"></A><A name="firstPoint.2(364)"></A>::&lt;(# do upperleft -&gt; p #);
     
     <B>upperleft</B><A name="RectShape.1.upperleft.2(365)"></A><A name="upperleft.2(365)"></A>: @InvalidatePoint;
     <B>width</B><A name="RectShape.1.width.2(366)"></A><A name="width.2(366)"></A>: @InvalidateInteger;
     <B>height</B><A name="RectShape.1.height.2(367)"></A><A name="height.2(367)"></A>: @InvalidateInteger;      
     
     <B>corners</B><A name="RectShape.1.corners.2(368)"></A><A name="corners.2(368)"></A>:
       (# lowerright: @Point;
          changeCorners:
            (# enter (upperleft,lowerright) 
            ... 
            #);
       enter changeCorners
       exit 
          (upperleft, 
          ((upperleft.p.x+width),
          (upperleft.p.y+height)) )
       #);
     <B>open</B><A name="RectShape.1.open.2(369)"></A><A name="open.2(369)"></A>::&lt;(# ... #);
     <B>getBounds</B><A name="RectShape.1.getBounds.2(370)"></A><A name="getBounds.2(370)"></A>::&lt;(# ... #);
     <B>containsPoint</B><A name="RectShape.1.containsPoint.2(371)"></A><A name="containsPoint.2(371)"></A>::&lt;(# ... #);
     <B>getControls</B><A name="RectShape.1.getControls.2(372)"></A><A name="getControls.2(372)"></A>::&lt;(# ... #);
     <B>copy</B><A name="RectShape.1.copy.2(373)"></A><A name="copy.2(373)"></A>::&lt;(# do INNER; ... #);
     
     (* HIGHLIGHTING *)
     <B>hiliteOutline</B><A name="RectShape.1.hiliteOutline.2(374)"></A><A name="hiliteOutline.2(374)"></A>::&lt; (# do INNER; ... #);
     
     (* INTERACTION *)
     <B>interactiveCreate</B><A name="RectShape.1.interactiveCreate.2(375)"></A><A name="interactiveCreate.2(375)"></A>::&lt;(# do ...; INNER #);
     <B>interactiveReshape</B><A name="RectShape.1.interactiveReshape.2(376)"></A><A name="interactiveReshape.2(376)"></A>::&lt;(# do ...; INNER #);
     
     <B>writePS</B><A name="RectShape.1.writePS.2(377)"></A><A name="writePS.2(377)"></A>::&lt;(# do ... #);
     <B>transform</B><A name="RectShape.1.transform.2(378)"></A><A name="transform.2(378)"></A>::&lt;(# ... #);
     <B>calculateShape</B><A name="RectShape.1.calculateShape.2(379)"></A><A name="calculateShape.2(379)"></A>::&lt; (* Private *)
       (# ... #);
     
  do INNER;
  #);

</PRE><P><HR><P><H2><A name="EllipseShape">EllipseShape</A></H2><PRE CLASS=interface>
<B>EllipseShape</B><A name="EllipseShape.1(380)"></A>: StrokeableShape
  (# &lt;&lt;SLOT EllipseShapeAttributes: attributes&gt;&gt;;
     
     <B>firstPoint</B><A name="EllipseShape.1.firstPoint.2(381)"></A><A name="firstPoint.2(381)"></A>::&lt; (# do center -&gt; p #);
     
     <B>center</B><A name="EllipseShape.1.center.2(382)"></A><A name="center.2(382)"></A>: @InvalidatePoint;
     <B>horizontalradius</B><A name="EllipseShape.1.horizontalradius.2(383)"></A><A name="horizontalradius.2(383)"></A>: @InvalidateInteger;
     <B>verticalradius</B><A name="EllipseShape.1.verticalradius.2(384)"></A><A name="verticalradius.2(384)"></A>: @InvalidateInteger;
     
     <B>geometry</B><A name="EllipseShape.1.geometry.2(385)"></A><A name="geometry.2(385)"></A>:
       (#
       enter (center, verticalradius, horizontalradius)
       exit  (center, verticalradius, horizontalradius)
       #);
     <B>open</B><A name="EllipseShape.1.open.2(386)"></A><A name="open.2(386)"></A>::&lt;(# ... #);
     <B>getBounds</B><A name="EllipseShape.1.getBounds.2(387)"></A><A name="getBounds.2(387)"></A>::&lt;(# ... #);
     <B>containsPoint</B><A name="EllipseShape.1.containsPoint.2(388)"></A><A name="containsPoint.2(388)"></A>::&lt;(# ... #);
     <B>getControls</B><A name="EllipseShape.1.getControls.2(389)"></A><A name="getControls.2(389)"></A>::&lt;(# do ...; INNER #);
     <B>copy</B><A name="EllipseShape.1.copy.2(390)"></A><A name="copy.2(390)"></A>::&lt; (# do INNER; ... #);
     
     (* HIGHLIGHTING *)
     <B>hiliteOutline</B><A name="EllipseShape.1.hiliteOutline.2(391)"></A><A name="hiliteOutline.2(391)"></A>::&lt; (# do INNER; ... #);
     
     (* INTERACTION *)
     <B>interactiveCreate</B><A name="EllipseShape.1.interactiveCreate.2(392)"></A><A name="interactiveCreate.2(392)"></A>::&lt;(# ... #);
     <B>interactiveReshape</B><A name="EllipseShape.1.interactiveReshape.2(393)"></A><A name="interactiveReshape.2(393)"></A>::&lt;(# do ...; INNER #);
     
     <B>writePS</B><A name="EllipseShape.1.writePS.2(394)"></A><A name="writePS.2(394)"></A>::&lt;(# do ... #);
     <B>transform</B><A name="EllipseShape.1.transform.2(395)"></A><A name="transform.2(395)"></A>::&lt;(# ... #);
     <B>calculateShape</B><A name="EllipseShape.1.calculateShape.2(396)"></A><A name="calculateShape.2(396)"></A>::&lt; (* private *)
       (# do ... #);
     
  do INNER;
  #);

</PRE><P><HR><P><H2><A name="Rasters">Rasters</A></H2><PRE CLASS=interface>
<B>Raster</B><A name="Raster.1(397)"></A>:
  (* An abstract superpattern for all Rasters. A raster is a
   * rectangular grid of pixels.
   *)
  (# &lt;&lt;SLOT RasterAttributes: attributes&gt;&gt;;
     
     <B>hotspot</B><A name="Raster.1.hotspot.2(398)"></A><A name="hotspot.2(398)"></A>:
       (* When used in a filling operation hotspot is placed in
        * hotspot of the shape being filled. Defaults to (0,0).
        *)
       (# p: @Point;                 
       enter (# enter p ... #)
       exit  (# ... exit p #)
       #);
     <B>pixel</B><A name="Raster.1.pixel.2(399)"></A><A name="pixel.2(399)"></A>:&lt; Object;
     
     <B>init</B><A name="Raster.1.init.2(400)"></A><A name="init.2(400)"></A>:&lt;
       (# width, height: @integer;
       enter (width, height)
       ...
       #);
     <B>copy</B><A name="Raster.1.copy.2(401)"></A><A name="copy.2(401)"></A>:&lt; (* Return a deep copy of THIS(Raster) *)
       (# aCopy: ^Raster;
       ...
       exit aCopy[]
       #);
     <B>width</B><A name="Raster.1.width.2(402)"></A><A name="width.2(402)"></A>: integerValue
       (* returns the width set by init or by read operations *)
       (# ... #);
     <B>height</B><A name="Raster.1.height.2(403)"></A><A name="height.2(403)"></A>: integerValue
       (* returns the height set by init or by read operations *)
       (# ... #);
     
     <B>putPixel</B><A name="Raster.1.putPixel.2(404)"></A><A name="putPixel.2(404)"></A>:&lt;
       (# i, j: @integer; p: ^pixel;
       enter (i,j,p[])
       ...
       #);
     <B>getPixel</B><A name="Raster.1.getPixel.2(405)"></A><A name="getPixel.2(405)"></A>:&lt;
       (# i, j: @integer; p: ^pixel;
       enter (i,j)
       ...
       exit p[]
       #);
     
     (* Private *)
     <B>calculate</B><A name="Raster.1.calculate.2(406)"></A><A name="calculate.2(406)"></A>:&lt; (# ... #);
     <B>RasterPrivatePart</B><A name="Raster.1.RasterPrivatePart.2(407)"></A><A name="RasterPrivatePart.2(407)"></A>: @ ...;
     
  do INNER; calculate;
  exit THIS(Raster)[]
  #);

<B>BitMap</B><A name="BitMap.1(408)"></A>: Raster
  (* Raster in which the pixels are booleans *)
  (# &lt;&lt;SLOT BitmapAttributes: attributes&gt;&gt;;
     
     <B>pixel</B><A name="BitMap.1.pixel.2(409)"></A><A name="pixel.2(409)"></A>::&lt; (# b: @boolean enter b exit b #);
     <B>init</B><A name="BitMap.1.init.2(410)"></A><A name="init.2(410)"></A>::&lt;  (# do ...; INNER #);
     <B>putPixel</B><A name="BitMap.1.putPixel.2(411)"></A><A name="putPixel.2(411)"></A>::&lt; (# do ...; INNER #);
     <B>getPixel</B><A name="BitMap.1.getPixel.2(412)"></A><A name="getPixel.2(412)"></A>::&lt; (# do ...; INNER #);
     <B>copy</B><A name="BitMap.1.copy.2(413)"></A><A name="copy.2(413)"></A>::&lt; (# do INNER; ... #);
     <B>writeToPBMfile</B><A name="BitMap.1.writeToPBMfile.2(414)"></A><A name="writeToPBMfile.2(414)"></A>: (* Not Yet Implemented *)
       (# pbmfilename: ^text;
          rawbits: @boolean
            (* If true, the RAWBITS format is used *);
       enter (pbmfilename[],rawbits)
       ... 
       #);
     <B>readFromPBMfile</B><A name="BitMap.1.readFromPBMfile.2(415)"></A><A name="readFromPBMfile.2(415)"></A>:
       (# pbmfilename: ^text;
       enter pbmfilename[]
       do ...;
       #);
     
     (* Private *)
     <B>calculate</B><A name="BitMap.1.calculate.2(416)"></A><A name="calculate.2(416)"></A>::&lt; (# ... #);
     <B>BitMapPrivatePart</B><A name="BitMap.1.BitMapPrivatePart.2(417)"></A><A name="BitMapPrivatePart.2(417)"></A>: @ ...;
  do INNER;
  #);

<B>GrayMap</B><A name="GrayMap.1(418)"></A>: Raster (* Not Yet Implemented *)
  (# &lt;&lt;SLOT GraymapAttributes: attributes&gt;&gt;;
     
     <B>pixel</B><A name="GrayMap.1.pixel.2(419)"></A><A name="pixel.2(419)"></A>::&lt;(# g: @integer enter g exit g #);
     <B>init</B><A name="GrayMap.1.init.2(420)"></A><A name="init.2(420)"></A>::&lt; (# ... #);
     <B>putPixel</B><A name="GrayMap.1.putPixel.2(421)"></A><A name="putPixel.2(421)"></A>::&lt; (# ... #);
     <B>getPixel</B><A name="GrayMap.1.getPixel.2(422)"></A><A name="getPixel.2(422)"></A>::&lt;(# ... #);
     <B>copy</B><A name="GrayMap.1.copy.2(423)"></A><A name="copy.2(423)"></A>::&lt;(# do INNER; ... #);
     <B>writeToPGMfile</B><A name="GrayMap.1.writeToPGMfile.2(424)"></A><A name="writeToPGMfile.2(424)"></A>:
       (# pgmfilename: ^text;
          rawbits: @boolean
            (* If true, the RAWBITS format is used *);
       enter (pgmfilename[],rawbits)
       ... 
       #);
     <B>readFromPGMfile</B><A name="GrayMap.1.readFromPGMfile.2(425)"></A><A name="readFromPGMfile.2(425)"></A>:
       (# pgmfilename: ^text;
       enter pgmfilename[]
       ... 
       #);
     
     (* Private *)
     <B>calculate</B><A name="GrayMap.1.calculate.2(426)"></A><A name="calculate.2(426)"></A>::&lt; (# ... #);
     <B>GrayMapPrivatePart</B><A name="GrayMap.1.GrayMapPrivatePart.2(427)"></A><A name="GrayMapPrivatePart.2(427)"></A>: @ ...;
  do INNER;
  #);

<B>PixMap</B><A name="PixMap.1(428)"></A>: Raster
  (* Raster in which the pixels are RGB values *)
  (# &lt;&lt;SLOT PixmapAttributes: attributes&gt;&gt;;
     
     <B>pixel</B><A name="PixMap.1.pixel.2(429)"></A><A name="pixel.2(429)"></A>::&lt; (# r,g,b: @integer enter (r,g,b) exit (r,g,b) #);
     <B>init</B><A name="PixMap.1.init.2(430)"></A><A name="init.2(430)"></A>::&lt; 
       (# maxVal: @integer; (* Maximum RGB value *)
       enter maxVal
       do ...; INNER
       #);
     <B>putPixel</B><A name="PixMap.1.putPixel.2(431)"></A><A name="putPixel.2(431)"></A>::&lt; (# do ...; INNER #);
     <B>getPixel</B><A name="PixMap.1.getPixel.2(432)"></A><A name="getPixel.2(432)"></A>::&lt; (# ... #);
     <B>copy</B><A name="PixMap.1.copy.2(433)"></A><A name="copy.2(433)"></A>::&lt; (# do INNER; ... #);
     <B>writeToPPMfile</B><A name="PixMap.1.writeToPPMfile.2(434)"></A><A name="writeToPPMfile.2(434)"></A>:  (* Not Yet Implemented *)
       (# ppmfilename: ^text;
          rawbits: @boolean
            (* If true, the RAWBITS format is used *);
       enter (ppmfilename[],rawbits)
       ... 
       #);
     <B>readFromPPMfile</B><A name="PixMap.1.readFromPPMfile.2(435)"></A><A name="readFromPPMfile.2(435)"></A>:  (* Not Yet Implemented *)
       (# ppmfilename: ^text;
       enter ppmfilename[]
       ... 
       #);
     
     (* Private *)
     <B>calculate</B><A name="PixMap.1.calculate.2(436)"></A><A name="calculate.2(436)"></A>::&lt; (# ... #);
     <B>PixMapPrivatePart</B><A name="PixMap.1.PixMapPrivatePart.2(437)"></A><A name="PixMapPrivatePart.2(437)"></A>: @ ...;
     
  do INNER;
  #);  

</PRE><P><HR><P><H2><A name="Paint">Paint</A></H2><PRE CLASS=interface>
<B>Paint</B><A name="Paint.1(438)"></A>: (* An abstract superpattern for all paint *)
  (# &lt;&lt;SLOT PaintAttributes: attributes&gt;&gt;;
     
     <B>init</B><A name="Paint.1.init.2(439)"></A><A name="init.2(439)"></A>:&lt; object;
     
     <B>copy</B><A name="Paint.1.copy.2(440)"></A><A name="copy.2(440)"></A>:&lt; (* Return a deep copy of THIS(Paint) *)
       (# aCopy: ^Paint;
       ...
       exit aCopy[]
       #);
     <B>fill</B><A name="Paint.1.fill.2(441)"></A><A name="fill.2(441)"></A>: 
       (* Prefix for fill operations *)
       (# theCanvas: ^BifrostCanvas enter theCanvas[] do INNER #);
     <B>fillShape</B><A name="Paint.1.fillShape.2(442)"></A><A name="fillShape.2(442)"></A>:&lt; fill
       (* Fill theShape with THIS(Paint) in theCanvas. *)
       (# theShape: ^Shape;
       enter (theShape[])
       ...
       #);
     <B>fillLine</B><A name="Paint.1.fillLine.2(443)"></A><A name="fillLine.2(443)"></A>:&lt; fill
       (* Fill theLine with THIS(Paint) in theCanvas. *)   
       (# theLine: ^LineShape;
       enter (theLine[])
       ...
       #);
     <B>fillMultiLine</B><A name="Paint.1.fillMultiLine.2(444)"></A><A name="fillMultiLine.2(444)"></A>:&lt; fill
       (* Fill theMultiLine with THIS(Paint) in theCanvas.
        *)   
       (# theMultiLine: ^MultiLineShape;
       enter (theMultiLine[])
       ...
       #);
     <B>fillText</B><A name="Paint.1.fillText.2(445)"></A><A name="fillText.2(445)"></A>:&lt; fill
       (* Fill the specified text with THIS(Paint) in theCanvas *)
       (# theText: ^TextShape;
       enter (theText[])
       ...
       #);
     <B>fillPie</B><A name="Paint.1.fillPie.2(446)"></A><A name="fillPie.2(446)"></A>:&lt; fill
       (* Fill thePie with THIS(Paint) in theCanvas. *)   
       (# thePie: ^pieShape;
       enter (thePie[])
       ...
       #);
     <B>fillArc</B><A name="Paint.1.fillArc.2(447)"></A><A name="fillArc.2(447)"></A>:&lt; fill
       (* Fill theArc with THIS(Paint) in theCanvas. *)   
       (# theArc: ^arcShape;
       enter (theArc[])
       ...
       #);
     <B>fillRect</B><A name="Paint.1.fillRect.2(448)"></A><A name="fillRect.2(448)"></A>:&lt; fill
       (* Fill theRect with THIS(Paint) in theCanvas. *)   
       (# theRect: ^RectShape;
       enter (theRect[])
       ...
       #);
     <B>fillEllipse</B><A name="Paint.1.fillEllipse.2(449)"></A><A name="fillEllipse.2(449)"></A>:&lt; fill
       (* Fill the theEllipse with THIS(Paint) in theCanvas *)   
       (# theEllipse: ^EllipseShape;
       enter (theEllipse[])
       ...
       #);
     <B>fillOther</B><A name="Paint.1.fillOther.2(450)"></A><A name="fillOther.2(450)"></A>:&lt; fill
       (* Used to fill other, e.g. user defined, shapes *)
       (# theShape: ^AbstractShape;
       enter theShape[]
       do INNER;
       #);
     
     (* PRIVATE *)
     <B>writePS</B><A name="Paint.1.writePS.2(451)"></A><A name="writePS.2(451)"></A>:&lt;
       (# out: ^stream; shape_hotspot: @point
       enter (out[], shape_hotspot)
       do INNER 
       #);
     <B>paintprivate</B><A name="Paint.1.paintprivate.2(452)"></A><A name="paintprivate.2(452)"></A>: @ ...;
     <B>setSpecialPaint</B><A name="Paint.1.setSpecialPaint.2(453)"></A><A name="setSpecialPaint.2(453)"></A>: (* Private *)
       (# theCanvas: ^BifrostCanvas;
          doneInInner: @boolean; 
       enter theCanvas[]
       do INNER 
       #);
     <B>setCanvasPaint</B><A name="Paint.1.setCanvasPaint.2(454)"></A><A name="setCanvasPaint.2(454)"></A>:&lt; (* Private *) setSpecialPaint;
     <B>setBorderPaint</B><A name="Paint.1.setBorderPaint.2(455)"></A><A name="setBorderPaint.2(455)"></A>:&lt; (* Private *) setSpecialPaint;
     <B>SetBackgroundPaint</B><A name="Paint.1.SetBackgroundPaint.2(456)"></A><A name="SetBackgroundPaint.2(456)"></A>:&lt; (* Private *) setSpecialPaint;
  do INNER;
  exit THIS(Paint)[]
  #);

</PRE><P><HR><P><H2><A name="SolidColor">SolidColor</A></H2><PRE CLASS=interface>
<B>SolidColor</B><A name="SolidColor.1(457)"></A>: Paint
  (* A solid color specified relative to the RGB, HSV, or CMY color
   * spaces, or by naming the color, using one of the name patterns
   * in the fragment ColorNames.
   *)
  (# &lt;&lt;SLOT SolidColorAttributes: attributes&gt;&gt;;
     
     <B>init</B><A name="SolidColor.1.init.2(458)"></A><A name="init.2(458)"></A>::&lt;(# ... #);
     <B>copy</B><A name="SolidColor.1.copy.2(459)"></A><A name="copy.2(459)"></A>::&lt; (# do INNER; ... #);
     <B>Name</B><A name="SolidColor.1.Name.2(460)"></A><A name="Name.2(460)"></A>:
       (* Change THIS(SolidColor) to the color specified.  The color
        * names are define as descriptors in the fragment
        * 'ColorNames'.  NOTICE: This is different from earlier
        * versions of Bifrost.
        *)
       (# enter RGBvalues #);
     <B>RGBvalues</B><A name="SolidColor.1.RGBvalues.2(461)"></A><A name="RGBvalues.2(461)"></A>:
       (* Set or query the Red-Green-Blue values of THIS(SolidColor)
        * r, g and b all ranges from 0 to MaxRGB.
        *)
       (# r,g,b: @Integer;
          changeRGB:
            (# enter (r,g,b) ... #);
          getRGB: 
            (# ... exit (r,g,b) #);
       enter changeRGB
       exit GetRGB
       #);
     <B>HSVvalues</B><A name="SolidColor.1.HSVvalues.2(462)"></A><A name="HSVvalues.2(462)"></A>:
       (* Set or query the Hue-Saturation-Value values of
        * THIS(SolidColor).  h, s and v are taken to range from 0 to
        * MaxHue, MaxSat and MaxVal respectively. Specializations may
        * alter the default bindings of these.
        *)
       (# h,s,v: @Integer;
          changeHSV:
            (# enter (h,s,v) do ... #);
          getHSV:
            (# do ... exit (h,s,v) #);
          MaxHue:&lt; integerValue
            (# do DefaultMaxHue -&gt; value; INNER #);
          MaxSat:&lt; integerValue
            (# do DefaultMaxSat -&gt; value; INNER #);
          MaxVal:&lt; integerValue
            (# do DefaultMaxVal -&gt; value; INNER #);
       enter changeHSV
       exit getHSV
       #);
     <B>CMYvalues</B><A name="SolidColor.1.CMYvalues.2(463)"></A><A name="CMYvalues.2(463)"></A>: (* RGB complementaries *)
       (* Set or query the Cyan-Magenta-Yellow values of
        * THIS(SolidColor).  c, m and y all ranges from 0 to MaxRGB.
        *)
     (# c,m,y: @Integer;
        changeCMY:
          (# enter (c,m,y) do ... #);
        getCMY: 
          (# do ...; exit (c,m,y) #);
     enter changeCMY
     exit getCMY
     #);
     
     <B>fillShape</B><A name="SolidColor.1.fillShape.2(464)"></A><A name="fillShape.2(464)"></A>::&lt;(# ... #);
     <B>fillLine</B><A name="SolidColor.1.fillLine.2(465)"></A><A name="fillLine.2(465)"></A>::&lt;(# do INNER; ... #);
     <B>fillMultiLine</B><A name="SolidColor.1.fillMultiLine.2(466)"></A><A name="fillMultiLine.2(466)"></A>::&lt;(# ... #);
     <B>fillText</B><A name="SolidColor.1.fillText.2(467)"></A><A name="fillText.2(467)"></A>::&lt;(# do INNER; ... #);
     <B>fillPie</B><A name="SolidColor.1.fillPie.2(468)"></A><A name="fillPie.2(468)"></A>::&lt;(# do INNER; ... #);
     <B>fillArc</B><A name="SolidColor.1.fillArc.2(469)"></A><A name="fillArc.2(469)"></A>::&lt;(# do INNER; ... #);
     <B>fillRect</B><A name="SolidColor.1.fillRect.2(470)"></A><A name="fillRect.2(470)"></A>::&lt;(# do INNER; ... #);
     <B>fillEllipse</B><A name="SolidColor.1.fillEllipse.2(471)"></A><A name="fillEllipse.2(471)"></A>::&lt;(# do INNER; ... #);
     
     (* PRIVATE *)
     <B>writePS</B><A name="SolidColor.1.writePS.2(472)"></A><A name="writePS.2(472)"></A>::&lt;(# do ... #);
     <B>setBorderPaint</B><A name="SolidColor.1.setBorderPaint.2(473)"></A><A name="setBorderPaint.2(473)"></A>::&lt; (* Private *)
       (# ...#);
     <B>setBackgroundPaint</B><A name="SolidColor.1.setBackgroundPaint.2(474)"></A><A name="setBackgroundPaint.2(474)"></A>::&lt; (* Private *)
       (# ...#);
     <B>setCanvasPaint</B><A name="SolidColor.1.setCanvasPaint.2(475)"></A><A name="setCanvasPaint.2(475)"></A>::&lt; (* Private *)
       (# ...#);
     <B>privatePart</B><A name="SolidColor.1.privatePart.2(476)"></A><A name="privatePart.2(476)"></A>: @ ...;
  do INNER;
  #);

</PRE><P><HR><P><H2><A name="Predefined Graytones">Predefined Graytones</A></H2><PRE CLASS=interface>
<B>SolidGray</B><A name="SolidGray.1(477)"></A>:
  (# <B>g</B><A name="SolidGray.1.g.2(478)"></A><A name="g.2(478)"></A>: ^SolidColor;
     <B>percentage</B><A name="SolidGray.1.percentage.2(479)"></A><A name="percentage.2(479)"></A>: @Integer;
  enter percentage
  ...
  exit g[]
  #);

<B>SolidGrey</B><A name="SolidGrey.1(480)"></A>: SolidGray (# do INNER #);

</PRE><P><HR><P><H2><A name="RasterPaint">RasterPaint</A></H2><PRE CLASS=interface>
<B>RasterPaint</B><A name="RasterPaint.1(481)"></A>: Paint
  (* Use thePixmap and optionally paddingSolidColor to fill out the
   * shape
   *)
  (# 
     (* If paddingSolidColor[]=NONE thePixmap will be repeated when
      * filling out the shape. If not, paddingSolidColor will be used
      * to fill out any parts of the shape the pixmap doesn't cover.
      *)
     <B>paddingSolidColor</B><A name="RasterPaint.1.paddingSolidColor.2(482)"></A><A name="paddingSolidColor.2(482)"></A>: ^SolidColor;
     
     <B>thePixMap</B><A name="RasterPaint.1.thePixMap.2(483)"></A><A name="thePixMap.2(483)"></A>: 
       (# p: ^PixMap;
       enter (# enter p[] ... #)
       exit (# ... exit p[] #)
       #);
     <B>init</B><A name="RasterPaint.1.init.2(484)"></A><A name="init.2(484)"></A>::&lt;(# ... #); 
     <B>copy</B><A name="RasterPaint.1.copy.2(485)"></A><A name="copy.2(485)"></A>::&lt;(# do INNER; ... #);
     <B>fillShape</B><A name="RasterPaint.1.fillShape.2(486)"></A><A name="fillShape.2(486)"></A>::&lt;(# do INNER; ...; #);
     <B>fillLine</B><A name="RasterPaint.1.fillLine.2(487)"></A><A name="fillLine.2(487)"></A>::&lt;(# ... #);
     <B>fillMultiLine</B><A name="RasterPaint.1.fillMultiLine.2(488)"></A><A name="fillMultiLine.2(488)"></A>::&lt;(# ... #);
     <B>fillText</B><A name="RasterPaint.1.fillText.2(489)"></A><A name="fillText.2(489)"></A>::&lt;(# ... #);
     <B>fillArc</B><A name="RasterPaint.1.fillArc.2(490)"></A><A name="fillArc.2(490)"></A>::&lt;(# ... #);
     <B>fillPie</B><A name="RasterPaint.1.fillPie.2(491)"></A><A name="fillPie.2(491)"></A>::&lt;(# ... #);
     <B>fillRect</B><A name="RasterPaint.1.fillRect.2(492)"></A><A name="fillRect.2(492)"></A>::&lt;(# ... #);
     <B>fillEllipse</B><A name="RasterPaint.1.fillEllipse.2(493)"></A><A name="fillEllipse.2(493)"></A>::&lt;(# ... #);
     
     (* PRIVATE *)
     <B>writePS</B><A name="RasterPaint.1.writePS.2(494)"></A><A name="writePS.2(494)"></A>::&lt;(# do ... #);
     <B>private</B><A name="RasterPaint.1.private.2(495)"></A><A name="private.2(495)"></A>: @...;
     <B>setBorderPaint</B><A name="RasterPaint.1.setBorderPaint.2(496)"></A><A name="setBorderPaint.2(496)"></A>::&lt;  (* Private *)
       (# do INNER; ... #);
     <B>setBackgroundPaint</B><A name="RasterPaint.1.setBackgroundPaint.2(497)"></A><A name="setBackgroundPaint.2(497)"></A>::&lt;  (* Private *)
       (# do INNER; ... #);
     <B>setCanvasPaint</B><A name="RasterPaint.1.setCanvasPaint.2(498)"></A><A name="setCanvasPaint.2(498)"></A>::&lt; (* Private *)
       (# do INNER; ... #);
  do INNER;
  #);

</PRE><P><HR><P><H2><A name="TiledSolidColor">TiledSolidColor</A></H2><PRE CLASS=interface>
<B>TiledSolidColor</B><A name="TiledSolidColor.1(499)"></A>: SolidColor
  (* A SolidColor extended with a BitMap. The BitMap will be tiled in
   * the Shape before the SolidColor is applied, and only where the
   * bits of the BitMap are true, the SolidColor will be visible.
   *)
  (# 
     <B>theTile</B><A name="TiledSolidColor.1.theTile.2(500)"></A><A name="theTile.2(500)"></A>: 
       (# t: ^BitMap;
       enter (# enter t[] ... #)
       exit (# ... exit t[] #)
       #);
     <B>init</B><A name="TiledSolidColor.1.init.2(501)"></A><A name="init.2(501)"></A>::&lt;(# ... #); 
     <B>copy</B><A name="TiledSolidColor.1.copy.2(502)"></A><A name="copy.2(502)"></A>::&lt;(# do INNER; ... #);
     <B>fillShape</B><A name="TiledSolidColor.1.fillShape.2(503)"></A><A name="fillShape.2(503)"></A>::&lt;(# ... #);
     <B>fillLine</B><A name="TiledSolidColor.1.fillLine.2(504)"></A><A name="fillLine.2(504)"></A>::&lt;(# ... #);
     <B>fillMultiLine</B><A name="TiledSolidColor.1.fillMultiLine.2(505)"></A><A name="fillMultiLine.2(505)"></A>::&lt;(# ... #);
     <B>fillText</B><A name="TiledSolidColor.1.fillText.2(506)"></A><A name="fillText.2(506)"></A>::&lt;(# ... #);
     <B>fillArc</B><A name="TiledSolidColor.1.fillArc.2(507)"></A><A name="fillArc.2(507)"></A>::&lt;(# ... #);
     <B>fillPie</B><A name="TiledSolidColor.1.fillPie.2(508)"></A><A name="fillPie.2(508)"></A>::&lt;(# ... #);
     <B>fillRect</B><A name="TiledSolidColor.1.fillRect.2(509)"></A><A name="fillRect.2(509)"></A>::&lt;(# ... #);
     <B>fillEllipse</B><A name="TiledSolidColor.1.fillEllipse.2(510)"></A><A name="fillEllipse.2(510)"></A>::&lt;(# ... #);
     
     (* PRIVATE *)
     <B>writePS</B><A name="TiledSolidColor.1.writePS.2(511)"></A><A name="writePS.2(511)"></A>::&lt;(# do ... #);
     <B>tiledPrivate</B><A name="TiledSolidColor.1.tiledPrivate.2(512)"></A><A name="tiledPrivate.2(512)"></A>: @ ...;
     <B>setBorderPaint</B><A name="TiledSolidColor.1.setBorderPaint.2(513)"></A><A name="setBorderPaint.2(513)"></A>::&lt;  (* Private *)
       (# do INNER; ... #);
     <B>setBackgroundPaint</B><A name="TiledSolidColor.1.setBackgroundPaint.2(514)"></A><A name="setBackgroundPaint.2(514)"></A>::&lt; (* Private *)
       (# do INNER; ... #);
     <B>setCanvasPaint</B><A name="TiledSolidColor.1.setCanvasPaint.2(515)"></A><A name="setCanvasPaint.2(515)"></A>::&lt; (* Private *)
       (# do INNER; ... #);
  do INNER;
  #);

</PRE><P><HR><P><H2><A name="AbstractGraphicalObject">AbstractGraphicalObject</A></H2><PRE CLASS=interface>
<B>AbstractGraphicalObject</B><A name="AbstractGraphicalObject.1(516)"></A>: (* To be further specialized *)
  (* The graphical object is the smallest entity that can be drawn
   * in a BifrostCanvas.  It is a aggregation of a Paint and a Shape.
   * ANY graphical object MUST be initialized before used (init).
   * After a paint and a shape has been specified, it can be drawn by
   * giving the reference of it as enter parameter to the method
   * "draw" in a BifrostCanvas.  Graphical objects may also be
   * created by using InteractiveCreateShape.
   *)
(# &lt;&lt;SLOT AbstractGraphicalObjectAttributes: attributes&gt;&gt;;
   <B>shapeDesc</B><A name="AbstractGraphicalObject.1.shapeDesc.2(517)"></A><A name="shapeDesc.2(517)"></A>:&lt; AbstractShape
     (* Specify actual shape in specializations *);
   <B>TMDesc</B><A name="AbstractGraphicalObject.1.TMDesc.2(518)"></A><A name="TMDesc.2(518)"></A>:&lt; 
     (# m: ^Matrix;
        transformpoint: @
          (# p: @Point enter p do p-&gt;m.transformpoint-&gt;p exit p #);
        CalcCanvasTM:&lt; 
          (# theTM: ^Matrix 
          enter theTM[]
          ...
          #);
        enterTM:&lt; (# enter m[] ... #);
        enterIt: @enterTM;
     enter enterIt
     do INNER;
     exit m[]
     #);
   (* TM describes the transformation from the coordinate system of
    * theShape (also known as GO coordinates) to the the Picture it
    * is part of, if any.
    *)
   <B>TM</B><A name="AbstractGraphicalObject.1.TM.2(519)"></A><A name="TM.2(519)"></A>: @TMDesc;
   
   <B>init</B><A name="AbstractGraphicalObject.1.init.2(520)"></A><A name="init.2(520)"></A>:&lt; (* MUST be called first *)
     (# ... #);
   <B>readUserData</B><A name="AbstractGraphicalObject.1.readUserData.2(521)"></A><A name="readUserData.2(521)"></A>:&lt;
     (#
        userdata: ^text;
        success: @boolean;
        parseNotification: notification
          (#
          do false -&gt; success;
             INNER
          #);
        parseError:&lt; parseNotification
     enter userdata[]
     do true -&gt; success;
        INNER
     exit success
     #);
   <B>writeUserData</B><A name="AbstractGraphicalObject.1.writeUserData.2(522)"></A><A name="writeUserData.2(522)"></A>:&lt;
     (# 
        userdata: ^text
     do &amp;text[] -&gt; userdata[]; INNER
     exit userdata[]
     #);
   <B>setPaint</B><A name="AbstractGraphicalObject.1.setPaint.2(523)"></A><A name="setPaint.2(523)"></A>:&lt;
     (* Specify the paint to use for THIS(AbstractGraphicalObject) *)
     (# enter thePaint[] do INNER #);
   <B>getPaint</B><A name="AbstractGraphicalObject.1.getPaint.2(524)"></A><A name="getPaint.2(524)"></A>:&lt; 
     (* Obtain the paint to use *)
     (# do INNER exit thePaint[] #);
   <B>getShape</B><A name="AbstractGraphicalObject.1.getShape.2(525)"></A><A name="getShape.2(525)"></A>:&lt;
     (* Obtain the shape to use.  The specialization
      * PredefinedGraphicalObject returns an approximating Shape.
      * Only the specialization Shape has a corresponding SetShape.
      *)
     (# s: ^Shape
     do INNER
     exit s[]
     #);  
   <B>draw</B><A name="AbstractGraphicalObject.1.draw.2(526)"></A><A name="draw.2(526)"></A>:&lt;
     (* Draw THIS(AbstractGraphicalObject) in theCanvas.
      * Normally this is not used by the user directly.  Instead
      * THIS(AbstractGraphicalObject)[] should be given to the draw
      * method of a BifrostCanvas.
      *)
     (# doneInInner: @boolean;
        theCanvas: ^BifrostCanvas
          (* BifrostCanvas to draw THIS(AbstractGraphicalObject) on *);
     enter theCanvas[]
     ...
     #);
   <B>erase</B><A name="AbstractGraphicalObject.1.erase.2(527)"></A><A name="erase.2(527)"></A>:&lt;
     (* Erase THIS(AbstractGraphicalObject) from theCanvas.
      * Normally this is not used by the user directly.  Instead
      * THIS(AbstractGraphicalObject)[] should be given to the erase
      * method of a BifrostCanvas.
      *)
     (# doneInInner: @boolean;
        theCanvas: ^BifrostCanvas
          (* BifrostCanvas to erase THIS(AbstractGraphicalObject) from *);
     enter theCanvas[]
     ... 
     #);
   <B>copy</B><A name="AbstractGraphicalObject.1.copy.2(528)"></A><A name="copy.2(528)"></A>:&lt; (* Return a deep copy of THIS(AbstractGraphicalObject) *)
     (# aCopy: ^AbstractGraphicalObject;
     ...
     exit aCopy[]
     #);
   <B>getBounds</B><A name="AbstractGraphicalObject.1.getBounds.2(529)"></A><A name="getBounds.2(529)"></A>:&lt;
     (* Exit a Rectangle containing the bounding box of
      * THIS(AbstractGraphicalObject) in BifrostCanvas coordinates.
      *)
     (# r: @rectangle;
        doneInInner: @boolean;
     ...
     exit r
     #);
   <B>hilite</B><A name="AbstractGraphicalObject.1.hilite.2(530)"></A><A name="hilite.2(530)"></A>:&lt; (* Highlight THIS(AbstractGraphicalObject) *)
     (# doneInInner: @boolean;
        theCanvas: ^BifrostCanvas
          (* The BifrostCanvas to do the highlighting on *)
     enter theCanvas[]
     ...
     #);
   <B>unHilite</B><A name="AbstractGraphicalObject.1.unHilite.2(531)"></A><A name="unHilite.2(531)"></A>:&lt; (* Unhighlight THIS(AbstractGraphicalObject) *)
     (# doneInInner: @boolean;
        theCanvas: ^BifrostCanvas
          (* The BifrostCanvas to do the unhighlighting on *)
     enter theCanvas[]
     ...
     #);
   
   (* INTERACTION *)
   <B>hitControl</B><A name="AbstractGraphicalObject.1.hitControl.2(532)"></A><A name="hitControl.2(532)"></A>:&lt;
     (* Answer whether thePoint is inside a 2x2mm box around a
      * control point of THIS(AbstractGraphicalObject).  thePoint is
      * in BifrostCanvas coordinates.  Exits reference to exact point
      * if hit, NONE otherwise.
      *)   
     (# thePoint: @Point;
        res: ^Point;
     enter thePoint
     do ...;
        INNER;
     exit res[]
     #);
   <B>interaction</B><A name="AbstractGraphicalObject.1.interaction.2(533)"></A><A name="interaction.2(533)"></A>: 
     (* Prefix for interactive operations *)
     (# theCanvas: ^BifrostCanvas
          (* The BifrostCanvas to show feedback in *);
        startPoint: @Point;
        theModifier: @Modifier;
        doneInInner: @boolean;
     enter (theCanvas[], startPoint, theModifier)
     do INNER;
     #);
   <B>interactiveCreateShape</B><A name="AbstractGraphicalObject.1.interactiveCreateShape.2(534)"></A><A name="interactiveCreateShape.2(534)"></A>:&lt; interaction
     (* Initialize the shape of THIS(AbstractGraphicalObject) by
      * providing feedback in a BifrostCanvas.  Normally this is not
      * used by the user directly.  Instead
      * THIS(AbstractGraphicalObject)[] should be given to the
      * interactiveCreateShape method of a BifrostCanvas.
      *)
     (# ... #);
   <B>interactiveCombineShape</B><A name="AbstractGraphicalObject.1.interactiveCombineShape.2(535)"></A><A name="interactiveCombineShape.2(535)"></A>:&lt; interaction 
     (* Combine a shape with the shape of
      * THIS(AbstractGraphicalObject) by providing feedback for
      * creating the new shape in a BifrostCanvas, and then combining
      * the shape of THIS(AbstractGraphicalObject) with the obtained
      * shape.  Normally this is not used by the user directly.
      * Instead THIS(AbstractGraphicalObject)[] should be given to
      * the interactiveCombineShape method of a BifrostCanvas.
      *)
     (# ... #);
   <B>interactiveReshape</B><A name="AbstractGraphicalObject.1.interactiveReshape.2(536)"></A><A name="interactiveReshape.2(536)"></A>:&lt; interaction
     (* Change the shape of THIS(AbstractGraphicalObject) by
      * providing feedback in a BifrostCanvas.  Normally this is not
      * used by the user directly.  Instead
      * THIS(AbstractGraphicalObject)[] should be given to the
      * interactiveReShape method of a BifrostCanvas.
      *)
     (# do ... #);
   <B>interactiveMove</B><A name="AbstractGraphicalObject.1.interactiveMove.2(537)"></A><A name="interactiveMove.2(537)"></A>:&lt; interaction
     (* Move the shape of THIS(AbstractGraphicalObject) using
      * theshape.(un)hiliteoutline for feedback in the BifrostCanvas
      * THIS(AbstractGraphicalObject) is drawn in.  Calls "move" to
      * do the transformation.  Normally this is not used by the user
      * directly.  Instead THIS(AbstractGraphicalObject)[] should be
      * given to the interactiveMove method of a BifrostCanvas.
      *)
     (# 
     do INNER; ...;
     #);
   <B>interactiveScale</B><A name="AbstractGraphicalObject.1.interactiveScale.2(538)"></A><A name="interactiveScale.2(538)"></A>:&lt; interaction (* Not Yet Implemented *)
     (* Scale the shape of THIS(AbstractGraphicalObject) using
      * theshape.(un)hiliteoutline for feedback in the BifrostCanvas
      * THIS(AbstractGraphicalObject) is drawn in.  Calls "scale" to
      * do the transformation.  Normally this is not used by the user
      * directly.  Instead THIS(AbstractGraphicalObject)[] should be
      * given to the interactiveScale method of a BifrostCanvas.
      *)
     (# ... #);
   <B>interactiveRotate</B><A name="AbstractGraphicalObject.1.interactiveRotate.2(539)"></A><A name="interactiveRotate.2(539)"></A>:&lt; interaction (* Not Yet Implemented *)
     (* Rotate the shape of THIS(AbstractGraphicalObject) using
      * theshape.(un)hiliteoutline for feedback in the BifrostCanvas
      * THIS(AbstractGraphicalObject) is drawn in.  Calls "rotate" to
      * do the transformation.  Normally this is not used by the user
      * directly.  Instead THIS(AbstractGraphicalObject)[] should be
      * given to the interactiveRotate method of a BifrostCanvas.
      *)
     (# ... #);
   
   (* TRANSFORMATIONS *)
   <B>transform</B><A name="AbstractGraphicalObject.1.transform.2(540)"></A><A name="transform.2(540)"></A>:&lt; 
     (* Transform THIS(AbstractGraphicalObject) by M, by multiplying
      * THIS(AbstractGraphicalObject).TM with M
      *)
     (# M: ^Matrix; 
     enter M[]
     ...
     #);
   <B>move</B><A name="AbstractGraphicalObject.1.move.2(541)"></A><A name="move.2(541)"></A>:&lt; (* Translate THIS(AbstractGraphicalObject) by offset *)
     (# offset: @Point;
     enter offset
     do ...; INNER;
     #);
   <B>moveTo</B><A name="AbstractGraphicalObject.1.moveTo.2(542)"></A><A name="moveTo.2(542)"></A>:&lt; 
     (* Move THIS(AbstractGraphicalObject).theShape.hotSpot to pos *)
     (# pos: @Point;
     enter pos
     do ...; INNER;
     #);
   <B>scale</B><A name="AbstractGraphicalObject.1.scale.2(543)"></A><A name="scale.2(543)"></A>:&lt; (* Scale THIS(AbstractGraphicalObject) by factor *)
     (# factor: @Vector; (* Real point *)
     enter factor
     do ...; INNER;
     #);
   <B>rotate</B><A name="AbstractGraphicalObject.1.rotate.2(544)"></A><A name="rotate.2(544)"></A>:&lt; 
     (* Rotate THIS(AbstractGraphicalObject) by angle (degrees) *)
     (# angle: @Real;
     enter angle
     do ...; INNER;
     #);
   
   (* QUERY *)
   <B>containsPoint</B><A name="AbstractGraphicalObject.1.containsPoint.2(545)"></A><A name="containsPoint.2(545)"></A>:&lt; booleanValue
     (* Answer if thePoint is inside the shape of
      * THIS(AbstractGraphicalObject).  thePoint is assumed to be in
      * coordinates relative to theCanvas.
      *)
     (# theCanvas: ^BifrostCanvas;
        thePoint: @Point;
        doneInInner: @boolean;
     enter (theCanvas[], thePoint)
     ...
     #);
   
   (* The aggregation parts *)
   <B>theShape</B><A name="AbstractGraphicalObject.1.theShape.2(546)"></A><A name="theShape.2(546)"></A>: ^ShapeDesc;
   <B>thePaint</B><A name="AbstractGraphicalObject.1.thePaint.2(547)"></A><A name="thePaint.2(547)"></A>: ^Paint;
   
   (* PRIVATE *)
   <B>writePS</B><A name="AbstractGraphicalObject.1.writePS.2(548)"></A><A name="writePS.2(548)"></A>:&lt;
     (# out: ^stream; invisible: @boolean 
     enter out[] 
     do ...
     #);
   <B>private</B><A name="AbstractGraphicalObject.1.private.2(549)"></A><A name="private.2(549)"></A>: @ ...;
   <B>recalculateShape</B><A name="AbstractGraphicalObject.1.recalculateShape.2(550)"></A><A name="recalculateShape.2(550)"></A>:&lt; (* private *)
     (# theCanvas: ^BifrostCanvas enter theCanvas[] do INNER #);
do INNER;
exit THIS(AbstractGraphicalObject)[]
#);  

</PRE><P><HR><P><H2><A name="GraphicalObject">GraphicalObject</A></H2><PRE CLASS=interface>
<B>GraphicalObject</B><A name="GraphicalObject.1(551)"></A>: AbstractGraphicalObject
  (#
     <B>shapeDesc</B><A name="GraphicalObject.1.shapeDesc.2(552)"></A><A name="shapeDesc.2(552)"></A>::&lt; (* The real shape with lines and splines *)
       Shape; 
     <B>setShape</B><A name="GraphicalObject.1.setShape.2(553)"></A><A name="setShape.2(553)"></A>: (* Set the Shape of THIS(GraphicalObject) *)
       (# enter theShape[] #);
     <B>getShape</B><A name="GraphicalObject.1.getShape.2(554)"></A><A name="getShape.2(554)"></A>::&lt; (* Get the Shape of THIS(GraphicalObject) *)
       (# do theShape[] -&gt; s[] #);
     <B>copy</B><A name="GraphicalObject.1.copy.2(555)"></A><A name="copy.2(555)"></A>::&lt; (# ... #);
     <B>draw</B><A name="GraphicalObject.1.draw.2(556)"></A><A name="draw.2(556)"></A>::&lt; (# ... #);
     <B>writePS</B><A name="GraphicalObject.1.writePS.2(557)"></A><A name="writePS.2(557)"></A>::&lt;(# do ... #);
     <B>hilite</B><A name="GraphicalObject.1.hilite.2(558)"></A><A name="hilite.2(558)"></A>::&lt; (# ... #);
     <B>unHilite</B><A name="GraphicalObject.1.unHilite.2(559)"></A><A name="unHilite.2(559)"></A>::&lt; (# ... #);
     <B>recalculateShape</B><A name="GraphicalObject.1.recalculateShape.2(560)"></A><A name="recalculateShape.2(560)"></A>::&lt; (* private *)
       (# ... #);
  do INNER
  #);

</PRE><P><HR><P><H2><A name="PictureShape">PictureShape</A></H2><PRE CLASS=interface>
<B>PictureShape</B><A name="PictureShape.1(561)"></A>: AbstractShape (* To be further specialized *)
  (# &lt;&lt;SLOT PictureShapeAttributes: attributes&gt;&gt;;
     
     <B>firstpoint</B><A name="PictureShape.1.firstpoint.2(562)"></A><A name="firstpoint.2(562)"></A>::&lt; (# ... #);
     <B>copy</B><A name="PictureShape.1.copy.2(563)"></A><A name="copy.2(563)"></A>::&lt; (# do INNER; ... #);
     <B>getBounds</B><A name="PictureShape.1.getBounds.2(564)"></A><A name="getBounds.2(564)"></A>::&lt; (# do ... #);
     <B>containsPoint</B><A name="PictureShape.1.containsPoint.2(565)"></A><A name="containsPoint.2(565)"></A>::&lt;(# ... #);
     <B>getControls</B><A name="PictureShape.1.getControls.2(566)"></A><A name="getControls.2(566)"></A>::&lt;(# ... #);
     <B>hiliteControls</B><A name="PictureShape.1.hiliteControls.2(567)"></A><A name="hiliteControls.2(567)"></A>::&lt;   (# ... #);
     <B>hiliteOutline</B><A name="PictureShape.1.hiliteOutline.2(568)"></A><A name="hiliteOutline.2(568)"></A>::&lt; (# ... #);
     <B>transform</B><A name="PictureShape.1.transform.2(569)"></A><A name="transform.2(569)"></A>::&lt;(# do ...; INNER #);
     
     (* Private *)
     <B>writePS</B><A name="PictureShape.1.writePS.2(570)"></A><A name="writePS.2(570)"></A>::&lt;(# do ... #);
     <B>pictureprivate</B><A name="PictureShape.1.pictureprivate.2(571)"></A><A name="pictureprivate.2(571)"></A>: @...;
  do INNER
  #);

</PRE><P><HR><P><H2><A name="Picture">Picture</A></H2><PRE CLASS=interface>
<B>Picture</B><A name="Picture.1(572)"></A>: AbstractGraphicalObject
  (* A collection of graphical objects *)
  (# &lt;&lt;SLOT PictureAttributes: attributes &gt;&gt;;
     
     <B>shapeDesc</B><A name="Picture.1.shapeDesc.2(573)"></A><A name="shapeDesc.2(573)"></A>::&lt; PictureShape;
     <B>TMDesc</B><A name="Picture.1.TMDesc.2(574)"></A><A name="TMDesc.2(574)"></A>::&lt;(# CalcCanvasTM::&lt;(# do ...; INNER #);
          enterTM::&lt; (# do ...; INNER #);
       do INNER;
       #);
     <B>init</B><A name="Picture.1.init.2(575)"></A><A name="init.2(575)"></A>::&lt; (# ... #);
     <B>add</B><A name="Picture.1.add.2(576)"></A><A name="add.2(576)"></A>:&lt;
       (* Add go to THIS(Picture) *)
       (# go: ^AbstractGraphicalObject;
       enter go[]                            
       ... 
       #);
     <B>delete</B><A name="Picture.1.delete.2(577)"></A><A name="delete.2(577)"></A>:&lt;
       (* Delete go from THIS(Picture) *)
       (# go: ^AbstractGraphicalObject;
       enter go[]
       ... 
       #);
     <B>drawOnPixmap</B><A name="Picture.1.drawOnPixmap.2(578)"></A><A name="drawOnPixmap.2(578)"></A>:  (* Not Yet Implemented *)
       (* Draw THIS(Picture) on pm *)
       (# pm: ^Pixmap;
       enter pm[]
       do ...;
       #);
     <B>draw</B><A name="Picture.1.draw.2(579)"></A><A name="draw.2(579)"></A>::&lt; (# ... #);
     <B>erase</B><A name="Picture.1.erase.2(580)"></A><A name="erase.2(580)"></A>::&lt; (# ... #);
     <B>copy</B><A name="Picture.1.copy.2(581)"></A><A name="copy.2(581)"></A>::&lt; (# do INNER; ... #);
     <B>setPaint</B><A name="Picture.1.setPaint.2(582)"></A><A name="setPaint.2(582)"></A>::&lt; 
       (* Specify the paint to use for all AbstractGraphicalObjects
        * in THIS(Picture). If they are shown on the Canvas, their
        * visual appearance is changed instantly.
        *)
       (# theCanvas: ^BifrostCanvas;
       enter theCanvas[]
       ...
       #);
     <B>getBounds</B><A name="Picture.1.getBounds.2(583)"></A><A name="getBounds.2(583)"></A>::&lt; (# ... #);
     <B>hilite</B><A name="Picture.1.hilite.2(584)"></A><A name="hilite.2(584)"></A>::&lt; (# ... #);
     <B>unHilite</B><A name="Picture.1.unHilite.2(585)"></A><A name="unHilite.2(585)"></A>::&lt; (# ... #);
     <B>bringForward</B><A name="Picture.1.bringForward.2(586)"></A><A name="bringForward.2(586)"></A>:
       (* Make aGO the last AbstractGraphicalObject of THIS(Picture)
        * aGO must already be a member of THIS(Picture)
        *)
       (# aGO: ^AbstractGraphicalObject;
       enter aGO[]                                                        
       ... 
       #);
     <B>sendBehind</B><A name="Picture.1.sendBehind.2(587)"></A><A name="sendBehind.2(587)"></A>:
       (* Make aGO the first AbstractGraphicalObject of THIS(Picture)
        * aGO must already be a member of THIS(Picture)
        *)
       (# aGO: ^AbstractGraphicalObject;
       enter aGO[]                                                        
       ... 
       #);
     <B>scanGOs</B><A name="Picture.1.scanGOs.2(588)"></A><A name="scanGOs.2(588)"></A>: 
       (* Scan through each AbstractGraphicalObject in THIS(Picture)
        * in order from the bottommost to the frontmost one.
        *)
       (# go: ^AbstractGraphicalObject;
       ...
       #);
     <B>scanGOsReverse</B><A name="Picture.1.scanGOsReverse.2(589)"></A><A name="scanGOsReverse.2(589)"></A>: 
       (* Scan through each AbstractGraphicalObject in THIS(Picture)
        * in order from the frontmost to the bottommost one.
        *)
       (# go: ^AbstractGraphicalObject;
       ...
       #);
     
     (* INTERACTION *)
     <B>interactiveCreateShape</B><A name="Picture.1.interactiveCreateShape.2(590)"></A><A name="interactiveCreateShape.2(590)"></A>::&lt;(# ... #);
     <B>interactiveCombineShape</B><A name="Picture.1.interactiveCombineShape.2(591)"></A><A name="interactiveCombineShape.2(591)"></A>::&lt;(# ... #);
     <B>interactiveReshape</B><A name="Picture.1.interactiveReshape.2(592)"></A><A name="interactiveReshape.2(592)"></A>::&lt;(# ... #);
     
     (* QUERY *)
     <B>lastGO</B><A name="Picture.1.lastGO.2(593)"></A><A name="lastGO.2(593)"></A>:
       (* Exit reference to last AbstractGraphicalObject in
        * THIS(Picture)
        *)
       (# aGO: ^AbstractGraphicalObject;
       ... 
       exit aGO[]
       #);
     <B>firstGO</B><A name="Picture.1.firstGO.2(594)"></A><A name="firstGO.2(594)"></A>:
       (* Exit reference to last AbstractGraphicalObject in
        * THIS(Picture)
        *)
       (# aGO: ^AbstractGraphicalObject;
       ... 
       exit aGO[]
       #);
     <B>noOfGOs</B><A name="Picture.1.noOfGOs.2(595)"></A><A name="noOfGOs.2(595)"></A>: integerValue
       (* Exit number of AbstractGraphicalObjects in THIS(Picture) *)
       (# ... #);
     <B>isEmpty</B><A name="Picture.1.isEmpty.2(596)"></A><A name="isEmpty.2(596)"></A>: booleanValue
       (* True iff no graphical objects has been added to
        * THIS(Picture)
        *)
       (# ... #);
     <B>isMember</B><A name="Picture.1.isMember.2(597)"></A><A name="isMember.2(597)"></A>: booleanValue
       (* True iff aGO has been added to THIS(Picture) *)
       (# aGO: ^AbstractGraphicalObject;
       enter aGO[]
       ...
       #);
     <B>containsPoint</B><A name="Picture.1.containsPoint.2(598)"></A><A name="containsPoint.2(598)"></A>::&lt;
       (* Answer if thePoint (canvascoordinates) is inside the shape
        * of any graphical object of THIS(Picture)
        *)
       (# ... #);
     <B>firstContaining</B><A name="Picture.1.firstContaining.2(599)"></A><A name="firstContaining.2(599)"></A>:&lt; 
       (* Returns reference to first AbstractGraphicalObject in
        * THIS(Abstract) that contains thePoint.
        * thePoint is assumed to be in coordinates relative to 
        * theCanvas.
        *)
       (# theCanvas: ^BifrostCanvas;
          thePoint: @Point;
          aGO: ^AbstractGraphicalObject;
       enter (theCanvas[], thePoint)
       ...
       exit aGO[] 
       #);
     <B>lastContaining</B><A name="Picture.1.lastContaining.2(600)"></A><A name="lastContaining.2(600)"></A>:&lt; 
       (* Returns reference to last AbstractGraphicalObject in
        * THIS(Picture) that contains thePoint.
        * thePoint is assumed to be in coordinates relative to 
        * theCanvas.
        *)
       (# theCanvas: ^BifrostCanvas;
          thePoint: @Point;
          aGO: ^AbstractGraphicalObject;
       enter (theCanvas[], thePoint)
       ...
       exit aGO[] 
       #);
     <B>writePS</B><A name="Picture.1.writePS.2(601)"></A><A name="writePS.2(601)"></A>::&lt;(# do ... #);
  do INNER;
  #);  (* Picture *)

</PRE><P><HR><P><H2><A name="BifrostCanvas">BifrostCanvas</A></H2><PRE CLASS=interface>
(* The BifrostCanvas is the connection between the graphic
 * definitions and the device. Graphical objects become visible on
 * the output device when they are added to a BifrostCanvas by the
 * use of the draw-method.
 *)

<B>BifrostCanvas</B><A name="BifrostCanvas.1(602)"></A>: Canvas
  (# &lt;&lt;SLOT CanvasAttributes: attributes &gt;&gt;;
     
     <B>thePicture</B><A name="BifrostCanvas.1.thePicture.2(603)"></A><A name="thePicture.2(603)"></A>: 
       (* Picture holding the graphical objects *)
       ^Picture; 
     <B>visualShape</B><A name="BifrostCanvas.1.visualShape.2(604)"></A><A name="visualShape.2(604)"></A>: 
       (* The part of THIS(BifrostCanvas) that is visible *)
       ^Shape; 
     <B>clipShape</B><A name="BifrostCanvas.1.clipShape.2(605)"></A><A name="clipShape.2(605)"></A>: 
       (* Shape used for clipping in THIS(BifrostCanvas). Defaults to
        * visualShape
        *)
       ^Shape;
     <B>draw</B><A name="BifrostCanvas.1.draw.2(606)"></A><A name="draw.2(606)"></A>:  (* Put GO on THIS(BifrostCanvas) *)
       (# GO: ^AbstractGraphicalObject
       enter GO[]
       ...
       #);
     <B>erase</B><A name="BifrostCanvas.1.erase.2(607)"></A><A name="erase.2(607)"></A>: (* Erase GO from THIS(BifrostCanvas) *)
       (# aGO: ^AbstractGraphicalObject;
       enter aGO[]
       ...
       #);
     <B>refresh</B><A name="BifrostCanvas.1.refresh.2(608)"></A><A name="refresh.2(608)"></A>: (* Mark entire BifrostCanvas as damaged and repair *)
       ...;
     <B>scanThePicture</B><A name="BifrostCanvas.1.scanThePicture.2(609)"></A><A name="scanThePicture.2(609)"></A>: 
       (* Scan through each AbstractGraphicalObject in thePicture in
        * order from the bottommost to the frontmost one.
        *)
       (# go: ^AbstractGraphicalObject;
       ...
       #);
     <B>scanThePictureReverse</B><A name="BifrostCanvas.1.scanThePictureReverse.2(610)"></A><A name="scanThePictureReverse.2(610)"></A>: 
       (* Scan through each AbstractGraphicalObject in thePicture in
        * order from the frontmost to the bottommost one.
        *)
       (# go: ^AbstractGraphicalObject;
       ...
       #);
     <B>firstContaining</B><A name="BifrostCanvas.1.firstContaining.2(611)"></A><A name="firstContaining.2(611)"></A>:
       (* Returns reference to first AbstractGraphicalObject in
        * thePicture that contains thePoint.
        * thePoint is assumed to be in coordinates relative to 
        * THIS(BifrostCanvas).
        *)
       (# thePoint: @Point;
       enter thePoint
       exit (THIS(BifrostCanvas)[],thePoint)
            -&gt;thePicture.firstContaining
       #);
     <B>lastContaining</B><A name="BifrostCanvas.1.lastContaining.2(612)"></A><A name="lastContaining.2(612)"></A>:
       (* Returns reference to last AbstractGraphicalObject in
        * thePicture that contains thePoint.
        * thePoint is assumed to be in coordinates relative to 
        * THIS(BifrostCanvas).
        *)
       (# thePoint: @Point;
       enter thePoint
       exit (THIS(BifrostCanvas)[],thePoint)
            -&gt;thePicture.lastContaining
       #);
     
     (* EVENT HANDLING *)
     <B>eventHandler</B><A name="BifrostCanvas.1.eventHandler.2(613)"></A><A name="eventHandler.2(613)"></A>::&lt;
       (# 
          <B>onOpen</B><A name="BifrostCanvas.1.eventHandler.2.onOpen.3(614)"></A><A name="onOpen.3(614)"></A>:&lt; 
            (* Called immediately after the BifrostCanvas has been
             * made visible.
             *)
            (#
            ...
            #);
          <B>onMouseDown</B><A name="BifrostCanvas.1.eventHandler.2.onMouseDown.3(615)"></A><A name="onMouseDown.3(615)"></A>::&lt; 
            (* Called when a mouse button is pressed *)
            (# mousePos: @Point 
                 (* the position of the mouse in device coordinates *);
               button: (# exit buttonState #);
               shiftModified: (# exit shiftKey #);
               (*lockModified: (# exit capsLock #);*)
               controlModified: (# exit controlKey #);
               metaModified: (# exit metaKey #);
               altModified: (# exit altKey #);
            ...
            #);
          <B>onKeyDown</B><A name="BifrostCanvas.1.eventHandler.2.onKeyDown.3(616)"></A><A name="onKeyDown.3(616)"></A>::&lt; (* Called when a key is pressed *)
            (# ... #);
          <B>onRefresh</B><A name="BifrostCanvas.1.eventHandler.2.onRefresh.3(617)"></A><A name="onRefresh.3(617)"></A>::&lt;
            (* Called when THIS(BifrostCanvas) is being refreshed *)
            (# do ... #);
          <B>onFrameChanged</B><A name="BifrostCanvas.1.eventHandler.2.onFrameChanged.3(618)"></A><A name="onFrameChanged.3(618)"></A>::&lt;
            (* Called when THIS(BifrostCanvas) changes its frame
             * (size).
             *)
            (# ... #);
          <B>onActivate</B><A name="BifrostCanvas.1.eventHandler.2.onActivate.3(619)"></A><A name="onActivate.3(619)"></A>::&lt; 
            (* Called when the BifrostCanvas is activated, e.g. by
             * entering it with the mouse.
             *)
            (# ... #);
          <B>onDeactivate</B><A name="BifrostCanvas.1.eventHandler.2.onDeactivate.3(620)"></A><A name="onDeactivate.3(620)"></A>::&lt; 
            (* Called when the BifrostCanvas is deactivated, e.g. by
             * leaving it with the mouse.
             *)
            (# ... #);
          <B>onFatalError</B><A name="BifrostCanvas.1.eventHandler.2.onFatalError.3(621)"></A><A name="onFatalError.3(621)"></A>:&lt; (# err: ^text; enter err[] do INNER #);
       #);
     <B>borderwidth</B><A name="BifrostCanvas.1.borderwidth.2(622)"></A><A name="borderwidth.2(622)"></A>: @
       (* The width of the border if present. Defaults to 0 *)
       (# value: @integer;
       enter (# enter value ... #)
       exit  (# ... exit value #)
       #);
     <B>borderpaint</B><A name="BifrostCanvas.1.borderpaint.2(623)"></A><A name="borderpaint.2(623)"></A>: @
       (* The Paint used to fill the border if present. Defaults to
        * black
        *)
       (# p: ^Paint;
       enter (# enter p[] ... #)
       exit  (# ... exit p[] #)
       #);
     <B>backgroundpaint</B><A name="BifrostCanvas.1.backgroundpaint.2(624)"></A><A name="backgroundpaint.2(624)"></A>: @
       (* The Paint used as background. Defaults to white *)
       (# p: ^Paint;
       enter (# enter p[] ... #)
       exit  (# ... exit p[] #)
       #);
     
     <B>size</B><A name="BifrostCanvas.1.size.2(625)"></A><A name="size.2(625)"></A>: 
       (* The size of THIS(BifrostCanvas) *)
       (# w, h: @integer;
       enter (# enter (w, h) ... #)
       exit THIS(Canvas).size
       #);
     <B>open</B><A name="BifrostCanvas.1.open.2(626)"></A><A name="open.2(626)"></A>::&lt;
       (* Open the BifrostCanvas, i.e. make it visible and start to
        * handle events.
        *)
       (# create::&lt; (# ... #);
          defaultbackground: @boolean
            (* If defaultbackground is set to true,
             * THIS(BifrostCanvas) will appear with the same
             * background color as the surrounding window, otherwise
             * it will be set to white (unless otherwise specified by
             * backgroundpaint
             *);
       ...
       #);
     <B>close</B><A name="BifrostCanvas.1.close.2(627)"></A><A name="close.2(627)"></A>::&lt;
       (* Close the BifrostCanvas, i.e. make it disappear and forget
        * all information stored in it.
        *)
       (# ... #);
     <B>writeEPS</B><A name="BifrostCanvas.1.writeEPS.2(628)"></A><A name="writeEPS.2(628)"></A>:&lt;
       (* Write Encapsulated PostScript to the stream out *)
       (# out: ^Stream;
          pagesize: @rectangle;
          vertical: @boolean;
          noOfCopies: @integer;
       enter (pagesize, vertical, noOfCopies, out[])
       do ...
       #);
     <B>readEPS</B><A name="BifrostCanvas.1.readEPS.2(629)"></A><A name="readEPS.2(629)"></A>:&lt; 
       (* Reads an EPS file written with writeEPS from stream inFile *)
       (# 
          inFile: ^Stream;
       enter inFile[]
       ...
       #);
     <B>setClip</B><A name="BifrostCanvas.1.setClip.2(630)"></A><A name="setClip.2(630)"></A>:
       (* Make clipShape the new clipping region in
        * THIS(BifrostCanvas)
        *)
       (# 
       enter clipShape[]
       do ...;
       #);
     <B>getClip</B><A name="BifrostCanvas.1.getClip.2(631)"></A><A name="getClip.2(631)"></A>:
       (* Exit the clipping region of THIS(BifrostCanvas) *)
       (# exit clipShape[] #);
     <B>deviceToCanvas</B><A name="BifrostCanvas.1.deviceToCanvas.2(632)"></A><A name="deviceToCanvas.2(632)"></A>:
       (* Transform p1 from Device coordinates to BifrostCanvas
        * coordinates.
        *)
       (# p1,p2: @Point;
       enter p1
       ...
       exit p2
       #);
     <B>canvasToDevice</B><A name="BifrostCanvas.1.canvasToDevice.2(633)"></A><A name="canvasToDevice.2(633)"></A>:
       (* Transform p1 from BifrostCanvas coordinates to Device
        * coordinates.
        *)
       (# p1,p2: @Point;
       enter p1
       ... 
       exit p2
       #);
     
     <B>canvasToDeviceRectangle</B><A name="BifrostCanvas.1.canvasToDeviceRectangle.2(634)"></A><A name="canvasToDeviceRectangle.2(634)"></A>:
       (* Transform r from BifrostCanvas coordinates to Device coordinates. *)
       (# r: @Rectangle;
       enter r
       do r -&gt; TM.transformRectangle -&gt; r;
       exit r
       #);
     
     <B>deviceToCanvasRectangle</B><A name="BifrostCanvas.1.deviceToCanvasRectangle.2(635)"></A><A name="deviceToCanvasRectangle.2(635)"></A>:
       (* Transform r from BifrostCanvas coordinates to Device coordinates. *)
       (# r: @Rectangle;
       enter r
       do r -&gt; TM.inverseTransformRectangle -&gt; r;
       exit r
       #);

     (* DAMAGE / REPAIR *)
     <B>damaged</B><A name="BifrostCanvas.1.damaged.2(636)"></A><A name="damaged.2(636)"></A>:
       (* Inform THIS(BifrostCanvas) that r has been damaged, and
        * thus should be a part of the area redrawn upon the next
        * repair.
        *)
       (# r: @Rectangle;
       enter r
       do ...;
       #);
     <B>repair</B><A name="BifrostCanvas.1.repair.2(637)"></A><A name="repair.2(637)"></A>: 
       (* Redraw all damaged areas in THIS(BifrostCanvas) *)
       (# do ... #);
     
     (* INTERACTION *)
     <B>interactionHandler</B><A name="BifrostCanvas.1.interactionHandler.2(638)"></A><A name="interactionHandler.2(638)"></A>:
       (* Specialize THIS(BifrostCanvas).InteractionHandler to
        * perform an interaction.  Specialize the different virtuals
        * inside THIS(InteractionHandler) to perform actions in
        * response to various events.  Of course, using an
        * InteractionHandler only gives meaning if a pointing device
        * and/or a keyboard is connected to the actual device.
        * 
        * NOTICE: At most one InteractionHandler may active at any
        * given time
        *)
       (# <B>initialize</B><A name="BifrostCanvas.1.interactionHandler.2.initialize.3(639)"></A><A name="initialize.3(639)"></A>:&lt;
            (* Called before THIS(InteractionHandler) is started *)
            (# ... #);
          <B>motion</B><A name="BifrostCanvas.1.interactionHandler.2.motion.3(640)"></A><A name="motion.3(640)"></A>:&lt; 
            (* Called when the the pointing device has been moved *)
            object;
          <B>idle</B><A name="BifrostCanvas.1.interactionHandler.2.idle.3(641)"></A><A name="idle.3(641)"></A>:&lt;
            (* Called repeatedly when no events are ready *)
            object;
          <B>buttonPress</B><A name="BifrostCanvas.1.interactionHandler.2.buttonPress.3(642)"></A><A name="buttonPress.3(642)"></A>:&lt;
            (* Called when a button of the pointing device has been
             * pressed.
             *)
            (# button: @Integer enter button do INNER; #);
          <B>buttonRelease</B><A name="BifrostCanvas.1.interactionHandler.2.buttonRelease.3(643)"></A><A name="buttonRelease.3(643)"></A>:&lt; object
            (* Called when a button of the pointing device has been
             * released
             *);
          <B>keyPress</B><A name="BifrostCanvas.1.interactionHandler.2.keyPress.3(644)"></A><A name="keyPress.3(644)"></A>:&lt;
            (* Called when a key on the keyboard has been pressed *)
            (# ch: @Char; enter ch do INNER #);
          <B>keyRelease</B><A name="BifrostCanvas.1.interactionHandler.2.keyRelease.3(645)"></A><A name="keyRelease.3(645)"></A>:&lt;
            (* Called when a key on the keyboard has been released *)
            (# ch: @Char; enter ch do INNER #);
          <B>terminateCondition</B><A name="BifrostCanvas.1.interactionHandler.2.terminateCondition.3(646)"></A><A name="terminateCondition.3(646)"></A>:&lt; booleanObject
            (* Specifies under what condition to stop
             * THIS(InteractionHandler)
             *)
            (# ... #);
          <B>terminated</B><A name="BifrostCanvas.1.interactionHandler.2.terminated.3(647)"></A><A name="terminated.3(647)"></A>:&lt;
            (* Called just before THIS(InteractionHandler) ends *)
            (# ... #);
          <B>getPointerLocation</B><A name="BifrostCanvas.1.interactionHandler.2.getPointerLocation.3(648)"></A><A name="getPointerLocation.3(648)"></A>: @
            (* Returns the current pointer location in device
             * coordinates
             *)
            (# thePoint: @Point;
            do ...;
            exit thePoint
            #);
          <B>getGlobalPointerLocation</B><A name="BifrostCanvas.1.interactionHandler.2.getGlobalPointerLocation.3(649)"></A><A name="getGlobalPointerLocation.3(649)"></A>: @
            (* Returns the current pointer location in screen
             * coordinates
             *)
            (# thePoint: @Point;
            do ...;
            exit thePoint
            #);
          <B>isModifierOn</B><A name="BifrostCanvas.1.interactionHandler.2.isModifierOn.3(650)"></A><A name="isModifierOn.3(650)"></A>: @booleanValue
            (* Tell if theModifier is currently being pressed *)
            (# theModifier: @Modifier;
            enter theModifier
            do ...;
            #);
          <B>doubleClick</B><A name="BifrostCanvas.1.interactionHandler.2.doubleClick.3(651)"></A><A name="doubleClick.3(651)"></A>: @booleanValue
            (* Answer if the last button press on the pointing device
             * was a double click
             *)
            (# ... #);
       do ...;
       #);
     <B>interactiveCreateShape</B><A name="BifrostCanvas.1.interactiveCreateShape.2(652)"></A><A name="interactiveCreateShape.2(652)"></A>:
       (* Tell GO to start an interaction for creation on
        * THIS(BifrostCanvas)
        *)
       (# GO: ^AbstractGraphicalObject;
          p: @Point (* start interaction at p *);
          theModifier: @Modifier;
       enter (GO[],p,theModifier)
       ... 
       #);
     <B>interactiveCombineShape</B><A name="BifrostCanvas.1.interactiveCombineShape.2(653)"></A><A name="interactiveCombineShape.2(653)"></A>:
       (* Tell GO to start an interaction for combination on
        * THIS(BifrostCanvas)
        *)
       (# GO: ^AbstractGraphicalObject;
          p: @Point (* start interaction at p *);
          theModifier: @Modifier;
       enter (GO[],p,theModifier)
       ... 
       #);
     <B>interactiveReshape</B><A name="BifrostCanvas.1.interactiveReshape.2(654)"></A><A name="interactiveReshape.2(654)"></A>:
       (* Tell GO to start an interaction for reshaping on
        * THIS(BifrostCanvas)
        *)
       (# GO: ^AbstractGraphicalObject;
          p: @Point (* start interaction at p *);
          theModifier: @Modifier;
       enter (GO[],p,theModifier)
       ... 
       #);
     <B>interactiveMove</B><A name="BifrostCanvas.1.interactiveMove.2(655)"></A><A name="interactiveMove.2(655)"></A>:
       (* Tell GO to start an interaction for motion on
        * THIS(BifrostCanvas).
        *)
       (# GO: ^AbstractGraphicalObject;
          p: @Point (* start interaction at p *);
          theModifier: @Modifier;
       enter (GO[],p,theModifier)
       ... 
       #);
     <B>interactiveRotate</B><A name="BifrostCanvas.1.interactiveRotate.2(656)"></A><A name="interactiveRotate.2(656)"></A>: (* Not Yet Implemented *)
       (* Tell pict to start an interaction for rotation on
        * THIS(BifrostCanvas)
        *)
       (# GO: ^AbstractGraphicalObject;
          p: @Point (* start interaction at p *);
          theModifier: @Modifier;
       enter (GO[],p,theModifier)
       ... 
       #);
     <B>interactiveScale</B><A name="BifrostCanvas.1.interactiveScale.2(657)"></A><A name="interactiveScale.2(657)"></A>: (* Not Yet Implemented *)
       (* Tell pict to start an interaction for scaling on
        * THIS(BifrostCanvas)
        *)
       (# GO: ^AbstractGraphicalObject;
          p: @Point (* start interaction at p *);
          theModifier: @Modifier;
       enter (GO[],p,theModifier)
       ... 
       #);
     <B>bringForward</B><A name="BifrostCanvas.1.bringForward.2(658)"></A><A name="bringForward.2(658)"></A>:
       (* Bring aGO forward in THIS(BifrostCanvas).thePicture *)
       (# aGO: ^AbstractGraphicalObject;
       enter aGO[]                                                       
       ...
       #);
     <B>sendBehind</B><A name="BifrostCanvas.1.sendBehind.2(659)"></A><A name="sendBehind.2(659)"></A>:
       (* Send aGO behind in THIS(BifrostCanvas).thePicture *)
       (# aGO: ^AbstractGraphicalObject;
       enter aGO[]                                                       
       ... 
       #);
     
     <B>hitControl</B><A name="BifrostCanvas.1.hitControl.2(660)"></A><A name="hitControl.2(660)"></A>:
       (* Answer whether p is within 2 mm of a control point of aGO
        * Exits exact point if hit, NONE otherwise
        *)
       (# aGO: ^AbstractGraphicalObject;
          p: @Point;
          res: ^Point;
       enter (aGO[],p)
       ... 
       exit res[]
       #);
     <B>hilite</B><A name="BifrostCanvas.1.hilite.2(661)"></A><A name="hilite.2(661)"></A>:
       (* Tell GO to highlight itself on THIS(BifrostCanvas) *)
       (# GO: ^AbstractGraphicalObject
       enter GO[]
       ... 
       #);
     <B>unHilite</B><A name="BifrostCanvas.1.unHilite.2(662)"></A><A name="unHilite.2(662)"></A>:
       (* Tell GO to unhighlight itself on THIS(BifrostCanvas) *)
       (#  GO: ^AbstractGraphicalObject
       enter GO[]
       ... 
       #);
     
     (* Primitives for immediate drawing (sometimes also known as
      * transient drawing).  For efficiency all of these use DEVICE
      * coordinates.  Nothing drawn by means of these primitives can
      * be repaired automatically by THIS(BifrostCanvas).  Uses an
      * arbitrary color, that is guarentied to be different to what
      * is underneath.  May be erased by repeating the draw-request,
      * and is thus very useful for feedback in interaction.
      *)
     
     <B>setImmediateLineWidth</B><A name="BifrostCanvas.1.setImmediateLineWidth.2(663)"></A><A name="setImmediateLineWidth.2(663)"></A>:
       (* Set the width used for immediate lines and arcs  *)
       (# lineWidth: @Integer;
       enter lineWidth
       ...
       #);
     <B>immediatespot</B><A name="BifrostCanvas.1.immediatespot.2(664)"></A><A name="immediatespot.2(664)"></A>:
       (* Draw a small filled rectangle around center *)
       (# center: @Point;
       enter (center)
       ...
       #);
     <B>immediateLine</B><A name="BifrostCanvas.1.immediateLine.2(665)"></A><A name="immediateLine.2(665)"></A>:
       (* Draw an immediate line from p1 to p2 *)
       (# p1,p2: @Point;
       enter (p1,p2)
       ...
       #);   
     <B>immediateDot</B><A name="BifrostCanvas.1.immediateDot.2(666)"></A><A name="immediateDot.2(666)"></A>:
       (* Draw a dot of the size of one device-pixel at p *)
       (# p1: @Point;
       enter (p1)
       ...
       #);
     <B>immediateMultiLine</B><A name="BifrostCanvas.1.immediateMultiLine.2(667)"></A><A name="immediateMultiLine.2(667)"></A>:
       (* Draw an immediate multiline specified by the points in p.
        * If close is true, the multiline will be closed by a line
        * from the first point to the last point.
        *)
       (# p: ^PointArray;
          close: @Boolean;
       enter (p[], close)
       do ...;
       #);
     <B>immediateArc</B><A name="BifrostCanvas.1.immediateArc.2(668)"></A><A name="immediateArc.2(668)"></A>:
       (# cx, cy: @integer; (* Center coordinates *)
          hr, vr: @integer; (* Horizontal/vertical radius *)
          a1, a2: @integer; (* Defining angles in degrees *)
       enter (cx, cy, hr, vr, a1, a2)
       ...
       #); 
     <B>immediaterect</B><A name="BifrostCanvas.1.immediaterect.2(669)"></A><A name="immediaterect.2(669)"></A>:
       (* Draw the outline of r *)
       (# r: @Rectangle;
       enter r
       ...
       #);
     <B>immediateText</B><A name="BifrostCanvas.1.immediateText.2(670)"></A><A name="immediateText.2(670)"></A>:
       (* Draw theString at pos, with appearance as specified with
        * theFontName, theStyle, theSize, and underline
        *)
       (# pos: @Point;
          theFontName: @FontName;
          theStyle: @Style;
          theSize: @integer;
          underline: @boolean;
          theString: ^text;
       enter (pos, theFontName, theStyle, theSize, 
              underline, theString[])
       do ...
       #);
     
     (* Utility functions to convert between pixels and
      * milimeter.
      *)
     <B>MMToPixel</B><A name="BifrostCanvas.1.MMToPixel.2(671)"></A><A name="MMToPixel.2(671)"></A>: (* Exits p scaled from mm to pixels *)
       (# p: @Point;    
       enter p
       do ...
       exit p
       #);
     <B>pixelToMM</B><A name="BifrostCanvas.1.pixelToMM.2(672)"></A><A name="pixelToMM.2(672)"></A>: (* Exits p scaled from pixels to mm *)
       (# p: @Point;    
       enter p
       do ...
       exit p
       #);
     
     (* Utility to set zoom factor of THIS(BifrostCanvas).
      * The value 1.0 correponds to unzoomed state.
      *)
     <B>ZoomFactor</B><A name="BifrostCanvas.1.ZoomFactor.2(673)"></A><A name="ZoomFactor.2(673)"></A>:
       (# set:
            (# z: @vector;
            enter z
            do ...
            #);
          get: 
            (# z: @vector;
            ...
            exit z
            #)
       enter set
       exit get
       #);
     
     (* PRIVATE *)
     
     <B>privatePart</B><A name="BifrostCanvas.1.privatePart.2(674)"></A><A name="privatePart.2(674)"></A>: @ ...;
     <B>TM</B><A name="BifrostCanvas.1.TM.2(675)"></A><A name="TM.2(675)"></A>: ^Matrix
       (* Transformation from THIS(BifrostCanvas) to the actual
        * device
        *);
  #);

</PRE><P><HR><P><H2><A name="Bifrost">Bifrost</A></H2><PRE CLASS=interface>
-- LIB: attributes --
<B>Bifrost</B><A name="Bifrost.1(676)"></A>: Guienv(# do INNER #)
</PRE>
<P></P>
<!--++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
<HR>
<P></P>
<TABLE border=0 width="100%">
<TR>
<TD width="40%" align="left"><ADDRESS>Bifrost Interface</ADDRESS></TD>
<TD width="20%" align="center"><FONT size="-1">&#169; <A HREF="http://www.mjolner.com" TARGET="_top">Mj&oslash;lner Informatics</A></FONT>
</TD>
<TD width="40%" align="right"><SCRIPT TYPE="text/javascript" LANGUAGE=JavaScript SRC="../../javascript/lastmod.js"></SCRIPT></TD>
</TABLE>
</BODY>
</HTML>
