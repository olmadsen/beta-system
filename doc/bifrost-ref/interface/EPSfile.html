<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>EPSfile Interface</TITLE>
<LINK REL="stylesheet" HREF="../../style/miadoc.css" TYPE="text/css">
</HEAD>
<BODY>
<P></P>
<A HREF="Palette.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="ColorNames.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Prev BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
<P></P>
<P>Interface Description</P>
<HR>
<!---------------------------------------------------------->

<H1>EPSfile Interface</H1>
<PRE CLASS=interface>
</PRE><P><HR><P><H2><A name="EPS file">EPS file</A></H2><PRE CLASS=interface>
ORIGIN 'Bifrost';
BODY 'private/PS/EPSread'
     'private/PS/EPSmacros';
--- streamLib: attributes ---
<b>skipEPSheaders</b><A name="skipEPSheaders.1(1217)"></A>:
  (* This functions should be called to skip over the PostScript
   * headers and check that it is a valid Bifrost PostScript file.
   *
   * PostScript headers are generated by canvas.writeEPS or if
   * startEPSfile is used directly.
   *)
  (# <b>formatException</b><A name="skipEPSheaders.1:formatException.2(1218)"></A><A name="formatException.2(1218)"></A><A name="skipEPSheaders.1:exception.2:_subpatterns.3:formatException.4"></A>: exception
       (* called if THIS(stream) isn't a valid Bifrost PostScript
        * file.
        *)
       (# t: ^text
       enter t[]
       ...
       #);
     <b>formatError</b><A name="skipEPSheaders.1:formatError.2(1219)"></A><A name="formatError.2(1219)"></A>:&lt; formatException;
     <b>inFile</b><A name="skipEPSheaders.1:inFile.2(1220)"></A><A name="inFile.2(1220)"></A>: ^stream;
  enter inFile[]
  ...
  #);

(* The following is indented to allow the user to write to
 * PostScript files, ie. writing several pictures (pages) to one
 * file.  Currently however, the user herself will have to generate
 * some PostScript code which separates the pages and makes it valid
 * postscript code.  This is likely to change in future releases.
 *)
<b>startEPSfile</b><A name="startEPSfile.1(1221)"></A>:
  (* Writes PostScript headers to THIS(stream).  This function
   * should be called exactly once for each file before you do * anything else.
   *
   * This is called automatically by canvas.writeEPS file, but can
   * be used if the user don't want to use canvas.writeEPS.
   *)
  (# ... #);
<b>WriteMacros</b><A name="WriteMacros.1(1222)"></A>: ...;
<b>endEPSfile</b><A name="endEPSfile.1(1223)"></A>:
  (* Write PostScript epilogue to out. This function should be
   * called exactly once, before you close this file.
   *
   * As startEPSfile, this is automatically called by
   * canvas.writeEPS, and should normally only be used if the user
   * also used startEPSfile.
   *)
  (# ... #);
<b>eoe</b><A name="eoe.1(1224)"></A><A name="booleanValue.:_subpatterns.2:eoe.3"></A>: booleanValue
  (* Tests for end of EPS file as marked by endEPSfile *)
  (# ... #)

--- BifrostAttributes: attributes ---
<b>loadPicture</b><A name="loadPicture.1(1225)"></A>:
  (# &lt;&lt;SLOT bifrostLoadPicture: attributes&gt;&gt;;
     <b>parseException</b><A name="loadPicture.1:parseException.2(1226)"></A><A name="parseException.2(1226)"></A><A name="loadPicture.1:exception.2:_subpatterns.3:parseException.4"></A>: exception
       (* A parse exception is generated if any parse errors occurs
        * while reading the EPS file.

        * Notice that if for instance the file is truncated, the
        * normal stream exception are generated.
        *)
       (# t: ^text;
       enter t[]
       ...
       #);
     <b>parseError</b><A name="loadPicture.1:parseError.2(1227)"></A><A name="parseError.2(1227)"></A>:&lt; parseException;
     <b>createGO</b><A name="loadPicture.1:createGO.2(1228)"></A><A name="createGO.2(1228)"></A>:&lt;
       (* Should be specialized to create user defined patterns *)
       (# GO: ^AbstractGraphicalObject;
          patternName: ^text;
       enter patternName[]
       ...
       exit GO[]
       #);
     <b>in</b><A name="loadPicture.1:in.2(1229)"></A><A name="in.2(1229)"></A>: ^stream;
     <b>out</b><A name="loadPicture.1:out.2(1230)"></A><A name="out.2(1230)"></A>: ^Picture;
     <b>private</b><A name="loadPicture.1:private.2(1231)"></A><A name="private.2(1231)"></A>: @...
  enter in[]
  ...
  exit out[]
  #)
</PRE>
<!---------------------------------------------------------->
<HR>
<P></P>
<ADDRESS>Interface Description</ADDRESS>
<P></P>
<A HREF="Palette.html"><IMG ALIGN=BOTTOM SRC="../../images/next.gif" ALT=Next BORDER=0></A>
<A HREF="ColorNames.html"><IMG ALIGN=BOTTOM SRC="../../images/prev.gif" ALT=Prev BORDER=0></A>
<A HREF="../index.html"><IMG ALIGN=BOTTOM SRC="../../images/top.gif" ALT=Top BORDER=0></A>
<A HREF="index.html"><IMG ALIGN=BOTTOM SRC="../../images/content.gif" ALT=Content BORDER=0></A>
<A HREF="inx.html"><IMG ALIGN=BOTTOM SRC="../../images/index.gif" ALT=Index BORDER=0></A>
</BODY>
</HTML>
