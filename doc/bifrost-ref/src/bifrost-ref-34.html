<H2>Updating <INX>Damaged Areas</INX></H2>
<P> When an area inside the visible area of
the canvas has been obscured, e.g. by an overlapping window, and again
becomes visible, parts of the canvas must be redrawn. The canvas
supports redrawing by updating areas that have been damaged. The
damaged area is handled by a damaged-list in the canvas. </P>

<P> Update events originating from the window system - say, a window
overlapping the canvas is moved - are handled automatically by
Bifrost. When Bifrost receives an update event from the window system,
the damaged area is in many cases reported along with the update
event. The canvas redraws the damaged area transparently to the
application. In cases where the damaged areas is not reported, the
whole visible area of the canvas is redrawn.</P>

<P> The process of updating damaged areas originating from application
dependent actions - say, removing of a graphical object - is a partly
application responsible process; it is not entirely automatic. In this
situation the application is responsible of adding damaged areas to
the damaged-list. Adding a rectangle to the list is accomplished by the
operation <INX>damaged</INX>. After the application has
called the operation <INX>Repair</INX>, the canvas
redraws the visible area using an advanced algorithm to determine
which objects must be redrawn. </P>

<P> The traditional way of redrawing is to draw all objects and turn
the responsibility of selecting the objects inside the clipping area
to the display device (or basic graphics library). Although clipping
is a very efficient way of reducing the overhead of the display device
in redrawing, it is still necessary to redraw all graphical objects in
the canvas.</P>

<P> An alternative is to limit the number of graphical objects and
pictures that has to be considered in the redrawing process. When
applications use graphics modelling, each picture typically consists
of a small set of proximate and related objects, expected to be
updated collectively, e.g. by moving the picture. This means, that if
a picture is completely outside the region that should be updated,
then it is not necessary to further consider the graphical objects
inside the picture. The following example illustrates the
situation:</P>

<P> </P>
<CENTER><GIF ALIGN=TOP SRC=images/damagedareas.gif></CENTER>
<P> </P>
<P> Given a clipping rectangle T and some pictures (illustrated by
dashed rectangles) and graphical objects (illustrated by small
circles) all the graphical objects in pictures that are completely
outside T are never considered.</P>

<P> This approach depends on the assumption that the application is
using graphics modelling, and that the graphical objects in each
picture are close to each other. Consider for example two graphical
objects in a picture, that are very distant from each other, the
picture becomes very large and it is a more likely that the picture
intersects T even though the graphical objects may be outside T. On
the other hand, this update approach encourage the application
programmer or user to apply graphics modelling to the drawing.</P>

<P> The advanced updating approach in Bifrost does not exclude the
possibility to use other updating mechanisms. In cases where graphics
modelling can not be used or does not make sense, the application
programmer can implement a different approach, e.g. the very advanced
method described by Edelsbrunner called 'dynamic rectangle
intersection search' <A
HREF=bibliography.html#edelsbrunner80>[Edelsbrunner 80]</A>.</P>






