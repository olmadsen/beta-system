<H2>Interaction Facilities in the Shape</H2>
<P> Since the shape of a graphical object defines the outline of the
object, the shape must define how to, interactively, create and modify
itself. This is accomplished in the operations InteractiveCreate,
InteractiveReshape and InteractiveCombine. The operations use the
general InteractionHandler and feedback primitives described
above. </P>

<DL>
<DT>
<B><INX>InteractiveCreate</INX></B>.
<DD>
Takes a beginning point and a modifier as arguments and starts an
interaction loop letting the user define the outline of a shape. When
the loop is terminated the control points of the shape are set
accordingly. The operation is most commonly used from
InteractiveCreateShape of a graphical object.

<DT>
<B><INX>InteractiveReshape</INX></B>. 
<DD>
Takes a point as argument and starts an interaction loop letting the
user reshape the shape at the control point in the neighborhood of the
point (obtained by using, say, HitControl). The operation is most
commonly used from InteractiveReshape of a graphical object.

<DT>
<B><INX>InteractiveCombine</INX></B>. 
<DD>
Takes a beginning point and a modifier as argument and starts an
interaction loop letting the user create a shape. When the loop is
terminated the new shape is combined with the original shape by using
the CombineShape operation. The operation is most commonly used from
InteractiveCombineShape of a graphical object.
</DL>


<H3><INX>Neighborhood</INX> </H3>
<P> The concept of neighborhood is used in some of the operations
presented. Neighborhood is defined as
follows: 

<BLOCKQUOTE>
<I>A point P is said to be in the neighborhood of another point
Q if P is inside a square with Q as center and a given side
length. 
</I>
</BLOCKQUOTE>

The length of the sides defaults to 2 mm, but may be changed
by the programmer.


<H3>Direct changing of Control Points</H3>
<P> A shape can also be manipulated by adding a new control point to
the shape, or by deleting a control point from the shape. The
following two operations support manipulation of control points. They
are especially useful in interaction. </P>

<DL>
<DT>
<B><INX>Insert</INX></B>.
<DD>
Takes two points as parameter. If the first point is in the
neighborhood of an existing control point, the second point is added
as a new control point between the neighbor point and the next control
point of the neighbor point.

<DT>
<B><INX>Delete</INX></B>.
<DD>
Takes a point as parameter and, if there is one, deletes a control
point in the neighborhood of the parameter point.
</DL>


<H3><INX>Shape Highlighting</INX> </H3>
<P> Highlighting a
graphical object is also part of interaction and interaction feedback,
and is handled by the shape of the graphical object by instances of
specializations of a special <INX>HiliteDesc</INX>
pattern. The HiliteDesc pattern enters three parameters: The canvas to
present the feedback in, a boolean indicating whether the feedback is
to be drawn or erased<EM><A REL=FOOTNOTE
HREF="#FOOTNOTE-9">[9]</A></EM>, and a transformation matrix, which
will be applied to the feedback before it is drawn in the canvas. The
following three predefined specializations of HiliteDesc define how to
highlight and unhighlight the shape in three standard ways. The actual
way of highlighting the shape is determined by the variable
DrawHilite. It references one of the Hilite operations. The
application programmer can easily extend the highlighting scheme by
adding new operations.</P> 

<TABLE align=right border=0>
<TR>
<TD>
<P>An ellipse with highlighted <BR>control points:</P>
<P> </P>
</TD>
<TR>
<TD>
<CENTER><IMG ALIGN=TOP SRC=images/ellipsehilite.gif></CENTER>
</TD>
</TABLE>

<DL>
<DT>
<B><INX>HiliteControls</INX></B>.
<DD>
Draws small squares at the locations of the control points. The
concept of control points can in this context be a bit different than
used earlier. For example, the control points of an ellipse are the
four corners of the bounding box of the ellipse. These corners can
naturally be manipulated interactively to modify the ellipse, in
contrast to the control points that are used to generate the ellipse
shape in the earlier sense.

<DT>
<B><INX>HiliteOutline</INX></B>.
<DD>
Highlights the shape by drawing a curve along the shape. Draws by
default the thinnest possible line, but another line width may be
specified in the parameter HiliteWidth.

<DT>
<B><INX>HiliteBound</INX></B>.
<DD>
Highlights the shape by drawing a rectangle along the bounding
box. Draws by default the thinnest possible line, but another line
width may be specified in the parameter HiliteWidth.

<DT>
<B><INX>DrawHilite</INX></B>.
<DD>
Refers to one of the above Hilite operations, and is the attribute of
the shape, which is invoked by the Hilite and Unhilite patterns of
Graphical Objects.
</DL>


<H3>Query Functions</H3>
<P> Four operations are defined as query functions of the shape.</P>

<DL>
<DT>
<B><INX>HitControl</INX></B>.
<DD>
Enters a point and if this point is in the neighborhood of a control
point, the control point is exited. Otherwise NONE is exited.

<DT>
<B><INX>ContainsPoint</INX></B>.
<DD>
Takes a point as argument and reports whether the point is inside the
shape or not.

<DT>
<B><INX>Intersects</INX></B> and <B><INX>Within</INX></B>.
<DD>
Takes a shape as argument, and reports whether it intersects or is
totally inside this shape, respectively.
</DL>



<HR>

<A NAME=FOOTNOTE-9>[9] </A>
 You may have noticed some lack of consequence in defining how to draw
and erase feedback: The Graphical Object defines both Hilite and
UnHilite patterns, whereas the Shape uses a boolean to control
this. Also the Canvas defines primitives that allow for XOR drawing,
which means, that there is no need for distinguishing between drawing
and erasing of feedback. Besides the fact, that the Graphical Object
needs to know the 'state' of the feedback (drawn or
erased), the reasons for these different views on drawing versus
erasing are purely historic. 







