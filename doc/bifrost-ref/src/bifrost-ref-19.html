<H2>Rasters</H2>
<P> <A NAME=MARKER-2-80></A>As described in the previous paragraphs
both tiled solid color and the raster paint concepts use some kind of
rasters describing either a tile, or a raster image in the raster
paint. Bifrost defines a class BitMap for using with tiling and a
class PixMap to be used in the RasterPaint. 
In <A HREF="#figure_11">Figure 11</A> the hierarchy is illustrated. </P>
<P> </P>
<CENTER><IMG ALIGN=TOP SRC=images/raster-hierarchy.gif></CENTER>
<P> </P>
<CENTER><A NAME=figure_11><STRONG CLASS=figure>Figure 11: The Raster Hierarchy</STRONG></A></CENTER>
<P> The implementation of bit and pixel maps are inspired by 'portable bitmap file format (PBM)' and 'portable pixmap file format (PPM)' <A HREF=bibliography.html#poskanzer>[Poskanzer]</A> available on many Unix and MS/DOS installations. Since the format of the Bifrost rasters are very close to this 'standard', Bifrost can read and write PBM and PPM files, and thereby get access to a huge set of rasters in a lot of different formats.</P>
<A NAME=HEADING19-8></A>
<H3>Raster</H3>
<P> <A NAME=MARKER-2-81></A>The Raster class generalizes the raster concept defining the following attributes</P>
<UL>
<LI> MagicNumber for identifying the type of the raster.
<LI> Hotspot is a point used when the raster is used in a fill operation: the raster in positioned so that hotspot coincides with the hotspot of the shape being filled.
<LI> Width and Height of the raster.
<LI> Pixel is virtually declared as an Object, and must be further bound in specializations of Raster.
<LI> Width * Height Values specifying the raster itself, starting at the top-left corner of the raster, proceeding in normal reading order.
</UL>
<P> In BETA code it could look like:</P>
<PRE CLASS=beta>
Raster:
(# 
   MagicNumber: @Integer;
   Width,Height: @Integer;
   Pixel:&lt; Object;
   Values: [Width*Height] @Pixel;
#)
</PRE>
<P> Two operations are supported by all rasters:</P>

<DL>
<DT><B>PutPixel</B>.
<DD>Takes an index (i,j) and a pixel value as argument and sets the pixel
value into the specified position of the Values.

<DT><B>GetPixel</B>.
<DD>Takes an index (i,j) as argument and returns the pixel value in the
specified position of the Values.
</DL>


<A NAME=HEADING19-29></A>
<H3>BitMap</H3>
<P> <A NAME=MARKER-2-82></A>Bifrost defines a bit map in the following way:</P>

<DL>
<DT>
<B>Pixel</B> 
<DD>
is bound to a Boolean where TRUE means &quot;set&quot; and FALSE
means &quot;not set&quot;.
</DL>

<P> Two operations are defined to read and write BitMaps:</P>

<DL>
<DT>
<B>ReadFromPBMFile</B>.
<DD>
Read a bit map from a PBM file into the BitMap.

<DT>
<B>WriteToPBMFile</B>.
<DD>
Write the BitMap out on a PBM file.
</DL>

<A NAME=HEADING19-37></A>
<H3>PixMap</H3>
<P> <A NAME=MARKER-2-83></A>Bifrost defines a pixel map in the following way:</P>

<DL>
<DT>
<B>MaxVal</B>
<DD>
The maximum color component value.
<DT>
<B>Pixel</B> 
<DD>
is bound to three decimal values between 0 and the specified
maximum value. The three values for each pixel represent red, green,
and blue, respectively. If it is desired to specify the pixel value
relative to some other color space, e.g. HSV (cf. <A HREF="bifrost-ref-20.html">section 5.2</A>), the
easiest way is to instantiate a SolidColor (<A HREF="bifrost-ref-20.html">section 5.2)</A>, specify the
HSV values to this, and then get the RGB values from the SolidColor,
and use these in the Pixel.
</DL>



