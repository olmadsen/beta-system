ORIGIN '~beta/basiclib/wtext';
BODY 'private/textholderbody';
BODY 'private/wtextholderbody';
(*BASIC BSTR;*)
--LIB: attributes--

(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-98
 *       All rights reserved.
 *)


(* Holder patterns for predefined BETA types *)

integerHolder: Holder
  (# value: @integer enter value exit value #);
shortIntHolder: Holder
  (# value: @shortInt enter value exit value #);
charHolder: Holder
  (# value: @char enter value exit value #);
booleanHolder: Holder
  (# value: @boolean #);
realHolder: Holder
  (# value: @real enter value exit value #);
int8Holder: Holder
  (# value: @int8 enter value exit value #);
int8uHolder: Holder
  (# value: @int8u enter value exit value #);
int16Holder: Holder
  (# value: @int16 enter value exit value #);
int16uHolder: Holder
  (# value: @int16u enter value exit value #);
int32Holder: Holder
  (# value: @int32 enter value exit value #);
int32uHolder: Holder
  (# value: @int32u enter value exit value #);
int64Holder: Holder
  (# value: @int64 enter value exit value #);
int64uHolder: Holder
  (# value: @int64u enter value exit value #);
wcharHolder: Holder
  (# value: @wchar enter value exit value #);

(* Holder for COM references (interfaces) *)
RefHolder: Holder
  (# type:< COM;
     ref: ^type;
  enter ref[] 
  exit ref[]
  #);

(* Holder for text objects *)

(* Other proposal:
 *   cText: stream
 *     (# charptr: @integer
 *          {* The pointer to the external string *};
 *        ....
 *     #);
 *   cTextHolder: RefHolder
 *     (# type::cText
 *     #);
 *)

TextHolder: Holder
  (* Externally allocated string used for pointer-to-text parameters
   * in COM interfaces.
   *)
  (# charptr: @integer
       (* The pointer to the external string *);
     allocate: 
       (* Allocate length bytes (default 256) using malloc, and assign the
        * result to charptr. You may want to explicitly free THIS(TextHolder)
        * before a reallocation.
        *)
       (# length: @integer;
       enter length 
       do <<SLOT TextHolderAllocate: descriptor>>
       #);
     free: 
       (* Free the externally allocated string. The chars of the externally
        * allocated string will be unaccessible after this operation.
        *)
       (# <<SLOT TextHolderFree: dopart>> #);
     set: 
       (* Initializes THIS(TextHolder) to be large enough to hold the
        * chars of T, and then copies the chars of T to
        * THIS(TextHolder). You may want to explicitly free
        * THIS(TextHolder) before this operation, if this is a
        * reinitialization.  For convenience, it also exits the char
        * pointer.
        *)
       (# T: ^text; 
       enter T[]
       do <<SLOT TextHolderSet: descriptor>>
       exit charptr
       #);
     get:
       (* Return the chars of THIS(TextHolder) copied into the text T *)
       (# T: ^text;
       do <<SLOT TextHolderGet: descriptor>>  
       exit T[]
       #);
     getChars:
       (* Return a repetition, with the chars of THIS(TextHolder)
        * copied to it
        *)
       (# R: [0]@char;
       do <<SLOT TextHolderGetChars: descriptor>>
       exit R
       #);
     length: IntegerValue
       (* Return the string-length if THIS(TextHolder), i.e., the
        * number of chars before the NULL-char in the externally
        * allocated string.
        *)
       (# <<SLOT TextHolderLength: dopart>> #);
     inxPut:
       (* Put ch at index inx in the externally allocated
        * TextHolder. The first char is at index 0. NOTICE: There is no
        * index check, it is up to the programmer to ensure, that it is
        * allowed to put at the given index.
        *)
       (# inx: @integer;
          ch: @char;
       enter (inx, ch) 
          <<SLOT TextHolderInxPut: dopart>>
       #);
     inxGet:
       (* Obtain the char at the given index in the externally
        * allocated string.  The first char is at index 0.
        *)
       (# inx: @integer;
          ch: @char;
       enter inx
          <<SLOT TextHolderInxGet: dopart>>
       exit ch
       #);
     <<SLOT TextHolderLib: attributes>>;
  #);

(* Other proposal:
 *   wString: 
 *     (# wcharptr: @integer
 *          {* The pointer to the external string *};
 *        ....
 *     #);
 *   wStringHolder: RefHolder
 *     (# type::wtext
 *     #);
 *   BSTR: wString(# .. #);
 *   BSTRHolder: refHolder
 *     (# type::BSTR #)
 *)

wTextHolder: Holder
  (* Externally allocated string used for pointer-to-wtext parameters
   * in COM interfaces.
   *)
  (# wcharptr: @integer
       (* The pointer to the external string *);
     
     (* The following can be used to give a negative offset to store
      * length in. Used for modelling BSTR.
      * Notice, that the current implementation does NOT support
      * NULL chars in the middle of BSTR's.
      *)
     BSTRoffset:<integervalue;
     BSTRoff: @BSTRoffset;
     
     allocate: 
       (* Allocate length int16 (default 256) using malloc, and assign the
        * result to wcharptr. You may want to explicitly free THIS(wTextHolder)
        * before a reallocation.
        *)
       (# length: @integer;
       enter length 
       do <<SLOT wTextHolderAllocate: descriptor>>
       #);
     free: 
       (* Free the externally allocated string. The chars of the externally
        * allocated string will be unaccessible after this operation.
        *)
       (# <<SLOT wTextHolderFree: dopart>> #);
     set: 
       (* Initializes THIS(wTextHolder) to be large enough to hold the
        * wchars of T, and then copies the wchars of T to
        * THIS(wTextHolder). You may want to explicitly free
        * THIS(wTextHolder) before this operation, if this is a
        * reinitialization.  For convenience, it also exits the wchar
        * pointer.
        *)
       (# T: ^wText; 
       enter T[]
       do <<SLOT wTextHolderSet: descriptor>>
       exit wcharptr
       #);
     get:
       (* Return the chars of THIS(wTextHolder) copied into the wText T *)
       (# T: ^wText;
       do <<SLOT wTextHolderGet: descriptor>>  
       exit T[]
       #);
     setText: 
       (* Initializes THIS(wTextHolder) to be large enough to hold the
        * chars of T, and then copies the chars of T to
        * THIS(wTextHolder). You may want to explicitly free
        * THIS(wTextHolder) before this operation, if this is a
        * reinitialization.  For convenience, it also exits the char
        * pointer.
        *)
       (# T: ^Text; 
       enter T[]
       do <<SLOT wTextHolderSetText: descriptor>>
       exit wcharptr
       #);
     getText:
       (* Return the chars of THIS(wTextHolder) copied into the text T *)
       (# T: ^text;
       do <<SLOT wTextHolderGetText: descriptor>>  
       exit T[]
       #);
     getChars:
       (* Return a repetition, with the wchars of THIS(wTextHolder)
        * copied to it
        *)
       (# R: [0]@wchar;
       do <<SLOT wTextHolderGetChars: descriptor>>
       exit R
       #);
     length: IntegerValue
       (* Return the string-length if THIS(wTextHolder), i.e., the
        * number of chars before the NULL-char in the externally
        * allocated string.
        *)
       (# <<SLOT wTextHolderLength: dopart>> #);
     inxPut:
       (* Put ch at index inx in the externally allocated
        * wTextHolder. The first char is at index 0. NOTICE: There is no
        * index check, it is up to the programmer to ensure, that it is
        * allowed to put at the given index.
        *)
       (# inx: @integer;
          ch: @wchar;
       enter (inx, ch) 
          <<SLOT wTextHolderInxPut: dopart>>
       #);
     inxGet:
       (* Obtain the char at the given index in the externally
        * allocated string.  The first char is at index 0.
        *)
       (# inx: @integer;
          ch: @wchar;
       enter inx
          <<SLOT wTextHolderInxGet: dopart>>
       exit ch
       #);
     <<SLOT wTextHolderLib: attributes>>;
  #);

BSTRHolder: wTextHolder
  (# BSTRoffset::(# do 4->value #)#);
BSTR: BSTRHolder
  (# enter wcharptr exit wcharptr #);
