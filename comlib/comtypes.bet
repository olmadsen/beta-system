ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'holders';
BODY 'private/comtypesbody';
-- LIB: Attributes --
(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-98
 *       All rights reserved.
 *)
HRESULT:
  (#
     value: @int32;
     succeeded: (#  exit value >= 0 #);
     failed: (#  exit value < 0 #);
     
  enter value
  exit THIS(HRESULT)[]
  #);
HRESULTHolder: Holder (# value: @HRESULT enter value exit value #);
GUIDdata: DATA
  (#
     Data1: @int32u;
     Data2: @int16u;
     Data3: @int16u;
     Data4_0: @int8u;
     Data4_1: @int8u;
     Data4_2: @int8u;
     Data4_3: @int8u;
     Data4_4: @int8u;
     Data4_5: @int8u;
     Data4_6: @int8u;
     Data4_7: @int8u;
     
  #);
GUID: holder
  (#
     Binary: ^GUIDdata;
     init: (#  <<SLOT GUIDinit:DoPart>> #);
     setFromText:
     (* Accepts the following format only:
      *   '32bb8320-b41b-11cf-a6bb-0080c7b2d682'
      *)
       (# <<SLOT GUIDsetFromTextLib:Attributes>>; t: ^Text; p: @Int32; 
       enter T[]
       do
          <<SLOT GUIDSetFromText:Descriptor>>
       #);
     getAsText:
       (# T: ^Text;  do <<SLOT GUIDGetAsText:Descriptor>> exit T[] #);
     setFromPointer:
     (* Given that refguid is a pointer to a binary GUID,
      * set THIS(GUID).binary accordingly.
      *)
       (# refguid: @int32; 
       enter refguid
       <<SLOT GuidSetFromPointer:DoPart>>
       #);
     equal: booleanValue
     (* Is THIS(GUID) equal to g? *)
       (# g: ^guid enter g[] <<SLOT GuidEqual:DoPart>> #);
     
  enter setFromText
  exit getAsText
  #);
CLSID: GUID (#  #);
IID: GUID (#  #);


VARIANT: DATA
  (#
     vt: (* VARTYPE *) @int16;
     wReserved1: (* WORD *) @int16;
     wReserved2: (* WORD *) @int16;
     wReserved3: (* WORD *) @int16;
     long3: @int32;
     long4: @int32;
     enter (vt, wReserved1, wReserved2, wReserved3, long3, long4)
     exit (vt, wReserved1, wReserved2, wReserved3, long3, long4)
  #);

VARIANT_TRUE: (# exit 0xffff #);
VARIANT_FALSE: (# exit 0 #);

VARIANTHolder: holder(# value: @VARIANT  #);

VARIANT_init:
  (# vd: ^VARIANT;
     vt: (#  enter vd.vt exit vd.vt #);
     (* union members for different accesses of (long3,long4) *)
     lVal: (* LONG *) _long (#  #);
     bVal: (* BYTE *) _byte (#  #);
     iVal: (* SHORT *) _short (#  #);
     fltVal: (* FLOAT *) _float (#  #);
     dblVal: (* DOUBLE*) _double (#  #);
     boolVal: (* VARIANT_BOOL *) _long (#  #);
     bool: (* _VARIANT_BOOL *) _long (#  #);
     scode: (* SCODE *) _long (#  #);
     cyVal: (* CY *)
       (# 
       enter (vd.long3,vd.long4)
       exit (vd.long3,vd.long4)
       #);
     date: (* DATE *) _double (#  #);
     bstrVal: (* BSTR *) _long (#  #);
     punkVal: (* IUnknown __RPC_FAR* *) _unknwn (#  #);
     pdispVal: (* IDispatch __RPC_FAR* *) _unknwn (#  #);
     parray: (* SAFEARRAY __RPC_FAR* *) _data (#  #);
     pbVal: (* BYTE __RPC_FAR* *) _long (#  #);
     piVal: (* SHORT __RPC_FAR* *) _long (#  #);
     plVal: (* LONG __RPC_FAR* *) _long (#  #);
     pfltVal: (* FLOAT __RPC_FAR* *) _long (#  #);
     pdblVal: (* DOUBLE __RPC_FAR* *) _long (#  #);
     pboolVal: (* VARIANT_BOOL __RPC_FAR* *) _long (#  #);
     pbool: (* _VARIANT_BOOL __RPC_FAR* *) _long (#  #);
     pscode: (* SCODE __RPC_FAR* *) _long (#  #);
     pcyVal: (* CY __RPC_FAR* *) _long (#  #);
     pdate: (* DATE __RPC_FAR* *) _long (#  #);
     pbstrVal: (* BSTR __RPC_FAR* *) _long (#  #);
     ppunkVal: (* IUnknown __RPC_FAR* __RPC_FAR* *) _long (#  #);
     ppdispVal: (* IDispatch __RPC_FAR* __RPC_FAR* *) _long (#  #);
     pparray: (* SAFEARRAY __RPC_FAR* __RPC_FAR* *) _long (#  #);
     pvarVal: (* VARIANT __RPC_FAR* *) _long (#  #);
     byref: (* PVOID *) _long (#  #);
     cVal: (* CHAR *) _ubyte (#  #);
     uiVal: (* USHORT *) _ushort (#  #);
     ulVal: (* ULONG *) _long (#  #);
     intVal: (* INT *) _long (#  #);
     uintVal: (* UINT *) _long (#  #);
     pdecVal: (* DECIMAL __RPC_FAR* *) _long (#  #);
     pcVal: (* CHAR __RPC_FAR* *) _long (#  #);
     puiVal: (* USHORT __RPC_FAR* *) _long (#  #);
     pulVal: (* ULONG __RPC_FAR* *) _long (#  #);
     pintVal: (* INT __RPC_FAR* *) _long (#  #);
     puintVal: (* UINT __RPC_FAR* *) _long (#  #);
     (* Union alternative to (long3, long4) *)
     decVal: (* DECIMAL *) (* NYI *)
       (# 
       enter (vd.long3,vd.long4)
       exit (vd.long3,vd.long4)
       #);
     (* help patterns *)
     _ubyte:
       (# 
       enter (# b: @int8 enter b do (b,0)->vd.long3.%putByte #)
       exit 0->vd.long3.%getByte
       #);
     _ushort:
       (# 
       enter (# i: @int16 enter i do (i,0)->vd.long3.%putShort #)
       exit 0->vd.long3.%getShort
       #);
     _long: (# enter vd.long3 exit vd.long3 #);
     _unknwn: 
       (# p: ^COM 
       enter (# enter p[] do %getLongAt(@@p)->vd.long3 #) 
       exit (# do (vd.long3) %putLongAt(@@p) (* ChkRA? *) exit p[] #)
       #);
     _data: 
       (# p: ^DATA 
       enter (# enter p[] do %getLongAt(@@p)->vd.long3 #) 
       exit (# do (vd.long3) %putLongAt(@@p) exit p[] #)
       #);
     _byte:
       (# 
       enter (# b: @int8 enter b do (b,0)->vd.long3.%putByte #)
       exit 0->vd.long3.%getSignedByte
       #);
     _short:
       (# 
       enter (# i: @int16 enter i do (i,0)->vd.long3.%putShort #)
       exit 0->vd.long3.%getSignedShort
       #);
     _float:
       (# r: @real
       enter
         (# 
         enter r
         do
            r->vd.long3;
            'Warning: VARIANT.float: precision lost!'->putline;
            
         #)
       exit (#  do vd.long3->r exit r #)
       #);
     _double:
       (# r: @real
       enter
         (# 
         enter r
         do (* r.%getlong fails *)
            %getLongAt(@@r)->vd.long3; %getLongAt(@@r+4)->vd.long4; 
         #)
       exit
         (# 
         do (* NOT tested. r.%putlong might fail like r.%getlong above *)
            (vd.long3,0)->r.%putLong; (vd.long4,1)->r.%putLong; 
         exit r
         #)
       #);
  enter vd[]
  do INNER;
  exit vd[]
  #);

STGMEDIUM: struct_tagSTGMEDIUM (#  #);
struct_tagSTGMEDIUM: holder
  (#
     substance: @DATA
       (#
          tymed: @int32u (* DWORD *) ;
          long2: @int32 (* one of the unioned types *) ;
          pUnkForRelease: @int32 (* IUnknown *)
       #);
     ;
     tymed: (#  enter substance.tymed exit substance.tymed #);
     (* union members for different accesses of (long3,long4) *)
     hBitmap: (#  enter _long exit _long #);
     hMetaFilePict: (#  enter _long exit _long #);
     hEnhMetaFile: (#  enter _long exit _long #);
     hGlobal: (#  enter _long exit _long #);
     lpszFileName: (#  enter _long exit _long #);
     pstm: (#  enter _lptr exit _lptr #);
     pstg: (#  enter _lptr exit _lptr #);
     pUnkForRelease:
       (# i: ^COM
       enter (# (* enter i[] do i.%getlong->substance.pUnkForRelease *)  #)
       exit (#  do (substance.pUnkForRelease,0)->i.%putlong exit i[] #)
       #);
     _long: (#  enter substance.long2 exit substance.long2 #);
     (* help patterns *)
     _lptr:
       (# i: ^COM
       enter (# (* enter i[] do i.%getlong->substance.long2 *)  #)
       exit (#  do (substance.long2,0)->i.%putlong exit i[] #)
       #)
  #);
GUIDHolder: GUID (#  #);
CLSIDHolder: CLSID (#  #);
IIDHolder: IID (#  #);
  

