ORIGIN '~beta/basiclib/betaenv';
INCLUDE 'holders';
BODY 'private/comtypesbody';
--LIB: attributes--

(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-98
 *       All rights reserved.
 *)


HRESULT: 
  (# value: @int32;
     succeeded: (# exit value>=0 #);
     failed: (# exit value<0 #);
  enter value
  exit THIS(HRESULT)[]
  #);
HRESULTHolder: Holder
  (# value: @HRESULT enter value exit value #);

GUIDdata: DATA
  (# Data1: @int32u;
     Data2: @int16u;
     Data3: @int16u;
     Data4_0: @int8u;
     Data4_1: @int8u;
     Data4_2: @int8u;
     Data4_3: @int8u;
     Data4_4: @int8u;
     Data4_5: @int8u;
     Data4_6: @int8u;
     Data4_7: @int8u;
  #);
GUID: holder
  (# 
     Binary: ^GUIDdata;
     setFromText:
       (* Accepts the following format only (no checking!):
        *   '32bb8320-b41b-11cf-a6bb-0080c7b2d682'
        *)
       (# <<SLOT GUIDsetFromTextLib: attributes>>;
          t: ^Text; p: @Int32;
       enter T[]
       do <<SLOT GUIDSetFromText: descriptor>>   
       #);
     getAsText:
       (# T: ^Text;
       do <<SLOT GUIDGetAsText: descriptor>>
       exit T[]
       #);
     setFromPointer:
       (* Given that refguid is a pointer to a binary GUID,
        * set THIS(GUID).binary accordingly.
        *)
       (# refguid: @int32;
       enter refguid
       <<SLOT GuidSetFromPointer:dopart>>
       #);
     equal: booleanValue
       (* Is THIS(GUID) equal to g? *)
       (# g: ^guid
       enter g[]
       <<SLOT GuidEqual: dopart>>
       #);
  enter setFromText
  exit getAsText
  #);     

CLSID: GUID(# #);
IID: GUID(# #);

VARIANT: holder
  (# 
     substance: @DATA
       (# vt: (* VARTYPE *) @int16;
          wReserved1: (* WORD *) @int16;
          wReserved2: (* WORD *) @int16;
          wReserved3: (* WORD *) @int16;
          long3: @int32;
          long4: @int32;
       #);
     
     vt: (# enter substance.vt exit substance.vt #);
     
     (* union members for different accesses of (long3,long4) *)
     lVal: (* LONG *) _long(# #);
     bVal: (* BYTE *) _byte(# #);
     iVal: (* SHORT *) _short(# #);
     fltVal: (* FLOAT *) _float(# #);
     dblVal: (* DOUBLE*) _double(# #);
     boolVal: (* VARIANT_BOOL *) _long(# #);
     bool: (* _VARIANT_BOOL *) _long(# #);
     scode: (* SCODE *) _long(# #);
     cyVal: (* CY *) 
       (# 
       enter (substance.long3,substance.long4)
       exit (substance.long3,substance.long4)
       #);
     date: (* DATE *) _double(# #);
     bstrVal: (* BSTR *) _long(# #);
     
     punkVal: (* IUnknown __RPC_FAR* *) _long(# #); (* OK? *)
     pdispVal: (* IDispatch __RPC_FAR* *) _long(# #); (* OK? *)
     parray: (* SAFEARRAY __RPC_FAR* *) _long(# #); (* OK? *)
     
     pbVal: (* BYTE __RPC_FAR* *) _long(# #);
     piVal: (* SHORT __RPC_FAR* *) _long(# #);
     plVal: (* LONG __RPC_FAR* *) _long(# #);
     pfltVal: (* FLOAT __RPC_FAR* *) _long(# #);
     pdblVal: (* DOUBLE __RPC_FAR* *) _long(# #);
     pboolVal: (* VARIANT_BOOL __RPC_FAR* *) _long(# #);
     pbool: (* _VARIANT_BOOL __RPC_FAR* *) _long(# #);
     pscode: (* SCODE __RPC_FAR* *) _long(# #);
     pcyVal: (* CY __RPC_FAR* *) _long(# #);
     pdate: (* DATE __RPC_FAR* *) _long(# #);
     pbstrVal: (* BSTR __RPC_FAR* *) _long(# #);
     ppunkVal: (* IUnknown __RPC_FAR* __RPC_FAR* *) _long(# #);
     ppdispVal: (* IDispatch __RPC_FAR* __RPC_FAR* *) _long(# #);
     pparray: (* SAFEARRAY __RPC_FAR* __RPC_FAR* *) _long(# #);
     pvarVal: (* VARIANT __RPC_FAR* *) _long(# #);
     
     byref: (* PVOID *) _long(# #);
     cVal: (* CHAR *) _ubyte(# #);
     uiVal: (* USHORT *) _ushort(# #);
     ulVal: (* ULONG *) _long(# #);
     intVal: (* INT *) _long(# #);
     uintVal: (* UINT *) _long(# #);
     
     pdecVal: (* DECIMAL __RPC_FAR* *) _long(# #);
     pcVal: (* CHAR __RPC_FAR* *) _long(# #);
     puiVal: (* USHORT __RPC_FAR* *) _long(# #);
     pulVal: (* ULONG __RPC_FAR* *) _long(# #);
     pintVal: (* INT __RPC_FAR* *) _long(# #);
     puintVal: (* UINT __RPC_FAR* *) _long(# #);
     
     (* Union alternative to (long3, long4) *)
     decVal: (* DECIMAL *)(* NYI *) 
     (# 
     enter (substance.long3, substance.long4)
     exit (substance.long3, substance.long4)
     #);
     
     (* help patterns *)
     _ubyte:
       (# 
       enter (# b: @int8 enter b do (b,1) ->substance.long3.%putByte #)
       exit 1->substance.long3.%getByte
       #);
     _ushort:
       (#
       enter (# i: @int16 enter i do (i,1) ->substance.long3.%putShort #)
       exit 1->substance.long3.%getShort
       #);
     _long:
       (# enter substance.long3 exit substance.long3 #);
     _byte:
       (# 
       enter (# b: @int8 enter b do (b,1) ->substance.long3.%putByte #)
       exit 1->substance.long3.%getSignedByte
       #);
     _short:
       (#
       enter (# i: @int16 enter i do (i,1) ->substance.long3.%putShort #)
       exit 1->substance.long3.%getSignedShort
       #);
     _float: 
       (# r: @real
       enter (# enter r 
             do r->substance.long3; 
                'Warning: VARIANT.float: precision lost!' -> putline;
             #)
       exit (# do substance.long3 -> r exit r #)
       #);
     _double:
       (# r: @real
       enter (# enter r 
             do 1->r.%getLong -> substance.long3; 
                2->r.%getLong -> substance.long4;
             #)
       exit (# 
            do (substance.long3,1)->r.%putLong; 
               (substance.long4,2)->r.%putLong; 
            exit r
            #)
       #);
  #);


GUIDHolder: Holder
  (# value: @GUID enter value exit value #);
CLSIDHolder: Holder
  (# value: @CLSID enter value exit value #);
IIDHolder: Holder
  (# value: @IID enter value exit value #);
