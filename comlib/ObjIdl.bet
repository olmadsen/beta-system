(* BETA interface generated from "ObjIdl.Idl" Tue May 12 10:33:34 1998 *)

ORIGIN '~beta/comlib/comtypes';
INCLUDE 'Unknwn';
INCLUDE 'wTypes';
--LIB: attributes--
  (* //+------------------------------------------------------------------------- *)
  (* // *)
  (* //  Microsoft Windows *)
  (* //  Copyright (C) Microsoft Corporation, 1992-1997. *)
  (* // *)
  (* //-------------------------------------------------------------------------- *)
  (* #if ( _MSC_VER >= 800 ) *)
  (* #endif *)
  SRVINFO: IntegerObject(# (* enum _SRVINFO *) #);
  SRVINFO_F_COSERVERINFO: (* SRVINFO *)(# exit 0 #);
  SRVINFO_F_COSERVERINFO2: (* SRVINFO *)(# exit 1 #);

  COSERVERINFO: struct__COSERVERINFO(# #);
  struct__COSERVERINFO: DATA
    (# dwReserved1: @int32u (* DWORD *);
       pwszName: @wcharHolder (* *LPWSTR *);
       pAuthInfo: ^struct__COAUTHINFO (* COAUTHINFO *);
       dwReserved2: @int32u (* DWORD *);
    #);
  COSERVERINFO2: struct__COSERVERINFO2(# #);
  struct__COSERVERINFO2: DATA
    (# dwFlags: @int32u (* DWORD *);
       pwszName: @wcharHolder (* *LPWSTR *);
       pAuthInfo: ^struct__COAUTHINFO (* COAUTHINFO *);
       ppCall: ^IUnknownHolder (* IUnknown *);
       pwszCodeURL: @wcharHolder (* *LPWSTR *);
       dwFileVersionMS: @int32u (* DWORD *);
       dwFileVersionLS: @int32u (* DWORD *);
       pwszContentType: @wcharHolder (* *LPWSTR *);
    #);

  IMarshal_IID: (# exit '00000003-0000-0000-C000-000000000046' #);

  IMarshal: IUnknown
    (# <<SLOT IMarshalLib: attributes>>;
       GetUnmarshalClass:<
         (# result: @int32 (* HRESULT *);
            riid: @int32 (* REFIID *); 
            pv: @int32 (* void* *); 
            dwDestContext: @int32u (* DWORD *); 
            pvDestContext: @int32 (* void* *); 
            mshlflags: @int32u (* DWORD *); 
            pCid: ^CLSIDHolder (* *CLSID *); 
         enter (riid, pv, dwDestContext, pvDestContext, mshlflags, pCid[])
         exit result
         #);
       GetMarshalSizeMax:<
         (# result: @int32 (* HRESULT *);
            riid: @int32 (* REFIID *); 
            pv: @int32 (* void* *); 
            dwDestContext: @int32u (* DWORD *); 
            pvDestContext: @int32 (* void* *); 
            mshlflags: @int32u (* DWORD *); 
            pSize: ^int32uHolder (* *DWORD *); 
         enter (riid, pv, dwDestContext, pvDestContext, mshlflags, pSize[])
         exit result
         #);
       MarshalInterface:<
         (# result: @int32 (* HRESULT *);
            pStm: ^IStream (* *IStream *); 
            riid: @int32 (* REFIID *); 
            pv: @int32 (* void* *); 
            dwDestContext: @int32u (* DWORD *); 
            pvDestContext: @int32 (* void* *); 
            mshlflags: @int32u (* DWORD *); 
         enter (pStm[], riid, pv, dwDestContext, pvDestContext, mshlflags)
         exit result
         #);
       UnmarshalInterface:<
         (# result: @int32 (* HRESULT *);
            pStm: ^IStream (* *IStream *); 
            riid: @int32 (* REFIID *); 
            ppv: @int32 (* void** *); 
         enter (pStm[], riid, ppv)
         exit result
         #);
       ReleaseMarshalData:<
         (# result: @int32 (* HRESULT *);
            pStm: ^IStream (* *IStream *); 
         enter pStm[]
         exit result
         #);
       DisconnectObject:<
         (# result: @int32 (* HRESULT *);
            dwReserved: @int32u (* DWORD *); 
         enter dwReserved
         exit result
         #);
    #);

  IMalloc_IID: (# exit '00000002-0000-0000-C000-000000000046' #);

  IMalloc: IUnknown
    (# <<SLOT IMallocLib: attributes>>;
       Alloc:<
         (# result: ^IUnknown (* void* *);
            cb: @int32u (* ULONG *); 
         enter cb
         exit result
         #);
       Realloc:<
         (# result: ^IUnknown (* void* *);
            pv: @int32 (* void* *); 
            cb: @int32u (* ULONG *); 
         enter (pv, cb)
         exit result
         #);
       Free:<
         (# (* No result *)
            pv: @int32 (* void* *); 
         enter pv

         #);
       GetSize:<
         (# result: @int32u (* ULONG *);
            pv: @int32 (* void* *); 
         enter pv
         exit result
         #);
       DidAlloc:<
         (# result: @integer (* param_base_type_spec NYI *);
            pv: @int32 (* void* *); 
         enter pv
         exit result
         #);
       HeapMinimize:<
         (# (* No result *)
            (* No parameters *); 

         #);
    #);

  IMallocSpy_IID: (# exit '0000001d-0000-0000-C000-000000000046' #);

  IMallocSpy: IUnknown
    (# <<SLOT IMallocSpyLib: attributes>>;
       PreAlloc:<
         (# result: @int32u (* ULONG *);
            cbRequest: @int32u (* ULONG *); 
         enter cbRequest
         exit result
         #);
       PostAlloc:<
         (# result: ^IUnknown (* void* *);
            pActual: @int32 (* void* *); 
         enter pActual
         exit result
         #);
       PreFree:<
         (# result: ^IUnknown (* void* *);
            pRequest: @int32 (* void* *); 
            fSpyed: @int32 (* BOOL *); 
         enter (pRequest, fSpyed)
         exit result
         #);
       PostFree:<
         (# (* No result *)
            fSpyed: @int32 (* BOOL *); 
         enter fSpyed

         #);
       PreRealloc:<
         (# result: @int32u (* ULONG *);
            pRequest: @int32 (* void* *); 
            cbRequest: @int32u (* ULONG *); 
            ppNewRequest: @int32 (* void** *); 
            fSpyed: @int32 (* BOOL *); 
         enter (pRequest, cbRequest, ppNewRequest, fSpyed)
         exit result
         #);
       PostRealloc:<
         (# result: ^IUnknown (* void* *);
            pActual: @int32 (* void* *); 
            fSpyed: @int32 (* BOOL *); 
         enter (pActual, fSpyed)
         exit result
         #);
       PreGetSize:<
         (# result: ^IUnknown (* void* *);
            pRequest: @int32 (* void* *); 
            fSpyed: @int32 (* BOOL *); 
         enter (pRequest, fSpyed)
         exit result
         #);
       PostGetSize:<
         (# result: @int32u (* ULONG *);
            cbActual: @int32u (* ULONG *); 
            fSpyed: @int32 (* BOOL *); 
         enter (cbActual, fSpyed)
         exit result
         #);
       PreDidAlloc:<
         (# result: ^IUnknown (* void* *);
            pRequest: @int32 (* void* *); 
            fSpyed: @int32 (* BOOL *); 
         enter (pRequest, fSpyed)
         exit result
         #);
       PostDidAlloc:<
         (# result: @integer (* param_base_type_spec NYI *);
            pRequest: @int32 (* void* *); 
            fSpyed: @int32 (* BOOL *); 
            fActual: @int32 (* int *); 
         enter (pRequest, fSpyed, fActual)
         exit result
         #);
       PreHeapMinimize:<
         (# (* No result *)
            (* No parameters *); 

         #);
       PostHeapMinimize:<
         (# (* No result *)
            (* No parameters *); 

         #);
    #);

  IStdMarshalInfo_IID: (# exit '00000018-0000-0000-C000-000000000046' #);

  IStdMarshalInfo: IUnknown
    (# <<SLOT IStdMarshalInfoLib: attributes>>;
       GetClassForHandler:<
         (# result: @int32 (* HRESULT *);
            dwDestContext: @int32u (* DWORD *); 
            pvDestContext: @int32 (* void* *); 
            pClsid: ^CLSIDHolder (* *CLSID *); 
         enter (dwDestContext, pvDestContext, pClsid[])
         exit result
         #);
    #);

  IExternalConnection_IID: (# exit '00000019-0000-0000-C000-000000000046' #);

  IExternalConnection: IUnknown
    (# <<SLOT IExternalConnectionLib: attributes>>;
       AddConnection:<
         (# result: @int32u (* DWORD *);
            extconn: @int32u (* DWORD *); 
            reserved: @int32u (* DWORD *); 
         enter (extconn, reserved)
         exit result
         #);
       ReleaseConnection:<
         (# result: @int32u (* DWORD *);
            extconn: @int32u (* DWORD *); 
            reserved: @int32u (* DWORD *); 
            fLastReleaseCloses: @int32 (* BOOL *); 
         enter (extconn, reserved, fLastReleaseCloses)
         exit result
         #);
    #);
  EXTCONN: IntegerObject(# (* enum tagEXTCONN *) #);
  EXTCONN_STRONG: (* EXTCONN *)(# exit 0x0001 #);
  EXTCONN_WEAK: (* EXTCONN *)(# exit 0x0002 #);
  EXTCONN_CALLABLE: (* EXTCONN *)(# exit 0x0004 #);


  IMultiQI_IID: (# exit '00000020-0000-0000-C000-000000000046' #);

  IMultiQI: IUnknown
    (# <<SLOT IMultiQILib: attributes>>;
       QueryMultipleInterfaces:<
         (# result: @int32 (* HRESULT *);
            cMQIs: @int32u (* ULONG *); 
            pMQIs: ^struct_tagMULTI_QI (* *MULTI_QI *); 
         enter (cMQIs, pMQIs[])
         exit result
         #);
    #);
  MULTI_QI: struct_tagMULTI_QI(# #);
  struct_tagMULTI_QI: DATA
    (# pIID: ^IIDHolder (* IID *);
       pItf: ^IUnknown (* IUnknown *);
       hr: @int32 (* HRESULT *);
    #);

  IEnumUnknown_IID: (# exit '00000100-0000-0000-C000-000000000046' #);

  IEnumUnknown: IUnknown
    (# <<SLOT IEnumUnknownLib: attributes>>;
       Next:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^IUnknownHolder (* **IUnknown *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       RemoteNext:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^IUnknownHolder (* **IUnknown *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       Skip:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
         enter celt
         exit result
         #);
       Reset:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       Clone:<
         (# result: @int32 (* HRESULT *);
            ppenum: ^IEnumUnknownHolder (* **IEnumUnknown *); 
         enter ppenum[]
         exit result
         #);
    #);

  IBindCtx_IID: (# exit '0000000e-0000-0000-C000-000000000046' #);

  IBindCtx: IUnknown
    (# <<SLOT IBindCtxLib: attributes>>;
       (* #if defined(__cplusplus) *)
       (*     typedef struct tagBIND_OPTS2 : tagBIND_OPTS{ *)
       (*     DWORD           dwTrackFlags; *)
       (*     DWORD           dwClassContext; *)
       (*     LCID            locale; *)
       (*     COSERVERINFO *  pServerInfo; *)
       (*     } BIND_OPTS2, * LPBIND_OPTS2; *)
       (* #else *)
       (* #endif *)
       RegisterObjectBound:<
         (# result: @int32 (* HRESULT *);
            punk: ^IUnknown (* *IUnknown *); 
         enter punk[]
         exit result
         #);
       RevokeObjectBound:<
         (# result: @int32 (* HRESULT *);
            punk: ^IUnknown (* *IUnknown *); 
         enter punk[]
         exit result
         #);
       ReleaseBoundObjects:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         exit result
         #);
       SetBindOptions:<
         (# result: @int32 (* HRESULT *);
            pbindopts: ^struct_tagBIND_OPTS (* *BIND_OPTS *); 
         enter pbindopts[]
         exit result
         #);
       RemoteSetBindOptions:<
         (# result: @int32 (* HRESULT *);
            pbindopts: ^struct_tagBIND_OPTS2 (* *BIND_OPTS2 *); 
         enter pbindopts[]
         exit result
         #);
       GetBindOptions:<
         (# result: @int32 (* HRESULT *);
            pbindopts: ^struct_tagBIND_OPTS (* *BIND_OPTS *); 
         enter pbindopts[]
         exit result
         #);
       RemoteGetBindOptions:<
         (# result: @int32 (* HRESULT *);
            pbindopts: ^struct_tagBIND_OPTS2 (* *BIND_OPTS2 *); 
         enter pbindopts[]
         exit result
         #);
       GetRunningObjectTable:<
         (# result: @int32 (* HRESULT *);
            pprot: ^IRunningObjectTableHolder (* **IRunningObjectTable *); 
         enter pprot[]
         exit result
         #);
       RegisterObjectParam:<
         (# result: @int32 (* HRESULT *);
            pszKey: [0]@char (* ^text NYI *) (* LPOLESTR *); 
            punk: ^IUnknown (* *IUnknown *); 
         enter (pszKey, punk[])
         exit result
         #);
       GetObjectParam:<
         (# result: @int32 (* HRESULT *);
            pszKey: [0]@char (* ^text NYI *) (* LPOLESTR *); 
            ppunk: ^IUnknownHolder (* **IUnknown *); 
         enter (pszKey, ppunk[])
         exit result
         #);
       EnumObjectParam:<
         (# result: @int32 (* HRESULT *);
            ppenum: ^IEnumStringHolder (* **IEnumString *); 
         enter ppenum[]
         exit result
         #);
       RevokeObjectParam:<
         (# result: @int32 (* HRESULT *);
            pszKey: [0]@char (* ^text NYI *) (* LPOLESTR *); 
         enter pszKey
         exit result
         #);
    #);
  BIND_OPTS: struct_tagBIND_OPTS(# #);
  struct_tagBIND_OPTS: DATA
    (# cbStruct: @int32u (* DWORD *);
       grfFlags: @int32u (* DWORD *);
       grfMode: @int32u (* DWORD *);
       dwTickCountDeadline: @int32u (* DWORD *);
    #);
  BIND_OPTS2: struct_tagBIND_OPTS2(# #);
  struct_tagBIND_OPTS2: DATA
    (# cbStruct: @int32u (* DWORD *);
       grfFlags: @int32u (* DWORD *);
       grfMode: @int32u (* DWORD *);
       dwTickCountDeadline: @int32u (* DWORD *);
       dwTrackFlags: @int32u (* DWORD *);
       dwClassContext: @int32u (* DWORD *);
       locale: @int32u (* LCID *);
       pServerInfo: ^struct__COSERVERINFO (* COSERVERINFO *);
    #);
  BIND_FLAGS: IntegerObject(# (* enum tagBIND_FLAGS *) #);
  BIND_MAYBOTHERUSER: (* BIND_FLAGS *)(# exit 1 #);
  BIND_JUSTTESTEXISTENCE: (* BIND_FLAGS *)(# exit 2 #);


  IEnumMoniker_IID: (# exit '00000102-0000-0000-C000-000000000046' #);

  IEnumMoniker: IUnknown
    (# <<SLOT IEnumMonikerLib: attributes>>;
       Next:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^IMonikerHolder (* **IMoniker *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       RemoteNext:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^IMonikerHolder (* **IMoniker *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       Skip:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
         enter celt
         exit result
         #);
       Reset:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       Clone:<
         (# result: @int32 (* HRESULT *);
            ppenum: ^IEnumMonikerHolder (* **IEnumMoniker *); 
         enter ppenum[]
         exit result
         #);
    #);

  IRunnableObject_IID: (# exit '00000126-0000-0000-C000-000000000046' #);

  IRunnableObject: IUnknown
    (# <<SLOT IRunnableObjectLib: attributes>>;
       GetRunningClass:<
         (# result: @int32 (* HRESULT *);
            lpClsid: ^CLSIDHolder (* LPCLSID *); 
         enter lpClsid[]
         exit result
         #);
       Run:<
         (# result: @int32 (* HRESULT *);
            pbc: ^IBindCtx (* LPBINDCTX *); 
         enter pbc[]
         exit result
         #);
       IsRunning:<
         (# result: @int32 (* BOOL *);
         exit result
         #);
       RemoteIsRunning:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       LockRunning:<
         (# result: @int32 (* HRESULT *);
            fLock: @int32 (* BOOL *); 
            fLastUnlockCloses: @int32 (* BOOL *); 
         enter (fLock, fLastUnlockCloses)
         exit result
         #);
       SetContainedObject:<
         (# result: @int32 (* HRESULT *);
            fContained: @int32 (* BOOL *); 
         enter fContained
         exit result
         #);
    #);

  IRunningObjectTable_IID: (# exit '00000010-0000-0000-C000-000000000046' #);

  IRunningObjectTable: IUnknown
    (# <<SLOT IRunningObjectTableLib: attributes>>;
       Register:<
         (# result: @int32 (* HRESULT *);
            grfFlags: @int32u (* DWORD *); 
            punkObject: ^IUnknown (* *IUnknown *); 
            pmkObjectName: ^IMoniker (* *IMoniker *); 
            pdwRegister: ^int32uHolder (* *DWORD *); 
         enter (grfFlags, punkObject[], pmkObjectName[], pdwRegister[])
         exit result
         #);
       Revoke:<
         (# result: @int32 (* HRESULT *);
            dwRegister: @int32u (* DWORD *); 
         enter dwRegister
         exit result
         #);
       IsRunning:<
         (# result: @int32 (* HRESULT *);
            pmkObjectName: ^IMoniker (* *IMoniker *); 
         enter pmkObjectName[]
         exit result
         #);
       GetObject:<
         (# result: @int32 (* HRESULT *);
            pmkObjectName: ^IMoniker (* *IMoniker *); 
            ppunkObject: ^IUnknownHolder (* **IUnknown *); 
         enter (pmkObjectName[], ppunkObject[])
         exit result
         #);
       NoteChangeTime:<
         (# result: @int32 (* HRESULT *);
            dwRegister: @int32u (* DWORD *); 
            pfiletime: ^struct__FILETIME (* *FILETIME *); 
         enter (dwRegister, pfiletime[])
         exit result
         #);
       GetTimeOfLastChange:<
         (# result: @int32 (* HRESULT *);
            pmkObjectName: ^IMoniker (* *IMoniker *); 
            pfiletime: ^struct__FILETIME (* *FILETIME *); 
         enter (pmkObjectName[], pfiletime[])
         exit result
         #);
       EnumRunning:<
         (# result: @int32 (* HRESULT *);
            ppenumMoniker: ^IEnumMonikerHolder (* **IEnumMoniker *); 
         enter ppenumMoniker[]
         exit result
         #);
    #);

  IPersist_IID: (# exit '0000010c-0000-0000-C000-000000000046' #);

  IPersist: IUnknown
    (# <<SLOT IPersistLib: attributes>>;
       GetClassID:<
         (# result: @int32 (* HRESULT *);
            pClassID: ^CLSIDHolder (* *CLSID *); 
         enter pClassID[]
         exit result
         #);
    #);

  IPersistStream_IID: (# exit '00000109-0000-0000-C000-000000000046' #);

  IPersistStream: IPersist
    (# <<SLOT IPersistStreamLib: attributes>>;
       IsDirty:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         exit result
         #);
       Load:<
         (# result: @int32 (* HRESULT *);
            pStm: ^IStream (* *IStream *); 
         enter pStm[]
         exit result
         #);
       Save:<
         (# result: @int32 (* HRESULT *);
            pStm: ^IStream (* *IStream *); 
            fClearDirty: @int32 (* BOOL *); 
         enter (pStm[], fClearDirty)
         exit result
         #);
       GetSizeMax:<
         (# result: @int32 (* HRESULT *);
            pcbSize: ^struct__ULARGE_INTEGER (* *ULARGE_INTEGER *); 
         enter pcbSize[]
         exit result
         #);
    #);

  IMoniker_IID: (# exit '0000000f-0000-0000-C000-000000000046' #);

  IMoniker: IPersistStream
    (# <<SLOT IMonikerLib: attributes>>;
       BindToObject:<
         (# result: @int32 (* HRESULT *);
            pbc: ^IBindCtx (* *IBindCtx *); 
            pmkToLeft: ^IMoniker (* *IMoniker *); 
            riidResult: @int32 (* REFIID *); 
            ppvResult: @int32 (* void** *); 
         enter (pbc[], pmkToLeft[], riidResult, ppvResult)
         exit result
         #);
       RemoteBindToObject:<
         (# result: @int32 (* HRESULT *);
            pbc: ^IBindCtx (* *IBindCtx *); 
            pmkToLeft: ^IMoniker (* *IMoniker *); 
            riidResult: @int32 (* REFIID *); 
            ppvResult: ^IUnknownHolder (* **IUnknown *); 
         enter (pbc[], pmkToLeft[], riidResult, ppvResult[])
         exit result
         #);
       BindToStorage:<
         (# result: @int32 (* HRESULT *);
            pbc: ^IBindCtx (* *IBindCtx *); 
            pmkToLeft: ^IMoniker (* *IMoniker *); 
            riid: @int32 (* REFIID *); 
            ppvObj: @int32 (* void** *); 
         enter (pbc[], pmkToLeft[], riid, ppvObj)
         exit result
         #);
       RemoteBindToStorage:<
         (# result: @int32 (* HRESULT *);
            pbc: ^IBindCtx (* *IBindCtx *); 
            pmkToLeft: ^IMoniker (* *IMoniker *); 
            riid: @int32 (* REFIID *); 
            ppvObj: ^IUnknownHolder (* **IUnknown *); 
         enter (pbc[], pmkToLeft[], riid, ppvObj[])
         exit result
         #);
       Reduce:<
         (# result: @int32 (* HRESULT *);
            pbc: ^IBindCtx (* *IBindCtx *); 
            dwReduceHowFar: @int32u (* DWORD *); 
            ppmkToLeft: ^IMonikerHolder (* **IMoniker *); 
            ppmkReduced: ^IMonikerHolder (* **IMoniker *); 
         enter (pbc[], dwReduceHowFar, ppmkToLeft[], ppmkReduced[])
         exit result
         #);
       ComposeWith:<
         (# result: @int32 (* HRESULT *);
            pmkRight: ^IMoniker (* *IMoniker *); 
            fOnlyIfNotGeneric: @int32 (* BOOL *); 
            ppmkComposite: ^IMonikerHolder (* **IMoniker *); 
         enter (pmkRight[], fOnlyIfNotGeneric, ppmkComposite[])
         exit result
         #);
       Enum:<
         (# result: @int32 (* HRESULT *);
            fForward: @int32 (* BOOL *); 
            ppenumMoniker: ^IEnumMonikerHolder (* **IEnumMoniker *); 
         enter (fForward, ppenumMoniker[])
         exit result
         #);
       IsEqual:<
         (# result: @int32 (* HRESULT *);
            pmkOtherMoniker: ^IMoniker (* *IMoniker *); 
         enter pmkOtherMoniker[]
         exit result
         #);
       Hash:<
         (# result: @int32 (* HRESULT *);
            pdwHash: ^int32uHolder (* *DWORD *); 
         enter pdwHash[]
         exit result
         #);
       IsRunning:<
         (# result: @int32 (* HRESULT *);
            pbc: ^IBindCtx (* *IBindCtx *); 
            pmkToLeft: ^IMoniker (* *IMoniker *); 
            pmkNewlyRunning: ^IMoniker (* *IMoniker *); 
         enter (pbc[], pmkToLeft[], pmkNewlyRunning[])
         exit result
         #);
       GetTimeOfLastChange:<
         (# result: @int32 (* HRESULT *);
            pbc: ^IBindCtx (* *IBindCtx *); 
            pmkToLeft: ^IMoniker (* *IMoniker *); 
            pFileTime: ^struct__FILETIME (* *FILETIME *); 
         enter (pbc[], pmkToLeft[], pFileTime[])
         exit result
         #);
       Inverse:<
         (# result: @int32 (* HRESULT *);
            ppmk: ^IMonikerHolder (* **IMoniker *); 
         enter ppmk[]
         exit result
         #);
       CommonPrefixWith:<
         (# result: @int32 (* HRESULT *);
            pmkOther: ^IMoniker (* *IMoniker *); 
            ppmkPrefix: ^IMonikerHolder (* **IMoniker *); 
         enter (pmkOther[], ppmkPrefix[])
         exit result
         #);
       RelativePathTo:<
         (# result: @int32 (* HRESULT *);
            pmkOther: ^IMoniker (* *IMoniker *); 
            ppmkRelPath: ^IMonikerHolder (* **IMoniker *); 
         enter (pmkOther[], ppmkRelPath[])
         exit result
         #);
       GetDisplayName:<
         (# result: @int32 (* HRESULT *);
            pbc: ^IBindCtx (* *IBindCtx *); 
            pmkToLeft: ^IMoniker (* *IMoniker *); 
            ppszDisplayName: ^textHolder (* *LPOLESTR *); 
         enter (pbc[], pmkToLeft[], ppszDisplayName[])
         exit result
         #);
       ParseDisplayName:<
         (# result: @int32 (* HRESULT *);
            pbc: ^IBindCtx (* *IBindCtx *); 
            pmkToLeft: ^IMoniker (* *IMoniker *); 
            pszDisplayName: [0]@char (* ^text NYI *) (* LPOLESTR *); 
            pchEaten: ^int32uHolder (* *ULONG *); 
            ppmkOut: ^IMonikerHolder (* **IMoniker *); 
         enter (pbc[], pmkToLeft[], pszDisplayName, pchEaten[], ppmkOut[])
         exit result
         #);
       IsSystemMoniker:<
         (# result: @int32 (* HRESULT *);
            pdwMksys: ^int32uHolder (* *DWORD *); 
         enter pdwMksys[]
         exit result
         #);
    #);
  MKSYS: IntegerObject(# (* enum tagMKSYS *) #);
  MKSYS_NONE: (* MKSYS *)(# exit 0 #);
  MKSYS_GENERICCOMPOSITE: (* MKSYS *)(# exit 1 #);
  MKSYS_FILEMONIKER: (* MKSYS *)(# exit 2 #);
  MKSYS_ANTIMONIKER: (* MKSYS *)(# exit 3 #);
  MKSYS_ITEMMONIKER: (* MKSYS *)(# exit 4 #);
  MKSYS_POINTERMONIKER: (* MKSYS *)(# exit 5 #);
  MKSYS_CLASSMONIKER: (* MKSYS *)(# exit 7 #);

  MKRREDUCE: IntegerObject(# (* enum tagMKREDUCE *) #);
  MKRREDUCE_ONE: (* MKRREDUCE *)(# exit 3 %sll 16 #);
  MKRREDUCE_TOUSER: (* MKRREDUCE *)(# exit 2 %sll 16 #);
  MKRREDUCE_THROUGHUSER: (* MKRREDUCE *)(# exit 1 %sll 16 #);
  MKRREDUCE_ALL: (* MKRREDUCE *)(# exit 0 #);


  IROTData_IID: (# exit 'f29f6bc0-5021-11ce-aa15-00006901293f' #);

  IROTData: IUnknown
    (# <<SLOT IROTDataLib: attributes>>;
       GetComparisonData:<
         (# result: @int32 (* HRESULT *);
            pbData: ^int8uHolder (* *byte *); 
            cbMax: @int32u (* ULONG *); 
            pcbData: ^int32uHolder (* *ULONG *); 
         enter (pbData[], cbMax, pcbData[])
         exit result
         #);
    #);

  IEnumString_IID: (# exit '00000101-0000-0000-C000-000000000046' #);

  IEnumString: IUnknown
    (# <<SLOT IEnumStringLib: attributes>>;
       Next:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^textHolder (* *LPOLESTR *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       RemoteNext:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^textHolder (* *LPOLESTR *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       Skip:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
         enter celt
         exit result
         #);
       Reset:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       Clone:<
         (# result: @int32 (* HRESULT *);
            ppenum: ^IEnumStringHolder (* **IEnumString *); 
         enter ppenum[]
         exit result
         #);
    #);

  ISequentialStream_IID: (# exit '0c733a30-2a1c-11ce-ade5-00aa0044773d' #);

  ISequentialStream: IUnknown
    (# <<SLOT ISequentialStreamLib: attributes>>;
       Read:<
         (# result: @int32 (* HRESULT *);
            pv: @int32 (* void* *); 
            cb: @int32u (* ULONG *); 
            pcbRead: ^int32uHolder (* *ULONG *); 
         enter (pv, cb, pcbRead[])
         exit result
         #);
       RemoteRead:<
         (# result: @int32 (* HRESULT *);
            pv: ^int8uHolder (* *byte *); 
            cb: @int32u (* ULONG *); 
            pcbRead: ^int32uHolder (* *ULONG *); 
         enter (pv[], cb, pcbRead[])
         exit result
         #);
       Write:<
         (# result: @int32 (* HRESULT *);
            pv: @int32 (* void* *); 
            cb: @int32u (* ULONG *); 
            pcbWritten: ^int32uHolder (* *ULONG *); 
         enter (pv, cb, pcbWritten[])
         exit result
         #);
       RemoteWrite:<
         (# result: @int32 (* HRESULT *);
            pv: ^int8uHolder (* *byte *); 
            cb: @int32u (* ULONG *); 
            pcbWritten: ^int32uHolder (* *ULONG *); 
         enter (pv[], cb, pcbWritten[])
         exit result
         #);
    #);

  IStream_IID: (# exit '0000000c-0000-0000-C000-000000000046' #);

  IStream: ISequentialStream
    (# <<SLOT IStreamLib: attributes>>;
       (* //FSSpec is Macintosh only, defined in macos\files.h *)
       (* #ifdef _MAC *)
       (*     typedef struct tagSTATSTG *)
       (*     {                       *)
       (*         LPOLESTR pwcsName; *)
       (*             FSSpec *pspec; *)
       (*         DWORD type; *)
       (*         ULARGE_INTEGER cbSize; *)
       (*         FILETIME mtime; *)
       (*         FILETIME ctime; *)
       (*         FILETIME atime; *)
       (*         DWORD grfMode; *)
       (*         DWORD grfLocksSupported; *)
       (*         CLSID clsid; *)
       (*         DWORD grfStateBits; *)
       (*         DWORD reserved; *)
       (*     } STATSTG; *)
       (* #else //_MAC *)
       (* #endif //_MAC *)
       Seek:<
         (# result: @int32 (* HRESULT *);
            dlibMove: @struct__LARGE_INTEGER (* LARGE_INTEGER *); 
            dwOrigin: @int32u (* DWORD *); 
            plibNewPosition: ^struct__ULARGE_INTEGER (* *ULARGE_INTEGER *); 
         enter (dlibMove, dwOrigin, plibNewPosition[])
         exit result
         #);
       RemoteSeek:<
         (# result: @int32 (* HRESULT *);
            dlibMove: @struct__LARGE_INTEGER (* LARGE_INTEGER *); 
            dwOrigin: @int32u (* DWORD *); 
            plibNewPosition: ^struct__ULARGE_INTEGER (* *ULARGE_INTEGER *); 
         enter (dlibMove, dwOrigin, plibNewPosition[])
         exit result
         #);
       SetSize:<
         (# result: @int32 (* HRESULT *);
            libNewSize: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
         enter libNewSize
         exit result
         #);
       CopyTo:<
         (# result: @int32 (* HRESULT *);
            pstm: ^IStream (* *IStream *); 
            cb: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
            pcbRead: ^struct__ULARGE_INTEGER (* *ULARGE_INTEGER *); 
            pcbWritten: ^struct__ULARGE_INTEGER (* *ULARGE_INTEGER *); 
         enter (pstm[], cb, pcbRead[], pcbWritten[])
         exit result
         #);
       RemoteCopyTo:<
         (# result: @int32 (* HRESULT *);
            pstm: ^IStream (* *IStream *); 
            cb: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
            pcbRead: ^struct__ULARGE_INTEGER (* *ULARGE_INTEGER *); 
            pcbWritten: ^struct__ULARGE_INTEGER (* *ULARGE_INTEGER *); 
         enter (pstm[], cb, pcbRead[], pcbWritten[])
         exit result
         #);
       Commit:<
         (# result: @int32 (* HRESULT *);
            grfCommitFlags: @int32u (* DWORD *); 
         enter grfCommitFlags
         exit result
         #);
       Revert:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       LockRegion:<
         (# result: @int32 (* HRESULT *);
            libOffset: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
            cb: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
            dwLockType: @int32u (* DWORD *); 
         enter (libOffset, cb, dwLockType)
         exit result
         #);
       UnlockRegion:<
         (# result: @int32 (* HRESULT *);
            libOffset: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
            cb: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
            dwLockType: @int32u (* DWORD *); 
         enter (libOffset, cb, dwLockType)
         exit result
         #);
       Stat:<
         (# result: @int32 (* HRESULT *);
            pstatstg: ^struct_tagSTATSTG (* *STATSTG *); 
            grfStatFlag: @int32u (* DWORD *); 
         enter (pstatstg[], grfStatFlag)
         exit result
         #);
       Clone:<
         (# result: @int32 (* HRESULT *);
            ppstm: ^IStreamHolder (* **IStream *); 
         enter ppstm[]
         exit result
         #);
    #);
  STATSTG: struct_tagSTATSTG(# #);
  struct_tagSTATSTG: DATA
    (# pwcsName: @wcharHolder (* *LPOLESTR *);
       type: @int32u (* DWORD *);
       cbSize: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *);
       mtime: @struct__FILETIME (* FILETIME *);
       ctime: @struct__FILETIME (* FILETIME *);
       atime: @struct__FILETIME (* FILETIME *);
       grfMode: @int32u (* DWORD *);
       grfLocksSupported: @int32u (* DWORD *);
       _clsid: @CLSID (* CLSID *);
       grfStateBits: @int32u (* DWORD *);
       reserved: @int32u (* DWORD *);
    #);
  STGTY: IntegerObject(# (* enum tagSTGTY *) #);
  STGTY_STORAGE: (* STGTY *)(# exit 1 #);
  STGTY_STREAM: (* STGTY *)(# exit 2 #);
  STGTY_LOCKBYTES: (* STGTY *)(# exit 3 #);
  STGTY_PROPERTY: (* STGTY *)(# exit 4 #);

  STREAM_SEEK: IntegerObject(# (* enum tagSTREAM_SEEK *) #);
  STREAM_SEEK_SET: (* STREAM_SEEK *)(# exit 0 #);
  STREAM_SEEK_CUR: (* STREAM_SEEK *)(# exit 1 #);
  STREAM_SEEK_END: (* STREAM_SEEK *)(# exit 2 #);

  LOCKTYPE: IntegerObject(# (* enum tagLOCKTYPE *) #);
  LOCK_WRITE: (* LOCKTYPE *)(# exit 1 #);
  LOCK_EXCLUSIVE: (* LOCKTYPE *)(# exit 2 #);
  LOCK_ONLYONCE: (* LOCKTYPE *)(# exit 4 #);


  IEnumSTATSTG_IID: (# exit '0000000d-0000-0000-C000-000000000046' #);

  IEnumSTATSTG: IUnknown
    (# <<SLOT IEnumSTATSTGLib: attributes>>;
       Next:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^struct_tagSTATSTG (* *STATSTG *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       RemoteNext:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^struct_tagSTATSTG (* *STATSTG *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       Skip:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
         enter celt
         exit result
         #);
       Reset:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       Clone:<
         (# result: @int32 (* HRESULT *);
            ppenum: ^IEnumSTATSTGHolder (* **IEnumSTATSTG *); 
         enter ppenum[]
         exit result
         #);
    #);

  IStorage_IID: (# exit '0000000b-0000-0000-C000-000000000046' #);

  IStorage: IUnknown
    (# <<SLOT IStorageLib: attributes>>;
       CreateStream:<
         (# result: @int32 (* HRESULT *);
            pwcsName: [0]@char (* ^text NYI *) (* *OLECHAR *); 
            grfMode: @int32u (* DWORD *); 
            reserved1: @int32u (* DWORD *); 
            reserved2: @int32u (* DWORD *); 
            ppstm: ^IStreamHolder (* **IStream *); 
         enter (pwcsName, grfMode, reserved1, reserved2, ppstm[])
         exit result
         #);
       OpenStream:<
         (# result: @int32 (* HRESULT *);
            pwcsName: [0]@char (* ^text NYI *) (* *OLECHAR *); 
            reserved1: @int32 (* void* *); 
            grfMode: @int32u (* DWORD *); 
            reserved2: @int32u (* DWORD *); 
            ppstm: ^IStreamHolder (* **IStream *); 
         enter (pwcsName, reserved1, grfMode, reserved2, ppstm[])
         exit result
         #);
       RemoteOpenStream:<
         (# result: @int32 (* HRESULT *);
            pwcsName: [0]@char (* ^text NYI *) (* *OLECHAR *); 
            cbReserved1: @int32u (* unsigned_long *); 
            reserved1: ^int8uHolder (* *byte *); 
            grfMode: @int32u (* DWORD *); 
            reserved2: @int32u (* DWORD *); 
            ppstm: ^IStreamHolder (* **IStream *); 
         enter (pwcsName, cbReserved1, reserved1[], grfMode, reserved2, ppstm[])
         exit result
         #);
       CreateStorage:<
         (# result: @int32 (* HRESULT *);
            pwcsName: [0]@char (* ^text NYI *) (* *OLECHAR *); 
            grfMode: @int32u (* DWORD *); 
            reserved1: @int32u (* DWORD *); 
            reserved2: @int32u (* DWORD *); 
            ppstg: ^IStorageHolder (* **IStorage *); 
         enter (pwcsName, grfMode, reserved1, reserved2, ppstg[])
         exit result
         #);
       OpenStorage:<
         (# result: @int32 (* HRESULT *);
            pwcsName: [0]@char (* ^text NYI *) (* *OLECHAR *); 
            pstgPriority: ^IStorage (* *IStorage *); 
            grfMode: @int32u (* DWORD *); 
            snbExclude: ^wcharHolder (* SNB *); 
            reserved: @int32u (* DWORD *); 
            ppstg: ^IStorageHolder (* **IStorage *); 
         enter (pwcsName, pstgPriority[], grfMode, snbExclude[], reserved, ppstg[])
         exit result
         #);
       CopyTo:<
         (# result: @int32 (* HRESULT *);
            ciidExclude: @int32u (* DWORD *); 
            rgiidExclude: ^IIDHolder (* *IID *); 
            snbExclude: ^wcharHolder (* SNB *); 
            pstgDest: ^IStorage (* *IStorage *); 
         enter (ciidExclude, rgiidExclude[], snbExclude[], pstgDest[])
         exit result
         #);
       MoveElementTo:<
         (# result: @int32 (* HRESULT *);
            pwcsName: [0]@char (* ^text NYI *) (* *OLECHAR *); 
            pstgDest: ^IStorage (* *IStorage *); 
            pwcsNewName: [0]@char (* ^text NYI *) (* *OLECHAR *); 
            grfFlags: @int32u (* DWORD *); 
         enter (pwcsName, pstgDest[], pwcsNewName, grfFlags)
         exit result
         #);
       Commit:<
         (# result: @int32 (* HRESULT *);
            grfCommitFlags: @int32u (* DWORD *); 
         enter grfCommitFlags
         exit result
         #);
       Revert:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       EnumElements:<
         (# result: @int32 (* HRESULT *);
            reserved1: @int32u (* DWORD *); 
            reserved2: @int32 (* void* *); 
            reserved3: @int32u (* DWORD *); 
            ppenum: ^IEnumSTATSTGHolder (* **IEnumSTATSTG *); 
         enter (reserved1, reserved2, reserved3, ppenum[])
         exit result
         #);
       RemoteEnumElements:<
         (# result: @int32 (* HRESULT *);
            reserved1: @int32u (* DWORD *); 
            cbReserved2: @int32u (* unsigned_long *); 
            reserved2: ^int8uHolder (* *byte *); 
            reserved3: @int32u (* DWORD *); 
            ppenum: ^IEnumSTATSTGHolder (* **IEnumSTATSTG *); 
         enter (reserved1, cbReserved2, reserved2[], reserved3, ppenum[])
         exit result
         #);
       DestroyElement:<
         (# result: @int32 (* HRESULT *);
            pwcsName: [0]@char (* ^text NYI *) (* *OLECHAR *); 
         enter pwcsName
         exit result
         #);
       RenameElement:<
         (# result: @int32 (* HRESULT *);
            pwcsOldName: [0]@char (* ^text NYI *) (* *OLECHAR *); 
            pwcsNewName: [0]@char (* ^text NYI *) (* *OLECHAR *); 
         enter (pwcsOldName, pwcsNewName)
         exit result
         #);
       SetElementTimes:<
         (# result: @int32 (* HRESULT *);
            pwcsName: [0]@char (* ^text NYI *) (* *OLECHAR *); 
            pctime: ^struct__FILETIME (* *FILETIME *); 
            patime: ^struct__FILETIME (* *FILETIME *); 
            pmtime: ^struct__FILETIME (* *FILETIME *); 
         enter (pwcsName, pctime[], patime[], pmtime[])
         exit result
         #);
       SetClass:<
         (# result: @int32 (* HRESULT *);
            _clsid: @int32 (* REFCLSID *); 
         enter _clsid
         exit result
         #);
       SetStateBits:<
         (# result: @int32 (* HRESULT *);
            grfStateBits: @int32u (* DWORD *); 
            grfMask: @int32u (* DWORD *); 
         enter (grfStateBits, grfMask)
         exit result
         #);
       Stat:<
         (# result: @int32 (* HRESULT *);
            pstatstg: ^struct_tagSTATSTG (* *STATSTG *); 
            grfStatFlag: @int32u (* DWORD *); 
         enter (pstatstg[], grfStatFlag)
         exit result
         #);
    #);
  RemSNB: struct_tagRemSNB(# #);
  struct_tagRemSNB: DATA
    (# ulCntStr: @int32u (* unsigned_long *);
       ulCntChar: @int32u (* unsigned_long *);
       rgString: ^wcharHolder (* OLECHAR *);
    #);

  IPersistFile_IID: (# exit '0000010b-0000-0000-C000-000000000046' #);

  IPersistFile: IPersist
    (# <<SLOT IPersistFileLib: attributes>>;
       IsDirty:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         exit result
         #);
       Load:<
         (# result: @int32 (* HRESULT *);
            pszFileName: [0]@char (* ^text NYI *) (* LPCOLESTR *); 
            dwMode: @int32u (* DWORD *); 
         enter (pszFileName, dwMode)
         exit result
         #);
       Save:<
         (# result: @int32 (* HRESULT *);
            pszFileName: [0]@char (* ^text NYI *) (* LPCOLESTR *); 
            fRemember: @int32 (* BOOL *); 
         enter (pszFileName, fRemember)
         exit result
         #);
       SaveCompleted:<
         (# result: @int32 (* HRESULT *);
            pszFileName: [0]@char (* ^text NYI *) (* LPCOLESTR *); 
         enter pszFileName
         exit result
         #);
       GetCurFile:<
         (# result: @int32 (* HRESULT *);
            ppszFileName: ^textHolder (* *LPOLESTR *); 
         enter ppszFileName[]
         exit result
         #);
    #);

  IPersistStorage_IID: (# exit '0000010a-0000-0000-C000-000000000046' #);

  IPersistStorage: IPersist
    (# <<SLOT IPersistStorageLib: attributes>>;
       IsDirty:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         exit result
         #);
       InitNew:<
         (# result: @int32 (* HRESULT *);
            pStg: ^IStorage (* *IStorage *); 
         enter pStg[]
         exit result
         #);
       Load:<
         (# result: @int32 (* HRESULT *);
            pStg: ^IStorage (* *IStorage *); 
         enter pStg[]
         exit result
         #);
       Save:<
         (# result: @int32 (* HRESULT *);
            pStgSave: ^IStorage (* *IStorage *); 
            fSameAsLoad: @int32 (* BOOL *); 
         enter (pStgSave[], fSameAsLoad)
         exit result
         #);
       SaveCompleted:<
         (# result: @int32 (* HRESULT *);
            pStgNew: ^IStorage (* *IStorage *); 
         enter pStgNew[]
         exit result
         #);
       HandsOffStorage:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         exit result
         #);
    #);

  ILockBytes_IID: (# exit '0000000a-0000-0000-C000-000000000046' #);

  ILockBytes: IUnknown
    (# <<SLOT ILockBytesLib: attributes>>;
       ReadAt:<
         (# result: @int32 (* HRESULT *);
            ulOffset: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
            pv: @int32 (* void* *); 
            cb: @int32u (* ULONG *); 
            pcbRead: ^int32uHolder (* *ULONG *); 
         enter (ulOffset, pv, cb, pcbRead[])
         exit result
         #);
       RemoteReadAt:<
         (# result: @int32 (* HRESULT *);
            ulOffset: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
            pv: ^int8uHolder (* *byte *); 
            cb: @int32u (* ULONG *); 
            pcbRead: ^int32uHolder (* *ULONG *); 
         enter (ulOffset, pv[], cb, pcbRead[])
         (* __stdcall *)
         exit result
         #);
       WriteAt:<
         (# result: @int32 (* HRESULT *);
            ulOffset: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
            pv: @int32 (* void* *); 
            cb: @int32u (* ULONG *); 
            pcbWritten: ^int32uHolder (* *ULONG *); 
         enter (ulOffset, pv, cb, pcbWritten[])
         exit result
         #);
       RemoteWriteAt:<
         (# result: @int32 (* HRESULT *);
            ulOffset: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
            pv: ^int8uHolder (* *byte *); 
            cb: @int32u (* ULONG *); 
            pcbWritten: ^int32uHolder (* *ULONG *); 
         enter (ulOffset, pv[], cb, pcbWritten[])
         exit result
         #);
       Flush:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       SetSize:<
         (# result: @int32 (* HRESULT *);
            cb: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
         enter cb
         exit result
         #);
       LockRegion:<
         (# result: @int32 (* HRESULT *);
            libOffset: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
            cb: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
            dwLockType: @int32u (* DWORD *); 
         enter (libOffset, cb, dwLockType)
         exit result
         #);
       UnlockRegion:<
         (# result: @int32 (* HRESULT *);
            libOffset: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
            cb: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
            dwLockType: @int32u (* DWORD *); 
         enter (libOffset, cb, dwLockType)
         exit result
         #);
       Stat:<
         (# result: @int32 (* HRESULT *);
            pstatstg: ^struct_tagSTATSTG (* *STATSTG *); 
            grfStatFlag: @int32u (* DWORD *); 
         enter (pstatstg[], grfStatFlag)
         exit result
         #);
    #);

  IEnumFORMATETC_IID: (# exit '00000103-0000-0000-C000-000000000046' #);

  IEnumFORMATETC: IUnknown
    (# <<SLOT IEnumFORMATETCLib: attributes>>;
       Next:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^struct_tagFORMATETC (* *FORMATETC *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       RemoteNext:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^struct_tagFORMATETC (* *FORMATETC *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       Skip:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
         enter celt
         exit result
         #);
       Reset:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       Clone:<
         (# result: @int32 (* HRESULT *);
            ppenum: ^IEnumFORMATETCHolder (* **IEnumFORMATETC *); 
         enter ppenum[]
         exit result
         #);
    #);
  DVTARGETDEVICE: struct_tagDVTARGETDEVICE(# #);
  struct_tagDVTARGETDEVICE: DATA
    (# tdSize: @int32u (* DWORD *);
       tdDriverNameOffset: @int16u (* WORD *);
       tdDeviceNameOffset: @int16u (* WORD *);
       tdPortNameOffset: @int16u (* WORD *);
       tdExtDevmodeOffset: @int16u (* WORD *);
       tdData: ^int8uHolder (* BYTE *);
    #);
  FORMATETC: struct_tagFORMATETC(# #);
  struct_tagFORMATETC: DATA
    (# cfFormat: @int16u (* CLIPFORMAT *);
       ptd: ^struct_tagDVTARGETDEVICE (* DVTARGETDEVICE *);
       dwAspect: @int32u (* DWORD *);
       lindex: @int32 (* LONG *);
       tymed: @int32u (* DWORD *);
    #);

  IEnumSTATDATA_IID: (# exit '00000105-0000-0000-C000-000000000046' #);

  IEnumSTATDATA: IUnknown
    (# <<SLOT IEnumSTATDATALib: attributes>>;
       Next:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^struct_tagSTATDATA (* *STATDATA *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       RemoteNext:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^struct_tagSTATDATA (* *STATDATA *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       Skip:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
         enter celt
         exit result
         #);
       Reset:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       Clone:<
         (# result: @int32 (* HRESULT *);
            ppenum: ^IEnumSTATDATAHolder (* **IEnumSTATDATA *); 
         enter ppenum[]
         exit result
         #);
    #);
  ADVF: IntegerObject(# (* enum tagADVF *) #);
  ADVF_NODATA: (* ADVF *)(# exit 1 #);
  ADVF_PRIMEFIRST: (* ADVF *)(# exit 2 #);
  ADVF_ONLYONCE: (* ADVF *)(# exit 4 #);
  ADVF_DATAONSTOP: (* ADVF *)(# exit 64 #);
  ADVFCACHE_NOHANDLER: (* ADVF *)(# exit 8 #);
  ADVFCACHE_FORCEBUILTIN: (* ADVF *)(# exit 16 #);
  ADVFCACHE_ONSAVE: (* ADVF *)(# exit 32 #);

  STATDATA: struct_tagSTATDATA(# #);
  struct_tagSTATDATA: DATA
    (# formatetc: @struct_tagFORMATETC (* FORMATETC *);
       advf: @int32u (* DWORD *);
       pAdvSink: ^IAdviseSink (* IAdviseSink *);
       dwConnection: @int32u (* DWORD *);
    #);

  IRootStorage_IID: (# exit '00000012-0000-0000-C000-000000000046' #);

  IRootStorage: IUnknown
    (# <<SLOT IRootStorageLib: attributes>>;
       SwitchToFile:<
         (# result: @int32 (* HRESULT *);
            pszFile: [0]@char (* ^text NYI *) (* LPOLESTR *); 
         enter pszFile
         exit result
         #);
    #);

  IAdviseSink_IID: (# exit '0000010f-0000-0000-C000-000000000046' #);

  IAdviseSink: IUnknown
    (# <<SLOT IAdviseSinkLib: attributes>>;
       (* #ifndef RC_INVOKED *)
       (* #endif *)
       (* #ifndef RC_INVOKED *)
       (* #endif *)
       (* #ifdef NONAMELESSUNION *)
       (* typedef struct tagSTGMEDIUM { *)
       (*     DWORD tymed; *)
       (*     union { *)
       (*         HBITMAP hBitmap; *)
       (*         HMETAFILEPICT hMetaFilePict; *)
       (*         HENHMETAFILE hEnhMetaFile; *)
       (*         HGLOBAL hGlobal; *)
       (*         LPOLESTR lpszFileName; *)
       (*         IStream *pstm; *)
       (*         IStorage *pstg; *)
       (*         } u; *)
       (*     IUnknown *pUnkForRelease; *)
       (* }uSTGMEDIUM; *)
       (* #else *)
       (* #endif /* !NONAMELESSUNION */ *)
       OnDataChange:<
         (# (* No result *)
            pFormatetc: ^struct_tagFORMATETC (* *FORMATETC *); 
            pStgmed: ^struct_tagSTGMEDIUM (* *STGMEDIUM *); 
         enter (pFormatetc[], pStgmed[])

         #);
       OnViewChange:<
         (# (* No result *)
            dwAspect: @int32u (* DWORD *); 
            lindex: @int32 (* LONG *); 
         enter (dwAspect, lindex)

         #);
       OnRename:<
         (# (* No result *)
            pmk: ^IMoniker (* *IMoniker *); 
         enter pmk[]

         #);
       OnSave:<
         (# (* No result *)

         #);
       OnClose:<
         (# (* No result *)

         #);
       RemoteOnDataChange:<
         (# (* No result *)
            pFormatetc: ^struct_tagFORMATETC (* *FORMATETC *); 
            pStgmed: ^struct_tagSTGMEDIUM (* *ASYNC_STGMEDIUM *); 
         enter (pFormatetc[], pStgmed[])

         #);
       RemoteOnViewChange:<
         (# (* No result *)
            dwAspect: @int32u (* DWORD *); 
            lindex: @int32 (* LONG *); 
         enter (dwAspect, lindex)

         #);
       RemoteOnRename:<
         (# (* No result *)
            pmk: ^IMoniker (* *IMoniker *); 
         enter pmk[]

         #);
       RemoteOnSave:<
         (# (* No result *)

         #);
       RemoteOnClose:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
    #);
  TYMED: IntegerObject(# (* enum tagTYMED *) #);
  TYMED_HGLOBAL: (* TYMED *)(# exit 1 #);
  TYMED_FILE: (* TYMED *)(# exit 2 #);
  TYMED_ISTREAM: (* TYMED *)(# exit 4 #);
  TYMED_ISTORAGE: (* TYMED *)(# exit 8 #);
  TYMED_GDI: (* TYMED *)(# exit 16 #);
  TYMED_MFPICT: (* TYMED *)(# exit 32 #);
  TYMED_ENHMF: (* TYMED *)(# exit 64 #);
  TYMED_NULL: (* TYMED *)(# exit 0 #);

  RemSTGMEDIUM: struct_tagRemSTGMEDIUM(# #);
  struct_tagRemSTGMEDIUM: DATA
    (# tymed: @int32u (* DWORD *);
       dwHandleType: @int32u (* DWORD *);
       pData: @int32u (* unsigned_long *);
       pUnkForRelease: @int32u (* unsigned_long *);
       cbData: @int32u (* unsigned_long *);
       data: ^int8uHolder (* byte *);
    #);
  uSTGMEDIUM: struct_tagSTGMEDIUM(# #);
  struct_tagSTGMEDIUM: DATA
    (# tymed: @int32u (* DWORD *);
       pUnkForRelease: ^IUnknown (* IUnknown *);
    #);
  GDI_OBJECT: union__GDI_OBJECT(# #);
  union__GDI_OBJECT: holder
    (# 
       (* 
        * union types are not translated.
        * You must do it by hand, sorry!
        *)
    #);
  userSTGMEDIUM: struct__userSTGMEDIUM(# #);
  struct__userSTGMEDIUM: DATA
    (# pUnkForRelease: ^IUnknown (* IUnknown *);
    #);
  userFLAG_STGMEDIUM: struct__userFLAG_STGMEDIUM(# #);
  struct__userFLAG_STGMEDIUM: DATA
    (# ContextFlags: @int32 (* long *);
       fPassOwnership: @int32 (* long *);
       Stgmed: @struct__userSTGMEDIUM (* userSTGMEDIUM *);
    #);
  FLAG_STGMEDIUM: struct__FLAG_STGMEDIUM(# #);
  struct__FLAG_STGMEDIUM: DATA
    (# ContextFlags: @int32 (* long *);
       fPassOwnership: @int32 (* long *);
       Stgmed: @struct_tagSTGMEDIUM (* STGMEDIUM *);
    #);

  IAdviseSink2_IID: (# exit '00000125-0000-0000-C000-000000000046' #);

  IAdviseSink2: IAdviseSink
    (# <<SLOT IAdviseSink2Lib: attributes>>;
       OnLinkSrcChange:<
         (# (* No result *)
            pmk: ^IMoniker (* *IMoniker *); 
         enter pmk[]

         #);
       RemoteOnLinkSrcChange:<
         (# (* No result *)
            pmk: ^IMoniker (* *IMoniker *); 
         enter pmk[]

         #);
    #);

  IDataObject_IID: (# exit '0000010e-0000-0000-C000-000000000046' #);

  IDataObject: IUnknown
    (# <<SLOT IDataObjectLib: attributes>>;
       GetData:<
         (# result: @int32 (* HRESULT *);
            pformatetcIn: ^struct_tagFORMATETC (* *FORMATETC *); 
            pmedium: ^struct_tagSTGMEDIUM (* *STGMEDIUM *); 
         enter (pformatetcIn[], pmedium[])
         exit result
         #);
       RemoteGetData:<
         (# result: @int32 (* HRESULT *);
            pformatetcIn: ^struct_tagFORMATETC (* *FORMATETC *); 
            pRemoteMedium: ^struct_tagSTGMEDIUM (* *STGMEDIUM *); 
         enter (pformatetcIn[], pRemoteMedium[])
         exit result
         #);
       GetDataHere:<
         (# result: @int32 (* HRESULT *);
            pformatetc: ^struct_tagFORMATETC (* *FORMATETC *); 
            pmedium: ^struct_tagSTGMEDIUM (* *STGMEDIUM *); 
         enter (pformatetc[], pmedium[])
         exit result
         #);
       RemoteGetDataHere:<
         (# result: @int32 (* HRESULT *);
            pformatetc: ^struct_tagFORMATETC (* *FORMATETC *); 
            pRemoteMedium: ^struct_tagSTGMEDIUM (* *STGMEDIUM *); 
         enter (pformatetc[], pRemoteMedium[])
         exit result
         #);
       QueryGetData:<
         (# result: @int32 (* HRESULT *);
            pformatetc: ^struct_tagFORMATETC (* *FORMATETC *); 
         enter pformatetc[]
         exit result
         #);
       GetCanonicalFormatEtc:<
         (# result: @int32 (* HRESULT *);
            pformatectIn: ^struct_tagFORMATETC (* *FORMATETC *); 
            pformatetcOut: ^struct_tagFORMATETC (* *FORMATETC *); 
         enter (pformatectIn[], pformatetcOut[])
         exit result
         #);
       SetData:<
         (# result: @int32 (* HRESULT *);
            pformatetc: ^struct_tagFORMATETC (* *FORMATETC *); 
            pmedium: ^struct_tagSTGMEDIUM (* *STGMEDIUM *); 
            fRelease: @int32 (* BOOL *); 
         enter (pformatetc[], pmedium[], fRelease)
         exit result
         #);
       RemoteSetData:<
         (# result: @int32 (* HRESULT *);
            pformatetc: ^struct_tagFORMATETC (* *FORMATETC *); 
            pmedium: ^struct__FLAG_STGMEDIUM (* *FLAG_STGMEDIUM *); 
            fRelease: @int32 (* BOOL *); 
         enter (pformatetc[], pmedium[], fRelease)
         exit result
         #);
       EnumFormatEtc:<
         (# result: @int32 (* HRESULT *);
            dwDirection: @int32u (* DWORD *); 
            ppenumFormatEtc: ^IEnumFORMATETCHolder (* **IEnumFORMATETC *); 
         enter (dwDirection, ppenumFormatEtc[])
         exit result
         #);
       DAdvise:<
         (# result: @int32 (* HRESULT *);
            pformatetc: ^struct_tagFORMATETC (* *FORMATETC *); 
            advf: @int32u (* DWORD *); 
            pAdvSink: ^IAdviseSink (* *IAdviseSink *); 
            pdwConnection: ^int32uHolder (* *DWORD *); 
         enter (pformatetc[], advf, pAdvSink[], pdwConnection[])
         exit result
         #);
       DUnadvise:<
         (# result: @int32 (* HRESULT *);
            dwConnection: @int32u (* DWORD *); 
         enter dwConnection
         exit result
         #);
       EnumDAdvise:<
         (# result: @int32 (* HRESULT *);
            ppenumAdvise: ^IEnumSTATDATAHolder (* **IEnumSTATDATA *); 
         enter ppenumAdvise[]
         exit result
         #);
    #);
  DATADIR: IntegerObject(# (* enum tagDATADIR *) #);
  DATADIR_GET: (* DATADIR *)(# exit 1 #);
  DATADIR_SET: (* DATADIR *)(# exit 2 #);


  IDataAdviseHolder_IID: (# exit '00000110-0000-0000-C000-000000000046' #);

  IDataAdviseHolder: IUnknown
    (# <<SLOT IDataAdviseHolderLib: attributes>>;
       Advise:<
         (# result: @int32 (* HRESULT *);
            pDataObject: ^IDataObject (* *IDataObject *); 
            pFetc: ^struct_tagFORMATETC (* *FORMATETC *); 
            advf: @int32u (* DWORD *); 
            pAdvise: ^IAdviseSink (* *IAdviseSink *); 
            pdwConnection: ^int32uHolder (* *DWORD *); 
         enter (pDataObject[], pFetc[], advf, pAdvise[], pdwConnection[])
         exit result
         #);
       Unadvise:<
         (# result: @int32 (* HRESULT *);
            dwConnection: @int32u (* DWORD *); 
         enter dwConnection
         exit result
         #);
       EnumAdvise:<
         (# result: @int32 (* HRESULT *);
            ppenumAdvise: ^IEnumSTATDATAHolder (* **IEnumSTATDATA *); 
         enter ppenumAdvise[]
         exit result
         #);
       SendOnDataChange:<
         (# result: @int32 (* HRESULT *);
            pDataObject: ^IDataObject (* *IDataObject *); 
            dwReserved: @int32u (* DWORD *); 
            advf: @int32u (* DWORD *); 
         enter (pDataObject[], dwReserved, advf)
         exit result
         #);
    #);

  IMessageFilter_IID: (# exit '00000016-0000-0000-C000-000000000046' #);

  IMessageFilter: IUnknown
    (# <<SLOT IMessageFilterLib: attributes>>;
       HandleInComingCall:<
         (# result: @int32u (* DWORD *);
            dwCallType: @int32u (* DWORD *); 
            htaskCaller: ^int32Holder (* HTASK *); 
            dwTickCount: @int32u (* DWORD *); 
            lpInterfaceInfo: ^struct_tagINTERFACEINFO (* LPINTERFACEINFO *); 
         enter (dwCallType, htaskCaller[], dwTickCount, lpInterfaceInfo[])
         exit result
         #);
       RetryRejectedCall:<
         (# result: @int32u (* DWORD *);
            htaskCallee: ^int32Holder (* HTASK *); 
            dwTickCount: @int32u (* DWORD *); 
            dwRejectType: @int32u (* DWORD *); 
         enter (htaskCallee[], dwTickCount, dwRejectType)
         exit result
         #);
       MessagePending:<
         (# result: @int32u (* DWORD *);
            htaskCallee: ^int32Holder (* HTASK *); 
            dwTickCount: @int32u (* DWORD *); 
            dwPendingType: @int32u (* DWORD *); 
         enter (htaskCallee[], dwTickCount, dwPendingType)
         exit result
         #);
    #);
  CALLTYPE: IntegerObject(# (* enum tagCALLTYPE *) #);
  CALLTYPE_TOPLEVEL: (* CALLTYPE *)(# exit 1 #);
  CALLTYPE_NESTED: (* CALLTYPE *)(# exit 2 #);
  CALLTYPE_ASYNC: (* CALLTYPE *)(# exit 3 #);
  CALLTYPE_TOPLEVEL_CALLPENDING: (* CALLTYPE *)(# exit 4 #);
  CALLTYPE_ASYNC_CALLPENDING: (* CALLTYPE *)(# exit 5 #);

  SERVERCALL: IntegerObject(# (* enum tagSERVERCALL *) #);
  SERVERCALL_ISHANDLED: (* SERVERCALL *)(# exit 0 #);
  SERVERCALL_REJECTED: (* SERVERCALL *)(# exit 1 #);
  SERVERCALL_RETRYLATER: (* SERVERCALL *)(# exit 2 #);

  PENDINGTYPE: IntegerObject(# (* enum tagPENDINGTYPE *) #);
  PENDINGTYPE_TOPLEVEL: (* PENDINGTYPE *)(# exit 1 #);
  PENDINGTYPE_NESTED: (* PENDINGTYPE *)(# exit 2 #);

  PENDINGMSG: IntegerObject(# (* enum tagPENDINGMSG *) #);
  PENDINGMSG_CANCELCALL: (* PENDINGMSG *)(# exit 0 #);
  PENDINGMSG_WAITNOPROCESS: (* PENDINGMSG *)(# exit 1 #);
  PENDINGMSG_WAITDEFPROCESS: (* PENDINGMSG *)(# exit 2 #);

  INTERFACEINFO: struct_tagINTERFACEINFO(# #);
  struct_tagINTERFACEINFO: DATA
    (# pUnk: ^IUnknown (* IUnknown *);
       _iid: @IID (* IID *);
       wMethod: @int16u (* WORD *);
    #);

  IRpcChannelBuffer_IID: (# exit 'D5F56B60-593B-101A-B569-08002B2DBF7A' #);

  IRpcChannelBuffer: IUnknown
    (# <<SLOT IRpcChannelBufferLib: attributes>>;
       GetBuffer:<
         (# result: @int32 (* HRESULT *);
            pMessage: ^struct_tagRPCOLEMESSAGE (* *RPCOLEMESSAGE *); 
            riid: @int32 (* REFIID *); 
         enter (pMessage[], riid)
         exit result
         #);
       SendReceive:<
         (# result: @int32 (* HRESULT *);
            pMessage: ^struct_tagRPCOLEMESSAGE (* *RPCOLEMESSAGE *); 
            pStatus: ^int32uHolder (* *ULONG *); 
         enter (pMessage[], pStatus[])
         exit result
         #);
       FreeBuffer:<
         (# result: @int32 (* HRESULT *);
            pMessage: ^struct_tagRPCOLEMESSAGE (* *RPCOLEMESSAGE *); 
         enter pMessage[]
         exit result
         #);
       GetDestCtx:<
         (# result: @int32 (* HRESULT *);
            pdwDestContext: ^int32uHolder (* *DWORD *); 
            ppvDestContext: @int32 (* void** *); 
         enter (pdwDestContext[], ppvDestContext)
         exit result
         #);
       IsConnected:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         exit result
         #);
    #);
  RPCOLEMESSAGE: struct_tagRPCOLEMESSAGE(# #);
  struct_tagRPCOLEMESSAGE: DATA
    (# reserved1: ^int32Holder;
       dataRepresentation: @int32u (* RPCOLEDATAREP *);
       Buffer: ^int32Holder;
       cbBuffer: @int32u (* ULONG *);
       iMethod: @int32u (* ULONG *);
       reserved2: ^int32Holder;
       rpcFlags: @int32u (* ULONG *);
    #);

  IRpcChannelBuffer2_IID: (# exit '594f31d0-7f19-11d0-b194-00a0c90dc8bf' #);

  IRpcChannelBuffer2: IRpcChannelBuffer
    (# <<SLOT IRpcChannelBuffer2Lib: attributes>>;
       GetProtocolVersion:<
         (# result: @int32 (* HRESULT *);
            pdwVersion: ^int32uHolder (* *DWORD *); 
         enter pdwVersion[]
         exit result
         #);
    #);

  IRpcChannelBuffer3_IID: (# exit '25B15600-0115-11d0-BF0D-00AA00B8DFD2' #);

  IRpcChannelBuffer3: IRpcChannelBuffer2
    (# <<SLOT IRpcChannelBuffer3Lib: attributes>>;
       Send:<
         (# result: @int32 (* HRESULT *);
            pMsg: ^struct_tagRPCOLEMESSAGE (* *RPCOLEMESSAGE *); 
            pulStatus: ^int32uHolder (* *ULONG *); 
         enter (pMsg[], pulStatus[])
         exit result
         #);
       Receive:<
         (# result: @int32 (* HRESULT *);
            pMsg: ^struct_tagRPCOLEMESSAGE (* *RPCOLEMESSAGE *); 
            ulSize: @int32u (* ULONG *); 
            pulStatus: ^int32uHolder (* *ULONG *); 
         enter (pMsg[], ulSize, pulStatus[])
         exit result
         #);
       Cancel:<
         (# result: @int32 (* HRESULT *);
            pMsg: ^struct_tagRPCOLEMESSAGE (* *RPCOLEMESSAGE *); 
         enter pMsg[]
         exit result
         #);
       GetCallContext:<
         (# result: @int32 (* HRESULT *);
            pMsg: ^struct_tagRPCOLEMESSAGE (* *RPCOLEMESSAGE *); 
            riid: @int32 (* REFIID *); 
            pInterface: @int32 (* void** *); 
         enter (pMsg[], riid, pInterface)
         exit result
         #);
       GetDestCtxEx:<
         (# result: @int32 (* HRESULT *);
            pMsg: ^struct_tagRPCOLEMESSAGE (* *RPCOLEMESSAGE *); 
            pdwDestContext: ^int32uHolder (* *DWORD *); 
            ppvDestContext: @int32 (* void** *); 
         enter (pMsg[], pdwDestContext[], ppvDestContext)
         exit result
         #);
       GetState:<
         (# result: @int32 (* HRESULT *);
            pMsg: ^struct_tagRPCOLEMESSAGE (* *RPCOLEMESSAGE *); 
            pState: ^int32uHolder (* *DWORD *); 
         enter (pMsg[], pState[])
         exit result
         #);
       RegisterAsync:<
         (# result: @int32 (* HRESULT *);
            pMsg: ^struct_tagRPCOLEMESSAGE (* *RPCOLEMESSAGE *); 
            pAsyncMgr: ^IAsyncManager (* *IAsyncManager *); 
         enter (pMsg[], pAsyncMgr[])
         exit result
         #);
    #);

  IRpcProxyBuffer_IID: (# exit 'D5F56A34-593B-101A-B569-08002B2DBF7A' #);

  IRpcProxyBuffer: IUnknown
    (# <<SLOT IRpcProxyBufferLib: attributes>>;
       Connect:<
         (# result: @int32 (* HRESULT *);
            pRpcChannelBuffer: ^IRpcChannelBuffer (* *IRpcChannelBuffer *); 
         enter pRpcChannelBuffer[]
         exit result
         #);
       Disconnect:<
         (# (* No result *)
            (* No parameters *); 

         #);
    #);

  IRpcStubBuffer_IID: (# exit 'D5F56AFC-593B-101A-B569-08002B2DBF7A' #);

  IRpcStubBuffer: IUnknown
    (# <<SLOT IRpcStubBufferLib: attributes>>;
       Connect:<
         (# result: @int32 (* HRESULT *);
            pUnkServer: ^IUnknown (* *IUnknown *); 
         enter pUnkServer[]
         exit result
         #);
       Disconnect:<
         (# (* No result *)

         #);
       Invoke:<
         (# result: @int32 (* HRESULT *);
            _prpcmsg: ^struct_tagRPCOLEMESSAGE (* *RPCOLEMESSAGE *); 
            _pRpcChannelBuffer: ^IRpcChannelBuffer (* *IRpcChannelBuffer *); 
         enter (_prpcmsg[], _pRpcChannelBuffer[])
         exit result
         #);
       IsIIDSupported:<
         (# result: @integer (* param_type_spec_ref NYI *);
            riid: @int32 (* REFIID *); 
         enter riid
         exit result
         #);
       CountRefs:<
         (# result: @int32u (* ULONG *);
            (* No parameters *); 
         exit result
         #);
       DebugServerQueryInterface:<
         (# result: @int32 (* HRESULT *);
            ppv: @int32 (* void** *); 
         enter ppv
         exit result
         #);
       DebugServerRelease:<
         (# (* No result *)
            pv: @int32 (* void* *); 
         enter pv

         #);
    #);

  IPSFactoryBuffer_IID: (# exit 'D5F569D0-593B-101A-B569-08002B2DBF7A' #);

  IPSFactoryBuffer: IUnknown
    (# <<SLOT IPSFactoryBufferLib: attributes>>;
       CreateProxy:<
         (# result: @int32 (* HRESULT *);
            pUnkOuter: ^IUnknown (* *IUnknown *); 
            riid: @int32 (* REFIID *); 
            ppProxy: ^IRpcProxyBufferHolder (* **IRpcProxyBuffer *); 
            ppv: @int32 (* void** *); 
         enter (pUnkOuter[], riid, ppProxy[], ppv)
         exit result
         #);
       CreateStub:<
         (# result: @int32 (* HRESULT *);
            riid: @int32 (* REFIID *); 
            pUnkServer: ^IUnknown (* *IUnknown *); 
            ppStub: ^IRpcStubBufferHolder (* **IRpcStubBuffer *); 
         enter (riid, pUnkServer[], ppStub[])
         exit result
         #);
    #);
  (* #if  (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) // DCOM *)
  (* // This interface is only valid on Windows NT 4.0 *)
  SChannelHookCallInfo: struct_SChannelHookCallInfo(# #);
  struct_SChannelHookCallInfo: DATA
    (# _iid: @IID (* IID *);
       cbSize: @int32u (* DWORD *);
       uCausality: @GUID (* GUID *);
       dwServerPid: @int32u (* DWORD *);
       iMethod: @int32u (* DWORD *);
       pObject: ^int32Holder;
    #);

  IChannelHook_IID: (# exit '1008c4a0-7613-11cf-9af1-0020af6e72f4' #);

  IChannelHook: IUnknown
    (# <<SLOT IChannelHookLib: attributes>>;
       ClientGetSize:<
         (# (* No result *)
            uExtent: @int32 (* REFGUID *); 
            riid: @int32 (* REFIID *); 
            pDataSize: ^int32uHolder (* *ULONG *); 
         enter (uExtent, riid, pDataSize[])

         #);
       ClientFillBuffer:<
         (# (* No result *)
            uExtent: @int32 (* REFGUID *); 
            riid: @int32 (* REFIID *); 
            pDataSize: ^int32uHolder (* *ULONG *); 
            pDataBuffer: @int32 (* void* *); 
         enter (uExtent, riid, pDataSize[], pDataBuffer)

         #);
       ClientNotify:<
         (# (* No result *)
            uExtent: @int32 (* REFGUID *); 
            riid: @int32 (* REFIID *); 
            cbDataSize: @int32u (* ULONG *); 
            pDataBuffer: @int32 (* void* *); 
            lDataRep: @int32u (* DWORD *); 
            hrFault: @int32 (* HRESULT *); 
         enter (uExtent, riid, cbDataSize, pDataBuffer, lDataRep, hrFault)

         #);
       ServerNotify:<
         (# (* No result *)
            uExtent: @int32 (* REFGUID *); 
            riid: @int32 (* REFIID *); 
            cbDataSize: @int32u (* ULONG *); 
            pDataBuffer: @int32 (* void* *); 
            lDataRep: @int32u (* DWORD *); 
         enter (uExtent, riid, cbDataSize, pDataBuffer, lDataRep)

         #);
       ServerGetSize:<
         (# (* No result *)
            uExtent: @int32 (* REFGUID *); 
            riid: @int32 (* REFIID *); 
            hrFault: @int32 (* HRESULT *); 
            pDataSize: ^int32uHolder (* *ULONG *); 
         enter (uExtent, riid, hrFault, pDataSize[])

         #);
       ServerFillBuffer:<
         (# (* No result *)
            uExtent: @int32 (* REFGUID *); 
            riid: @int32 (* REFIID *); 
            pDataSize: ^int32uHolder (* *ULONG *); 
            pDataBuffer: @int32 (* void* *); 
            hrFault: @int32 (* HRESULT *); 
         enter (uExtent, riid, pDataSize[], pDataBuffer, hrFault)

         #);
    #);
  (* #endif //DCOM *)

  IPropertyStorage_IID: (# exit '00000138-0000-0000-C000-000000000046' #);

  IPropertyStorage: IUnknown
    (# <<SLOT IPropertyStorageLib: attributes>>;
       (*  *)
       (* // Well-known Property Set Format IDs *)
       (*  *)
       (* // Flags for IPropertySetStorage::Create *)
         PROPSETFLAG_DEFAULT: (# exit 0 #);
         PROPSETFLAG_NONSIMPLE: (# exit 1 #);
         PROPSETFLAG_ANSI: (# exit 2 #);
       (* // This flag is only supported on StgCreatePropStg & StgOpenPropStg *)
         PROPSETFLAG_UNBUFFERED: (# exit 4 #);
       (* // Disable the warning about the obsolete member named 'bool' *)
       (* // 'bool', 'true', 'false', 'mutable', 'explicit', & 'typename' *)
       (* // are reserved keywords *)
       (* // Reserved global Property IDs *)
         PID_DICTIONARY: (# exit 0x00000000 #);
         PID_CODEPAGE: (# exit 0x00000001 #);
         PID_FIRST_USABLE: (# exit 0x00000002 #);
         PID_FIRST_NAME_DEFAULT: (# exit 0x00000fff #);
         PID_LOCALE: (# exit 0x80000000 #);
         PID_MODIFY_TIME: (# exit 0x80000001 #);
         PID_SECURITY: (# exit 0x80000002 #);
         PID_ILLEGAL: (# exit 0xffffffff #);
       (* // Property IDs for the SummaryInformation Property Set *)
       (*  *)
       (* #define PIDSI_TITLE               0x00000002L  // VT_LPSTR *)
       (* #define PIDSI_SUBJECT             0x00000003L  // VT_LPSTR *)
       (* #define PIDSI_AUTHOR              0x00000004L  // VT_LPSTR *)
       (* #define PIDSI_KEYWORDS            0x00000005L  // VT_LPSTR *)
       (* #define PIDSI_COMMENTS            0x00000006L  // VT_LPSTR *)
       (* #define PIDSI_TEMPLATE            0x00000007L  // VT_LPSTR *)
       (* #define PIDSI_LASTAUTHOR          0x00000008L  // VT_LPSTR *)
       (* #define PIDSI_REVNUMBER           0x00000009L  // VT_LPSTR *)
       (* #define PIDSI_EDITTIME            0x0000000aL  // VT_FILETIME (UTC) *)
       (* #define PIDSI_LASTPRINTED         0x0000000bL  // VT_FILETIME (UTC) *)
       (* #define PIDSI_CREATE_DTM          0x0000000cL  // VT_FILETIME (UTC) *)
       (* #define PIDSI_LASTSAVE_DTM        0x0000000dL  // VT_FILETIME (UTC) *)
       (* #define PIDSI_PAGECOUNT           0x0000000eL  // VT_I4 *)
       (* #define PIDSI_WORDCOUNT           0x0000000fL  // VT_I4 *)
       (* #define PIDSI_CHARCOUNT           0x00000010L  // VT_I4 *)
       (* #define PIDSI_THUMBNAIL           0x00000011L  // VT_CF *)
       (* #define PIDSI_APPNAME             0x00000012L  // VT_LPSTR *)
       (* #define PIDSI_DOC_SECURITY        0x00000013L  // VT_I4 *)
         PRSPEC_INVALID: (# exit 0xffffffff #);
         PRSPEC_LPWSTR: (# exit 0 #);
         PRSPEC_PROPID: (# exit 1 #);
       (* // Macros for parsing the OS Version of the Property Set Header *)
       (* #define PROPSETHDR_OSVER_KIND(dwOSVer)      HIWORD( (dwOSVer) ) *)
       (* #define PROPSETHDR_OSVER_MAJOR(dwOSVer)     LOBYTE(LOWORD( (dwOSVer) )) *)
       (* #define PROPSETHDR_OSVER_MINOR(dwOSVer)     HIBYTE(LOWORD( (dwOSVer) )) *)
       (* #define PROPSETHDR_OSVERSION_UNKNOWN        0xFFFFFFFF *)
       ReadMultiple:<
         (# result: @int32 (* HRESULT *);
            cpspec: @int32u (* ULONG *); 
            rgpspec: ^struct_tagPROPSPEC (* *PROPSPEC *); 
            rgpropvar: ^struct_tagPROPVARIANT (* *PROPVARIANT *); 
         enter (cpspec, rgpspec[], rgpropvar[])
         exit result
         #);
       WriteMultiple:<
         (# result: @int32 (* HRESULT *);
            cpspec: @int32u (* ULONG *); 
            rgpspec: ^struct_tagPROPSPEC (* *PROPSPEC *); 
            rgpropvar: ^struct_tagPROPVARIANT (* *PROPVARIANT *); 
            propidNameFirst: @int32u (* PROPID *); 
         enter (cpspec, rgpspec[], rgpropvar[], propidNameFirst)
         exit result
         #);
       DeleteMultiple:<
         (# result: @int32 (* HRESULT *);
            cpspec: @int32u (* ULONG *); 
            rgpspec: ^struct_tagPROPSPEC (* *PROPSPEC *); 
         enter (cpspec, rgpspec[])
         exit result
         #);
       ReadPropertyNames:<
         (# result: @int32 (* HRESULT *);
            cpropid: @int32u (* ULONG *); 
            rgpropid: ^int32uHolder (* *PROPID *); 
            rglpwstrName: ^textHolder (* *LPOLESTR *); 
         enter (cpropid, rgpropid[], rglpwstrName[])
         exit result
         #);
       WritePropertyNames:<
         (# result: @int32 (* HRESULT *);
            cpropid: @int32u (* ULONG *); 
            rgpropid: ^int32uHolder (* *PROPID *); 
            rglpwstrName: ^textHolder (* *LPOLESTR *); 
         enter (cpropid, rgpropid[], rglpwstrName[])
         exit result
         #);
       DeletePropertyNames:<
         (# result: @int32 (* HRESULT *);
            cpropid: @int32u (* ULONG *); 
            rgpropid: ^int32uHolder (* *PROPID *); 
         enter (cpropid, rgpropid[])
         exit result
         #);
       Commit:<
         (# result: @int32 (* HRESULT *);
            grfCommitFlags: @int32u (* DWORD *); 
         enter grfCommitFlags
         exit result
         #);
       Revert:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       Enum:<
         (# result: @int32 (* HRESULT *);
            ppenum: ^IEnumSTATPROPSTGHolder (* **IEnumSTATPROPSTG *); 
         enter ppenum[]
         exit result
         #);
       SetTimes:<
         (# result: @int32 (* HRESULT *);
            pctime: ^struct__FILETIME (* *FILETIME *); 
            patime: ^struct__FILETIME (* *FILETIME *); 
            pmtime: ^struct__FILETIME (* *FILETIME *); 
         enter (pctime[], patime[], pmtime[])
         exit result
         #);
       SetClass:<
         (# result: @int32 (* HRESULT *);
            _clsid: @int32 (* REFCLSID *); 
         enter _clsid
         exit result
         #);
       Stat:<
         (# result: @int32 (* HRESULT *);
            pstatpsstg: ^struct_tagSTATPROPSETSTG (* *STATPROPSETSTG *); 
         enter pstatpsstg[]
         exit result
         #);
    #);
  PROPVARIANT: struct_tagPROPVARIANT(# #);
  CAUB: struct_tagCAUB(# #);
  struct_tagCAUB: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^int8uHolder (* unsigned_char *);
    #);
  CAI: struct_tagCAI(# #);
  struct_tagCAI: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^int16Holder (* short *);
    #);
  CAUI: struct_tagCAUI(# #);
  struct_tagCAUI: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^int16uHolder (* USHORT *);
    #);
  CAL: struct_tagCAL(# #);
  struct_tagCAL: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^int32Holder (* long *);
    #);
  CAUL: struct_tagCAUL(# #);
  struct_tagCAUL: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^int32uHolder (* ULONG *);
    #);
  CAFLT: struct_tagCAFLT(# #);
  struct_tagCAFLT: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^realHolder (* float *);
    #);
  CADBL: struct_tagCADBL(# #);
  struct_tagCADBL: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^realHolder (* double *);
    #);
  CACY: struct_tagCACY(# #);
  struct_tagCACY: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^struct_tagCY (* CY *);
    #);
  CADATE: struct_tagCADATE(# #);
  struct_tagCADATE: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^realHolder (* DATE *);
    #);
  CABSTR: struct_tagCABSTR(# #);
  struct_tagCABSTR: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^BSTRHolder (* BSTR *);
    #);
  CABSTRBLOB: struct_tagCABSTRBLOB(# #);
  struct_tagCABSTRBLOB: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^struct_tagBSTRBLOB (* BSTRBLOB *);
    #);
  CABOOL: struct_tagCABOOL(# #);
  struct_tagCABOOL: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^int16Holder (* VARIANT_BOOL *);
    #);
  CASCODE: struct_tagCASCODE(# #);
  struct_tagCASCODE: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^int32Holder (* SCODE *);
    #);
  CAPROPVARIANT: struct_tagCAPROPVARIANT(# #);
  struct_tagCAPROPVARIANT: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^struct_tagPROPVARIANT (* PROPVARIANT *);
    #);
  CAH: struct_tagCAH(# #);
  struct_tagCAH: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^struct__LARGE_INTEGER (* LARGE_INTEGER *);
    #);
  CAUH: struct_tagCAUH(# #);
  struct_tagCAUH: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^struct__ULARGE_INTEGER (* ULARGE_INTEGER *);
    #);
  CALPSTR: struct_tagCALPSTR(# #);
  struct_tagCALPSTR: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^charHolder (* *LPSTR *);
    #);
  CALPWSTR: struct_tagCALPWSTR(# #);
  struct_tagCALPWSTR: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^wcharHolder (* *LPWSTR *);
    #);
  CAFILETIME: struct_tagCAFILETIME(# #);
  struct_tagCAFILETIME: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^struct__FILETIME (* FILETIME *);
    #);
  CACLIPDATA: struct_tagCACLIPDATA(# #);
  struct_tagCACLIPDATA: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^struct_tagCLIPDATA (* CLIPDATA *);
    #);
  CACLSID: struct_tagCACLSID(# #);
  struct_tagCACLSID: DATA
    (# cElems: @int32u (* ULONG *);
       pElems: ^CLSIDHolder (* CLSID *);
    #);
  struct_tagPROPVARIANT: DATA
    (# vt: @int16u (* VARTYPE *);
       wReserved1: @int16u (* WORD *);
       wReserved2: @int16u (* WORD *);
       wReserved3: @int16u (* WORD *);
    #);
  PROPSPEC: struct_tagPROPSPEC(# #);
  struct_tagPROPSPEC: DATA
    (# ulKind: @int32u (* ULONG *);
    #);
  STATPROPSTG: struct_tagSTATPROPSTG(# #);
  struct_tagSTATPROPSTG: DATA
    (# lpwstrName: @wcharHolder (* *LPOLESTR *);
       propid: @int32u (* PROPID *);
       vt: @int16u (* VARTYPE *);
    #);
  STATPROPSETSTG: struct_tagSTATPROPSETSTG(# #);
  struct_tagSTATPROPSETSTG: DATA
    (# fmtid: @GUID (* FMTID *);
       _clsid: @CLSID (* CLSID *);
       grfFlags: @int32u (* DWORD *);
       mtime: @struct__FILETIME (* FILETIME *);
       ctime: @struct__FILETIME (* FILETIME *);
       atime: @struct__FILETIME (* FILETIME *);
       dwOSVersion: @int32u (* DWORD *);
    #);

  IPropertySetStorage_IID: (# exit '0000013A-0000-0000-C000-000000000046' #);

  IPropertySetStorage: IUnknown
    (# <<SLOT IPropertySetStorageLib: attributes>>;
       Create:<
         (# result: @int32 (* HRESULT *);
            rfmtid: @int32 (* REFFMTID *); 
            pclsid: ^CLSIDHolder (* *CLSID *); 
            grfFlags: @int32u (* DWORD *); 
            grfMode: @int32u (* DWORD *); 
            ppprstg: ^IPropertyStorageHolder (* **IPropertyStorage *); 
         enter (rfmtid, pclsid[], grfFlags, grfMode, ppprstg[])
         exit result
         #);
       Open:<
         (# result: @int32 (* HRESULT *);
            rfmtid: @int32 (* REFFMTID *); 
            grfMode: @int32u (* DWORD *); 
            ppprstg: ^IPropertyStorageHolder (* **IPropertyStorage *); 
         enter (rfmtid, grfMode, ppprstg[])
         exit result
         #);
       Delete:<
         (# result: @int32 (* HRESULT *);
            rfmtid: @int32 (* REFFMTID *); 
         enter rfmtid
         exit result
         #);
       Enum:<
         (# result: @int32 (* HRESULT *);
            ppenum: ^IEnumSTATPROPSETSTGHolder (* **IEnumSTATPROPSETSTG *); 
         enter ppenum[]
         exit result
         #);
    #);

  IEnumSTATPROPSTG_IID: (# exit '00000139-0000-0000-C000-000000000046' #);

  IEnumSTATPROPSTG: IUnknown
    (# <<SLOT IEnumSTATPROPSTGLib: attributes>>;
       Next:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^struct_tagSTATPROPSTG (* *STATPROPSTG *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       RemoteNext:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^struct_tagSTATPROPSTG (* *STATPROPSTG *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       Skip:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
         enter celt
         exit result
         #);
       Reset:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       Clone:<
         (# result: @int32 (* HRESULT *);
            ppenum: ^IEnumSTATPROPSTGHolder (* **IEnumSTATPROPSTG *); 
         enter ppenum[]
         exit result
         #);
    #);

  IEnumSTATPROPSETSTG_IID: (# exit '0000013B-0000-0000-C000-000000000046' #);

  IEnumSTATPROPSETSTG: IUnknown
    (# <<SLOT IEnumSTATPROPSETSTGLib: attributes>>;
       Next:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^struct_tagSTATPROPSETSTG (* *STATPROPSETSTG *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       RemoteNext:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^struct_tagSTATPROPSETSTG (* *STATPROPSETSTG *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       Skip:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
         enter celt
         exit result
         #);
       Reset:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       Clone:<
         (# result: @int32 (* HRESULT *);
            ppenum: ^IEnumSTATPROPSETSTGHolder (* **IEnumSTATPROPSETSTG *); 
         enter ppenum[]
         exit result
         #);
    #);
  (* WINOLEAPI PropVariantCopy ( PROPVARIANT * pvarDest, const PROPVARIANT * pvarSrc ); *)
  (* WINOLEAPI PropVariantClear ( PROPVARIANT * pvar ); *)
  (* WINOLEAPI FreePropVariantArray ( ULONG cVariants, PROPVARIANT * rgvars ); *)
  (*  *)
  (* #define _PROPVARIANTINIT_DEFINED_ *)
  (* #   ifdef __cplusplus *)
  (* inline void PropVariantInit ( PROPVARIANT * pvar ) *)
  (* { *)
  (*     memset ( pvar, 0, sizeof(PROPVARIANT) ); *)
  (* } *)
  (* #   else *)
  (* #   define PropVariantInit(pvar) memset ( pvar, 0, sizeof(PROPVARIANT) ) *)
  (* #   endif *)
  (*  *)
  (*  *)
  (* #ifndef _STGCREATEPROPSTG_DEFINED_ *)
  (* WINOLEAPI StgCreatePropStg( IUnknown* pUnk, REFFMTID fmtid, const CLSID *pclsid, DWORD grfFlags, DWORD dwReserved, IPropertyStorage **ppPropStg ); *)
  (* WINOLEAPI StgOpenPropStg( IUnknown* pUnk, REFFMTID fmtid, DWORD grfFlags, DWORD dwReserved, IPropertyStorage **ppPropStg ); *)
  (* WINOLEAPI StgCreatePropSetStg( IStorage *pStorage, DWORD dwReserved, IPropertySetStorage **ppPropSetStg); *)
  (*  *)
  (* #define CCH_MAX_PROPSTG_NAME    31 *)
  (* WINOLEAPI FmtIdToPropStgName( const FMTID *pfmtid, LPOLESTR oszName ); *)
  (* WINOLEAPI PropStgNameToFmtId( const LPOLESTR oszName, FMTID *pfmtid ); *)
  (* #endif *)
  (* #if  (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) // DCOM *)
  (* // This interface is only valid on Windows NT 4.0 *)

  IClientSecurity_IID: (# exit '0000013D-0000-0000-C000-000000000046' #);

  IClientSecurity: IUnknown
    (# <<SLOT IClientSecurityLib: attributes>>;
       QueryBlanket:<
         (# result: @int32 (* HRESULT *);
            pProxy: ^IUnknown (* *IUnknown *); 
            pAuthnSvc: ^int32uHolder (* *DWORD *); 
            pAuthzSvc: ^int32uHolder (* *DWORD *); 
            pServerPrincName: ^wcharHolder (* **OLECHAR *); 
            pAuthnLevel: ^int32uHolder (* *DWORD *); 
            pImpLevel: ^int32uHolder (* *DWORD *); 
            pAuthInfo: @int32 (* void** *); 
            pCapabilites: ^int32uHolder (* *DWORD *); 
         enter (pProxy[], pAuthnSvc[], pAuthzSvc[], pServerPrincName[], pAuthnLevel[], pImpLevel[], pAuthInfo, pCapabilites[])
         exit result
         #);
       SetBlanket:<
         (# result: @int32 (* HRESULT *);
            pProxy: ^IUnknown (* *IUnknown *); 
            AuthnSvc: @int32u (* DWORD *); 
            AuthzSvc: @int32u (* DWORD *); 
            pServerPrincName: ^wcharHolder (* *OLECHAR *); 
            AuthnLevel: @int32u (* DWORD *); 
            ImpLevel: @int32u (* DWORD *); 
            pAuthInfo: @int32 (* void* *); 
            Capabilities: @int32u (* DWORD *); 
         enter (pProxy[], AuthnSvc, AuthzSvc, pServerPrincName[], AuthnLevel, ImpLevel, pAuthInfo, Capabilities)
         exit result
         #);
       CopyProxy:<
         (# result: @int32 (* HRESULT *);
            pProxy: ^IUnknown (* *IUnknown *); 
            ppCopy: ^IUnknownHolder (* **IUnknown *); 
         enter (pProxy[], ppCopy[])
         exit result
         #);
    #);
  SOLE_AUTHENTICATION_SERVICE: struct_tagSOLE_AUTHENTICATION_SERVICE(# #);
  struct_tagSOLE_AUTHENTICATION_SERVICE: DATA
    (# dwAuthnSvc: @int32u (* DWORD *);
       dwAuthzSvc: @int32u (* DWORD *);
       pPrincipalName: ^wcharHolder (* OLECHAR *);
       hr: @int32 (* HRESULT *);
    #);
  EOLE_AUTHENTICATION_CAPABILITIES: IntegerObject(# (* enum tagEOLE_AUTHENTICATION_CAPABILITIES *) #);
  EOAC_NONE: (* EOLE_AUTHENTICATION_CAPABILITIES *)(# exit 0x0 #);
  EOAC_MUTUAL_AUTH: (* EOLE_AUTHENTICATION_CAPABILITIES *)(# exit 0x1 #);
  EOAC_CLOAKING: (* EOLE_AUTHENTICATION_CAPABILITIES *)(# exit 0x10 #);
  EOAC_SECURE_REFS: (* EOLE_AUTHENTICATION_CAPABILITIES *)(# exit 0x2 #);
  EOAC_ACCESS_CONTROL: (* EOLE_AUTHENTICATION_CAPABILITIES *)(# exit 0x4 #);
  EOAC_APPID: (* EOLE_AUTHENTICATION_CAPABILITIES *)(# exit 0x8 #);


  IServerSecurity_IID: (# exit '0000013E-0000-0000-C000-000000000046' #);

  IServerSecurity: IUnknown
    (# <<SLOT IServerSecurityLib: attributes>>;
       QueryBlanket:<
         (# result: @int32 (* HRESULT *);
            pAuthnSvc: ^int32uHolder (* *DWORD *); 
            pAuthzSvc: ^int32uHolder (* *DWORD *); 
            pServerPrincName: ^wcharHolder (* **OLECHAR *); 
            pAuthnLevel: ^int32uHolder (* *DWORD *); 
            pImpLevel: ^int32uHolder (* *DWORD *); 
            pPrivs: @int32 (* void** *); 
            pCapabilities: ^int32uHolder (* *DWORD *); 
         enter (pAuthnSvc[], pAuthzSvc[], pServerPrincName[], pAuthnLevel[], pImpLevel[], pPrivs, pCapabilities[])
         exit result
         #);
       ImpersonateClient:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       RevertToSelf:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       IsImpersonating:<
         (# result: @int32 (* BOOL *);
         exit result
         #);
    #);

  IClassActivator_IID: (# exit '00000140-0000-0000-C000-000000000046' #);

  IClassActivator: IUnknown
    (# <<SLOT IClassActivatorLib: attributes>>;
       GetClassObject:<
         (# result: @int32 (* HRESULT *);
            rclsid: @int32 (* REFCLSID *); 
            dwClassContext: @int32u (* DWORD *); 
            locale: @int32u (* LCID *); 
            riid: @int32 (* REFIID *); 
            ppv: @int32 (* void** *); 
         enter (rclsid, dwClassContext, locale, riid, ppv)
         exit result
         #);
    #);

  IRpcOptions_IID: (# exit '00000144-0000-0000-C000-000000000046' #);

  IRpcOptions: IUnknown
    (# <<SLOT IRpcOptionsLib: attributes>>;
       Set:<
         (# result: @int32 (* HRESULT *);
            pPrx: ^IUnknown (* *IUnknown *); 
            dwProperty: @int32u (* DWORD *); 
            dwValue: @int32u (* DWORD *); 
         enter (pPrx[], dwProperty, dwValue)
         exit result
         #);
       Query:<
         (# result: @int32 (* HRESULT *);
            pPrx: ^IUnknown (* *IUnknown *); 
            dwProperty: @int32u (* DWORD *); 
            pdwValue: ^int32uHolder (* *DWORD *); 
         enter (pPrx[], dwProperty, pdwValue[])
         exit result
         #);
       CopyProxy:<
         (# result: @int32 (* HRESULT *);
            punkProxy: ^IUnknown (* *IUnknown *); 
            ppunkCopy: ^IUnknownHolder (* **IUnknown *); 
         enter (punkProxy[], ppunkCopy[])
         exit result
         #);
    #);
  COMBND_RPCSTRINGS: (# exit 0x01 #);


  IComBinding_IID: (# exit '00000148-0000-0000-C000-000000000046' #);

  IComBinding: IUnknown
    (# <<SLOT IComBindingLib: attributes>>;
       InitBinding:<
         (# result: @int32 (* HRESULT *);
            dwEndpointFlags: @int32u (* DWORD *); 
            dwNICFlags: @int32u (* DWORD *); 
            mbzReserved1: @int32u (* DWORD *); 
            mbzReserved2: @int32u (* DWORD *); 
            pszBinding: [0]@char (* ^text NYI *) (* LPOLESTR *); 
         enter (dwEndpointFlags, dwNICFlags, mbzReserved1, mbzReserved2, pszBinding)
         exit result
         #);
       QueryBinding:<
         (# result: @int32 (* HRESULT *);
            pdwEndpointFlags: ^int32uHolder (* LPDWORD *); 
            pdwNICFlags: ^int32uHolder (* LPDWORD *); 
            mbzReserved1: ^int32uHolder (* LPDWORD *); 
            mbzReserved2: ^int32uHolder (* LPDWORD *); 
            ppszBinding: ^textHolder (* *LPOLESTR *); 
         enter (pdwEndpointFlags[], pdwNICFlags[], mbzReserved1[], mbzReserved2[], ppszBinding[])
         exit result
         #);
    #);
  (* #endif //DCOM *)

  IFillLockBytes_IID: (# exit '99caf010-415e-11cf-8814-00aa00b569f5' #);

  IFillLockBytes: IUnknown
    (# <<SLOT IFillLockBytesLib: attributes>>;
       FillAppend:<
         (# result: @int32 (* HRESULT *);
            pv: @int32 (* void* *); 
            cb: @int32u (* ULONG *); 
            pcbWritten: ^int32uHolder (* *ULONG *); 
         enter (pv, cb, pcbWritten[])
         exit result
         #);
       RemoteFillAppend:<
         (# result: @int32 (* HRESULT *);
            pv: ^int8uHolder (* *byte *); 
            cb: @int32u (* ULONG *); 
            pcbWritten: ^int32uHolder (* *ULONG *); 
         enter (pv[], cb, pcbWritten[])
         (* __stdcall *)
         exit result
         #);
       FillAt:<
         (# result: @int32 (* HRESULT *);
            ulOffset: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
            pv: @int32 (* void* *); 
            cb: @int32u (* ULONG *); 
            pcbWritten: ^int32uHolder (* *ULONG *); 
         enter (ulOffset, pv, cb, pcbWritten[])
         exit result
         #);
       RemoteFillAt:<
         (# result: @int32 (* HRESULT *);
            ulOffset: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
            pv: ^int8uHolder (* *byte *); 
            cb: @int32u (* ULONG *); 
            pcbWritten: ^int32uHolder (* *ULONG *); 
         enter (ulOffset, pv[], cb, pcbWritten[])
         (* __stdcall *)
         exit result
         #);
       SetFillSize:<
         (# result: @int32 (* HRESULT *);
            ulSize: @struct__ULARGE_INTEGER (* ULARGE_INTEGER *); 
         enter ulSize
         exit result
         #);
       Terminate:<
         (# result: @int32 (* HRESULT *);
            bCanceled: @int32 (* BOOL *); 
         enter bCanceled
         exit result
         #);
    #);

  IProgressNotify_IID: (# exit 'a9d758a0-4617-11cf-95fc-00aa00680db4' #);

  IProgressNotify: IUnknown
    (# <<SLOT IProgressNotifyLib: attributes>>;
       OnProgress:<
         (# result: @int32 (* HRESULT *);
            dwProgressCurrent: @int32u (* DWORD *); 
            dwProgressMaximum: @int32u (* DWORD *); 
            fAccurate: @int32 (* BOOL *); 
            fOwner: @int32 (* BOOL *); 
         enter (dwProgressCurrent, dwProgressMaximum, fAccurate, fOwner)
         exit result
         #);
    #);

  ILayoutStorage_IID: (# exit '0e6d4d90-6738-11cf-9608-00aa00680db4' #);

  ILayoutStorage: IUnknown
    (# <<SLOT ILayoutStorageLib: attributes>>;
       LayoutScript:<
         (# result: @int32 (* HRESULT *);
            pStorageLayout: ^struct_tagStorageLayout (* *StorageLayout *); 
            nEntries: @int32u (* DWORD *); 
            glfInterleavedFlag: @int32u (* DWORD *); 
         enter (pStorageLayout[], nEntries, glfInterleavedFlag)
         (* __stdcall *)
         exit result
         #);
       BeginMonitor:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         (* __stdcall *)
         exit result
         #);
       EndMonitor:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         (* __stdcall *)
         exit result
         #);
       ReLayoutDocfile:<
         (# result: @int32 (* HRESULT *);
            pwcsNewDfName: ^wcharHolder (* *OLECHAR *); 
         enter pwcsNewDfName[]
         (* __stdcall *)
         exit result
         #);
       ReLayoutDocfileOnILockBytes:<
         (# result: @int32 (* HRESULT *);
            pILockBytes: ^ILockBytes (* *ILockBytes *); 
         enter pILockBytes[]
         (* __stdcall *)
         exit result
         #);
    #);
  StorageLayout: struct_tagStorageLayout(# #);
  struct_tagStorageLayout: DATA
    (# LayoutType: @int32u (* DWORD *);
       pwcsElementName: ^wcharHolder (* OLECHAR *);
       cOffset: @struct__LARGE_INTEGER (* LARGE_INTEGER *);
       cBytes: @struct__LARGE_INTEGER (* LARGE_INTEGER *);
    #);

  ISurrogate_IID: (# exit '00000022-0000-0000-C000-000000000046' #);

  ISurrogate: IUnknown
    (# <<SLOT ISurrogateLib: attributes>>;
       version: (# exit 1.0 #);
       LoadDllServer:<
         (# result: @int32 (* HRESULT *);
            _Clsid: @int32 (* REFCLSID *); 
         enter _Clsid
         exit result
         #);
       FreeSurrogate:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
    #);

  IGlobalInterfaceTable_IID: (# exit '00000146-0000-0000-C000-000000000046' #);

  IGlobalInterfaceTable: IUnknown
    (# <<SLOT IGlobalInterfaceTableLib: attributes>>;
       RegisterInterfaceInGlobal:<
         (# result: @int32 (* HRESULT *);
            pUnk: ^IUnknown (* *IUnknown *); 
            riid: @int32 (* REFIID *); 
            pdwCookie: ^int32uHolder (* *DWORD *); 
         enter (pUnk[], riid, pdwCookie[])
         exit result
         #);
       RevokeInterfaceFromGlobal:<
         (# result: @int32 (* HRESULT *);
            dwCookie: @int32u (* DWORD *); 
         enter dwCookie
         exit result
         #);
       GetInterfaceFromGlobal:<
         (# result: @int32 (* HRESULT *);
            dwCookie: @int32u (* DWORD *); 
            riid: @int32 (* REFIID *); 
            ppv: @int32 (* void** *); 
         enter (dwCookie, riid, ppv)
         exit result
         #);
    #);

  IDirectWriterLock_IID: (# exit '0e6d4d92-6738-11cf-9608-00aa00680db4' #);

  IDirectWriterLock: IUnknown
    (# <<SLOT IDirectWriterLockLib: attributes>>;
       WaitForWriteAccess:<
         (# result: @int32 (* HRESULT *);
            dwTimeout: @int32u (* DWORD *); 
         enter dwTimeout
         exit result
         #);
       ReleaseWriteAccess:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       HaveWriteAccess:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
    #);

  ISynchronize_IID: (# exit '00000023-0000-0000-C000-000000000046' #);

  ISynchronize: IUnknown
    (# <<SLOT ISynchronizeLib: attributes>>;
       Wait:<
         (# result: @int32 (* HRESULT *);
            dwMilliseconds: @int32u (* DWORD *); 
         enter dwMilliseconds
         exit result
         #);
       Signal:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       Reset:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
    #);

  ISynchronizeMutex_IID: (# exit '00000025-0000-0000-C000-000000000046' #);

  ISynchronizeMutex: ISynchronize
    (# <<SLOT ISynchronizeMutexLib: attributes>>;
       ReleaseMutex:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
    #);

  IAsyncSetup_IID: (# exit '00000024-0000-0000-C000-000000000046' #);

  IAsyncSetup: IUnknown
    (# <<SLOT IAsyncSetupLib: attributes>>;
       GetAsyncManager:<
         (# result: @int32 (* HRESULT *);
            riid: @int32 (* REFIID *); 
            pOuter: ^IUnknown (* *IUnknown *); 
            dwFlags: @int32u (* DWORD *); 
            ppInner: ^IUnknownHolder (* **IUnknown *); 
            ppAsyncMgr: ^IAsyncManagerHolder (* **IAsyncManager *); 
         enter (riid, pOuter[], dwFlags, ppInner[], ppAsyncMgr[])
         exit result
         #);
    #);

  ICancelMethodCalls_IID: (# exit '00000029-0000-0000-C000-000000000046' #);

  ICancelMethodCalls: IUnknown
    (# <<SLOT ICancelMethodCallsLib: attributes>>;
       Cancel:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         exit result
         #);
       TestCancel:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         exit result
         #);
       SetCancelTimeout:<
         (# result: @int32 (* HRESULT *);
            ulSeconds: @int32u (* ULONG *); 
         enter ulSeconds
         exit result
         #);
    #);

  IAsyncManager_IID: (# exit '0000002A-0000-0000-C000-000000000046' #);

  IAsyncManager: IUnknown
    (# <<SLOT IAsyncManagerLib: attributes>>;
       CompleteCall:<
         (# result: @int32 (* HRESULT *);
            _Result: @int32 (* HRESULT *); 
         enter _Result
         exit result
         #);
       GetCallContext:<
         (# result: @int32 (* HRESULT *);
            riid: @int32 (* REFIID *); 
            pInterface: @int32 (* void** *); 
         enter (riid, pInterface)
         exit result
         #);
       GetState:<
         (# result: @int32 (* HRESULT *);
            pulStateFlags: ^int32uHolder (* *ULONG *); 
         enter pulStateFlags[]
         exit result
         #);
    #);
  DCOM_CALL_STATE: IntegerObject(# (* enum tagDCOM_CALL_STATE *) #);
  DCOM_NONE: (* DCOM_CALL_STATE *)(# exit 0x0 #);
  DCOM_CALL_COMPLETE: (* DCOM_CALL_STATE *)(# exit 0x1 #);
  DCOM_CALL_CANCELED: (* DCOM_CALL_STATE *)(# exit 0x2 #);


  IWaitMultiple_IID: (# exit '0000002B-0000-0000-C000-000000000046' #);

  IWaitMultiple: IUnknown
    (# <<SLOT IWaitMultipleLib: attributes>>;
       WaitMultiple:<
         (# result: @int32 (* HRESULT *);
            timeout: @int32u (* DWORD *); 
            pSync: ^ISynchronizeHolder (* **ISynchronize *); 
         enter (timeout, pSync[])
         exit result
         #);
       AddSynchronize:<
         (# result: @int32 (* HRESULT *);
            pSync: ^ISynchronize (* *ISynchronize *); 
         enter pSync[]
         exit result
         #);
    #);

  ISynchronizeEvent_IID: (# exit '0000002C-0000-0000-C000-000000000046' #);

  ISynchronizeEvent: IUnknown
    (# <<SLOT ISynchronizeEventLib: attributes>>;
       GetEvent:<
         (# result: @int32 (* HRESULT *);
            pEvent: ^int32Holder (* *HANDLE *); 
         enter pEvent[]
         exit result
         #);
    #);

  IUrlMon_IID: (# exit '00000026-0000-0000-C000-000000000046' #);

  IUrlMon: IUnknown
    (# <<SLOT IUrlMonLib: attributes>>;
       AsyncGetClassBits:<
         (# result: @int32 (* HRESULT *);
            rclsid: @int32 (* REFCLSID *); 
            pszTYPE: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            pszExt: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            dwFileVersionMS: @int32u (* DWORD *); 
            dwFileVersionLS: @int32u (* DWORD *); 
            pszCodeBase: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            pbc: ^IBindCtx (* *IBindCtx *); 
            dwClassContext: @int32u (* DWORD *); 
            riid: @int32 (* REFIID *); 
            flags: @int32u (* DWORD *); 
         enter (rclsid, pszTYPE, pszExt, dwFileVersionMS, dwFileVersionLS, pszCodeBase, pbc[], dwClassContext, riid, flags)
         exit result
         #);
    #);

  IClassAccess_IID: (# exit '00000190-0000-0000-C000-000000000046' #);

  IClassAccess: IUnknown
    (# <<SLOT IClassAccessLib: attributes>>;
       GetClassInfo:<
         (# result: @int32 (* HRESULT *);
            _clsid: @int32 (* REFCLSID *); 
            QryContext: @struct_tagQUERYCONTEXT (* QUERYCONTEXT *); 
            pPackageInfo: ^struct_tagPACKAGEINFO (* *PACKAGEINFO *); 
         enter (_clsid, QryContext, pPackageInfo[])
         exit result
         #);
       GetClassSpecInfo:<
         (# result: @int32 (* HRESULT *);
            pClassSpec: ^uCLSSPEC (* *uCLSSPEC *); 
            QryContext: @struct_tagQUERYCONTEXT (* QUERYCONTEXT *); 
            pPackageInfo: ^struct_tagPACKAGEINFO (* *PACKAGEINFO *); 
         enter (pClassSpec[], QryContext, pPackageInfo[])
         exit result
         #);
       GetInstallablePackages:<
         (# result: @int32 (* HRESULT *);
            Count: @int32u (* DWORD *); 
            pInfoList: ^struct_tagPUBLISHEDINFOLIST (* *PUBLISHEDINFOLIST *); 
         enter (Count, pInfoList[])
         exit result
         #);
    #);
  PUBLISHEDINFOLIST: struct_tagPUBLISHEDINFOLIST(# #);
  struct_tagPUBLISHEDINFOLIST: DATA
    (# cPublApps: @int32u (* DWORD *);
       pPublAppInfo: ^struct__PUBLISHEDAPPINFO (* PUBLISHEDAPPINFO *);
    #);

  IClassRefresh_IID: (# exit '00000192-0000-0000-C000-000000000046' #);

  IClassRefresh: IUnknown
    (# <<SLOT IClassRefreshLib: attributes>>;
       GetUpgrades:<
         (# result: @int32 (* HRESULT *);
            cClasses: @int32u (* ULONG *); 
            pClassList: ^CLSIDHolder (* *CLSID *); 
            Platform: @struct_tagCSPLATFORM (* CSPLATFORM *); 
            Locale: @int32u (* LCID *); 
            pPackageInfoList: ^struct_tagPACKAGEINFOLIST (* *PACKAGEINFOLIST *); 
         enter (cClasses, pClassList[], Platform, Locale, pPackageInfoList[])
         exit result
         #);
       CommitUpgrades:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
    #);
  PACKAGEINFOLIST: struct_tagPACKAGEINFOLIST(# #);
  struct_tagPACKAGEINFOLIST: DATA
    (# cPackInfo: @int32u (* DWORD *);
       pPackageInfo: ^struct_tagPACKAGEINFO (* PACKAGEINFO *);
    #);
  CLASSDETAIL: struct_tagCLASSDETAIL(# #);
  struct_tagCLASSDETAIL: DATA
    (# _Clsid: @CLSID (* CLSID *);
       pszDesc: @wcharHolder (* *LPOLESTR *);
       pszIconPath: @wcharHolder (* *LPOLESTR *);
       TreatAsClsid: @CLSID (* CLSID *);
       AutoConvertClsid: @CLSID (* CLSID *);
       cFileExt: @int32u (* DWORD *);
       prgFileExt: ^wcharHolder (* *LPOLESTR *);
       pMimeType: @wcharHolder (* *LPOLESTR *);
       pDefaultProgId: @wcharHolder (* *LPOLESTR *);
       cOtherProgId: @int32u (* DWORD *);
       prgOtherProgId: ^wcharHolder (* *LPOLESTR *);
    #);
  (* #ifndef _LPCSADMNENUM_DEFINED *)
  (* #define _LPCSADMNENUM_DEFINED *)

  IEnumPackage_IID: (# exit '00000193-0000-0000-C000-000000000046' #);

  IEnumPackage: IUnknown
    (# <<SLOT IEnumPackageLib: attributes>>;
       Next:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^struct_tagPACKAGEDETAIL (* *PACKAGEDETAIL *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       Skip:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
         enter celt
         exit result
         #);
       Reset:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       Clone:<
         (# result: @int32 (* HRESULT *);
            ppenum: ^IEnumPackageHolder (* **IEnumPackage *); 
         enter ppenum[]
         exit result
         #);
    #);

  IEnumClass_IID: (# exit '00000194-0000-0000-C000-000000000046' #);

  IEnumClass: IUnknown
    (# <<SLOT IEnumClassLib: attributes>>;
       Next:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^struct_tagCLASSDETAIL (* *CLASSDETAIL *); 
            pceltFetched: ^int32uHolder (* *ULONG *); 
         enter (celt, rgelt[], pceltFetched[])
         exit result
         #);
       Skip:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
         enter celt
         exit result
         #);
       Reset:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       Clone:<
         (# result: @int32 (* HRESULT *);
            ppenum: ^IEnumClassHolder (* **IEnumClass *); 
         enter ppenum[]
         exit result
         #);
    #);
  (* #endif *)

  IClassAdmin_IID: (# exit '00000191-0000-0000-C000-000000000046' #);

  IClassAdmin: IUnknown
    (# <<SLOT IClassAdminLib: attributes>>;
       NewClass:<
         (# result: @int32 (* HRESULT *);
            pClassDetail: ^struct_tagCLASSDETAIL (* *CLASSDETAIL *); 
         enter pClassDetail[]
         exit result
         #);
       DeleteClass:<
         (# result: @int32 (* HRESULT *);
            guidClsId: @int32 (* REFCLSID *); 
         enter guidClsId
         exit result
         #);
       NewInterface:<
         (# result: @int32 (* HRESULT *);
            _iid: @int32 (* REFIID *); 
            pszDesc: [0]@char (* ^text NYI *) (* LPOLESTR *); 
            psclsid: @int32 (* REFCLSID *); 
            typelibid: @int32 (* REFCLSID *); 
         enter (_iid, pszDesc, psclsid, typelibid)
         exit result
         #);
       DeleteInterface:<
         (# result: @int32 (* HRESULT *);
            _iid: @int32 (* REFIID *); 
         enter _iid
         exit result
         #);
       NewPackage:<
         (# result: @int32 (* HRESULT *);
            pPackageDetail: ^struct_tagPACKAGEDETAIL (* *PACKAGEDETAIL *); 
         enter pPackageDetail[]
         exit result
         #);
       DeletePackage:<
         (# result: @int32 (* HRESULT *);
            pszPackageName: [0]@char (* ^text NYI *) (* LPOLESTR *); 
         enter pszPackageName
         exit result
         #);
       GetClassesEnum:<
         (# result: @int32 (* HRESULT *);
            ppIEnumClass: ^IEnumClassHolder (* **IEnumClass *); 
         enter ppIEnumClass[]
         exit result
         #);
       GetPackagesEnum:<
         (# result: @int32 (* HRESULT *);
            guidClsid: @int32 (* REFCLSID *); 
            pszVendor: [0]@char (* ^text NYI *) (* LPOLESTR *); 
            Platform: @struct_tagCSPLATFORM (* CSPLATFORM *); 
            dwContext: @int32u (* DWORD *); 
            Locale: @int32u (* LCID *); 
            ppIEnumPackage: ^IEnumPackageHolder (* **IEnumPackage *); 
         enter (guidClsid, pszVendor, Platform, dwContext, Locale, ppIEnumPackage[])
         exit result
         #);
       GetClassDetails:<
         (# result: @int32 (* HRESULT *);
            guidClsId: @int32 (* REFCLSID *); 
            pClassDetail: ^struct_tagCLASSDETAIL (* *CLASSDETAIL *); 
         enter (guidClsId, pClassDetail[])
         exit result
         #);
       GetIidDetails:<
         (# result: @int32 (* HRESULT *);
            _iid: @int32 (* REFIID *); 
            ppszDesc: ^textHolder (* *LPOLESTR *); 
            psClsid: ^CLSIDHolder (* *CLSID *); 
            pTypeLibId: ^CLSIDHolder (* *CLSID *); 
         enter (_iid, ppszDesc[], psClsid[], pTypeLibId[])
         exit result
         #);
       GetPackageDetails:<
         (# result: @int32 (* HRESULT *);
            pszPackageName: [0]@char (* ^text NYI *) (* LPOLESTR *); 
            pPackageDetail: ^struct_tagPACKAGEDETAIL (* *PACKAGEDETAIL *); 
         enter (pszPackageName, pPackageDetail[])
         exit result
         #);
    #);
  (* #if ( _MSC_VER >= 800 ) *)
  (* #endif *)

  (* Holders *)

  COSERVERINFOHolder: Holder
    (# value: @COSERVERINFO; #);
  struct__COSERVERINFOHolder: Holder
    (# value: @struct__COSERVERINFO; #);
  COSERVERINFO2Holder: Holder
    (# value: @COSERVERINFO2; #);
  struct__COSERVERINFO2Holder: Holder
    (# value: @struct__COSERVERINFO2; #);
  MULTI_QIHolder: Holder
    (# value: @MULTI_QI; #);
  struct_tagMULTI_QIHolder: Holder
    (# value: @struct_tagMULTI_QI; #);
  BIND_OPTSHolder: Holder
    (# value: @BIND_OPTS; #);
  struct_tagBIND_OPTSHolder: Holder
    (# value: @struct_tagBIND_OPTS; #);
  BIND_OPTS2Holder: Holder
    (# value: @BIND_OPTS2; #);
  struct_tagBIND_OPTS2Holder: Holder
    (# value: @struct_tagBIND_OPTS2; #);
  STATSTGHolder: Holder
    (# value: @STATSTG; #);
  struct_tagSTATSTGHolder: Holder
    (# value: @struct_tagSTATSTG; #);
  RemSNBHolder: Holder
    (# value: @RemSNB; #);
  struct_tagRemSNBHolder: Holder
    (# value: @struct_tagRemSNB; #);
  DVTARGETDEVICEHolder: Holder
    (# value: @DVTARGETDEVICE; #);
  struct_tagDVTARGETDEVICEHolder: Holder
    (# value: @struct_tagDVTARGETDEVICE; #);
  FORMATETCHolder: Holder
    (# value: @FORMATETC; #);
  struct_tagFORMATETCHolder: Holder
    (# value: @struct_tagFORMATETC; #);
  STATDATAHolder: Holder
    (# value: @STATDATA; #);
  struct_tagSTATDATAHolder: Holder
    (# value: @struct_tagSTATDATA; #);
  RemSTGMEDIUMHolder: Holder
    (# value: @RemSTGMEDIUM; #);
  struct_tagRemSTGMEDIUMHolder: Holder
    (# value: @struct_tagRemSTGMEDIUM; #);
  uSTGMEDIUMHolder: Holder
    (# value: @uSTGMEDIUM; #);
  struct_tagSTGMEDIUMHolder: Holder
    (# value: @struct_tagSTGMEDIUM; #);
  GDI_OBJECTHolder: Holder
    (# value: @GDI_OBJECT; #);
  union__GDI_OBJECTHolder: Holder
    (# value: @union__GDI_OBJECT; #);
  userSTGMEDIUMHolder: Holder
    (# value: @userSTGMEDIUM; #);
  struct__userSTGMEDIUMHolder: Holder
    (# value: @struct__userSTGMEDIUM; #);
  userFLAG_STGMEDIUMHolder: Holder
    (# value: @userFLAG_STGMEDIUM; #);
  struct__userFLAG_STGMEDIUMHolder: Holder
    (# value: @struct__userFLAG_STGMEDIUM; #);
  FLAG_STGMEDIUMHolder: Holder
    (# value: @FLAG_STGMEDIUM; #);
  struct__FLAG_STGMEDIUMHolder: Holder
    (# value: @struct__FLAG_STGMEDIUM; #);
  INTERFACEINFOHolder: Holder
    (# value: @INTERFACEINFO; #);
  struct_tagINTERFACEINFOHolder: Holder
    (# value: @struct_tagINTERFACEINFO; #);
  RPCOLEMESSAGEHolder: Holder
    (# value: @RPCOLEMESSAGE; #);
  struct_tagRPCOLEMESSAGEHolder: Holder
    (# value: @struct_tagRPCOLEMESSAGE; #);
  SChannelHookCallInfoHolder: Holder
    (# value: @SChannelHookCallInfo; #);
  struct_SChannelHookCallInfoHolder: Holder
    (# value: @struct_SChannelHookCallInfo; #);
  PROPVARIANTHolder: Holder
    (# value: @PROPVARIANT; #);
  struct_tagPROPVARIANTHolder: Holder
    (# value: @struct_tagPROPVARIANT; #);
  CAUBHolder: Holder
    (# value: @CAUB; #);
  struct_tagCAUBHolder: Holder
    (# value: @struct_tagCAUB; #);
  CAIHolder: Holder
    (# value: @CAI; #);
  struct_tagCAIHolder: Holder
    (# value: @struct_tagCAI; #);
  CAUIHolder: Holder
    (# value: @CAUI; #);
  struct_tagCAUIHolder: Holder
    (# value: @struct_tagCAUI; #);
  CALHolder: Holder
    (# value: @CAL; #);
  struct_tagCALHolder: Holder
    (# value: @struct_tagCAL; #);
  CAULHolder: Holder
    (# value: @CAUL; #);
  struct_tagCAULHolder: Holder
    (# value: @struct_tagCAUL; #);
  CAFLTHolder: Holder
    (# value: @CAFLT; #);
  struct_tagCAFLTHolder: Holder
    (# value: @struct_tagCAFLT; #);
  CADBLHolder: Holder
    (# value: @CADBL; #);
  struct_tagCADBLHolder: Holder
    (# value: @struct_tagCADBL; #);
  CACYHolder: Holder
    (# value: @CACY; #);
  struct_tagCACYHolder: Holder
    (# value: @struct_tagCACY; #);
  CADATEHolder: Holder
    (# value: @CADATE; #);
  struct_tagCADATEHolder: Holder
    (# value: @struct_tagCADATE; #);
  CABSTRHolder: Holder
    (# value: @CABSTR; #);
  struct_tagCABSTRHolder: Holder
    (# value: @struct_tagCABSTR; #);
  CABSTRBLOBHolder: Holder
    (# value: @CABSTRBLOB; #);
  struct_tagCABSTRBLOBHolder: Holder
    (# value: @struct_tagCABSTRBLOB; #);
  CABOOLHolder: Holder
    (# value: @CABOOL; #);
  struct_tagCABOOLHolder: Holder
    (# value: @struct_tagCABOOL; #);
  CASCODEHolder: Holder
    (# value: @CASCODE; #);
  struct_tagCASCODEHolder: Holder
    (# value: @struct_tagCASCODE; #);
  CAPROPVARIANTHolder: Holder
    (# value: @CAPROPVARIANT; #);
  struct_tagCAPROPVARIANTHolder: Holder
    (# value: @struct_tagCAPROPVARIANT; #);
  CAHHolder: Holder
    (# value: @CAH; #);
  struct_tagCAHHolder: Holder
    (# value: @struct_tagCAH; #);
  CAUHHolder: Holder
    (# value: @CAUH; #);
  struct_tagCAUHHolder: Holder
    (# value: @struct_tagCAUH; #);
  CALPSTRHolder: Holder
    (# value: @CALPSTR; #);
  struct_tagCALPSTRHolder: Holder
    (# value: @struct_tagCALPSTR; #);
  CALPWSTRHolder: Holder
    (# value: @CALPWSTR; #);
  struct_tagCALPWSTRHolder: Holder
    (# value: @struct_tagCALPWSTR; #);
  CAFILETIMEHolder: Holder
    (# value: @CAFILETIME; #);
  struct_tagCAFILETIMEHolder: Holder
    (# value: @struct_tagCAFILETIME; #);
  CACLIPDATAHolder: Holder
    (# value: @CACLIPDATA; #);
  struct_tagCACLIPDATAHolder: Holder
    (# value: @struct_tagCACLIPDATA; #);
  CACLSIDHolder: Holder
    (# value: @CACLSID; #);
  struct_tagCACLSIDHolder: Holder
    (# value: @struct_tagCACLSID; #);
  PROPSPECHolder: Holder
    (# value: @PROPSPEC; #);
  struct_tagPROPSPECHolder: Holder
    (# value: @struct_tagPROPSPEC; #);
  STATPROPSTGHolder: Holder
    (# value: @STATPROPSTG; #);
  struct_tagSTATPROPSTGHolder: Holder
    (# value: @struct_tagSTATPROPSTG; #);
  STATPROPSETSTGHolder: Holder
    (# value: @STATPROPSETSTG; #);
  struct_tagSTATPROPSETSTGHolder: Holder
    (# value: @struct_tagSTATPROPSETSTG; #);
  SOLE_AUTHENTICATION_SERVICEHolder: Holder
    (# value: @SOLE_AUTHENTICATION_SERVICE; #);
  struct_tagSOLE_AUTHENTICATION_SERVICEHolder: Holder
    (# value: @struct_tagSOLE_AUTHENTICATION_SERVICE; #);
  StorageLayoutHolder: Holder
    (# value: @StorageLayout; #);
  struct_tagStorageLayoutHolder: Holder
    (# value: @struct_tagStorageLayout; #);
  PUBLISHEDINFOLISTHolder: Holder
    (# value: @PUBLISHEDINFOLIST; #);
  struct_tagPUBLISHEDINFOLISTHolder: Holder
    (# value: @struct_tagPUBLISHEDINFOLIST; #);
  PACKAGEINFOLISTHolder: Holder
    (# value: @PACKAGEINFOLIST; #);
  struct_tagPACKAGEINFOLISTHolder: Holder
    (# value: @struct_tagPACKAGEINFOLIST; #);
  CLASSDETAILHolder: Holder
    (# value: @CLASSDETAIL; #);
  struct_tagCLASSDETAILHolder: Holder
    (# value: @struct_tagCLASSDETAIL; #);


  (* Reference Holders *)

  IMarshalHolder: refHolder
    (# type:: IMarshal #);
  IMallocHolder: refHolder
    (# type:: IMalloc #);
  IMallocSpyHolder: refHolder
    (# type:: IMallocSpy #);
  IStdMarshalInfoHolder: refHolder
    (# type:: IStdMarshalInfo #);
  IExternalConnectionHolder: refHolder
    (# type:: IExternalConnection #);
  IMultiQIHolder: refHolder
    (# type:: IMultiQI #);
  IEnumUnknownHolder: refHolder
    (# type:: IEnumUnknown #);
  IBindCtxHolder: refHolder
    (# type:: IBindCtx #);
  IEnumMonikerHolder: refHolder
    (# type:: IEnumMoniker #);
  IRunnableObjectHolder: refHolder
    (# type:: IRunnableObject #);
  IRunningObjectTableHolder: refHolder
    (# type:: IRunningObjectTable #);
  IPersistHolder: refHolder
    (# type:: IPersist #);
  IPersistStreamHolder: refHolder
    (# type:: IPersistStream #);
  IMonikerHolder: refHolder
    (# type:: IMoniker #);
  IROTDataHolder: refHolder
    (# type:: IROTData #);
  IEnumStringHolder: refHolder
    (# type:: IEnumString #);
  ISequentialStreamHolder: refHolder
    (# type:: ISequentialStream #);
  IStreamHolder: refHolder
    (# type:: IStream #);
  IEnumSTATSTGHolder: refHolder
    (# type:: IEnumSTATSTG #);
  IStorageHolder: refHolder
    (# type:: IStorage #);
  IPersistFileHolder: refHolder
    (# type:: IPersistFile #);
  IPersistStorageHolder: refHolder
    (# type:: IPersistStorage #);
  ILockBytesHolder: refHolder
    (# type:: ILockBytes #);
  IEnumFORMATETCHolder: refHolder
    (# type:: IEnumFORMATETC #);
  IEnumSTATDATAHolder: refHolder
    (# type:: IEnumSTATDATA #);
  IRootStorageHolder: refHolder
    (# type:: IRootStorage #);
  IAdviseSinkHolder: refHolder
    (# type:: IAdviseSink #);
  IAdviseSink2Holder: refHolder
    (# type:: IAdviseSink2 #);
  IDataObjectHolder: refHolder
    (# type:: IDataObject #);
  IDataAdviseHolderHolder: refHolder
    (# type:: IDataAdviseHolder #);
  IMessageFilterHolder: refHolder
    (# type:: IMessageFilter #);
  IRpcChannelBufferHolder: refHolder
    (# type:: IRpcChannelBuffer #);
  IRpcChannelBuffer2Holder: refHolder
    (# type:: IRpcChannelBuffer2 #);
  IRpcChannelBuffer3Holder: refHolder
    (# type:: IRpcChannelBuffer3 #);
  IRpcProxyBufferHolder: refHolder
    (# type:: IRpcProxyBuffer #);
  IRpcStubBufferHolder: refHolder
    (# type:: IRpcStubBuffer #);
  IPSFactoryBufferHolder: refHolder
    (# type:: IPSFactoryBuffer #);
  IChannelHookHolder: refHolder
    (# type:: IChannelHook #);
  IPropertyStorageHolder: refHolder
    (# type:: IPropertyStorage #);
  IPropertySetStorageHolder: refHolder
    (# type:: IPropertySetStorage #);
  IEnumSTATPROPSTGHolder: refHolder
    (# type:: IEnumSTATPROPSTG #);
  IEnumSTATPROPSETSTGHolder: refHolder
    (# type:: IEnumSTATPROPSETSTG #);
  IClientSecurityHolder: refHolder
    (# type:: IClientSecurity #);
  IServerSecurityHolder: refHolder
    (# type:: IServerSecurity #);
  IClassActivatorHolder: refHolder
    (# type:: IClassActivator #);
  IRpcOptionsHolder: refHolder
    (# type:: IRpcOptions #);
  IComBindingHolder: refHolder
    (# type:: IComBinding #);
  IFillLockBytesHolder: refHolder
    (# type:: IFillLockBytes #);
  IProgressNotifyHolder: refHolder
    (# type:: IProgressNotify #);
  ILayoutStorageHolder: refHolder
    (# type:: ILayoutStorage #);
  ISurrogateHolder: refHolder
    (# type:: ISurrogate #);
  IGlobalInterfaceTableHolder: refHolder
    (# type:: IGlobalInterfaceTable #);
  IDirectWriterLockHolder: refHolder
    (# type:: IDirectWriterLock #);
  ISynchronizeHolder: refHolder
    (# type:: ISynchronize #);
  ISynchronizeMutexHolder: refHolder
    (# type:: ISynchronizeMutex #);
  IAsyncSetupHolder: refHolder
    (# type:: IAsyncSetup #);
  ICancelMethodCallsHolder: refHolder
    (# type:: ICancelMethodCalls #);
  IAsyncManagerHolder: refHolder
    (# type:: IAsyncManager #);
  IWaitMultipleHolder: refHolder
    (# type:: IWaitMultiple #);
  ISynchronizeEventHolder: refHolder
    (# type:: ISynchronizeEvent #);
  IUrlMonHolder: refHolder
    (# type:: IUrlMon #);
  IClassAccessHolder: refHolder
    (# type:: IClassAccess #);
  IClassRefreshHolder: refHolder
    (# type:: IClassRefresh #);
  IEnumPackageHolder: refHolder
    (# type:: IEnumPackage #);
  IEnumClassHolder: refHolder
    (# type:: IEnumClass #);
  IClassAdminHolder: refHolder
    (# type:: IClassAdmin #);

