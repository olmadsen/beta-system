ORIGIN './control';
INCLUDE './idlsematt';
BODY 'const_exp';

--Translate: Descriptor --
(#
   BobsTab: (# exit '~beta/grammars/idl/v2.0/idl-parser.btab' #);
   MaxFragments: (# exit 100 #);
   
   ast: @astInterface
     (* An instance of the AST interface *)
     (# defaultGrammarFinder:: findGrammar #);
   
   idl: @ast.idl; (* The MPS interface to the BETA grammar/ASTs *)
   
   (* Operations needed because exit parameters of getNameAppl,
    * getNameDecl etc are not quilified enough to say gettext etc.
    * on them!
    *)
   NameApplToText: 
     (# na: ^astinterface.NameAppl enter na[]  exit na.getText #);
   NameDeclToText: 
     (# nd: ^astinterface.NameDecl enter nd[]  exit nd.getText #);
   StringToText:   
     (# s: ^astinterface.String    enter s[]   exit s.getText #);
   ConstToInteger:
     (# con: ^astinterface.Const   enter con[] exit con.getValue #);
   ConstToText:
     (# con: ^astinterface.Const   enter con[] exit con.getText #);
   
   optionalPresent: 
     (# opt: ^ast.ast; 
     enter opt[]
     exit opt.kind<>ast.kinds.optional
     #);
   
   ExpandFileName:
     (# Name, ExpandedName: ^text
     enter Name[]
     do (Name[], '') -> ast.thePathHandler.convertFilePath -> ExpandedName[];
     exit ExpandedName[]
     #);
   
   InitAstEnv:
     (* Initialization of the meta programming system *)
     (# 
     do 
	(if Debug then
            (ast.trace.topOpen,true) -> ast.trace.set;
            (ast.trace.fragmentOpen,true) -> ast.trace.set;
            (ast.trace.grammars,true) -> ast.trace.set;
            (ast.trace.compactOpen,true) -> ast.trace.set;
            (ast.trace.onParse,true) -> ast.trace.set;
            (ast.trace.parser,true) -> ast.trace.set;
            (ast.trace.getBinding,true) -> ast.trace.set;
            (ast.trace.getBindingMark,true) -> ast.trace.set;
        if);
	ast; 
        idl.init; 
	BobsTab -> ast.expandToFullPath -> idl.parser.initialize(# EOLasComEnd::(#do true->value#) #);
     #);
   
   IdentifierToText:
     (# i: ^idl.identifier;
     enter i[]
     exit i.getnameAppl -> NameApplToText
     #);
   
   CheckComment:
     (* Stolen from prettyprinter *)
     (# currentSubcomment: ^text;
        n: @integer;
        do_comment:
          (# 
          do (if currentSubcomment[] <> none then
                 (if currentSubcomment.lgth<>0 then
                     currentSubcomment[]->outfile.CommentLine;
                  else
                     (* empty line comment *)
                     outfile.newline;
                 if)
             if)
          #);
        a: ^ast.ast;
     enter a[]
     do a.getNextComment->(currentSubcomment[],n);
        (if n
         // 0 then
            do_comment; 
         // 1 then
            do_comment;
            loop:
              (# 
              do a.getNextComment->(currentSubcomment[],n);
                 do_comment;
                 (if n = 1 then restart loop if);
              #)            
        if);
     #);
   DoFragment:
     (#
	fg: ^ast.fragmentGroup; 
        ff: ^ast.fragmentForm;
	List: [maxfragments]^text; 
        End: @integer; 
        NodeName: ^text;
	
	Insert:
	  (# path, basis: ^text; strippedbasis: @text;
	     i: @integer;
	  enter (path[], basis[])
	  do end+1 -> end;
	     basis -> strippedbasis;
	     ast.thepathhandler.directorychar
	       -> strippedbasis.findall(# do inx -> i #);
	     (i,strippedbasis.length) -> strippedbasis.delete;
	     (path[],strippedbasis[]) -> ast.thePathHandler.convertFilePath 
	       -> List[End][]
	  #);
	
	Target: @text;
	Found: @boolean;
	
     enter NodeName[]
     do
	'Opening '''->puttext; 
	(NodeName[], '') -> ast.thePathhandler.localpath -> puttext; 
	'''...'->putline;
	(NodeName[], screen[]) 
	  -> ast.top.open(# StartingParsing::< (# do '  parsing...'->putline #)#)
	  -> fg[];
	(if fg[]=NONE then
	    'Not able to open: ' -> puttext; 
            NodeName[] -> putText; 
            newLine; 
            Stop
	if);
	
	(if Debug then 'scanincludes: ' -> putline; if);
        fg.scanIncludes
	(# 
        do (if Debug then
               'current.linkname: ' -> puttext; current.linkname[]->putline;
           if);
	   (current.linkname[], fg.FullName) -> Insert;
	#);
	fg.fragmentList.scan
	(# do
	   (if Current.type
	    // ast.groupType then 
               (failure,'Groups not supported.') -> stop
	    // ast.formType then
	       '  translate: ' -> putText; 
               Current.name[] -> putText;
	       Current.f[] -> ff[]; 
               ff.root[] -> do_specification;
	       newLine;
	if) #);
	fg.close;
	(for i: End repeat List[i][] -> DoFragment for);
     #);
      
   do_specification:
     (* Translate the top node of the IDL *)
     (# s: ^idl.specification;
     enter s[]
     do s[] -> CheckComment;
        outfile.newline;
        s.getDefinitions -> do_definitions;
     #);
   
   do_definitions:
     (# d: ^idl.definitions;
     enter d[]
     do d.newscan
	(# 
	do 
	   (if current.symbol
            // idl.def_type_dcl then current[] -> do_def_type_dcl 
            // idl.const_dcl then current[] -> do_const_dcl;
            // idl.except_dcl then current[] -> do_except_dcl;
            // idl.interface_dcl then current[] -> do_interface_dcl;
            // idl.forward_dcl then current[] -> do_forward_dcl;
            // idl.module then current[] -> do_module;
            // idl.definition_error then current[] -> do_definition_error; 
	    else
	       '\nERROR: DoSpecification: illegal current.symbol: ' -> puttext;
	       current.symbol -> putint;
	       newline;
	   if);
	#)
     #);
   
   do_def_type_dcl: 
     (# d: ^idl.def_type_dcl;
     enter d[]
     do outfile.indent;
        'do_def_type_dcl not yet implemented' -> outfile.commentline;
     #);
   
   do_const_dcl: 
     (# c: ^idl.const_dcl;
     enter c[]
     do outfile.indent;
        'do_const_dcl not yet implemented' -> outfile.commentline;
     #);
   
   do_except_dcl: 
     (# e: ^idl.except_dcl;
     enter e[]
     do outfile.indent;
        'do_except_dcl not yet implemented' -> outfile.commentline;
     #);
   
   do_const_exp:
     (# e: ^idl.const_exp;
        <<SLOT const_exp_lib: attributes>>
     enter e[]
     <<SLOT const_exp_body:dopart>>
     #);
   
   do_scoped_name:
     (# n: ^idl.scoped_name;
        s1: ^idl.scoped_name1;
        s2: ^idl.scoped_name2;
        s3: ^idl.scoped_name3;
     enter n[]
     do (if n.symbol
         // idl.scoped_name1 then
            n[] -> s1[];
            s1.getIdentifier -> IdentifierToText 
              -> outfile.puttext;
         // idl.scoped_name2 then
            n[] -> s2[];
            s2.getIdentifier -> IdentifierToText 
              -> outfile.puttext;
         // idl.scoped_name3 then
            n[] -> s3[];
            s3.getscoped_name -> do_scoped_name;
            '.' -> outfile.put;
            s3.getIdentifier -> IdentifierToText 
              -> outfile.puttext;
        if);
     #);
   
   do_interface_dcl:
     (# i: ^idl.interface_dcl;
        do_interface_header:
          (# h: ^idl.interface_header;
             do_inheritance_spec:
               (# i: ^idl.inheritance_spec;
                  n: ^idl.scoped_names;
                  
                  numPrefixes: @integer;
               enter i[]
               do 0->numPrefixes;
                  i.getscoped_names -> n[];
                  n.newscan
                  (# 
                  do (if numPrefixes>0 then
                         'Error: Multiple inheritance_specs not supported!'
                           -> screen.putline;
                         stop;
                      else
                         current[] -> do_scoped_name;
                     if);
                  #)
               #);
             do_interface_attributes:
               (# do_uuid:
                    (# do_uuid_rep:
                         (# r: ^idl.uuid_rep;
                         enter r[]
                         do r.newscan
                            (# k: ^idl.keys;
                               first_done: @boolean;
                            do current[] -> k[];
                               (if first_done then
                                   '-' -> outfile.put;
                                else
                                   true->first_done
                               if);
                               k.newscan
                               (# n: ^idl.namekey;
                                  c: ^idl.constkey;
                               do (if current.symbol
                                   // idl.namekey then
                                      current[] -> n[];
                                      n.getnameappl -> NameApplToText -> outfile.puttext;
                                   // idl.constkey then
                                      current[] -> c[];
                                      c.getconst -> ConstToText -> outfile.puttext;
                                  if)
                               #);
                            #)
                         #);
                       u: ^idl.uuid
                    enter u[]
                    do outfile.indent;
                       outfile.CommentBegin;
                       'uuid: ' -> outfile.puttext;
                       u.getuuid_rep -> do_uuid_rep;
                       outfile.CommentEnd;
                       outfile.newline;
                    #);
                  do_iversion:
                    (# v: ^idl.iversion
                    enter v[]
                    do outfile.indent;
                       'do_iversion NYI' -> outfile.commentline;
                    #);
                  do_endpoint:
                    (# e: ^idl.endpoint
                    enter e[]
                    do outfile.indent;
                       'do_endpoint NYI' -> outfile.commentline;
                    #);
                  do_local:
                    (# l: ^idl.local
                    enter l[]
                    do outfile.indent;
                       'keyword found: \'local\'' -> outfile.commentline;
                    #);
                  do_pointer_default:
                    (# do_ptr_attr:
                         (# p: ^idl.ptr_attr;
                            i: ^idl.iid_is;
                         enter p[]
                         do (if p.symbol
                             // idl.ref then
                                'ref' -> outfile.puttext;
                             // idl.ptr then
                                'ptr' -> outfile.puttext;
                             // idl.unique then
                                'unique' -> outfile.puttext;
                             // idl.iid_is then
                                'iid_is: ' -> outfile.puttext;
                                (p[]->i[]).getIdentifier 
                                  -> IdentifierToText -> outfile.puttext;
                            if);
                         #);
                       p: ^idl.pointer_default
                    enter p[]
                    do outfile.indent;
                       outfile.CommentBegin;
                       'do_pointer_default NYI: ' -> outfile.puttext;
                       p.getptr_attr->do_ptr_attr;
                       outfile.CommentEnd;
                       outfile.newline;
                    #);
                  do_object:
                    (# o: ^idl.object
                    enter o[]
                    do outfile.indent;
                       'keyword found: \'object\'' -> outfile.commentline;
                    #);
                  a: ^idl.interface_attributes;
               enter a[]
               do a.newscan
	          (# 
	          do 
	             (if current.symbol
                      // idl.uuid then current[] -> do_uuid;
                      // idl.iversion then current[] -> do_iversion;
                      // idl.endpoint then current[] -> do_endpoint;
                      // idl.local then current[] -> do_local;
                      // idl.pointer_default then current[] -> do_pointer_default;
                      // idl.object then current[] -> do_object;
                     if);
                  #);
               #);
          enter h[]
          do outfile.newline;
             outfile.indent;
             h.getIdentifier -> IdentifierToText -> outfile.puttext;
             ': ' -> outfile.puttext;
             (if h.getinheritance_specOpt -> optionalPresent then
                 h.getinheritance_specOpt -> do_inheritance_spec;
             if);
             outfile.newline;
             (* The following will be matched with corresponding lines
              * in end of do_interface_body.
              *)
             2 -> outfile.indent.inc;
             outfile.indent;
             outfile.PatternBegin;
             outfile.newline;
             3 -> outfile.indent.inc;
             h.getinterface_attributes -> do_interface_attributes; 
             outfile.newline;
          #);
        do_interface_body:
          (# do_export_type_dcl:
               (# e: ^idl.export_type_dcl;
               enter e[]
               do outfile.indent;
                  'do_export_type_dcl NYI' -> outfile.commentline;
               #);
             do_export_const_dcl:
               (# e: ^idl.export_const_dcl;
               enter e[]
               do outfile.indent;
                  'do_export_const_dcl NYI' -> outfile.commentline;
               #);
             do_export_except_dcl:
               (# e: ^idl.export_except_dcl;
               enter e[]
               do outfile.indent;
                  'do_export_except_dcl NYI' -> outfile.commentline;
               #);
             do_export_attr_dcl:
               (# e: ^idl.export_attr_dcl;
               enter e[]
               do outfile.indent;
                  'do_export_attr_dcl NYI' -> outfile.commentline;
               #);
             
             do_export_op_dcl:
               (# e: ^idl.export_op_dcl;
                  do_op_dcl:
                    (# do_op_attribute:
                         (# o: ^idl.op_attribute;
                         enter o[]
                         do outfile.indent;
                            'do_op_attribute NYI' -> outfile.commentline;
                         #);
                       do_raises_expr:
                         (# o: ^idl.raises_expr;
                         enter o[]
                         do outfile.indent;
                            'do_raises_expr NYI' -> outfile.commentline;
                         #);
                       do_context_expr:
                         (# o: ^idl.context_expr;
                         enter o[]
                         do outfile.indent;
                            'do_context_expr NYI' -> outfile.commentline;
                         #);
                       do_parameter_dcls:
                         (# p: ^idl.parameter_dcls;
                            d: ^idl.param_dcls;
                         enter p[]
                         do 0 -> num_enter_parameters;
                            p.getparam_dcls -> d[];
                            d.newscan
                            (# 
                            do current[] -> do_param_dcl;
                            #);
                         #);
                       do_param_dcl:
                         (# d: ^idl.param_dcl;
                            do_param_attributes:
                              (# do_attributeY:
                                   (# y: ^idl.attributeY;
                                      ca: ^idl.call_as;
                                      aii: ^idl.att_iid_is;
                                      ii: ^idl.iid_is;
                                      ta: ^idl.transmit_as;
                                      st: ^idl.switch_type;
                                      si: ^idl.switch_is;
                                      ac: ^idl.att_case;
                                      zi: ^idl.size_is;
                                      li: ^idl.length_is;
                                      p, pp: @boolean;
                                   enter y[]
                                   do (if y.symbol
                                       // idl.att_unique then
                                          'unique'->outfile.puttext;
		                       // idl.att_ref then
                                          'ref'->outfile.puttext;
		                       // idl.att_in then
                                          'in'->outfile.puttext;
		                       // idl.att_out then
                                          'out'->outfile.puttext;
		                       // idl.att_in_out then
                                          'in_out'->outfile.puttext;
		                       // idl.att_local then
                                          'local'->outfile.puttext;
		                       // idl.call_as then
                                          'call_as('->outfile.puttext;
                                          (y[]->ca[]).getIdentifier
                                            -> IdentifierToText
                                            -> outfile.puttext;
                                          ')'->outfile.put;
		                       // idl.att_iid_is then
                                          'iid_is('->outfile.puttext;
                                          (y[]->aii[]).getiid_is->ii[];
                                          ii.getIdentifier
                                            -> IdentifierToText
                                            -> outfile.puttext;
                                          ')'->outfile.put;
		                       // idl.size_is then
                                          'size_is('->outfile.puttext;
                                          (y[]->zi[]).getconst_exp
                                            ->do_const_exp;
                                          ')'->outfile.put;
		                       // idl.length_is then
                                          'length_is('->outfile.puttext;
                                          (* Save booleans *)
                                          arg_is_pointer -> p;
                                          arg_is_pointer_pointer -> pp;
                                          (outfile[], 
                                          (y[]->li[]).getdeclarator)
                                            -> do_declarator;
                                          p -> arg_is_pointer;
                                          pp -> arg_is_pointer_pointer;
                                          ')'->outfile.put;
		                       // idl.v1_enum then
                                          'v1_enum'->outfile.puttext;
		                       // idl.transmit_as then
                                          'transmit_as('->outfile.puttext;
                                          (y[]->ta[]).getIdentifier
                                            -> IdentifierToText
                                            -> outfile.puttext;
                                          ')'->outfile.put;
		                       // idl.att_string then
                                          'string'->outfile.puttext;
		                       // idl.switch_type then
                                          'switch_type('->outfile.puttext;
                                          (y[]->st[]).getIdentifier
                                            -> IdentifierToText
                                            -> outfile.puttext;
                                          ')'->outfile.put;
		                       // idl.switch_is then
                                          'switch_is(('->outfile.puttext;
                                          (y[]->si[]).getId1
                                            -> IdentifierToText
                                            -> outfile.puttext;
                                          ')'->outfile.put;
                                          si.getId2
                                            -> IdentifierToText
                                            -> outfile.puttext;
                                          ')'->outfile.put;
		                       // idl.att_case then
                                          'case('->outfile.puttext;
                                          (y[]->ac[]).getIdentifier
                                            -> IdentifierToText
                                            -> outfile.puttext;
                                          ')'->outfile.put;
		                       // idl.async then
                                          'async'->outfile.puttext;
                                     if);
                                   #);
                                 a: ^idl.param_attribute;
                                 do_param_attribute_list:
                                   (# l: ^idl.param_attribute_list;
                                      x: ^idl.attributeX;
                                      a: ^idl.attributes;
                                   enter l[]
                                   do l.getattributeX -> x[];
                                      x.getattributes -> a[];
                                      ' '->outfile.put;
                                      outfile.CommentBegin;
                                      a.newscan
                                      (# first_done: @boolean;
                                      do (if first_done then
                                             ',' -> outfile.put;
                                          else
                                             true->first_done
                                         if);
                                         current[]->do_attributeY;
                                      #);
                                      outfile.CommentEnd;
                                   #);
                              enter a[]
                              do (if a.symbol
                                  // idl.in then
                                     'in' -> outfile.comment;
                                  // idl.out then
                                     'out' -> outfile.comment;
                                  // idl.in_out then
                                     'inout' -> outfile.comment;
                                  // idl.param_attribute_list then
                                     a[] -> do_param_attribute_list;
                                 if);
                                 
                              #);
                            do_const:
                              (# c: ^idl.const_key;
                              enter c[]
                              do (*'const' -> outfile.comment;*)
                              #);
                            do_declarator: 
                              (# d: ^idl.declarator;
                                 s: ^idl.simple_declarator;
                                 p: ^idl.pointer_declarator;
                                 a: ^idl.array_declarator;
                                 pa: ^idl.pointer_to_array_declarator;
                                 pp: ^idl.pointer_to_pointer_declarator;
                                 out: ^stream;
                              enter (out[],d[])
                              do (* Find the NAME and POINTER STATUS
                                  * of the parameter.
                                  *)
                                 (if d.symbol
                                  // idl.simple_declarator then
                                     (d[]->s[]).getidentifier 
                                       -> IdentifierToText
                                       -> out.puttext;
                                  // idl.array_declarator then
                                     (d[]->a[]).getidentifier
                                       -> IdentifierToText
                                       -> out.puttext;
                                     true -> arg_is_pointer;
		                  // idl.pointer_declarator then
                                     (d[]->p[]).getidentifier 
                                       -> IdentifierToText
                                       -> out.puttext;
                                     true -> arg_is_pointer;
		                  // idl.pointer_to_pointer_declarator 
                                     then
                                     (d[]->pp[]).getidentifier 
                                       -> IdentifierToText
                                       -> out.puttext;
                                     true -> arg_is_pointer_pointer;
		                  // idl.pointer_to_array_declarator then
                                     (d[]->pa[]).getarray_declarator->a[];
                                     a.getidentifier
                                       -> IdentifierToText
                                       -> out.puttext;
                                     true -> arg_is_pointer_pointer;
                                 if)
                              #);
                            put_arg:
                              (#
                              do arg[] -> outfile.puttext;
                                 ': ' -> outfile.puttext;
                                 num_enter_parameters+1
                                   -> num_enter_parameters;
                                 (if num_enter_parameters
                                     > enter_parameters.range then
                                     enter_parameters.range
                                       -> enter_parameters.extend;
                                 if);
                                 arg.copy->
                                 enter_parameters[num_enter_parameters][];
                                 arg.reset;
                              #);
                            generate_param_name:
                              (# 
                              do 'arg' -> arg.puttext;
                                 num_enter_parameters->arg.putint;
                              #);
                            do_param_type_spec:
                              (# t: ^idl.param_type_spec;
                                 s: ^idl.param_scoped_name;
                              enter t[]
                              do (if t.symbol
                                  // idl.param_base_type_spec then
                                     put_arg;
                                     '@integer (* param_base_type_spec NYI *)' 
                                       -> outfile.puttext;
			          // idl.param_string_type then
                                     put_arg;
                                     '@integer (* param_string_type NYI *)' 
                                       -> outfile.puttext;
                                  // idl.param_scoped_name then
                                     put_arg;
                                     '@' -> outfile.put;
                                     put_arg_pointer_status;
                                     (t[]->s[]).getscoped_name
                                       -> do_scoped_name;
			          // idl.param_void then
                                     (if true
                                      // arg_is_pointer then
                                         put_arg;
                                         '@integer (* void* *)'
                                           -> outfile.puttext;
                                      // arg_is_pointer_pointer then
                                         put_arg;
                                         '@integer (* void** *)'
                                           -> outfile.puttext;
                                      else
                                         (* If a parameter has type 
                                          * void, then it must mean that
                                          * there are NO parameters! 
                                          * I.e. foo(void).
                                          *)
                                         (if num_enter_parameters=0 then
                                             'No parameters' 
                                               -> outfile.comment;
                                             0->num_enter_parameters
                                          else
                                             'Error: Met void parameter at num_enter_parameters='
                                               -> screen.puttext;
                                             num_enter_parameters
                                               -> screen.putint;
                                             screen.newline;
                                             stop;
                                         if);
                                     if)
                                 if);
                              #);
                            put_arg_pointer_status:
                              (# 
                              do (if arg_is_pointer then
                                     '(*^*)' -> outfile.puttext;
                                 if);
                                 (if arg_is_pointer_pointer then
                                     '(*^^*)' -> outfile.puttext;
                                 if);
                              #);
                            arg: @text;
                            arg_is_pointer: @boolean;
                            arg_is_pointer_pointer: @boolean;
                         enter d[]
                         do arg.reset;
                            false -> arg_is_pointer;
                            false -> arg_is_pointer_pointer;
                            outfile.indent;
                            (if d.getconst2->optionalPresent then
                                d.getconst2->do_const;
                            if);
                            (if d.getdeclarator->optionalPresent then
                                (arg[], d.getdeclarator)->do_declarator
                             else
                                generate_param_name;
                            if);
                            (if d.getconst1->optionalPresent then
                                d.getconst1->do_const;
                            if);
                            d.gettype -> do_param_type_spec;
                            (if d.getattributes->optionalPresent then
                                d.getattributes->do_param_attributes;
                            if);
                            ';' -> outfile.putline;
                         #);
                       emit_enter_parameters:
                         (# first_done: @boolean;
                         do (for i:num_enter_parameters repeat
                                 (if first_done then
                                     ', '->outfile.puttext;
                                  else
                                     true -> first_done;
                                 if);
                                 enter_parameters[i][]
                                   -> outfile.puttext;
                            for)
                         #);
                       result_present: @boolean;
                       enter_parameters: [4]^text;
                       num_enter_parameters: @integer;
                       do_op_type_spec:
                         (# t: ^idl.op_type_spec;
                            s: ^idl.param_scoped_name;
                         enter t[]
                         do false -> result_present;
                            (if t.symbol
                             // idl.void then
                                'No result' -> outfile.comment;
                             // idl.void_ref then
                                true -> result_present;
                                'result: @integer ' -> outfile.puttext;
                                'void*' -> outfile.comment;
                                ';' -> outfile.put;
                             // idl.param_base_type_spec then
                                true -> result_present;
                                'result: @integer ' -> outfile.puttext;
                                'param_base_type_spec NYI' -> outfile.comment;
                                ';' -> outfile.put;
                             // idl.param_string_type then
                                true -> result_present;
                                'result: @integer ' -> outfile.puttext;
                                'param_string_type' -> outfile.comment;
                                ';' -> outfile.put;
                             // idl.param_scoped_name then
                                true -> result_present;
                                'result: @' -> outfile.puttext;
                                (t[]->s[]).getscoped_name 
                                  -> do_scoped_name;
                                ';' -> outfile.put;
                             // idl.param_void then
                                false -> result_present;
                                'No result' -> outfile.comment;
                                ';' -> outfile.put;
                             // idl.param_type_spec_ref then
                                true -> result_present;
                                'result: @integer ' -> outfile.puttext;
                                'param_type_spec_ref NYI'
                                  -> outfile.comment;
                                ';' -> outfile.put;
                            if);
                            outfile.newline;
                         #);
                       e: ^idl.op_dcl;
                    enter e[]
                    do outfile.indent;
                       (* Start a virtual *)
                       e.getIdentifier 
                         -> IdentifierToText -> outfile.puttext;
                       (*':< External' -> outfile.puttext;*)
                       ':< ' -> outfile.puttext;
                       outfile.newline;
                       2 -> outfile.indent.inc;
                       (if e.getop_attributeOpt -> optionalPresent then
                           e.getop_attributeOpt -> do_op_attribute
                       if);
                       (if e.getraises_exprOpt -> optionalPresent then
                           e.getraises_exprOpt -> do_raises_expr;
                       if);
                       (if e.getcontext_exprOpt -> optionalPresent then
                           e.getcontext_exprOpt -> do_context_expr;
                       if);
                       outfile.indent;
                       outfile.PatternBegin;
                       (* Handle the exit parameter *)
                       e.getop_type_spec -> do_op_type_spec;
                       3 -> outfile.indent.inc;
                       (* Handle the enter parameters *)
                       e.getparameter_dcls -> do_parameter_dcls;
                       
                       (* Finish this virtual - emit enter,do,exit *)
                       3 -> outfile.indent.dec;
                       (if num_enter_parameters>0 then
                           outfile.indent;
                           'enter ' -> outfile.puttext;
                           (if num_enter_parameters>1 then 
                               '(' -> outfile.put;
                           if);
                           emit_enter_parameters;
                           (if num_enter_parameters>1 then 
                               ')' -> outfile.put;
                           if);
                           outfile.newline;
                       if);
                       (if e.getstd_call_opt -> optionalPresent then
                           outfile.indent;
                           (*'do CallStd;' -> outfile.putline;*)
                           '__stdcall' -> outfile.commentline;
                        else
                           (* outfile.indent; *)
                           (*'do CallC;' -> outfile.putline;*)
                       if);
                       (if result_present then
                           outfile.indent;
                           'exit result' -> outfile.putline;
                       if);
                       outfile.indent;
                       outfile.PatternEnd;
                       2 -> outfile.indent.dec;
                       (*outfile.newline;*)
                    #);
               enter e[]
               do e.getop_dcl -> do_op_dcl;
               #);
             do_cpp_quote:
               (# c: ^idl.cpp_quote;
               enter c[]
               do outfile.indent;
                  c.getString -> StringToText -> outfile.commentline;
               #);
             do_export_error:
               (# e: ^idl.export_error;
               enter e[]
               do outfile.indent;
                  'do_export_error NYI' -> outfile.commentline;
               #);
             b: ^idl.interface_body;
             e: ^idl.exports;
          enter b[]
          do b.getexports -> e[];
             e.newscan
             (# 
             do (if current.symbol
                 // idl.export_type_dcl then
                    current[] -> do_export_type_dcl
                 // idl.export_const_dcl then
                    current[] -> do_export_const_dcl
                 // idl.export_except_dcl then
                    current[] -> do_export_except_dcl
                 // idl.export_attr_dcl then
                    current[] -> do_export_attr_dcl
                 // idl.export_op_dcl then
                    current[] -> do_export_op_dcl
		 // idl.cpp_quote then
                    current[] -> do_cpp_quote
		 // idl.export_error then
                    current[] -> do_export_error 
                if);
             #);     
             (* The following is matched by the pattern-begin in 
              * do_interface_header
              *)
             3 -> outfile.indent.dec;
             outfile.indent;
             outfile.PatternEnd;
             2 -> outfile.indent.dec;
          #)
     enter i[]
     do 2 -> outfile.indent.inc;
        i.getinterface_header -> do_interface_header;
        i.getinterface_body -> do_interface_body;
        2 -> outfile.indent.dec;
     #);
   
   do_forward_dcl:
     (# f: ^idl.forward_dcl;
     enter f[]
     do 2 -> outfile.indent.inc;
        outfile.indent;
        outfile.CommentBegin;
        'forward_dcl ignored: ' -> outfile.puttext;
        f.getIdentifier -> IdentifierToText -> outfile.puttext;
        outfile.CommentEnd;
        outfile.newline;
        2 -> outfile.indent.dec;
     #);
   
   do_module: 
     (# m: ^idl.module;
     enter m[]
     do outfile.indent;
        'do_module NYI' -> outfile.commentline;
     #);
   
   do_definition_error: 
     (# d: ^idl.definition_error
     enter d[]
     do outfile.indent;
        'do_definition_error NYI' -> outfile.commentline;
     #);
   
do
   InitAstEnv;
   (if debug then 'With DEBUG.' -> screen.putline; 
       'Using parser: ' -> screen.puttext;
       BobsTab -> screen.putline;
   if);
   IdlFileName[] -> ExpandFileName -> DoFragment;
#)
