ORIGIN './control';
INCLUDE './idlsematt';
--Translate: Descriptor --
(#
   BobsTab: (# exit '~beta/grammars/idl/v2.0/idl-parser.btab' #);
   AstTrace: (# exit false #);
   MaxFragments: (# exit 100 #);
   
   ast: @astInterface
     (* An instance of the AST interface *)
     (# defaultGrammarFinder:: findGrammar #);
   
   idl: @ast.idl; (* The MPS interface to the BETA grammar/ASTs *)
   
   NameApplToText: (# na: ^ast.NameAppl enter na[]  exit na.getText #);
   NameDeclToText: (# nd: ^ast.NameDecl enter nd[]  exit nd.getText #);
   ConstToInteger: (# con: ^ast.Const   enter con[] exit con.getValue #);
   
   isOptionalPresent: 
     (# opt: ^ast.ast; 
     enter opt[]
     exit opt.kind<>ast.kinds.optional
     #);
   
   ExpandFileName:
     (# Name, ExpandedName: ^text
     enter Name[]
     do (Name[], '') -> ast.thePathHandler.convertFilePath -> ExpandedName[];
     exit ExpandedName[]
     #);
   
   InitAstEnv:
     (* Initialization of the meta programming system *)
     (# 
     do 
	(if AstTrace then
            (ast.trace.topOpen,true) -> ast.trace.set;
            (ast.trace.fragmentOpen,true) -> ast.trace.set;
            (ast.trace.grammars,true) -> ast.trace.set;
            (ast.trace.compactOpen,true) -> ast.trace.set;
            (ast.trace.onParse,true) -> ast.trace.set;
            (ast.trace.parser,true) -> ast.trace.set;
            (ast.trace.getBinding,true) -> ast.trace.set;
            (ast.trace.getBindingMark,true) -> ast.trace.set;
        if);
	ast; 
        idl.init; 
	BobsTab -> ast.expandToFullPath -> idl.parser.initialize(# EOLasComEnd::(#do true->value#) #);
     #);
   
   IdentifierToText:
     (# i: ^idl.identifier;
     enter i[]
     exit i.getnameAppl -> NameApplToText
     #);
   
   CheckComment:
     (* Stolen from prettyprinter *)
     (# currentSubcomment: ^text;
        n: @integer;
        do_comment:
          (# 
          do (if currentSubcomment[] <> none then
                 (if currentSubcomment.lgth<>0 then
                     '(* '->outfile.puttext;
                     currentSubcomment[]->outfile.putText;
                     ' *)'->outfile.putline;
                  else
                     (* empty line comment *)
                     outfile.newline;
                 if)
             if)
          #);
        a: ^ast.ast;
     enter a[]
     do a.getNextComment->(currentSubcomment[],n);
        (if n
         // 0 then
            do_comment; 
         // 1 then
            do_comment;
            loop:
              (# 
              do a.getNextComment->(currentSubcomment[],n);
                 do_comment;
                 (if n = 1 then restart loop if);
              #)            
        if);
     #);
   DoFragment:
     (#
	fg: ^ast.fragmentGroup; 
        ff: ^ast.fragmentForm;
	List: [maxfragments]^text; 
        End: @integer; 
        NodeName: ^text;
	
	Insert:
	  (# path, basis: ^text; strippedbasis: @text;
	     i: @integer;
	  enter (path[], basis[])
	  do end+1 -> end;
	     basis -> strippedbasis;
	     ast.thepathhandler.directorychar
	       -> strippedbasis.findall(# do inx -> i #);
	     (i,strippedbasis.length) -> strippedbasis.delete;
	     (path[],strippedbasis[]) -> ast.thePathHandler.convertFilePath 
	       -> List[End][]
	  #);
	
	Target: @text;
	Found: @boolean;
	
     enter NodeName[]
     do
	'Opening '''->puttext; 
	(NodeName[], '') -> ast.thePathhandler.localpath -> puttext; 
	'''...'->putline;
	(NodeName[], screen[]) 
	  -> ast.top.open(# StartingParsing::< (# do '  parsing...'->putline #)#)
	  -> fg[];
	(if fg[]=NONE then
	    'Not able to open: ' -> puttext; 
            NodeName[] -> putText; 
            newLine; 
            Stop
	if);
	
	(if AstTrace then 'scanincludes: ' -> putline; if);
        fg.scanIncludes
	(# 
        do (if AstTrace then
               'current.linkname: ' -> puttext; current.linkname[]->putline;
           if);
	   (current.linkname[], fg.FullName) -> Insert;
	#);
	fg.fragmentList.scan
	(# do
	   (if Current.type
	    // ast.groupType then 
               (failure,'Groups not supported.') -> stop
	    // ast.formType then
	       '  translate: ' -> putText; 
               Current.name[] -> putText;
	       Current.f[] -> ff[]; 
               ff.root[] -> do_specification;
	       newLine;
	if) #);
	fg.close;
	(for i: End repeat List[i][] -> DoFragment for);
     #);
   
   indent: @
     (# textindent: @text;
        inc: 
          (# i: @integer;
          enter i
          do (for i repeat ' ' -> textindent.put for);
          #);
        dec:
          (# i: @integer
          enter i
          do (1,i) -> textindent.delete;
          #);
     do textindent[] -> outfile.puttext;
     #);
   
   do_specification:
     (* Translate the top node of the IDL *)
     (# s: ^idl.specification;
     enter s[]
     do s[] -> CheckComment;
        outfile.newline;
        s.getDefinitions -> do_definitions;
     #);
   
   do_definitions:
     (# d: ^idl.definitions;
     enter d[]
     do d.newscan
	(# 
	do 
	   (if current.symbol
            // idl.def_type_dcl then current[] -> do_def_type_dcl 
            // idl.const_dcl then current[] -> do_const_dcl;
            // idl.except_dcl then current[] -> do_except_dcl;
            // idl.interface_dcl then current[] -> do_interface_dcl;
            // idl.forward_dcl then current[] -> do_forward_dcl;
            // idl.module then current[] -> do_module;
            // idl.definition_error then current[] -> do_definition_error; 
	    else
	       '\nERROR: DoSpecification: illegal current.symbol: ' -> puttext;
	       current.symbol -> putint;
	       newline;
	   if);
	#)
     #);
   
   do_def_type_dcl: 
     (# d: ^idl.def_type_dcl;
     enter d[]
     do indent;
        '(* do_def_type_dcl not yet implemented *)' -> outfile.putline;
     #);
   
   do_const_dcl: 
     (# c: ^idl.const_dcl;
     enter c[]
     do indent;
        '(* do_const_dcl not yet implemented *)' -> outfile.putline;
     #);
   
   do_except_dcl: 
     (# e: ^idl.except_dcl;
     enter e[]
     do indent;
        '(* do_except_dcl not yet implemented *)' -> outfile.putline;
     #);
   
   do_interface_dcl:
     (# i: ^idl.interface_dcl;
        do_interface_header:
          (# h: ^idl.interface_header;
             do_inheritance_spec:
               (# i: ^idl.inheritance_spec;
               enter i[]
               do '(* do_inheritance_spec NYI *)' -> outfile.puttext;
               #);
             do_interface_attributes:
               (# do_uuid:
                    (# do_uuid_rep:
                         (# r: ^idl.uuid_rep;
                         enter r[]
                         do r.newscan
                            (# k: ^idl.keys;
                               first_done: @boolean;
                            do current[] -> k[];
                               (if first_done then
                                   '-' -> outfile.put;
                                else
                                   true->first_done
                               if);
                               k.newscan
                               (# n: ^idl.namekey;
                                  c: ^idl.constkey;
                               do (if current.symbol
                                   // idl.namekey then
                                      current[] -> n[];
                                      n.getnameappl -> NameApplToText -> outfile.puttext;
                                   // idl.constkey then
                                      current[] -> c[];
                                      c.getconst -> ConstToInteger -> outfile.putint;
                                  if)
                               #);
                            #)
                         #);
                       u: ^idl.uuid
                    enter u[]
                    do indent;
                       '(* do_uuid NYI: ' -> outfile.puttext;
                       u.getuuid_rep -> do_uuid_rep;
                       ' *)' -> outfile.putline;
                    #);
                  do_iversion:
                    (# v: ^idl.iversion
                    enter v[]
                    do indent;
                       '(* do_iversion NYI *)' -> outfile.putline;
                    #);
                  do_endpoint:
                    (# e: ^idl.endpoint
                    enter e[]
                    do indent;
                       '(* do_endpoint NYI *)' -> outfile.putline;
                    #);
                  do_local:
                    (# l: ^idl.local
                    enter l[]
                    do indent;
                       '(* do_local NYI *)' -> outfile.putline;
                    #);
                  do_pointer_default:
                    (# p: ^idl.pointer_default
                    enter p[]
                    do indent;
                       '(* do_pointer_default NYI *)' -> outfile.putline;
                    #);
                  do_object:
                    (# o: ^idl.object
                    enter o[]
                    do indent;
                       '(* do_object NYI *)' -> outfile.putline;
                    #);
                  a: ^idl.interface_attributes;
               enter a[]
               do a.newscan
	          (# 
	          do 
	             (if current.symbol
                      // idl.uuid then current[] -> do_uuid;
                      // idl.iversion then current[] -> do_iversion;
                      // idl.endpoint then current[] -> do_endpoint;
                      // idl.local then current[] -> do_local;
                      // idl.pointer_default then current[] -> do_pointer_default;
                      // idl.object then current[] -> do_object;
                     if);
                  #);
               #);
          enter h[]
          do outfile.newline;
             indent;
             h.getIdentifier -> IdentifierToText -> outfile.puttext;
             ': ' -> outfile.puttext;
             (if h.getinheritance_specOpt -> isOptionalPresent then
                 h.getinheritance_specOpt -> do_inheritance_spec;
             if);
             outfile.newline;
             2 -> indent.inc;
             indent;
             '(# ' -> outfile.putline;
             h.getinterface_attributes -> do_interface_attributes; 
             outfile.newline;
          #);
        do_interface_body:
          (# b: ^idl.interface_body;
          enter b[]
          do indent;
             '(* do_interface_body NYI *)' 
               -> outfile.putline;
             indent;
             '#);' -> outfile.putline;
             2 -> indent.dec;
          #)
     enter i[]
     do 2 -> indent.inc;
        i.getinterface_header -> do_interface_header;
        i.getinterface_body -> do_interface_body;
        2 -> indent.dec;
     #);
   
   do_forward_dcl:
     (# f: ^idl.forward_dcl;
     enter f[]
     do 2 -> indent.inc;
        indent;
        '(* forward_dcl ignored: ' -> outfile.puttext;
        f.getIdentifier -> IdentifierToText -> outfile.puttext;
        ' *)' -> outfile.putline;
        2 -> indent.dec;
     #);
   
   do_module: 
     (# m: ^idl.module;
     enter m[]
     do indent;
        '(* do_module NYI *)' -> outfile.putline;
     #);
   
   do_definition_error: 
     (# d: ^idl.definition_error
     enter d[]
     do indent;
        '(* do_definition_error NYI *)' -> outfile.putline;
     #);
   
do
   InitAstEnv;
   (if debug then 'With DEBUG.' -> screen.putline; if);
   'Using parser: ' -> screen.puttext;
   BobsTab -> screen.putline;
   IdlFileName[] -> ExpandFileName -> DoFragment;
#)
