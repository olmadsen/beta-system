ORIGIN 'control';
INCLUDE 'idlsematt';
INCLUDE 'mpsadditions';
BODY 'preprocess';
BODY 'interface_header';
BODY 'interface_body';
BODY 'type_dcl';
BODY 'const_exp';
BODY 'declarator';
BODY 'attributes';

--Translate: Descriptor -----
(#
   <<SLOT TranslateLib: attributes>>;
   
   BobsTab: (# exit '$(BETALIB)/grammars/idl/v2.0/idl-parser.btab' #);
   
   ast: @astInterface
     (* An instance of the AST interface *)
     (# defaultGrammarFinder:: findGrammar #);
   
   idl: @ast.idl; (* The MPS interface to the BETA grammar/ASTs *)
   
   holders: @list(# element::text #);
   refholders: @list(# element::text #);
   imports: @list(# element::text #);
   
   optionalPresent: 
     (# opt: ^astinterface.ast; 
     enter opt[]
     exit opt.kind<>ast.kinds.optional
     #);
   
   ExpandFileName:
     (# Name, ExpandedName: ^text
     enter Name[]
     do (Name[], '') 
          -> ast.thePathHandler.convertFilePath -> ExpandedName[];
     exit ExpandedName[]
     #);
   
   Preprocess:
     (# 
     do <<SLOT PreprocessBody:descriptor>>
     #);
   
   Postprocess:
     (# 
     do <<SLOT Postprocess:descriptor>>
     #);
   
   InitAstEnv:
     (* Initialization of the meta programming system *)
     (# parser_entry, bidl_entry: @diskentry;
     do 
	(if Debug then
            (ast.trace.topOpen,true) -> ast.trace.set;
            (ast.trace.fragmentOpen,true) -> ast.trace.set;
            (ast.trace.grammars,true) -> ast.trace.set;
            (ast.trace.compactOpen,true) -> ast.trace.set;
            (ast.trace.onParse,true) -> ast.trace.set;
            (ast.trace.parser,true) -> ast.trace.set;
            (ast.trace.getBinding,true) -> ast.trace.set;
            (ast.trace.getBindingMark,true) -> ast.trace.set;
        if);
        BobsTab -> ast.expandToFullPath -> parser_entry.path;
        1 -> Arguments -> bidl_entry.path;
        (if bidl_entry.modtime < parser_entry.modtime then
            'Parser is newer than bidl executable - recompile bidl!'
              -> screen.putline;
            stop;
        if);
	ast.astLevelInit;
        idl.init; 
	parser_entry.path
          -> idl.parser.initialize(# EOLasComEnd::(#do true->value#) #);
     #);
   
   EmitComments: FetchComments
     (# 
     do (if currentSubcomment.lgth<>0 then
            currentSubcomment[]->outfile.CommentLine;
         else
            (* empty line comment *)
            outfile.newline;
        if)
     #);
   
   IdentifierToText:
     (# i: ^idl.identifier;
     enter i[]
     exit i.getnameAppl -> NameApplToText
     #);
   
   EmitHolders:
     (# 
     do (if not holders.empty then
            2 -> outfile.indent.inc;
            outfile.newline;
            outfile.indent;
            'Holders' -> outfile.CommentLine;
            outfile.newline;
            holders.scan
            (# 
            do outfile.indent;
               current[] -> outfile.puttext;
               'Holder: Holder' -> outfile.putline;
               2 -> outfile.indent.inc;
               outfile.indent;
               outfile.PatternBegin;
               outfile.newline;
               3 -> outfile.indent.inc;
               outfile.indent;
               'value: @' ->outfile.puttext;
               current[] -> outfile.puttext;
               ';' -> outfile.putline;
               3 -> outfile.indent.dec;
               outfile.indent;
               outfile.PatternEnd;
               2 -> outfile.indent.dec;
               ';' -> outfile.putline;
            #);
            2 -> outfile.indent.dec;
        if);
     #);
   EmitRefholders:
     (# 
     do (if not refholders.empty then
            2 -> outfile.indent.inc;
            outfile.newline;
            outfile.indent;
            'Reference Holders' -> outfile.CommentLine;
            outfile.newline;refholders.scan
            (# 
            do outfile.indent;
               current[] -> outfile.puttext;
               'Holder: refHolder' -> outfile.putline;
               2 -> outfile.indent.inc;
               outfile.indent;
               outfile.PatternBegin;
               outfile.newline;
               3 -> outfile.indent.inc;
               outfile.indent;
               'type:: ' ->outfile.puttext;
               current[] -> outfile.puttext;
               ';' -> outfile.putline;
               3 -> outfile.indent.dec;
               outfile.indent;
               outfile.PatternEnd;
               2 -> outfile.indent.dec;
               ';' -> outfile.putline;
            #);
            2 -> outfile.indent.dec;
        if);
     #);
   
   DoFile:
     (# ifile: @file;
        ok: @boolean;
        ff: ^ast.fragmentForm;
     do
	(if not quiet then
            'Opening '''->screen.puttext; 
	    (IdlFileName[], '') -> ast.thePathhandler.localpath -> screen.puttext; 
	    '''...'->screen.putline;
        if);
        (* We do not use top.open, since this enforces fragment
         * syntax on the source files. And we would like to be able to
         * use the IDL files "as-is", without modification.
         * This means, that we will have to do the following ourselves:
         *    dependency analysis
         *    include handling (if needed - currently not)
         *)
        (if not quiet then '  preprocessing...' -> screen.putline; if);
        PreProcess;
        Ifilename[] -> ifile.name;
        ifile.openread;
        idl[] -> ast.newFragmentForm -> ff[];
        (if not quiet then 
            '  parsing...' -> screen.putline; 
            '    [parser: ' -> screen.puttext;
            BobsTab -> ast.expandToFullPath -> screen.puttext;
            ']' -> screen.putline;
        if);
        (0,fromBeginning) -> ifile.setpos;
        (1,ifile[],screen[],ff[]) -> idl.parser -> ok;
	(if ok then
            (if not quiet then '  translating...' -> screen.putline; if);
            ff.root[] -> do_specification;
            PostProcess;
            (if not quiet then '  done.' -> screen.putline; if);
         else
            (0,fromBeginning) -> ifile.setpos;
            'Parse errors:' -> screen.putline;
            (ifile[],screen[]) -> idl.parser.ErrorReport;
            PostProcess;
        if);
        ifile.close;
     #);
      
   do_specification:
     (* Translate the top node of the IDL *)
     (# s: ^idl.specification;
     enter s[]
     do s[] -> EmitComments;
        outfile.newline;
        s.getDefinitions -> do_definitions;
        EmitHolders;
        EmitRefHolders;
     #);
   
   declarator_info:
     (# id: ^text;
        is_pointer: @boolean;
        is_pointer_pointer: @boolean;
     #);
   
   do_declarator: 
     (* Find the NAME and POINTER STATUS
      * of the parameter. 
      *)
     (# d: ^idl.declarator;
        info: ^declarator_info;
     enter (info[],d[])
     do <<SLOT declarator_body: descriptor>>
     #);
   
   do_attributeX:
     (# x: ^idl.attributeX;
        a: ^idl.attributes;
     enter x[]
     do x.getattributes -> a[];
        outfile.CommentBegin;
        a.newscan
        (# first_done: @boolean;
        do (if first_done then
               ',' -> outfile.put;
            else
               true->first_done
           if);
           current[] -> do_attributeY;
        #);
        outfile.CommentEnd;
     #);
   
   do_attributeY:
     (# y: ^idl.attributeY;
     enter y[]
     do <<SLOT attributeY_body: descriptor>>
     #);
   
   do_definitions:
     (# d: ^idl.definitions;
     enter d[]
     do Outfile.Origin;
        outfile.Lib;
        d.newscan
	(# t: ^text;
	do (if current.symbol
            // idl.import then current[] -> do_import
            // idl.def_type_dcl then current[] -> do_def_type_dcl 
            // idl.const_dcl then current[] -> do_const_dcl;
            // idl.except_dcl then current[] -> do_except_dcl;
            // idl.interface_dcl then current[] -> do_interface_dcl;
            // idl.forward_dcl then current[] -> do_forward_dcl;
            // idl.module then current[] -> do_module;
            // idl.import then (* handled above *)
            // idl.library
            // idl.coclass
            // idl.importlib then 
               (if not quiet then 
                   'type-library information not translated' -> t[];
                   '    ['-> screen.puttext; t[] -> screen.puttext;
                   ']' -> screen.putline;
               if);
               2 -> outfile.indent.inc;
               outfile.newline;
               outfile.indent;
               t[] -> outfile.commentline;
               2 -> outfile.indent.dec;
            // idl.definition_error then current[] 
                 -> do_definition_error; 
	    else
	       '\nERROR: do_specification: illegal current.symbol: ' 
                 -> puttext;
	       current.symbol -> putint;
	       newline;
	   if);
	#)
     #);
   
   do_def_type_dcl: 
     (# d: ^idl.def_type_dcl;
     enter d[]
     do 2 -> outfile.indent.inc;
        d.gettype_dcl -> do_type_dcl;
        2 -> outfile.indent.dec;
     #);
   
   do_type_dcl: 
     (# <<SLOT type_dcl_lib: attributes>>;
        d: ^idl.type_dcl;
     enter d[]
     do <<SLOT type_dcl_body: descriptor>>
     #);
   
   do_const_dcl: 
     (# c: ^idl.const_dcl;
     enter c[]
     do outfile.indent;
        'do_const_dcl NYI' -> outfile.commentline;
     #);
   
   do_except_dcl: 
     (# e: ^idl.except_dcl;
     enter e[]
     do outfile.indent;
        'do_except_dcl NYI' -> outfile.commentline;
     #);
   
   do_scoped_name:
     (# n: ^idl.scoped_name;
        s1: ^idl.scoped_name1;
        s2: ^idl.scoped_name2;
        s3: ^idl.scoped_name3;
        id: ^text;
     enter n[]
     do (if n.symbol
         // idl.scoped_name1 then
            n[] -> s1[];
            s1.getIdentifier -> IdentifierToText 
              -> id[] 
              -> outfile.puttext;
         // idl.scoped_name2 then
            n[] -> s2[];
            s2.getIdentifier -> IdentifierToText 
              -> id[] 
              -> outfile.puttext;
         // idl.scoped_name3 then
            n[] -> s3[];
            s3.getscoped_name -> do_scoped_name -> id[];
            '.' -> id.put;
            s3.getIdentifier -> IdentifierToText 
              -> id.puttext;
            id[] -> outfile.puttext;
        if);
     exit id[]
     #);
   
   do_const_exp:
     (# e: ^idl.const_exp;
        <<SLOT const_exp_lib: attributes>>
     enter e[]
     <<SLOT const_exp_body:dopart>>
     #);
   
   do_interface_dcl:
     (# i: ^idl.interface_dcl;
        do_interface_header:
          (# <<SLOT interface_header_lib: attributes>>;
             h: ^idl.interface_header;
          enter h[]
          <<SLOT interface_header_body: dopart>>
          #);
        do_interface_body:
          (# <<SLOT interface_body_lib: attributes>>;
             b: ^idl.interface_body;
             e: ^idl.exports;
          enter b[]
          <<SLOT interface_body_body: dopart>>
          #)
     enter i[]
     do 2 -> outfile.indent.inc;
        i.getinterface_header -> do_interface_header;
        i.getinterface_body -> do_interface_body;
        2 -> outfile.indent.dec;
     #);
   
   do_forward_dcl:
     (# f: ^idl.forward_dcl;
     enter f[]
     do 2 -> outfile.indent.inc;
        outfile.indent;
        outfile.CommentBegin;
        'forward_dcl ignored: ' -> outfile.puttext;
        f.getIdentifier -> IdentifierToText -> outfile.puttext;
        outfile.CommentEnd;
        outfile.newline;
        2 -> outfile.indent.dec;
     #);
   
   do_module: 
     (# m: ^idl.module;
     enter m[]
     do outfile.indent;
        'do_module NYI' -> outfile.commentline;
     #);
   
   do_import: 
     (# m: ^idl.import;
     enter m[]
     do m.getstring -> StringToText -> imports.append;
     #);
   
   do_definition_error: 
     (# d: ^idl.definition_error
     enter d[]
     do outfile.indent;
        'do_definition_error NYI' -> outfile.commentline;
     #);
   
do
   InitAstEnv;
   (if debug then 'With DEBUG.' -> screen.putline; 
       false -> quiet;
       'Using parser: ' -> screen.puttext;
       BobsTab -> screen.putline;
   if);
   (if trace then 'With TRACE.' -> screen.putline; 
       false -> quiet;
   if);
   DoFile;
#)
