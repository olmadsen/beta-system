ORIGIN '~beta/basiclib/file';
BODY 'private/betaoutfilebody' (* For now, it's a .bet text file *);
-- Lib:Attributes --

debug: (# exit false #);

OutputFile: 
  (# <<SLOT OutFileAttributes: attributes>>;
     compact, opened: @boolean;
     
     (* Hack to allow for this "file" to temporatily change
      * implementation to be a text (in order to delay emission
      * of text to it).
      *)
     medium: ^stream (* Must be one of theFile or theText *);
     theFile: @File;
     
     do_open:
       (# 
       do (if medium[]=NONE then theFile[] -> medium[] if);
          true -> opened;
          INNER;
       #);
     if_open:
       (# 
       do (if opened then INNER if);
       #);
     
     openWrite: do_open
       (# 
       do theFile.openWrite;
       #);
     openAppend: do_open
       (# 
       do theFile.openAppend;
       #);
     close: if_open
       (# 
       do false -> opened;
          theFile.close;
       #);
     
     Identification: if_open
       (# IdlFileName: ^text 
       enter IdlFileName[]  
       <<SLOT OutfileIdentification:dopart>> 
       #);
     Origin: if_open
       (# chain: @boolean;
          PreviousFile: ^text;
       enter (chain, PreviousFile[])
       <<SLOT OutfileOrigin:dopart>> 
       #);

     Lib: if_open
       (#  
       <<SLOT OutfileLib:dopart>> 
       #);

     Epilog: if_open
       (# 
       <<SLOT OutfileEpilog:dopart>>
       #);

     Indent: @if_open
       (# indentlevel: @integer;
          get:
            (# exit indentlevel #);
          set:
            (# i: @integer;
            enter i
            do i -> indentlevel;
               (if debug then
                   commentbegin;
                   '='->put;
                   indentlevel->putint;
                   commentend;
               if)
            #);
          inc: 
            (# i: @integer;
            enter i
            do indentlevel+i -> indentlevel;
               (if debug then
                   commentbegin;
                   '+'->put;
                   i->putint;
                   '='->put;
                   indentlevel->putint;
                   commentend;
               if)
            #);
          dec:
            (# i: @integer
            enter i
            do indentlevel-i -> indentlevel;
               (if debug then
                   commentbegin;
                   '-'->put;
                   i->putint;
                   '='->put;
                   indentlevel->putint;
                   commentend;
               if)
            #);
       do (for i:indentlevel repeat ' '->put for);
       #);

     PatternBegin: if_open
       (# <<SLOT OutFilePatternBegin: dopart>> #);

     PatternEnd: if_open
       (# <<SLOT OutFilePatternEnd: dopart>> #);

     CommentBegin: if_open
       (# <<SLOT OutFileCommentBegin: dopart>> #);

     CommentEnd: if_open
       (# <<SLOT OutFileCommentEnd: dopart>> #);

     SpaceComment: if_open
       (# c: ^text;
       enter c[]
       <<SLOT OutFileSpaceComment: dopart>>
       #);
     Comment: if_open
       (# c: ^text;
       enter c[]
       <<SLOT OutFileComment: dopart>>
       #);
     CommentLine: if_open
       (# c: ^text;
       enter c[]
       <<SLOT OutFileCommentLine: dopart>>
       #);
     
     puttext: if_open
       (# t: ^text
       enter t[]
       do t[] -> medium.puttext;
       #);
     putline: if_open
       (# t: ^text
       enter t[]
       do t[] -> medium.putline;
       #);
     putint: if_open
       (# i: @integer
       enter i
       do i -> medium.putint;
       #);
     put: if_open
       (# c: @char
       enter c
       do c -> medium.put;
       #);
     newline: if_open
       (# 
       do medium.newline;
       #);
  #);
