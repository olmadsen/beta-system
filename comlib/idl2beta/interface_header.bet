ORIGIN 'translate'

-- interface_header_lib: attributes--
do_inheritance_spec:
  (# i: ^idl.inheritance_spec;
     n: ^idl.scoped_names;
     
     numPrefixes: @integer;
  enter i[]
  do 0->numPrefixes;
     i.getscoped_names -> n[];
     n.newscan
     (# 
     do (if numPrefixes>0 then
            'Error: Multiple inheritance_specs not supported!'
              -> screen.putline;
            stop;
         else
            current[] -> do_scoped_name -> outfile.puttext;
        if);
     #)
  #);
do_interface_attributes:
  (# 
     do_iversion:
       (# v: ^idl.iversion;
          major: ^idl.major_version;
          minor: ^idl.minor_version;
       enter v[]
       do outfile.indent;
          'version: (\# exit ' -> outfile.puttext;
          v.getmajor_version -> major[];
          major.getconst -> ConstToText -> outfile.puttext;
          (if v.getminor_version_opt -> optionalPresent then
              '.' -> outfile.put;
              v.getminor_version_opt -> minor[];
              minor.getconst -> ConstToText -> outfile.puttext;
          if);
          ' #\);' -> outfile.putline;
       #);
     do_endpoint:
       (# e: ^idl.endpoint
       enter e[]
       do outfile.indent;
          'do_endpoint NYI' -> outfile.commentline;
       #);
     do_helpstring:
       (# s: ^idl.helpstring
       enter s[]
       do (* No need to do anything - has been done by
           * do_interface_header_helpstring 
           *)
       #);
     
     do_local:
       (# l: ^idl.local
       enter l[]
       do outfile.indent;
          'keyword found: \'local\'' -> outfile.commentline;
       #);
     do_hidden:
       (# h: ^idl.hidden
       enter h[]
       do outfile.indent;
          'keyword found: \'hidden\'' -> outfile.commentline;
       #);
     do_pointer_default:
       (# do_ptr_attr:
            (# p: ^idl.ptr_attr;
               i: ^idl.iid_is;
            enter p[]
            do (if p.symbol
                // idl.ref then
                   'ref' -> outfile.puttext;
                // idl.ptr then
                   'ptr' -> outfile.puttext;
                // idl.unique then
                   'unique' -> outfile.puttext;
                // idl.iid_is then
                   'iid_is: ' -> outfile.puttext;
                   (p[]->i[]).getIdentifier 
                     -> IdentifierToText -> outfile.puttext;
               if);
            #);
          p: ^idl.pointer_default
       enter p[]
       do outfile.indent;
          outfile.CommentBegin;
          'pointer_default: ' -> outfile.puttext;
          p.getptr_attr->do_ptr_attr;
          outfile.CommentEnd;
          outfile.newline;
       #);
     do_object:
       (# o: ^idl.object
       enter o[]
       do outfile.indent;
          'keyword found: \'object\'' -> outfile.commentline;
       #);
     a: ^idl.interface_attributes;
  enter a[]
  do a.newscan
     (# 
     do 
        (if current.symbol
         // idl.uuid then 
            (* already done in do_interface_header *)
         // idl.helpstring then current[] -> do_helpstring;
         // idl.iversion then current[] -> do_iversion;
         // idl.endpoint then current[] -> do_endpoint;
         // idl.local then current[] -> do_local;
         // idl.hidden then current[] -> do_hidden;
         // idl.pointer_default then current[] -> do_pointer_default;
         // idl.object then current[] -> do_object;
        if);
     #);
  #);

do_interface_header_uuid:
  (# do_uuid_rep:
       (# r: ^idl.uuid_rep;
       enter r[]
       do r.newscan
          (# k: ^idl.keys;
             first_done: @boolean;
          do current[] -> k[];
             (if first_done then
                 '-' -> outfile.put;
              else
                 true->first_done
             if);
             k.newscan
             (# n: ^idl.namekey;
                c: ^idl.constkey;
             do (if current.symbol
                 // idl.namekey then
                    current[] -> n[];
                    n.getnameappl -> NameApplToText -> outfile.puttext;
                 // idl.constkey then
                    current[] -> c[];
                    c.getconst -> ConstToText -> outfile.puttext;
                if)
             #);
          #)
       #);
     h: ^idl.interface_header;
     a: ^idl.interface_attributes;
  enter h[]
  do '\'' -> outfile.puttext;
     h.getinterface_attributes -> a[];
     a.newscan
     (# u: ^idl.uuid
     do (if current.symbol
         // idl.uuid then 
            (current[] -> u[]).getuuid_rep -> do_uuid_rep;
        if);
     #);
     '\'' -> outfile.puttext;
  #);

do_interface_header_helpstring:
  (# h: ^idl.interface_header;
     a: ^idl.interface_attributes;
  enter h[]
  do h.getinterface_attributes -> a[];
     a.newscan
     (# s: ^idl.helpstring;
     do (if current.symbol
         // idl.helpstring then
            outfile.indent;
            (current[]->s[]).getstring 
              -> StringToText
              -> outfile.commentline;
        if)
     #)
  #);

--interface_header_body: descriptor--
(# interface_name: ^text;
do outfile.newline;
   (* Declare the IID *)
   outfile.indent;
   h.getIdentifier -> IdentifierToText -> interface_name[] -> outfile.puttext;
   '_IID: (# exit ' -> outfile.puttext;
   h[] -> do_interface_header_uuid;
   ' #);\n' -> outfile.putline;
   
   (* Declare the interface *)
   outfile.indent;
   interface_name[] -> outfile.puttext;
   ': ' -> outfile.puttext;
   (if h.getinheritance_specOpt -> optionalPresent then
       h.getinheritance_specOpt -> do_inheritance_spec;
    else
       (* IUnknown prefix *)
       'COM' -> outfile.puttext;
   if);
   outfile.newline;
   (* The following will be matched with corresponding lines
    * in end of do_interface_body.
    *)
   2 -> outfile.indent.inc;
   h[] -> do_interface_header_helpstring;
   outfile.indent;
   outfile.PatternBegin;
   outfile.newline;
   3 -> outfile.indent.inc;
   h.getinterface_attributes -> do_interface_attributes; 
   outfile.newline;
#)   
   
   
