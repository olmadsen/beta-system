ORIGIN 'Deep_Thought';
INCLUDE '~beta/basiclib/numberio';
INCLUDE '~beta/win32lib/winerror';
--LIB: attributes--
Calc: 
  (# Unknown_IID: ^IID;
     Calc_IID: ^IID;
     Calc2_IID: ^IID;
     Hello_IID: ^IID;
     ncalc: @integer;
     ncalc2: @integer;
     nhello: @integer;
     
     QueryIF:
       (# result: @int32;
          riid: ^IID; 
          ppvObject: ^IUnknownHolder; 
       enter (riid[], ppvObject[])
       do (if Unknown_IID[]=NONE then
              &IID[] -> Unknown_IID[];
              IUnknown_IID -> Unknown_IID;
          if);
          (if Calc_IID[]=NONE then
              &IID[] -> Calc_IID[];
              ICalc_IID -> Calc_IID;
          if);
          (if Calc2_IID[]=NONE then
              &IID[] -> Calc2_IID[];
              ICalc2_IID -> Calc2_IID;
          if);
          (if Hello_IID[]=NONE then
              &IID[] -> Hello_IID[];
              IHello_IID -> Hello_IID;
          if);
          (if true 
           // riid[] -> Unknown_IID.equal then
              CCalc[] -> ppvObject;
           // riid[] -> Calc_IID.equal then
              CCalc[] -> ppvObject;
           // riid[] -> Calc2_IID.equal then
              CCalc2 -> ppvObject;
           // riid[] -> Hello_IID.equal then
              CHello -> ppvObject;
           else
              NONE -> ppvObject;
              E_NOINTERFACE -> result;
              leave QueryInterface;
          if);
          S_OK -> result;
          ppvObject.ref.AddRef;
       exit result
       #);
     
     CCalc: @ICalc
       (# QueryInterface::
            (# 
            do (riid[], ppvObject[]) -> QueryIF -> result;
            #);
          AddRef::
            (# 
            do ncalc+1 -> ncalc;
               ncalc -> result;
            #);
          Release::
            (# 
            do ncalc-1 -> ncalc;
               (if ncalc=0 then
                   (* Could do some deallocation here *)
               if);
               ncalc -> result;
            #);
          Add::
            (# do (v1 + v2) -> res #);
          Subtract::
            (# do (v1 - v2) -> res #);
          Multiply::
            (# do (v1 * v2) -> res #);
          Divide::
            (# 
            do (if v2 = 0 then 
                   0 -> res;
                   E_FAIL -> result;
                else
                   (v1 div v2) -> res;
               if);
            #);
          Modulus::
            (# 
            do (if v2 = 0 then 
                   0 -> res;
                   E_FAIL -> result;
                else
                   (v1 div v2) -> res;
               if);
            #);
       #);
     
     CCalc2: @ICalc2
       (# QueryInterface::
            (# 
            #);
          AddRef::
            (# 
            #);
          Release::
            (# 
            #);
          Power::
            (# 
            #);
       #);
     
     CHello: @IHello
       (# QueryInterface::
            (# 
            #);
          AddRef::
            (# 
            #);
          Release::
            (# 
            #);
          World::
            (# 
            #);
       #);
     
  #) (* Calc *);

Conv: 
  (# 
     CConv: @IConv
       (# QueryInterface::
            (# 
            #);
          AddRef::
            (# 
            #);
          Release::
            (# 
            #);
          Hex2Dec::
            (# b: @BSTR; hex: ^text;
            do v -> b;
               b.gettext -> hex[];
               (if '0' -> hex.equal then
                   0 -> res;
                else
                   hex.reset;
                   hex.getHex -> res;
               if);
            #);
          Dec2Hex::
            (# hex: ^text;
            do '' -> hex[];
               (* PutHex uses zeropadding. We do not want that.
                * v -> hex.putHex;
                *)
               (16,v)->hex.putRadix(# do true->uppercase #);
            #);
       #);
  #);
