ORIGIN 'Deep_Thought';
INCLUDE '~beta/basiclib/numberio';
INCLUDE '~beta/win32lib/winerror';
--LIB: attributes--
BetaCoCreateInstance:
  (# theclsid: ^CLSID; 
     outer: ^IUnknown;
     flags: @int32;
     hr: @HRESULT;
     theiid: ^IID;
     pUnknown: ^IUnknown;
     theCalc: ^Calc;
     theConv: ^Conv;
     ppvObject: @IUnknownHolder;
     guid_conv, guid_calc: @GUID;
  enter (theclsid[], outer[], flags, theiid[])
  do (if outer[]=NONE then
         'outer NONE, fine.'->screen.putLine;
         Calc_CLSID -> guid_calc;
         (if theclsid[] -> guid_calc.equal then
             'classid matched, fine.'->screen.putLine;
             &Calc[] ->theCalc[];
             (theiid.binary[], ppvObject[]) -> theCalc.QueryIF -> hr;
             'QueryIF completed with hr='->screen.putText; 
             hr.value->screen.putInt; screen.newLine;
             (if hr.succeeded then
                 'iid matched, fine.'->screen.putLine;
                 ppvobject -> pUnknown[]
             if)
         if);
         Conv_CLSID -> guid_conv;
         (if theclsid[] -> guid_conv.equal then
             'classid matched, fine.'->screen.putLine;
             &Conv[] ->theConv[];
             (theiid.binary[], ppvObject[]) -> theConv.QueryIF -> hr;
             'QueryIF completed with hr='->screen.putText; 
             hr.value->screen.putInt; screen.newLine;
             (if hr.succeeded then
                 'iid matched, fine.'->screen.putLine;
                 ppvobject -> pUnknown[]
             if)
         if)
      else
         (* aggregation not handled yet? *)
     if);
     (if pUnknown[]=NONE then
         'BetaCoCreateInstance: cannot instantiate' -> putline;
     if);
  exit pUnknown[]
  #);

Calc: (* coclass *)
  (# Unknown_IID: ^IID;
     Calc_IID: ^IID;
     Calc2_IID: ^IID;
     Hello_IID: ^IID;
     ncalc: @integer;
     ncalc2: @integer;
     nhello: @integer;
     
     theCalc: ^CalcImpl;
     theCalc2: ^Calc2Impl;
     theHello: ^HelloImpl;
     
     init: (*Probably belongs in classfactory *)
       (# 
       do (if Unknown_IID[]=NONE then
              &IID[] -> Unknown_IID[];
              IUnknown_IID -> Unknown_IID;
          if);
          (if Calc_IID[]=NONE then
              &IID[] -> Calc_IID[];
              ICalc_IID -> Calc_IID;
          if);
          (if Calc2_IID[]=NONE then
              &IID[] -> Calc2_IID[];
              ICalc2_IID -> Calc2_IID;
          if);
          (if Hello_IID[]=NONE then
              &IID[] -> Hello_IID[];
              IHello_IID -> Hello_IID;
          if);
       #);
          
     QueryIF:
       (# result: @int32;
          xriid: ^GUIDdata; riid: @ guid;
          ppvObject: ^IUnknownHolder; 
       enter (xriid[], ppvObject[])
       do xriid[] -> riid.binary[];
          init;
          'QueryIF init done'->screen.putLine;
          Hello_IID -> screen.putLine;
          'QueryIF iid-print done 1'->screen.putLine;
          riid -> screen.putLine;
          'QueryIF iid-print done 2'->screen.putLine;
          
          (if true 
           // riid[] -> Unknown_IID.equal then
              (if theCalc[]=NONE then
                  &CalcImpl[] -> theCalc[]
              if);
              theCalc[] -> ppvObject;
           // riid[] -> Calc_IID.equal then
              'QueryIF matches Calc_IID'->screen.putLine;
              (if theCalc[]=NONE then
                  &CalcImpl[] -> theCalc[]
              if);
              'QueryIF instantiated CalcImpl'->screen.putLine;
              theCalc[] -> ppvObject;
              'QueryIF assigned to holder'->screen.putLine;
           // riid[] -> Hello_IID.equal then
              'QueryIF matches Hello_IID'->screen.putLine;
              (if theHello[]=NONE then
                  &HelloImpl[] -> theHello[];
              if);
              'QueryIF instantiated HelloImpl'->screen.putLine;
              theHello[] -> ppvObject;
              'QueryIF assigned to holder'->screen.putLine;
           // riid[] -> Calc2_IID.equal then
              (if theCalc2[]=NONE then
                  &Calc2Impl[] -> theCalc2[]
              if);
              theCalc2[] -> ppvObject;
           else
              'QueryIF: no Matching interface'->screen.putLine;
              NONE -> ppvObject;
              E_NOINTERFACE -> result;
              leave QueryIF;
          if);
          S_OK -> result;
          'QueryIF result S_OK'->screen.putLine;
          ppvObject.ref.AddRef;
          'QueryIF addRef done'->screen.putLine;
       exit result
       #);
     
     CalcImpl: ICalc
       (# QueryInterface::
            (# 
            do (riid[], ppvObject[]) -> QueryIF -> result;
            #);
          AddRef::
            (#
            do ncalc+1 -> ncalc -> result;
            #);
          Release::
            (# 
            do ncalc-1 -> ncalc -> result;
               (if ncalc=0 then
                   (* Could do some deallocation here *)
                   NONE -> theCalc[]; (* maybe? *)
               if);
            #);
          Add::
            (# do (v1 + v2) -> res #);
          Subtract::
            (# do (v1 - v2) -> res #);
          Multiply::
            (# do (v1 * v2) -> res #);
          Divide::
            (# 
            do (if v2 = 0 then 
                   0 -> res;
                   E_FAIL -> result;
                else
                   (v1 div v2) -> res;
               if);
            #);
          Modulus::
            (# 
            do (if v2 = 0 then 
                   0 -> res;
                   E_FAIL -> result;
                else
                   (v1 div v2) -> res;
               if);
            #);
       #);
     
     Calc2Impl: ICalc2
       (# QueryInterface::
            (# 
            do (riid[], ppvObject[]) -> QueryIF -> result;
            #);
          AddRef::
            (#
            do ncalc2+1 -> ncalc2 -> result;
            #);
          Release::
            (# 
            do ncalc2-1 -> ncalc2 -> result;
               (if ncalc2=0 then
                   (* Could do some deallocation here *)
                   NONE -> theCalc2[]; (* maybe? *)
               if);
            #);
          Power::
            (# 
            do E_FAIL -> result;
            #);
       #);
     
     HelloImpl: IHello
       (# QueryInterface::
            (# 
            do (riid[], ppvObject[]) -> QueryIF -> result;
            #);
          AddRef::
            (#
            do nhello+1 -> nhello -> result;
            #);
          Release::
            (# 
            do nhello-1 -> nhello -> result;
               (if nhello=0 then
                   (* Could do some deallocation here *)
                   NONE -> theHello[]; (* maybe? *)
               if);
            #);
          World::
            (# 
            do 'BETA calculator server: Hello, World!' -> res.setText;
            #);
       #);
     
  #) (* Calc *);

Conv: (* coclass *)
  (# Unknown_IID: ^IID;
     Conv_IID: ^IID;
     nconv: @integer;
     
     theConv: ^ConvImpl;
     
     init: (*Probably belongs in classfactory *)
       (# 
       do (if Unknown_IID[]=NONE then
              &IID[] -> Unknown_IID[];
              IUnknown_IID -> Unknown_IID;
          if);
          (if Conv_IID[]=NONE then
              &IID[] -> Conv_IID[];
              IConv_IID -> Conv_IID;
          if);
       #);
          
     QueryIF:
       (# result: @int32;
          xriid: ^GUIDdata; riid: @ guid;
          ppvObject: ^IUnknownHolder; 
       enter (xriid[], ppvObject[])
       do xriid[] -> riid.binary[];
          init;
          (if true 
           // riid[] -> Unknown_IID.equal then
              (if theConv[]=NONE then
                  &ConvImpl[] -> theConv[]
              if);
              theConv[] -> ppvObject;
           // riid[] -> Conv_IID.equal then
              'QueryIF matches Conv_IID'->screen.putLine;
              (if theConv[]=NONE then
                  &ConvImpl[] -> theConv[]
              if);
              'QueryIF instantiated ConvImpl'->screen.putLine;
              theConv[] -> ppvObject;
              'QueryIF assigned to holder'->screen.putLine;
           else
              'QueryIF: no Matching interface'->screen.putLine;
              NONE -> ppvObject;
              E_NOINTERFACE -> result;
              leave QueryIF;
          if);
          S_OK -> result;
          'QueryIF result S_OK'->screen.putLine;
          ppvObject.ref.AddRef;
          'QueryIF addRef done'->screen.putLine;
       exit result
       #);
     
     ConvImpl: IConv
       (# QueryInterface::
            (# 
            do (riid[], ppvObject[]) -> QueryIF -> result;
            #);
          AddRef::
            (#
            do nconv+1 -> nconv -> result;
            #);
          Release::
            (# 
            do nconv-1 -> nconv -> result;
               (if nconv=0 then
                   (* Could do some deallocation here *)
                   NONE -> theConv[]; (* maybe? *)
               if);
            #);
          Hex2Dec::
            (# b: @BSTR; hex: ^text;
            do v -> b;
               b.gettext -> hex[];
               (if '0' -> hex.equal then
                   0 -> res;
                else
                   hex.reset;
                   hex.getHex
                   (# noNumberError::
                        (# 
                        do 0 -> x;
                           E_FAIL -> result;
                           true -> continue;
                        #)
                   #)-> res;
               if);
            #);
          Dec2Hex::
            (# hex: ^text;
            do '' -> hex[];
               (* PutHex uses zeropadding. We do not want that.
                * v -> hex.putHex;
                *)
               (16,v)->hex.putRadix(# do true->uppercase #);
               hex[] -> res.setText;
            #);
       #);
  #);
