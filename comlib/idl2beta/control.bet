ORIGIN '~beta/basiclib/v1.6/betaenv';
INCLUDE '~beta/toollibs/utils/v1.0/fileExtensions';
INCLUDE '~beta/containers/v1.6/list';
BODY   'translate';
INCLUDE 'outfile';
INCLUDE 'idl_attributes';
--StreamLib: attributes--
Line:
  (# do '--------------------------------------------------------'->putline #);
--Lib: Attributes--
Control:
  (#
     Outfile: @OutputFile;
     Debug, trace, mps_trace, preserve, quiet: @boolean;
   
     StartOfFilenames: @integer; 
     aText: ^text;
     OutFileName, IdlFileName, Ifilename, Cfilename: ^text;
     
     textlist: list(# element::text #);
     defines: @textlist;
     holders: @textlist;
     refholders: @textlist;
     imports: @textlist;
     
     type_info:
       (# name: ^text;
          pointer_level: @integer;
          basic_type: ^text;
          comment: ^text;
          is_alias_for: ^type_info;
          attributes: ^idl_attributes;
       #);
     type_list: list
       (# element::type_info;
          outer_scope: ^type_list;
          findtype: 
            (# name: ^text;
               found: @boolean;
               current: ^element;
            enter name[]
            do find
               (# predicate::(# do (current.name[]->name.equal)->value #);
               do current[] -> THIS(findtype).current[];
                  INNER findtype; 
                  true -> found;
               #);
               (if (not found) and (outer_scope[]<>NONE) then
                   (* continue recursive search in outer_scope *)
                   name[] -> &outer_scope.findtype
                   (# do current[]->THIS(findtype).current[]; INNER findtype #)
               if);
            #);
          print:
            (# 
            do 'name    pointer basic   alias   attributes'-> putline;
               screen.line;
               scan
               (# 
               do (if current.name[]=NONE then
                      '<NONE>' -> puttext;
                   else
                      current.name[] -> puttext;
                  if);
                  '\t' -> puttext;
                  (for current.pointer_level repeat
                       '*' -> put;
                  for);
                  '\t' -> puttext;
                  (if current.basic_type[]<>NONE then
                      current.basic_type[] -> puttext;
                  if);
                  '\t' -> puttext;
                  (if current.is_alias_for[] <> NONE then
                      current.is_alias_for.name[] -> puttext;
                  if);
                  '\t' -> puttext;
                  (if current.attributes[]=NONE then
                      '<NONE>' -> puttext;
                   else
                      screen[] -> current.attributes.print;
                  if);
                  newline;
               #);
               screen.line;
            #);
       #);
     global_types: @type_list (* globally known types *);
     local_types: @type_list (* types local to current file *);
     
     declarator_info:
       (# name: ^text;
          type: ^type_info;
          attributes: ^idl_attributes;
          pointer_level: @integer;
       #);
     
     declarator_list: list
       (# element::declarator_info;
          findsym: find 
            (# name: ^text;
               predicate::(# do (current.name[]->name.equal)->value #);
            enter name[]
            do INNER
            #);
          print:
            (# 
            do '    name pointer type\tattributes' -> putline;
               '    '->puttext; screen.line;
               scan
               (# 
               do (if current.name[]=NONE then
                      '    <NONE>' -> puttext;
                   else
                      '    '->puttext;
                      current.name[] -> puttext;
                  if);
                  '\t ' -> puttext;
                  (for current.pointer_level repeat
                       '*' -> put;
                  for);
                  (for 8-current.pointer_level repeat
                       ' ' -> put;
                  for);
                  (if current.type[]=NONE then
                      '<NONE>' -> puttext;
                   else
                      current.type.name[] -> puttext;
                  if);
                  '\t' -> puttext;
                  (if current.attributes[]=NONE then
                      '<NONE>' -> puttext;
                   else
                      screen[] -> current.attributes.print;
                  if);
                  newline;
               #);
               '    '->screen.puttext; screen.line;
            #);
       #);
     
     symbols: @ 
       (* symbols (name,type) local to current function *)
       declarator_list;
     
  do global_types[] -> local_types.outer_scope[];
     block:
       (#
          Usage:(# 
                do 'Usage: ' -> putText; 1 -> Arguments -> putText;
                   ' [Options] [-o <name>] <filenames>' -> putLine;
                   '\nOptions:' -> putline;
                   '  -q' -> putline; 		   
                   '  --quiet\tBe quiet - emit only error messages' -> putline;
                   '  -p' -> putline; 		   
                   '  --preserve\tPreserve temporary files' -> putline;
                   '  -D name' -> putline;
                   '  --define name\tDefine preprocessor name' -> putline;
                   '\nDebug options:' -> putline;
                   '  -d' -> putline; 
                   '  --debug\tEnable debug of bidl' -> putline;
                   '  -t' -> putline; 
                   '  --trace\tEnable tracing of bidl' -> putline;
                   '  -T' -> putline; 
                   '  --mps_trace\tEnable tracing of mps' -> putline;
                #);
       do
          (if (NoOfArguments <= 1) then Usage; leave block if);
          2 -> StartOfFilenames;
          
          args: 
            (# 
            do StartOfFilenames -> Arguments -> aText[];    
               (if true 
                // ('-o' -> aText.Equal) then
                   (if (NoOfArguments <= StartOfFilenames+1) then 
                       Usage; leave block
                   if);      
                   StartOfFilenames+1 -> Arguments -> OutFileName[]; 
                   StartOfFilenames+2 -> StartOfFilenames;
                   restart args;
                // ('-D' -> aText.Equal) then
                   (if (NoOfArguments <= StartOfFilenames+1) then 
                       Usage; leave block
                   if);      
                   StartOfFilenames+1 -> Arguments -> defines.append; 
                   StartOfFilenames+2 -> StartOfFilenames;
                   restart args;
                // ('-p' -> aText.equal)
                // ('--preserve' -> aText.equal) then 
                   true -> preserve;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart args;
                // ('-q' -> aText.equal)
                // ('--quiet' -> aText.equal) then 
                   true -> quiet;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart args;
                // ('-d' -> aText.equal)  
                // ('--debug' -> aText.equal) then 
                   true -> debug;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart args;
                // ('-t' -> aText.equal)  
                // ('--trace' -> aText.equal) then 
                   true -> trace;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart args;
                // ('-T' -> aText.equal)  
                // ('--mps_trace' -> aText.equal) then 
                   true -> mps_trace;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart args;
               if);
            #);
          
          (if StartOfFilenames>NoOfArguments then
              Usage; leave block;
          if);
          
          (if not quiet then 'IDL to BETA translator.' -> putLine; if);
          
          (# type: ^type_info;
          do (* Add types from comlib.bet to symbol table *)
             &type_info[] -> type[] -> global_types.append;
             'HRESULT' -> type.name[] -> type.basic_type[];
          #);
        
          process_files:
            (# 
            do 
               StartOfFilenames -> Arguments -> IdlFileName[];
               '.idl' -> IdlFileName.appendExtension;
               '.idl' -> IdlFileName.appendExtension;
          
               (if OutFileName[]=NONE then
                   IdlFileName.copy -> OutFileName[];
                   '.idl' -> OutFileName.stripExtension;
                   (* Prevent identically named ast files: 
                    * NOT needed anymore, since the ast file for
                    * the IDL is not saved.
                    *)
                   (* '-beta' -> OutFileName.append; *)
                   '.bet' -> OutFileName.append;
               if);
               IdlFileName.copy -> IFilename[];
               '.idl' -> IFileName.stripExtension;
               '.i' -> IFileName.appendExtension;
               IdlFileName.copy -> CFilename[];
               '.idl' -> CFileName.stripExtension;
               '.c' -> CFileName.appendExtension;

               
               OutFileName[] -> Outfile.Name;
               Outfile.OpenWrite;
               IdlFileName[] -> Outfile.Identification; 
               <<SLOT Translate:descriptor>>;
               Outfile.Epilog;
               Outfile.Close;
               (if debug then
                   newline;
                   'Trace: Global types:'->putline;
                   screen.line;
                   global_types.print;
                   'Trace: Local types for file '->puttext;
                   IdlFileName[] -> puttext;
                   ':' -> putline;
                   screen.line;
                   local_types.print;
               if);
               
               StartOfFilenames+1 -> StartOfFilenames;
               (if StartOfFilenames<=NoOfArguments then
                   NONE -> OutFileName[];
                   restart process_files;
               if);
            #);
       #)
  #);
