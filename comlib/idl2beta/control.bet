ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/toollibs/utils/fileExtensions';
INCLUDE '~beta/containers/list';
INCLUDE 'idlsematt';
INCLUDE 'mpsadditions';
BODY   'translate';
BODY   'symboltable';
INCLUDE 'outfile';
INCLUDE 'idl_attributes';

--StreamLib: attributes--
Line:
  (# 
  do '------------------------------------------------------------------'
       ->putline
  #);

--Lib: Attributes--
Control:
  (#
     BobsTab: (# exit '$(BETALIB)/grammars/idl/idl-parser.btab' #);
     
     (* Standalone parsing can be done as such:
      * ~beta/bobs/parse ~beta/grammars/idl/idl-parser.btab foo.idl -case -ceol
      *)
     
     ast: @astInterface
       (* An instance of the AST interface *)
       (# defaultGrammarFinder:: findGrammar #);
     
     idl: @ast.idl; (* The MPS interface to the BETA grammar/ASTs *)
   
     Outfile: @OutputFile;
     Debug, trace, mps_trace, preserve, verbose, quiet, mute, 
     errorwarnings, force, chain: @boolean;
   
     StartOfFilenames: @integer; 
     aText: ^text;
     OutFileName, IdlFileName, PreviousFile, HeadOfIdlFileName, Ifilename, Cfilename: ^text;
     
     textlist: list
       (# element::text;
          add:<
            (# name: ^text;
            enter name[]
            do find(# predicate:: (# do current[]->name.equalNCS->value #);
                      notfound:: (# do name[]->append; #)
                   #);
               INNER add;
            #);
       #);
     includepaths: @textlist;
     defines: @textlist;
     holders: @textlist;
     refholders: @textlist;
     imports: @textlist
       (* (# add::
        *    (#
        *    do 'imports: added: '-> screen.puttext;
        *       name[] -> screen.putline;
        *    #)
        * #);
        *);
     files_remaining: @textlist
       (* (# add::
        *    (#
        *    do 'files_remaining: added: '-> screen.puttext;
        *       name[] -> screen.putline;
        *    #)
        * #);
        *);
     propputs: @textlist;
     propgets: @textlist;
     
     type_cat_basic:     (# exit 1 #);
     type_cat_struct:    (# exit 2 #);
     type_cat_enum:      (# exit 3 #);
     type_cat_union:     (# exit 4 #);
     type_cat_user:      (# exit 5 #);
     type_cat_interface: (# exit 6 #);
     
     type_info:
       (# as_text:
            (# t: ^text;
            do &text[] -> t[];
               (for pointer_level repeat '*' -> t.put for);
               (if name[]<>NONE then
                   name[] -> t.append;
                else
                   '<NONE>' -> t.append;
               if);
            exit t[]
            #);
          name: ^text;
          pointer_level: @integer;
          representation: ^text;
          comment: ^text;
          category: @integer;
          attributes: ^idl_attributes;
       #);
     type_list: list
       (# element::type_info;
          outer_scope: ^type_list;
          findtype: 
            (# name: ^text;
               found: @boolean;
               current: ^element;
            enter name[]
            <<SLOT type_list_findtype: dopart>>
            #);
          add_basic_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_basic_type: dopart>>
            exit type[]
            #);
          add_interface_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_interface_type: dopart>>
            exit type[]
            #);
          add_basic_pointer_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_basic_pointer_type: dopart>>
            exit type[]
            #);
          add_user_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_user_type: dopart>>
            exit type[]
            #);
          add_union_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_union_type: dopart>>
            exit type[]
            #);
          add_struct_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_struct_type: dopart>>
            exit type[]
            #);
          print:
            (# 
            <<SLOT type_list_print: dopart>>
            #);
       #);
     global_types: @type_list(* globally known types *);
     local_types: @type_list(* types local to current file *);
     
     declarator_info:
       (# as_text:
            (# t: ^text;
            do &text[] -> t[];
               (for pointer_level repeat '*' -> t.put for);
               (if type[]<>NONE then
                   type.name[] -> t.append;
                else
                   '<NONE>' -> t.append;
               if);
            exit t[]
            #);
          name: ^text;
          type: ^type_info;
          type_comment: ^text;
          attributes: ^idl_attributes;
          pointer_level: @integer;
       #);
     
     declarator_list: list
       (# element::declarator_info;
          findsym: find 
            (# name: ^text;
               predicate::(# do (current.name[]->name.equal)->value #);
               notfound::
                 (# msg: ^text
                 do 'declarator_list: not found: '->msg[]; 
                    name[] -> msg.append;
                    msg[] -> error_report;
                 #);
            enter name[]
            do INNER
            #);
          print:
            (# 
            <<SLOT declarator_list_print: dopart>>
            #);
       #);
     
     symbols: @ 
       (* symbols (name,type) local to current function *)
       declarator_list;
     
     CheckForReservedWord:
       (# word: ^text
       enter word[]
       <<SLOT CheckForReservedWord: dopart>>
       exit word[]
       #);
     
     error:
       (# msg: ^text
       enter msg[]
       do (if not mute then
              '    *** Error: ' -> screen.puttext;
              msg[] -> screen.putline;
          if);
       #);
     error_report: (* alias *)(# enter error #);
     
     warning:
       (# msg: ^text
       enter msg[]
       do (if errorwarnings then 
              msg[] -> error
           else
              (if not quiet then
                  '    *** Warning: ' -> screen.puttext;
                  msg[] -> screen.putline;
              if)
          if);
       #);
     
     
  do (* Control *)
     global_types[] -> local_types.outer_scope[];
     block:
       (#
          Usage:(# 
                do 'Usage: ' -> putText; 1 -> Arguments -> putText;
                   ' [Options] [-o <name>] <filename>' -> putLine;
                   '\nOptions:' -> putline;
                   '  -c' -> putline; 		   
                   '  --chain        \tChain ORIGINs.' -> putline;
                   '  -e' -> putline; 		   
                   '  --errorwarnings\tMake warnings become errors.' -> putline;
                   '  -f' -> putline; 		   
                   '  --force        \tForce generation of BETA files.' -> putline;
                   '  -v' -> putline; 		   
                   '  --verbose      \tPrint verbose info on progress' -> putline;
                   '  -q' -> putline; 		   
                   '  --quiet        \tBe quiet - print minimal output, like files opened, ' -> putline;
                   '                 \terror messages (but not warnings)' -> screen.putline;
                   '  -m' -> putline; 		   
                   '  --mute         \tBe absolutely quiet - print nothing' -> putline;
                   '  -p' -> putline; 		   
                   '  --preserve     \tPreserve temporary files' -> putline;
                   '  -D name' -> putline;
                   '  --define name  \tDefine preprocessor name' -> putline;
                   '  -I path' -> putline;
                   '  --include path \tAdd path to list of paths known by preprocessor' -> putline;
                   '\nDebug options:' -> putline;
                   '  -d' -> putline; 
                   '  --debug        \tEnable debug of bidl' -> putline;
                   '  -t' -> putline; 
                   '  --trace        \tEnable tracing of bidl' -> putline;
                   '  -T' -> putline; 
                   '  --mps_trace    \tEnable tracing of mps' -> putline;
                #);
          
          InitAstEnv:
            
            (* Initialization of the meta programming system *)
            (# parser_entry, bidl_entry: @diskentry;
            do 
	       (if debug and mps_trace then
                   (ast.trace.topOpen,true) -> ast.trace.set;
                   (ast.trace.fragmentOpen,true) -> ast.trace.set;
                   (ast.trace.grammars,true) -> ast.trace.set;
                   (ast.trace.compactOpen,true) -> ast.trace.set;
                   (ast.trace.onParse,true) -> ast.trace.set;
                   (ast.trace.parser,true) -> ast.trace.set;
                   (ast.trace.getBinding,true) -> ast.trace.set;
                   (ast.trace.getBindingMark,true) -> ast.trace.set;
               if);
               BobsTab -> ast.expandToFullPath -> parser_entry.path;
               1 -> Arguments -> bidl_entry.path;
               (* FIXME: the stuff below fails on NTI *)
               (if false then
                   (if bidl_entry.modtime < parser_entry.modtime then
                       'Parser is newer than bidl executable - recompile bidl!'
                         -> screen.putline;
                       stop;
                   if);
               if);
	       ast.astLevelInit;
               idl.init; 
	       parser_entry.path -> idl.parser.initialize
               (# EOLasComEnd::(# do true->value #);
                  caseSensitive::(# do true->value #);
               #);
            #);
          
       do
          (if (NoOfArguments <= 1) then Usage; leave block if);
          2 -> StartOfFilenames;
          
          args: 
            (# 
            do StartOfFilenames -> Arguments -> aText[];    
               (if true 
                // ('-o' -> aText.Equal) then
                   (if (NoOfArguments <= StartOfFilenames+1) then 
                       Usage; leave block
                   if);      
                   StartOfFilenames+1 -> Arguments -> OutFileName[]; 
                   StartOfFilenames+2 -> StartOfFilenames;
                   restart args;
                // ('-D' -> aText.Equal) then
                // ('--define' -> aText.Equal) then
                   (if (NoOfArguments <= StartOfFilenames+1) then 
                       Usage; leave block
                   if);      
                   StartOfFilenames+1 -> Arguments -> defines.append; 
                   StartOfFilenames+2 -> StartOfFilenames;
                   restart args;
                // ('-I' -> aText.Equal) then
                // ('--include' -> aText.Equal) then
                   (if (NoOfArguments <= StartOfFilenames+1) then 
                       Usage; leave block
                   if);      
                   StartOfFilenames+1 -> Arguments -> includepaths.append; 
                   StartOfFilenames+2 -> StartOfFilenames;
                   restart args;
                // ('-p' -> aText.equal)
                // ('--preserve' -> aText.equal) then 
                   true -> preserve;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart args;
                // ('-e' -> aText.equal)
                // ('--errorwarnings' -> aText.equal) then 
                   true -> errorwarnings;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart args;
                // ('-f' -> aText.equal)
                // ('--force' -> aText.equal) then 
                   true -> force;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart args;
                // ('-c' -> aText.equal)
                // ('--chain' -> aText.equal) then 
                   true -> chain;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart args;
                // ('-q' -> aText.equal)
                // ('--quiet' -> aText.equal) then 
                   true -> quiet; false -> verbose -> mute;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart args;
                // ('-v' -> aText.equal)
                // ('--verbose' -> aText.equal) then 
                   true -> verbose;
                   false -> quiet -> mute;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart args;
                // ('-m' -> aText.equal)
                // ('--mute' -> aText.equal) then 
                   true -> mute -> quiet;
                   false -> verbose;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart args;
                // ('-d' -> aText.equal)  
                // ('--debug' -> aText.equal) then 
                   true -> debug -> verbose;
                   false -> quiet -> mute;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart args;
                // ('-t' -> aText.equal)  
                // ('--trace' -> aText.equal) then 
                   true -> trace;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart args;
                // ('-T' -> aText.equal)  
                // ('--mps_trace' -> aText.equal) then 
                   true -> mps_trace;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart args;
               if);
            #);
          
          (if StartOfFilenames<>NoOfArguments then
              (* Temporarily only allowing one file, since all 
               * files must know each other's types because of
               * the need to split up large file (AST overflow).
               *)
              Usage; leave block;
          if);
          
          (if not quiet then 'IDL to BETA translator.' -> putLine; if);
          
          <<SLOT add_basic_types: descriptor>>;
          
          collect_files:
            (# 
            do (if StartOfFilenames<=NoOfArguments then
                   StartOfFilenames -> Arguments -> files_remaining.add;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart collect_files;
               if)
            #);
          
          process_files:
            (# idl_entry, beta_entry: @diskentry;
            do 
               (if files_remaining.empty then leave process_files if);
               (files_remaining.head -> files_remaining.delete).elm[]
                 -> IdlFileName[];
               
               InitAstEnv;
               (if debug then 'With DEBUG.' -> screen.putline; 
                   false -> quiet;
                   'Using parser: ' -> screen.puttext;
                   BobsTab -> screen.putline;
               if);
               (if trace then 'With TRACE.' -> screen.putline; 
                   false -> quiet -> mute;
               if);
               
               '.idl' -> IdlFileName.appendExtension;
               
               (* First check that IDL file is there *)
               IdlFileName[] -> idl_entry.path;
               (if not idl_entry.exists then
                   (if not quiet then
                       '    [IDL file \'' -> screen.puttext;
                       idl_entry.path -> screen.puttext;
                       '\' does not exist; skipped]' -> screen.putline;
                   if);
                   restart process_files;
               if);
          
               (if OutFileName[]=NONE then
                   IdlFileName.copy -> OutFileName[];
                   '.idl' -> OutFileName.stripExtension;
                   (* Prevent identically named ast files: 
                    * NOT needed anymore, since the ast file for
                    * the IDL is not saved.
                    *)
                   (* '-beta' -> OutFileName.append; *)
                   '.bet' -> OutFileName.append;
               if);
               IdlFileName.copy -> IFilename[];
               '.idl' -> IFileName.stripExtension;
               '.i' -> IFileName.appendExtension;
               IdlFileName.copy -> CFilename[];
               '.idl' -> CFileName.stripExtension;
               '.c' -> CFileName.appendExtension;
               
               
               OutFileName[] -> Outfile.Name;
               (*'opening ' -> screen.puttext; Outfile.Name -> screen.putline;*)
	       (if not mute then
                   'Processing '''->screen.puttext; 
	           (IdlFileName[], '') -> ast.thePathhandler.localpath 
                     -> screen.puttext; 
	           '''...'->screen.putline;
               if);
               
               idl_entry.path.head -> HeadOfIdlFileName[];
               (if HeadOfIdlFileName.length>0 then
                   directorychar -> HeadOfIdlFileName.put;
               if);
               (* We do not use top.open, since this enforces fragment
                * syntax on the source files. And we would like to be able to
                * use the IDL files "as-is", without modification.
                * This means, that we will have to do the following ourselves:
                *    dependency analysis
                *    include handling 
                *)
               (if not force then
                   (* Check if .bet file needs to be generated *)
                   OutFileName[] -> beta_entry.path;
                   (if beta_entry.exists then
                       (if beta_entry.modtime>idl_entry.modtime then
                           (if not quiet then
                               '    [BETA file is up-to-date; skipped]' 
                                 -> screen.putline
                           if);
                           restart process_files;
                       if)
                   if);
               if);
               
               <<SLOT Translate:descriptor>>;
               
               (if chain and (IdlFileName[]<>NONE) then
                   IdlFileName.copy -> PreviousFile[];
                   (PreviousFile[], HeadOfIdlFileName[]) 
                     -> ast.thePathHandler.localpath 
                     -> PreviousFile[];
                   '.idl' -> PreviousFile.stripExtension;
               if);
               
               (if debug then
                   newline;
                   'Trace: Global types:'->putline;
                   screen.line;
                   global_types.print;
                   'Trace: Local types for file '->puttext;
                   IdlFileName[] -> puttext;
                   ':' -> putline;
                   screen.line;
                   local_types.print;
               if);
               
               NONE -> OutFileName[];
               restart process_files;
            #);
       #)
  #);
