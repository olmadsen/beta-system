ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/toollibs/utils/fileExtensions';
INCLUDE '~beta/containers/list';
INCLUDE 'idlsematt';
INCLUDE 'mpsadditions';
BODY   'translate';
BODY   'symboltable';
BODY   'private/controlbody';
INCLUDE 'outfile';
INCLUDE 'idl_attributes';

--StreamLib: attributes--
Line:
  (# 
  do '------------------------------------------------------------------'
       ->putline
  #);

--Lib: Attributes--
Control:
  (#
     BobsTab: (# exit '$(BETALIB)/grammars/idl/idl-parser.btab' #);
     
     (* Standalone parsing can be done as such:
      * ~beta/bobs/parse ~beta/grammars/idl/idl-parser.btab foo.idl -case -ceol
      *)
     
     ast: @astInterface
       (* An instance of the AST interface *)
       (# defaultGrammarFinder:: findGrammar #);
     
     idl: @ast.idl; (* The MPS interface to the BETA grammar/ASTs *)
     
     Debug, trace, mps_trace, preserve, verbose, quiet, mute, 
     nowarnings, errorwarnings, force, forceall, chain, compact: @boolean;
   
     StartOfFilenames: @integer; 
     last_include: ^text;
     IdlFileName, PreviousFile: ^text;
     
     global_types: @type_list(* globally known types *);
     
     imported_types: ^type_list(* points to type_list of last imported file *);
     
     textlist: list
       (# element::text;
          add:<
            (# name: ^text;
            enter name[]
            do find(# predicate:: (# do current[]->name.equalNCS->value #);
                      notfound:: (# do name[]->append; #)
                   #);
               INNER add;
            #);
       #);
     includepaths: @textlist;
     defines: @textlist;
     files_remaining: @textlist
       (* (# add::
        *    (#
        *    do 'files_remaining: added: '-> screen.puttext;
        *       name[] -> screen.putline;
        *    #)
        * #);
        *);
     
     type_cat_basic:     (# exit 1 #);
     type_cat_struct:    (# exit 2 #);
     type_cat_enum:      (# exit 3 #);
     type_cat_union:     (# exit 4 #);
     type_cat_user:      (# exit 5 #);
     type_cat_interface: (# exit 6 #);
     
     type_info:
       (# as_text:
            (# t: ^text;
            do (if name[]<>NONE then
                   &text[] -> t[];
                   (for pointer_level repeat '*' -> t.put for);
                   name[] -> t.append;
               if);
            exit t[]
            #);
          name: ^text;
          pointer_level: @integer;
          representation: ^text;
          comment: ^text;
          category: @integer;
          attributes: ^idl_attributes;
       #);
     type_list: list
       (# name: ^text (* identification for debug/trace purposes *);
          element::type_info;
          outer_scope: ^type_list;
          findtype: 
            (# name: ^text;
               found: @boolean;
               current: ^element;
            enter name[]
            <<SLOT type_list_findtype: dopart>>
            #);
          add_basic_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_basic_type: dopart>>
            exit type[]
            #);
          add_interface_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_interface_type: dopart>>
            exit type[]
            #);
          add_basic_pointer_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_basic_pointer_type: dopart>>
            exit type[]
            #);
          add_user_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_user_type: dopart>>
            exit type[]
            #);
          add_union_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_union_type: dopart>>
            exit type[]
            #);
          add_struct_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_struct_type: dopart>>
            exit type[]
            #);
          print:
            (# 
            <<SLOT type_list_print: dopart>>
            #);
       #);
     
     declarator_info:
       (# as_text:
            (# t: ^text;
            do (if type[]<>NONE then
                   &text[] -> t[];
                   (for pointer_level repeat '*' -> t.put for);
                   type.name[] -> t.append;
               if);
            exit t[]
            #);
          name: ^text;
          type: ^type_info;
          type_comment: ^text;
          attributes: ^idl_attributes;
          pointer_level: @integer;
       #);
     
     declarator_list: list
       (# element::declarator_info;
          findsym: find 
            (# name: ^text;
               predicate::(# do (current.name[]->name.equal)->value #);
               notfound::
                 (# msg: ^text
                 do 'declarator_list: not found: '->msg[]; 
                    name[] -> msg.append;
                    msg[] -> error_report;
                 #);
            enter name[]
            do INNER
            #);
          print:
            (# 
            <<SLOT declarator_list_print: dopart>>
            #);
       #);
          
     CheckForReservedWord:
       (# word: ^text
       enter word[]
       <<SLOT CheckForReservedWord: dopart>>
       exit word[]
       #);
     
     notice:
       (# msg: ^text
       enter msg[]
       do (if verbose then
              '    *** Notice: ' -> screen.puttext;
              msg[] -> screen.putline;
          if);
       #);
     
     error:
       (# msg: ^text
       enter msg[]
       do (if not mute then
              '    *** Error: ' -> screen.puttext;
              msg[] -> screen.putline;
          if);
       #);
     error_report: (* alias *)(# enter error #);
     
     warning:
       (# msg: ^text
       enter msg[]
       do (if errorwarnings then 
              msg[] -> error
           else
              (if (not nowarnings) and (not quiet) then
                  '    *** Warning: ' -> screen.puttext;
                  msg[] -> screen.putline;
              if)
          if);
       #);
     
     
  do (* Control *)
     'Global Types' -> global_types.name[];
     global_types[] -> imported_types[];
     block:
       (#
          Usage: 
            <<SLOT Usage: descriptor>>;
          InitAstEnv:
            (* Initialization of the meta programming system *)
            <<SLOT InitAstEnv: descriptor>>;
       do
          (if (NoOfArguments <= 1) then Usage; leave block if);
          2 -> StartOfFilenames;
          
          <<SLOT CollectArguments: descriptor>>;
          
          (if StartOfFilenames<>NoOfArguments then
              (* Temporarily only allowing one file, since all 
               * files must know each other's types because of
               * the need to split up large file (AST overflow).
               *)
              Usage; leave block;
          if);
          
          (if not quiet then 'IDL to BETA translator.' -> putLine; if);

          (if debug then 'With DEBUG.' -> screen.putline; 
              false -> quiet;
              'Using parser: ' -> screen.puttext;
              BobsTab -> screen.putline;
          if);
          (if trace then 'With TRACE.' -> screen.putline; 
              false -> quiet -> mute;
          if);
                         
          <<SLOT add_basic_types: descriptor>>;
          
          collect_files:
            (* Currently only collects one file *)
            (# 
            do (if StartOfFilenames<=NoOfArguments then
                   StartOfFilenames -> Arguments -> files_remaining.add;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart collect_files;
               if)
            #);
          
          process_files:
            (# 
            do 
               (if files_remaining.empty then leave process_files if);
               (files_remaining.head 
                 -> files_remaining.delete).elm[]
                 -> IdlFileName[];
               
               '.idl' -> IdlFileName.appendExtension;
               
              
               (if debug then
                   newline;
                   'Trace: Global types:'->putline;
                   screen.line;
                   global_types.print;
               if);
               
               <<SLOT Translate:descriptor>>;
               
               restart process_files;
            #);
       #)
  #);
