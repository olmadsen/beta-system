ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/toollibs/utils/fileExtensions';
INCLUDE '~beta/containers/list';
INCLUDE 'idlsematt';
INCLUDE 'mpsadditions';
BODY   'translate';
BODY   'symboltable';
BODY   'private/controlbody';
INCLUDE 'outfile';
INCLUDE 'idl_attributes';

--StreamLib: attributes--
Line:
  (# 
  do '------------------------------------------------------------------'
       ->putline
  #);

--Lib: Attributes--
Control:
  (#
     BobsTab: (# exit '$(BETALIB)/grammars/idl/idl-parser.btab' #);
     
     (* Standalone parsing can be done as such:
      * ~beta/bobs/parse ~beta/grammars/idl/idl-parser.btab foo.idl -case -ceol
      *)
     
     ast: @astInterface
       (* An instance of the AST interface *)
       (# (* No need to bind findGrammar - we do it ourselves. See
           * call of registerGrammer below.
           * And thus no need to specify IDL grammer in MBSgrammars.text.
           *)
          (*defaultGrammarFinder:: findGrammar*)
       #);
     
     idl: @ast.idl; (* The MPS interface to the BETA grammar/ASTs *)
     
     Debug, trace, mps_trace, preserve, verbose, quiet, mute, 
     nowarnings, errorwarnings, force, forceall, chain (* obsolete *), compact, lowqua: @boolean;
   
     StartOfFilenames: @integer; 
     last_include: ^text;
     IdlFileName, PreviousFile: ^text;
     
     global_types: @type_list(* globally known types *);
     
     imported_types: ^type_list(* points to type_list of last imported file *);
     
     textlist: list
       (# element::text;
          add:<
            (# name: ^text;
            enter name[]
            do find(# predicate:: (# do current[]->name.equalNCS->value #);
                      notfound:: (# do name[]->append; #)
                   #);
               INNER add;
            #);
       #);
     includepaths: @textlist;
     processed_files: @textlist;
     defines: @textlist;
     files_remaining: @textlist
       (* (# add::
        *    (#
        *    do 'files_remaining: added: '-> screen.puttext;
        *       name[] -> screen.putline;
        *    #)
        * #);
        *);
     
     type_cat_basic:     (# exit 1 #);
     type_cat_struct:    (# exit 2 #);
     type_cat_enum:      (# exit 3 #);
     type_cat_union:     (# exit 4 #);
     type_cat_user:      (# exit 5 #);
     type_cat_interface: (# exit 6 #);
     
     type_info:
       (# as_text:
            (# t: ^text;
            do (if name[]<>NONE then
                   &text[] -> t[];
                   name[] -> t.puttext;
                   (for pointer_level repeat '*' -> t.put for);
               if);
            exit t[]
            #);
          print: 
            <<SLOT type_info_print: descriptor>>;
          name: ^text;
          pointer_level: @integer;
          representation: ^text;
          comment: ^text;
          category: @integer;
          attributes: ^idl_attributes;
       #);
     notfound_descriptor:
       (# name: ^text (* name of type not found *);
          type: ^type_info (* instantiated type *)
       enter name[]
       do INNER
       exit type[]
       #);
     type_list: list
       (# name: ^text (* identification for debug/trace purposes *);
          element::type_info;
          append: 
            (# elm: ^element;
               msg: ^text;
               report: @boolean;
            enter elm[]
            do (* A few predefined types may NOT be redefined by typedefs.
                * We need to treat them specially.
                * Except for types defined in global types 
                * - we really mean it there! (:-)
                *)
               (if (THIS(type_list)[]<>global_types[]) then
                   (if true
                    // ('HRESULT' -> elm.name.equal) 
                    // ('VARIANT' -> elm.name.equal) 
                    // ('BSTR' -> elm.name.equal) 
                    // ('GUID' -> elm.name.equal) 
                    // ('CLSID' -> elm.name.equal) 
                    // ('IID' -> elm.name.equal) 
                       then
                       (if not quiet then
                           'Skipped definition of type \'' -> msg[];
                           elm.name[] -> msg.puttext;
                           '\'' -> msg.puttext;
                           msg[] -> warning;
                       if);
                       leave append;
                   if);
               if);
               (THIS(type_list)[]<>global_types[]) and (verbose) 
                 -> report;
               (if debug then
                   'Appending type for ' -> screen.puttext;
                   THIS(type_list).name[] -> screen.putline;
                   elm.print;
               if);
               (if report then
                   '    [type ' -> screen.puttext;
                   elm.name[] -> screen.puttext;
                   ': '-> screen.puttext;
                   elm.representation[] -> screen.puttext;
                   (for i: elm.pointer_level repeat '*' -> screen.put for);
                   (if elm.category
                    // type_cat_basic then ' (basic)' -> screen.puttext;
                    // type_cat_struct then ' (struct)' -> screen.puttext;
                    // type_cat_enum then ' (enum)' -> screen.puttext;
                    // type_cat_union then ' (union)' -> screen.puttext;
                    // type_cat_user then ' (user)' -> screen.puttext;
                    // type_cat_interface then ' (interface)'->screen.puttext;
                    else 
                       ' (' -> screen.puttext;
                       elm.category -> screen.putint;
                       ')' -> screen.put;
                   if);
                   (* Check if it is already there - if so: delete it *)
                   find
                   (# predicate::(# do (current.name[]->elm.name.equal)->value #);
                   do current[] -> at -> delete;
                      (if report then
                          '; redefinition' -> screen.puttext;
                      if);
                   #);
                   (if report then
                       ']' -> screen.putline;
                   if);
               if);
               elm[] -> THIS(list).append;
            #);
          outer_scope: ^type_list;
          findtype: 
            (# name: ^text;
               found: @boolean;
               current: ^element;
               notfound_object: ^notfound_descriptor;
               notfound:
                 (# 
                 do (if notfound_object[]<>NONE then
                        name[] -> notfound_object -> current[];
                        NONE -> notfound_object[];
                     else
                        <<SLOT FindTypeNotFound: descriptor>>
                    if);
                 #);
            enter (name[],notfound_object[])
            <<SLOT type_list_findtype: dopart>>
            #);
          findtypeNCS: 
            (# name: ^text;
               found: @boolean;
               current: ^element;
            enter (name[])
            <<SLOT type_list_findtypeNCS: dopart>>
            exit found
            #);
          add_basic_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_basic_type: dopart>>
            exit type[]
            #);
          add_interface_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_interface_type: dopart>>
            exit type[]
            #);
          add_basic_pointer_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_basic_pointer_type: dopart>>
            exit type[]
            #);
          add_user_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_user_type: dopart>>
            exit type[]
            #);
          add_union_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_union_type: dopart>>
            exit type[]
            #);
          add_struct_type:
            (# name: ^text;
               representation: ^text;
               type: ^type_info;
            enter (name[], representation[])
            <<SLOT type_list_add_struct_type: dopart>>
            exit type[]
            #);
          print:
            (# 
            <<SLOT type_list_print: dopart>>
            #);
       #);
     
     declarator_info:
       (# as_text:
            (# t: ^text;
            do (if type[]<>NONE then
                   type.as_text -> t[];
                   (if t[]<>NONE then
                       (for pointer_level repeat '*' -> t.put for);
                   if);
               if);
            exit t[]
            #);
          name: ^text;
          type: ^type_info;
          type_comment: ^text;
          attributes: ^idl_attributes;
          pointer_level: @integer;
       #);
     
     declarator_list: list
       (# element::declarator_info;
          findsym: find 
            (# name: ^text;
               predicate::(# do (current.name[]->name.equal)->value #);
               notfound::
                 (# msg: ^text
                 do 'declarator_list: not found: '->msg[]; 
                    name[] -> msg.append;
                    msg[] -> error_report;
                 #);
            enter name[]
            do INNER
            #);
          print:
            (# 
            <<SLOT declarator_list_print: dopart>>
            #);
       #);
          
     CheckForReservedWord:
       (# word: ^text
       enter word[]
       <<SLOT CheckForReservedWord: dopart>>
       exit word[]
       #);
     
     notice:
       (# msg: ^text
       enter msg[]
       do (if verbose then
              '    *** Notice: ' -> screen.puttext;
              msg[] -> screen.putline;
          if);
       #);
     
     error:
       (# msg: ^text
       enter msg[]
       do (if not mute then
              '    *** Error: ' -> screen.puttext;
              msg[] -> screen.putline;
          if);
       exit msg[] (* to allow putting into output too *)
       #);
     error_report: (* alias *)(# enter error #);
     
     warning:
       (# msg: ^text
       enter msg[]
       do (if errorwarnings then 
              msg[] -> error
           else
              (if (not nowarnings) and (not quiet) then
                  '    *** Warning: ' -> screen.puttext;
                  msg[] -> screen.putline;
              if)
          if);
       exit msg[] (* to allow putting into output too *)
       #);
     
     
  do (* Control *)
     '__midl' -> defines.append;
     'bidl' -> defines.append;
     'Global Types' -> global_types.name[];
     global_types[] -> imported_types[];
     block:
       (#
          Usage: 
            <<SLOT Usage: descriptor>>;
          InitAstEnv:
            (* Initialization of the meta programming system *)
            <<SLOT InitAstEnv: descriptor>>;
       do
          (if (NoOfArguments <= 1) then Usage; leave block if);
          2 -> StartOfFilenames;
          
          <<SLOT CollectArguments: descriptor>>;
          
          (if StartOfFilenames<>NoOfArguments then
              (* Temporarily only allowing one file, since all 
               * files must know each other's types because of
               * the need to split up large file (AST overflow).
               *)
              Usage; leave block;
          if);
          
          (if not quiet then 'IDL to BETA translator.' -> putLine; if);

          (if debug then 'With DEBUG.' -> screen.putline; 
              false -> quiet;
              'Using parser: ' -> screen.puttext;
              BobsTab -> screen.putline;
          if);
          (if trace then 'With TRACE.' -> screen.putline; 
              false -> quiet -> mute;
          if);
                         
          <<SLOT add_basic_types: descriptor>>;
          
          collect_files:
            (* Currently only collects one file *)
            (# 
            do (if StartOfFilenames<=NoOfArguments then
                   StartOfFilenames -> Arguments -> files_remaining.add;
                   StartOfFilenames+1 -> StartOfFilenames;
                   restart collect_files;
               if)
            #);
          
          process_files:
            (# 
            do 
               (if files_remaining.empty then leave process_files if);
               (files_remaining.head 
                 -> files_remaining.delete).elm[]
                 -> IdlFileName[];
               
               '.idl' -> IdlFileName.appendExtension;
               
              
               (if debug then
                   newline;
                   'Trace: Global types:'->putline;
                   screen.line;
                   global_types.print;
               if);
               
               <<SLOT Translate:descriptor>>;
               
               restart process_files;
            #);
       #)
  #);
