ORIGIN '../translate';
INCLUDE '~beta/basiclib/file';
MDBODY nti 'preprocess_ntibody'
default 'preprocess_unixbody';

--TranslateLib: attributes--

report:
  (# cmd: ^text
  enter cmd[]
  do (if not quiet then
         '    [' -> screen.puttext; 
         cmd[] -> screen.puttext; 
         ']'->screen.putline;
     if);
  #);
system: external
  (# cmd: [0]@char;
  enter cmd
  #);

--PostProcess:descriptor--
(# cmd: ^text;
   oldfilename, newfilename: ^text;
do <<SLOT DeleleIFile: descriptor>>;
   (if chain and (last_include[]<>NONE) then
       (* We are chaining ORIGINS and IDL file has imports.
        * So we need to rename to an environment and create extra file
        * which ties it all up:
        *   foo_env.bet
        *           |___ foo1.bet
        *           |___ foo2.bet
        *           |___ ...
        *           |___ fooN.bet
        *                 |
        *   foo.bet_______|
        *)
       output.close;
       (if IdlFileName[]<>NONE then 
           '.idl' -> IdlFileName.stripextension;
           '_env.idl' -> IdlFileName.append;
       if);
       output.name -> newfilename[];
       newfilename.copy -> oldfilename[];
       '.bet' -> newfilename.stripExtension;
       '_env.bet' -> newfilename.append;
       (if not quiet then
           '    [rename ' -> screen.puttext;
           output.name -> screen.puttext;
           ' ' -> screen.put;
           newfilename[] -> screen.puttext;
           ']' -> screen.putline;
       if);
       newfilename[] -> output.entry.rename;
       outfilename[] -> output.name;
       (if not quiet then
           '    [reopen ' -> screen.puttext;
           output.name -> screen.puttext;
           ']' -> screen.putline;
       if);
       output.openWrite;
       'ORIGIN \'' -> output.puttext;
       last_include[] -> output.puttext;
       '\';' -> output.putline;
   if);
#)

--ScanForImports: dopart--
do idl.import -> root.suffixWalkForProd
   (# scancat::idl.import;
      imported_name, lib: ^text;
      e: @diskentry;
      imported: ^text;
      exists: @boolean;
      
   do current.getstring -> StringToText -> imported_name[];
      IdlFileName.copy -> e.path;
      imported_name.copy -> lib[];
      '.idl' -> lib.stripExtension;
      HeadOfIdlFileName.copy -> imported[];
      imported_name[] -> imported.append;
      imported[] -> e.path;
      e.exists -> exists;
      (if not exists then
          '~beta/comlib/' -> imported[];
          imported[] -> lib.prepend;
          imported_name[] -> imported.append;
          (imported[], '') -> ast.thePathhandler.convertFilePath -> imported[];
          imported[] -> e.path;
          e.exists -> exists;
      if);
      (if chain then
          (if exists then lib.copy -> last_include[]; if);
       else
          (if not exists then output.commentbegin if);
          'INCLUDE \'' -> output.puttext;
          lib[] -> output.puttext;
          '\'' -> output.put;
          (if not exists then output.commentend if);
          ';' -> output.putline;
      if);
      (* Call recursively *)
      (if not mute then
          '    [file imported from \''->screen.puttext;
          (IdlFileName[], '') -> ast.thePathhandler.localpath 
            -> screen.puttext;
          '\': \'' -> screen.puttext;
          imported[] -> screen.puttext;
          '\']' -> screen.putline;
      if);
      (imported[],forceall) -> DoFile;
      (if not mute then
          'Continuing processing of '''->screen.puttext; 
          (IdlFileName[], '') -> ast.thePathhandler.localpath 
            -> screen.puttext; 
          '''...'->screen.putline;
      if);
   #);
   
--DoFile: dopart--
do (* First check that IDL file is there *)
   IdlFileName[] -> idl_entry.path;
   (if not idl_entry.exists then
       (if not mute then
           '    [IDL file \'' -> screen.puttext;
           idl_entry.path -> screen.puttext;
           '\' does not exist; skipped]' -> screen.putline;
       if);
       leave DoFile;
   if);
   
   InitAstEnv;
   
   &type_list[] -> local_types[];
   IdlFileName.copy -> local_types.name[];
   imported_types[] -> local_types.outer_scope[];
   
   IdlFileName.copy -> OutFileName[];
   '.idl' -> OutFileName.stripExtension;
   '.bet' -> OutFileName.append;
   
   IdlFileName.copy -> IFilename[];
   '.idl' -> IFileName.stripExtension;
   '.i' -> IFileName.appendExtension;
   IdlFileName.copy -> CFilename[];
   '.idl' -> CFileName.stripExtension;
   '.c' -> CFileName.appendExtension;
   
   OutFileName[] -> Output.Name;
   (*'opening ' -> screen.puttext; Output.Name -> screen.putline;*)
   (if not mute then
       'Processing '''->screen.puttext; 
       (IdlFileName[], '') -> ast.thePathhandler.localpath 
         -> screen.puttext; 
       '''...'->screen.putline;
   if);
   
   idl_entry.path.head -> HeadOfIdlFileName[];
   (if HeadOfIdlFileName.length>0 then
       directorychar -> HeadOfIdlFileName.put;
   if);
   (* We do not use top.open, since this enforces fragment
    * syntax on the source files. And we would like to be able to
    * use the IDL files "as-is", without modification.
    * This means, that we will have to do the following ourselves:
    *    dependency analysis
    *    include handling 
    *)
   (if not force then
       (* Check if .bet file needs to be generated *)
       OutFileName[] -> beta_entry.path;
       (if beta_entry.exists then
           (if beta_entry.modtime>idl_entry.modtime then
               (if not quiet then
                   '    [BETA file is up-to-date; skipped]' 
                     -> screen.putline
               if);
               leave DoFile;;
           if)
       if);
   if);
   
   (if false then
       'before: idlfilename: ' -> screen.puttext;
       IdlFileName[] -> screen.putline;
       'before: PreviousFile: ' -> screen.puttext;
       PreviousFile[] -> screen.putline;
   if);
   
   compact -> output.compact;
   (if not quiet then '  Preprocessing...' -> screen.putline; if);
   PreProcess;
   Ifilename[] -> ifile.name;
   ifile.openread;
   idl[] -> ast.newFragmentForm -> ff[];
   (if not quiet then 
       '  Parsing...' -> screen.putline; 
       '    [' -> screen.puttext;
       BobsTab -> ast.expandToFullPath -> screen.puttext;
       ' '->screen.put;
       ifilename[] -> screen.puttext;
       ']' -> screen.putline;
   if);
   (0,fromBeginning) -> ifile.setpos;
   (1,ifile[],screen[],ff[]) -> 
   idl.parser.doParse
   (# astOverflow::
        (# 
        do '\n*** AST overflow:' -> screen.putline;
           'An overflow occurred in the internal representation'
             -> screen.putline;
           'of the parsed IDL file. Sorry!'
             -> screen.putline;
           'Try splitting up ' 
             -> screen.puttext;
           IdlFileName[]
             -> screen.putline;
           'and run bidl again.' -> screen.putline;
           (*'File pos: ' -> screen.puttext;*)
           (*idl.parser.privatepart.b.lex.pos -> screen.putint;*)
           screen.newline;
           stop;
        #)
   #) -> ok;
   (if ok then
       (if not quiet then '  Translating...' -> screen.putline; if);
       Output.OpenWrite;
       IdlFileName[] -> Output.Identification;
       (chain, PreviousFile[]) -> Output.Origin;
       ff.root[] -> scanForImports;
       ff.root[] -> EmitComments;
       output.Lib;
       ff.root[] -> do_specification;
       ifile.close;
       Output.Epilog;
       PostProcess;
       (*'closing ' -> screen.puttext; Output.Name -> screen.putline;*)
       Output.Close;
       (if not quiet then 
           '  Translated BETA file in: \'' -> screen.puttext;
           outfilename[] -> screen.puttext;
           '\'' -> screen.putline;
       if);
    else
       (0,fromBeginning) -> ifile.setpos;
       'Parse errors:' -> screen.putline;
       (ifile[],screen[]) -> idl.parser.ErrorReport;
       ifile.close;
       PostProcess;
   if);
   (if chain and (IdlFileName[]<>NONE) then
       (if false then
           'after: idlfilename: ' -> screen.puttext;
           IdlFileName[] -> screen.putline;
       if);
       IdlFileName.copy -> PreviousFile[];
       (PreviousFile[], HeadOfIdlFileName[]) 
         -> ast.thePathHandler.localpath 
         -> PreviousFile[];
       '.idl' -> PreviousFile.stripExtension;
       (if false then
           'after: PreviousFile: ' -> screen.puttext;
           PreviousFile[] -> screen.putline;
       if);
   if);
   
   (if debug then
       newline;
       'Trace: Global types:'->putline;
       screen.line;
       global_types.print;
       'Trace: Local types for file '->puttext;
       IdlFileName[] -> puttext;
       ':' -> putline;
       screen.line;
       local_types.print;
   if);
   
   (* Make local_types become new imported_types *)
   local_types[] -> imported_types[];
   
