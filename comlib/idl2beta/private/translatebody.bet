ORIGIN '../translate';
INCLUDE '~beta/basiclib/file';
MDBODY nti 'preprocess_ntibody'
default 'preprocess_unixbody';

--TranslateLib: attributes--

report:
  (# cmd: ^text
  enter cmd[]
  do (if not quiet then
         '    [' -> screen.puttext; 
         cmd[] -> screen.puttext; 
         ']'->screen.putline;
     if);
  #);
system: external
  (# cmd: [0]@char;
  enter cmd
  #);

--PostProcess:descriptor--
(# cmd: ^text;
   oldfilename, newfilename: ^text;
do <<SLOT DeleleIFile: descriptor>>;
   (if chain and (last_include[]<>NONE) then
       (* We are chaining ORIGINS and IDL file has imports.
        * So we need to rename to an environment and create extra file
        * which ties it all up:
        *   foo_env.bet
        *           |___ foo1.bet
        *           |___ foo2.bet
        *           |___ ...
        *           |___ fooN.bet
        *                 |
        *   foo.bet_______|
        *)
       output.close;
       (if IdlFileName[]<>NONE then 
           '.idl' -> IdlFileName.stripextension;
           '_env.idl' -> IdlFileName.append;
       if);
       output.theFile.name -> newfilename[];
       newfilename.copy -> oldfilename[];
       '.bet' -> newfilename.stripExtension;
       '_env.bet' -> newfilename.append;
       (if not quiet then
           '    [rename ' -> screen.puttext;
           output.theFile.name -> screen.puttext;
           ' ' -> screen.put;
           newfilename[] -> screen.puttext;
           ']' -> screen.putline;
       if);
       newfilename[] -> output.theFile.entry.rename;
       outfilename[] -> output.theFile.name;
       (if not quiet then
           '    [reopen ' -> screen.puttext;
           output.theFile.name -> screen.puttext;
           ']' -> screen.putline;
       if);
       (if not nocode then output.openWrite; if);
       'ORIGIN \'' -> output.puttext;
       last_include[] -> output.puttext;
       '\';' -> output.putline;
   if);
#)

--ScanForImports: dopart--
do root.suffixWalk
   (# imported_name, lib: ^text;
      e: @diskentry;
      imported: ^text;
      exists: @boolean;
      imp: ^idl.import;
      implib: ^idl.importlib;
   do walk:
        (# 
        do (if current.symbol
            // idl.import then
               (current[]->imp[]).getstring -> StringToText -> imported_name[];
            // idl.importlib then
               (current[]->implib[]).getstring -> StringToText -> imported_name[];
            else
               leave walk
           if);
           '.odl' -> imported_name.stripExtension;
           '.tlb' -> imported_name.stripExtension;
           '.olb' -> imported_name.stripExtension;
           '.dll' -> imported_name.stripExtension;
           '.idl' -> imported_name.appendExtension;
           IdlFileName.copy -> e.path;
           
           (* First try to find imported in directory of original IDL file *)
           HeadOfIdlFileName.copy -> imported[];
           imported_name[] -> imported.append;
           imported[] -> e.path;
           e.exists -> exists;
           (if not exists then
               (* Then try in current directory *)
               './' -> imported[];
               imported_name[] -> imported.append;
               (imported[], '') -> ast.thePathhandler.convertFilePath -> imported[];
               imported[] -> e.path;
               e.exists -> exists;
           if);
           (if not exists then
               (* Then try in comlib *)
               '~beta/comlib/' -> imported[];
               imported_name[] -> imported.append;
               (imported[], '') -> ast.thePathhandler.convertFilePath -> imported[];
               imported[] -> e.path;
               e.exists -> exists;
           if);
           (if imported[]<>NONE then
               (# lib_entry: @diskentry;
               do imported.copy -> lib[];
                  '.idl' -> lib.stripExtension;
                  lib[] -> lib_entry.path;
                  (lib[], '') -> ast.thePathhandler.convertFilePath -> lib[];
                  (lib[], output.thefile.entry.path.head) -> ast.thePathhandler.localPath -> lib[];
               #);
           if);
           (if chain then
               (if exists then lib.copy -> last_include[]; if);
            else
               (if not exists then output.commentbegin if);
               'INCLUDE \'' -> output.puttext;
               lib[] -> output.puttext;
               '\'' -> output.put;
               (if not exists then output.commentend if);
               ';' -> output.putline;
           if);
           (* Call recursively *)
           (if not quiet then
               '    [file imported from \''->screen.puttext;
               (IdlFileName[], '') 
                 -> ast.thePathhandler.localpath 
                 -> screen.puttext;
               '\': \'' -> screen.puttext;
               imported[] -> screen.puttext;
               '\']' -> screen.putline;
           if);
           (* Close Output file to prevent too many open files *)
           Output.close;
           (imported[],forceall) -> DoFile;
           (* Make sure imported types become visible to me *)
           imported_types[] -> local_types.outer_scope[];
           (* Now reopen Output File *)
           Output.openAppend;
           (if not mute then
               'Back from \'' -> screen.puttext;
               imported[] -> screen.puttext;
               '\'' -> screen.putline;
               'Continuing processing of \''->screen.puttext; 
               (IdlFileName[], '') -> ast.thePathhandler.localpath 
                 -> screen.puttext; 
               '\'...'->screen.putline;
           if);
        #)
   #);
   
--DoFile: dopart--
do DoFileLabel:
     (# 
     do 
        (* First check if file is/has already being/been processed *)
        false -> already_processed;
        processed_files.find
        (# predicate::(# do (current[]->IdlFileName.equal)->value#);
        do true->already_processed
        #);
        (if already_processed then 
            (if not quiet then
                '    [IDL file has already been processed; not redoing it]'
                  -> screen.putline;
            if);
            leave DoFileLabel;
        if);
        (* Then immediately mark it as processed. This must be done
         * already now, since it may be met again during procesing of 
         * imported files.
         *)
        IdlFileName.copy -> processed_files.append;
        
        (* Then check that IDL file is there *)
        IdlFileName[] -> idl_entry.path;
        (if not idl_entry.exists then
            (if not mute then
                '    [IDL file \'' -> screen.puttext;
                idl_entry.path -> screen.puttext;
                '\' does not exist; skipped]' -> screen.putline;
            if);
            leave DoFileLabel;
        if);
        
        InitAstEnv;
        
        &type_list[] -> local_types[];
        IdlFileName.copy -> local_types.name[];
        imported_types[] -> local_types.outer_scope[];
        
        (if false then
            'DoFile: IdlFileName is \'' -> puttext;
            IdlFileName[] -> puttext;
            '\''-> putline;
        if);
        
        IdlFileName.copy -> OutFileName[];
        '.idl' -> OutFileName.stripExtension;
        '.bet' -> OutFileName.append;
        
        IdlFileName.copy -> IFilename[];
        '.idl' -> IFileName.stripExtension;
        '.i' -> IFileName.appendExtension;
        IdlFileName.copy -> CFilename[];
        '.idl' -> CFileName.stripExtension;
        '.c' -> CFileName.appendExtension;
        
        (if false then
            'DoFile: CFileName is \'' -> puttext;
            CFileName[] -> puttext;
            '\''-> putline;
        if);
        
        OutFileName[] -> Output.TheFile.Name;
        (*'opening ' -> screen.puttext; Output.TheFile.Name -> screen.putline;*)
        (if not mute then
            'Processing \''->screen.puttext; 
            (IdlFileName[], '') -> ast.thePathhandler.localpath 
              -> screen.puttext; 
            '\'...'->screen.putline;
        if);
        
        idl_entry.path.head -> HeadOfIdlFileName[];
        (if HeadOfIdlFileName.length>0 then
            directorychar -> HeadOfIdlFileName.put;
        if);
        (* We do not use top.open, since this enforces fragment
         * syntax on the source files. And we would like to be able to
         * use the IDL files "as-is", without modification.
         * This means, that we will have to do the following ourselves:
         *    dependency analysis
         *    include handling 
         *)
        (if not force then
            (* Check if .bet file needs to be generated *)
            OutFileName[] -> beta_entry.path;
            (if beta_entry.exists then
                (if beta_entry.modtime>idl_entry.modtime then
                    (if not quiet then
                        '    [BETA file is up-to-date; not generating BETA code]' 
                          -> screen.putline
                    if);
                    true -> nocode;
                if)
            if);
        if);
        
        (if false then
            'before: idlfilename: ' -> screen.puttext;
            IdlFileName[] -> screen.putline;
            'before: PreviousFile: ' -> screen.puttext;
            PreviousFile[] -> screen.putline;
        if);
        
        compact -> output.compact;
        (if not quiet then '  Preprocessing...' -> screen.putline; if);
        PreProcess;
        Ifilename[] -> ifile.name;
        ifile.openread;
        idl[] -> ast.newFragmentForm -> ff[];
        (if not quiet then 
            '  Parsing...' -> screen.putline; 
            '    [' -> screen.puttext;
            BobsTab -> ast.expandToFullPath -> screen.puttext;
            ' '->screen.put;
            ifilename[] -> screen.puttext;
            ']' -> screen.putline;
        if);
        (0,fromBeginning) -> ifile.setpos;
        (1,ifile[],screen[],ff[]) -> 
        idl.parser.doParse
        (# astOverflow::
             (# 
             do '\n*** AST overflow:' -> screen.putline;
                'An overflow occurred in the internal representation'
                  -> screen.putline;
                'of the parsed IDL file. Sorry!'
                  -> screen.putline;
                'Try splitting up ' 
                  -> screen.puttext;
                IdlFileName[]
                  -> screen.putline;
                'and run bidl again.' -> screen.putline;
                (*'File pos: ' -> screen.puttext;*)
                (*idl.parser.privatepart.b.lex.pos -> screen.putint;*)
                screen.newline;
                stop;
             #)
        #) -> ok;
        (if ok then
            (if not quiet then 
                (if nocode then
                    '  Gathering type information...' -> screen.putline;
                 else
                    '  Translating...' -> screen.putline;
                if);
            if);
            ifile.close;
            (if not nocode then Output.OpenWrite; if);
            IdlFileName[] -> Output.Identification;
            (chain, PreviousFile[]) -> Output.Origin;
            ff.root[] -> scanForImports;
            ff.root[] -> EmitComments;
            output.Lib;
            ff.root[] -> do_specification;
            Output.Epilog;
            PostProcess;
            (*'closing ' -> screen.puttext; Output.TheFile.Name -> screen.putline;*)
            (if not nocode then
                Output.Close;
                (if not mute then 
                    '  Translated BETA file in: \'' -> screen.puttext;
                    outfilename[] -> screen.puttext;
                    '\'' -> screen.putline;
                if);
            if);
         else
            (0,fromBeginning) -> ifile.setpos;
            'Parse errors:' -> screen.putline;
            (ifile[],screen[]) -> idl.parser.ErrorReport;
            ifile.close;
            PostProcess;
        if);
        (if chain and (IdlFileName[]<>NONE) then
            (if false then
                'after: idlfilename: ' -> screen.puttext;
                IdlFileName[] -> screen.putline;
            if);
            IdlFileName.copy -> PreviousFile[];
            (PreviousFile[], HeadOfIdlFileName[]) 
              -> ast.thePathHandler.localpath 
              -> PreviousFile[];
            '.idl' -> PreviousFile.stripExtension;
            (if false then
                'after: PreviousFile: ' -> screen.puttext;
                PreviousFile[] -> screen.putline;
            if);
        if);
        
        (if debug then
            'Trace: Local types for file '->puttext;
            IdlFileName[] -> puttext;
            ':' -> putline;
            screen.line;
            local_types.print;
        if);
        
        (* Make local_types become new imported_types *)
        local_types[] -> imported_types[];
        
     #)
