ORIGIN '../control';

--Usage: descriptor--
(# 
do 'Usage: ' -> putText; 1 -> Arguments -> putText;
   ' [Options] <filename>' -> putLine;
   '\nOptions:' -> putline;
   '  -c' -> putline; 		   
   '  --compact      \tCompact output - no comments, less newlines.' -> putline;
   '  -w' -> putline; 		   
   '  --nowarnings   \tDon\'t display warnings.' -> putline;
   '  -e' -> putline; 		   
   '  --errorwarnings\tMake warnings become errors (displayed despite -q).' -> putline;
   '  -f' -> putline; 		   
   '  --force        \tForce generation of BETA file for argument IDL file.' -> putline;
   '  -F' -> putline; 		   
   '  --forceall     \tForce generation of BETA files for all IDL files' -> putline;
   '                 \t(including imported ones)' -> putline;
   '  -v' -> putline; 		   
   '  --verbose      \tPrint verbose info on progress' -> putline;
   '  -q' -> putline; 		   
   '  --quiet        \tBe quiet - print minimal output, like files opened, ' -> putline;
   '                 \terror messages (but not warnings)' -> screen.putline;
   '  -m' -> putline; 		   
   '  --mute         \tBe absolutely quiet - print nothing' -> putline;
   '  -p' -> putline; 		   
   '  --preserve     \tPreserve temporary files' -> putline;
   '  -D name' -> putline;
   '  --define name  \tDefine preprocessor name' -> putline;
   '  -I path' -> putline;
   '  --include path \tAdd path to list of paths known by preprocessor' -> putline;
   '\nDebug options:' -> putline;
   '  -d' -> putline; 
   '  --debug        \tEnable debug of bidl' -> putline;
   '  -t' -> putline; 
   '  --trace        \tEnable tracing of bidl' -> putline;
   '  -T' -> putline; 
   '  --mps_trace    \tEnable tracing of mps' -> putline;
#)

--CollectArguments: descriptor--
(# 
do args:
     (# aText: ^text;
     do StartOfFilenames -> Arguments -> aText[];    
        (if true 
         // ('-D' -> aText.Equal) then
         // ('--define' -> aText.Equal) then
            (if (NoOfArguments <= StartOfFilenames+1) then 
                Usage; leave block
            if);      
            StartOfFilenames+1 -> Arguments -> defines.append; 
            StartOfFilenames+2 -> StartOfFilenames;
            restart args;
         // ('-I' -> aText.Equal) then
         // ('--include' -> aText.Equal) then
            (if (NoOfArguments <= StartOfFilenames+1) then 
                Usage; leave block
            if);      
            StartOfFilenames+1 -> Arguments -> includepaths.append; 
            StartOfFilenames+2 -> StartOfFilenames;
            restart args;
         // ('-p' -> aText.equal)
         // ('--preserve' -> aText.equal) then 
            true -> preserve;
            StartOfFilenames+1 -> StartOfFilenames;
            restart args;
         // ('-e' -> aText.equal)
         // ('--errorwarnings' -> aText.equal) then 
            true -> errorwarnings;
            StartOfFilenames+1 -> StartOfFilenames;
            restart args;
         // ('-w' -> aText.equal)
         // ('--nowarnings' -> aText.equal) then 
            true -> nowarnings;
            StartOfFilenames+1 -> StartOfFilenames;
            restart args;
         // ('-f' -> aText.equal)
         // ('--force' -> aText.equal) then 
            true -> force;
            StartOfFilenames+1 -> StartOfFilenames;
            restart args;
         // ('-F' -> aText.equal)
         // ('--forceall' -> aText.equal) then 
            true -> forceall -> force;
            StartOfFilenames+1 -> StartOfFilenames;
            restart args;
         // ('-c' -> aText.equal)
         // ('--compact' -> aText.equal) then 
            true -> compact;
            StartOfFilenames+1 -> StartOfFilenames;
            restart args;
         // ('-q' -> aText.equal)
         // ('--quiet' -> aText.equal) then 
            true -> quiet; false -> verbose -> mute;
            StartOfFilenames+1 -> StartOfFilenames;
            restart args;
         // ('-v' -> aText.equal)
         // ('--verbose' -> aText.equal) then 
            true -> verbose;
            false -> quiet -> mute;
            StartOfFilenames+1 -> StartOfFilenames;
            restart args;
         // ('-m' -> aText.equal)
         // ('--mute' -> aText.equal) then 
            true -> mute -> quiet;
            false -> verbose;
            StartOfFilenames+1 -> StartOfFilenames;
            restart args;
         // ('-d' -> aText.equal)  
         // ('--debug' -> aText.equal) then 
            true -> debug -> verbose;
            false -> quiet -> mute;
            StartOfFilenames+1 -> StartOfFilenames;
            restart args;
         // ('-t' -> aText.equal)  
         // ('--trace' -> aText.equal) then 
            true -> trace;
            StartOfFilenames+1 -> StartOfFilenames;
            restart args;
         // ('-T' -> aText.equal)  
         // ('--mps_trace' -> aText.equal) then 
            true -> mps_trace;
            StartOfFilenames+1 -> StartOfFilenames;
            restart args;
        if);
     #)
#)
--InitAstEnv: descriptor--
(# parser_entry, bidl_entry: @diskentry;
do 
   (if debug and mps_trace then
       (ast.trace.topOpen,true) -> ast.trace.set;
       (ast.trace.fragmentOpen,true) -> ast.trace.set;
       (ast.trace.grammars,true) -> ast.trace.set;
       (ast.trace.compactOpen,true) -> ast.trace.set;
       (ast.trace.onParse,true) -> ast.trace.set;
       (ast.trace.parser,true) -> ast.trace.set;
       (ast.trace.getBinding,true) -> ast.trace.set;
       (ast.trace.getBindingMark,true) -> ast.trace.set;
   if);
   BobsTab -> ast.expandToFullPath -> parser_entry.path;
   1 -> Arguments -> bidl_entry.path;
   (* FIXME: the stuff below fails on NTI *)
   (if false then
       (if bidl_entry.modtime < parser_entry.modtime then
           'Parser is newer than bidl executable - recompile bidl!'
             -> screen.putline;
           stop;
       if);
   if);
   ast.astLevelInit;
   idl.init; 
   parser_entry.path -> idl.parser.initialize
   (# EOLasComEnd::(# do true->value #);
      caseSensitive::(# do true->value #);
   #);
#)

