ORIGIN 'control';
INCLUDE '~beta/basiclib/formatio';

--LIB: attributes--
trace_findtype: (# exit false #);

--FindTypeNotFound: descriptor--
(# msg: ^text;
do 'Unknown type: '->msg[];
   name[] -> msg.puttext;
   '. Using \'int32\'.' ->msg.append;
   msg[] -> warning;
   (name[],'int32') 
     -> add_basic_type 
     -> THIS(findtype).current[];
   (if trace_findtype then
       THIS(type_list).name[] -> puttext;
       '(3): current.representation: ' -> screen.puttext;
       THIS(findtype).current.representation[] -> screen.putline;
   if);
#)

--type_list_findtype: dopart--
do findtypelabel:
     (# 
     do 
        (if trace_findtype then
            'findtype: ' -> screen.puttext;
            THIS(type_list).name[] -> puttext; 
            ': '->puttext;
            name[] -> screen.putline;
        if);
        (if name[]=NONE then
            'find_type: name is NONE' -> error;
            leave findtypelabel;
        if);
        find
        (# 
           predicate::(# do (current.name[]->name.equal)->value #);
        do current[] -> THIS(findtype).current[];
           (if trace_findtype then
               THIS(type_list).name[] -> puttext;
               '(1): current.representation: ' -> screen.puttext;
               THIS(findtype).current.representation[] -> screen.putline;
           if);
           INNER findtype; 
           true -> found;
        #);
        (if (not found) then
            (if (outer_scope[]<>NONE) then
                (* continue recursive search in outer_scope *)
                (name[],notfound_object[]) -> &outer_scope.findtype
                (# 
                do current[]->THIS(findtype).current[]; 
                   (if trace_findtype then
                       THIS(type_list).name[] -> puttext;
                       '(2): current.representation: ' -> screen.puttext;
                       THIS(findtype).current.representation[] -> screen.putline;
                   if);
                   INNER findtype; 
                #)
             else
                notfound;
                INNER findtype;
            if)
        if);
     #);

--type_list_add_basic_type: dopart--
do &type_info[] -> type[];
   name[] -> type.name[];
   representation[] -> type.representation[];
   type_cat_basic -> type.category;
   type[] -> append;
   
--type_list_add_basic_pointer_type: dopart--
do &type_info[] -> type[];
   name[] -> type.name[];
   representation[] -> type.representation[];
   1 -> type.pointer_level;
   type_cat_basic -> type.category;
   type[] -> append;
  
--type_list_add_user_type: dopart--
do &type_info[] -> type[];
   name[] -> type.name[];
   representation[] -> type.representation[];
   type_cat_user -> type.category;
   type[] -> append;

--type_list_add_union_type: dopart--
do &type_info[] -> type[];
   name[] -> type.name[];
   representation[] -> type.representation[];
   type_cat_union -> type.category;
   type[] -> append;

--type_list_add_struct_type: dopart--
do &type_info[] -> type[];
   name[] -> type.name[];
   representation[] -> type.representation[];
   type_cat_struct -> type.category;
   type[] -> append;

--type_list_add_interface_type: dopart--
do &type_info[] -> type[];
   name[] -> type.name[];
   representation[] -> type.representation[];
   type_cat_interface -> type.category;
   type[] -> append;
   
--type_info_print: descriptor--
(#
do (if name[]=NONE then
          '%20s' -> putformat(# do '<NONE>'->s #);
       else
          '%20s' -> putformat(# do name[]->s #);
      if);
      (for pointer_level repeat
           '*' -> put;
      for);
      (for 4-pointer_level repeat
           ' ' -> put;
      for);
      (if representation[]=NONE then
          '%14s' -> putformat(# do '<NONE>'->s #);
       else
          '%14s' -> putformat(# do representation[]->s #);
      if);
      ' '-> put;
      (if category
       // type_cat_basic      then '%10s' -> putformat(# do 'basic'->s #);
       // type_cat_struct     then '%10s' -> putformat(# do 'struct'->s #);
       // type_cat_enum       then '%10s' -> putformat(# do 'enum'->s #);
       // type_cat_union      then '%10s' -> putformat(# do 'union'->s #);
       // type_cat_user       then '%10s' -> putformat(# do 'user'->s #);
       // type_cat_interface  then '%10s' -> putformat(# do 'interface'->s #);
       else '<%07d>' -> putformat(# do category->d #);
      if);
      (if attributes[]=NONE then
          '<NONE>' -> puttext;
       else
          screen[] -> attributes.print;
      if);
      newline;
#)

--type_list_print: dopart--
do '%20s' -> putformat(# do 'name'->s #);
   '%4s'  -> putformat(# do 'ptr'->s #);
   '%15s' -> putformat(# do 'representation'->s #);
   '%10s'  -> putformat(# do 'category'->s #);
   'attributes' -> putline;
   
   screen.line;
   scan(# do current.print #);
   screen.line;
   
--declarator_list_print: dopart--
do '    ' -> puttext;
   '%20s' -> putformat(# do 'name'->s #);
   '%4s' -> putformat(# do 'ptr'->s #);
   '%20s' -> putformat(# do 'type'->s #);
   '%8s' -> putformat(# do 'comment'->s #);
   'attributes' -> putline;
   
   '    '->puttext; screen.line;
   scan
   (# 
   do '    ' -> puttext;
      (if current.name[]=NONE then
          '%20s' -> putformat(# do '<NONE>'->s #);
       else
          '%20s' -> putformat(# do current.name[]->s #);
      if);
      (for current.pointer_level repeat
           '*' -> put;
      for);
      (for 4-current.pointer_level repeat
           ' ' -> put;
      for);
      (if current.type[]=NONE then
          '%20s' -> putformat(# do '<NONE>'->s #);
       else
          '%20s' -> putformat(# do current.type.name[]->s #);
      if);
      (if current.type_comment[]=NONE then
          '%8s' -> putformat(# do '<NONE>'->s #);
       else
          '%8s' -> putformat(# do current.type_comment[]->s #);
      if);
      (if current.attributes[]=NONE then
          '<NONE>' -> puttext;
       else
          screen[] -> current.attributes.print;
      if);
      newline;
   #);
   '    '->screen.puttext; screen.line;
   
--CheckForReservedWord: dopart--
do (* Check for reserved BETA words *)
   CheckForReservedWordLabel:
     (# 
     do 
        (if true
         // 'enter'->word.equalNCS
         // 'exit'->word.equalNCS
         // 'do'->word.equalNCS
         // 'for'->word.equalNCS
         // 'repeat'->word.equalNCS
         // 'if'->word.equalNCS
         // 'restart'->word.equalNCS
         // 'inner'->word.equalNCS
         // 'suspend'->word.equalNCS
         // 'code'->word.equalNCS
         // 'then'->word.equalNCS
         // 'else'->word.equalNCS
         // 'tos'->word.equalNCS
         // 'this'->word.equalNCS
         // 'or'->word.equalNCS
         // 'xor'->word.equalNCS
         // 'div'->word.equalNCS
         // 'mod'->word.equalNCS
         // 'and'->word.equalNCS
         // 'not'->word.equalNCS
         // 'none'->word.equalNCS
            then
            (# msg: ^text
            do 'Reserved BETA word \'' -> msg[];
               word[] -> msg.puttext;
               '\' changed to \'' -> msg.puttext;
               '_' -> word.prepend;
               word[] -> msg.puttext;
               '\'.' -> msg.puttext;
               msg[] -> warning;
            #);
            leave CheckForReservedWordLabel;
        if);
        (if true
         // 'integer'->word.equalNCS
         // 'shortInt'->word.equalNCS
         // 'char'->word.equalNCS
         // 'boolean'->word.equalNCS
         // 'false'->word.equalNCS
         // 'true'->word.equalNCS
         // 'real'->word.equalNCS
         // 'int8'->word.equalNCS
         // 'int8u'->word.equalNCS
         // 'int16'->word.equalNCS
         // 'int16u'->word.equalNCS
         // 'int32'->word.equalNCS
         // 'int32u'->word.equalNCS
         // 'int64'->word.equalNCS
         // 'int64u'->word.equalNCS
         // 'wchar'->word.equalNCS
         // 'COM'->word.equalNCS
         // 'Holder'->word.equalNCS     
            then
            (# msg: ^text
            do '\'' -> msg[];
               word[] -> msg.puttext;
               '\' changed to \'' -> msg.puttext;
               '_' -> word.prepend;
               word[] -> msg.puttext;
               '\', since it is a predefined BETA pattern.' -> msg.puttext;
               msg[] -> warning;
            #);
            leave CheckForReservedWordLabel;
        if);
        (if true
         // 'result'->word.equalNCS
            then
            (# msg: ^text
            do 'Reserved BIDL word \'' -> msg[];
               word[] -> msg.puttext;
               '\' changed to \'' -> msg.puttext;
               '_' -> word.prepend;
               word[] -> msg.puttext;
               '\'.' -> msg.puttext;
               msg[] -> warning;
            #);
            leave CheckForReservedWordLabel;
        if);
        (if true
         // (('guid'->word.equalNCS) and (not ('GUID'->word.equal)))
         // (('iid'->word.equalNCS) and (not ('IID'->word.equal)))
         // (('clsid'->word.equalNCS) and (not ('CLSID'->word.equal)))
            then
            (# msg: ^text
            do '\'' -> msg[];
               word[] -> msg.puttext;
               '\' changed to \'' -> msg.puttext;
               '_' -> word.prepend;
               word[] -> msg.puttext;
               '\', since BETA is case-insensitive.' -> msg.puttext;
               msg[] -> warning;
            #);
            leave CheckForReservedWordLabel;
        if);
     #)
