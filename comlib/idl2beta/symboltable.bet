ORIGIN 'control';
INCLUDE '~beta/basiclib/formatio';
INCLUDE '~beta/sysutils/objinterface';

--LIB: attributes--
trace_findtype: (# exit false #);

--type_list_findtype: dopart--
do (if trace_findtype then
       'findtype: ' -> screen.puttext;
       name[] -> screen.putline;
   if);
   (if name[]=NONE then
       'find_type: name is NONE' -> error;
       leave findtype;
   if);
   find
   (# 
      predicate::(# do (current.name[]->name.equal)->value #);
   do current[] -> THIS(findtype).current[];
      (if trace_findtype then
          THIS(findtype).origin[] -> getpatternname -> puttext;
          '(1): current.representation: ' -> screen.puttext;
          THIS(findtype).current.representation[] -> screen.putline;
      if);
      INNER findtype; 
      true -> found;
   #);
   (if (not found) then
       (if (outer_scope[]<>NONE) then
           (* continue recursive search in outer_scope *)
           name[] -> &outer_scope.findtype
           (# 
           do current[]->THIS(findtype).current[]; 
              (if trace_findtype then
                  THIS(findtype).origin[] -> getpatternname -> puttext;
                  '(2): current.representation: ' -> screen.puttext;
                  THIS(findtype).current.representation[] -> screen.putline;
              if);
              INNER findtype; 
           #)
        else
           (# msg: ^text;
           do 'Unknown type: '->msg[];
              name[] -> msg.puttext;
              '. Using \'int32\'.' ->msg.append;
              msg[] -> warning;
           #);
           (name[],'int32') 
             -> local_types.add_basic_type 
             -> THIS(findtype).current[];
           (if trace_findtype then
               THIS(findtype).origin[] -> getpatternname -> puttext;
               '(3): current.representation: ' -> screen.puttext;
               THIS(findtype).current.representation[] -> screen.putline;
           if);
           INNER findtype;
       if)
   if);
   
--type_list_add_basic_type: dopart--
do &type_info[] -> type[] -> append;
   name[] -> type.name[];
   representation[] -> type.representation[];
   type_cat_basic -> type.category;
   
--type_list_add_basic_pointer_type: dopart--
do &type_info[] -> type[] -> append;
   name[] -> type.name[];
   representation[] -> type.representation[];
   1 -> type.pointer_level;
   type_cat_basic -> type.category;
   
--type_list_add_user_type: dopart--
do &type_info[] -> type[] -> append;
   name[] -> type.name[];
   representation[] -> type.representation[];
   type_cat_user -> type.category;
   
--type_list_add_union_type: dopart--
do &type_info[] -> type[] -> append;
   name[] -> type.name[];
   representation[] -> type.representation[];
   type_cat_union -> type.category;
   
--type_list_add_struct_type: dopart--
do &type_info[] -> type[] -> append;
   name[] -> type.name[];
   representation[] -> type.representation[];
   type_cat_struct -> type.category;
   
--type_list_add_interface_type: dopart--
do &type_info[] -> type[] -> append;
   name[] -> type.name[];
   representation[] -> type.representation[];
   type_cat_interface -> type.category;
    
--type_list_print: dopart--
do '%20s' -> putformat(# do 'name'->s #);
   '%4s'  -> putformat(# do 'ptr'->s #);
   '%15s' -> putformat(# do 'representation'->s #);
   '%10s'  -> putformat(# do 'category'->s #);
   'attributes' -> putline;
   
   screen.line;
   scan
   (# 
   do (if current.name[]=NONE then
          '%20s' -> putformat(# do '<NONE>'->s #);
       else
          '%20s' -> putformat(# do current.name[]->s #);
      if);
      (for current.pointer_level repeat
           '*' -> put;
      for);
      (for 4-current.pointer_level repeat
           ' ' -> put;
      for);
      (if current.representation[]=NONE then
          '%14s' -> putformat(# do '<NONE>'->s #);
       else
          '%14s' -> putformat(# do current.representation[]->s #);
      if);
      ' '-> put;
      (if current.category
       // type_cat_basic      then '%10s' -> putformat(# do 'basic'->s #);
       // type_cat_struct     then '%10s' -> putformat(# do 'struct'->s #);
       // type_cat_enum       then '%10s' -> putformat(# do 'enum'->s #);
       // type_cat_union      then '%10s' -> putformat(# do 'union'->s #);
       // type_cat_user       then '%10s' -> putformat(# do 'user'->s #);
       // type_cat_interface  then '%10s' -> putformat(# do 'interface'->s #);
       else '<%07d>' -> putformat(# do current.category->d #);
      if);
      (if current.attributes[]=NONE then
          '<NONE>' -> puttext;
       else
          screen[] -> current.attributes.print;
      if);
      newline;
   #);
   screen.line;
   
--declarator_list_print: dopart--
do '    ' -> puttext;
   '%20s' -> putformat(# do 'name'->s #);
   '%4s' -> putformat(# do 'ptr'->s #);
   '%20s' -> putformat(# do 'type'->s #);
   '%8s' -> putformat(# do 'comment'->s #);
   'attributes' -> putline;
   
   '    '->puttext; screen.line;
   scan
   (# 
   do '    ' -> puttext;
      (if current.name[]=NONE then
          '%20s' -> putformat(# do '<NONE>'->s #);
       else
          '%20s' -> putformat(# do current.name[]->s #);
      if);
      (for current.pointer_level repeat
           '*' -> put;
      for);
      (for 4-current.pointer_level repeat
           ' ' -> put;
      for);
      (if current.type[]=NONE then
          '%20s' -> putformat(# do '<NONE>'->s #);
       else
          '%20s' -> putformat(# do current.type.name[]->s #);
      if);
      (if current.type_comment[]=NONE then
          '%8s' -> putformat(# do '<NONE>'->s #);
       else
          '%8s' -> putformat(# do current.type_comment[]->s #);
      if);
      (if current.attributes[]=NONE then
          '<NONE>' -> puttext;
       else
          screen[] -> current.attributes.print;
      if);
      newline;
   #);
   '    '->screen.puttext; screen.line;
   
--CheckForReservedWord: dopart--
do (* Check for reserved BETA words *)
   (if true
    // 'enter'->word.equalNCS
    // 'exit'->word.equalNCS
    // 'do'->word.equalNCS
    // 'for'->word.equalNCS
    // 'repeat'->word.equalNCS
    // 'if'->word.equalNCS
    // 'restart'->word.equalNCS
    // 'inner'->word.equalNCS
    // 'suspend'->word.equalNCS
    // 'code'->word.equalNCS
    // 'then'->word.equalNCS
    // 'else'->word.equalNCS
    // 'tos'->word.equalNCS
    // 'this'->word.equalNCS
    // 'or'->word.equalNCS
    // 'xor'->word.equalNCS
    // 'div'->word.equalNCS
    // 'mod'->word.equalNCS
    // 'and'->word.equalNCS
    // 'not'->word.equalNCS
    // 'none'->word.equalNCS then
       (# msg: ^text
       do 'Reserved BETA word \'' -> msg[];
          word[] -> msg.puttext;
          '\' changed to \'' -> msg.puttext;
          '_' -> word.prepend;
          word[] -> msg.puttext;
          '\'.' -> msg.puttext;
          msg[] -> warning;
       #)
   if);
