ORIGIN 'translate'

-- interface_body_lib: attributes--
do_base_type_spec:
  (# s: ^idl.base_type_spec;
  enter s[]
  do (if s.symbol
      // idl.float then 'real (* float *)' -> outfile.puttext;
      // idl.double then 'real (* double *)' -> outfile.puttext;
      // idl.int then 'int32' -> outfile.puttext;
      // idl.signed_long_int then 'int32' -> outfile.puttext;
      // idl.signed_short_int then 'int16' -> outfile.puttext;
      // idl.unsigned_long_int then 'int32u' -> outfile.puttext;
      // idl.unsigned_short_int then 'int16u' -> outfile.puttext;
      // idl.unsigned_char then 'int8u' -> outfile.puttext;
      // idl.signed_char then 'int8' -> outfile.puttext;
      // idl.char then 'char' -> outfile.puttext;
      // idl.boolean_type then 'boolean' -> outfile.puttext;
      // idl.octet_type then 'int8u (* octet *)' -> outfile.puttext;
      // idl.any_type then 'integer (* any NYI *)' -> outfile.puttext;
     if);
  #);
do_export_type_dcl:
  (# e: ^idl.export_type_dcl;
  enter e[]
  do e.gettype_dcl -> do_type_dcl;
  #);
do_export_const_dcl:
  (# e: ^idl.export_const_dcl;
  enter e[]
  do outfile.indent;
     'do_export_const_dcl NYI' -> outfile.commentline;
  #);
do_export_except_dcl:
  (# e: ^idl.export_except_dcl;
  enter e[]
  do outfile.indent;
     'do_export_except_dcl NYI' -> outfile.commentline;
  #);
do_export_attr_dcl:
  (# e: ^idl.export_attr_dcl;
  enter e[]
  do outfile.indent;
     'do_export_attr_dcl NYI' -> outfile.commentline;
  #);

do_export_op_dcl:
  (# e: ^idl.export_op_dcl;
     do_op_dcl:
       (# do_op_attribute:
            (# o: ^idl.op_attribute;
            enter o[]
            do outfile.indent;
               'do_op_attribute NYI' -> outfile.commentline;
            #);
          do_raises_expr:
            (# o: ^idl.raises_expr;
            enter o[]
            do outfile.indent;
               'do_raises_expr NYI' -> outfile.commentline;
            #);
          do_context_expr:
            (# o: ^idl.context_expr;
            enter o[]
            do outfile.indent;
               'do_context_expr NYI' -> outfile.commentline;
            #);
          do_parameter_dcls:
            (# p: ^idl.parameter_dcls;
               d: ^idl.param_dcls;
            enter p[]
            do 0 -> num_enter_parameters;
               enter_parameters.clear;
               p.getparam_dcls -> d[];
               d.newscan
               (# 
               do current[] -> do_param_dcl;
               #);
            #);
          do_param_dcl:
            (# d: ^idl.param_dcl;
               do_param_attribute_list:
                 (# l: ^idl.param_attribute_list;
                    x: ^idl.attributeX;
                    a: ^idl.attributes;
                 enter l[]
                 do l.getattributeX -> x[];
                    x.getattributes -> a[];
                    ' '->outfile.put;
                    outfile.CommentBegin;
                    a.newscan
                    (# first_done: @boolean;
                    do (if first_done then
                           ',' -> outfile.put;
                        else
                           true->first_done
                       if);
                       current[]->do_attributeY;
                    #);
                    outfile.CommentEnd;
                 #);
               do_const:
                 (# c: ^idl.const_key;
                 enter c[]
                 do (*'const' -> outfile.comment;*)
                 #);
               
               do_param_type_spec:
                 (# t: ^idl.param_type_spec;
                    s: ^idl.param_scoped_name;
                    b: ^idl.param_base_type_spec;
                    dcl_info: ^declarator_info;
                 enter (dcl_info[], t[])
                 do (if t.symbol
                     // idl.param_base_type_spec then
                        put_arg;
                        (t[]->b[]).getbase_type_spec
                          -> do_base_type_spec;
                     // idl.param_string_type then
                        put_arg;
                        '@integer (* param_string_type NYI *)' 
                          -> outfile.puttext;
                     // idl.param_scoped_name then
                        put_arg;
                        (t[]->s[]).getscoped_name
                          -> do_scoped_name 
                          -> types.findsym
                        (# 
                        do (if current.basic_type[] <> NONE then
                               (* We must add pointer levels from
                                * declarator with type's pointer
                                * level!
                                *)
                               (if dcl_info.pointer_level
                                   + current.pointer_level
                                // 0 then
                                   '@' -> outfile.put;
                                   current.basic_type[]->outfile.puttext;
                                // 1 then
                                   (* pointer to basic type *)
                                   '^' -> outfile.put;
                                   current.basic_type[]->outfile.puttext;
                                   'Holder' -> outfile.puttext;
                                else
                                   'pointer_level_too_big!;' 
                                     -> outfile.puttext;
                                   'pointer_level>1 for basictype NYI' 
                                     -> putline;
                               if)
                            else
                               '@' -> outfile.put;
                               current.basic_type[] -> outfile.puttext;
                           if);
                        #) 
                     // idl.param_void then
                        (if true
                         // arg_info.pointer_level=1 then
                            put_arg;
                            '@integer (* void* *)' -> outfile.puttext;
                         // arg_info.pointer_level=2 then
                            put_arg;
                            '@integer (* void** *)' -> outfile.puttext;
                         else
                            (* If a parameter has type 
                             * void, then it must mean that
                             * there are NO parameters! 
                             * I.e. foo(void).
                             *)
                            (if num_enter_parameters=0 then
                                'No parameters' 
                                  -> outfile.comment;
                             else
                                'Error: Met void parameter at num_enter_parameters='
                                  -> screen.puttext;
                                num_enter_parameters
                                  -> screen.putint;
                                screen.newline;
                                stop;
                            if);
                        if)
                    if);
                 #);
               put_arg:
                 (#
                 do arg_info.id[] -> outfile.puttext;
                    ': ' -> outfile.puttext;
                    num_enter_parameters+1 -> num_enter_parameters;
                    (* FIXME: possible boxes missing *)
                    (if num_enter_parameters>1 then
                        ', ' -> enter_parameters.append;
                    if);
                    arg_info.id[] -> enter_parameters.append;
                 #);
               generate_param_name:
                 (# 
                 do 'arg' -> arg_info.id[];
                    num_enter_parameters->arg_info.id.putint;
                 #);
               arg_info: ^declarator_info;
            enter d[]
            do &declarator_info[] -> arg_info[];
               outfile.indent;
               (if d.getconst2->optionalPresent then
                   d.getconst2->do_const;
               if);
               (if d.getdeclarator->optionalPresent then
                   (arg_info[], d.getdeclarator)->do_declarator
                else
                   generate_param_name;
               if);
               (if d.getconst1->optionalPresent then
                   d.getconst1->do_const;
               if);
               (arg_info[], d.gettype) -> do_param_type_spec;
               (if d.getattributes->optionalPresent then
                   d.getattributes->do_param_attribute_list;
               if);
               ';' -> outfile.putline;
            #);
          result_present: @boolean;
          num_enter_parameters: @integer;
          enter_parameters: @text;
          do_op_type_spec:
            (# t: ^idl.op_type_spec;
               s: ^idl.param_scoped_name;
               name: ^text;
            enter t[]
            do false -> result_present;
               (if t.symbol
                // idl.void then
                   'No result' -> outfile.comment;
                // idl.void_ref then
                   true -> result_present;
                   'result: ^IUnknown ' -> outfile.puttext;
                   'void*' -> outfile.comment;
                   ';' -> outfile.put;
                   'Warning: void* result translated to ^IUnknown'
                   -> putline;
                // idl.param_base_type_spec then
                   true -> result_present;
                   'result: @integer ' -> outfile.puttext;
                   'param_base_type_spec NYI' -> outfile.comment;
                   ';' -> outfile.put;
                // idl.param_string_type then
                   true -> result_present;
                   'result: @integer ' -> outfile.puttext;
                   'param_string_type NYI' -> outfile.comment;
                   ';' -> outfile.put;
                // idl.param_scoped_name then
                   true -> result_present;
                   'result: ' -> outfile.puttext;
                   (t[]->s[]).getscoped_name 
                     -> do_scoped_name -> name[];
                   name[] -> types.findsym
                   (# 
                   do (if current.basic_type[] <> NONE then
                          (if current.pointer_level
                           // 0 then
                              '@' -> outfile.put;
                              current.basic_type[] -> outfile.puttext;
                           // 1 then
                              (* pointer to basic type *)
                              '^' -> outfile.put;
                              current.basic_type[] -> outfile.puttext;
                              'Holder' -> outfile.puttext;
                           else
                              'pointer_level>1 for basictype NYI' 
                                ->  putline;
                          if)
                       else
                          '@' -> outfile.put;
                          current.basic_type[] -> outfile.puttext;
                      if);
                   #);                                  
                   ';' -> outfile.put;
                // idl.param_void then
                   false -> result_present;
                   'No result' -> outfile.comment;
                   ';' -> outfile.put;
                // idl.param_type_spec_ref then
                   true -> result_present;
                   'result: @integer ' -> outfile.puttext;
                   'param_type_spec_ref NYI'
                     -> outfile.comment;
                   ';' -> outfile.put;
               if);
               outfile.newline;
            #);
          e: ^idl.op_dcl;
       enter e[]
       do outfile.indent;
          (* Start a virtual *)
          e.getIdentifier 
            -> IdentifierToText -> outfile.puttext;
          (*':< External' -> outfile.puttext;*)
          ':< ' -> outfile.puttext;
          outfile.newline;
          2 -> outfile.indent.inc;
          (if e.getop_attributeOpt -> optionalPresent then
              e.getop_attributeOpt -> do_op_attribute
          if);
          (if e.getraises_exprOpt -> optionalPresent then
              e.getraises_exprOpt -> do_raises_expr;
          if);
          (if e.getcontext_exprOpt -> optionalPresent then
              e.getcontext_exprOpt -> do_context_expr;
          if);
          outfile.indent;
          outfile.PatternBegin;
          (* Handle the exit parameter *)
          e.getop_type_spec -> do_op_type_spec;
          3 -> outfile.indent.inc;
          (* Handle the enter parameters *)
          e.getparameter_dcls -> do_parameter_dcls;
          
          (* Finish this virtual - emit enter,do,exit *)
          3 -> outfile.indent.dec;
          (if num_enter_parameters>0 then
              outfile.indent;
              'enter ' -> outfile.puttext;
              (if num_enter_parameters>1 then 
                  '(' -> outfile.put;
              if);
              enter_parameters[] -> outfile.puttext;
              (if num_enter_parameters>1 then 
                  ')' -> outfile.put;
              if);
              outfile.newline;
          if);
          (if e.getstd_call_opt -> optionalPresent then
              outfile.indent;
              (*'do CallStd;' -> outfile.putline;*)
              '__stdcall' -> outfile.commentline;
           else
              (* outfile.indent; *)
              (*'do CallC;' -> outfile.putline;*)
          if);
          (if result_present then
              outfile.indent;
              'exit result' -> outfile.putline;
          if);
          outfile.indent;
          outfile.PatternEnd;
          ';' -> outfile.putline;
          2 -> outfile.indent.dec;
          (*outfile.newline;*)
       #);
  enter e[]
  do e.getop_dcl -> do_op_dcl;
  #);
do_cpp_quote:
  (# c: ^idl.cpp_quote;
  enter c[]
  do outfile.indent;
     c.getString -> StringToText -> outfile.commentline;
  #);
do_export_import:
  (# e: ^idl.export_import;
     i: ^idl.import;
  enter e[]
  do e.getimport -> i[];
     i.getString -> StringToText -> imports.append;
  #);
do_export_error:
  (# e: ^idl.export_error;
  enter e[]
  do outfile.indent;
     'do_export_error NYI' -> outfile.commentline;
  #);

--interface_body_body: dopart--
do b.getexports -> e[];
   e.newscan
   (# 
   do (if current.symbol
       // idl.export_type_dcl then
          current[] -> do_export_type_dcl
       // idl.export_const_dcl then
          current[] -> do_export_const_dcl
       // idl.export_except_dcl then
          current[] -> do_export_except_dcl
       // idl.export_attr_dcl then
          current[] -> do_export_attr_dcl
       // idl.export_op_dcl then
          current[] -> do_export_op_dcl
       // idl.export_import then
          current[] -> do_export_import
       // idl.cpp_quote then
          current[] -> do_cpp_quote
       // idl.export_error then
          current[] -> do_export_error 
      if);
   #); 
   
   (* End pattern.
    * The following is matched by the pattern-begin in 
    * do_interface_header
    *)
   3 -> outfile.indent.dec;
   outfile.indent;
   outfile.PatternEnd;
   ';' -> outfile.putline;
   2 -> outfile.indent.dec;
   
