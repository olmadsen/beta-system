ORIGIN 'translate'

-- interface_body_lib: attributes--
do_export_type_dcl:
  (# e: ^idl.export_type_dcl;
  enter e[]
  do e.gettype_dcl -> do_type_dcl;
  #);
do_export_const_dcl:
  (# e: ^idl.export_const_dcl;
  enter e[]
  do outfile.indent;
     'do_export_const_dcl NYI' -> outfile.commentline;
  #);
do_export_except_dcl:
  (# e: ^idl.export_except_dcl;
  enter e[]
  do outfile.indent;
     'do_export_except_dcl NYI' -> outfile.commentline;
  #);
do_export_attr_dcl:
  (# e: ^idl.export_attr_dcl;
  enter e[]
  do outfile.indent;
     'do_export_attr_dcl NYI' -> outfile.commentline;
  #);

do_export_op_dcl:
  (# e: ^idl.export_op_dcl;
     do_op_dcl:
       (# do_raises_expr:
            (# o: ^idl.raises_expr;
            enter o[]
            do outfile.indent;
               'do_raises_expr NYI' -> outfile.commentline;
            #);
          do_context_expr:
            (# o: ^idl.context_expr;
            enter o[]
            do outfile.indent;
               'do_context_expr NYI' -> outfile.commentline;
            #);
          do_parameter_dcls:
            (# p: ^idl.parameter_dcls;
               d: ^idl.param_dcls;
               dcl_info: ^declarator_info;
            enter (p[])
            do 0 -> num_enter_parameters;
               enter_parameters.clear;
               p.getparam_dcls -> d[];
               d.newscan
               (# 
               do &declarator_info[] -> dcl_info[] -> symbols.append;
                  (dcl_info[], current[]) -> do_param_dcl;
               #);
            #);
          do_param_dcl:
            (# d: ^idl.param_dcl;
               do_const:
                 (# c: ^idl.const_key;
                 enter c[]
                 do (*'const' -> outfile.comment;*)
                 #);
               
               do_param_type_spec:
                 (# t: ^idl.param_type_spec;
                    s: ^idl.param_scoped_name;
                    b: ^idl.param_base_type_spec;
                    dcl_info: ^declarator_info;
                 enter (dcl_info[], t[])
                 do (if t.symbol
                     // idl.param_base_type_spec then
                        (dcl_info[], (t[]->b[]).getbase_type_spec)
                          -> do_base_type_spec;
                        put_arg;
                        (if dcl_info.pointer_level+dcl_info.type.pointer_level
                         // 0 then '@' -> outfile.put;
                            dcl_info.type.representation[] -> outfile.puttext;
                         // 1 then '^' -> outfile.put;
                            dcl_info.type.representation[] -> outfile.puttext;
                            'Holder' -> outfile.puttext;
                         else
                            'pointerlevel>1 for param_base_type_spec'
                              -> putline;
                        if);
                        (if dcl_info.type_comment[]<>NONE then
                            outfile.CommentBegin;
                            dcl_info.type_comment[] -> outfile.puttext;
                            outfile.CommentEnd;
                        if);
                     // idl.param_string_type then
                        put_arg;
                        '@integer (* param_string_type NYI *)' 
                          -> outfile.puttext;
                     // idl.param_scoped_name then
                        (t[]->s[]).getscoped_name -> do_scoped_name -> 
                        local_types.findtype
                        (# pointer_level: @integer;
                           isString, isWide: @boolean;
                        do current[] -> dcl_info.type[];
                           put_arg;
                           (* We must add pointer levels from
                            * declarator with type's pointer
                            * level!
                            *)
                           dcl_info.pointer_level + current.pointer_level
                             -> pointer_level;
                           
                           (* We must handle texts specially *)
                           (((current.attributes[]<>NONE) and
                              current.attributes.array_size.string) or
                            ((dcl_info.attributes[]<>NONE) and
                              dcl_info.attributes.array_size.string)) 
                             -> isString;
                           
                           (if true 
                            // isString then
                               (* scoped name which is string attributes *)
                               (if true
                                // 'wchar_t'->current.name.equal 
                                // 'signed_wchar_t'->current.name.equal 
                                // 'unsigned_wchar_t'->current.name.equal then
                                   true -> isWide;
                               if);
                               (if pointer_level
                                // 0 then
                                   (if isWide then
                                       '@wtext' -> outfile.puttext;
                                    else
                                       '[0]@char (* @text NYI *)' 
                                         -> outfile.puttext;
                                   if);
                                // 1 then
                                   (if isWide then
                                       '^wtext' -> outfile.puttext;
                                    else
                                       '[0]@char (* ^text NYI *)' 
                                         -> outfile.puttext;
                                       (* FIXME: arrrgh: The put_arg above has
                                        * added '[]' to the end of 
                                        * enter_parameters, since it is 
                                        * actually a reference (:-(. 
                                        * I have to delete it - it's the 
                                        * only way
                                        *)
                                       (enter_parameters.length-1,
                                        enter_parameters.length) 
                                         -> enter_parameters.delete;
                                   if);
                                // 2 then
                                   (if isWide then
                                       '^wtextHolder' -> outfile.puttext;
                                    else
                                       '^textHolder' -> outfile.puttext;
                                   if);
                                else
                                   'pointerlevel>2 for string!;' 
                                     -> outfile.puttext;
                                   'pointerlevel>2 for string not supported!' 
                                     -> screen.putline;
                               if);
                            // current.representation[] <> NONE then
                               (* Scoped name which is not string *)
                               (if pointer_level
                                // 0 then
                                   '@' -> outfile.put;
                                   (* yet some more special cases *)
                                   (if true
                                    // 'BSTR' -> current.representation.equal
                                    // 'VARIANT' -> current.representation.equal
                                       then
                                       'int32' -> outfile.puttext;
                                    else
                                       current.representation[]->outfile.puttext;
                                   if);
                                // 1 then
                                   '^' -> outfile.put;
                                   current.representation[]->outfile.puttext;
                                   (if current.category=type_cat_basic then
                                       (* pointer to basic type *)
                                       'Holder' -> outfile.puttext;
                                   if);
                                // 2 then
                                   '^' -> outfile.put;
                                   current.representation[]->outfile.puttext;
                                   'Holder' -> outfile.puttext;
                                   (if current.category=type_cat_basic then
                                       'pointer-to-pointer-to-basictype not supported' -> error;
                                   if);
                                else
                                   'pointerlevel>2!;' 
                                     -> outfile.puttext;
                                   'pointer_level>2 not supported!' 
                                     -> error;
                               if)
                            else
                               '@' -> outfile.put;
                               current.representation[] -> outfile.puttext;
                           if);
                        #) 
                     // idl.param_void then
                        (if true
                         // arg_info.pointer_level=1 then
                            put_arg;
                            '@integer (* void* *)' -> outfile.puttext;
                         // arg_info.pointer_level=2 then
                            put_arg;
                            '@integer (* void** *)' -> outfile.puttext;
                         else
                            (* If a parameter has type 
                             * void, then it must mean that
                             * there are NO parameters! 
                             * I.e. foo(void).
                             *)
                            (if num_enter_parameters=0 then
                                'No parameters' 
                                  -> outfile.comment;
                             else
                                (# msg: ^text;
                                do 'Met void parameter at ' -> msg[];
                                   'num_enter_parameters=' -> msg.append;
                                   num_enter_parameters
                                     -> msg.putint;
                                   msg[] -> error;
                                #);
                            if);
                        if);
                    if);
                    ' '->outfile.put; dcl_info.as_text->outfile.comment;
                 #);
               put_arg:
                 (* Put out the parameter name, and remember it in
                  * enter_parameters for later emission of enter list
                  *)
                 (# 
                 do (if arg_info.type[]=NONE then
                        'put_arg('->puttext;
                        arg_info.name[] -> puttext;
                        ') called with no type' -> putline;
                    if);
                    (if arg_info.name[] = NONE then
                        generate_param_name;
                    if);
                    arg_info.name[] -> outfile.puttext;
                    ': ' -> outfile.puttext;
                    num_enter_parameters+1 -> num_enter_parameters;
                    (if num_enter_parameters>1 then
                        ', ' -> enter_parameters.append;
                    if);
                    arg_info.name.copy -> enter_parameters.append;
                    (if arg_info.pointer_level+arg_info.type.pointer_level>0
                        then '[]' -> enter_parameters.append;
                    if);
                 #);
               generate_param_name:
                 (# 
                 do 'arg' -> arg_info.name[];
                    num_enter_parameters->arg_info.name.putint;
                 #);
               arg_info: ^declarator_info;
            enter (arg_info[], d[])
            do outfile.indent;
               (if d.getconst2->optionalPresent then
                   d.getconst2->do_const;
               if);
               (if d.getdeclarator->optionalPresent then
                   (arg_info[], d.getdeclarator)->do_declarator
                else
                   generate_param_name;
               if);
               (if d.getconst1->optionalPresent then
                   d.getconst1->do_const;
               if);
               (if d.getattributes_spec_opt->optionalPresent then
                   (if arg_info.attributes[]=NONE then
                        &idl_attributes[] -> arg_info.attributes[];
                    if);
                   (arg_info.attributes[],d.getattributes_spec_opt)->do_attributes_spec;
               if);
               (arg_info[], d.gettype) -> do_param_type_spec;
               ';' -> outfile.putline;
            #);
          result_present: @boolean;
          num_enter_parameters: @integer;
          enter_parameters: @text;
          do_op_type_spec:
            (# t: ^idl.op_type_spec;
               s: ^idl.param_scoped_name;
               res_info: ^type_info;
            enter t[]
            do false -> result_present;
               (if t.symbol
                // idl.void then
                   'No result' -> outfile.comment;
                // idl.void_ref then
                   true -> result_present;
                   'result: ^IUnknown ' -> outfile.puttext;
                   'void*' -> outfile.comment;
                   ';' -> outfile.put;
                   'void* result translated to ^IUnknown'->warning
                // idl.param_base_type_spec then
                   true -> result_present;
                   'result: @integer ' -> outfile.puttext;
                   'param_base_type_spec NYI' -> outfile.comment;
                   ';' -> outfile.put;
                // idl.param_string_type then
                   true -> result_present;
                   'result: @integer ' -> outfile.puttext;
                   'param_string_type NYI' -> outfile.comment;
                   ';' -> outfile.put;
                // idl.param_scoped_name then
                   true -> result_present;
                   'result: ' -> outfile.puttext;
                   (t[]->s[]).getscoped_name 
                     -> do_scoped_name 
                     -> local_types.findtype
                   (# 
                   do current[] -> res_info[];
                      (if current.representation[] <> NONE then
                          (if current.pointer_level
                           // 0 then
                              '@' -> outfile.put;
                              current.representation[] -> outfile.puttext;
                           // 1 then
                              (* pointer to basic type *)
                              '^' -> outfile.put;
                              current.representation[] -> outfile.puttext;
                              'Holder' -> outfile.puttext;
                           else
                              'pointer_level>1 for basictype NYI' 
                                ->  putline;
                          if)
                       else
                          '@' -> outfile.put;
                          current.representation[] -> outfile.puttext;
                      if);
                      ' '->outfile.put; current.as_text->outfile.comment;
                   #);                                  
                   ';' -> outfile.put;
                // idl.param_void then
                   false -> result_present;
                   'No result' -> outfile.comment;
                   ';' -> outfile.put;
                // idl.param_type_spec_ref then
                   true -> result_present;
                   'result: @integer ' -> outfile.puttext;
                   'param_type_spec_ref NYI'
                     -> outfile.comment;
                   ';' -> outfile.put;
               if);
               outfile.newline;
            #);
          e: ^idl.op_dcl;
          virtual_name, property_name: ^text;
          att: @idl_attributes;
       enter e[]
       do NONE -> property_name[];
          outfile.indent;
          (* Start a virtual *)
          e.getIdentifier 
            -> IdentifierToText 
            -> virtual_name[];
          (if e.getattributes_spec_opt -> optionalPresent then
              (att[], e.getattributes_spec_opt) -> do_attributes_spec
          if);
          (if att.typelib.propget then
              (* If both a propput and a propget, save for help pattern *)
              propputs.find
              (# predicate::(# do virtual_name[] -> current.equal -> value #);
                 notfound::(# do virtual_name.copy -> propgets.append; #);
              do virtual_name.copy-> property_name[];
              #);
              'get' -> virtual_name.prepend;
          if);
          (if att.typelib.propput then
              (* If both a propput and a propget, save for help pattern *)
              propgets.find
              (# predicate::(# do virtual_name[] -> current.equal -> value #);
                 notfound::(# do virtual_name.copy -> propputs.append; #);
              do virtual_name.copy-> property_name[];
              #);
              'put' -> virtual_name.prepend;
          if);
          (if verbose then
              '      [' -> screen.puttext;
              virtual_name[] -> screen.puttext;
              ']' -> screen.putline;
          if);
          virtual_name[] -> outfile.puttext;
          ':< ' -> outfile.puttext;
          outfile.newline;
          2 -> outfile.indent.inc;
          (if att.typelib.helpstring[] <> NONE then
              outfile.indent;
              att.typelib.helpstring[] -> outfile.commentline;
          if);
          (if e.getraises_exprOpt -> optionalPresent then
              e.getraises_exprOpt -> do_raises_expr;
          if);
          (if e.getcontext_exprOpt -> optionalPresent then
              e.getcontext_exprOpt -> do_context_expr;
          if);
          outfile.indent;
          outfile.PatternBegin;
          (* Handle the exit parameter *)
          e.getop_type_spec -> do_op_type_spec;
          3 -> outfile.indent.inc;
          (* Handle the enter parameters *)
          e.getparameter_dcls -> do_parameter_dcls;
          
          (* Finish this virtual - emit enter,do,exit *)
          3 -> outfile.indent.dec;
          (if num_enter_parameters>0 then
              outfile.indent;
              'enter ' -> outfile.puttext;
              (if num_enter_parameters>1 then 
                  '(' -> outfile.put;
              if);
              enter_parameters[] -> outfile.puttext;
              (if num_enter_parameters>1 then 
                  ')' -> outfile.put;
              if);
              outfile.newline;
          if);
          (if e.getstd_call_opt -> optionalPresent then
              outfile.indent;
              (*'do CallStd;' -> outfile.putline;*)
              '__stdcall' -> outfile.commentline;
           else
              (* outfile.indent; *)
              (*'do CallC;' -> outfile.putline;*)
          if);
          (if result_present then
              outfile.indent;
              'exit result' -> outfile.putline;
          if);
          outfile.indent;
          outfile.PatternEnd;
          ';' -> outfile.putline;
          2 -> outfile.indent.dec;
          (if property_name[]<>NONE then
              (* Emit help pattern *)
              outfile.indent;
              property_name[] -> outfile.puttext;
              ': ' -> outfile.puttext;
              'property' -> outfile.commentline;
              2 -> outfile.indent.inc;
              outfile.indent;
              outfile.patternbegin;
              'enter put' -> outfile.puttext;
              property_name[] -> outfile.puttext;
              ' exit get' -> outfile.puttext;
              property_name[] -> outfile.puttext;
              ' '->outfile.put;
              outfile.patternend;
              ';' -> outfile.putline;
              2 -> outfile.indent.dec;
          if);
          (if trace then
              newline;
              '    Trace: Symbols for virtual '->puttext;
              virtual_name[] -> puttext;
              ':' -> putline;
              '    '->screen.puttext; screen.line;
              symbols.print;
          if);
          symbols.clear (* forget symbols from this virtual before the next *)
       #);
  enter e[]
  do e.getop_dcl -> do_op_dcl;
  #);
do_cpp_quote:
  (# c: ^idl.cpp_quote;
  enter c[]
  do outfile.indent;
     c.getString -> StringToText -> outfile.commentline;
  #);
do_export_import:
  (# e: ^idl.export_import;
     i: ^idl.import;
  enter e[]
  do e.getimport -> i[];
     i.getString -> StringToText -> imports.append;
  #);
do_export_error:
  (# e: ^idl.export_error;
  enter e[]
  do outfile.indent;
     'do_export_error NYI' -> outfile.commentline;
  #);

--interface_body_body: dopart--
do (if b.getexports_opt -> optionalPresent then
       b.getexports_opt -> e[];
       e.newscan
       (# 
       do (if current.symbol
           // idl.export_type_dcl then
              current[] -> do_export_type_dcl
           // idl.export_const_dcl then
              current[] -> do_export_const_dcl
           // idl.export_except_dcl then
              current[] -> do_export_except_dcl
           // idl.export_attr_dcl then
              current[] -> do_export_attr_dcl
           // idl.export_op_dcl then
              current[] -> do_export_op_dcl (* The usual entry *)
           // idl.export_import then
              current[] -> do_export_import
           // idl.cpp_quote then
              current[] -> do_cpp_quote
           // idl.export_error then
              current[] -> do_export_error 
          if);
       #); 
   if);
   
   (* End pattern.
    * The following is matched by the pattern-begin in 
    * do_interface_header
    *)
   3 -> outfile.indent.dec;
   outfile.indent;
   outfile.PatternEnd;
   ';' -> outfile.putline;
   2 -> outfile.indent.dec;
   
