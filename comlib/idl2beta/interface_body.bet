ORIGIN 'translate'

-- interface_body_lib: attributes--
do_export_type_dcl:
  (# e: ^idl.export_type_dcl;
  enter e[]
  do e.gettype_dcl -> do_type_dcl;
  #);
do_export_const_dcl:
  (# e: ^idl.export_const_dcl;
  enter e[]
  do e.getconst_dcl -> do_const_dcl;
  #);
do_export_except_dcl:
  (# e: ^idl.export_except_dcl;
  enter e[]
  do (if not compact then output.indent; if);
     'do_export_except_dcl NYI' -> output.commentline;
  #);
do_export_attr_dcl:
  (# e: ^idl.export_attr_dcl;
  enter e[]
  do (if not compact then output.indent; if);
     'do_export_attr_dcl NYI' -> output.commentline;
  #);

do_export_op_dcl:
  (# e: ^idl.export_op_dcl;
     do_op_dcl:
       (# do_raises_expr:
            (# o: ^idl.raises_expr;
            enter o[]
            do (if not compact then output.indent; if);
               'do_raises_expr NYI' -> output.commentline;
            #);
          do_context_expr:
            (# o: ^idl.context_expr;
            enter o[]
            do (if not compact then output.indent;if);
               'do_context_expr NYI' -> output.commentline;
            #);
          do_parameter_dcls:
            (# p: ^idl.parameter_dcls;
               d: ^idl.param_dcls;
               dcl_info: ^declarator_info;
            enter (p[])
            do 0 -> num_enter_parameters;
               enter_parameters.clear;
               p.getparam_dcls -> d[];
               d.newscan
               (# 
               do &declarator_info[] -> dcl_info[] -> symbols.append;
                  (dcl_info[], current[]) -> do_param_dcl;
               #);
            #);
          do_param_dcl:
            (# do_const:
                 (# c: ^idl.const_key;
                 enter c[]
                 do (*'const' -> output.comment;*)
                 #);
               
               do_param_type_spec:
                 (# 
                    do_param_scoped_name:
                      (# s: ^idl.param_scoped_name;
                      enter s[]
                      do (s.getscoped_name -> do_scoped_name, NONE) -> 
                         local_types.findtype
                         (# pointer_level: @integer;
                            isString, isWide: @boolean;
                         do current[] -> dcl_info.type[];
                            put_arg;
                            (* We must add pointer levels from
                             * declarator with type's pointer
                             * level!
                             *)
                            dcl_info.pointer_level + current.pointer_level
                              -> pointer_level;
                            
                            (* We must handle texts specially *)
                            (((current.attributes[]<>NONE) and
                            current.attributes.array_size.string) or
                            ((dcl_info.attributes[]<>NONE) and
                            dcl_info.attributes.array_size.string)) 
                              -> isString;
                            
                            (if true 
                             // isString then
                                (* scoped name which is string attributed *)
                                (if true
                                 // 'wchar_t'->current.name.equal 
                                 // 'signed_wchar_t'->current.name.equal 
                                 // 'unsigned_wchar_t'->current.name.equal then
                                    true -> isWide;
                                if);
                                (if pointer_level
                                 // 0 then
                                    (if isWide then
                                        '@wtext' -> output.puttext;
                                     else
                                        '[0]@char' -> output.puttext;
                                        '@text NYI' -> output.spacecomment;
                                    if);
                                 // 1 then
                                    (if isWide then
                                        '^wtext' -> output.puttext;
                                     else
                                        '[0]@char' -> output.puttext;
                                        '^text NYI' -> output.spacecomment;

                                        (* FIXME: arrrgh: The put_arg above has
                                         * added '[]' to the end of 
                                         * enter_parameters, since it is 
                                         * actually a reference (:-(. 
                                         * I have to delete it - it's the 
                                         * only way
                                         *)
                                        (enter_parameters.length-1,
                                        enter_parameters.length) 
                                          -> enter_parameters.delete;
                                    if);
                                 // 2 then
                                    (if isWide then
                                        '^wtextHolder' -> output.puttext;
                                     else
                                        '^textHolder' -> output.puttext;
                                    if);
                                 else
                                    'pointerlevel>2 for string!;' 
                                      -> output.puttext;
                                    'pointerlevel>2 for string not supported!' 
                                      -> error;
                                if);
                             // current.representation[] <> NONE then
                                (* Scoped name which is not string *)
                                (if pointer_level
                                 // 0 then
                                    '@' -> output.put;
                                    (* yet some more special cases *)
                                    (if true
                                     // 'GUID' -> current.representation.equal
                                     // 'IID' -> current.representation.equal
                                     // 'CLSID' -> current.representation.equal
                                     // 'BSTR' -> current.representation.equal
                                     // 'VARIANT' -> current.representation.equal
                                        then
                                        'int32' -> output.puttext;
                                     else
                                        current.representation[]->output.puttext;
                                    if);
                                 // 1 then
                                    '^' -> output.put;
                                    current.representation[]->output.puttext;
                                    (if current.category
                                     // type_cat_basic 
                                     // type_cat_enum 
                                        then
                                        (* pointer to basic type *)
                                        'Holder' -> output.puttext;
                                    if);
                                 // 2 then
                                    '^' -> output.put;
                                    current.representation[]->output.puttext;
                                    'Holder' -> output.puttext;
                                    (if current.category
                                     // type_cat_basic 
                                     // type_cat_enum 
                                        then
                                        (# msg: ^text;
                                        do 'pointer-to-pointer-to-basictype not supported.' 
                                             -> msg[];
                                           '\n        Using \'' -> msg.puttext;
                                           current.representation[]->msg.puttext;
                                           'Holder\' for parameter \''->msg.puttext;
                                           dcl_info.name[] -> msg.puttext;
                                           '\'.'->msg.puttext;
                                           msg[] -> warning;
                                        #);
                                    if);
                                 else
                                    'pointerlevel>2!;' 
                                      -> output.puttext;
                                    'pointer_level>2 not supported!' 
                                      -> error;
                                if)
                             else
                                '@' -> output.put;
                                current.representation[] -> output.puttext;
                            if);
                         #) 
                      #);
                    
                    do_param_base_type_spec:
                      (# b: ^idl.param_base_type_spec;
                      enter b[]
                      do (dcl_info[], b.getbase_type_spec)
                           -> do_base_type_spec;
                         put_arg;
                         (if dcl_info.pointer_level+dcl_info.type.pointer_level
                          // 0 then '@' -> output.put;
                             dcl_info.type.representation[] -> output.puttext;
                          // 1 then '^' -> output.put;
                             dcl_info.type.representation[] -> output.puttext;
                             'Holder' -> output.puttext;
                          else
                             'pointerlevel>1 for param_base_type_spec'
                               -> putline;
                         if);
                         (if (dcl_info.type_comment[]<>NONE) 
                             and (not compact) then
                             dcl_info.type_comment[] -> output.comment;
                         if);
                      #);
                    
                    do_param_void:
                      (# msg: ^text;
                      do (if true
                          // arg_info.pointer_level=1 then
                             put_arg;
                             '@int32' -> output.puttext;
                             'void*' -> output.spacecomment;
                             'Using \'int32\' for \'void*\' parameter \''
                               ->msg[];
                             arg_info.name[] -> msg.puttext;
                             '\'.' -> msg.puttext;
                             msg[] -> warning;
                          // arg_info.pointer_level=2 then
                             put_arg;
                             '@int32' -> output.puttext;
                             'void**' -> output.spacecomment;
                             'Using \'int32\' for \'void**\' parameter \''
                               ->msg[];
                             arg_info.name[] -> msg.puttext;
                             '\'.' -> msg.puttext;
                          else
                             (* If a parameter has type 
                              * void, then it must mean that
                              * there are NO parameters! 
                              * I.e. foo(void).
                              *)
                             (if (num_enter_parameters=0) then
                                 (if not compact then
                                     'No parameters' -> output.comment;
                                 if);
                              else
                                 (# msg: ^text;
                                 do 'Met void parameter \'' -> msg[];
                                    arg_info.name[] -> msg.append;
                                    '\' at num_enter_parameters='-> msg.append;
                                    num_enter_parameters
                                      -> msg.putint;
                                    msg[] -> error;
                                 #);
                             if);
                         if)
                      #);
                    
                    t: ^idl.param_type_spec;
                    dcl_info: ^declarator_info;
                 enter (dcl_info[], t[])
                 do (if t.symbol
                     // idl.param_base_type_spec then
                        t[] -> do_param_base_type_spec;
                     // idl.param_string_type then
                        put_arg;
                        '@integer' -> output.puttext;
                        'param_string_type NYI' -> output.comment;
                        'param_string_type not yet implemented, sorry!' 
                          -> error;
                     // idl.param_scoped_name then
                        t[] -> do_param_scoped_name;
                     // idl.param_void then
                        do_param_void;
                        ;
                    if);
                    dcl_info.as_text->output.spacecomment;
                 #);
               put_arg:
                 (* Put out the parameter name, and remember it in
                  * enter_parameters for later emission of enter list
                  *)
                 (# 
                 do (if arg_info.name[] = NONE then
                        generate_param_name;
                    if);
                    arg_info.name[] -> output.puttext;
                    ': ' -> output.puttext;
                    num_enter_parameters+1 -> num_enter_parameters;
                    (if num_enter_parameters>1 then
                        ', ' -> enter_parameters.append;
                    if);
                    arg_info.name.copy -> enter_parameters.append;
                    (if arg_info.type[]=NONE then
                        (if debug then
                            'put_arg('->puttext;
                            arg_info.name[] -> puttext;
                            ') called with type=NONE' -> putline;
                        if);
                     else
                        (if arg_info.pointer_level + 
                            arg_info.type.pointer_level > 0 then 
                            '[]' -> enter_parameters.append;
                        if);
                    if);
                 #);
               generate_param_name:
                 (# 
                 do 'arg' -> arg_info.name[];
                    num_enter_parameters->arg_info.name.putint;
                 #);
               arg_info: ^declarator_info;
               pd: ^idl.param_dcl;
               sd: ^idl.simple_param_dcl;
               fd: ^idl.fnc_ptr_param_dcl;
            enter (arg_info[], pd[])
            do (if not compact then output.indent; if);
               (if arg_info.attributes[]=NONE then
                   &idl_attributes[] -> arg_info.attributes[];
               if);
               
               (if pd.symbol
                // idl.simple_param_dcl then
                   pd[] -> sd[];
                   (arg_info.attributes[],sd.getattributes_specs)
                     -> do_attributes_specs;
                   (if sd.getdeclarator->optionalPresent then
                       (arg_info[], sd.getdeclarator)->do_declarator
                   if);
                   (arg_info[], sd.gettype) -> do_param_type_spec;
                // idl.fnc_ptr_param_dcl then
                   (* Function pointer parameter *)
                   pd[] -> fd[];
                   fd.getfnc_ptr_type_declarator 
                     -> do_fnc_ptr_type_declarator 
                     -> (arg_info.name[], arg_info.type[]);
                   put_arg;
                   '@' -> output.put;
                   arg_info.type.representation[] -> output.puttext;
                   arg_info.as_text->output.spacecomment;
                else
                   'unknown parameter kind' -> error;
               if);
               '; ' -> output.puttext;
               (if not compact then output.newline if);
            #);
          result_present: @boolean;
          num_enter_parameters: @integer;
          enter_parameters: @text;
          do_op_type_spec:
            (# t: ^idl.op_type_spec;
               s: ^idl.param_scoped_name;
               res_info: ^type_info;
            enter t[]
            do false -> result_present;
               (if t.symbol
                // idl.void then
                   'No result' -> output.comment;
                // idl.void_ref then
                   true -> result_present;
                   'result: ^IUnknown' -> output.puttext;
                   'void*' -> output.spacecomment;
                   ';' -> output.put;
                   'void* result translated to ^IUnknown'->warning
                // idl.param_base_type_spec then
                   true -> result_present;
                   'result: @integer ' -> output.puttext;
                   'param_base_type_spec NYI' -> output.comment;
                   ';' -> output.put;
                // idl.param_string_type then
                   true -> result_present;
                   'result: @integer ' -> output.puttext;
                   'param_string_type NYI' -> output.comment;
                   ';' -> output.put;
                // idl.param_scoped_name then
                   true -> result_present;
                   'result: ' -> output.puttext;
                   ((t[]->s[]).getscoped_name -> do_scoped_name, NONE)
                     -> local_types.findtype
                   (# 
                   do current[] -> res_info[];
                      (if current.representation[] <> NONE then
                          (if current.pointer_level
                           // 0 then
                              '@' -> output.put;
                              current.representation[] -> output.puttext;
                           // 1 then
                              (* pointer to basic type *)
                              '^' -> output.put;
                              current.representation[] -> output.puttext;
                              'Holder' -> output.puttext;
                           else
                              'pointer_level>1 for basictype NYI' 
                                ->  putline;
                          if)
                       else
                          '@' -> output.put;
                          current.representation[] -> output.puttext;
                      if);
                      current.as_text->output.spacecomment;
                   #);                                  
                   ';' -> output.put;
                // idl.param_void then
                   false -> result_present;
                   'No result' -> output.comment;
                   ';' -> output.put;
                // idl.param_type_spec_ref then
                   true -> result_present;
                   'result: @integer ' -> output.puttext;
                   'param_type_spec_ref NYI' -> output.comment;
                   ';' -> output.put;
               if);
               (if compact then 
                   ' '-> output.put;
                else
                   output.newline;
               if);
            #);
          e: ^idl.op_dcl;
          virtual_name, property_name: ^text;
          att: @idl_attributes;
       enter e[]
       do NONE -> property_name[];
          output.indent;
          (* Start a virtual *)
          e.getIdentifier 
            -> IdentifierToText 
            -> virtual_name[];
          (att[], e.getattributes_specs) -> do_attributes_specs;
          (if att.typelib.propget then
              (* If both a propput and a propget, save for help pattern *)
              propputs.find
              (# predicate::(# do virtual_name[] -> current.equal -> value #);
                 notfound::(# do virtual_name.copy -> propgets.append; #);
              do virtual_name.copy-> property_name[];
              #);
              'get' -> virtual_name.prepend;
          if);
          (if att.typelib.propput then
              (* If both a propput and a propget, save for help pattern *)
              propgets.find
              (# predicate::(# do virtual_name[] -> current.equal -> value #);
                 notfound::(# do virtual_name.copy -> propputs.append; #);
              do virtual_name.copy-> property_name[];
              #);
              'put' -> virtual_name.prepend;
          if);
          (if verbose then
              '      [' -> screen.puttext;
              virtual_name[] -> screen.puttext;
              ']' -> screen.putline;
          if);
          virtual_name[] -> output.puttext;
          ':<' -> output.puttext;
          (if not compact then 
              output.newline;
              2 -> output.indent.inc;
              (if att.typelib.helpstring[] <> NONE then
                  output.indent;
                  att.typelib.helpstring[] -> output.commentline;
              if);
          if);
          (if e.getraises_expr_Opt -> optionalPresent then
              e.getraises_expr_Opt -> do_raises_expr;
          if);
          (if e.getcontext_expr_Opt -> optionalPresent then
              e.getcontext_expr_Opt -> do_context_expr;
          if);
          (if not compact then 
              output.indent;
          if);
          output.PatternBegin;
          (* Handle the exit parameter *)
          e.getop_type_spec -> do_op_type_spec;
          (if not compact then 3 -> output.indent.inc; if);
          (* Handle the enter parameters *)
          e.getparameter_dcls -> do_parameter_dcls;
          
          (* Finish this virtual - emit enter,do,exit *)
          (if not compact then 3 -> output.indent.dec; if);
          (if num_enter_parameters>0 then
              (if not compact then output.indent; if);
              'enter ' -> output.puttext;
              (if num_enter_parameters>1 then 
                  '(' -> output.put;
              if);
              enter_parameters[] -> output.puttext;
              (if num_enter_parameters>1 then 
                  ')' -> output.put;
              if);
              (if not compact then output.newline; if);
          if);
          (if (e.getstd_call_opt -> optionalPresent) and (not compact) then
              output.indent;
              '__stdcall' -> output.commentline;
          if);
          (if result_present then
              (if not compact then 
                  output.indent;
               else
                  ' ' -> output.put
              if);
              'exit result' -> output.puttext;
          if);
          (if not compact then 
              output.newline;
              output.indent;
           else
              ' ' -> output.put;
          if);
          output.PatternEnd;
          ';' -> output.putline;
          (if not compact then 
              2 -> output.indent.dec;
              (if (property_name[]<>NONE) then
                  (* Emit help pattern *)
                  output.indent;
                  property_name[] -> output.puttext;
                  ': ' -> output.puttext;
                  'property' -> output.commentline;
                  2 -> output.indent.inc;
                  output.indent;
                  output.patternbegin;
                  'enter put' -> output.puttext;
                  property_name[] -> output.puttext;
                  ' exit get' -> output.puttext;
                  property_name[] -> output.puttext;
                  ' '->output.put;
                  output.patternend;
                  ';' -> output.putline;
                  2 -> output.indent.dec;
              if);
          if);
          (if trace then
              newline;
              '    Trace: Symbols for virtual '->puttext;
              virtual_name[] -> puttext;
              ':' -> putline;
              '    '->screen.puttext; screen.line;
              symbols.print;
          if);
          symbols.clear (* forget symbols from this virtual before the next *)
       #);
  enter e[]
  do e.getop_dcl -> do_op_dcl;
  #);
do_cpp_quote:
  (# c: ^idl.cpp_quote;
  enter c[]
  do (if not compact then output.indent; if);
     c.getString -> StringToText -> output.commentline;
  #);
do_export_error:
  (# e: ^idl.export_error;
  enter e[]
  do (if not compact then output.indent; if);
     'do_export_error NYI' -> output.commentline;
  #);

--interface_body_body: dopart--
do (if b.getexports_opt -> optionalPresent then
       b.getexports_opt -> e[];
       e.newscan
       (# 
       do (if current.symbol
           // idl.export_type_dcl then
              current[] -> do_export_type_dcl
           // idl.export_const_dcl then
              current[] -> do_export_const_dcl
           // idl.export_except_dcl then
              current[] -> do_export_except_dcl
           // idl.export_attr_dcl then
              current[] -> do_export_attr_dcl
           // idl.export_op_dcl then
              current[] -> do_export_op_dcl (* The usual entry *)
           // idl.export_import then
              (* handled by scanForImports *)
           // idl.cpp_quote then
              current[] -> do_cpp_quote
           // idl.export_error then
              current[] -> do_export_error 
          if);
       #); 
   if);
   
   (* End pattern.
    * The following is matched by the pattern-begin in 
    * do_interface_header
    *)
   3 -> output.indent.dec;
   output.indent;
   output.PatternEnd;
   ';' -> output.putline;
   2 -> output.indent.dec;
   
