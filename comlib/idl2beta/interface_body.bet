ORIGIN 'translate'

-- interface_body_lib: attributes--
do_export_type_dcl:
  (# e: ^idl.export_type_dcl;
  enter e[]
  do outfile.indent;
     'do_export_type_dcl NYI' -> outfile.commentline;
  #);
do_export_const_dcl:
  (# e: ^idl.export_const_dcl;
  enter e[]
  do outfile.indent;
     'do_export_const_dcl NYI' -> outfile.commentline;
  #);
do_export_except_dcl:
  (# e: ^idl.export_except_dcl;
  enter e[]
  do outfile.indent;
     'do_export_except_dcl NYI' -> outfile.commentline;
  #);
do_export_attr_dcl:
  (# e: ^idl.export_attr_dcl;
  enter e[]
  do outfile.indent;
     'do_export_attr_dcl NYI' -> outfile.commentline;
  #);

do_export_op_dcl:
  (# e: ^idl.export_op_dcl;
     do_op_dcl:
       (# do_op_attribute:
            (# o: ^idl.op_attribute;
            enter o[]
            do outfile.indent;
               'do_op_attribute NYI' -> outfile.commentline;
            #);
          do_raises_expr:
            (# o: ^idl.raises_expr;
            enter o[]
            do outfile.indent;
               'do_raises_expr NYI' -> outfile.commentline;
            #);
          do_context_expr:
            (# o: ^idl.context_expr;
            enter o[]
            do outfile.indent;
               'do_context_expr NYI' -> outfile.commentline;
            #);
          do_parameter_dcls:
            (# p: ^idl.parameter_dcls;
               d: ^idl.param_dcls;
            enter p[]
            do 0 -> num_enter_parameters;
               p.getparam_dcls -> d[];
               d.newscan
               (# 
               do current[] -> do_param_dcl;
               #);
            #);
          do_param_dcl:
            (# d: ^idl.param_dcl;
               do_param_attributes:
                 (# do_attributeY:
                      (# y: ^idl.attributeY;
                         ca: ^idl.call_as;
                         aii: ^idl.att_iid_is;
                         ii: ^idl.iid_is;
                         ta: ^idl.transmit_as;
                         st: ^idl.switch_type;
                         si: ^idl.switch_is;
                         ac: ^idl.att_case;
                         zi: ^idl.size_is;
                         li: ^idl.length_is;
                         p, pp: @boolean;
                      enter y[]
                      do (if y.symbol
                          // idl.att_unique then
                             'unique'->outfile.puttext;
                          // idl.att_ref then
                             'ref'->outfile.puttext;
                          // idl.att_in then
                             'in'->outfile.puttext;
                          // idl.att_out then
                             'out'->outfile.puttext;
                          // idl.att_in_out then
                             'in_out'->outfile.puttext;
                          // idl.att_local then
                             'local'->outfile.puttext;
                          // idl.call_as then
                             'call_as('->outfile.puttext;
                             (y[]->ca[]).getIdentifier
                               -> IdentifierToText
                               -> outfile.puttext;
                             ')'->outfile.put;
                          // idl.att_iid_is then
                             'iid_is('->outfile.puttext;
                             (y[]->aii[]).getiid_is->ii[];
                             ii.getIdentifier
                               -> IdentifierToText
                               -> outfile.puttext;
                             ')'->outfile.put;
                          // idl.size_is then
                             'size_is('->outfile.puttext;
                             (y[]->zi[]).getconst_exp->do_const_exp;
                             ')'->outfile.put;
                          // idl.length_is then
                             'length_is('->outfile.puttext;
                             (* Save booleans *)
                             arg_is_pointer -> p;
                             arg_is_pointer_pointer -> pp;
                             (outfile[], (y[]->li[]).getdeclarator)
                               -> do_declarator;
                             p -> arg_is_pointer;
                             pp -> arg_is_pointer_pointer;
                             ')'->outfile.put;
                          // idl.v1_enum then
                             'v1_enum'->outfile.puttext;
                          // idl.transmit_as then
                             'transmit_as('->outfile.puttext;
                             (y[]->ta[]).getIdentifier
                               -> IdentifierToText
                               -> outfile.puttext;
                             ')'->outfile.put;
                          // idl.att_string then
                             'string'->outfile.puttext;
                          // idl.switch_type then
                             'switch_type('->outfile.puttext;
                             (y[]->st[]).getIdentifier
                               -> IdentifierToText
                               -> outfile.puttext;
                             ')'->outfile.put;
                          // idl.switch_is then
                             'switch_is(('->outfile.puttext;
                             (y[]->si[]).getId1
                               -> IdentifierToText
                               -> outfile.puttext;
                             ')'->outfile.put;
                             si.getId2
                               -> IdentifierToText
                               -> outfile.puttext;
                             ')'->outfile.put;
                          // idl.att_case then
                             'case('->outfile.puttext;
                             (y[]->ac[]).getIdentifier
                               -> IdentifierToText
                               -> outfile.puttext;
                             ')'->outfile.put;
                          // idl.async then
                             'async'->outfile.puttext;
                         if);
                      #);
                    a: ^idl.param_attribute;
                    do_param_attribute_list:
                      (# l: ^idl.param_attribute_list;
                         x: ^idl.attributeX;
                         a: ^idl.attributes;
                      enter l[]
                      do l.getattributeX -> x[];
                         x.getattributes -> a[];
                         ' '->outfile.put;
                         outfile.CommentBegin;
                         a.newscan
                         (# first_done: @boolean;
                         do (if first_done then
                                ',' -> outfile.put;
                             else
                                true->first_done
                            if);
                            current[]->do_attributeY;
                         #);
                         outfile.CommentEnd;
                      #);
                 enter a[]
                 do (if a.symbol
                     // idl.in then
                        'in' -> outfile.comment;
                     // idl.out then
                        'out' -> outfile.comment;
                     // idl.in_out then
                        'inout' -> outfile.comment;
                     // idl.param_attribute_list then
                        a[] -> do_param_attribute_list;
                    if);
                    
                 #);
               do_const:
                 (# c: ^idl.const_key;
                 enter c[]
                 do (*'const' -> outfile.comment;*)
                 #);
               do_declarator: 
                 (# d: ^idl.declarator;
                    s: ^idl.simple_declarator;
                    p: ^idl.pointer_declarator;
                    a: ^idl.array_declarator;
                    pa: ^idl.pointer_to_array_declarator;
                    pp: ^idl.pointer_to_pointer_declarator;
                    out: ^stream;
                 enter (out[],d[])
                 do (* Find the NAME and POINTER STATUS
                     * of the parameter.
                     *)
                    (if d.symbol
                     // idl.simple_declarator then
                        (d[]->s[]).getidentifier 
                          -> IdentifierToText
                          -> out.puttext;
                     // idl.array_declarator then
                        (d[]->a[]).getidentifier
                          -> IdentifierToText
                          -> out.puttext;
                        true -> arg_is_pointer;
                     // idl.pointer_declarator then
                        (d[]->p[]).getidentifier 
                          -> IdentifierToText
                          -> out.puttext;
                        true -> arg_is_pointer;
                     // idl.pointer_to_pointer_declarator 
                        then
                        (d[]->pp[]).getidentifier 
                          -> IdentifierToText
                          -> out.puttext;
                        true -> arg_is_pointer_pointer;
                     // idl.pointer_to_array_declarator then
                        (d[]->pa[]).getarray_declarator->a[];
                        a.getidentifier
                          -> IdentifierToText
                          -> out.puttext;
                        true -> arg_is_pointer_pointer;
                    if)
                 #);
               put_arg:
                 (#
                 do arg[] -> outfile.puttext;
                    ': ' -> outfile.puttext;
                    num_enter_parameters+1
                      -> num_enter_parameters;
                    (if num_enter_parameters
                        > enter_parameters.range then
                        enter_parameters.range
                          -> enter_parameters.extend;
                    if);
                    arg.copy->
                    enter_parameters[num_enter_parameters][];
                    arg.reset;
                 #);
               generate_param_name:
                 (# 
                 do 'arg' -> arg.puttext;
                    num_enter_parameters->arg.putint;
                 #);
               do_param_type_spec:
                 (# t: ^idl.param_type_spec;
                    s: ^idl.param_scoped_name;
                 enter t[]
                 do (if t.symbol
                     // idl.param_base_type_spec then
                        put_arg;
                        '@integer (* param_base_type_spec NYI *)' 
                          -> outfile.puttext;
                     // idl.param_string_type then
                        put_arg;
                        '@integer (* param_string_type NYI *)' 
                          -> outfile.puttext;
                     // idl.param_scoped_name then
                        put_arg;
                        '@' -> outfile.put;
                        put_arg_pointer_status;
                        (t[]->s[]).getscoped_name
                          -> do_scoped_name;
                     // idl.param_void then
                        (if true
                         // arg_is_pointer then
                            put_arg;
                            '@integer (* void* *)'
                              -> outfile.puttext;
                         // arg_is_pointer_pointer then
                            put_arg;
                            '@integer (* void** *)'
                              -> outfile.puttext;
                         else
                            (* If a parameter has type 
                             * void, then it must mean that
                             * there are NO parameters! 
                             * I.e. foo(void).
                             *)
                            (if num_enter_parameters=0 then
                                'No parameters' 
                                  -> outfile.comment;
                                0->num_enter_parameters
                             else
                                'Error: Met void parameter at num_enter_parameters='
                                  -> screen.puttext;
                                num_enter_parameters
                                  -> screen.putint;
                                screen.newline;
                                stop;
                            if);
                        if)
                    if);
                 #);
               put_arg_pointer_status:
                 (# 
                 do (if arg_is_pointer then
                        '(*^*)' -> outfile.puttext;
                    if);
                    (if arg_is_pointer_pointer then
                        '(*^^*)' -> outfile.puttext;
                    if);
                 #);
               arg: @text;
               arg_is_pointer: @boolean;
               arg_is_pointer_pointer: @boolean;
            enter d[]
            do arg.reset;
               false -> arg_is_pointer;
               false -> arg_is_pointer_pointer;
               outfile.indent;
               (if d.getconst2->optionalPresent then
                   d.getconst2->do_const;
               if);
               (if d.getdeclarator->optionalPresent then
                   (arg[], d.getdeclarator)->do_declarator
                else
                   generate_param_name;
               if);
               (if d.getconst1->optionalPresent then
                   d.getconst1->do_const;
               if);
               d.gettype -> do_param_type_spec;
               (if d.getattributes->optionalPresent then
                   d.getattributes->do_param_attributes;
               if);
               ';' -> outfile.putline;
            #);
          emit_enter_parameters:
            (# first_done: @boolean;
            do (for i:num_enter_parameters repeat
                    (if first_done then
                        ', '->outfile.puttext;
                     else
                        true -> first_done;
                    if);
                    enter_parameters[i][]
                      -> outfile.puttext;
               for)
            #);
          result_present: @boolean;
          enter_parameters: [4]^text;
          num_enter_parameters: @integer;
          do_op_type_spec:
            (# t: ^idl.op_type_spec;
               s: ^idl.param_scoped_name;
            enter t[]
            do false -> result_present;
               (if t.symbol
                // idl.void then
                   'No result' -> outfile.comment;
                // idl.void_ref then
                   true -> result_present;
                   'result: @integer ' -> outfile.puttext;
                   'void*' -> outfile.comment;
                   ';' -> outfile.put;
                // idl.param_base_type_spec then
                   true -> result_present;
                   'result: @integer ' -> outfile.puttext;
                   'param_base_type_spec NYI' -> outfile.comment;
                   ';' -> outfile.put;
                // idl.param_string_type then
                   true -> result_present;
                   'result: @integer ' -> outfile.puttext;
                   'param_string_type' -> outfile.comment;
                   ';' -> outfile.put;
                // idl.param_scoped_name then
                   true -> result_present;
                   'result: @' -> outfile.puttext;
                   (t[]->s[]).getscoped_name 
                     -> do_scoped_name;
                   ';' -> outfile.put;
                // idl.param_void then
                   false -> result_present;
                   'No result' -> outfile.comment;
                   ';' -> outfile.put;
                // idl.param_type_spec_ref then
                   true -> result_present;
                   'result: @integer ' -> outfile.puttext;
                   'param_type_spec_ref NYI'
                     -> outfile.comment;
                   ';' -> outfile.put;
               if);
               outfile.newline;
            #);
          e: ^idl.op_dcl;
       enter e[]
       do outfile.indent;
          (* Start a virtual *)
          e.getIdentifier 
            -> IdentifierToText -> outfile.puttext;
          (*':< External' -> outfile.puttext;*)
          ':< ' -> outfile.puttext;
          outfile.newline;
          2 -> outfile.indent.inc;
          (if e.getop_attributeOpt -> optionalPresent then
              e.getop_attributeOpt -> do_op_attribute
          if);
          (if e.getraises_exprOpt -> optionalPresent then
              e.getraises_exprOpt -> do_raises_expr;
          if);
          (if e.getcontext_exprOpt -> optionalPresent then
              e.getcontext_exprOpt -> do_context_expr;
          if);
          outfile.indent;
          outfile.PatternBegin;
          (* Handle the exit parameter *)
          e.getop_type_spec -> do_op_type_spec;
          3 -> outfile.indent.inc;
          (* Handle the enter parameters *)
          e.getparameter_dcls -> do_parameter_dcls;
          
          (* Finish this virtual - emit enter,do,exit *)
          3 -> outfile.indent.dec;
          (if num_enter_parameters>0 then
              outfile.indent;
              'enter ' -> outfile.puttext;
              (if num_enter_parameters>1 then 
                  '(' -> outfile.put;
              if);
              emit_enter_parameters;
              (if num_enter_parameters>1 then 
                  ')' -> outfile.put;
              if);
              outfile.newline;
          if);
          (if e.getstd_call_opt -> optionalPresent then
              outfile.indent;
              (*'do CallStd;' -> outfile.putline;*)
              '__stdcall' -> outfile.commentline;
           else
              (* outfile.indent; *)
              (*'do CallC;' -> outfile.putline;*)
          if);
          (if result_present then
              outfile.indent;
              'exit result' -> outfile.putline;
          if);
          outfile.indent;
          outfile.PatternEnd;
          2 -> outfile.indent.dec;
          (*outfile.newline;*)
       #);
  enter e[]
  do e.getop_dcl -> do_op_dcl;
  #);
do_cpp_quote:
  (# c: ^idl.cpp_quote;
  enter c[]
  do outfile.indent;
     c.getString -> StringToText -> outfile.commentline;
  #);
do_export_error:
  (# e: ^idl.export_error;
  enter e[]
  do outfile.indent;
     'do_export_error NYI' -> outfile.commentline;
  #);

--interface_body_body: dopart--
do b.getexports -> e[];
   e.newscan
   (# 
   do (if current.symbol
       // idl.export_type_dcl then
          current[] -> do_export_type_dcl
       // idl.export_const_dcl then
          current[] -> do_export_const_dcl
       // idl.export_except_dcl then
          current[] -> do_export_except_dcl
       // idl.export_attr_dcl then
          current[] -> do_export_attr_dcl
       // idl.export_op_dcl then
          current[] -> do_export_op_dcl
       // idl.cpp_quote then
          current[] -> do_cpp_quote
       // idl.export_error then
          current[] -> do_export_error 
      if);
   #);     
   (* The following is matched by the pattern-begin in 
    * do_interface_header
    *)
   3 -> outfile.indent.dec;
   outfile.indent;
   outfile.PatternEnd;
   2 -> outfile.indent.dec;
   
