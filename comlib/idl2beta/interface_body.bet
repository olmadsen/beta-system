ORIGIN 'translate'

-- dofilelib: attributes--

generate_property_help_pattern: (# exit false #);

do_export_type_dcl:
  (# e: ^idl.export_type_dcl;
  enter e[]
  do e.gettype_dcl -> do_type_dcl;
  #);
do_export_const_dcl:
  (# e: ^idl.export_const_dcl;
  enter e[]
  do e.getconst_dcl -> do_const_dcl;
  #);
do_export_except_dcl:
  (# e: ^idl.export_except_dcl;
  enter e[]
  do (if not compact then output.indent; if);
     (* FIXME: *)'do_export_except_dcl NYI' -> error -> output.commentline;
  #);
do_export_attr_dcl:
  (# e: ^idl.export_attr_dcl;
  enter e[]
  do (if not compact then output.indent; if);
     (* FIXME: *)'do_export_attr_dcl NYI' -> error ->  output.commentline;
  #);

do_export_op_dcl:
  (# e: ^idl.export_op_dcl;
     do_op_dcl:
       (# do_raises_expr:
            (# o: ^idl.raises_expr;
            enter o[]
            do (if not compact then output.indent; if);
               (* FIXME: *)'do_raises_expr NYI' -> error -> output.commentline;
            #);
          do_context_expr:
            (# o: ^idl.context_expr;
            enter o[]
            do (if not compact then output.indent;if);
               (* FIXME: *)'do_context_expr NYI' -> error -> output.commentline;
            #);
          do_parameter_dcls:
            (# p: ^idl.parameter_dcls;
               d: ^idl.param_dcls;
               dcl_info: ^declarator_info;
            enter (p[])
            do 0 -> num_enter_parameters;
               enter_parameters.clear;
               p.getparam_dcls -> d[];
               d.newscan
               (# 
               do &declarator_info[] -> dcl_info[] -> symbols.append;
                  (dcl_info[], current[]) -> do_param_dcl;
               #);
            #);
          do_param_dcl:
            (# do_const:
                 (# c: ^idl.const_key;
                 enter c[]
                 do (*'const' -> output.comment;*)
                 #);
               
               do_param_type_spec:
                 (# 
                    do_param_scoped_name:
                      (# s: ^idl.param_scoped_name;
                      enter s[]
                      do (s.getscoped_name -> do_scoped_name, NONE) -> 
                         local_types.findtype
                         (# pointer_level: @integer;
                            isString, isWide, isOutParam, isArray: @boolean;
                            removebrackets:
                              (# 
                              do (* FIXME: arrrgh: The put_arg has
                                  * added '[]' to the end of 
                                  * enter_parameters, since it is 
                                  * actually a reference. 
                                  * I have to delete it - it's the 
                                  * only way
                                  *)
                                 (enter_parameters.length-1,
                                 enter_parameters.length) 
                                   -> enter_parameters.delete;
                              #);
                         do current[] -> dcl_info.type[];
                            put_arg;
                            (* We must add pointer levels from
                             * declarator with type's pointer
                             * level!
                             *)
                            dcl_info.pointer_level + current.pointer_level
                              -> pointer_level;
                            
                            (* We must handle texts specially *)
                            (((current.attributes[]<>NONE) and
                            current.attributes.array_size.string) or
                            ((dcl_info.attributes[]<>NONE) and
                            dcl_info.attributes.array_size.string)) 
                              -> isString;
                            
                            
                            (* Find out if it is an output param *)
                            (((current.attributes[]<>NONE) and
                            current.attributes.directional.out) or
                            ((dcl_info.attributes[]<>NONE) and
                            dcl_info.attributes.directional.out)) 
                              -> isOutParam;
                            
                            (* Find out if it is an array param *)
                            (((current.attributes[]<>NONE) and
                             ((current.attributes.array_size.size_is[]<>NONE) or
                              (current.attributes.array_size.length_is[]<>NONE)))
                             or
                             ((dcl_info.attributes[]<>NONE) and
                              ((dcl_info.attributes.array_size.size_is[]<>NONE) or
                               (dcl_info.attributes.array_size.length_is[]<>NONE))))
                              -> isArray;
                            
                            (if true 
                             // isString then
                                (* scoped name which is string attributed *)
                                (if true
                                 // 'wchar'->current.representation.equal 
                                 // 'wchar_t'->current.representation.equal 
                                 // 'signed_wchar_t'->current.representation.equal 
                                 // 'unsigned_wchar_t'->current.representation.equal then
                                    true -> isWide;
                                if);
                                (if pointer_level
                                 // 0 then
                                    (* Can this happen? *)
                                    (if isWide then
                                        '[0]@wchar' -> output.puttext;
                                        '@wtext NYI' -> output.spacecomment;
                                     else
                                        '[0]@char' -> output.puttext;
                                        '@text NYI' -> output.spacecomment;
                                    if);
                                 // 1 then
                                    (* E.g. OLECHAR *str *)
                                    (if isWide then
                                        '[0]@wchar' -> output.puttext;
                                        '^wtext NYI' -> output.spacecomment;
                                     else
                                        '[0]@char' -> output.puttext;
                                        '^text NYI' -> output.spacecomment;
                                    if);
                                    removebrackets;
                                 // 2 then
                                    (* e.g. OLECHAR **rgszNames *)
                                    (if isOutParam then
                                        (* String array is RESULT *)
                                        (if isWide then
                                            '^wtextHolder' -> output.puttext;
                                         else
                                            '^textHolder' -> output.puttext;
                                        if);
                                     else
                                        (* String array is parameter TO func *)
                                        '@int32' -> output.puttext;
                                        '(Build argument string array in ExternalRecord)' -> output.spacecomment;
                                        removebrackets;
                                    if);
                                 else
                                    '@int32' -> output.puttext;
                                    (if isOutParam then
                                        '(Allocate return structure in ExternalRecord)' -> output.spacecomment;
                                     else
                                        '(Build argument structure in ExternalRecord)' -> output.spacecomment;
                                    if);
                                    removebrackets;
                                if);
                             // current.representation[] <> NONE then
                                (* Scoped name which is not string *)
                                (if pointer_level
                                 // 0 then
                                    '@' -> output.put;
                                    (* yet some more special cases *)
                                    (if true
                                     // 'GUID' -> current.representation.equal
                                     // 'IID' -> current.representation.equal
                                     // 'CLSID' -> current.representation.equal
                                     // 'BSTR' -> current.representation.equal
                                     // 'VARIANT' -> current.representation.equal
                                        then
                                        'int32' -> output.puttext;
                                     else
                                        current.representation[]->output.puttext;
                                    if);
                                 // 1 then
                                    (if current.category
                                     // type_cat_basic 
                                     // type_cat_enum 
                                        then (* pointer to basic type *)
                                        (if isArray then
                                            '@int32' -> output.puttext;
                                            (if isOutParam then
                                                '(Allocate return structure in ExternalRecord)' -> output.spacecomment;
                                             else
                                                '(Build argument structure in ExternalRecord)' -> output.spacecomment;
                                            if);
                                            removebrackets;
                                         else
                                            (if isOutParam then
                                                '^' -> output.put;
                                                current.representation[]
                                                  ->output.puttext;
                                                'Holder' 
                                                  ->output.puttext;
                                             else
                                                '@int32' 
                                                  -> output.puttext;
                                                removebrackets;
                                            if)
                                        if);
                                     else
                                        '^' -> output.put;
                                        (if lowqua and (current.category=type_cat_interface) then
                                            'IUnknown' -> output.puttext;
                                         else
                                            current.representation[]
                                              ->output.puttext;
                                        if);
                                    
                                    if);
                                 // 2 then
                                    '^' -> output.put;
                                    (if lowqua and (current.category=type_cat_interface) then
                                        'IUnknown' -> output.puttext;
                                     else
                                        current.representation[]->output.puttext;
                                    if);
                                    'Holder' -> output.puttext;
                                    (if current.category
                                     // type_cat_basic 
                                     // type_cat_enum 
                                        then
                                        (# msg: ^text;
                                        do 'pointer-to-pointer-to-basictype not supported.' 
                                             -> msg[];
                                           '\n        Using \'' -> msg.puttext;
                                           current.representation[]->msg.puttext;
                                           'Holder\' for parameter \''->msg.puttext;
                                           dcl_info.name[] -> msg.puttext;
                                           '\'.'->msg.puttext;
                                           msg[] -> warning;
                                        #);
                                    if);
                                 else
                                    'pointerlevel>2!;' 
                                      -> output.puttext;
                                    'pointer_level>2 not supported!' 
                                      -> error;
                                if)
                             else
                                '@' -> output.put;
                                current.representation[] -> output.puttext;
                            if);
                         #) 
                      #);
                    
                    do_param_base_type_spec:
                      (# b: ^idl.param_base_type_spec;
                      enter b[]
                      do (dcl_info[], b.getbase_type_spec)
                           -> do_base_type_spec;
                         put_arg;
                         (if dcl_info.pointer_level+dcl_info.type.pointer_level
                          // 0 then '@' -> output.put;
                             dcl_info.type.representation[] -> output.puttext;
                          // 1 then '^' -> output.put;
                             dcl_info.type.representation[] -> output.puttext;
                             'Holder' -> output.puttext;
                          else
                             '@int32' -> output.puttext;
                             'pointerlevel>1 for param_base_type_spec'
                               -> error -> output.comment; 
                         if);
                         (if (dcl_info.type_comment[]<>NONE) 
                             and (not compact) then
                             dcl_info.type_comment[] -> output.comment;
                         if);
                      #);
                    
                    do_param_void:
                      (# msg: ^text;
                      do (if true
                          // arg_info.pointer_level=1 then
                             'Using \'^IUnknown\' for \'void*\' parameter \''
                               ->msg[];
                             arg_info.name[] -> msg.puttext;
                             '\'.' -> msg.puttext;
                             msg[] -> warning;
                             &type_info[] -> arg_info.type[];
                             'IUnknown' -> arg_info.type.representation[];
                             type_cat_interface -> arg_info.type.category;
                             'void' -> arg_info.type.name[];
                             put_arg;
                             '^' -> output.put;
                             arg_info.type.representation[] -> output.puttext;
                          // arg_info.pointer_level=2 then
                             'Using \'^IUnknownHolder\' for \'void**\' parameter \''
                               ->msg[];
                             arg_info.name[] -> msg.puttext;
                             '\'.' -> msg.puttext;
                             msg[] -> warning;
                             &type_info[] -> arg_info.type[];
                             'IUnknownHolder' -> arg_info.type.representation[];
                             type_cat_interface -> arg_info.type.category;
                             'void' -> arg_info.type.name[];
                             put_arg;
                             '^' -> output.put;
                             arg_info.type.representation[] -> output.puttext;
                          else
                             (* If a parameter has type 
                              * void, then it must mean that
                              * there are NO parameters! 
                              * I.e. foo(void).
                              *)
                             (if (num_enter_parameters=0) then
                                 (if not compact then
                                     'No parameters' -> output.comment;
                                 if);
                              else
                                 (# msg: ^text;
                                 do 'Met void parameter \'' -> msg[];
                                    arg_info.name[] -> msg.append;
                                    '\' at num_enter_parameters='-> msg.append;
                                    num_enter_parameters
                                      -> msg.putint;
                                    msg[] -> error;
                                 #);
                             if);
                         if)
                      #);
                    
                    t: ^idl.param_type_spec;
                    dcl_info: ^declarator_info;
                 enter (dcl_info[], t[])
                 do (* do_param_type_spec *)
                    (if t.symbol
                     // idl.param_base_type_spec then
                        t[] -> do_param_base_type_spec;
                     // idl.param_string_type then
                        put_arg;
                        '@int32' -> output.puttext;
                        (* FIXME: *)'param_string_type NYI' -> error -> output.comment;
                     // idl.param_scoped_name then
                        t[] -> do_param_scoped_name;
                     // idl.param_void then
                        do_param_void;
                    if);
                    dcl_info.as_text->output.spacecomment;
                 #);
               check_name_not_type:
                 (# name: ^text;
                    limit: @integer;
                 enter name[]
                 do fix:
                      (if name[]->local_types.findtypeNCS then
                          '_' -> name.prepend;
                          limit+1 -> limit;
                          (if limit>10 then
                              '*** check_name_not_type: limit 10 reached for fixup: ' -> screen.puttext; name[] -> screen.putline;
                           else
                              restart fix;
                          if)
                      if);
                 #);
               put_arg:
                 (* Put out the parameter name, and remember it in
                  * enter_parameters for later emission of enter list
                  *)
                 (# 
                 do (if arg_info.name[] = NONE then
                        generate_param_name;
                    if);
                    arg_info.name[] -> check_name_not_type;
                    arg_info.name[] -> output.puttext;
                    ': ' -> output.puttext;
                    num_enter_parameters+1 -> num_enter_parameters;
                    (if num_enter_parameters>1 then
                        ', ' -> enter_parameters.append;
                    if);
                    arg_info.name.copy -> enter_parameters.append;
                    (if arg_info.type[]=NONE then
                        (if debug then
                            'put_arg('->puttext;
                            arg_info.name[] -> puttext;
                            ') called with type=NONE' -> putline;
                        if);
                     else
                        (if arg_info.pointer_level + 
                            arg_info.type.pointer_level > 0 then 
                            '[]' -> enter_parameters.append;
                        if);
                    if);
                 #);
               generate_param_name:
                 (# 
                 do 'arg' -> arg_info.name[];
                    num_enter_parameters->arg_info.name.putint;
                 #);
               arg_info: ^declarator_info;
               pd: ^idl.param_dcl;
               sd: ^idl.simple_param_dcl;
               fd: ^idl.fnc_ptr_param_dcl;
            enter (arg_info[], pd[])
            do (if not compact then output.indent; if);
               (if arg_info.attributes[]=NONE then
                   &idl_attributes[] -> arg_info.attributes[];
               if);
               
               (if pd.symbol
                // idl.simple_param_dcl then
                   pd[] -> sd[];
                   (arg_info.attributes[],sd.getattributes_specs)
                     -> do_attributes_specs;
                   (if sd.getdeclarator->optionalPresent then
                       (arg_info[], sd.getdeclarator)->do_declarator
                   if);
                   (arg_info[], sd.gettype) -> do_param_type_spec;
                // idl.fnc_ptr_param_dcl then
                   (* Function pointer parameter *)
                   pd[] -> fd[];
                   fd.getfnc_ptr_type_declarator 
                     -> do_fnc_ptr_type_declarator 
                     -> (arg_info.name[], arg_info.type[]);
                   put_arg;
                   '@' -> output.put;
                   arg_info.type.representation[] -> output.puttext;
                   arg_info.as_text->output.spacecomment;
                else
                   'unknown parameter kind' -> error;
               if);
               '; ' -> output.puttext;
               (if not compact then output.newline if);
            #);
          result_present: @boolean;
          res_info: ^type_info;
          num_enter_parameters: @integer;
          enter_parameters: @text;
          do_op_type_spec:
            (# t: ^idl.op_type_spec;
               s: ^idl.param_scoped_name;
               do_result_param_base_type_spec:
                 (# b: ^idl.param_base_type_spec;
                    dcl_info: @declarator_info;
                 enter b[]
                 do &type_info[]->res_info[];
                    res_info[] -> dcl_info.type[];
                    (dcl_info[], b.getbase_type_spec)
                      -> do_base_type_spec;
                    'result: ' -> output.puttext;
                    (if dcl_info.pointer_level+dcl_info.type.pointer_level
                     // 0 then '@' -> output.put;
                        dcl_info.type.representation[] -> output.puttext;
                     // 1 then '^' -> output.put;
                        dcl_info.type.representation[] -> output.puttext;
                        'Holder' -> output.puttext;
                     else
                        'pointerlevel>1 for param_base_type_spec'
                          -> error -> output.comment;
                    if);
                    (if (dcl_info.type_comment[]<>NONE) 
                        and (not compact) then
                        dcl_info.type_comment[] -> output.comment;
                    if);
                 #);
            enter t[]
            do false -> result_present;
               (if t.symbol
                // idl.void then
                   'No result' -> output.comment;
                // idl.void_ref then
                   true -> result_present;
                   'result: ^IUnknown' -> output.puttext;
                   'void*' -> output.spacecomment;
                   ';' -> output.put;
                   &type_info[]->res_info[];
                   'IUnknown' -> res_info.name[] -> res_info.representation[];
                   type_cat_interface -> res_info.category;
                   1-> res_info.pointer_level;
                   'Using \'^IUnknown\' for \'void*\' result' -> warning;
                // idl.param_base_type_spec then
                   true -> result_present;
                   t[] -> do_result_param_base_type_spec;
                   ';' -> output.put;
                // idl.param_string_type then
                   true -> result_present;
                   'result: @int32 ' -> output.puttext;
                   (* FIXME: *)'param_string_type result NYI' 
                     -> error -> output.comment;
                   ';' -> output.put;
                // idl.param_scoped_name then
                   true -> result_present;
                   'result: ' -> output.puttext;
                   ((t[]->s[]).getscoped_name -> do_scoped_name, NONE)
                     -> local_types.findtype
                   (# 
                   do current[] -> res_info[];
                      (if current.representation[] <> NONE then
                          (if current.pointer_level
                           // 0 then
                              '@' -> output.put;
                              current.representation[] -> output.puttext;
                           // 1 then
                              (* pointer to basic type *)
                              '^' -> output.put;
                              current.representation[] -> output.puttext;
                              'Holder' -> output.puttext;
                           else
                              'pointer_level>1 for basictype' 
                                -> error -> output.comment;
                          if)
                       else
                          '@' -> output.put;
                          current.representation[] -> output.puttext;
                      if);
                      current.as_text->output.spacecomment;
                   #);                                  
                   ';' -> output.put;
                // idl.param_void then
                   false -> result_present;
                   'No result' -> output.comment;
                   ';' -> output.put;
                // idl.param_type_spec_ref then
                   true -> result_present;
                   'result: @integer ' -> output.puttext;
                   (* FIXME: *)'param_type_spec_ref result NYI' 
                     -> error -> output.comment;
                   ';' -> output.put;
               if);
               (if compact then 
                   ' '-> output.put;
                else
                   output.newline;
               if);
            #);
          e: ^idl.op_dcl;
          virtual_name, property_name: ^text;
          att: @idl_attributes;
          is_virtual: @boolean;
       enter (e[], is_virtual)
       do NONE -> property_name[];
          output.indent;
          (* Start a virtual *)
          e.getIdentifier 
            -> IdentifierToText 
            -> virtual_name[];
          (att[], e.getattributes_specs) -> do_attributes_specs;
          (if att.typelib.propget then
              (if generate_property_help_pattern then
                  (* If both a propput and a propget, save for help pattern *)
                  propputs.find
                  (# predicate::(# do virtual_name[] -> current.equal -> value #);
                     notfound::(# do virtual_name.copy -> propgets.append; #);
                  do virtual_name.copy-> property_name[];
                  #);
              if);
              'get' -> virtual_name.prepend;
          if);
          (if att.typelib.propput then
              (if generate_property_help_pattern then
                  (* If both a propput and a propget, save for help pattern *)
                  propgets.find
                  (# predicate::(# do virtual_name[] -> current.equal -> value #);
                     notfound::(# do virtual_name.copy -> propputs.append; #);
                  do virtual_name.copy-> property_name[];
                  #);
              if);
              'put' -> virtual_name.prepend;
          if);
          (if verbose then
              '      [' -> screen.puttext;
              virtual_name[] -> screen.puttext;
              ']' -> screen.putline;
          if);
          virtual_name[] -> output.puttext;
          (if att.alias_marshal.call_as[]=NONE then
              (if is_virtual then
                  (* Normal virtual *)
                  ':<' -> output.puttext;
               else
                  (* Using invoke *)
                  ':' -> output.puttext;
              if)
           else
              (* call_as attributd methods do not contribute to vtable
               * i.e. must not be virtual.
               *)
              ': ' -> output.puttext;
              (if not compact then
                  'call_as(' 
                    -> (')' 
                    -> (att.alias_marshal.call_as.copy).append).prepend 
                    -> output.comment;
              if);
          if);
          (if not compact then 
              output.newline;
              2 -> output.indent.inc;
              (if att.typelib.helpstring[] <> NONE then
                  output.indent;
                  att.typelib.helpstring[] -> output.commentline;
              if);
          if);
          (if e.getraises_expr_Opt -> optionalPresent then
              e.getraises_expr_Opt -> do_raises_expr;
          if);
          (if e.getcontext_expr_Opt -> optionalPresent then
              e.getcontext_expr_Opt -> do_context_expr;
          if);
          (if not compact then 
              output.indent;
          if);
          output.PatternBegin;
          (* Handle the exit parameter *)
          e.getop_type_spec -> do_op_type_spec;
          (if not compact then 3 -> output.indent.inc; if);
          (* Handle the enter parameters *)
          e.getparameter_dcls -> do_parameter_dcls;
          
          (* Finish this virtual - emit enter,do,exit *)
          (if not compact then 3 -> output.indent.dec; if);
          (if num_enter_parameters>0 then
              (if not compact then output.indent; if);
              'enter ' -> output.puttext;
              (if num_enter_parameters>1 then 
                  '(' -> output.put;
              if);
              enter_parameters[] -> output.puttext;
              (if num_enter_parameters>1 then 
                  ')' -> output.put;
              if);
              (if not compact then output.newline; if);
          if);
          (if compact then
              ' ' -> output.put;
           else
              output.indent;
          if);
          'do ' -> output.puttext;
          (if is_virtual then
              (if (e.getstd_call_opt -> optionalPresent) and (not compact) then
                  'callStd' -> output.comment; ' ' -> output.put;
              if);
              'INNER;' -> output.puttext;
           else
              output.Commentbegin;
              'Call Invoke with id=' -> output.puttext;
              att.typelib.id[] -> output.puttext;
              output.CommentEnd;
          if);
          (if result_present then
              (if not compact then
                  output.newline;
                  output.indent;
               else
                  ' ' -> output.put
              if);
              'exit result' -> output.puttext;
              (if (res_info[]<>NONE) and (res_info.pointer_level>0) then
                  '[]' -> output.puttext;
              if);
          if);
          (if not compact then 
              output.newline;
              output.indent;
           else
              ' ' -> output.put;
          if);
          output.PatternEnd;
          ';' -> output.putline;
          (if not compact then 
              2 -> output.indent.dec;
              (if generate_property_help_pattern then
                  (if (property_name[]<>NONE) then
                      (* Emit help pattern *)
                      output.indent;
                      property_name[] -> output.puttext;
                      ': ' -> output.puttext;
                      'property' -> output.commentline;
                      2 -> output.indent.inc;
                      output.indent;
                      output.patternbegin;
                      'enter put' -> output.puttext;
                      property_name[] -> output.puttext;
                      ' exit get' -> output.puttext;
                      property_name[] -> output.puttext;
                      ' '->output.put;
                      output.patternend;
                      ';' -> output.putline;
                      2 -> output.indent.dec;
                  if);
              if);
          if);
          (if trace then
              newline;
              '    Trace: Symbols for virtual '->puttext;
              virtual_name[] -> puttext;
              ':' -> putline;
              '    '->screen.puttext; screen.line;
              symbols.print;
          if);
          symbols.clear (* forget symbols from this virtual before the next *)
       #);
     is_virtual: @boolean;
  enter (e[], is_virtual)
  do (e.getop_dcl, is_virtual) -> do_op_dcl;
  #);
do_cpp_quote:
  (# c: ^idl.cpp_quote;
  enter c[]
  do (if not compact then output.indent; if);
     c.getString -> StringToText -> output.commentline;
  #);
do_export_error:
  (# e: ^idl.export_error;
  enter e[]
  do (if not compact then output.indent; if);
     (* FIXME: *)'do_export_error NYI' -> error -> output.commentline;
  #);

--interface_body_body: dopart--
do (if b.getexports_opt -> optionalPresent then
       b.getexports_opt -> e[];
       e.newscan
       (# 
       do (if current.symbol
           // idl.export_type_dcl then
              current[] -> do_export_type_dcl
           // idl.export_const_dcl then
              current[] -> do_export_const_dcl
           // idl.export_except_dcl then
              current[] -> do_export_except_dcl
           // idl.export_attr_dcl then
              current[] -> do_export_attr_dcl
           // idl.export_op_dcl then
              (current[],true) -> do_export_op_dcl (* The usual entry *)
           // idl.export_import then
              (* handled by scanForImports *)
           // idl.cpp_quote then
              current[] -> do_cpp_quote
           // idl.export_error then
              current[] -> do_export_error 
          if);
       #); 
   if);
   
   (* End pattern.
    * The following is matched by the pattern-begin in 
    * do_interface_header
    *)
   3 -> output.indent.dec;
   output.indent;
   output.PatternEnd;
   ';' -> output.putline;
   2 -> output.indent.dec;
   
