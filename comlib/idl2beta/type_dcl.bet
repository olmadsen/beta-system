ORIGIN 'translate';

--add_basic_types: descriptor--
(# 
do (* Add basic types to global_types. The types are
    * derived from the MIDL base types as defined at URL
    * http://premium.microsoft.com/isapi/devonly/prodinfo/msdnprod/msdnlib.idc
    * ?theURL=/msdn/library/sdkdoc/ov-iface_0ipf.htm
    *)
   ('boolean',            'boolean') -> global_types.add_basic_type;
   ('unsigned_boolean',   'boolean') -> global_types.add_basic_type;
   ('signed_boolean',     'int8') -> global_types.add_basic_type;
   ('byte',               'int8u') -> global_types.add_basic_type;
   ('char',               'char') -> global_types.add_basic_type;
   ('signed_char',        'int8') -> global_types.add_basic_type;
   ('unsigned_char',      'int8u') -> global_types.add_basic_type;
   ('double',             'real') -> global_types.add_basic_type;
   ('error_status_t',     'int32u') -> global_types.add_basic_type;
   ('float',              'real') -> global_types.add_basic_type;
   ('handle_t',           'int32u') -> global_types.add_basic_type;
   (* hyper left out - 56 bit quantity not possible to handle in beta *)
   
   ('int',                'int32') -> global_types.add_basic_type;
   ('long',               'int32') -> global_types.add_basic_type;
   ('long_int',           'int32') -> global_types.add_basic_type;
   ('signed',             'int32') -> global_types.add_basic_type;
   ('unsigned',           'int32u') -> global_types.add_basic_type;
   ('signed_int',         'int32') -> global_types.add_basic_type;
   ('unsigned_int',       'int32u') -> global_types.add_basic_type;
   ('signed_long',        'int32') -> global_types.add_basic_type;
   ('unsigned_long',      'int32u') -> global_types.add_basic_type;
   ('signed_long_int',    'int32') -> global_types.add_basic_type;
   ('unsigned_long_int',  'int32u') -> global_types.add_basic_type;
   
   ('short',              'int16') -> global_types.add_basic_type;
   ('short_int',          'int16') -> global_types.add_basic_type;
   ('signed_short',       'int16') -> global_types.add_basic_type;
   ('unsigned_short',     'int16u') -> global_types.add_basic_type;
   ('signed_short_int',   'int16') -> global_types.add_basic_type;
   ('unsigned_short_int', 'int16u') -> global_types.add_basic_type;
   
   ('small',              'int16') -> global_types.add_basic_type;
   ('small_int',          'int16') -> global_types.add_basic_type;
   ('signed_small',       'int16') -> global_types.add_basic_type;
   ('unsigned_small',     'int16u') -> global_types.add_basic_type;
   ('signed_small_int',   'int16') -> global_types.add_basic_type;
   ('unsigned_small_int', 'int16u') -> global_types.add_basic_type;
   
   ('int64',              'int64') -> global_types.add_basic_type;
   ('signed_int64',       'int64') -> global_types.add_basic_type;
   ('unsigned_int64',     'int64u') -> global_types.add_basic_type;
   

   ('wchar_t',            'wchar') -> global_types.add_basic_type;
   
   (* 'hyper' not represented in BETA *)
   
   (* These are not defined by MIDL, but nevertheless seem to be used *)
   ('octet',              'int8u') -> global_types.add_basic_type;
   ('any',                'int32') -> global_types.add_basic_type;
   
   (* Add types from comtypes.bet to global_types *)
   ('HRESULT',            'int32') -> global_types.add_basic_type;
   ('BSTR',               'BSTR') -> global_types.add_basic_type;
   ('GUID',               'GUID') -> global_types.add_basic_type;
   ('CLSID',              'CLSID') -> global_types.add_basic_type;
   ('IID',                'IID') -> global_types.add_basic_type;
   ('VARIANT',            'VARIANT') -> global_types.add_union_type;
   
#)

--do_base_type_spec: descriptor--
(# name: ^text;
do (if s.symbol
    // idl.int then 'int' -> name[];
    // idl.long then 'long' -> name[];
    // idl.long_int then 'long_int' -> name[];
    // idl.signed then 'signed' -> name[];
    // idl.unsigned then 'unsigned' -> name[];
    // idl.signed_int then 'signed_int' -> name[];
    // idl.unsigned_int then 'unsigned_int' -> name[];
    // idl.signed_long then 'signed_long' -> name[];
    // idl.unsigned_long then 'unsigned_long' -> name[];
    // idl.signed_long_int then 'signed_long_int' -> name[];
    // idl.unsigned_long_int then 'unsigned_long_int' -> name[];
    // idl.short then 'short' -> name[];
    // idl.short_int then 'short_int' -> name[];
    // idl.signed_short then 'signed_short' -> name[];
    // idl.unsigned_short then 'unsigned_short' -> name[];
    // idl.signed_short_int then 'signed_short_int' -> name[];
    // idl.unsigned_short_int then 'unsigned_short_int' -> name[];
    // idl.small then 'small' -> name[];
    // idl.small_int then 'small_int' -> name[];
    // idl.signed_small then 'signed_small' -> name[];
    // idl.unsigned_small then 'unsigned_small' -> name[];
    // idl.signed_small_int then 'signed_small_int' -> name[];
    // idl.unsigned_small_int then 'unsigned_small_int' -> name[];
    // idl.int64 then 'int64' -> name[];
    // idl.signed_int64 then 'signed_int64' -> name[];
    // idl.unsigned_int64 then 'unsigned_int64' -> name[];
    // idl.hyper then 
       'integer type \'hyper\' is not supported - using \'int32\'' -> warning;
       'int' -> name[]
    // idl.float then 'float' -> name[];
    // idl.double then 'double' -> name[]; 
    // idl.unsigned_char then 'unsigned_char' -> name[];
    // idl.signed_char then 'signed_char' -> name[];
    // idl.char then 'char' -> name[];
    // idl.boolean_type then 'boolean' -> name[];
    // idl.octet_type then 'octet' -> name[]; 
    // idl.any_type then 'any' -> name[];
    else
       (# msg: ^text;
         do 'do_base_type_spec: unhandled symbol: ' -> msg[];
            s.symbol -> msg.putint;
            msg[] -> error;
         #)
   if);
   (* The type should be in global_types *)
   (name[],NONE) -> global_types.findtype(# do current[] -> dcl_info.type[] #);
#)

--type_dcl_lib: attributes--
do_type_spec:
  (# t: ^idl.type_spec;
     info: ^type_info;
     types: ^type_list;
     found: @boolean;
     name: ^text;
     msg: ^text;
     is_definition: @boolean;
  enter (info[],types[],t[],is_definition)
  do (* First handle basic types. They can be found in types *)
     (if t.symbol
      // idl.int then 'int' -> name[];
      // idl.long then 'long' -> name[];
      // idl.long_int then 'long_int' -> name[];
      // idl.signed then 'signed' -> name[];
      // idl.unsigned then 'unsigned' -> name[];
      // idl.signed_int then 'signed_int' -> name[];
      // idl.unsigned_int then 'unsigned_int' -> name[];
      // idl.signed_long then 'signed_long' -> name[];
      // idl.unsigned_long then 'unsigned_long' -> name[];
      // idl.signed_long_int then 'signed_long_int' -> name[];
      // idl.unsigned_long_int then 'unsigned_long_int' -> name[];
      // idl.short then 'short' -> name[];
      // idl.short_int then 'short_int' -> name[];
      // idl.signed_short then 'signed_short' -> name[];
      // idl.unsigned_short then 'unsigned_short' -> name[];
      // idl.signed_short_int then 'signed_short_int' -> name[];
      // idl.unsigned_short_int then 'unsigned_short_int' -> name[];
      // idl.small then 'small' -> name[];
      // idl.small_int then 'small_int' -> name[];
      // idl.signed_small then 'signed_small' -> name[];
      // idl.unsigned_small then 'unsigned_small' -> name[];
      // idl.signed_small_int then 'signed_small_int' -> name[];
      // idl.unsigned_small_int then 'unsigned_small_int' -> name[];
      // idl.int64 then 'int64' -> name[];
      // idl.signed_int64 then 'signed_int64' -> name[];
      // idl.unsigned_int64 then 'unsigned_int64' -> name[];
      // idl.hyper then 
         'integer type \'hyper\' is not supported - using \'int32\'' -> warning;
         'int' -> name[]      
      // idl.float then 'float' -> name[];
      // idl.double then 'double' -> name[]; 
      // idl.unsigned_char then 'unsigned_char' -> name[];
      // idl.signed_char then 'signed_char' -> name[];
      // idl.char then 'char' -> name[];
      // idl.boolean_type then 'boolean' -> name[];
      // idl.octet_type then 'octet' -> name[]; 
      // idl.any_type then 'any' -> name[];
      else
         (* not an error - the rest is treated below *)
     if);
     (if name[]<>NONE then
         (* Find info about the basic type in types *)
         (name[],NONE)-> types.findtype
         (#
         do (if info.name[]=NONE then
                (* If info.name is not NONE,
                 * then a typedef may be going
                 * on, and we want the new
                 * type to be known under the
                 * new name!
                 *)
                current.name.copy->info.name[];
            if);
            (if current.representation[]=NONE then
                'Type representation is NONE for type '-> msg[];
                current.name[] -> msg.puttext;
                msg[] -> error;
            if);
            current.representation.copy
              ->info.representation[];
            current.pointer_level+info.pointer_level
              ->info.pointer_level;
            current.category
              ->info.category;
         #);
      else
         (if t.symbol
          // idl.sequence1
          // idl.sequence2 then 
             'Sequence type not yet supported, sorry!. Using \'int32\''
               -> warning;
             'int32' -> info.representation[];
          // idl.string1 
          // idl.string2 then 
             'String type not yet supported, sorry!. Using \'int32\''
               -> warning;
             'int32' -> info.representation[];
          // idl.scoped_name1
          // idl.scoped_name2
          // idl.scoped_name3 then 
             t[] -> do_scoped_name -> name[];
             (* The type specification is just a name.
              * Thus it's an alias for 'name', i.e.
              *   typedef name info.name
              * Let's find the representation of the aliased name.
              *)
             (if is_definition then
                 (name[],NONE)-> types.findtype
                 (# 
                 do (if current.representation[]=NONE then
                        (# msg: ^text
                        do 'Type representation is NONE for type '-> msg[];
                           current.name[] -> msg.puttext;
                           msg[] -> error;
                        #)
                    if);
                    current.representation.copy
                      ->info.representation[];
                    current.pointer_level+info.pointer_level
                      ->info.pointer_level;
                    current.category
                      ->info.category;
                 #);
              else
                 (* It's an *application of a type name, e.g. in a 
                  * struct member. The type better be defined already!
                  *)
                 (name[],NONE)-> types.findtype
                 (# 
                 do current.representation.copy
                      ->info.representation[];
                    current.pointer_level+info.pointer_level
                      ->info.pointer_level;
                    current.category
                      ->info.category;
                    current.name.copy 
                      ->info.name[];
                 #);
             if);
          // idl.void_type_spec then
             (if info.name[]<>NONE then
                 info.name.copy -> msg[];
                 ': ' -> msg.puttext;
              else
                 &text[]->msg[];
             if);
             'Using \'int32\' for type \'void\'.' -> msg.puttext;
             msg[] -> warning;
             'int32' -> info.representation[];
             type_cat_basic -> info.category;
          // idl.constr_struct_type then
             (* Both emit the definition of the construction mapping, and
              * add the type to types.
              *)
             (info[], t[], is_definition) -> do_constr_struct_type;
          // idl.constr_union_type then
             (info[], t[], is_definition) -> do_constr_union_type;
          // idl.constr_enum_type then
             (* Both emit the definition of the enum mapping, and
              * add the type to types.
              *)
             (info[], t[]) -> do_constr_enum_type;
          else
             'Oops, must have forgotten a type!' -> output.comment;
         if);
     if);
  #);

do_type_declarator:
  (# t: ^idl.type_declarator;
     sd: ^idl.simple_type_declarator;
     info: ^type_info;
     att: ^idl_attributes;
     name: ^text;
     dcl_info: ^declarator_info;
     d: ^idl.declarators;
     types: ^type_list;
     
  enter (types[], att[], t[])
  do (if t.symbol
      // idl.fnc_ptr_type_declarator then
         t[] -> do_fnc_ptr_type_declarator -> (name[], info[]);
      // idl.simple_type_declarator then
         t[] -> sd[];
         sd.getdeclarators -> d[];
         d.newscan
         (# d: ^idl.declarator;
         do &type_info[] -> info[];
            att[] -> info.attributes[];
            &declarator_info[] -> dcl_info[];
            info[] -> dcl_info.type[];
            (* Get the name and pointer level of the type declaration *)
            (dcl_info[], current[]) -> do_declarator;
            dcl_info.name.copy -> info.name[];
            dcl_info.pointer_level -> info.pointer_level;
            (* done with dcl_info *)
            (* Fill in the rest of the type *)
            (info[], types[], sd.gettype_spec, true) -> do_type_spec;
            info[] -> types.append;
         #);
     if);
  #);

do_extern:
  (# t: ^idl.extern;
     td: ^idl.type_declarator;
     sd: ^idl.simple_type_declarator;
     att: @idl_attributes;
  enter (t[])
  do t.gettype_declarator->td[];
     (if td.symbol
      // idl.fnc_ptr_type_declarator then
         td[] -> do_fnc_ptr_type_declarator;
      // idl.simple_type_declarator then
         td[] -> sd[];
         (att[],sd.getattributes_specs) -> do_attributes_specs;
         (if (not compact) and (att.typelib.helpstring[]<>NONE) then
             output.newline;
             output.indent;
             att.typelib.helpstring[]-> output.commentline;
         if);
         (local_types[], att[], t.gettype_declarator) -> do_type_declarator;
     if);
  #);

do_typedef:
  (# t: ^idl.typedef;
     td: ^idl.type_declarator;
     sd: ^idl.simple_type_declarator;
     att: @idl_attributes;
  enter (t[])
  do t.gettype_declarator->td[];
     (if td.symbol
      // idl.fnc_ptr_type_declarator then
         td[] -> do_fnc_ptr_type_declarator;
      // idl.simple_type_declarator then
         td[] -> sd[];
         (att[],sd.getattributes_specs) -> do_attributes_specs;
         (if (not compact) and (att.typelib.helpstring[]<>NONE) then
             output.newline;
             output.indent;
             att.typelib.helpstring[]-> output.commentline;
         if);
         (local_types[], att[], t.gettype_declarator) -> do_type_declarator;
     if);
  #);

emit_alias_pattern:
  (# newname, oldname, msg: ^text;
  enter (newname[], oldname[])
  do (if true
      // ('HRESULT'->newname.equal)
      // ('VARIANT'->newname.equal)
      // ('BSTR'->newname.equal)
      // ('GUID'->newname.equal)
      // ('CLSID'->newname.equal)
      // ('IID'->newname.equal)
         then
         'Skipped definition of alias pattern for predefined pattern '-> msg[];
         newname[]->msg.append;
         msg[]->warning;
         leave emit_alias_pattern;
     if);
     output.indent;
     newname[] -> output.puttext;
     ': ' -> output.puttext;
     oldname[] -> output.puttext;
     '(# #);' -> output.putline;
     newname[] -> holders.add;
  #);

do_struct_body:
  (# m: ^idl.members;
     body: ^idl.struct_body;
     td: ^idl.type_declarator;
     sd: ^idl.simple_type_declarator; 
     l: ^idl.members;
  enter body[]
  do body.getmembers -> m[];
     m.newscan
     (# d: ^idl.declarators;
        mem: ^idl.member;
        first_done: @boolean;
     do current[] -> mem[];
        mem.gettype_declarator->td[];
        (if td.symbol
         // idl.fnc_ptr_type_declarator then
            (# info: ^type_info;
               name: ^text;
            do td[] -> do_fnc_ptr_type_declarator -> (name[], info[]);
               (if first_done then
                   output.indent;
                else
                   true -> first_done;
               if);
               name[] -> output.puttext;
               ': '->output.puttext;
               info.representation[] -> output.puttext;
               info.as_text -> output.spacecomment;
               ';' -> output.putline;
            #);
         // idl.simple_type_declarator then
            td[] -> sd[];
            sd.getdeclarators -> d[];
            d.newscan
            (# d: ^idl.declarator;
               dcl_info: ^declarator_info;
               info: ^type_info;
            do (if first_done then
                   output.indent;
                else
                   true -> first_done;
               if);
               &type_info[] -> info[];
               &declarator_info[] -> dcl_info[];
               (dcl_info[], current[]) -> do_declarator;
               dcl_info.name[] -> output.puttext;
               ': '->output.puttext;
               (if dcl_info.pointer_level>0 then
                   '^' -> output.put;
                else
                   '@' -> output.put;
               if);
               
               
               (info[], local_types[], sd.gettype_spec, false) 
                 -> do_type_spec;
               info.representation[] -> output.puttext;
               (if dcl_info.pointer_level+info.pointer_level
                // 0 then
                   (* not holder *)
                // 1 then
                   (if info.category=type_cat_basic then
                       (* pointer to basic type *)
                       'Holder' -> output.puttext;
                   if)
                else
                   'Holder' -> output.puttext;
               if);
               info.as_text -> output.spacecomment;
               (if info.attributes[]=NONE then
                   &idl_attributes[]->info.attributes[];
               if);
               (info.attributes[],sd.getattributes_specs)
                 -> do_attributes_specs;
               ';' -> output.putline;
            #);
        if)
     #);
  #);
do_struct_type:
  (# t: ^idl.struct_type;
     body: ^idl.struct_body;
     info, type_return: ^type_info;
     struct_tag: ^text;
     msg: ^text;
     is_definition: @boolean;
     
     emit_struct_pattern:
       (# name: ^text;
          already_emitted: @boolean;
       enter name[]
       do (if debug then
              'emit_struct_pattern: name: ' -> puttext;
              name[] -> putline;
          if);
          (if is_definition then
              (* Make sure we do not emit twice. Would happen otherwise for
               *   typedef struct XXX { ... } YYY, ZZZ;
               *)
              struct_patterns_emitted.find
              (# predicate:: (# do (name[]->current.equal)->value #);
              do true-> already_emitted;
              #);
              (if already_emitted then
                  (if debug then
                      'emit_struct_pattern: already emitted.' -> putline;
                  if);
                  leave emit_struct_pattern;
              if);
              name[] -> struct_patterns_emitted.append;
              output.indent;
              name[] -> output.puttext;
              ': ' -> output.puttext;
          if);
          'DATA' -> output.puttext;
          2 -> output.indent.inc;
          output.newline;
          output.indent;
          output.PatternBegin;
          3 -> output.indent.inc;
          body[] -> do_struct_body;
          3 -> output.indent.dec;
          output.indent;
          output.PatternEnd;
          2 -> output.indent.dec;
          (if is_definition then
              ';' -> output.putline;
          if);
       #);
     add_struct_type:
       (# type: ^type_info;
          name, representation, holder: ^text;
       enter (name[], representation[], holder[])
       do (if debug then
              'add_struct_type: name: ' -> puttext;
              name[] -> puttext;
              ', representation: ' -> puttext;
              representation[] -> putline;
          if);
          (name[], representation[]) -> local_types.add_struct_type -> type[];
          holder[] -> holders.add;
       exit type[]
       #);
     add_tagged_struct_type: 
       (# tag: ^text;
          name, representation: ^text;
          type: ^type_info;
       enter tag[]
       do (if debug then
              'add_tagged_struct_type: tag: ' -> puttext;
              tag[] -> putline;
          if);
          'struct-' -> (tag.copy).prepend -> name[];
          'struct_' -> (tag.copy).prepend -> representation[];
          (name[], representation[], representation[]) 
            -> add_struct_type 
            -> type[];
       exit type[]
       #);
     alias_tagged_struct_type:
       (# notfound: @notfound_descriptor
            (* default is to use int32 for unknown types, but
             *    typedef struct XXX YYY
             * is allowed *before* 'struct XXX' is defined.
             *)
            (# representation: ^text;
            do 'struct_' -> (struct_tag.copy).prepend -> representation[];
               (name[], representation[], representation[]) 
                 -> add_struct_type 
                 -> type[];
               (if body[]<>NONE then
                   (* The type was not there, and there is a body. E.g.:
                    *   typedef struct TTT { ... } *XXX
                    * So emit pattern now. 
                    *)
                   representation[] -> emit_struct_pattern;
               if);
            #);
          type_name: ^text;
       do (if debug then
              'alias_tagged_struct_type: tag: ' -> puttext;
              struct_tag[] -> putline;
          if);
          (* Let's find the representation of the aliased type
           * and copy the type information into info.
           *)
          (if struct_tag[]=NONE then
              'alias_tagged_struct_type: tag is none!' -> error;
           else
              'struct-' -> (struct_tag.copy).prepend -> type_name[];
              (type_name[], notfound[]) -> local_types.findtype
              (# 
              do current.representation.copy -> info.representation[];
                 current.category -> info.category;
              #);
          if)
       #);
  enter (info[], t[], is_definition)
  do (* If info is not NONE, set up info.representation and info.category *)
     (* Is there a tag? *)
     (if t.gettag -> optionalPresent then
         t.gettag -> IdentifierToText -> struct_tag[];
      else
         NONE -> struct_tag[]
     if);
     (* Is there a body? *)
     (if (t.getstruct_body_opt -> optionalPresent) then
         t.getstruct_body_opt -> body[];
      else
         NONE -> body[];
     if);
     (if (struct_tag[]=NONE) and (body[]=NONE) then
         (* Error: No struct tag and no struct body, i.e.
          *   typedef struct XXX;
          *)
         (if (info[]<>NONE) and (info.name[]<>NONE) then
             info.name.copy -> msg[];
             ': ' ->  msg.append;
          else
             &text[] -> msg[];
         if);
         'No struct tag and no struct body; ignored' -> msg.append;
         msg[] -> error;
     if);
     (if body[]=NONE then
         (* This is one of 
          *   typedef struct XXX YYY; 
          *   typedef struct XXX *YYY; 
          * Tag cannot be NONE, c.f. above.
          * info.name is YYY, struct_tag is XXX.
          *)
         (if (info[]<>NONE) then
             (if (info.pointer_level=0) then
                 (info.name[], 'struct_'->(struct_tag.copy).prepend)
                   -> emit_alias_pattern;
             if)
         if);
         alias_tagged_struct_type (* works for pointer_levels too *);
         leave do_struct_type;
     if);
     (if struct_tag[]=NONE then
         (* body cannot be NONE c.f. above *)
         (if info[]=NONE then
             (* typedef struct { ... } *)
             'typedef of struct with no name and no tag; ignored' -> error;
             leave do_struct_type;
         if);
         (if info.pointer_level=0 then
             (* typedef struct { ... } XXX *)
             info.name[] -> emit_struct_pattern;
             (if info.name[]<>NONE then
                 (* name may be NONE if is_definition is false *)
                 info.name.copy -> info.representation[];
                 type_cat_struct -> info.category;
                 info.representation.copy -> holders.add;
             if);
             leave do_struct_type;
          else
             (* typedef struct { ... } *XXX *)
             (* We have to generate a pattern to point to! *)
             info.name.copy -> struct_tag[];
             (* rest is handled below *)
         if);
     if);
         
     (* If we get here there is a tag (possibly generated) and a body. 
      * Name may, however be missing (info[]=NONE). I.e. we have one of
      *   1. typedef struct TTT { ... } XXX
      *   2. typedef struct TTT { ... } *XXX
      *   3. typedef struct TTT { ... }
      *)
     (if (info[]<>NONE) then
         (if (info.pointer_level > 0) then
             (* This is 
              *    typedef struct TTT {...} *XXX
              *)
             alias_tagged_struct_type;
             leave do_struct_type;
         if);
         (if (info.name[]<>NONE) then
             (* This is
              *    typedef struct TTT { ... } XXX;
              * info.name is XXX, struct_tag is TTT.
              *)
             (* Create alias pattern too *)
             (info.name[], 'struct_'->(struct_tag.copy).prepend)
               -> emit_alias_pattern;
         if);
         struct_tag[] -> add_tagged_struct_type;
         (* set up info for XXX *)
         type_cat_struct -> info.category;
         'struct_' -> (struct_tag.copy).prepend  -> info.representation[];
         (* Emit pattern *)
         info.representation[] -> emit_struct_pattern;
      else
         (* This is
          *    typedef struct TTT { ... };
          * info is NONE, struct_tag is TTT.
          *)
         struct_tag[] -> add_tagged_struct_type -> type_return[];
         type_return.representation[] -> emit_struct_pattern;
     if);
  #);

do_union_body:
  (# name, msg: ^text;
     body: ^idl.union_body;
  enter (name[], body[])
  do (if not nocode then
         (if name[]<>NONE then
             name.copy -> msg[];
             ':' -> msg.puttext;
          else 
             &text[]->msg[];
         if);
         '\n        union types are not translated. ' -> msg.puttext;
         'You must do it by hand, sorry!' -> msg.puttext;
         msg[] -> warning;
         output.newline; output.indent;
         output.commentbegin;
         output.newline; output.indent; ' * ' -> output.puttext; 
         'union types are not translated.' -> output.puttext;
         output.newline; output.indent; ' * ' -> output.puttext; 
         'You must do it by hand, sorry!' -> output.puttext;
         output.newline; output.indent; 
         output.commentend;
         output.newline;
     if);
  #);

do_union_type:
  (# t: ^idl.union_type;
     body: ^idl.union_body;
     info, type_return: ^type_info;
     union_tag: ^text;
     msg: ^text;
     is_definition: @boolean;
     
     emit_union_pattern:
       (# name: ^text;
          already_emitted: @boolean;
       enter name[]
       do (if debug then
              'emit_union_pattern: name: ' -> puttext;
              name[] -> putline;
          if);
          (if is_definition then
              (* Make sure we do not emit twice. Would happen otherwise for
               *   typedef union XXX { ... } YYY, ZZZ;
               *)
              union_patterns_emitted.find
              (# predicate:: (# do (name[]->current.equal)->value #);
              do true-> already_emitted;
              #);
              (if already_emitted then
                  (if debug then
                      'emit_union_pattern: already emitted.' -> putline;
                  if);
                  leave emit_union_pattern;
              if);
              name[] -> union_patterns_emitted.append;
              output.indent;
              name[] -> output.puttext;
              ': ' -> output.puttext;
          if);
          'holder' -> output.puttext (* to allow for parameter *);
          2 -> output.indent.inc;
          output.newline;
          output.indent;
          output.PatternBegin;
          3 -> output.indent.inc;
          (info.name[], body[]) -> do_union_body;
          3 -> output.indent.dec;
          output.indent;
          output.PatternEnd;
          2 -> output.indent.dec;
          (if is_definition then
              ';' -> output.putline;
          if);
       #);
     add_union_type:
       (# type: ^type_info;
          name, representation, holder: ^text;
       enter (name[], representation[], holder[])
       do (if debug then
              'add_union_type: name: ' -> puttext;
              name[] -> puttext;
              ', representation: ' -> puttext;
              representation[] -> putline;
          if);
          (name[], representation[]) -> local_types.add_union_type -> type[];
          holder[] -> holders.add;
       exit type[]
       #);
     add_tagged_union_type: 
       (# tag: ^text;
          name, representation: ^text;
          type: ^type_info;
       enter tag[]
       do (if debug then
              'add_tagged_union_type: tag: ' -> puttext;
              tag[] -> putline;
          if);
          'union-' -> (tag.copy).prepend -> name[];
          'union_' -> (tag.copy).prepend -> representation[];
          (name[], representation[], representation[]) 
            -> add_union_type 
            -> type[];
       exit type[]
       #);
     alias_tagged_union_type:
       (# notfound: @notfound_descriptor
            (* default is to use int32 for unknown types, but
             *    typedef union XXX YYY
             * is allowed *before* 'union XXX' is defined.
             *)
            (# representation: ^text;
            do 'union_' -> (union_tag.copy).prepend -> representation[];
               (name[], representation[], representation[]) 
                 -> add_union_type 
                 -> type[];
               (if body[]<>NONE then
                   (* The type was not there, and there is a body. E.g.:
                    *   typedef union TTT { ... } *XXX
                    * So emit pattern now. 
                    *)
                   representation[] -> emit_union_pattern;
               if);
            #);
          type_name: ^text;
       do (if debug then
              'alias_tagged_union_type: tag: ' -> puttext;
              union_tag[] -> putline;
          if);
          (* Let's find the representation of the aliased type
           * and copy the type information into info.
           *)
          (if union_tag[]=NONE then
              'alias_tagged_union_type: tag is none!' -> error;
           else
              'union-' -> (union_tag.copy).prepend -> type_name[];
              (type_name[], notfound[]) -> local_types.findtype
              (# 
              do current.representation.copy -> info.representation[];
                 current.category -> info.category;
              #);
          if)
       #);
  enter (info[], t[], is_definition)
  do (* If info is not NONE, set up info.representation and info.category *)
     (* Is there a tag? *)
     (if t.gettag -> optionalPresent then
         t.gettag -> IdentifierToText -> union_tag[];
      else
         NONE -> union_tag[]
     if);
     (* Is there a body? *)
     (if (t.getunion_body_opt -> optionalPresent) then
         t.getunion_body_opt -> body[];
      else
         NONE -> body[];
     if);
     (if (union_tag[]=NONE) and (body[]=NONE) then
         (* Error: No union tag and no union body, i.e.
          *   typedef union XXX;
          *)
         (if (info[]<>NONE) and (info.name[]<>NONE) then
             info.name.copy -> msg[];
             ': ' ->  msg.append;
          else
             &text[] -> msg[];
         if);
         'No union tag and no union body; ignored' -> msg.append;
         msg[] -> error;
     if);
     (if body[]=NONE then
         (* This is one of 
          *   typedef union XXX YYY; 
          *   typedef union XXX *YYY; 
          * Tag cannot be NONE, c.f. above.
          * info.name is YYY, union_tag is XXX.
          *)
         (if (info[]<>NONE) then
             (if (info.pointer_level=0) then
                 (info.name[], 'union_'->(union_tag.copy).prepend)
                   -> emit_alias_pattern;
             if)
         if);
         alias_tagged_union_type (* works for pointer_levels too *);
         leave do_union_type;
     if);
     (if union_tag[]=NONE then
         (* body cannot be NONE c.f. above *)
         (if info[]=NONE then
             (* typedef union { ... } *)
             'typedef of union with no name and no tag; ignored' -> error;
             leave do_union_type;
         if);
         (if info.pointer_level=0 then
             (* typedef union { ... } XXX *)
             info.name[] -> emit_union_pattern;
             (if info.name[]<>NONE then
                 (* name may be NONE if is_definition is false *)
                 info.name.copy -> info.representation[];
                 type_cat_union -> info.category;
                 info.representation.copy -> holders.add;
             if);
             leave do_union_type;
          else
             (* typedef union { ... } *XXX *)
             (* We have to generate a pattern to point to! *)
             info.name.copy -> union_tag[];
             (* rest is handled below *)
         if);
     if);
         
     (* If we get here there is a tag (possibly generated) and a body. 
      * Name may, however be missing (info[]=NONE). I.e. we have one of
      *   1. typedef union TTT { ... } XXX
      *   2. typedef union TTT { ... } *XXX
      *   3. typedef union TTT { ... }
      *)
     (if (info[]<>NONE) then
         (if (info.pointer_level > 0) then
             (* This is 
              *    typedef union TTT {...} *XXX
              *)
             alias_tagged_union_type;
             leave do_union_type;
         if);
         (if (info.name[]<>NONE) then
             (* This is
              *    typedef union TTT { ... } XXX;
              * info.name is XXX, union_tag is TTT.
              *)
             (* Create alias pattern too *)
             (info.name[], 'union_'->(union_tag.copy).prepend)
               -> emit_alias_pattern;
         if);
         union_tag[] -> add_tagged_union_type;
         (* set up info for XXX *)
         type_cat_union -> info.category;
         'union_' -> (union_tag.copy).prepend  -> info.representation[];
         (* Emit pattern *)
         info.representation[] -> emit_union_pattern;
      else
         (* This is
          *    typedef union TTT { ... };
          * info is NONE, union_tag is TTT.
          *)
         union_tag[] -> add_tagged_union_type -> type_return[];
         type_return.representation[] -> emit_union_pattern;
     if);
  #);

do_enum_type:
  (# t: ^idl.enum_type;
     eb: ^idl.enum_body;
     es: ^idl.enumerators;
     val: @integer;
     id, previous_id: ^text;
     initializer_met: @boolean;
     info: ^type_info;
  enter (info[], t[])
  do (if t.getenum_body_opt -> optionalPresent then
         t.getenum_body_opt -> eb[];
         (if info[]<>NONE then
             (* Define the enum-"type" *)
             output.indent;
             info.name[] -> output.puttext;
             ': IntegerObject(\# ' -> output.puttext;
             (if not compact then 
                 (if t.gettag -> optionalPresent then
                     output.CommentBegin;
                     'enum ' -> output.puttext;
                     t.gettag -> IdentifierToText -> output.puttext;
                     output.CommentEnd;
                     ' '->output.put;
                 if);
             if);
             output.PatternEnd;
             ';' -> output.putline;
             'int32' -> info.representation[];
             type_cat_enum -> info.category;
             (* No need for holder: Never pointer to enum *)
         if);
         (* Process each enumerator *) 
         eb.getenumerators -> es[];
         0->val;
         NONE -> id[];
         NONE -> previous_id[];
         false -> initializer_met;
         es.newscan
         (# v: ^idl.value;
            help: ^text;
            att: @idl_attributes;
            first_done: @boolean;
         do (if first_done then
                ';' -> output.putline;
             else
                true->first_done
            if);
            output.indent;
            id[] -> previous_id[];
            (att[], current.getattributes_specs) -> do_attributes_specs;
            att.typelib.helpstring[] -> help[];
            current.getidentifier -> IdentifierToText -> id[] ->output.puttext;
            ': ' -> output.puttext;
            (if (info[]<>NONE) and (info.name[]<>NONE) then
                info.name[] -> output.comment; 
            if);
            (if help[]<>NONE then
                help[] -> output.comment;
            if);
            output.PatternBegin;
            'exit ' -> output.puttext;
            (if current.getvalue_opt -> optionalPresent then
                ((current.getvalue_opt -> v[]).getconst_exp, true)
                  -> do_const_exp
                  -> output.puttext;
                true -> initializer_met;
             else
                (if initializer_met then
                    (* emit expression - let beta compiler do the work (:-) *)
                    previous_id[] -> output.puttext;
                    '+1' -> output.puttext;
                 else
                    (* emit value *)
                    val -> output.putint;
                    val+1 -> val;
                if);
            if);
            ' ' -> output.put;
            output.PatternEnd;
         #);
         ';' -> output.putline;
         (if not compact then output.newline; if);
     if);
  #);

do_constr_enum_type:
  (# info: ^type_info;
     t: ^idl.constr_enum_type;
  enter (info[], t[])
  do (info[], t.getenum_type) -> do_enum_type;
  #);

do_constr_struct_type:
  (# info: ^type_info;
     t: ^idl.constr_struct_type;
     is_definition: @boolean;
  enter (info[], t[], is_definition)
  do (info[], t.getstruct_type, is_definition) -> do_struct_type;
  #);

do_constr_union_type:
  (# info: ^type_info;
     t: ^idl.constr_union_type;
     is_definition: @boolean;
  enter (info[], t[], is_definition)
  do (info[], t.getunion_type, is_definition) -> do_union_type;
  #);


do_type_dcl_error:
  (# t: ^idl.type_dcl_error;
  enter t[]
  do output.indent;
     (* FIXME: *)'do_type_dcl_error NYI' -> error -> output.commentline;
  #);

--type_dcl_body: descriptor--
(#          
do (if d.symbol
    // idl.typedef then
       (d[]) -> do_typedef;
    // idl.extern then
       (d[]) -> do_extern;
    // idl.union_type then
       (NONE, d[], true) -> do_union_type;
    // idl.struct_type then
       (NONE,d[], true) -> do_struct_type;
    // idl.enum_type then
       (NONE,d[]) -> do_enum_type;
    // idl.type_dcl_error then
       d[] -> do_type_dcl_error;
   if);
#)
