ORIGIN 'translate';

--type_dcl_lib: attributes--
do_typedef:
  (# t: ^idl.typedef;
     x: ^idl.attributeX;
  enter (t[])
  do (t.gettype_declarator) -> do_type_declarator;
     (* FIXME: attributes should be put into type_info *)
     (if t.getattribute_opt -> optionalPresent then
         t.getattribute_opt -> do_attributeX;
     if);
  #);
  
do_type_spec:
  (# t: ^idl.type_spec;
     info: ^declarator_info;
     alias: ^text;
     found: @boolean;
  enter (info[],t[])
  do (if t.symbol
      // idl.float then
         'real' -> info.basic_type[];
         'float' -> info.comment[];
      // idl.double then
         'real' -> info.basic_type[];
         'double' -> info.comment[];
      // idl.signed_long_int then
         'int32' -> info.basic_type[];
      // idl.int then
         'int32' -> info.basic_type[];
      // idl.signed_short_int then
         'int16' -> info.basic_type[];
      // idl.unsigned_long_int then
         'int32u' -> info.basic_type[];
      // idl.unsigned_short_int then
         'int16u' -> info.basic_type[];
      // idl.unsigned_char then
         'int8u' -> info.basic_type[];
      // idl.signed_char then
         'int8' -> info.basic_type[];
      // idl.char then
         'char' -> info.basic_type[];
      // idl.boolean_type then
         'boolean' -> info.basic_type[];
      // idl.octet_type then
         'int8u' -> info.basic_type[];
         'octet' -> info.comment[];
      // idl.any_type then
         'any_type' -> info.basic_type[];
         'NYI' -> info.comment[];
      // idl.sequence1 then
         'sequence1' -> info.basic_type[];
         'NYI' -> info.comment[];
      // idl.sequence2 then
         'sequence2' -> info.basic_type[];
         'NYI' -> info.comment[];
      // idl.string1 then
         'sequence1' -> info.basic_type[];
         'NYI' -> info.comment[];
      // idl.string2 then
         'sequence2' -> info.basic_type[];
         'NYI' -> info.comment[];
      // idl.scoped_name1
      // idl.scoped_name2
      // idl.scoped_name3 then
         (* We have an alias *)
         t[] -> do_scoped_name -> alias[];
         find: types.scan
         (# 
         do (if current.id[] -> alias.equal then
                current[] -> info.is_alias_for[];
                true -> found;
                leave find;
            if);
         #);
         (if not found then
             'Warning: ' -> puttext;
             alias[] -> puttext;
             ' not found in symbol table!' -> putline;
         if);
      // idl.constr_struct_type then
         (* Both emit the definition of the construction mapping, and
          * add the type to types.
          *)
         info.id[] -> outfile.puttext; ': ' -> outfile.puttext;
         t[] -> do_constr_struct_type;
         'data' -> info.basic_type[];
      // idl.constr_union_type then
         'constr_union_type NYI' -> outfile.puttext;
      // idl.constr_enum_type then
         (* Both emit the definition of the enum mapping, and
          * add the type to types.
          *)
         info.id[] -> outfile.puttext; ': ' -> outfile.puttext;
         (info[],t[]) -> do_constr_enum_type;
         'integer' -> info.basic_type[];
      // idl.void_type_spec then
         'void' -> info.basic_type[];
      else
         'Oops, must have forgotten a type!' -> outfile.comment;
     if);
  #);

do_type_declarator:
  (# t: ^idl.type_declarator;
     info: ^declarator_info;
     d: ^idl.declarators;
  enter t[]
  do t.getdeclarators -> d[];
     d.newscan
     (# d: ^idl.declarator;
     do &declarator_info[] -> info[] -> types.append;
        (info[], current[]) -> do_declarator;
        (info[], t.gettype_spec) -> do_type_spec;
     #);
  #);

do_struct_type:
  (# t: ^idl.struct_type;
     l: ^idl.member_list;
     do_members:
       (# m: ^idl.members
       enter m[]
       do m.newscan
          (# d: ^idl.declarators;
             mem: ^idl.member;
          do current[] -> mem[];
             mem.getdeclarators -> d[];
             d.newscan
             (# d: ^idl.declarator;
                info: @declarator_info;
             do outfile.indent;
                (info[], current[]) -> do_declarator;
                info.id[] -> outfile.puttext;
                ': '->outfile.puttext;
                (if info.pointer_level>0 then
                    '^' -> outfile.put;
                 else
                    '@' -> outfile.put;
                if);
                (info[], mem.gettype_spec) -> do_type_spec;
                (if info.pointer_level>1 then
                    'Holder' -> outfile.puttext;
                    info.id.copy -> refholders.append;
                if);
                (if mem.getattribute_opt -> optionalPresent then
                    mem.getattribute_opt -> do_attributeX;
                if);
                ';' -> outfile.putline;
             #);
          #);
       #);
  enter t[]
  do 'DATA' -> outfile.putline;
     2 -> outfile.indent.inc;
     outfile.indent;
     outfile.CommentBegin;
     'struct' -> outfile.puttext;
     (if t.getidentifierOpt -> optionalPresent then
         ' ' -> outfile.put;
         t.getidentifierOpt 
           -> IdentifierToText
           -> outfile.puttext;
     if);
     outfile.CommentEnd;
     outfile.newline;
     outfile.indent;
     outfile.PatternBegin;
     outfile.newline;
     3 -> outfile.indent.inc;
     t.getmember_list -> l[];
     l.getmembers -> do_members;
     3 -> outfile.indent.dec;
     outfile.indent;
     outfile.PatternEnd;
     2 -> outfile.indent.dec;
  #);
do_enum_type:
  (# t: ^idl.enum_type;
     es: ^idl.enumerators;
     val: @integer;
     info: ^declarator_info;
     id, previous_id: ^text;
     initializer_met: @boolean;
  enter (info[],t[])
  do (* Define "type" pattern *)
     'IntegerObject(\# ' -> outfile.puttext;
     outfile.CommentBegin;
     'enum ' -> outfile.puttext;
     t.getidentifier -> IdentifierToText -> outfile.puttext;
     outfile.CommentEnd;
     outfile.PatternEnd;
     (* Process each enumerator *) 
     t.getenumerators -> es[];
     0->val;
     NONE -> id[];
     NONE -> previous_id[];
     false -> initializer_met;
     es.newscan
     (# v: ^idl.value;
     do ';' -> outfile.putline;
        outfile.indent;
        id[] -> previous_id[];
        current.getidentifier -> IdentifierToText -> id[] ->outfile.puttext;
        ': ' -> outfile.puttext;
        outfile.CommentBegin;
        info.id[] -> outfile.puttext;
        outfile.CommentEnd;
        outfile.PatternBegin;
        'exit ' -> outfile.puttext;
        (if current.getvalue_opt -> optionalPresent then
            (current.getvalue_opt -> v[]).getconst_exp -> do_const_exp;
            true -> initializer_met;
         else
            (if initializer_met then
                (* emit expression - let beta compiler do the work (:-) *)
                previous_id[] -> outfile.puttext;
                '+1' -> outfile.puttext;
             else
                (* emit value *)
                val -> outfile.putint;
                val+1 -> val;
            if);
        if);
        outfile.PatternEnd;
     #);
  #);

do_constr_enum_type:
  (# t: ^idl.constr_enum_type;
     info: ^declarator_info;
  enter (info[],t[])
  do (info[],t.getenum_type) -> do_enum_type;
  #);

do_constr_struct_type:
  (# t: ^idl.constr_struct_type;
  enter t[]
  do t.getstruct_type -> do_struct_type;
  #);


do_type_dcl_error:
  (# t: ^idl.type_dcl_error;
  enter t[]
  do outfile.indent;
     'do_type_dcl_error NYI' -> outfile.commentline;
  #);

--type_dcl_body: descriptor--
(# dcl_info: @declarator_info;          
do (if d.symbol
    // idl.typedef then
       d[] -> do_typedef;
    // idl.struct_type then
       d[] -> do_struct_type;
    // idl.enum_type then
       (dcl_info[],d[]) -> do_enum_type;
    // idl.type_dcl_error then
       d[] -> do_type_dcl_error;
   if);
#)
