ORIGIN 'translate';

--add_basic_types: descriptor--
(# 
do (* Add basic types to global_types. The types are
    * derived from the MIDL base types as defined at URL
    * http://premium.microsoft.com/isapi/devonly/prodinfo/msdnprod/msdnlib.idc
    * ?theURL=/msdn/library/sdkdoc/ov-iface_0ipf.htm
    *)
   ('boolean',            'boolean') -> global_types.add_basic_type;
   ('unsigned_boolean',   'boolean') -> global_types.add_basic_type;
   ('signed_boolean',     'int8') -> global_types.add_basic_type;
   ('byte',               'int8u') -> global_types.add_basic_type;
   ('char',               'char') -> global_types.add_basic_type;
   ('signed_char',        'int8') -> global_types.add_basic_type;
   ('unsigned_char',      'int8u') -> global_types.add_basic_type;
   ('double',             'real') -> global_types.add_basic_type;
   ('error_status_t',     'int32u') -> global_types.add_basic_type;
   ('float',              'real') -> global_types.add_basic_type;
   ('handle_t',           'int32u') -> global_types.add_basic_type;
   (* hyper left out - 56 bit quantity not possible to handle in beta *)
   
   ('int',                'int32') -> global_types.add_basic_type;
   ('signed_int',         'int32') -> global_types.add_basic_type;
   ('unsigned_int',       'int32u') -> global_types.add_basic_type;
   
   ('long_int',           'int32') -> global_types.add_basic_type;
   ('long',               'int32') -> global_types.add_basic_type;
   ('signed_long_int',    'int32') -> global_types.add_basic_type;
   ('signed_long',        'int32') -> global_types.add_basic_type;
   ('unsigned_long_int',  'int32u') -> global_types.add_basic_type;
   ('unsigned_long',      'int32u') -> global_types.add_basic_type;
   
   ('short_int',          'int16') -> global_types.add_basic_type;
   ('short',              'int16') -> global_types.add_basic_type;
   ('signed_short_int',   'int16') -> global_types.add_basic_type;
   ('signed_short',       'int16') -> global_types.add_basic_type;
   ('unsigned_short_int', 'int16u') -> global_types.add_basic_type;
   ('unsigned_short',     'int16u') -> global_types.add_basic_type;
   
   ('small_int',          'int16') -> global_types.add_basic_type;
   ('small',              'int16') -> global_types.add_basic_type;
   ('signed_small_int',   'int16') -> global_types.add_basic_type;
   ('signed_small',       'int16') -> global_types.add_basic_type;
   ('unsigned_small_int', 'int16u') -> global_types.add_basic_type;
   ('unsigned_small',     'int16u') -> global_types.add_basic_type;
   
   ('wchar_t',            'wchar') -> global_types.add_basic_type;
   
   (* These are not defined by MIDL, but nevertheless seem to be used *)
   ('octet',              'int8') -> global_types.add_basic_type;
   ('any',                'int32') -> global_types.add_basic_type;
   
   (* Add types from comlib.bet/wtypes.bet to global_types *)
   ('IUnknown',           'IUnknown') -> global_types.add_interface_type;
   ('IDispatch',          'IDispatch') -> global_types.add_interface_type;
   ('HRESULT',            'int32') -> global_types.add_basic_type;
   ('BSTR',               'BSTR') -> global_types.add_basic_type;
   ('DATE',               'real') -> global_types.add_basic_type;
   ('VARIANT',            'VARIANT') -> global_types.add_union_type;
   ('VARIANT_BOOL',       'int16') -> global_types.add_basic_type;
   ('OLECMDF',            'int32') -> global_types.add_basic_type;
   ('OLECMDID',           'int32') -> global_types.add_basic_type;
   ('OLECMDEXECOPT',      'int32') -> global_types.add_basic_type;
   ('READYSTATE',         'int32') -> global_types.add_basic_type;
   ('tagREADYSTATE',      'int32') -> global_types.add_basic_type;
#)

--do_base_type_spec: descriptor--
(# name: ^text;
do (if s.symbol
    // idl.float then 'float' -> name[];
    // idl.double then 'double' -> name[]; 
    // idl.int then 'int' -> name[];
    // idl.signed_long_int then 'signed_long_int' -> name[];
    // idl.signed_short_int then 'signed_short_int' -> name[];
    // idl.unsigned_long_int then 'unsigned_long_int' -> name[];
    // idl.unsigned_short_int then 'unsigned_short_int' -> name[];
    // idl.unsigned_char then 'unsigned_char' -> name[];
    // idl.signed_char then 'signed_char' -> name[];
    // idl.char then 'char' -> name[];
    // idl.boolean_type then 'boolean' -> name[];
    // idl.octet_type then 'octet' -> name[]; 
    // idl.any_type then 'any' -> name[];
   if);
   (* The type should be in global_types *)
   name[] -> global_types.findtype(# do current[] -> dcl_info.type[] #);
#)

--type_dcl_lib: attributes--
do_type_spec:
  (# t: ^idl.type_spec;
     info: ^type_info;
     types: ^type_list;
     found: @boolean;
     name: ^text;
  enter (info[],types[],t[])
  do (* First handle basic types. They can be found in types *)
     (if t.symbol
      // idl.float then 'float' -> name[];
      // idl.double then 'double' -> name[]; 
      // idl.int then 'int' -> name[];
      // idl.signed_long_int then 'signed_long_int' -> name[];
      // idl.signed_short_int then 'signed_short_int' -> name[];
      // idl.unsigned_long_int then 'unsigned_long_int' -> name[];
      // idl.unsigned_short_int then 'unsigned_short_int' -> name[];
      // idl.unsigned_char then 'unsigned_char' -> name[];
      // idl.signed_char then 'signed_char' -> name[];
      // idl.char then 'char' -> name[];
      // idl.boolean_type then 'boolean' -> name[];
      // idl.octet_type then 'octet' -> name[]; 
      // idl.any_type then 'any' -> name[];
     if);
     (if name[]<>NONE then
         (* Find the type in types *)
         name[]-> types.findtype(# 
                                do (if info.name[]=NONE then
                                       (* If info.name is not NONE,
                                        * then a typedef may be going
                                        * on, and we want the new
                                        * type to be known under the
                                        * new name!
                                        *)
                                       current.name.copy->info.name[];
                                   if);
                                   current.representation.copy
                                     ->info.representation[];
                                   current.pointer_level+info.pointer_level
                                     ->info.pointer_level;
                                   current.category
                                     ->info.category;
                                #);
      else
         (if t.symbol
          // idl.sequence1 then 'sequence1' -> info.representation[];
          // idl.sequence2 then 'sequence2' -> info.representation[];
          // idl.string1 then 'string1' -> info.representation[];
          // idl.string2 then 'string2' -> info.representation[];
          // idl.scoped_name1
          // idl.scoped_name2
          // idl.scoped_name3 then t[] 
               -> do_scoped_name 
               -> info.representation[];
             type_cat_user -> info.category;
          // idl.void_type_spec then
             'void' -> info.representation[];
          // idl.constr_struct_type then
             (* Both emit the definition of the construction mapping, and
              * add the type to types.
              *)
             outfile.indent;
             info.name[] -> outfile.puttext; ': ' -> outfile.puttext;
             (t[]) -> do_constr_struct_type;
             info.name.copy -> info.representation[];
             type_cat_struct -> info.category;
          // idl.constr_union_type then
             'constr_union_type NYI' -> outfile.puttext;
             type_cat_union -> info.category;
          // idl.constr_enum_type then
             (* Both emit the definition of the enum mapping, and
              * add the type to types.
              *)
             outfile.indent;
             info.name[] -> outfile.puttext; ': ' -> outfile.puttext;
             (t[]) -> do_constr_enum_type;
             'int32' -> info.representation[];
             type_cat_enum -> info.category;
          else
             'Oops, must have forgotten a type!' -> outfile.comment;
         if);
     if);
  #);

do_type_declarator:
  (# t: ^idl.type_declarator;
     info: ^type_info;
     att: ^idl_attributes;
     dcl_info: ^declarator_info;
     d: ^idl.declarators;
     types: ^type_list;
  enter (types[], att[], t[])
  do t.getdeclarators -> d[];
     d.newscan
     (# d: ^idl.declarator;
     do &type_info[] -> info[] -> types.append;
        att[] -> info.attributes[];
        &declarator_info[] -> dcl_info[];
        info[] -> dcl_info.type[];
        (* Get the name and pointer level of the type declaration *)
        (dcl_info[], current[]) -> do_declarator;
        dcl_info.name.copy -> info.name[];
        dcl_info.pointer_level -> info.pointer_level;
        (* done with dcl_info *)
        (* Fill in the rest of the type *)
        (info[], types[], t.gettype_spec) -> do_type_spec;
        (if debug then
            outfile.indent;
            outfile.CommentBegin;
            'typedef: ' -> outfile.puttext;
            info.name[] -> outfile.puttext;
            ': '-> outfile.puttext;
            (for info.pointer_level repeat '*' -> outfile.put for);
            info.representation[] -> outfile.puttext;
            outfile.CommentEnd;
            outfile.newline;
        if);
        outfile.newline;
     #);
  #);

do_typedef:
  (# t: ^idl.typedef;
     att: @idl_attributes;
  enter (t[])
  do outfile.newline;
     outfile.indent;
     (if t.getattributes_spec_opt -> optionalPresent then
         (att[],t.getattributes_spec_opt) -> do_attributes_spec;
         (if att.typelib.helpstring[]<>NONE then
             att.typelib.helpstring[]-> outfile.commentline;
         if)
     if);
     (local_types[], att[], t.gettype_declarator) -> do_type_declarator;
  #);
  
do_struct_type:
  (# t: ^idl.struct_type;
     l: ^idl.member_list;
     do_members:
       (# m: ^idl.members
       enter m[]
       do m.newscan
          (# d: ^idl.declarators;
             mem: ^idl.member;
          do current[] -> mem[];
             mem.getdeclarators -> d[];
             d.newscan
             (# d: ^idl.declarator;
                dcl_info: ^declarator_info;
                info: ^type_info;
             do outfile.indent;
                &type_info[] -> info[];
                &declarator_info[] -> dcl_info[];
                (dcl_info[], current[]) -> do_declarator;
                dcl_info.name[] -> outfile.puttext;
                ': '->outfile.puttext;
                (if dcl_info.pointer_level>0 then
                    '^' -> outfile.put;
                 else
                    '@' -> outfile.put;
                if);
                (info[], local_types[], mem.gettype_spec) -> do_type_spec;
                info.representation[] -> outfile.puttext;
                ' '->outfile.put; info.as_text -> outfile.comment;
                (if info.pointer_level>1 then
                    'Holder' -> outfile.puttext;
                    info.name.copy -> holders.add;
                if);
                (if mem.getattributes_spec_opt -> optionalPresent then
                    &idl_attributes[]->info.attributes[];
                    (info.attributes[],mem.getattributes_spec_opt)
                      -> do_attributes_spec;
                if);
                ';' -> outfile.put;
             #);
          #);
       #);
  enter (t[])
  do 'DATA' -> outfile.putline;
     2 -> outfile.indent.inc;
     outfile.indent;
     outfile.CommentBegin;
     'struct' -> outfile.puttext;
     (if t.getidentifierOpt -> optionalPresent then
         ' ' -> outfile.put;
         t.getidentifierOpt 
           -> IdentifierToText
           -> outfile.puttext;
     if);
     outfile.CommentEnd;
     outfile.newline;
     outfile.indent;
     outfile.PatternBegin;
     outfile.newline;
     3 -> outfile.indent.inc;
     t.getmember_list -> l[];
     l.getmembers -> do_members;
     3 -> outfile.indent.dec;
     outfile.indent;
     outfile.PatternEnd;
     2 -> outfile.indent.dec;
  #);
do_enum_type:
  (# t: ^idl.enum_type;
     es: ^idl.enumerators;
     val: @integer;
     id, previous_id: ^text;
     initializer_met: @boolean;
  enter (t[])
  do 'IntegerObject(\# ' -> outfile.puttext;
     outfile.CommentBegin;
     'enum ' -> outfile.puttext;
     t.getidentifier -> IdentifierToText -> outfile.puttext;
     outfile.CommentEnd;
     ' '->outfile.put;
     outfile.PatternEnd;
     (* Process each enumerator *) 
     t.getenumerators -> es[];
     0->val;
     NONE -> id[];
     NONE -> previous_id[];
     false -> initializer_met;
     es.newscan
     (# v: ^idl.value;
        help: ^text;
        att: @idl_attributes;
     do ';' -> outfile.putline;
        outfile.indent;
        id[] -> previous_id[];
        (if current.getattributes_spec_opt -> optionalPresent then
            (att[], current.getattributes_spec_opt) -> do_attributes_spec;
            att.typelib.helpstring[] -> help[]
         else
            NONE -> help[];
        if);
        current.getidentifier -> IdentifierToText -> id[] ->outfile.puttext;
        ': ' -> outfile.puttext;
        (* FIXME: missing
         * outfile.CommentBegin;
         * info.name[] -> outfile.puttext; 
         * outfile.CommentEnd;
         *)
        (if help[]<>NONE then
            help[] -> outfile.comment;
        if);
        outfile.PatternBegin;
        'exit ' -> outfile.puttext;
        (if current.getvalue_opt -> optionalPresent then
            (current.getvalue_opt -> v[]).getconst_exp 
              -> do_const_exp
              -> outfile.puttext;
            true -> initializer_met;
         else
            (if initializer_met then
                (* emit expression - let beta compiler do the work (:-) *)
                previous_id[] -> outfile.puttext;
                '+1' -> outfile.puttext;
             else
                (* emit value *)
                val -> outfile.putint;
                val+1 -> val;
            if);
        if);
        ' ' -> outfile.put;
        outfile.PatternEnd;
     #);
     ';' -> outfile.putline;
  #);

do_union_type:
  (# t: ^idl.union_type;
  enter (t[])
  do 'do_union_type NYI' -> outfile.commentline;
  #);

do_constr_enum_type:
  (# t: ^idl.constr_enum_type;
  enter (t[])
  do (t.getenum_type) -> do_enum_type;
  #);

do_constr_struct_type:
  (# t: ^idl.constr_struct_type;
  enter (t[])
  do (t.getstruct_type) -> do_struct_type;
  #);


do_type_dcl_error:
  (# t: ^idl.type_dcl_error;
  enter t[]
  do outfile.indent;
     'do_type_dcl_error NYI' -> outfile.commentline;
  #);

--type_dcl_body: descriptor--
(#          
do (if d.symbol
    // idl.typedef then
       (d[]) -> do_typedef;
    // idl.union_type then
       (d[]) -> do_union_type;
    // idl.struct_type then
       (d[]) -> do_struct_type;
    // idl.enum_type then
       (d[]) -> do_enum_type;
    // idl.type_dcl_error then
       d[] -> do_type_dcl_error;
   if);
#)
