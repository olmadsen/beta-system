(* BETA interface generated from "OAIdl.Idl"
 * with options: -F -q 
 *)
ORIGIN '~beta/comlib/comtypes';
INCLUDE 'ObjIdl';
(*BASIC iDispatch;*)
--LIB: attributes-- ;
  (* //+------------------------------------------------------------------------- *)
  (* // *)
  (* //  Microsoft Windows *)
  (* //  Copyright 1992 - 1998 Microsoft Corporation. *)
  (* // *)
  (* //-------------------------------------------------------------------------- *)
  (* #if ( _MSC_VER >= 800 ) *)
  (* #endif *)

  IOleAutomationTypes: COM
    (# <<SLOT IOleAutomationTypesLib: attributes>>;
       version: (# exit 1.0 #);
         (* /* the following is what MIDL knows how to remote */ *)
         (* /* VARIANT STRUCTURE *)
         (*  * *)
         (*  *  VARTYPE vt; *)
         (*  *  WORD wReserved1; *)
         (*  *  WORD wReserved2; *)
         (*  *  WORD wReserved3; *)
         (*  *  union { *)
         (*  *    LONG           VT_I4 *)
         (*  *    BYTE           VT_UI1 *)
         (*  *    SHORT          VT_I2 *)
         (*  *    FLOAT          VT_R4 *)
         (*  *    DOUBLE         VT_R8 *)
         (*  *    VARIANT_BOOL   VT_BOOL *)
         (*  *    SCODE          VT_ERROR *)
         (*  *    CY             VT_CY *)
         (*  *    DATE           VT_DATE *)
         (*  *    BSTR           VT_BSTR *)
         (*  *    IUnknown *     VT_UNKNOWN *)
         (*  *    IDispatch *    VT_DISPATCH *)
         (*  *    SAFEARRAY *    VT_ARRAY *)
         (*  *    BYTE *         VT_BYREF|VT_UI1 *)
         (*  *    SHORT *        VT_BYREF|VT_I2 *)
         (*  *    LONG *         VT_BYREF|VT_I4 *)
         (*  *    FLOAT *        VT_BYREF|VT_R4 *)
         (*  *    DOUBLE *       VT_BYREF|VT_R8 *)
         (*  *    VARIANT_BOOL * VT_BYREF|VT_BOOL *)
         (*  *    SCODE *        VT_BYREF|VT_ERROR *)
         (*  *    CY *           VT_BYREF|VT_CY *)
         (*  *    DATE *         VT_BYREF|VT_DATE *)
         (*  *    BSTR *         VT_BYREF|VT_BSTR *)
         (*  *    IUnknown **    VT_BYREF|VT_UNKNOWN *)
         (*  *    IDispatch **   VT_BYREF|VT_DISPATCH *)
         (*  *    SAFEARRAY **   VT_BYREF|VT_ARRAY *)
         (*  *    VARIANT *      VT_BYREF|VT_VARIANT *)
         (*  *    PVOID          VT_BYREF (Generic ByRef) *)
         (*  *    CHAR           VT_I1 *)
         (*  *    USHORT         VT_UI2 *)
         (*  *    ULONG          VT_UI4 *)
         (*  *    INT            VT_INT *)
         (*  *    UINT           VT_UINT *)
         (*  *    DECIMAL *      VT_BYREF|VT_DECIMAL *)
         (*  *    CHAR *         VT_BYREF|VT_I1 *)
         (*  *    USHORT *       VT_BYREF|VT_UI2 *)
         (*  *    ULONG *        VT_BYREF|VT_UI4 *)
         (*  *    INT *          VT_BYREF|VT_INT *)
         (*  *    UINT *         VT_BYREF|VT_UINT *)
         (*  *  } *)
         (*  */ *)
         (* #if (__STDC__ && !defined(_FORCENAMELESSUNION)) || defined(NONAMELESSUNION) *)
         (* #define __VARIANT_NAME_1 n1 *)
         (* #define __VARIANT_NAME_2 n2 *)
         (* #define __VARIANT_NAME_3 n3 *)
         (* #define __VARIANT_NAME_4 brecVal *)
         (* #else *)
         (* #define __tagVARIANT *)
         (* #define __VARIANT_NAME_1 *)
         (* #define __VARIANT_NAME_2 *)
         (* #define __VARIANT_NAME_3 *)
         (* #define __tagBRECORD *)
         (* #define __VARIANT_NAME_4 *)
         (* #endif *)
         (* /* the following is what MIDL knows how to remote */ *)
         (* #if 0 *)
         (* /* the following is what MIDL knows how to remote */ *)
         (* #else /* 0 */ *)
         (* typedef struct tagELEMDESC { *)
         (*     TYPEDESC tdesc;             /* the type of the element */ *)
         (*     union { *)
         (*         IDLDESC idldesc;        /* info for remoting the element */ *)
         (*         PARAMDESC paramdesc;    /* info about the parameter */ *)
         (*     }; *)
         (* } ELEMDESC, * LPELEMDESC; *)
         (* #endif /* 0 */ *)
         (* #if 0 *)
         (* /* the following is what MIDL knows how to remote */ *)
         (* #else /* 0 */ *)
         (* typedef struct tagEXCEPINFO { *)
         (*     WORD  wCode; *)
         (*     WORD  wReserved; *)
         (*     BSTR  bstrSource; *)
         (*     BSTR  bstrDescription; *)
         (*     BSTR  bstrHelpFile; *)
         (*     DWORD dwHelpContext; *)
         (*     PVOID pvReserved; *)
         (*     HRESULT (__stdcall *pfnDeferredFillIn)(struct tagEXCEPINFO * ); *)
         (*     SCODE scode; *)
         (* } EXCEPINFO, * LPEXCEPINFO; *)
         (* #endif /* 0 */ *)
    #);
  SAFEARRAYBOUND: struct_tagSAFEARRAYBOUND(# #);
  struct_tagSAFEARRAYBOUND: DATA
    (# cElements: @int32u (* ULONG *);
       lLbound: @int32 (* LONG *);
    #);
  SAFEARR_BSTR: struct__wireSAFEARR_BSTR(# #);
  struct__wireSAFEARR_BSTR: DATA
    (# Size: @int32u (* ULONG *);
       aBstr: @int32 (* (Build argument array in ExternalRecord) *);
    #);
  SAFEARR_UNKNOWN: struct__wireSAFEARR_UNKNOWN(# #);
  struct__wireSAFEARR_UNKNOWN: DATA
    (# Size: @int32u (* ULONG *);
       apUnknown: @int32 (* (Build argument array in ExternalRecord) *);
    #);
  SAFEARR_DISPATCH: struct__wireSAFEARR_DISPATCH(# #);
  struct__wireSAFEARR_DISPATCH: DATA
    (# Size: @int32u (* ULONG *);
       apDispatch: @int32 (* (Build argument array in ExternalRecord) *);
    #);
  SAFEARR_VARIANT: struct__wireSAFEARR_VARIANT(# #);
  struct__wireSAFEARR_VARIANT: DATA
    (# Size: @int32u (* ULONG *);
       aVariant: @int32 (* (Build argument array in ExternalRecord) *);
    #);
  SAFEARR_BRECORD: struct__wireSAFEARR_BRECORD(# #);
  struct__wireSAFEARR_BRECORD: DATA
    (# Size: @int32u (* ULONG *);
       aRecord: @int32 (* (Build argument array in ExternalRecord) *);
    #);
  SAFEARR_HAVEIID: struct__wireSAFEARR_HAVEIID(# #);
  struct__wireSAFEARR_HAVEIID: DATA
    (# Size: @int32u (* ULONG *);
       apUnknown: @int32 (* (Build argument array in ExternalRecord) *);
       _iid: @GUIDdata (* IID *);
    #);
  enum_SF_TYPE: IntegerObject(# (* enum tagSF_TYPE *) #);
  SF_ERROR: (* SF_TYPE *)(# exit VT_ERROR #);
  SF_I1: (* SF_TYPE *)(# exit VT_I1 #);
  SF_I2: (* SF_TYPE *)(# exit VT_I2 #);
  SF_I4: (* SF_TYPE *)(# exit VT_I4 #);
  SF_I8: (* SF_TYPE *)(# exit VT_I8 #);
  SF_BSTR: (* SF_TYPE *)(# exit VT_BSTR #);
  SF_UNKNOWN: (* SF_TYPE *)(# exit VT_UNKNOWN #);
  SF_DISPATCH: (* SF_TYPE *)(# exit VT_DISPATCH #);
  SF_VARIANT: (* SF_TYPE *)(# exit VT_VARIANT #);
  SF_RECORD: (* SF_TYPE *)(# exit VT_RECORD #);
  SF_HAVEIID: (* SF_TYPE *)(# exit VT_UNKNOWN %Bor VT_RESERVED #);

  SAFEARRAYUNION: union__wireSAFEARRAY_UNION(# #);
  union__wireSAFEARRAY_UNION: holder
    (# 
       (* 
        * union types are not translated.
        * You must do it by hand, sorry!
        *)
    #);
  struct__wireSAFEARRAY: DATA
    (# cDims: @int16u (* USHORT *);
       fFeatures: @int16u (* USHORT *);
       cbElements: @int32u (* ULONG *);
       cLocks: @int32u (* ULONG *);
       uArrayStructs: @union__wireSAFEARRAY_UNION (* SAFEARRAYUNION *);
       rgsabound: @int32 (* (Build argument array in ExternalRecord) *);
    #);
  SAFEARRAY: struct_tagSAFEARRAY(# #);
  struct_tagSAFEARRAY: DATA
    (# cDims: @int16u (* USHORT *);
       fFeatures: @int16u (* USHORT *);
       cbElements: @int32u (* ULONG *);
       cLocks: @int32u (* ULONG *);
       pvData: ^int32Holder (* PVOID* *);
       rgsabound: ^struct_tagSAFEARRAYBOUND (* SAFEARRAYBOUND* *);
    #);
  FADF_AUTO: (# exit 0x0001 #);
  FADF_STATIC: (# exit 0x0002 #);
  FADF_EMBEDDED: (# exit 0x0004 #);
  FADF_FIXEDSIZE: (# exit 0x0010 #);
  FADF_RECORD: (# exit 0x0020 #);
  FADF_HAVEIID: (# exit 0x0040 #);
  FADF_HAVEVARTYPE: (# exit 0x0080 #);
  FADF_BSTR: (# exit 0x0100 #);
  FADF_UNKNOWN: (# exit 0x0200 #);
  FADF_DISPATCH: (# exit 0x0400 #);
  FADF_VARIANT: (# exit 0x0800 #);
  FADF_RESERVED: (# exit 0xF008 #);
  struct_tagVARIANT: DATA
    (# __VARIANT_NAME_1: @holder
         (# 
            (* 
             * union types are not translated.
             * You must do it by hand, sorry!
             *)
         #);
    #);
  struct__wireBRECORD: DATA
    (# fFlags: @int32u (* ULONG *);
       clSize: @int32u (* ULONG *);
       pRecInfo: ^IRecordInfo (* IRecordInfo* *);
       pRecord: @int32 (* (Build argument array in ExternalRecord) *);
    #);
  struct__wireVARIANT: DATA
    (# clSize: @int32u (* DWORD *);
       rpcReserved: @int32u (* DWORD *);
       vt: @int16u (* USHORT *);
       wReserved1: @int16u (* USHORT *);
       wReserved2: @int16u (* USHORT *);
       wReserved3: @int16u (* USHORT *);
    #);
  enum_TYPEKIND: IntegerObject(# (* enum tagTYPEKIND *) #);
  TKIND_ENUM: (* TYPEKIND *)(# exit 0 #);
  TKIND_RECORD: (* TYPEKIND *)(# exit TKIND_ENUM+1 #);
  TKIND_MODULE: (* TYPEKIND *)(# exit TKIND_RECORD+1 #);
  TKIND_INTERFACE: (* TYPEKIND *)(# exit TKIND_MODULE+1 #);
  TKIND_DISPATCH: (* TYPEKIND *)(# exit TKIND_INTERFACE+1 #);
  TKIND_COCLASS: (* TYPEKIND *)(# exit TKIND_DISPATCH+1 #);
  TKIND_ALIAS: (* TYPEKIND *)(# exit TKIND_COCLASS+1 #);
  TKIND_UNION: (* TYPEKIND *)(# exit TKIND_ALIAS+1 #);
  TKIND_MAX: (* TYPEKIND *)(# exit TKIND_UNION+1 #);

  TYPEDESC: struct_tagTYPEDESC(# #);
  struct_tagTYPEDESC: DATA
    (# vt: @int16u (* VARTYPE *);
    #);
  ARRAYDESC: struct_tagARRAYDESC(# #);
  struct_tagARRAYDESC: DATA
    (# tdescElem: @struct_tagTYPEDESC (* TYPEDESC *);
       cDims: @int16u (* USHORT *);
       rgbounds: @int32 (* (Build argument array in ExternalRecord) *);
    #);
  PARAMDESCEX: struct_tagPARAMDESCEX(# #);
  struct_tagPARAMDESCEX: DATA
    (# cBytes: @int32u (* ULONG *);
       varDefaultValue: @VARIANT (* VARIANTARG *);
    #);
  PARAMDESC: struct_tagPARAMDESC(# #);
  struct_tagPARAMDESC: DATA
    (# pparamdescex: ^struct_tagPARAMDESCEX (* LPPARAMDESCEX* *);
       wParamFlags: @int16u (* USHORT *);
    #);
  PARAMFLAG_NONE: (# exit 0x00 #);
  PARAMFLAG_FIN: (# exit 0x01 #);
  PARAMFLAG_FOUT: (# exit 0x02 #);
  PARAMFLAG_FLCID: (# exit 0x04 #);
  PARAMFLAG_FRETVAL: (# exit 0x08 #);
  PARAMFLAG_FOPT: (# exit 0x10 #);
  PARAMFLAG_FHASDEFAULT: (# exit 0x20 #);
  PARAMFLAG_FHASCUSTDATA: (# exit 0x40 #);
  IDLDESC: struct_tagIDLDESC(# #);
  struct_tagIDLDESC: DATA
    (# dwReserved: @int32u (* ULONG *);
       wIDLFlags: @int16u (* USHORT *);
    #);
  IDLFLAG_NONE: (# exit PARAMFLAG_NONE #);
  IDLFLAG_FIN: (# exit PARAMFLAG_FIN #);
  IDLFLAG_FOUT: (# exit PARAMFLAG_FOUT #);
  IDLFLAG_FLCID: (# exit PARAMFLAG_FLCID #);
  IDLFLAG_FRETVAL: (# exit PARAMFLAG_FRETVAL #);
  ELEMDESC: struct_tagELEMDESC(# #);
  struct_tagELEMDESC: DATA
    (# tdesc: @struct_tagTYPEDESC (* TYPEDESC *);
       paramdesc: @struct_tagPARAMDESC (* PARAMDESC *);
    #);
  TYPEATTR: struct_tagTYPEATTR(# #);
  struct_tagTYPEATTR: DATA
    (# _guid: @GUIDdata (* GUID *);
       lcid: @int32u (* LCID *);
       dwReserved: @int32u (* DWORD *);
       memidConstructor: @int32 (* MEMBERID *);
       memidDestructor: @int32 (* MEMBERID *);
       lpstrSchema: ^wcharHolder (* LPOLESTR* *);
       cbSizeInstance: @int32u (* ULONG *);
       typekind: @int32 (* TYPEKIND *);
       cFuncs: @int16u (* WORD *);
       cVars: @int16u (* WORD *);
       cImplTypes: @int16u (* WORD *);
       cbSizeVft: @int16u (* WORD *);
       cbAlignment: @int16u (* WORD *);
       wTypeFlags: @int16u (* WORD *);
       wMajorVerNum: @int16u (* WORD *);
       wMinorVerNum: @int16u (* WORD *);
       tdescAlias: @struct_tagTYPEDESC (* TYPEDESC *);
       idldescType: @struct_tagIDLDESC (* IDLDESC *);
    #);
  DISPPARAMS: struct_tagDISPPARAMS(# #);
  struct_tagDISPPARAMS: DATA
    (# rgvarg: @int32 (* (Build argument array in ExternalRecord) *);
       rgdispidNamedArgs: @int32 (* (Build argument array in ExternalRecord) *);
       cArgs: @int32u (* UINT *);
       cNamedArgs: @int32u (* UINT *);
    #);
  EXCEPINFO: struct_tagEXCEPINFO(# #);
  struct_tagEXCEPINFO: DATA
    (# wCode: @int16u (* WORD *);
       wReserved: @int16u (* WORD *);
       bstrSource: @int32 (* BSTR *);
       bstrDescription: @int32 (* BSTR *);
       bstrHelpFile: @int32 (* BSTR *);
       dwHelpContext: @int32u (* DWORD *);
       pvReserved: @int32u (* ULONG *);
       pfnDeferredFillIn: @int32u (* ULONG *);
       scode: @int32 (* SCODE *);
    #);
  enum_CALLCONV: IntegerObject(# (* enum tagCALLCONV *) #);
  CC_FASTCALL: (* CALLCONV *)(# exit 0 #);
  CC_CDECL: (* CALLCONV *)(# exit 1 #);
  CC_MSCPASCAL: (* CALLCONV *)(# exit CC_CDECL+1 #);
  CC_PASCAL: (* CALLCONV *)(# exit CC_MSCPASCAL #);
  CC_MACPASCAL: (* CALLCONV *)(# exit CC_PASCAL+1 #);
  CC_STDCALL: (* CALLCONV *)(# exit CC_MACPASCAL+1 #);
  CC_FPFASTCALL: (* CALLCONV *)(# exit CC_STDCALL+1 #);
  CC_SYSCALL: (* CALLCONV *)(# exit CC_FPFASTCALL+1 #);
  CC_MPWCDECL: (* CALLCONV *)(# exit CC_SYSCALL+1 #);
  CC_MPWPASCAL: (* CALLCONV *)(# exit CC_MPWCDECL+1 #);
  CC_MAX: (* CALLCONV *)(# exit CC_MPWPASCAL+1 #);

  enum_FUNCKIND: IntegerObject(# (* enum tagFUNCKIND *) #);
  FUNC_VIRTUAL: (* FUNCKIND *)(# exit 0 #);
  FUNC_PUREVIRTUAL: (* FUNCKIND *)(# exit 1 #);
  FUNC_NONVIRTUAL: (* FUNCKIND *)(# exit 2 #);
  FUNC_STATIC: (* FUNCKIND *)(# exit 3 #);
  FUNC_DISPATCH: (* FUNCKIND *)(# exit 4 #);

  enum_INVOKEKIND: IntegerObject(# (* enum tagINVOKEKIND *) #);
  INVOKE_FUNC: (* INVOKEKIND *)(# exit 1 #);
  INVOKE_PROPERTYGET: (* INVOKEKIND *)(# exit 2 #);
  INVOKE_PROPERTYPUT: (* INVOKEKIND *)(# exit 4 #);
  INVOKE_PROPERTYPUTREF: (* INVOKEKIND *)(# exit 8 #);

  FUNCDESC: struct_tagFUNCDESC(# #);
  struct_tagFUNCDESC: DATA
    (# memid: @int32 (* MEMBERID *);
       lprgscode: @int32 (* (Build argument array in ExternalRecord) *);
       lprgelemdescParam: @int32 (* (Build argument array in ExternalRecord) *);
       funckind: @int32 (* FUNCKIND *);
       invkind: @int32 (* INVOKEKIND *);
       callconv: @int32 (* CALLCONV *);
       cParams: @int16 (* SHORT *);
       cParamsOpt: @int16 (* SHORT *);
       oVft: @int16 (* SHORT *);
       cScodes: @int16 (* SHORT *);
       elemdescFunc: @struct_tagELEMDESC (* ELEMDESC *);
       wFuncFlags: @int16u (* WORD *);
    #);
  enum_VARKIND: IntegerObject(# (* enum tagVARKIND *) #);
  VAR_PERINSTANCE: (* VARKIND *)(# exit 0 #);
  VAR_STATIC: (* VARKIND *)(# exit 1 #);
  VAR_CONST: (* VARKIND *)(# exit 2 #);
  VAR_DISPATCH: (* VARKIND *)(# exit 3 #);

  IMPLTYPEFLAG_FDEFAULT: (# exit 0x1 #);
  IMPLTYPEFLAG_FSOURCE: (# exit 0x2 #);
  IMPLTYPEFLAG_FRESTRICTED: (# exit 0x4 #);
  IMPLTYPEFLAG_FDEFAULTVTABLE: (# exit 0x8 #);
  VARDESC: struct_tagVARDESC(# #);
  struct_tagVARDESC: DATA
    (# memid: @int32 (* MEMBERID *);
       lpstrSchema: ^wcharHolder (* LPOLESTR* *);
       elemdescVar: @struct_tagELEMDESC (* ELEMDESC *);
       wVarFlags: @int16u (* WORD *);
       varkind: @int32 (* VARKIND *);
    #);
  enum_TYPEFLAGS: IntegerObject(# (* enum tagTYPEFLAGS *) #);
  TYPEFLAG_FAPPOBJECT: (* TYPEFLAGS *)(# exit 0x01 #);
  TYPEFLAG_FCANCREATE: (* TYPEFLAGS *)(# exit 0x02 #);
  TYPEFLAG_FLICENSED: (* TYPEFLAGS *)(# exit 0x04 #);
  TYPEFLAG_FPREDECLID: (* TYPEFLAGS *)(# exit 0x08 #);
  TYPEFLAG_FHIDDEN: (* TYPEFLAGS *)(# exit 0x10 #);
  TYPEFLAG_FCONTROL: (* TYPEFLAGS *)(# exit 0x20 #);
  TYPEFLAG_FDUAL: (* TYPEFLAGS *)(# exit 0x40 #);
  TYPEFLAG_FNONEXTENSIBLE: (* TYPEFLAGS *)(# exit 0x80 #);
  TYPEFLAG_FOLEAUTOMATION: (* TYPEFLAGS *)(# exit 0x100 #);
  TYPEFLAG_FRESTRICTED: (* TYPEFLAGS *)(# exit 0x200 #);
  TYPEFLAG_FAGGREGATABLE: (* TYPEFLAGS *)(# exit 0x400 #);
  TYPEFLAG_FREPLACEABLE: (* TYPEFLAGS *)(# exit 0x800 #);
  TYPEFLAG_FDISPATCHABLE: (* TYPEFLAGS *)(# exit 0x1000 #);
  TYPEFLAG_FREVERSEBIND: (* TYPEFLAGS *)(# exit 0x2000 #);

  enum_FUNCFLAGS: IntegerObject(# (* enum tagFUNCFLAGS *) #);
  FUNCFLAG_FRESTRICTED: (* FUNCFLAGS *)(# exit 0x1 #);
  FUNCFLAG_FSOURCE: (* FUNCFLAGS *)(# exit 0x2 #);
  FUNCFLAG_FBINDABLE: (* FUNCFLAGS *)(# exit 0x4 #);
  FUNCFLAG_FREQUESTEDIT: (* FUNCFLAGS *)(# exit 0x8 #);
  FUNCFLAG_FDISPLAYBIND: (* FUNCFLAGS *)(# exit 0x10 #);
  FUNCFLAG_FDEFAULTBIND: (* FUNCFLAGS *)(# exit 0x20 #);
  FUNCFLAG_FHIDDEN: (* FUNCFLAGS *)(# exit 0x40 #);
  FUNCFLAG_FUSESGETLASTERROR: (* FUNCFLAGS *)(# exit 0x80 #);
  FUNCFLAG_FDEFAULTCOLLELEM: (* FUNCFLAGS *)(# exit 0x100 #);
  FUNCFLAG_FUIDEFAULT: (* FUNCFLAGS *)(# exit 0x200 #);
  FUNCFLAG_FNONBROWSABLE: (* FUNCFLAGS *)(# exit 0x400 #);
  FUNCFLAG_FREPLACEABLE: (* FUNCFLAGS *)(# exit 0x800 #);
  FUNCFLAG_FIMMEDIATEBIND: (* FUNCFLAGS *)(# exit 0x1000 #);

  enum_VARFLAGS: IntegerObject(# (* enum tagVARFLAGS *) #);
  VARFLAG_FREADONLY: (* VARFLAGS *)(# exit 0x1 #);
  VARFLAG_FSOURCE: (* VARFLAGS *)(# exit 0x2 #);
  VARFLAG_FBINDABLE: (* VARFLAGS *)(# exit 0x4 #);
  VARFLAG_FREQUESTEDIT: (* VARFLAGS *)(# exit 0x8 #);
  VARFLAG_FDISPLAYBIND: (* VARFLAGS *)(# exit 0x10 #);
  VARFLAG_FDEFAULTBIND: (* VARFLAGS *)(# exit 0x20 #);
  VARFLAG_FHIDDEN: (* VARFLAGS *)(# exit 0x40 #);
  VARFLAG_FRESTRICTED: (* VARFLAGS *)(# exit 0x80 #);
  VARFLAG_FDEFAULTCOLLELEM: (* VARFLAGS *)(# exit 0x100 #);
  VARFLAG_FUIDEFAULT: (* VARFLAGS *)(# exit 0x200 #);
  VARFLAG_FNONBROWSABLE: (* VARFLAGS *)(# exit 0x400 #);
  VARFLAG_FREPLACEABLE: (* VARFLAGS *)(# exit 0x800 #);
  VARFLAG_FIMMEDIATEBIND: (* VARFLAGS *)(# exit 0x1000 #);

  CLEANLOCALSTORAGE: struct_tagCLEANLOCALSTORAGE(# #);
  struct_tagCLEANLOCALSTORAGE: DATA
    (# pInterface: ^IUnknown (* IUnknown* *);
       pStorage: ^int32Holder (* PVOID* *);
       flags: @int32u (* DWORD *);
    #);
  CUSTDATAITEM: struct_tagCUSTDATAITEM(# #);
  struct_tagCUSTDATAITEM: DATA
    (# _guid: @GUIDdata (* GUID *);
       varValue: @VARIANT (* VARIANTARG *);
    #);
  CUSTDATA: struct_tagCUSTDATA(# #);
  struct_tagCUSTDATA: DATA
    (# cCustData: @int32u (* DWORD *);
       prgCustData: @int32 (* (Build argument array in ExternalRecord) *);
    #);

  ICreateTypeInfo_IID: (# exit '00020405-0000-0000-C000-000000000046' #);

  ICreateTypeInfo: IUnknown
    (# <<SLOT ICreateTypeInfoLib: attributes>>;
       SetGuid:<
         (# result: @int32 (* HRESULT *);
            _guid: ^GUIDdata (* REFGUID* *); 
         enter _guid[]
         do INNER;
         exit result
         #);
       SetTypeFlags:<
         (# result: @int32 (* HRESULT *);
            uTypeFlags: @int32u (* UINT *); 
         enter uTypeFlags
         do INNER;
         exit result
         #);
       SetDocString:<
         (# result: @int32 (* HRESULT *);
            pStrDoc: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
         enter pStrDoc
         do INNER;
         exit result
         #);
       SetHelpContext:<
         (# result: @int32 (* HRESULT *);
            dwHelpContext: @int32u (* DWORD *); 
         enter dwHelpContext
         do INNER;
         exit result
         #);
       SetVersion:<
         (# result: @int32 (* HRESULT *);
            wMajorVerNum: @int16u (* WORD *); 
            wMinorVerNum: @int16u (* WORD *); 
         enter (wMajorVerNum, wMinorVerNum)
         do INNER;
         exit result
         #);
       AddRefTypeInfo:<
         (# result: @int32 (* HRESULT *);
            pTInfo: ^ITypeInfo (* ITypeInfo* *); 
            phRefType: @int32 (* HREFTYPE* *); 
         enter (pTInfo[], phRefType)
         do INNER;
         exit result
         #);
       AddFuncDesc:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            pFuncDesc: ^struct_tagFUNCDESC (* FUNCDESC* *); 
         enter (index, pFuncDesc[])
         do INNER;
         exit result
         #);
       AddImplType:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            _hRefType: @int32u (* HREFTYPE *); 
         enter (index, _hRefType)
         do INNER;
         exit result
         #);
       SetImplTypeFlags:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            implTypeFlags: @int32 (* INT *); 
         enter (index, implTypeFlags)
         do INNER;
         exit result
         #);
       SetAlignment:<
         (# result: @int32 (* HRESULT *);
            cbAlignment: @int16u (* WORD *); 
         enter cbAlignment
         do INNER;
         exit result
         #);
       SetSchema:<
         (# result: @int32 (* HRESULT *);
            pStrSchema: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
         enter pStrSchema
         do INNER;
         exit result
         #);
       AddVarDesc:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            pVarDesc: ^struct_tagVARDESC (* VARDESC* *); 
         enter (index, pVarDesc[])
         do INNER;
         exit result
         #);
       SetFuncAndParamNames:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            rgszNames: @int32 (* (Build argument string array in ExternalRecord) *) (* LPOLESTR** *); 
            cNames: @int32u (* UINT *); 
         enter (index, rgszNames, cNames)
         do INNER;
         exit result
         #);
       SetVarName:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            szName: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
         enter (index, szName)
         do INNER;
         exit result
         #);
       SetTypeDescAlias:<
         (# result: @int32 (* HRESULT *);
            pTDescAlias: ^struct_tagTYPEDESC (* TYPEDESC* *); 
         enter pTDescAlias[]
         do INNER;
         exit result
         #);
       DefineFuncAsDllEntry:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            szDllName: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
            szProcName: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
         enter (index, szDllName, szProcName)
         do INNER;
         exit result
         #);
       SetFuncDocString:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            szDocString: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
         enter (index, szDocString)
         do INNER;
         exit result
         #);
       SetVarDocString:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            szDocString: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
         enter (index, szDocString)
         do INNER;
         exit result
         #);
       SetFuncHelpContext:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            dwHelpContext: @int32u (* DWORD *); 
         enter (index, dwHelpContext)
         do INNER;
         exit result
         #);
       SetVarHelpContext:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            dwHelpContext: @int32u (* DWORD *); 
         enter (index, dwHelpContext)
         do INNER;
         exit result
         #);
       SetMops:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            bstrMops: @int32 (* BSTR *); 
         enter (index, bstrMops)
         do INNER;
         exit result
         #);
       SetTypeIdldesc:<
         (# result: @int32 (* HRESULT *);
            pIdlDesc: ^struct_tagIDLDESC (* IDLDESC* *); 
         enter pIdlDesc[]
         do INNER;
         exit result
         #);
       LayOut:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
    #);

  ICreateTypeInfo2_IID: (# exit '0002040E-0000-0000-C000-000000000046' #);

  ICreateTypeInfo2: ICreateTypeInfo
    (# <<SLOT ICreateTypeInfo2Lib: attributes>>;
       DeleteFuncDesc:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
         enter index
         do INNER;
         exit result
         #);
       DeleteFuncDescByMemId:<
         (# result: @int32 (* HRESULT *);
            memid: @int32 (* MEMBERID *); 
            invKind: @int32 (* INVOKEKIND *); 
         enter (memid, invKind)
         do INNER;
         exit result
         #);
       DeleteVarDesc:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
         enter index
         do INNER;
         exit result
         #);
       DeleteVarDescByMemId:<
         (# result: @int32 (* HRESULT *);
            memid: @int32 (* MEMBERID *); 
         enter memid
         do INNER;
         exit result
         #);
       DeleteImplType:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
         enter index
         do INNER;
         exit result
         #);
       SetCustData:<
         (# result: @int32 (* HRESULT *);
            _guid: ^GUIDdata (* REFGUID* *); 
            pVarVal: ^VARIANT (* VARIANT* *); 
         enter (_guid[], pVarVal[])
         do INNER;
         exit result
         #);
       SetFuncCustData:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            _guid: ^GUIDdata (* REFGUID* *); 
            pVarVal: ^VARIANT (* VARIANT* *); 
         enter (index, _guid[], pVarVal[])
         do INNER;
         exit result
         #);
       SetParamCustData:<
         (# result: @int32 (* HRESULT *);
            indexFunc: @int32u (* UINT *); 
            indexParam: @int32u (* UINT *); 
            _guid: ^GUIDdata (* REFGUID* *); 
            pVarVal: ^VARIANT (* VARIANT* *); 
         enter (indexFunc, indexParam, _guid[], pVarVal[])
         do INNER;
         exit result
         #);
       SetVarCustData:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            _guid: ^GUIDdata (* REFGUID* *); 
            pVarVal: ^VARIANT (* VARIANT* *); 
         enter (index, _guid[], pVarVal[])
         do INNER;
         exit result
         #);
       SetImplTypeCustData:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            _guid: ^GUIDdata (* REFGUID* *); 
            pVarVal: ^VARIANT (* VARIANT* *); 
         enter (index, _guid[], pVarVal[])
         do INNER;
         exit result
         #);
       SetHelpStringContext:<
         (# result: @int32 (* HRESULT *);
            dwHelpStringContext: @int32u (* ULONG *); 
         enter dwHelpStringContext
         do INNER;
         exit result
         #);
       SetFuncHelpStringContext:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            dwHelpStringContext: @int32u (* ULONG *); 
         enter (index, dwHelpStringContext)
         do INNER;
         exit result
         #);
       SetVarHelpStringContext:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            dwHelpStringContext: @int32u (* ULONG *); 
         enter (index, dwHelpStringContext)
         do INNER;
         exit result
         #);
       Invalidate:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       SetName:<
         (# result: @int32 (* HRESULT *);
            szName: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
         enter szName
         do INNER;
         exit result
         #);
    #);

  ICreateTypeLib_IID: (# exit '00020406-0000-0000-C000-000000000046' #);

  ICreateTypeLib: IUnknown
    (# <<SLOT ICreateTypeLibLib: attributes>>;
       CreateTypeInfo:<
         (# result: @int32 (* HRESULT *);
            szName: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
            tkind: @int32 (* TYPEKIND *); 
            ppCTInfo: ^ICreateTypeInfoHolder (* ICreateTypeInfo** *); 
         enter (szName, tkind, ppCTInfo[])
         do INNER;
         exit result
         #);
       SetName:<
         (# result: @int32 (* HRESULT *);
            szName: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
         enter szName
         do INNER;
         exit result
         #);
       SetVersion:<
         (# result: @int32 (* HRESULT *);
            wMajorVerNum: @int16u (* WORD *); 
            wMinorVerNum: @int16u (* WORD *); 
         enter (wMajorVerNum, wMinorVerNum)
         do INNER;
         exit result
         #);
       SetGuid:<
         (# result: @int32 (* HRESULT *);
            _guid: ^GUIDdata (* REFGUID* *); 
         enter _guid[]
         do INNER;
         exit result
         #);
       SetDocString:<
         (# result: @int32 (* HRESULT *);
            szDoc: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
         enter szDoc
         do INNER;
         exit result
         #);
       SetHelpFileName:<
         (# result: @int32 (* HRESULT *);
            szHelpFileName: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
         enter szHelpFileName
         do INNER;
         exit result
         #);
       SetHelpContext:<
         (# result: @int32 (* HRESULT *);
            dwHelpContext: @int32u (* DWORD *); 
         enter dwHelpContext
         do INNER;
         exit result
         #);
       SetLcid:<
         (# result: @int32 (* HRESULT *);
            _lcid: @int32u (* LCID *); 
         enter _lcid
         do INNER;
         exit result
         #);
       SetLibFlags:<
         (# result: @int32 (* HRESULT *);
            uLibFlags: @int32u (* UINT *); 
         enter uLibFlags
         do INNER;
         exit result
         #);
       SaveAllChanges:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
    #);

  ICreateTypeLib2_IID: (# exit '0002040F-0000-0000-C000-000000000046' #);

  ICreateTypeLib2: ICreateTypeLib
    (# <<SLOT ICreateTypeLib2Lib: attributes>>;
       DeleteTypeInfo:<
         (# result: @int32 (* HRESULT *);
            szName: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
         enter szName
         do INNER;
         exit result
         #);
       SetCustData:<
         (# result: @int32 (* HRESULT *);
            _guid: ^GUIDdata (* REFGUID* *); 
            pVarVal: ^VARIANT (* VARIANT* *); 
         enter (_guid[], pVarVal[])
         do INNER;
         exit result
         #);
       SetHelpStringContext:<
         (# result: @int32 (* HRESULT *);
            dwHelpStringContext: @int32u (* ULONG *); 
         enter dwHelpStringContext
         do INNER;
         exit result
         #);
       SetHelpStringDll:<
         (# result: @int32 (* HRESULT *);
            szFileName: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
         enter szFileName
         do INNER;
         exit result
         #);
    #);

  IDispatch_IID: (# exit '00020400-0000-0000-C000-000000000046' #);

  IDispatch: IUnknown
    (# <<SLOT IDispatchLib: attributes>>;
       GetTypeInfoCount:<
         (# result: @int32 (* HRESULT *);
            pctinfo: ^int32uHolder (* UINT* *); 
         enter pctinfo[]
         do INNER;
         exit result
         #);
       GetTypeInfo:<
         (# result: @int32 (* HRESULT *);
            iTInfo: @int32u (* UINT *); 
            _lcid: @int32u (* LCID *); 
            ppTInfo: ^ITypeInfoHolder (* ITypeInfo** *); 
         enter (iTInfo, _lcid, ppTInfo[])
         do INNER;
         exit result
         #);
       GetIDsOfNames:<
         (# result: @int32 (* HRESULT *);
            riid: ^GUIDdata (* REFIID* *); 
            rgszNames: @int32 (* (Build argument string array in ExternalRecord) *) (* LPOLESTR** *); 
            cNames: @int32u (* UINT *); 
            _lcid: @int32u (* LCID *); 
            rgDispId: @int32 (* (Allocate return structure in ExternalRecord) *) (* DISPID* *); 
         enter (riid[], rgszNames, cNames, _lcid, rgDispId)
         do INNER;
         exit result
         #);
       Invoke:<
         (# result: @int32 (* HRESULT *);
            dispIdMember: @int32 (* DISPID *); 
            riid: ^GUIDdata (* REFIID* *); 
            _lcid: @int32u (* LCID *); 
            wFlags: @int16u (* WORD *); 
            pDispParams: ^struct_tagDISPPARAMS (* DISPPARAMS* *); 
            pVarResult: ^VARIANT (* VARIANT* *); 
            pExcepInfo: ^struct_tagEXCEPINFO (* EXCEPINFO* *); 
            puArgErr: ^int32uHolder (* UINT* *); 
         enter (dispIdMember, riid[], _lcid, wFlags, pDispParams[], pVarResult[], pExcepInfo[], puArgErr[])
         do INNER;
         exit result
         #);
       RemoteInvoke: (* call_as(Invoke) *)
         (# result: @int32 (* HRESULT *);
            dispIdMember: @int32 (* DISPID *); 
            riid: ^GUIDdata (* REFIID* *); 
            _lcid: @int32u (* LCID *); 
            dwFlags: @int32u (* DWORD *); 
            pDispParams: ^struct_tagDISPPARAMS (* DISPPARAMS* *); 
            pVarResult: ^VARIANT (* VARIANT* *); 
            pExcepInfo: ^struct_tagEXCEPINFO (* EXCEPINFO* *); 
            pArgErr: ^int32uHolder (* UINT* *); 
            cVarRef: @int32u (* UINT *); 
            rgVarRefIdx: @int32 (* (Build argument structure in ExternalRecord) *) (* UINT* *); 
            rgVarRef: ^VARIANT (* VARIANTARG* *); 
         enter (dispIdMember, riid[], _lcid, dwFlags, pDispParams[], pVarResult[], pExcepInfo[], pArgErr[], cVarRef, rgVarRefIdx, rgVarRef[])
         do INNER;
         exit result
         #);
         (* /* DISPID reserved to indicate an \"unknown\" name */ *)
         (* /* only reserved for data members (properties); reused as a method dispid below */ *)
         (* /* DISPID reserved for the \"value\" property */ *)
         (* /* The following DISPID is reserved to indicate the param *)
         (*  * that is the right-hand-side (or \"put\" value) of a PropertyPut *)
         (*  */ *)
         (* /* DISPID reserved for the standard \"NewEnum\" method */ *)
         (* /* DISPID reserved for the standard \"Evaluate\" method */ *)
         (* /* The range -500 through -999 is reserved for Controls */ *)
         (* /* The range 0x80010000 through 0x8001FFFF is reserved for Controls */ *)
         (* /* The range -5000 through -5499 is reserved for ActiveX Accessability */ *)
         (* /* The range -2000 through -2499 is reserved for VB5 */ *)
         (* /* The range -3900 through -3999 is reserved for Forms */ *)
         (* /* The range -5500 through -5550 is reserved for Forms */ *)
         (* /* The remainder of the negative DISPIDs are reserved for future use */ *)
    #);
  DISPID_UNKNOWN: (# exit -1 #);
  DISPID_VALUE: (# exit 0 #);
  DISPID_PROPERTYPUT: (# exit -3 #);
  DISPID_NEWENUM: (# exit -4 #);
  DISPID_EVALUATE: (# exit -5 #);
  DISPID_CONSTRUCTOR: (# exit -6 #);
  DISPID_DESTRUCTOR: (# exit -7 #);
  DISPID_COLLECT: (# exit -8 #);

  IEnumVARIANT_IID: (# exit '00020404-0000-0000-C000-000000000046' #);

  IEnumVARIANT: IUnknown
    (# <<SLOT IEnumVARIANTLib: attributes>>;
       Next:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgVar: ^VARIANT (* VARIANT* *); 
            pCeltFetched: ^int32uHolder (* ULONG* *); 
         enter (celt, rgVar[], pCeltFetched[])
         do INNER;
         exit result
         #);
       RemoteNext: (* call_as(Next) *)
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgVar: ^VARIANT (* VARIANT* *); 
            pCeltFetched: ^int32uHolder (* ULONG* *); 
         enter (celt, rgVar[], pCeltFetched[])
         do INNER;
         exit result
         #);
       Skip:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
         enter celt
         do INNER;
         exit result
         #);
       Reset:<
         (# result: @int32 (* HRESULT *);
         do INNER;
         exit result
         #);
       Clone:<
         (# result: @int32 (* HRESULT *);
            ppEnum: ^IEnumVARIANTHolder (* IEnumVARIANT** *); 
         enter ppEnum[]
         do INNER;
         exit result
         #);
    #);

  ITypeComp_IID: (# exit '00020403-0000-0000-C000-000000000046' #);

  ITypeComp: IUnknown
    (# <<SLOT ITypeCompLib: attributes>>;
       Bind:<
         (# result: @int32 (* HRESULT *);
            szName: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
            lHashVal: @int32u (* ULONG *); 
            wFlags: @int16u (* WORD *); 
            ppTInfo: ^ITypeInfoHolder (* ITypeInfo** *); 
            pDescKind: ^int32Holder (* DESCKIND* *); 
            pBindPtr: ^union_tagBINDPTR (* BINDPTR* *); 
         enter (szName, lHashVal, wFlags, ppTInfo[], pDescKind[], pBindPtr[])
         do INNER;
         exit result
         #);
       RemoteBind: (* call_as(Bind) *)
         (# result: @int32 (* HRESULT *);
            szName: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
            lHashVal: @int32u (* ULONG *); 
            wFlags: @int16u (* WORD *); 
            ppTInfo: ^ITypeInfoHolder (* ITypeInfo** *); 
            pDescKind: ^int32Holder (* DESCKIND* *); 
            ppFuncDesc: ^struct_tagFUNCDESCHolder (* LPFUNCDESC** *); 
            ppVarDesc: ^struct_tagVARDESCHolder (* LPVARDESC** *); 
            ppTypeComp: ^ITypeCompHolder (* ITypeComp** *); 
            pDummy: ^struct_tagCLEANLOCALSTORAGE (* CLEANLOCALSTORAGE* *); 
         enter (szName, lHashVal, wFlags, ppTInfo[], pDescKind[], ppFuncDesc[], ppVarDesc[], ppTypeComp[], pDummy[])
         do INNER;
         exit result
         #);
       BindType:<
         (# result: @int32 (* HRESULT *);
            szName: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
            lHashVal: @int32u (* ULONG *); 
            ppTInfo: ^ITypeInfoHolder (* ITypeInfo** *); 
            ppTComp: ^ITypeCompHolder (* ITypeComp** *); 
         enter (szName, lHashVal, ppTInfo[], ppTComp[])
         do INNER;
         exit result
         #);
       RemoteBindType: (* call_as(BindType) *)
         (# result: @int32 (* HRESULT *);
            szName: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
            lHashVal: @int32u (* ULONG *); 
            ppTInfo: ^ITypeInfoHolder (* ITypeInfo** *); 
         enter (szName, lHashVal, ppTInfo[])
         do INNER;
         exit result
         #);
    #);
  enum_DESCKIND: IntegerObject(# (* enum tagDESCKIND *) #);
  DESCKIND_NONE: (* DESCKIND *)(# exit 0 #);
  DESCKIND_FUNCDESC: (* DESCKIND *)(# exit DESCKIND_NONE+1 #);
  DESCKIND_VARDESC: (* DESCKIND *)(# exit DESCKIND_FUNCDESC+1 #);
  DESCKIND_TYPECOMP: (* DESCKIND *)(# exit DESCKIND_VARDESC+1 #);
  DESCKIND_IMPLICITAPPOBJ: (* DESCKIND *)(# exit DESCKIND_TYPECOMP+1 #);
  DESCKIND_MAX: (* DESCKIND *)(# exit DESCKIND_IMPLICITAPPOBJ+1 #);

  BINDPTR: union_tagBINDPTR(# #);
  union_tagBINDPTR: holder
    (# 
       (* 
        * union types are not translated.
        * You must do it by hand, sorry!
        *)
    #);

  ITypeInfo_IID: (# exit '00020401-0000-0000-C000-000000000046' #);

  ITypeInfo: IUnknown
    (# <<SLOT ITypeInfoLib: attributes>>;
       GetTypeAttr:<
         (# result: @int32 (* HRESULT *);
            ppTypeAttr: ^struct_tagTYPEATTRHolder (* TYPEATTR** *); 
         enter ppTypeAttr[]
         do INNER;
         exit result
         #);
       RemoteGetTypeAttr: (* call_as(GetTypeAttr) *)
         (# result: @int32 (* HRESULT *);
            ppTypeAttr: ^struct_tagTYPEATTRHolder (* LPTYPEATTR** *); 
            pDummy: ^struct_tagCLEANLOCALSTORAGE (* CLEANLOCALSTORAGE* *); 
         enter (ppTypeAttr[], pDummy[])
         do INNER;
         exit result
         #);
       GetTypeComp:<
         (# result: @int32 (* HRESULT *);
            ppTComp: ^ITypeCompHolder (* ITypeComp** *); 
         enter ppTComp[]
         do INNER;
         exit result
         #);
       GetFuncDesc:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            ppFuncDesc: ^struct_tagFUNCDESCHolder (* FUNCDESC** *); 
         enter (index, ppFuncDesc[])
         do INNER;
         exit result
         #);
       RemoteGetFuncDesc: (* call_as(GetFuncDesc) *)
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            ppFuncDesc: ^struct_tagFUNCDESCHolder (* LPFUNCDESC** *); 
            pDummy: ^struct_tagCLEANLOCALSTORAGE (* CLEANLOCALSTORAGE* *); 
         enter (index, ppFuncDesc[], pDummy[])
         do INNER;
         exit result
         #);
       GetVarDesc:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            ppVarDesc: ^struct_tagVARDESCHolder (* VARDESC** *); 
         enter (index, ppVarDesc[])
         do INNER;
         exit result
         #);
       RemoteGetVarDesc: (* call_as(GetVarDesc) *)
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            ppVarDesc: ^struct_tagVARDESCHolder (* LPVARDESC** *); 
            pDummy: ^struct_tagCLEANLOCALSTORAGE (* CLEANLOCALSTORAGE* *); 
         enter (index, ppVarDesc[], pDummy[])
         do INNER;
         exit result
         #);
       GetNames:<
         (# result: @int32 (* HRESULT *);
            memid: @int32 (* MEMBERID *); 
            rgBstrNames: @int32 (* (Allocate return structure in ExternalRecord) *) (* BSTR* *); 
            cMaxNames: @int32u (* UINT *); 
            pcNames: ^int32uHolder (* UINT* *); 
         enter (memid, rgBstrNames, cMaxNames, pcNames[])
         do INNER;
         exit result
         #);
       RemoteGetNames: (* call_as(GetNames) *)
         (# result: @int32 (* HRESULT *);
            memid: @int32 (* MEMBERID *); 
            rgBstrNames: @int32 (* (Allocate return structure in ExternalRecord) *) (* BSTR* *); 
            cMaxNames: @int32u (* UINT *); 
            pcNames: ^int32uHolder (* UINT* *); 
         enter (memid, rgBstrNames, cMaxNames, pcNames[])
         do INNER;
         exit result
         #);
       GetRefTypeOfImplType:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            pRefType: ^int32uHolder (* HREFTYPE* *); 
         enter (index, pRefType[])
         do INNER;
         exit result
         #);
       GetImplTypeFlags:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            pImplTypeFlags: ^int32Holder (* INT* *); 
         enter (index, pImplTypeFlags[])
         do INNER;
         exit result
         #);
       GetIDsOfNames:<
         (# result: @int32 (* HRESULT *);
            rgszNames: @int32 (* (Build argument string array in ExternalRecord) *) (* LPOLESTR** *); 
            cNames: @int32u (* UINT *); 
            pMemId: @int32 (* (Allocate return structure in ExternalRecord) *) (* MEMBERID* *); 
         enter (rgszNames, cNames, pMemId)
         do INNER;
         exit result
         #);
       LocalGetIDsOfNames: (* call_as(GetIDsOfNames) *)
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       Invoke:<
         (# result: @int32 (* HRESULT *);
            pvInstance: @int32 (* PVOID* *); 
            memid: @int32 (* MEMBERID *); 
            wFlags: @int16u (* WORD *); 
            pDispParams: ^struct_tagDISPPARAMS (* DISPPARAMS* *); 
            pVarResult: ^VARIANT (* VARIANT* *); 
            pExcepInfo: ^struct_tagEXCEPINFO (* EXCEPINFO* *); 
            puArgErr: ^int32uHolder (* UINT* *); 
         enter (pvInstance, memid, wFlags, pDispParams[], pVarResult[], pExcepInfo[], puArgErr[])
         do INNER;
         exit result
         #);
       LocalInvoke: (* call_as(Invoke) *)
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       GetDocumentation:<
         (# result: @int32 (* HRESULT *);
            memid: @int32 (* MEMBERID *); 
            pBstrName: ^int32Holder (* BSTR* *); 
            pBstrDocString: ^int32Holder (* BSTR* *); 
            pdwHelpContext: ^int32uHolder (* DWORD* *); 
            pBstrHelpFile: ^int32Holder (* BSTR* *); 
         enter (memid, pBstrName[], pBstrDocString[], pdwHelpContext[], pBstrHelpFile[])
         do INNER;
         exit result
         #);
       RemoteGetDocumentation: (* call_as(GetDocumentation) *)
         (# result: @int32 (* HRESULT *);
            memid: @int32 (* MEMBERID *); 
            refPtrFlags: @int32u (* DWORD *); 
            pBstrName: ^int32Holder (* BSTR* *); 
            pBstrDocString: ^int32Holder (* BSTR* *); 
            pdwHelpContext: ^int32uHolder (* DWORD* *); 
            pBstrHelpFile: ^int32Holder (* BSTR* *); 
         enter (memid, refPtrFlags, pBstrName[], pBstrDocString[], pdwHelpContext[], pBstrHelpFile[])
         do INNER;
         exit result
         #);
       GetDllEntry:<
         (# result: @int32 (* HRESULT *);
            memid: @int32 (* MEMBERID *); 
            invKind: @int32 (* INVOKEKIND *); 
            pBstrDllName: ^int32Holder (* BSTR* *); 
            pBstrName: ^int32Holder (* BSTR* *); 
            pwOrdinal: ^int16uHolder (* WORD* *); 
         enter (memid, invKind, pBstrDllName[], pBstrName[], pwOrdinal[])
         do INNER;
         exit result
         #);
       RemoteGetDllEntry: (* call_as(GetDllEntry) *)
         (# result: @int32 (* HRESULT *);
            memid: @int32 (* MEMBERID *); 
            invKind: @int32 (* INVOKEKIND *); 
            refPtrFlags: @int32u (* DWORD *); 
            pBstrDllName: ^int32Holder (* BSTR* *); 
            pBstrName: ^int32Holder (* BSTR* *); 
            pwOrdinal: ^int16uHolder (* WORD* *); 
         enter (memid, invKind, refPtrFlags, pBstrDllName[], pBstrName[], pwOrdinal[])
         do INNER;
         exit result
         #);
       GetRefTypeInfo:<
         (# result: @int32 (* HRESULT *);
            _hRefType: @int32u (* HREFTYPE *); 
            ppTInfo: ^ITypeInfoHolder (* ITypeInfo** *); 
         enter (_hRefType, ppTInfo[])
         do INNER;
         exit result
         #);
       AddressOfMember:<
         (# result: @int32 (* HRESULT *);
            memid: @int32 (* MEMBERID *); 
            invKind: @int32 (* INVOKEKIND *); 
            ppv: ^int32Holder (* PVOID** *); 
         enter (memid, invKind, ppv[])
         do INNER;
         exit result
         #);
       LocalAddressOfMember: (* call_as(AddressOfMember) *)
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       CreateInstance:<
         (# result: @int32 (* HRESULT *);
            pUnkOuter: ^IUnknown (* IUnknown* *); 
            riid: ^GUIDdata (* REFIID* *); 
            ppvObj: ^int32Holder (* PVOID** *); 
         enter (pUnkOuter[], riid[], ppvObj[])
         do INNER;
         exit result
         #);
       RemoteCreateInstance: (* call_as(CreateInstance) *)
         (# result: @int32 (* HRESULT *);
            riid: ^GUIDdata (* REFIID* *); 
            ppvObj: ^IUnknownHolder (* IUnknown** *); 
         enter (riid[], ppvObj[])
         do INNER;
         exit result
         #);
       GetMops:<
         (# result: @int32 (* HRESULT *);
            memid: @int32 (* MEMBERID *); 
            pBstrMops: ^int32Holder (* BSTR* *); 
         enter (memid, pBstrMops[])
         do INNER;
         exit result
         #);
       GetContainingTypeLib:<
         (# result: @int32 (* HRESULT *);
            ppTLib: ^ITypeLibHolder (* ITypeLib** *); 
            pIndex: ^int32uHolder (* UINT* *); 
         enter (ppTLib[], pIndex[])
         do INNER;
         exit result
         #);
       RemoteGetContainingTypeLib: (* call_as(GetContainingTypeLib) *)
         (# result: @int32 (* HRESULT *);
            ppTLib: ^ITypeLibHolder (* ITypeLib** *); 
            pIndex: ^int32uHolder (* UINT* *); 
         enter (ppTLib[], pIndex[])
         do INNER;
         exit result
         #);
       ReleaseTypeAttr:<
         (# (* No result *)
            pTypeAttr: ^struct_tagTYPEATTR (* TYPEATTR* *); 
         enter pTypeAttr[]
         do INNER;
         #);
       LocalReleaseTypeAttr: (* call_as(ReleaseTypeAttr) *)
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       ReleaseFuncDesc:<
         (# (* No result *)
            pFuncDesc: ^struct_tagFUNCDESC (* FUNCDESC* *); 
         enter pFuncDesc[]
         do INNER;
         #);
       LocalReleaseFuncDesc: (* call_as(ReleaseFuncDesc) *)
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       ReleaseVarDesc:<
         (# (* No result *)
            pVarDesc: ^struct_tagVARDESC (* VARDESC* *); 
         enter pVarDesc[]
         do INNER;
         #);
       LocalReleaseVarDesc: (* call_as(ReleaseVarDesc) *)
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
    #);

  ITypeInfo2_IID: (# exit '00020412-0000-0000-C000-000000000046' #);

  ITypeInfo2: ITypeInfo
    (# <<SLOT ITypeInfo2Lib: attributes>>;
       GetTypeKind:<
         (# result: @int32 (* HRESULT *);
            pTypeKind: ^int32Holder (* TYPEKIND* *); 
         enter pTypeKind[]
         do INNER;
         exit result
         #);
       GetTypeFlags:<
         (# result: @int32 (* HRESULT *);
            pTypeFlags: ^int32uHolder (* ULONG* *); 
         enter pTypeFlags[]
         do INNER;
         exit result
         #);
       GetFuncIndexOfMemId:<
         (# result: @int32 (* HRESULT *);
            memid: @int32 (* MEMBERID *); 
            invKind: @int32 (* INVOKEKIND *); 
            pFuncIndex: ^int32uHolder (* UINT* *); 
         enter (memid, invKind, pFuncIndex[])
         do INNER;
         exit result
         #);
       GetVarIndexOfMemId:<
         (# result: @int32 (* HRESULT *);
            memid: @int32 (* MEMBERID *); 
            pVarIndex: ^int32uHolder (* UINT* *); 
         enter (memid, pVarIndex[])
         do INNER;
         exit result
         #);
       GetCustData:<
         (# result: @int32 (* HRESULT *);
            _guid: ^GUIDdata (* REFGUID* *); 
            pVarVal: ^VARIANT (* VARIANT* *); 
         enter (_guid[], pVarVal[])
         do INNER;
         exit result
         #);
       GetFuncCustData:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            _guid: ^GUIDdata (* REFGUID* *); 
            pVarVal: ^VARIANT (* VARIANT* *); 
         enter (index, _guid[], pVarVal[])
         do INNER;
         exit result
         #);
       GetParamCustData:<
         (# result: @int32 (* HRESULT *);
            indexFunc: @int32u (* UINT *); 
            indexParam: @int32u (* UINT *); 
            _guid: ^GUIDdata (* REFGUID* *); 
            pVarVal: ^VARIANT (* VARIANT* *); 
         enter (indexFunc, indexParam, _guid[], pVarVal[])
         do INNER;
         exit result
         #);
       GetVarCustData:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            _guid: ^GUIDdata (* REFGUID* *); 
            pVarVal: ^VARIANT (* VARIANT* *); 
         enter (index, _guid[], pVarVal[])
         do INNER;
         exit result
         #);
       GetImplTypeCustData:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            _guid: ^GUIDdata (* REFGUID* *); 
            pVarVal: ^VARIANT (* VARIANT* *); 
         enter (index, _guid[], pVarVal[])
         do INNER;
         exit result
         #);
       GetDocumentation2:<
         (# result: @int32 (* HRESULT *);
            memid: @int32 (* MEMBERID *); 
            _lcid: @int32u (* LCID *); 
            pbstrHelpString: ^int32Holder (* BSTR* *); 
            pdwHelpStringContext: ^int32uHolder (* DWORD* *); 
            pbstrHelpStringDll: ^int32Holder (* BSTR* *); 
         enter (memid, _lcid, pbstrHelpString[], pdwHelpStringContext[], pbstrHelpStringDll[])
         do INNER;
         exit result
         #);
       RemoteGetDocumentation2: (* call_as(GetDocumentation2) *)
         (# result: @int32 (* HRESULT *);
            memid: @int32 (* MEMBERID *); 
            _lcid: @int32u (* LCID *); 
            refPtrFlags: @int32u (* DWORD *); 
            pbstrHelpString: ^int32Holder (* BSTR* *); 
            pdwHelpStringContext: ^int32uHolder (* DWORD* *); 
            pbstrHelpStringDll: ^int32Holder (* BSTR* *); 
         enter (memid, _lcid, refPtrFlags, pbstrHelpString[], pdwHelpStringContext[], pbstrHelpStringDll[])
         do INNER;
         exit result
         #);
       GetAllCustData:<
         (# result: @int32 (* HRESULT *);
            pCustData: ^struct_tagCUSTDATA (* CUSTDATA* *); 
         enter pCustData[]
         do INNER;
         exit result
         #);
       GetAllFuncCustData:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            pCustData: ^struct_tagCUSTDATA (* CUSTDATA* *); 
         enter (index, pCustData[])
         do INNER;
         exit result
         #);
       GetAllParamCustData:<
         (# result: @int32 (* HRESULT *);
            indexFunc: @int32u (* UINT *); 
            indexParam: @int32u (* UINT *); 
            pCustData: ^struct_tagCUSTDATA (* CUSTDATA* *); 
         enter (indexFunc, indexParam, pCustData[])
         do INNER;
         exit result
         #);
       GetAllVarCustData:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            pCustData: ^struct_tagCUSTDATA (* CUSTDATA* *); 
         enter (index, pCustData[])
         do INNER;
         exit result
         #);
       GetAllImplTypeCustData:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            pCustData: ^struct_tagCUSTDATA (* CUSTDATA* *); 
         enter (index, pCustData[])
         do INNER;
         exit result
         #);
    #);

  ITypeLib_IID: (# exit '00020402-0000-0000-C000-000000000046' #);

  ITypeLib: IUnknown
    (# <<SLOT ITypeLibLib: attributes>>;
       GetTypeInfoCount:<
         (# result: @int32u (* UINT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       RemoteGetTypeInfoCount: (* call_as(GetTypeInfoCount) *)
         (# result: @int32 (* HRESULT *);
            pcTInfo: ^int32uHolder (* UINT* *); 
         enter pcTInfo[]
         do INNER;
         exit result
         #);
       GetTypeInfo:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            ppTInfo: ^ITypeInfoHolder (* ITypeInfo** *); 
         enter (index, ppTInfo[])
         do INNER;
         exit result
         #);
       GetTypeInfoType:<
         (# result: @int32 (* HRESULT *);
            index: @int32u (* UINT *); 
            pTKind: ^int32Holder (* TYPEKIND* *); 
         enter (index, pTKind[])
         do INNER;
         exit result
         #);
       GetTypeInfoOfGuid:<
         (# result: @int32 (* HRESULT *);
            _guid: ^GUIDdata (* REFGUID* *); 
            ppTinfo: ^ITypeInfoHolder (* ITypeInfo** *); 
         enter (_guid[], ppTinfo[])
         do INNER;
         exit result
         #);
       GetLibAttr:<
         (# result: @int32 (* HRESULT *);
            ppTLibAttr: ^struct_tagTLIBATTRHolder (* TLIBATTR** *); 
         enter ppTLibAttr[]
         do INNER;
         exit result
         #);
       RemoteGetLibAttr: (* call_as(GetLibAttr) *)
         (# result: @int32 (* HRESULT *);
            ppTLibAttr: ^struct_tagTLIBATTRHolder (* LPTLIBATTR** *); 
            pDummy: ^struct_tagCLEANLOCALSTORAGE (* CLEANLOCALSTORAGE* *); 
         enter (ppTLibAttr[], pDummy[])
         do INNER;
         exit result
         #);
       GetTypeComp:<
         (# result: @int32 (* HRESULT *);
            ppTComp: ^ITypeCompHolder (* ITypeComp** *); 
         enter ppTComp[]
         do INNER;
         exit result
         #);
       GetDocumentation:<
         (# result: @int32 (* HRESULT *);
            index: @int32 (* INT *); 
            pBstrName: ^int32Holder (* BSTR* *); 
            pBstrDocString: ^int32Holder (* BSTR* *); 
            pdwHelpContext: ^int32uHolder (* DWORD* *); 
            pBstrHelpFile: ^int32Holder (* BSTR* *); 
         enter (index, pBstrName[], pBstrDocString[], pdwHelpContext[], pBstrHelpFile[])
         do INNER;
         exit result
         #);
       RemoteGetDocumentation: (* call_as(GetDocumentation) *)
         (# result: @int32 (* HRESULT *);
            index: @int32 (* INT *); 
            refPtrFlags: @int32u (* DWORD *); 
            pBstrName: ^int32Holder (* BSTR* *); 
            pBstrDocString: ^int32Holder (* BSTR* *); 
            pdwHelpContext: ^int32uHolder (* DWORD* *); 
            pBstrHelpFile: ^int32Holder (* BSTR* *); 
         enter (index, refPtrFlags, pBstrName[], pBstrDocString[], pdwHelpContext[], pBstrHelpFile[])
         do INNER;
         exit result
         #);
       IsName:<
         (# result: @int32 (* HRESULT *);
            szNameBuf: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
            lHashVal: @int32u (* ULONG *); 
            pfName: ^int32Holder (* BOOL* *); 
         enter (szNameBuf, lHashVal, pfName[])
         do INNER;
         exit result
         #);
       RemoteIsName: (* call_as(IsName) *)
         (# result: @int32 (* HRESULT *);
            szNameBuf: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
            lHashVal: @int32u (* ULONG *); 
            pfName: ^int32Holder (* BOOL* *); 
            pBstrLibName: ^int32Holder (* BSTR* *); 
         enter (szNameBuf, lHashVal, pfName[], pBstrLibName[])
         do INNER;
         exit result
         #);
       FindName:<
         (# result: @int32 (* HRESULT *);
            szNameBuf: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
            lHashVal: @int32u (* ULONG *); 
            ppTInfo: ^ITypeInfoHolder (* ITypeInfo** *); 
            rgMemId: @int32 (* (Allocate return structure in ExternalRecord) *) (* MEMBERID* *); 
            pcFound: ^int16uHolder (* USHORT* *); 
         enter (szNameBuf, lHashVal, ppTInfo[], rgMemId, pcFound[])
         do INNER;
         exit result
         #);
       RemoteFindName: (* call_as(FindName) *)
         (# result: @int32 (* HRESULT *);
            szNameBuf: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
            lHashVal: @int32u (* ULONG *); 
            ppTInfo: ^ITypeInfoHolder (* ITypeInfo** *); 
            rgMemId: @int32 (* (Allocate return structure in ExternalRecord) *) (* MEMBERID* *); 
            pcFound: ^int16uHolder (* USHORT* *); 
            pBstrLibName: ^int32Holder (* BSTR* *); 
         enter (szNameBuf, lHashVal, ppTInfo[], rgMemId, pcFound[], pBstrLibName[])
         do INNER;
         exit result
         #);
       ReleaseTLibAttr:<
         (# (* No result *)
            pTLibAttr: ^struct_tagTLIBATTR (* TLIBATTR* *); 
         enter pTLibAttr[]
         do INNER;
         #);
       LocalReleaseTLibAttr: (* call_as(ReleaseTLibAttr) *)
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
    #);
  enum_SYSKIND: IntegerObject(# (* enum tagSYSKIND *) #);
  SYS_WIN16: (* SYSKIND *)(# exit 0 #);
  SYS_WIN32: (* SYSKIND *)(# exit SYS_WIN16+1 #);
  SYS_MAC: (* SYSKIND *)(# exit SYS_WIN32+1 #);

  enum_LIBFLAGS: IntegerObject(# (* enum tagLIBFLAGS *) #);
  LIBFLAG_FRESTRICTED: (* LIBFLAGS *)(# exit 0x01 #);
  LIBFLAG_FCONTROL: (* LIBFLAGS *)(# exit 0x02 #);
  LIBFLAG_FHIDDEN: (* LIBFLAGS *)(# exit 0x04 #);
  LIBFLAG_FHASDISKIMAGE: (* LIBFLAGS *)(# exit 0x08 #);

  TLIBATTR: struct_tagTLIBATTR(# #);
  struct_tagTLIBATTR: DATA
    (# _guid: @GUIDdata (* GUID *);
       lcid: @int32u (* LCID *);
       syskind: @int32 (* SYSKIND *);
       wMajorVerNum: @int16u (* WORD *);
       wMinorVerNum: @int16u (* WORD *);
       wLibFlags: @int16u (* WORD *);
    #);

  ITypeLib2_IID: (# exit '00020411-0000-0000-C000-000000000046' #);

  ITypeLib2: ITypeLib
    (# <<SLOT ITypeLib2Lib: attributes>>;
       GetCustData:<
         (# result: @int32 (* HRESULT *);
            _guid: ^GUIDdata (* REFGUID* *); 
            pVarVal: ^VARIANT (* VARIANT* *); 
         enter (_guid[], pVarVal[])
         do INNER;
         exit result
         #);
       GetLibStatistics:<
         (# result: @int32 (* HRESULT *);
            pcUniqueNames: ^int32uHolder (* ULONG* *); 
            pcchUniqueNames: ^int32uHolder (* ULONG* *); 
         enter (pcUniqueNames[], pcchUniqueNames[])
         do INNER;
         exit result
         #);
       RemoteGetLibStatistics: (* call_as(GetLibStatistics) *)
         (# result: @int32 (* HRESULT *);
            pcUniqueNames: ^int32uHolder (* ULONG* *); 
            pcchUniqueNames: ^int32uHolder (* ULONG* *); 
         enter (pcUniqueNames[], pcchUniqueNames[])
         do INNER;
         exit result
         #);
       GetDocumentation2:<
         (# result: @int32 (* HRESULT *);
            index: @int32 (* INT *); 
            _lcid: @int32u (* LCID *); 
            pbstrHelpString: ^int32Holder (* BSTR* *); 
            pdwHelpStringContext: ^int32uHolder (* DWORD* *); 
            pbstrHelpStringDll: ^int32Holder (* BSTR* *); 
         enter (index, _lcid, pbstrHelpString[], pdwHelpStringContext[], pbstrHelpStringDll[])
         do INNER;
         exit result
         #);
       RemoteGetDocumentation2: (* call_as(GetDocumentation2) *)
         (# result: @int32 (* HRESULT *);
            index: @int32 (* INT *); 
            _lcid: @int32u (* LCID *); 
            refPtrFlags: @int32u (* DWORD *); 
            pbstrHelpString: ^int32Holder (* BSTR* *); 
            pdwHelpStringContext: ^int32uHolder (* DWORD* *); 
            pbstrHelpStringDll: ^int32Holder (* BSTR* *); 
         enter (index, _lcid, refPtrFlags, pbstrHelpString[], pdwHelpStringContext[], pbstrHelpStringDll[])
         do INNER;
         exit result
         #);
       GetAllCustData:<
         (# result: @int32 (* HRESULT *);
            pCustData: ^struct_tagCUSTDATA (* CUSTDATA* *); 
         enter pCustData[]
         do INNER;
         exit result
         #);
    #);

  ITypeChangeEvents_IID: (# exit '00020410-0000-0000-C000-000000000046' #);

  ITypeChangeEvents: IUnknown
    (# <<SLOT ITypeChangeEventsLib: attributes>>;
       RequestTypeChange:<
         (# result: @int32 (* HRESULT *);
            _changeKind: @int32 (* CHANGEKIND *); 
            pTInfoBefore: ^ITypeInfo (* ITypeInfo* *); 
            pStrName: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
            pfCancel: ^int32Holder (* INT* *); 
         enter (_changeKind, pTInfoBefore[], pStrName, pfCancel[])
         do INNER;
         exit result
         #);
       AfterTypeChange:<
         (# result: @int32 (* HRESULT *);
            _changeKind: @int32 (* CHANGEKIND *); 
            pTInfoAfter: ^ITypeInfo (* ITypeInfo* *); 
            pStrName: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
         enter (_changeKind, pTInfoAfter[], pStrName)
         do INNER;
         exit result
         #);
    #);
  enum_CHANGEKIND: IntegerObject(# (* enum tagCHANGEKIND *) #);
  CHANGEKIND_ADDMEMBER: (* CHANGEKIND *)(# exit 0 #);
  CHANGEKIND_DELETEMEMBER: (* CHANGEKIND *)(# exit 1 #);
  CHANGEKIND_SETNAMES: (* CHANGEKIND *)(# exit 2 #);
  CHANGEKIND_SETDOCUMENTATION: (* CHANGEKIND *)(# exit 3 #);
  CHANGEKIND_GENERAL: (* CHANGEKIND *)(# exit 4 #);
  CHANGEKIND_INVALIDATE: (* CHANGEKIND *)(# exit 5 #);
  CHANGEKIND_CHANGEFAILED: (* CHANGEKIND *)(# exit 6 #);
  CHANGEKIND_MAX: (* CHANGEKIND *)(# exit 7 #);


  IErrorInfo_IID: (# exit '1CF2B120-547D-101B-8E65-08002B2BD119' #);

  IErrorInfo: IUnknown
    (# <<SLOT IErrorInfoLib: attributes>>;
       GetGUID:<
         (# result: @int32 (* HRESULT *);
            pGUID: ^GUIDdata (* GUID* *); 
         enter pGUID[]
         do INNER;
         exit result
         #);
       GetSource:<
         (# result: @int32 (* HRESULT *);
            pBstrSource: ^int32Holder (* BSTR* *); 
         enter pBstrSource[]
         do INNER;
         exit result
         #);
       GetDescription:<
         (# result: @int32 (* HRESULT *);
            pBstrDescription: ^int32Holder (* BSTR* *); 
         enter pBstrDescription[]
         do INNER;
         exit result
         #);
       GetHelpFile:<
         (# result: @int32 (* HRESULT *);
            pBstrHelpFile: ^int32Holder (* BSTR* *); 
         enter pBstrHelpFile[]
         do INNER;
         exit result
         #);
       GetHelpContext:<
         (# result: @int32 (* HRESULT *);
            pdwHelpContext: ^int32uHolder (* DWORD* *); 
         enter pdwHelpContext[]
         do INNER;
         exit result
         #);
    #);

  ICreateErrorInfo_IID: (# exit '22F03340-547D-101B-8E65-08002B2BD119' #);

  ICreateErrorInfo: IUnknown
    (# <<SLOT ICreateErrorInfoLib: attributes>>;
       SetGUID:<
         (# result: @int32 (* HRESULT *);
            rguid: ^GUIDdata (* REFGUID* *); 
         enter rguid[]
         do INNER;
         exit result
         #);
       SetSource:<
         (# result: @int32 (* HRESULT *);
            szSource: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
         enter szSource
         do INNER;
         exit result
         #);
       SetDescription:<
         (# result: @int32 (* HRESULT *);
            szDescription: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
         enter szDescription
         do INNER;
         exit result
         #);
       SetHelpFile:<
         (# result: @int32 (* HRESULT *);
            szHelpFile: [0]@wchar (* ^wtext NYI *) (* LPOLESTR* *); 
         enter szHelpFile
         do INNER;
         exit result
         #);
       SetHelpContext:<
         (# result: @int32 (* HRESULT *);
            dwHelpContext: @int32u (* DWORD *); 
         enter dwHelpContext
         do INNER;
         exit result
         #);
    #);

  ISupportErrorInfo_IID: (# exit 'DF0B3D60-548F-101B-8E65-08002B2BD119' #);

  ISupportErrorInfo: IUnknown
    (# <<SLOT ISupportErrorInfoLib: attributes>>;
       InterfaceSupportsErrorInfo:<
         (# result: @int32 (* HRESULT *);
            riid: ^GUIDdata (* REFIID* *); 
         enter riid[]
         do INNER;
         exit result
         #);
    #);

  ITypeFactory_IID: (# exit '0000002E-0000-0000-C000-000000000046' #);

  ITypeFactory: IUnknown
    (# <<SLOT ITypeFactoryLib: attributes>>;
       CreateFromTypeInfo:<
         (# result: @int32 (* HRESULT *);
            pTypeInfo: ^ITypeInfo (* ITypeInfo* *); 
            riid: ^GUIDdata (* REFIID* *); 
            ppv: ^IUnknownHolder (* IUnknown** *); 
         enter (pTypeInfo[], riid[], ppv[])
         do INNER;
         exit result
         #);
    #);

  ITypeMarshal_IID: (# exit '0000002D-0000-0000-C000-000000000046' #);

  ITypeMarshal: IUnknown
    (# <<SLOT ITypeMarshalLib: attributes>>;
       Size:<
         (# result: @int32 (* HRESULT *);
            pvType: @int32 (* PVOID* *); 
            dwDestContext: @int32u (* DWORD *); 
            pvDestContext: @int32 (* PVOID* *); 
            _pSize: ^int32uHolder (* ULONG* *); 
         enter (pvType, dwDestContext, pvDestContext, _pSize[])
         do INNER;
         exit result
         #);
       Marshal:<
         (# result: @int32 (* HRESULT *);
            pvType: @int32 (* PVOID* *); 
            dwDestContext: @int32u (* DWORD *); 
            pvDestContext: @int32 (* PVOID* *); 
            cbBufferLength: @int32u (* ULONG *); 
            pBuffer: ^int8uHolder (* BYTE* *); 
            pcbWritten: ^int32uHolder (* ULONG* *); 
         enter (pvType, dwDestContext, pvDestContext, cbBufferLength, pBuffer[], pcbWritten[])
         do INNER;
         exit result
         #);
       Unmarshal:<
         (# result: @int32 (* HRESULT *);
            pvType: ^int32Holder (* PVOID* *); 
            dwFlags: @int32u (* DWORD *); 
            cbBufferLength: @int32u (* ULONG *); 
            pBuffer: @int32 (* BYTE* *); 
            pcbRead: ^int32uHolder (* ULONG* *); 
         enter (pvType[], dwFlags, cbBufferLength, pBuffer, pcbRead[])
         do INNER;
         exit result
         #);
       Free:<
         (# result: @int32 (* HRESULT *);
            pvType: @int32 (* PVOID* *); 
         enter pvType
         do INNER;
         exit result
         #);
    #);

  IRecordInfo_IID: (# exit '0000002F-0000-0000-C000-000000000046' #);

  IRecordInfo: IUnknown
    (# <<SLOT IRecordInfoLib: attributes>>;
       RecordInit:<
         (# result: @int32 (* HRESULT *);
            pvNew: ^int32Holder (* PVOID* *); 
         enter pvNew[]
         do INNER;
         exit result
         #);
       RecordClear:<
         (# result: @int32 (* HRESULT *);
            pvExisting: @int32 (* PVOID* *); 
         enter pvExisting
         do INNER;
         exit result
         #);
       RecordCopy:<
         (# result: @int32 (* HRESULT *);
            pvExisting: @int32 (* PVOID* *); 
            pvNew: ^int32Holder (* PVOID* *); 
         enter (pvExisting, pvNew[])
         do INNER;
         exit result
         #);
       GetGuid:<
         (# result: @int32 (* HRESULT *);
            pguid: ^GUIDdata (* GUID* *); 
         enter pguid[]
         do INNER;
         exit result
         #);
       GetName:<
         (# result: @int32 (* HRESULT *);
            pbstrName: ^int32Holder (* BSTR* *); 
         enter pbstrName[]
         do INNER;
         exit result
         #);
       GetSize:<
         (# result: @int32 (* HRESULT *);
            pcbSize: ^int32uHolder (* ULONG* *); 
         enter pcbSize[]
         do INNER;
         exit result
         #);
       GetTypeInfo:<
         (# result: @int32 (* HRESULT *);
            ppTypeInfo: ^ITypeInfoHolder (* ITypeInfo** *); 
         enter ppTypeInfo[]
         do INNER;
         exit result
         #);
       GetField:<
         (# result: @int32 (* HRESULT *);
            pvData: @int32 (* PVOID* *); 
            szFieldName: [0]@wchar (* ^wtext NYI *) (* LPCOLESTR* *); 
            pvarField: ^VARIANT (* VARIANT* *); 
         enter (pvData, szFieldName, pvarField[])
         do INNER;
         exit result
         #);
       GetFieldNoCopy:<
         (# result: @int32 (* HRESULT *);
            pvData: @int32 (* PVOID* *); 
            szFieldName: [0]@wchar (* ^wtext NYI *) (* LPCOLESTR* *); 
            pvarField: ^VARIANT (* VARIANT* *); 
            ppvDataCArray: ^int32Holder (* PVOID** *); 
         enter (pvData, szFieldName, pvarField[], ppvDataCArray[])
         do INNER;
         exit result
         #);
       PutField:<
         (# result: @int32 (* HRESULT *);
            wFlags: @int32u (* ULONG *); 
            pvData: ^int32Holder (* PVOID* *); 
            szFieldName: [0]@wchar (* ^wtext NYI *) (* LPCOLESTR* *); 
            pvarField: ^VARIANT (* VARIANT* *); 
         enter (wFlags, pvData[], szFieldName, pvarField[])
         do INNER;
         exit result
         #);
       PutFieldNoCopy:<
         (# result: @int32 (* HRESULT *);
            wFlags: @int32u (* ULONG *); 
            pvData: ^int32Holder (* PVOID* *); 
            szFieldName: [0]@wchar (* ^wtext NYI *) (* LPCOLESTR* *); 
            pvarField: ^VARIANT (* VARIANT* *); 
         enter (wFlags, pvData[], szFieldName, pvarField[])
         do INNER;
         exit result
         #);
       GetFieldNames:<
         (# result: @int32 (* HRESULT *);
            pcNames: ^int32uHolder (* ULONG* *); 
            rgBstrNames: @int32 (* (Allocate return structure in ExternalRecord) *) (* BSTR* *); 
         enter (pcNames[], rgBstrNames)
         do INNER;
         exit result
         #);
       IsMatchingType:<
         (# result: @int32 (* BOOL *);
            pRecordInfo: ^IRecordInfo (* IRecordInfo* *); 
         enter pRecordInfo[]
         do INNER;
         exit result
         #);
       RecordCreate:<
         (# result: ^int32Holder (* PVOID* *);
         do INNER;
         exit result[]
         #);
       RecordCreateCopy:<
         (# result: @int32 (* HRESULT *);
            pvSource: @int32 (* PVOID* *); 
            ppvDest: ^int32Holder (* PVOID** *); 
         enter (pvSource, ppvDest[])
         do INNER;
         exit result
         #);
       RecordDestroy:<
         (# result: @int32 (* HRESULT *);
            pvRecord: @int32 (* PVOID* *); 
         enter pvRecord
         do INNER;
         exit result
         #);
    #);
  (* #if ( _MSC_VER >= 800 ) *)
  (* #endif *)

  (* Holders *)

  SAFEARRAYBOUNDHolder: Holder
    (# value: @SAFEARRAYBOUND; #);
  struct_tagSAFEARRAYBOUNDHolder: Holder
    (# value: @struct_tagSAFEARRAYBOUND; #);
  struct__wireVARIANTHolder: Holder
    (# value: @struct__wireVARIANT; #);
  struct__wireBRECORDHolder: Holder
    (# value: @struct__wireBRECORD; #);
  SAFEARR_BSTRHolder: Holder
    (# value: @SAFEARR_BSTR; #);
  struct__wireSAFEARR_BSTRHolder: Holder
    (# value: @struct__wireSAFEARR_BSTR; #);
  SAFEARR_UNKNOWNHolder: Holder
    (# value: @SAFEARR_UNKNOWN; #);
  struct__wireSAFEARR_UNKNOWNHolder: Holder
    (# value: @struct__wireSAFEARR_UNKNOWN; #);
  SAFEARR_DISPATCHHolder: Holder
    (# value: @SAFEARR_DISPATCH; #);
  struct__wireSAFEARR_DISPATCHHolder: Holder
    (# value: @struct__wireSAFEARR_DISPATCH; #);
  SAFEARR_VARIANTHolder: Holder
    (# value: @SAFEARR_VARIANT; #);
  struct__wireSAFEARR_VARIANTHolder: Holder
    (# value: @struct__wireSAFEARR_VARIANT; #);
  SAFEARR_BRECORDHolder: Holder
    (# value: @SAFEARR_BRECORD; #);
  struct__wireSAFEARR_BRECORDHolder: Holder
    (# value: @struct__wireSAFEARR_BRECORD; #);
  SAFEARR_HAVEIIDHolder: Holder
    (# value: @SAFEARR_HAVEIID; #);
  struct__wireSAFEARR_HAVEIIDHolder: Holder
    (# value: @struct__wireSAFEARR_HAVEIID; #);
  SAFEARRAYUNIONHolder: Holder
    (# value: @SAFEARRAYUNION; #);
  union__wireSAFEARRAY_UNIONHolder: Holder
    (# value: @union__wireSAFEARRAY_UNION; #);
  struct__wireSAFEARRAYHolder: Holder
    (# value: @struct__wireSAFEARRAY; #);
  SAFEARRAYHolder: Holder
    (# value: @SAFEARRAY; #);
  struct_tagSAFEARRAYHolder: Holder
    (# value: @struct_tagSAFEARRAY; #);
  struct_tagVARIANTHolder: Holder
    (# value: @struct_tagVARIANT; #);
  TYPEDESCHolder: Holder
    (# value: @TYPEDESC; #);
  struct_tagTYPEDESCHolder: Holder
    (# value: @struct_tagTYPEDESC; #);
  ARRAYDESCHolder: Holder
    (# value: @ARRAYDESC; #);
  struct_tagARRAYDESCHolder: Holder
    (# value: @struct_tagARRAYDESC; #);
  PARAMDESCEXHolder: Holder
    (# value: @PARAMDESCEX; #);
  struct_tagPARAMDESCEXHolder: Holder
    (# value: @struct_tagPARAMDESCEX; #);
  PARAMDESCHolder: Holder
    (# value: @PARAMDESC; #);
  struct_tagPARAMDESCHolder: Holder
    (# value: @struct_tagPARAMDESC; #);
  IDLDESCHolder: Holder
    (# value: @IDLDESC; #);
  struct_tagIDLDESCHolder: Holder
    (# value: @struct_tagIDLDESC; #);
  ELEMDESCHolder: Holder
    (# value: @ELEMDESC; #);
  struct_tagELEMDESCHolder: Holder
    (# value: @struct_tagELEMDESC; #);
  TYPEATTRHolder: Holder
    (# value: @TYPEATTR; #);
  struct_tagTYPEATTRHolder: Holder
    (# value: @struct_tagTYPEATTR; #);
  DISPPARAMSHolder: Holder
    (# value: @DISPPARAMS; #);
  struct_tagDISPPARAMSHolder: Holder
    (# value: @struct_tagDISPPARAMS; #);
  EXCEPINFOHolder: Holder
    (# value: @EXCEPINFO; #);
  struct_tagEXCEPINFOHolder: Holder
    (# value: @struct_tagEXCEPINFO; #);
  FUNCDESCHolder: Holder
    (# value: @FUNCDESC; #);
  struct_tagFUNCDESCHolder: Holder
    (# value: @struct_tagFUNCDESC; #);
  VARDESCHolder: Holder
    (# value: @VARDESC; #);
  struct_tagVARDESCHolder: Holder
    (# value: @struct_tagVARDESC; #);
  CLEANLOCALSTORAGEHolder: Holder
    (# value: @CLEANLOCALSTORAGE; #);
  struct_tagCLEANLOCALSTORAGEHolder: Holder
    (# value: @struct_tagCLEANLOCALSTORAGE; #);
  CUSTDATAITEMHolder: Holder
    (# value: @CUSTDATAITEM; #);
  struct_tagCUSTDATAITEMHolder: Holder
    (# value: @struct_tagCUSTDATAITEM; #);
  CUSTDATAHolder: Holder
    (# value: @CUSTDATA; #);
  struct_tagCUSTDATAHolder: Holder
    (# value: @struct_tagCUSTDATA; #);
  BINDPTRHolder: Holder
    (# value: @BINDPTR; #);
  union_tagBINDPTRHolder: Holder
    (# value: @union_tagBINDPTR; #);
  TLIBATTRHolder: Holder
    (# value: @TLIBATTR; #);
  struct_tagTLIBATTRHolder: Holder
    (# value: @struct_tagTLIBATTR; #);


  (* Reference Holders *)

  IOleAutomationTypesHolder: refHolder
    (# type:: IOleAutomationTypes #);
  ICreateTypeInfoHolder: refHolder
    (# type:: ICreateTypeInfo #);
  ICreateTypeInfo2Holder: refHolder
    (# type:: ICreateTypeInfo2 #);
  ICreateTypeLibHolder: refHolder
    (# type:: ICreateTypeLib #);
  ICreateTypeLib2Holder: refHolder
    (# type:: ICreateTypeLib2 #);
  IDispatchHolder: refHolder
    (# type:: IDispatch #);
  IEnumVARIANTHolder: refHolder
    (# type:: IEnumVARIANT #);
  ITypeCompHolder: refHolder
    (# type:: ITypeComp #);
  ITypeInfoHolder: refHolder
    (# type:: ITypeInfo #);
  ITypeInfo2Holder: refHolder
    (# type:: ITypeInfo2 #);
  ITypeLibHolder: refHolder
    (# type:: ITypeLib #);
  ITypeLib2Holder: refHolder
    (# type:: ITypeLib2 #);
  ITypeChangeEventsHolder: refHolder
    (# type:: ITypeChangeEvents #);
  IErrorInfoHolder: refHolder
    (# type:: IErrorInfo #);
  ICreateErrorInfoHolder: refHolder
    (# type:: ICreateErrorInfo #);
  ISupportErrorInfoHolder: refHolder
    (# type:: ISupportErrorInfo #);
  ITypeFactoryHolder: refHolder
    (# type:: ITypeFactory #);
  ITypeMarshalHolder: refHolder
    (# type:: ITypeMarshal #);
  IRecordInfoHolder: refHolder
    (# type:: IRecordInfo #);

