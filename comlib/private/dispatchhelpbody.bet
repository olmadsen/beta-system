ORIGIN '../dispatchhelp';

--LIB: attributes--
debug: (# exit false #);

--DispatchParamsPrivate: MainPart--
(* Prefix COM *)
(# (* Memory-fixed part objects *)
   dParms: @DISPPARAMS (* specialization of DATA *);
   varg: @VARIANT (* specialization of DATA *);
   excep: @EXCEPINFO (* specialization of DATA *);
   
   rgvarg: @ExternalRepetition
     (# elementSize::(# do 16->value (* sizeof(VARIANT) *) #)#);
   alpszArgNames: @ExternalRepetition
     (# elementSize::(# do 4->value (* sizeof( OLECHAR* ) *)#)#);
   rgdispidNamedArgs: @ExternalRepetition
     (# elementSize::(# do 4->value (* sizeof( DISPID* ) *)#)#);
   cArgs, cNamedArgs, maxArgs, maxNamedArgs: @integer;
   
   print_rgvargs:
     (# 
     do  'DispatchParams: cArgs=' -> puttext; private.cArgs -> putint; newline;
        (for i:private.cArgs repeat
             private.rgvarg.ptr+(i-1)*16 -> putint; ': vt=' -> puttext; 
             %getLongAt(private.rgvarg.ptr+(i-1)*16) -> putint; 
             ', long3=' -> puttext; 
             %getLongAt(private.rgvarg.ptr+(i-1)*16+8) -> putint; newline;
        for);
     #);
#)

--DispatchParamsRelease: Descriptor--
(# wstr: @wstring;
do (0,0,0,0,0,0) -> private.varg;
   private.rgvarg.free;
   (for i:private.cNamedArgs repeat
        (i-1) -> private.alpszArgNames.inxget -> wstr; wstr.free;
   for);
   private.alpszArgNames.free;
   private.rgdispidNamedArgs.free;
   0 -> private.cArgs -> private.cNamedArgs -> private.maxArgs -> private.maxNamedArgs;
#)

--DispatchParamsCheck: dopart--
do (if private.cArgs+1>private.maxArgs then
       ((2*private.rgvarg.range, private.cArgs+1) -> max) -> private.maxArgs;
       private.maxArgs - private.rgvarg.range -> add;
       add -> private.rgvarg.extend;
   if);
   (if private.alpszArgNames.range=0 then
       (* Make room for member name *)
       1 -> private.alpszArgNames.new;
       1 -> private.rgdispidNamedArgs.new;
   if);
   (if (name[]<>NONE) and (private.cNamedArgs+1>private.maxNamedArgs) then
       ((2*private.alpszArgNames.range, private.cNamedArgs+1) -> max) -> private.maxNamedArgs;
       private.maxNamedArgs+1 - private.alpszArgNames.range -> add;
       add -> private.alpszArgNames.extend;
       add -> private.rgdispidNamedArgs.extend;
   if);
   INNER;

--DispatchParamsPut: descriptor--
(# wstr: @wstring;
do (* If there is a name, add it *)
   (if name[]<>NONE then
       (* First increment namecounter. Deliberately done before
        * argument is put, since arguments come from index 1 
        * (index 0 is for member name).
        *)
       private.cNamedArgs+1 -> private.cNamedArgs;
       name[] -> wstr.set;
       (wstr, private.cNamedArgs) -> private.alpszArgNames.inxPut;
   if);
   (* Specializations fill in varg in INNER *)
   INNER put;
   (private.cArgs, private.varg[]) -> private.rgvarg.inxCopy;
   private.cArgs+1 -> private.cArgs;
#)

--DispatchParamsPutDispatch: dopart--
do private.varg[]->VARIANT_init
   (# 
   do VT_DISPATCH -> vt;
      value[] -> pdispVal;
   #);


--DispatchParamsPutInt16: dopart--
do private.varg[]->VARIANT_init
   (# 
   do VT_I2 -> vt;
      value -> iVal;
   #);
   
   
--DispatchParamsPutBoolean: dopart--
do private.varg[]->VARIANT_init
   (# 
   do VT_BOOL -> vt;
      (if value then
          VARIANT_TRUE -> bool;
       else
          VARIANT_FALSE -> bool;
      if);                    
   #);
       
--DispatchParamsPutReal: dopart--
do private.varg[]->VARIANT_init
   (# 
   do VT_R8 -> vt;
      value -> dblVal;
   #);
   
--DispatchParamsPutString: dopart--
do putString:
     (# wstr: @wstring;
        bstr: @integer;
     do value[] -> wstr.set;
        wstr -> SysAllocString -> bstr;
        (if bstr=0 then
            'DispatchParams.putString: SysAllocString failed' -> putline;
            leave putString;
        if);
        private.varg[]->VARIANT_init
        (# 
        do VT_BSTR -> vt;
           bstr -> bstrVal;
        #);
     #)
   
--DispatchParamsPutSafeArrayPrivate: descriptor--
(# psa: ^SAFEARRAY;
   mydata: @COM(# sab: @SAFEARRAYBOUND (* specialization of DATA *) #);
   saBound: @ExternalRepetition(# elementSize::(# do 8 -> value #)#);
   hr: @HRESULT;
   pVargBase: ^VARIANT;
   pVarg: @VariantRefHolder;
   i: @integer;
   elm: ^element;
#)
--DispatchParamsPutSafeArray: dopart--
do putSafeArrayLabel:
     (# cDims:@integer;
     do Dimensions.range -> cDims;
        
        cDims -> private.saBound.new;
        
        (for i:cDims repeat
             1 -> private.mydata.sab.lLbound;
             Dimensions[i] -> private.mydata.sab.cElements;
             (i-1,private.mydata.sab[]) -> private.saBound.inxCopy;
        for);
        
        (VT_VARIANT, cDims, private.saBound) -> SafeArrayCreate -> private.psa[];
        (if debug then
            'psa: ' -> puttext;
            %getLongAt(@@private.psa) -> theinteger;
            theInteger -> putint; newline;
        if);
        
        (if private.psa[]=NONE then
            'DispatchParams.putSafeArray: SafeArrayCreate failed' -> putline;
            leave putSafeArrayLabel;
        if);
        
        private.saBound.free;
        
        (* Lock the SAFEARRAY while accessing the data *)
        (private.psa[], private.pvarg[]) -> SafeArrayAccessData -> private.hr;
        (if private.hr.succeeded then
            (* Save pointer, we will increment pvarg in a while *)
            private.pvarg -> private.pvargBase[];
         else
            'DispatchParams.putSafeArray: SafeArrayCreate failed' 
              -> putline;
            private.psa[] -> SafeArrayDestroy;
            leave putSafeArrayLabel;
        if);
        
        (if debug then
            'pvarg.value: ' -> puttext;
            %getLongAt(@@private.pvarg.value) -> theinteger;
            theInteger -> putint; newline;
        if);
        
        scan:
          (for i:R.range repeat
               i -> private.i;
               R[i][] -> private.elm[];
               INNER putSafeArray;
               (if private.psa[]=NONE then leave scan if);
               private.pvarg.increment;
               (if debug then
                   'pvarg.value: ' -> puttext;
                   %getLongAt(@@private.pvarg.value) -> theInteger;
                   theInteger -> putint; newline;
               if);
          for);
        (if private.psa[]=NONE then leave putSafeArrayLabel if);
        
        (* Unlock *)
        private.psa[] -> SafeArrayUnaccessData -> private.hr;
        (if private.hr.succeeded then
         else
            'DispatchParams.putSafeArray: SafeArrayUnaccessData failed' -> putline;
            private.psa[] -> SafeArrayDestroy;
            leave putSafeArrayLabel;
        if);
        
        (* Now set up argument *)
        THIS(DispatchParams).private.varg[]->VARIANT_init
        (# 
        do VT_VARIANT %Bor VT_ARRAY -> vt;
           (if debug then
               'vt: ' -> puttext; vt -> putint; newline;
               'psa: ' -> puttext;
               %getLongAt(@@private.psa) -> theinteger;
               theInteger -> putint; newline;
           if);
           private.psa[] -> parray;
           (if debug then
               'parray: ' -> puttext; vd.long3 -> putint; newline;
           if);
        #)
     #)
   
--DispatchParamsPutStringArray: dopart--
do setup: private.pvarg.value[] -> VARIANT_init
   (# bstr: @integer;
      wstr: @wstring;
   do VT_BSTR -> vt;
      (if debug then
          private.elm[] -> puttext; ': '->puttext;
      if);
      
      private.elm[] -> wstr.set;
      wstr -> SysAllocString -> bstr;
      wstr.free;
      (if bstr<>0 then
          bstr -> bstrVal;
       else
          'DispatchParams.putStringArray: SysAllocString failed' 
            -> putline;
          (* Clean up *)
          private.pvargBase[] -> private.pvarg;
          (for j:private.i repeat
               private.pvarg -> VARIANT_init
               (# do bstrVal -> SysFreeString #);
               private.pvarg.increment;
          for);
          private.psa[] -> SafeArrayDestroy;
          NONE -> private.psa[];
          leave setup;
      if);
   #);
   
--DispatchParamsPutInt16Array: dopart--
do private.pvarg.value[] -> VARIANT_init
   (# 
   do VT_I2 -> vt;
      private.elm -> iVal;
   #);
   
--InvokeByName: dopart--
do InvokeByName:
     (# cNamedArgs: @integer;
        dispidMember: @integer;
        hr: @HRESULT;
        lcid: @integer;
        wstr: @wstring;
        puArgErr: @int32uholder;
     do true -> status;
        LOCALE_USER_DEFAULT -> lcid;
        params.private.cNamedArgs -> cNamedArgs;
        (* Look up DISPIDs of member name, and any possibly arguments
         * previously put to params.
         *)
        member[] -> params.check
        (# 
        do name[] -> wstr.set; 
           (wstr, 0) -> params.private.alpszArgNames.inxPut;
        #);
        (IID_NULL, params.private.alpszArgNames, 1+cNamedArgs, lcid, params.private.rgdispidNamedArgs)
          -> pDisp.GetIdsOfNames
          -> hr; 
        (*wstr.free; crashes?? *)
        (if hr.succeeded then
            0->params.private.rgdispidNamedArgs.inxGet -> dispidmember;
            (if debug then
                'Got Id for \'' -> puttext;
                member[]->puttext;
                '\': ' -> puttext;
                dispidMember -> putint;
                newline;
            if);
         else
            ('GetIdsOfNames Failed', hr.value) -> ComErrorMessage;
            false -> status;
            leave InvokeByName;
        if);
        
        (* If doing a propertyput, we need to put adjust the first argument
         * to have a named arg of DISPID_PROPERTYPUT
         *)
        (if (wAction %Band DISPATCH_PROPERTYPUT) <> 0 then
            (* PROPERTY_PUT only have 1 named arg besides the "member name" *)
            1 -> cNamedArgs; 
            (DISPID_PROPERTYPUT, 1) -> params.private.rgdispidNamedArgs.inxPut;
        if);
        
        (* Now fill in the DISPPARAMS structure *)
        params.private.rgdispidNamedArgs + 4 -> params.private.dparms.rgdispidNamedArgs;
        params.private.rgvarg -> params.private.dParms.rgvarg;
        params.private.cArgs -> params.private.dParms.cArgs;
        cNamedArgs -> params.private.dParms.cNamedArgs;
        
        0 -> params.private.excep.pfnDeferredFillIn;
        
        (* Finally call invoke *)
        (# dummy: @char do 
           (dispidMember, IID_NULL, lcid, wAction, params.private.dParms[], vReturn[], params.private.excep[], puArgErr[])
             -> pDisp.Invoke
             -> hr;
        #);
        (if hr.succeeded then
            (if debug then
                'Invoke succeeded' -> putline;
            if);
         else
            (# printf: external
                 (# fmt: [0]@char; value: @integer enter (fmt,value) #);
            do ('Invoke Failed', hr.value) -> ComErrorMessage;
               false -> status;
               'wCode: ' -> puttext;
               params.private.excep.wCode -> putint; newline;
               'Source: ' -> puttext;
               params.private.excep.bstrSource -> wstr;
               wstr.get -> putline;
               wstr.free;
               'Description: ' -> puttext;
               params.private.excep.bstrDescription -> wstr;
               wstr.get -> putline;
               wstr.free;
               'Helpfile: ' -> puttext;
               params.private.excep.bstrHelpfile -> wstr;
               wstr.get -> putline;
               wstr.free;
               'sCode: ' -> puttext;
               ('0x%08x\n', params.private.excep.sCode) -> printf;
               'Argument causing error: ' -> puttext;
               puArgErr.value -> putint; newline;
            #);
            leave InvokeByName;
        if);
     #);
   
--PropertyPutByName: dopart--
do (pDisp[], member[], dParms[], DISPATCH_PROPERTYPUT, NONE) 
     -> InvokeByName
     -> status;
   
--PropertyGetByName: dopart--
do (pDisp[], member[], dParms[], DISPATCH_PROPERTYGET, vResult[]) 
     -> InvokeByName
     -> status;
   
