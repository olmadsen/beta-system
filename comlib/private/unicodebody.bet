ORIGIN  '../unicodetext';
INCLUDE '~beta/basiclib/private/betaenvbody';
(*
 * COPYRIGHT
 *       Copyright (C) Aarhus University
 *       All rights reserved.
 *)

--- unicodeTextwStreamGetNonBlank: dopart ---
do skipblanks;
   (if testEOS then ascii.fs->ch else getCh->ch if);
   INNER getNonBlank
   
--- unicodeTextwStreamGetInt: descriptor ---
(# ch: @wchar; negative: @boolean; getC: @get; peekC: @peek; eosTest: @eos;
   nextch: @
     (# do getC; (if not eosTest then peekC->ch else ascii.nul->ch if) #)
do 0->value; false->negative;
   skip: 
     (if not eosTest then
         (if ((peekC->ch)->ascii.isWhiteSpace) then getC; restart skip if)
      else 
     if);
   (if ch
    //'-' then true->negative; nextch
    //'+' then nextch
   if);
   (if  not (ch->ascii.isDigit) then syntaxError if);
   ReadDigits: 
     (if (ch->ascii.isDigit) then
         value*10+(ch-'0')->value;
         nextch;
         restart readDigits
     if);
   (if negative then -value->value if)
#)

--- unicodeTextwStreamPutInt: descriptor ---
(# i, noOfSpaces: @integer; negative: @boolean; c: [20] @wchar; pad: @wchar;
   putC: @put
do (if n=minInt then '8463847412          '->C; 10->i; true->negative
    else
       (if (n<0)->negative then -n->n if);
       0->i;
       loop: 
         (if ((i=0) or (0<n)) then
       	     i+1->i;
       	     (n mod 10)+'0'->c[i];
       	     n div 10->n;
       	     restart loop
   if)if);
   (if (width-i->noOfspaces)<0 then 0->noOfspaces if);
   (if adjustLeft then
       (if negative then noOfSpaces-1->noOfSpaces; '-'->putC
        else (if true
              //signed then noOfSpaces-1->noOfSpaces; '+'->putC
              //blankSign then noOfSpaces-1->noOfSpaces; ' '->putC
             if)
       if);
       (for l: i repeat c[i-(l-1)]->putC for);
       (for l: noOfspaces repeat ' '->putC for)
    else (if zeroPadding then
             (if negative then noOfSpaces-1->noOfSpaces; '-'->putC
              else (if true
                    //signed then noOfSpaces-1->noOfSpaces; '+'->putC
                    //blankSign then noOfSpaces-1->noOfSpaces; ' '->putC
                   if)
             if);
             (for l: noOfspaces repeat '0'->putC for);
             (for l: i repeat c[i-(l-1)]->putC for)
          else (if negative then noOfSpaces-1->noOfSpaces; i+1->i; '-'->c[i]
                else (if true
                      //signed then noOfSpaces-1->noOfSpaces; i+1->i; '+'->c[i]
                      //blankSign then noOfSpaces-1->noOfSpaces; i+1->i; ' '->c[i]
                     if)
               if);
             (for l: noOfspaces repeat ' '->putC for);
             (for l: i repeat c[i-(l-1)]->putC for)
         if)
   if)
#)

--- unicodeTextwStreamAsIntDopart: dopart ---
do l: (#
      do reset;
         getInt
         (# syntaxError:: (# do peek->this(asInt).syntaxError; leave l #) #)
           ->i;
         INNER asInt;
         ScanWhiteSpace; (if not eos then peek->syntaxError if)
      #)
   
--- unicodeTextwStreamScan: dopart ---
do scanLoop:
     (if not testEOS then
         (if (getPeek->whilecondition) then
             getCh->ch; INNER scan; restart scanLoop
         if)
     if)
   
--- unicodeTextwStreamScanAtom: dopart ---
do scanWhiteSpace;
   scan(# while::< (# do not (ch->ascii.isWhiteSpace)->value #)
       do ch->this(scanAtom).ch; INNER scanAtom
       #)
   
--- unicodeTextwStreamScanToNl: dopart ---
do scan
   (# while::< (# do (ch <> ascii.newline)->value #)
   do ch->THIS(scanToNl).ch; INNER scanToNl
   #);
   (if not eos then getCh->ch if)

--- unicodeTextwTextPut: dopart ---
do INNER put;
   (if (pos+1->pos)>lgth then pos->lgth if);
   (if lgth > T.range then T.range+16->T.extend if);
   ch->T[pos]
   
--- unicodeTextwTextPutText: dopart ---
do INNER putText;
   (if T.range < (pos+txt.lgth) then T.range+16+txt.lgth->T.extend if);
   (for i: txt.lgth repeat
        txt.T[i]->T[pos+i]
   for);
   (if (pos+txt.lgth->pos) > lgth then pos->lgth if)
   
--- unicodeTextwTextGet: dopart ---
do (if pos >= lgth then EOSError if);
   T[pos+1->pos]->ch
   
--- unicodeTextwTextGetAtom: dopart ---
do skipBlanks:
     (if pos < lgth then
         (if (T[pos+1]->ascii.isWhiteSpace) then
             pos+1->pos; restart skipBlanks 
     if)if);
   scan:
     (if pos < lgth then
         (if not (T[pos+1]->ascii.isWhiteSpace) then
             (if (txt.pos+1->txt.pos) > txt.T.range then txt.T.range+16->txt.T.extend if);
             pos+1->pos; T[pos]->txt.T[txt.pos]; txt.lgth+1->txt.lgth;
             restart scan
     if)if);
   INNER getAtom
   
--- unicodeTextwTextGetLine: dopart ---
do scan:
     (if (pos < lgth) then
         (if (T[pos+1]<>ascii.newline) then
             (if (txt.pos+1->txt.pos) > txt.T.range then txt.T.range+16->txt.T.extend if);
             pos+1->pos; T[pos]->txt.T[txt.pos]; txt.lgth+1->txt.lgth;
             restart scan
          else pos+1->pos
         if)
     if);
   INNER getline
              
--- unicodeTextwTextPeek: dopart ---
do (if pos >= lgth then EOSError if);
   T[pos+1]->ch;
   INNER peek
   
--- unicodeTextSetPos: dopart ---
do INNER setpos;
   (if true
    //p < 0 then 0->pos
    //p > lgth then lgth->pos
    else p->pos
   if)

--- unicodeTextwTextEOS: dopart ---
do (pos >= lgth)->value
   
--- unicodeTextwTextInxGet: descriptor ---
(# checkit: @check
do i->checkit; T[i]->value; INNER inxGet
#)

--- unicodeTextwTextInxPut: descriptor ---
(# checkit: @check
do INNER inxPut;
   i->checkit; ch->T[i]
#)

--- unicodeTextwTextAppend: dopart ---
do (if T1[] <> NONE then
       INNER append;
       (if (T.range < lgth+T1.lgth) then T.range+16+T1.lgth->T.extend if);
       (for i: T1.lgth repeat T1.T[i]->T[lgth+i] for);
       (if pos=lgth then pos+T1.lgth->pos if);
       lgth+T1.lgth->lgth; 
   if)

--- unicodeTextwTextPrepend: dopart ---
do INNER prepend; (T1[],0)->Insert
   
--- unicodeTextwTextSub: descriptor ---
(# copyType: ##wText
do (if (i<1) then 1->i if);
   (if (j>lgth) then lgth->j if);
   this(wText)##->copyType##; &copyType[]->T1[];
   (if (i<=j) then
       j-i+1->T1.lgth->T1.pos;
       (if (T1.lgth>T1.T.range) then T1.lgth->T1.T.new if);
       (for k: T1.lgth repeat T[k+i-1]->T1.T[k] for)
   if);
   INNER sub
#)

--- unicodeTextwTextInsert: dopart ---
do INNER insert;
   (if T1[] <> NONE then
       (if inx<1 then 1->inx if);
       (if (lgth<inx) then T1[]->append
        else
           (if (T.range < lgth+T1.lgth) then T.range+16+T1.lgth->T.extend if);
           (for k: (lgth-inx+1) repeat
	        T[lgth-k+1]->T[lgth+T1.lgth-k+1]
           for);
           (for i: T1.lgth repeat
                T1.T[i]->T[inx+i-1]
           for);
           (if (pos >= inx) then pos+T1.lgth->pos if);
           lgth+T1.lgth->lgth 
   if)if)

--- unicodeTextwTextDelete: descriptor ---
(# checkit: @check
do INNER delete;
   i->checkit;
   j->checkit;
   (if (i<=j) then
       (for k: lgth-j repeat
            T[j+k]->T[i+k-1]
       for);
       lgth-(j-i+1)->lgth;
       (if true
        //pos>=j then pos-(j-i+1)->pos
        //pos>=i then i-1->pos
           (* else don't change pos *)
if)if)#)

--- unicodeTextwTextEqual: dopart ---
do equal:
     (if txt[]<>NONE then
         (if txt.lgth=lgth then
             (if NCS then
                 (for i: lgth repeat
                      (if ascii.private.UPCASE[T[i]+1]
                          <>ascii.private.UPCASE[txt.T[i]+1] then leave equal if)
                 for)
              else
                 (for i: lgth repeat
                      (if T[i]<>txt.T[i] then leave equal if)
                 for)
             if);
             true->value
     if)if);
   INNER equal
   
--- unicodeTextwTextLess: dopart ---
do less:
     (if T1[] <> NONE then
         (if true
          //(T1.lgth<lgth) then
             (for i: T1.lgth repeat
                  (if T1.T[i]<>T[i] then (T1.T[i]<T[i])->value; leave less if)
             for);
             (* T1 exhausted *)
             true->value;
          //(T1.lgth>=lgth) then
             (for i: lgth repeat
                  (if T1.T[i]<>T[i] then (T1.T[i]<T[i])->value; leave less if)
             for);
             (* T exhausted *)
             false->value;
         if) 
     if);
   INNER less
   
--- unicodeTextwTextGreater: dopart ---
do greater:
     (if T1[] <> NONE then
         (for i: T1.lgth repeat
              (if ((i > lgth)->value) then leave greater
               else 
                  (if ((T1.T[i] > T[i])->value) then leave greater
                   else 
                      (if (T1.T[i] < T[i]) then 
                          false->value;
                          leave greater
                       else false->value
                      if)
     if)if)for)if);
   INNER greater
   
--- unicodeTextwTextMakeLC: dopart ---
do (for i: lgth repeat ascii.private.lowCase[T[i]+1]->T[i] for)
   
--- unicodeTextwTextMakeUC: dopart ---
do (for i: lgth repeat ascii.private.upCase[T[i]+1]->T[i] for)
   
--- unicodeTextwTextFind: dopart ---
do from+1->inx;
   (if NCS then
       ascii.private.UPCASE[ch+1]->ch;
       (for lgth-inx+1 repeat
            (if ch=ascii.private.UPCASE[T[inx]+1] then INNER find if);
            inx+1->inx
       for)
    else
       (for lgth-inx+1 repeat
            (if ch=T[inx] then INNER find if);
            inx+1->inx
       for)
   if)
   
--- unicodeTextwTextFindwText: dopart ---
do (if txt[]<>NONE then
       from+1->inx;
       (if NCS then
           (txt.copy->txt[]).makeUC;
           (for lgth-inx-txt.lgth+2 repeat
                L: (# 
                   do (for i: txt.lgth repeat
                           (if txt.T[i]<>ascii.private.UPCASE[T[inx+i-1]+1] then
                               leave L if)
                      for);
                      INNER findwText
                   #);
                inx+1->inx
           for)
        else
           (for lgth-inx-txt.lgth+2 repeat
                L: (# 
                   do (for i: txt.lgth repeat
                           (if txt.T[i]<>T[inx+i-1] then leave L if)
                      for);
                      INNER findwText
                   #);
                inx+1->inx
           for)
       if)
   if)
   
--- unicodeTextwTextCopy: descriptor ---
(# copyType: ##wText
do this(wText)##->copyType##; &copyType[]->T1[];
   lgth->T1.lgth->T1.pos; T[1: lgth]->T1.T;
   INNER copy
#)

--- unicodeTextwTextIndexError: dopart ---
do 'Index error in wText! (index '->msg.putText;
   inx->msg.putint;
   ') \n'->msg.putText;
   msg[]->wTextErrorMsg;
   INNER
   
--- unicodeTextwTextEOSerror: dopart ---
do msg[]->wTextErrormsg; INNER 
   
--- unicodeTextwTextOtherError: dopart ---
do msg[]->wTextErrormsg; INNER 
   
--- wTextLib: attributes ---
Check: 
  (# i: @integer
  enter i
  do (if ((i<1) or (lgth<i)) then i->IndexError if)
  #);
wTextErrorMsg: 
  (# msg: ^Text
  enter msg[]
  do (if lgth=0 then
         'Empty wText.'->msg.putline
      else
         (if lgth>70 then
             'Error in wText, which begins as follows: '->msg.putLine;
             '\''->msg.put;
             (for i: 70 repeat T[i]->msg.put for);
             '.....\''->msg.putLine
          else
             'Error in the wText: \''->msg.putText;
             this(wText)[]-> asText -> msg.putText;
             '\''->msg.putline
         if)
     if)
  #);
asText:
  (# awText: ^wText; aTxt: ^text
  enter awText[]
  do 'Convert unicode text to ascii text (not implemented'
       -> screen.putline
  exit aTxt[]
  #);


