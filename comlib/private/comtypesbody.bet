ORIGIN '../comtypes';
INCLUDE '~beta/basiclib/formatio';
INCLUDE '~beta/sysutils/objinterface';
   
--- GUIDsetFromTextLib: attributes ---
traceGUID: (# exit false #);
(* FIXME: there are standard COM functions we could call.*)

hextoint: 
  (# c: @Char;
  enter c
  do (if c>'Z' then c-32->c (* Upcase *) if);
     c-'0'->c (* normalize to 0-9 *);
     (if c>10 then c-7->c (* normalize to 10-15 *) if);
     (if (c<0) or (c>15) then
         'hextoint error for character: \''->putText;
         c -> put;
         '\' ('->puttext;
         c->putint;
         ')' -> putline;
     if);
  exit c
  #);

--LIB: attributes --
malloc: external
     (# numbytes, result: @integer
     enter numbytes
     exit result
     #);

--- GUIDinit: dopart ---
do (16->malloc) %putLongAt (@@binary);
   
--- GUIDSetFromText: descriptor ---
(# v: @integer;
do SetT:
     (# 
     do (if binary[]=NONE then init if);
        (if T[]=NONE then
            THIS(GUID)[]->GetPatternName -> putText;
            '.setFromText: Text is NONE - ignored' ->putline;
            leave setT;
        if);
        (if T.length<>36 then
            THIS(GUID)[]->GetPatternName -> putText;
            '.setFromText: Text is not long enough - ignored' ->putline;
        if);            
        1->p;
        (for i:16 repeat
             (if T.T[p]='-' then p+1->p if);
             ((T.T[p]->hextoint)*16)+(T.T[p+1]->hextoint) -> v;
             (v) %putByteAt ((@@Binary.data1)+i-1);
             p+2->p;
        for);
        binary.data1.%byteswaplong;
        binary.data2.%byteswapshort;
        binary.data3.%byteswapshort;
        (if traceGUID then 
            'GUID.setfromtext: Parsed'->putline;
            T[] -> putline; 'into the following:' -> putline;
            getAsText -> putLine;
        if);
     #)
#)

--- GUIDGetAsText: descriptor ---
(# 
do (if binary[]=NONE then
       NONE -> T[];
    else
       &Text[]->T[]; 
       '%08.08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x' -> 
       T.putFormat
       (# 
       do binary.data1 -> x;
          binary.data2 -> x;
          binary.data3 -> x;
          (for i:16-8 repeat
               (%getByteAt ((@@binary.data4_0)+i-1)) -> x
          for)
       #); 
   if);
#)

--- GUIDSetFromPointer: dopart---
do (refguid) %putLongAt (@@binary);

--GuidEqual: dopart--
do (if (binary[]=NONE) or (g.binary[]=NONE) then
       false->value;
       leave equal;
   if);
   (if (binary[]=g.binary[]) then
       true->value;
       leave equal;
   if);
   (* FIXME: probably cheaper to use memcmp *)
   (binary.data1=g.binary.data1) 
   and ((%getLongAt(@@binary.data2))  =(%getLongAt(@@g.binary.data2)))
   and ((%getLongAt(@@binary.data4_0))=(%getLongAt(@@g.binary.data4_0)))
   and ((%getLongAt(@@binary.data4_4))=(%getLongAt(@@g.binary.data4_4)))
     -> value;
   
