(* BETA interface generated from "UrlMon.Idl" Tue May 12 13:15:57 1998 *)

ORIGIN '~beta/comlib/comtypes';
INCLUDE 'ObjIdl';
INCLUDE 'OleIdl';
INCLUDE 'ServProv';
INCLUDE 'MsXml';
--LIB: attributes--
  (* //=--------------------------------------------------------------------------= *)
  (* // UrlMon.h *)
  (* //=--------------------------------------------------------------------------= *)
  (* // (C) Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. *)
  (* // *)
  (* // THIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF *)
  (* // ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO *)
  (* // THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A *)
  (* // PARTICULAR PURPOSE. *)
  (* //=--------------------------------------------------------------------------= *)
  (*  *)
  (*  *)
  (* //---------------------------------------------------------------------------= *)
  (* // URL Moniker Interfaces. *)
  (*  *)
  (* // These are for backwards compatibility with previous URLMON versions *)
  (* #define BINDF_DONTUSECACHE BINDF_GETNEWESTVERSION *)
  (* #define BINDF_DONTPUTINCACHE BINDF_NOWRITECACHE *)
  (* #define BINDF_NOCOPYDATA BINDF_PULLDATA *)
  (* #define PI_DOCFILECLSIDLOOKUP PI_CLSIDLOOKUP *)
  (* EXTERN_C const IID IID_IAsyncMoniker;     *)
  (* EXTERN_C const IID CLSID_StdURLMoniker;   *)
  (* EXTERN_C const IID CLSID_HttpProtocol;    *)
  (* EXTERN_C const IID CLSID_FtpProtocol;     *)
  (* EXTERN_C const IID CLSID_GopherProtocol;  *)
  (* EXTERN_C const IID CLSID_HttpSProtocol;   *)
  (* EXTERN_C const IID CLSID_FileProtocol;    *)
  (* EXTERN_C const IID CLSID_MkProtocol;      *)
  (* EXTERN_C const IID CLSID_StdURLProtocol;  *)
  (* EXTERN_C const IID CLSID_UrlMkBindCtx;    *)
  (* EXTERN_C const IID CLSID_StdEncodingFilterFac;  *)
  (* EXTERN_C const IID CLSID_DeCompMimeFilter;      *)
  (* EXTERN_C const IID CLSID_CdlProtocol;           *)
  (* EXTERN_C const IID CLSID_ClassInstallFilter;    *)
  (* EXTERN_C const IID IID_IAsyncBindCtx;     *)
  (* // MessageId: MK_S_ASYNCHRONOUS                                               *)
  (* // MessageText: Operation is successful, but will complete asynchronously.    *)
  (* //                                                                            *)
  (* #define MK_S_ASYNCHRONOUS    _HRESULT_TYPEDEF_(0x000401E8L)                   *)
  (* #ifndef S_ASYNCHRONOUS                                                        *)
  (* #define S_ASYNCHRONOUS       MK_S_ASYNCHRONOUS                                *)
  (* #endif                                                                        *)
  (*                                                                               *)
  (* #ifndef E_PENDING                                                             *)
  (* #define E_PENDING _HRESULT_TYPEDEF_(0x8000000AL)                              *)
  (* #endif                                                                        *)
  (*                                                                               *)
  (* //                                                                            *)
  (* //                                                                            *)
  (* // WinINet and protocol specific errors are mapped to one of the following    *)
  (* // error which are returned in IBSC::OnStopBinding                            *)
  (* //                                                                            *)
  (* //                                                                            *)
  (* // Note: FACILITY C is split into ranges of 1k                                *)
  (* // C0000 - C03FF  INET_E_ (URLMON's original hresult)                         *)
  (* // C0400 - C07FF  INET_E_CLIENT_xxx                                           *)
  (* // C0800 - C0BFF  INET_E_SERVER_xxx                                           *)
  (* // C0C00 - C0FFF  INET_E_????                                                 *)
  (* // C1000 - C13FF  INET_E_AGENT_xxx (info delivery agents)                     *)
  (* #define INET_E_INVALID_URL               _HRESULT_TYPEDEF_(0x800C0002L)       *)
  (* #define INET_E_NO_SESSION                _HRESULT_TYPEDEF_(0x800C0003L)       *)
  (* #define INET_E_CANNOT_CONNECT            _HRESULT_TYPEDEF_(0x800C0004L)       *)
  (* #define INET_E_RESOURCE_NOT_FOUND        _HRESULT_TYPEDEF_(0x800C0005L)       *)
  (* #define INET_E_OBJECT_NOT_FOUND          _HRESULT_TYPEDEF_(0x800C0006L)       *)
  (* #define INET_E_DATA_NOT_AVAILABLE        _HRESULT_TYPEDEF_(0x800C0007L)       *)
  (* #define INET_E_DOWNLOAD_FAILURE          _HRESULT_TYPEDEF_(0x800C0008L)       *)
  (* #define INET_E_AUTHENTICATION_REQUIRED   _HRESULT_TYPEDEF_(0x800C0009L)       *)
  (* #define INET_E_NO_VALID_MEDIA            _HRESULT_TYPEDEF_(0x800C000AL)       *)
  (* #define INET_E_CONNECTION_TIMEOUT        _HRESULT_TYPEDEF_(0x800C000BL)       *)
  (* #define INET_E_INVALID_REQUEST           _HRESULT_TYPEDEF_(0x800C000CL)       *)
  (* #define INET_E_UNKNOWN_PROTOCOL          _HRESULT_TYPEDEF_(0x800C000DL)       *)
  (* #define INET_E_SECURITY_PROBLEM          _HRESULT_TYPEDEF_(0x800C000EL)       *)
  (* #define INET_E_CANNOT_LOAD_DATA          _HRESULT_TYPEDEF_(0x800C000FL)       *)
  (* #define INET_E_CANNOT_INSTANTIATE_OBJECT _HRESULT_TYPEDEF_(0x800C0010L)       *)
  (* #define INET_E_REDIRECT_FAILED           _HRESULT_TYPEDEF_(0x800C0014L)       *)
  (* #define INET_E_REDIRECT_TO_DIR           _HRESULT_TYPEDEF_(0x800C0015L)       *)
  (* #define INET_E_CANNOT_LOCK_REQUEST       _HRESULT_TYPEDEF_(0x800C0016L)       *)
  (* #define INET_E_ERROR_FIRST               _HRESULT_TYPEDEF_(0x800C0002L)       *)
  (* #define INET_E_ERROR_LAST                INET_E_REDIRECT_TO_DIR *)
  (* #ifndef _LPPERSISTMONIKER_DEFINED *)
  (* #define _LPPERSISTMONIKER_DEFINED *)

  IPersistMoniker_IID: (# exit '79eac9c9-baf9-11ce-8c82-00aa004ba90b' #);

  IPersistMoniker: IUnknown
    (# <<SLOT IPersistMonikerLib: attributes>>;
       GetClassID:<
         (# result: @int32 (* HRESULT *);
            pClassID: ^CLSIDHolder (* *CLSID *); 
         enter pClassID[]
         exit result
         #);
       IsDirty:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         exit result
         #);
       Load:<
         (# result: @int32 (* HRESULT *);
            fFullyAvailable: @int32 (* BOOL *); 
            pimkName: ^IMoniker (* *IMoniker *); 
            pibc: ^IBindCtx (* LPBC *); 
            grfMode: @int32u (* DWORD *); 
         enter (fFullyAvailable, pimkName[], pibc[], grfMode)
         exit result
         #);
       Save:<
         (# result: @int32 (* HRESULT *);
            pimkName: ^IMoniker (* *IMoniker *); 
            pbc: ^IBindCtx (* LPBC *); 
            fRemember: @int32 (* BOOL *); 
         enter (pimkName[], pbc[], fRemember)
         exit result
         #);
       SaveCompleted:<
         (# result: @int32 (* HRESULT *);
            pimkName: ^IMoniker (* *IMoniker *); 
            pibc: ^IBindCtx (* LPBC *); 
         enter (pimkName[], pibc[])
         exit result
         #);
       GetCurMoniker:<
         (# result: @int32 (* HRESULT *);
            ppimkName: ^IMonikerHolder (* **IMoniker *); 
         enter ppimkName[]
         exit result
         #);
    #);
  (* #endif *)
  (* #ifndef _LPBINDPROTOCOL_DEFINED *)
  (* #define _LPBINDPROTOCOL_DEFINED *)

  IBindProtocol_IID: (# exit '79eac9cd-baf9-11ce-8c82-00aa004ba90b' #);

  IBindProtocol: IUnknown
    (# <<SLOT IBindProtocolLib: attributes>>;
       CreateBinding:<
         (# result: @int32 (* HRESULT *);
            szUrl: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            pbc: ^IBindCtx (* *IBindCtx *); 
            ppb: ^IBindingHolder (* **IBinding *); 
         enter (szUrl, pbc[], ppb[])
         exit result
         #);
    #);
  (* #endif *)
  (* #ifndef _LPBINDING_DEFINED *)
  (* #define _LPBINDING_DEFINED *)

  IBinding_IID: (# exit '79eac9c0-baf9-11ce-8c82-00aa004ba90b' #);

  IBinding: IUnknown
    (# <<SLOT IBindingLib: attributes>>;
       Abort:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       _Suspend:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       Resume:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       SetPriority:<
         (# result: @int32 (* HRESULT *);
            nPriority: @int32 (* LONG *); 
         enter nPriority
         exit result
         #);
       GetPriority:<
         (# result: @int32 (* HRESULT *);
            pnPriority: ^int32Holder (* *LONG *); 
         enter pnPriority[]
         exit result
         #);
       GetBindResult:<
         (# result: @int32 (* HRESULT *);
            pclsidProtocol: ^CLSIDHolder (* *CLSID *); 
            pdwResult: ^int32uHolder (* *DWORD *); 
            pszResult: ^textHolder (* *LPOLESTR *); 
            pdwReserved: ^int32uHolder (* *DWORD *); 
         enter (pclsidProtocol[], pdwResult[], pszResult[], pdwReserved[])
         exit result
         #);
       RemoteGetBindResult:<
         (# result: @int32 (* HRESULT *);
            pclsidProtocol: ^CLSIDHolder (* *CLSID *); 
            pdwResult: ^int32uHolder (* *DWORD *); 
            pszResult: ^textHolder (* *LPOLESTR *); 
            dwReserved: @int32u (* DWORD *); 
         enter (pclsidProtocol[], pdwResult[], pszResult[], dwReserved)
         exit result
         #);
    #);
  (* #endif *)
  (* #ifndef _LPBINDSTATUSCALLBACK_DEFINED *)
  (* #define _LPBINDSTATUSCALLBACK_DEFINED *)

  IBindStatusCallback_IID: (# exit '79eac9c1-baf9-11ce-8c82-00aa004ba90b' #);

  IBindStatusCallback: IUnknown
    (# <<SLOT IBindStatusCallbackLib: attributes>>;
       OnStartBinding:<
         (# result: @int32 (* HRESULT *);
            dwReserved: @int32u (* DWORD *); 
            pib: ^IBinding (* *IBinding *); 
         enter (dwReserved, pib[])
         exit result
         #);
       GetPriority:<
         (# result: @int32 (* HRESULT *);
            pnPriority: ^int32Holder (* *LONG *); 
         enter pnPriority[]
         exit result
         #);
       OnLowResource:<
         (# result: @int32 (* HRESULT *);
            reserved: @int32u (* DWORD *); 
         enter reserved
         exit result
         #);
       OnProgress:<
         (# result: @int32 (* HRESULT *);
            ulProgress: @int32u (* ULONG *); 
            ulProgressMax: @int32u (* ULONG *); 
            ulStatusCode: @int32u (* ULONG *); 
            szStatusText: [0]@char (* ^text NYI *) (* LPCWSTR *); 
         enter (ulProgress, ulProgressMax, ulStatusCode, szStatusText)
         exit result
         #);
       OnStopBinding:<
         (# result: @int32 (* HRESULT *);
            hresult: @int32 (* HRESULT *); 
            szError: [0]@char (* ^text NYI *) (* LPCWSTR *); 
         enter (hresult, szError)
         exit result
         #);
       GetBindInfo:<
         (# result: @int32 (* HRESULT *);
            grfBINDF: ^int32uHolder (* *DWORD *); 
            pbindinfo: ^struct__tagBINDINFO (* *BINDINFO *); 
         enter (grfBINDF[], pbindinfo[])
         exit result
         #);
       RemoteGetBindInfo:<
         (# result: @int32 (* HRESULT *);
            grfBINDF: ^int32uHolder (* *DWORD *); 
            pbindinfo: ^struct__tagRemBINDINFO (* *RemBINDINFO *); 
            pstgmed: ^struct_tagRemSTGMEDIUM (* *RemSTGMEDIUM *); 
         enter (grfBINDF[], pbindinfo[], pstgmed[])
         exit result
         #);
       OnDataAvailable:<
         (# result: @int32 (* HRESULT *);
            grfBSCF: @int32u (* DWORD *); 
            dwSize: @int32u (* DWORD *); 
            pformatetc: ^struct_tagFORMATETC (* *FORMATETC *); 
            pstgmed: ^struct_tagSTGMEDIUM (* *STGMEDIUM *); 
         enter (grfBSCF, dwSize, pformatetc[], pstgmed[])
         exit result
         #);
       RemoteOnDataAvailable:<
         (# result: @int32 (* HRESULT *);
            grfBSCF: @int32u (* DWORD *); 
            dwSize: @int32u (* DWORD *); 
            pformatetc: ^struct_tagRemFORMATETC (* *RemFORMATETC *); 
            pstgmed: ^struct_tagRemSTGMEDIUM (* *RemSTGMEDIUM *); 
         enter (grfBSCF, dwSize, pformatetc[], pstgmed[])
         exit result
         #);
       OnObjectAvailable:<
         (# result: @int32 (* HRESULT *);
            riid: @int32 (* REFIID *); 
            punk: ^IUnknown (* *IUnknown *); 
         enter (riid, punk[])
         exit result
         #);
    #);
  BINDVERB: IntegerObject(# #);
  BINDVERB_GET: (* BINDVERB *)(# exit 0x00000000 #);
  BINDVERB_POST: (* BINDVERB *)(# exit 0x00000001 #);
  BINDVERB_PUT: (* BINDVERB *)(# exit 0x00000002 #);
  BINDVERB_CUSTOM: (* BINDVERB *)(# exit 0x00000003 #);

  BINDINFOF: IntegerObject(# #);
  BINDINFOF_URLENCODESTGMEDDATA: (* BINDINFOF *)(# exit 0x00000001 #);
  BINDINFOF_URLENCODEDEXTRAINFO: (* BINDINFOF *)(# exit 0x00000002 #);

  BINDF: IntegerObject(# #);
  BINDF_ASYNCHRONOUS: (* BINDF *)(# exit 0x00000001 #);
  BINDF_ASYNCSTORAGE: (* BINDF *)(# exit 0x00000002 #);
  BINDF_NOPROGRESSIVERENDERING: (* BINDF *)(# exit 0x00000004 #);
  BINDF_OFFLINEOPERATION: (* BINDF *)(# exit 0x00000008 #);
  BINDF_GETNEWESTVERSION: (* BINDF *)(# exit 0x00000010 #);
  BINDF_NOWRITECACHE: (* BINDF *)(# exit 0x00000020 #);
  BINDF_NEEDFILE: (* BINDF *)(# exit 0x00000040 #);
  BINDF_PULLDATA: (* BINDF *)(# exit 0x00000080 #);
  BINDF_IGNORESECURITYPROBLEM: (* BINDF *)(# exit 0x00000100 #);
  BINDF_RESYNCHRONIZE: (* BINDF *)(# exit 0x00000200 #);
  BINDF_HYPERLINK: (* BINDF *)(# exit 0x00000400 #);
  BINDF_NO_UI: (* BINDF *)(# exit 0x00000800 #);
  BINDF_SILENTOPERATION: (* BINDF *)(# exit 0x00001000 #);
  BINDF_PRAGMA_NO_CACHE: (* BINDF *)(# exit 0x00002000 #);
  BINDF_FREE_THREADED: (* BINDF *)(# exit 0x00010000 #);
  BINDF_DIRECT_READ: (* BINDF *)(# exit 0x00020000 #);
  BINDF_FORMS_SUBMIT: (* BINDF *)(# exit 0x00040000 #);
  BINDF_GETFROMCACHE_IF_NET_FAIL: (* BINDF *)(# exit 0x00080000 #);

  BINDINFO: struct__tagBINDINFO(# #);
  struct__tagBINDINFO: DATA
    (# cbSize: @int32u (* ULONG *);
       szExtraInfo: @wcharHolder (* *LPWSTR *);
       stgmedData: @struct_tagSTGMEDIUM (* STGMEDIUM *);
       grfBindInfoF: @int32u (* DWORD *);
       dwBindVerb: @int32u (* DWORD *);
       szCustomVerb: @wcharHolder (* *LPWSTR *);
       cbstgmedData: @int32u (* DWORD *);
       dwOptions: @int32u (* DWORD *);
       dwOptionsFlags: @int32u (* DWORD *);
       dwCodePage: @int32u (* DWORD *);
       securityAttributes: @struct__SECURITY_ATTRIBUTES (* SECURITY_ATTRIBUTES *);
       _iid: @IID (* IID *);
       pUnk: ^IUnknown (* IUnknown *);
       dwReserved: @int32u (* DWORD *);
    #);
  REMSECURITY_ATTRIBUTES: struct__REMSECURITY_ATTRIBUTES(# #);
  struct__REMSECURITY_ATTRIBUTES: DATA
    (# nLength: @int32u (* DWORD *);
       lpSecurityDescriptor: @int32u (* DWORD *);
       bInheritHandle: @int32 (* BOOL *);
    #);
  RemBINDINFO: struct__tagRemBINDINFO(# #);
  struct__tagRemBINDINFO: DATA
    (# cbSize: @int32u (* ULONG *);
       szExtraInfo: @wcharHolder (* *LPWSTR *);
       grfBindInfoF: @int32u (* DWORD *);
       dwBindVerb: @int32u (* DWORD *);
       szCustomVerb: @wcharHolder (* *LPWSTR *);
       cbstgmedData: @int32u (* DWORD *);
       dwOptions: @int32u (* DWORD *);
       dwOptionsFlags: @int32u (* DWORD *);
       dwCodePage: @int32u (* DWORD *);
       securityAttributes: @struct__REMSECURITY_ATTRIBUTES (* REMSECURITY_ATTRIBUTES *);
       _iid: @IID (* IID *);
       pUnk: ^IUnknown (* IUnknown *);
       dwReserved: @int32u (* DWORD *);
    #);
  RemFORMATETC: struct_tagRemFORMATETC(# #);
  struct_tagRemFORMATETC: DATA
    (# cfFormat: @int32u (* DWORD *);
       ptd: @int32u (* DWORD *);
       dwAspect: @int32u (* DWORD *);
       lindex: @int32 (* LONG *);
       tymed: @int32u (* DWORD *);
    #);
  BSCF: IntegerObject(# #);
  BSCF_FIRSTDATANOTIFICATION: (* BSCF *)(# exit 0x00000001 #);
  BSCF_INTERMEDIATEDATANOTIFICATION: (* BSCF *)(# exit 0x00000002 #);
  BSCF_LASTDATANOTIFICATION: (* BSCF *)(# exit 0x00000004 #);
  BSCF_DATAFULLYAVAILABLE: (* BSCF *)(# exit 0x00000008 #);
  BSCF_AVAILABLEDATASIZEUNKNOWN: (* BSCF *)(# exit 0x00000010 #);

  BINDSTATUS: IntegerObject(# (* enum tagBINDSTATUS *) #);
  BINDSTATUS_FINDINGRESOURCE: (* BINDSTATUS *)(# exit 1 #);
  BINDSTATUS_CONNECTING: (* BINDSTATUS *)(# exit BINDSTATUS_FINDINGRESOURCE+1 #);
  BINDSTATUS_REDIRECTING: (* BINDSTATUS *)(# exit BINDSTATUS_CONNECTING+1 #);
  BINDSTATUS_BEGINDOWNLOADDATA: (* BINDSTATUS *)(# exit BINDSTATUS_REDIRECTING+1 #);
  BINDSTATUS_DOWNLOADINGDATA: (* BINDSTATUS *)(# exit BINDSTATUS_BEGINDOWNLOADDATA+1 #);
  BINDSTATUS_ENDDOWNLOADDATA: (* BINDSTATUS *)(# exit BINDSTATUS_DOWNLOADINGDATA+1 #);
  BINDSTATUS_BEGINDOWNLOADCOMPONENTS: (* BINDSTATUS *)(# exit BINDSTATUS_ENDDOWNLOADDATA+1 #);
  BINDSTATUS_INSTALLINGCOMPONENTS: (* BINDSTATUS *)(# exit BINDSTATUS_BEGINDOWNLOADCOMPONENTS+1 #);
  BINDSTATUS_ENDDOWNLOADCOMPONENTS: (* BINDSTATUS *)(# exit BINDSTATUS_INSTALLINGCOMPONENTS+1 #);
  BINDSTATUS_USINGCACHEDCOPY: (* BINDSTATUS *)(# exit BINDSTATUS_ENDDOWNLOADCOMPONENTS+1 #);
  BINDSTATUS_SENDINGREQUEST: (* BINDSTATUS *)(# exit BINDSTATUS_USINGCACHEDCOPY+1 #);
  BINDSTATUS_CLASSIDAVAILABLE: (* BINDSTATUS *)(# exit BINDSTATUS_SENDINGREQUEST+1 #);
  BINDSTATUS_MIMETYPEAVAILABLE: (* BINDSTATUS *)(# exit BINDSTATUS_CLASSIDAVAILABLE+1 #);
  BINDSTATUS_CACHEFILENAMEAVAILABLE: (* BINDSTATUS *)(# exit BINDSTATUS_MIMETYPEAVAILABLE+1 #);
  BINDSTATUS_BEGINSYNCOPERATION: (* BINDSTATUS *)(# exit BINDSTATUS_CACHEFILENAMEAVAILABLE+1 #);
  BINDSTATUS_ENDSYNCOPERATION: (* BINDSTATUS *)(# exit BINDSTATUS_BEGINSYNCOPERATION+1 #);
  BINDSTATUS_BEGINUPLOADDATA: (* BINDSTATUS *)(# exit BINDSTATUS_ENDSYNCOPERATION+1 #);
  BINDSTATUS_UPLOADINGDATA: (* BINDSTATUS *)(# exit BINDSTATUS_BEGINUPLOADDATA+1 #);
  BINDSTATUS_ENDUPLOADDATA: (* BINDSTATUS *)(# exit BINDSTATUS_UPLOADINGDATA+1 #);
  BINDSTATUS_PROTOCOLCLASSID: (* BINDSTATUS *)(# exit BINDSTATUS_ENDUPLOADDATA+1 #);
  BINDSTATUS_ENCODING: (* BINDSTATUS *)(# exit BINDSTATUS_PROTOCOLCLASSID+1 #);
  BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE: (* BINDSTATUS *)(# exit BINDSTATUS_ENCODING+1 #);
  BINDSTATUS_CLASSINSTALLLOCATION: (* BINDSTATUS *)(# exit BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE+1 #);
  BINDSTATUS_DECODING: (* BINDSTATUS *)(# exit BINDSTATUS_CLASSINSTALLLOCATION+1 #);
  BINDSTATUS_LOADINGMIMEHANDLER: (* BINDSTATUS *)(# exit BINDSTATUS_DECODING+1 #);

  (* #endif *)
  (* #ifndef _LPAUTHENTICATION_DEFINED *)
  (* #define _LPAUTHENTICATION_DEFINED *)

  IAuthenticate_IID: (# exit '79eac9d0-baf9-11ce-8c82-00aa004ba90b' #);

  IAuthenticate: IUnknown
    (# <<SLOT IAuthenticateLib: attributes>>;
       Authenticate:<
         (# result: @int32 (* HRESULT *);
            phwnd: ^int32Holder (* *HWND *); 
            pszUsername: ^textHolder (* *LPWSTR *); 
            pszPassword: ^textHolder (* *LPWSTR *); 
         enter (phwnd[], pszUsername[], pszPassword[])
         exit result
         #);
    #);
  (* #endif *)
  (* #ifndef _LPHTTPNEGOTIATE_DEFINED *)
  (* #define _LPHTTPNEGOTIATE_DEFINED *)

  IHttpNegotiate_IID: (# exit '79eac9d2-baf9-11ce-8c82-00aa004ba90b' #);

  IHttpNegotiate: IUnknown
    (# <<SLOT IHttpNegotiateLib: attributes>>;
       BeginningTransaction:<
         (# result: @int32 (* HRESULT *);
            szURL: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            szHeaders: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            dwReserved: @int32u (* DWORD *); 
            pszAdditionalHeaders: ^textHolder (* *LPWSTR *); 
         enter (szURL, szHeaders, dwReserved, pszAdditionalHeaders[])
         exit result
         #);
       OnResponse:<
         (# result: @int32 (* HRESULT *);
            dwResponseCode: @int32u (* DWORD *); 
            szResponseHeaders: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            szRequestHeaders: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            pszAdditionalRequestHeaders: ^textHolder (* *LPWSTR *); 
         enter (dwResponseCode, szResponseHeaders, szRequestHeaders, pszAdditionalRequestHeaders[])
         exit result
         #);
    #);
  (* #endif *)
  (* #ifndef _LPWINDOWFORBINDINGUI_DEFINED *)
  (* #define _LPWINDOWFORBINDINGUI_DEFINED *)

  IWindowForBindingUI_IID: (# exit '79eac9d5-bafa-11ce-8c82-00aa004ba90b' #);

  IWindowForBindingUI: IUnknown
    (# <<SLOT IWindowForBindingUILib: attributes>>;
       GetWindow:<
         (# result: @int32 (* HRESULT *);
            rguidReason: @int32 (* REFGUID *); 
            phwnd: ^int32Holder (* *HWND *); 
         enter (rguidReason, phwnd[])
         exit result
         #);
    #);
  (* #endif *)
  (* #ifndef _LPCODEINSTALL_DEFINED *)
  (* #define _LPCODEINSTALL_DEFINED *)

  ICodeInstall_IID: (# exit '79eac9d1-baf9-11ce-8c82-00aa004ba90b' #);

  ICodeInstall: IWindowForBindingUI
    (# <<SLOT ICodeInstallLib: attributes>>;
       OnCodeInstallProblem:<
         (# result: @int32 (* HRESULT *);
            ulStatusCode: @int32u (* ULONG *); 
            szDestination: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            szSource: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            dwReserved: @int32u (* DWORD *); 
         enter (ulStatusCode, szDestination, szSource, dwReserved)
         exit result
         #);
    #);
  CIP_STATUS: IntegerObject(# #);
  CIP_DISK_FULL: (* CIP_STATUS *)(# exit 0 #);
  CIP_ACCESS_DENIED: (* CIP_STATUS *)(# exit 1 #);
  CIP_NEWER_VERSION_EXISTS: (* CIP_STATUS *)(# exit 2 #);
  CIP_OLDER_VERSION_EXISTS: (* CIP_STATUS *)(# exit 3 #);
  CIP_NAME_CONFLICT: (* CIP_STATUS *)(# exit 4 #);
  CIP_TRUST_VERIFICATION_COMPONENT_MISSING: (* CIP_STATUS *)(# exit 5 #);
  CIP_EXE_SELF_REGISTERATION_TIMEOUT: (* CIP_STATUS *)(# exit 6 #);
  CIP_UNSAFE_TO_ABORT: (* CIP_STATUS *)(# exit 7 #);
  CIP_NEED_REBOOT: (* CIP_STATUS *)(# exit 8 #);

  (* #endif *)
  (* #ifndef _LPWININETINFO_DEFINED *)
  (* #define _LPWININETINFO_DEFINED *)

  IWinInetInfo_IID: (# exit '79eac9d6-bafa-11ce-8c82-00aa004ba90b' #);

  IWinInetInfo: IUnknown
    (# <<SLOT IWinInetInfoLib: attributes>>;
       QueryOption:<
         (# result: @int32 (* HRESULT *);
            dwOption: @int32u (* DWORD *); 
            pBuffer: ^int32Holder (* LPVOID *); 
            pcbBuf: ^int32uHolder (* *DWORD *); 
         enter (dwOption, pBuffer[], pcbBuf[])
         exit result
         #);
       RemoteQueryOption:<
         (# result: @int32 (* HRESULT *);
            dwOption: @int32u (* DWORD *); 
            pBuffer: ^int8uHolder (* *BYTE *); 
            pcbBuf: ^int32uHolder (* *DWORD *); 
         enter (dwOption, pBuffer[], pcbBuf[])
         exit result
         #);
    #);
  (* #endif *)
  (* #define WININETINFO_OPTION_LOCK_HANDLE 65534 *)
  (* #ifndef _LPHTTPSECURITY_DEFINED *)
  (* #define _LPHTTPSECURITY_DEFINED *)

  IHttpSecurity_IID: (# exit '79eac9d7-bafa-11ce-8c82-00aa004ba90b' #);

  IHttpSecurity: IWindowForBindingUI
    (# <<SLOT IHttpSecurityLib: attributes>>;
       OnSecurityProblem:<
         (# result: @int32 (* HRESULT *);
            dwProblem: @int32u (* DWORD *); 
         enter dwProblem
         exit result
         #);
    #);
  (* #endif *)
  (* #ifndef _LPWININETHTTPINFO_DEFINED *)
  (* #define _LPWININETHTTPINFO_DEFINED *)

  IWinInetHttpInfo_IID: (# exit '79eac9d8-bafa-11ce-8c82-00aa004ba90b' #);

  IWinInetHttpInfo: IWinInetInfo
    (# <<SLOT IWinInetHttpInfoLib: attributes>>;
       QueryInfo:<
         (# result: @int32 (* HRESULT *);
            dwOption: @int32u (* DWORD *); 
            pBuffer: ^int32Holder (* LPVOID *); 
            pcbBuf: ^int32uHolder (* *DWORD *); 
            pdwFlags: ^int32uHolder (* *DWORD *); 
            pdwReserved: ^int32uHolder (* *DWORD *); 
         enter (dwOption, pBuffer[], pcbBuf[], pdwFlags[], pdwReserved[])
         exit result
         #);
       RemoteQueryInfo:<
         (# result: @int32 (* HRESULT *);
            dwOption: @int32u (* DWORD *); 
            pBuffer: ^int8uHolder (* *BYTE *); 
            pcbBuf: ^int32uHolder (* *DWORD *); 
            pdwFlags: ^int32uHolder (* *DWORD *); 
            pdwReserved: ^int32uHolder (* *DWORD *); 
         enter (dwOption, pBuffer[], pcbBuf[], pdwFlags[], pdwReserved[])
         exit result
         #);
    #);
  (* #endif *)
  (* #define SID_IBindHost IID_IBindHost *)
  (* #define SID_SBindHost IID_IBindHost *)
  (* #ifndef _LPBINDHOST_DEFINED *)
  (* #define _LPBINDHOST_DEFINED *)
  (* EXTERN_C const GUID SID_BindHost; *)

  IBindHost_IID: (# exit 'fc4801a1-2ba9-11cf-a229-00aa003d7352' #);

  IBindHost: IUnknown
    (# <<SLOT IBindHostLib: attributes>>;
       CreateMoniker:<
         (# result: @int32 (* HRESULT *);
            szName: [0]@char (* ^text NYI *) (* LPOLESTR *); 
            pBC: ^IBindCtx (* *IBindCtx *); 
            ppmk: ^IMonikerHolder (* **IMoniker *); 
            dwReserved: @int32u (* DWORD *); 
         enter (szName, pBC[], ppmk[], dwReserved)
         exit result
         #);
       MonikerBindToStorage:<
         (# result: @int32 (* HRESULT *);
            pMk: ^IMoniker (* *IMoniker *); 
            pBC: ^IBindCtx (* *IBindCtx *); 
            pBSC: ^IBindStatusCallback (* *IBindStatusCallback *); 
            riid: @int32 (* REFIID *); 
            ppvObj: @int32 (* void** *); 
         enter (pMk[], pBC[], pBSC[], riid, ppvObj)
         exit result
         #);
       RemoteMonikerBindToStorage:<
         (# result: @int32 (* HRESULT *);
            pMk: ^IMoniker (* *IMoniker *); 
            pBC: ^IBindCtx (* *IBindCtx *); 
            pBSC: ^IBindStatusCallback (* *IBindStatusCallback *); 
            riid: @int32 (* REFIID *); 
            ppvObj: ^IUnknownHolder (* **IUnknown *); 
         enter (pMk[], pBC[], pBSC[], riid, ppvObj[])
         exit result
         #);
       MonikerBindToObject:<
         (# result: @int32 (* HRESULT *);
            pMk: ^IMoniker (* *IMoniker *); 
            pBC: ^IBindCtx (* *IBindCtx *); 
            pBSC: ^IBindStatusCallback (* *IBindStatusCallback *); 
            riid: @int32 (* REFIID *); 
            ppvObj: @int32 (* void** *); 
         enter (pMk[], pBC[], pBSC[], riid, ppvObj)
         exit result
         #);
       RemoteMonikerBindToObject:<
         (# result: @int32 (* HRESULT *);
            pMk: ^IMoniker (* *IMoniker *); 
            pBC: ^IBindCtx (* *IBindCtx *); 
            pBSC: ^IBindStatusCallback (* *IBindStatusCallback *); 
            riid: @int32 (* REFIID *); 
            ppvObj: ^IUnknownHolder (* **IUnknown *); 
         enter (pMk[], pBC[], pBSC[], riid, ppvObj[])
         exit result
         #);
    #);
  (* #endif *)
  (* // These are for backwards compatibility with previous URLMON versions *)
  (* #ifndef _LPIINTERNET *)
  (* #define _LPIINTERNET *)

  IInternet_IID: (# exit '79eac9e0-baf9-11ce-8c82-00aa004ba90b' #);

  IInternet: IUnknown
    (# <<SLOT IInternetLib: attributes>>;
    #);
  (* #endif *)
  (* #ifndef _LPIINTERNETBINDINFO *)
  (* #define _LPIINTERNETBINDINFO *)

  IInternetBindInfo_IID: (# exit '79eac9e1-baf9-11ce-8c82-00aa004ba90b' #);

  IInternetBindInfo: IUnknown
    (# <<SLOT IInternetBindInfoLib: attributes>>;
       GetBindInfo:<
         (# result: @int32 (* HRESULT *);
            grfBINDF: ^int32uHolder (* *DWORD *); 
            pbindinfo: ^struct__tagBINDINFO (* *BINDINFO *); 
         enter (grfBINDF[], pbindinfo[])
         exit result
         #);
       GetBindString:<
         (# result: @int32 (* HRESULT *);
            ulStringType: @int32u (* ULONG *); 
            ppwzStr: ^textHolder (* *LPOLESTR *); 
            cEl: @int32u (* ULONG *); 
            pcElFetched: ^int32uHolder (* *ULONG *); 
         enter (ulStringType, ppwzStr[], cEl, pcElFetched[])
         exit result
         #);
    #);
  BINDSTRING: IntegerObject(# (* enum tagBINDSTRING *) #);
  BINDSTRING_HEADERS: (* BINDSTRING *)(# exit 1 #);
  BINDSTRING_ACCEPT_MIMES: (* BINDSTRING *)(# exit BINDSTRING_HEADERS+1 #);
  BINDSTRING_EXTRA_URL: (* BINDSTRING *)(# exit BINDSTRING_ACCEPT_MIMES+1 #);
  BINDSTRING_LANGUAGE: (* BINDSTRING *)(# exit BINDSTRING_EXTRA_URL+1 #);
  BINDSTRING_USERNAME: (* BINDSTRING *)(# exit BINDSTRING_LANGUAGE+1 #);
  BINDSTRING_PASSWORD: (* BINDSTRING *)(# exit BINDSTRING_USERNAME+1 #);
  BINDSTRING_UA_PIXELS: (* BINDSTRING *)(# exit BINDSTRING_PASSWORD+1 #);
  BINDSTRING_UA_COLOR: (* BINDSTRING *)(# exit BINDSTRING_UA_PIXELS+1 #);
  BINDSTRING_OS: (* BINDSTRING *)(# exit BINDSTRING_UA_COLOR+1 #);
  BINDSTRING_USER_AGENT: (* BINDSTRING *)(# exit BINDSTRING_OS+1 #);
  BINDSTRING_ACCEPT_ENCODINGS: (* BINDSTRING *)(# exit BINDSTRING_USER_AGENT+1 #);
  BINDSTRING_POST_COOKIE: (* BINDSTRING *)(# exit BINDSTRING_ACCEPT_ENCODINGS+1 #);
  BINDSTRING_POST_DATA_MIME: (* BINDSTRING *)(# exit BINDSTRING_POST_COOKIE+1 #);
  BINDSTRING_URL: (* BINDSTRING *)(# exit BINDSTRING_POST_DATA_MIME+1 #);

  (* #endif *)
  (* #ifndef _LPIINTERNETPROTOCOLROOT_DEFINED *)
  (* #define _LPIINTERNETPROTOCOLROOT_DEFINED *)

  IInternetProtocolRoot_IID: (# exit '79eac9e3-baf9-11ce-8c82-00aa004ba90b' #);

  IInternetProtocolRoot: IUnknown
    (# <<SLOT IInternetProtocolRootLib: attributes>>;
       Start:<
         (# result: @int32 (* HRESULT *);
            szUrl: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            pOIProtSink: ^IInternetProtocolSink (* *IInternetProtocolSink *); 
            pOIBindInfo: ^IInternetBindInfo (* *IInternetBindInfo *); 
            grfPI: @int32u (* DWORD *); 
            dwReserved: @int32u (* DWORD *); 
         enter (szUrl, pOIProtSink[], pOIBindInfo[], grfPI, dwReserved)
         exit result
         #);
       Continue:<
         (# result: @int32 (* HRESULT *);
            pProtocolData: ^struct__tagPROTOCOLDATA (* *PROTOCOLDATA *); 
         enter pProtocolData[]
         exit result
         #);
       Abort:<
         (# result: @int32 (* HRESULT *);
            hrReason: @int32 (* HRESULT *); 
            dwOptions: @int32u (* DWORD *); 
         enter (hrReason, dwOptions)
         exit result
         #);
       Terminate:<
         (# result: @int32 (* HRESULT *);
            dwOptions: @int32u (* DWORD *); 
         enter dwOptions
         exit result
         #);
       _Suspend:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       Resume:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
    #);
  PI_FLAGS: IntegerObject(# (* enum _tagPI_FLAGS *) #);
  PI_PARSE_URL: (* PI_FLAGS *)(# exit 0x00000001 #);
  PI_FILTER_MODE: (* PI_FLAGS *)(# exit 0x00000002 #);
  PI_FORCE_ASYNC: (* PI_FLAGS *)(# exit 0x00000004 #);
  PI_USE_WORKERTHREAD: (* PI_FLAGS *)(# exit 0x00000008 #);
  PI_MIMEVERIFICATION: (* PI_FLAGS *)(# exit 0x00000010 #);
  PI_CLSIDLOOKUP: (* PI_FLAGS *)(# exit 0x00000020 #);
  PI_DATAPROGRESS: (* PI_FLAGS *)(# exit 0x00000040 #);
  PI_SYNCHRONOUS: (* PI_FLAGS *)(# exit 0x00000080 #);
  PI_APARTMENTTHREADED: (* PI_FLAGS *)(# exit 0x00000100 #);
  PI_CLASSINSTALL: (* PI_FLAGS *)(# exit 0x00000200 #);
  PD_FORCE_SWITCH: (* PI_FLAGS *)(# exit 0x00010000 #);

  PROTOCOLDATA: struct__tagPROTOCOLDATA(# #);
  struct__tagPROTOCOLDATA: DATA
    (# grfFlags: @int32u (* DWORD *);
       dwState: @int32u (* DWORD *);
       pData: @int32Holder (* *LPVOID *);
       cbData: @int32u (* ULONG *);
    #);
  (* #endif *)
  (* #ifndef _LPIINTERNETPROTOCOL_DEFINED *)
  (* #define _LPIINTERNETPROTOCOL_DEFINED *)

  IInternetProtocol_IID: (# exit '79eac9e4-baf9-11ce-8c82-00aa004ba90b' #);

  IInternetProtocol: IInternetProtocolRoot
    (# <<SLOT IInternetProtocolLib: attributes>>;
       Read:<
         (# result: @int32 (* HRESULT *);
            pv: @int32 (* void* *); 
            cb: @int32u (* ULONG *); 
            pcbRead: ^int32uHolder (* *ULONG *); 
         enter (pv, cb, pcbRead[])
         exit result
         #);
       Seek:<
         (# result: @int32 (* HRESULT *);
            dlibMove: @struct__LARGE_INTEGER (* LARGE_INTEGER *); 
            dwOrigin: @int32u (* DWORD *); 
            plibNewPosition: ^struct__ULARGE_INTEGER (* *ULARGE_INTEGER *); 
         enter (dlibMove, dwOrigin, plibNewPosition[])
         exit result
         #);
       LockRequest:<
         (# result: @int32 (* HRESULT *);
            dwOptions: @int32u (* DWORD *); 
         enter dwOptions
         exit result
         #);
       UnlockRequest:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
    #);
  (* #endif *)
  (* #ifndef _LPIINTERNETPROTOCOLSINK_DEFINED *)
  (* #define _LPIINTERNETPROTOCOLSINK_DEFINED *)

  IInternetProtocolSink_IID: (# exit '79eac9e5-baf9-11ce-8c82-00aa004ba90b' #);

  IInternetProtocolSink: IUnknown
    (# <<SLOT IInternetProtocolSinkLib: attributes>>;
       Switch:<
         (# result: @int32 (* HRESULT *);
            pProtocolData: ^struct__tagPROTOCOLDATA (* *PROTOCOLDATA *); 
         enter pProtocolData[]
         exit result
         #);
       ReportProgress:<
         (# result: @int32 (* HRESULT *);
            ulStatusCode: @int32u (* ULONG *); 
            szStatusText: [0]@char (* ^text NYI *) (* LPCWSTR *); 
         enter (ulStatusCode, szStatusText)
         exit result
         #);
       ReportData:<
         (# result: @int32 (* HRESULT *);
            grfBSCF: @int32u (* DWORD *); 
            ulProgress: @int32u (* ULONG *); 
            ulProgressMax: @int32u (* ULONG *); 
         enter (grfBSCF, ulProgress, ulProgressMax)
         exit result
         #);
       ReportResult:<
         (# result: @int32 (* HRESULT *);
            hrResult: @int32 (* HRESULT *); 
            dwError: @int32u (* DWORD *); 
            szResult: [0]@char (* ^text NYI *) (* LPCWSTR *); 
         enter (hrResult, dwError, szResult)
         exit result
         #);
    #);
  (* #endif *)
  (* #ifndef _LPIINTERNETSESSION_DEFINED *)
  (* #define _LPIINTERNETSESSION_DEFINED *)

  IInternetSession_IID: (# exit '79eac9e7-baf9-11ce-8c82-00aa004ba90b' #);

  IInternetSession: IUnknown
    (# <<SLOT IInternetSessionLib: attributes>>;
       RegisterNameSpace:<
         (# result: @int32 (* HRESULT *);
            pCF: ^IClassFactory (* *IClassFactory *); 
            rclsid: @int32 (* REFCLSID *); 
            pwzProtocol: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            cPatterns: @int32u (* ULONG *); 
            ppwzPatterns: ^textHolder (* *LPCWSTR *); 
            dwReserved: @int32u (* DWORD *); 
         enter (pCF[], rclsid, pwzProtocol, cPatterns, ppwzPatterns[], dwReserved)
         exit result
         #);
       UnregisterNameSpace:<
         (# result: @int32 (* HRESULT *);
            pCF: ^IClassFactory (* *IClassFactory *); 
            pszProtocol: [0]@char (* ^text NYI *) (* LPCWSTR *); 
         enter (pCF[], pszProtocol)
         exit result
         #);
       RegisterMimeFilter:<
         (# result: @int32 (* HRESULT *);
            pCF: ^IClassFactory (* *IClassFactory *); 
            rclsid: @int32 (* REFCLSID *); 
            pwzType: [0]@char (* ^text NYI *) (* LPCWSTR *); 
         enter (pCF[], rclsid, pwzType)
         exit result
         #);
       UnregisterMimeFilter:<
         (# result: @int32 (* HRESULT *);
            pCF: ^IClassFactory (* *IClassFactory *); 
            pwzType: [0]@char (* ^text NYI *) (* LPCWSTR *); 
         enter (pCF[], pwzType)
         exit result
         #);
       CreateBinding:<
         (# result: @int32 (* HRESULT *);
            pBC: ^IBindCtx (* LPBC *); 
            szUrl: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            pUnkOuter: ^IUnknown (* *IUnknown *); 
            ppUnk: ^IUnknownHolder (* **IUnknown *); 
            ppOInetProt: ^IInternetProtocolHolder (* **IInternetProtocol *); 
            dwOption: @int32u (* DWORD *); 
         enter (pBC[], szUrl, pUnkOuter[], ppUnk[], ppOInetProt[], dwOption)
         exit result
         #);
       SetSessionOption:<
         (# result: @int32 (* HRESULT *);
            dwOption: @int32u (* DWORD *); 
            pBuffer: ^int32Holder (* LPVOID *); 
            dwBufferLength: @int32u (* DWORD *); 
            dwReserved: @int32u (* DWORD *); 
         enter (dwOption, pBuffer[], dwBufferLength, dwReserved)
         exit result
         #);
       GetSessionOption:<
         (# result: @int32 (* HRESULT *);
            dwOption: @int32u (* DWORD *); 
            pBuffer: ^int32Holder (* LPVOID *); 
            pdwBufferLength: ^int32uHolder (* *DWORD *); 
            dwReserved: @int32u (* DWORD *); 
         enter (dwOption, pBuffer[], pdwBufferLength[], dwReserved)
         exit result
         #);
    #);
  OIBDG_FLAGS: IntegerObject(# (* enum _tagOIBDG_FLAGS *) #);
  OIBDG_APARTMENTTHREADED: (* OIBDG_FLAGS *)(# exit 0x00000100 #);

  (* #endif *)
  (* #ifndef _LPIINTERNETTHREADSWITCH_DEFINED *)
  (* #define _LPIINTERNETTHREADSWITCH_DEFINED *)

  IInternetThreadSwitch_IID: (# exit '79eac9e8-baf9-11ce-8c82-00aa004ba90b' #);

  IInternetThreadSwitch: IUnknown
    (# <<SLOT IInternetThreadSwitchLib: attributes>>;
       Prepare:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
       Continue:<
         (# result: @int32 (* HRESULT *);
         exit result
         #);
    #);
  (* #endif *)
  (* #ifndef _LPIINTERNETPRIORITY_DEFINED *)
  (* #define _LPIINTERNETPRIORITY_DEFINED *)

  IInternetPriority_IID: (# exit '79eac9eb-baf9-11ce-8c82-00aa004ba90b' #);

  IInternetPriority: IUnknown
    (# <<SLOT IInternetPriorityLib: attributes>>;
       SetPriority:<
         (# result: @int32 (* HRESULT *);
            nPriority: @int32 (* LONG *); 
         enter nPriority
         exit result
         #);
       GetPriority:<
         (# result: @int32 (* HRESULT *);
            pnPriority: ^int32Holder (* *LONG *); 
         enter pnPriority[]
         exit result
         #);
    #);
  (* #endif *)
  (* #ifndef _LPIINTERNETPROTOCOLINFO_DEFINED *)
  (* #define _LPIINTERNETPROTOCOLINFO_DEFINED *)

  IInternetProtocolInfo_IID: (# exit '79eac9ec-baf9-11ce-8c82-00aa004ba90b' #);

  IInternetProtocolInfo: IUnknown
    (# <<SLOT IInternetProtocolInfoLib: attributes>>;
       ParseUrl:<
         (# result: @int32 (* HRESULT *);
            pwzUrl: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            ParseAction: @int32 (* PARSEACTION *); 
            dwParseFlags: @int32u (* DWORD *); 
            pwzResult: [0]@char (* ^text NYI *) (* LPWSTR *); 
            cchResult: @int32u (* DWORD *); 
            pcchResult: ^int32uHolder (* *DWORD *); 
            dwReserved: @int32u (* DWORD *); 
         enter (pwzUrl, ParseAction, dwParseFlags, pwzResult, cchResult, pcchResult[], dwReserved)
         exit result
         #);
       CombineUrl:<
         (# result: @int32 (* HRESULT *);
            pwzBaseUrl: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            pwzRelativeUrl: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            dwCombineFlags: @int32u (* DWORD *); 
            pwzResult: [0]@char (* ^text NYI *) (* LPWSTR *); 
            cchResult: @int32u (* DWORD *); 
            pcchResult: ^int32uHolder (* *DWORD *); 
            dwReserved: @int32u (* DWORD *); 
         enter (pwzBaseUrl, pwzRelativeUrl, dwCombineFlags, pwzResult, cchResult, pcchResult[], dwReserved)
         exit result
         #);
       CompareUrl:<
         (# result: @int32 (* HRESULT *);
            pwzUrl1: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            pwzUrl2: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            dwCompareFlags: @int32u (* DWORD *); 
         enter (pwzUrl1, pwzUrl2, dwCompareFlags)
         exit result
         #);
       QueryInfo:<
         (# result: @int32 (* HRESULT *);
            pwzUrl: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            OueryOption: @int32 (* QUERYOPTION *); 
            dwQueryFlags: @int32u (* DWORD *); 
            pBuffer: ^int32Holder (* LPVOID *); 
            cbBuffer: @int32u (* DWORD *); 
            pcbBuf: ^int32uHolder (* *DWORD *); 
            dwReserved: @int32u (* DWORD *); 
         enter (pwzUrl, OueryOption, dwQueryFlags, pBuffer[], cbBuffer, pcbBuf[], dwReserved)
         exit result
         #);
    #);
  PARSEACTION: IntegerObject(# (* enum _tagPARSEACTION *) #);
  PARSE_CANONICALIZE: (* PARSEACTION *)(# exit 1 #);
  PARSE_FRIENDLY: (* PARSEACTION *)(# exit PARSE_CANONICALIZE+1 #);
  PARSE_SECURITY_URL: (* PARSEACTION *)(# exit PARSE_FRIENDLY+1 #);
  PARSE_ROOTDOCUMENT: (* PARSEACTION *)(# exit PARSE_SECURITY_URL+1 #);
  PARSE_DOCUMENT: (* PARSEACTION *)(# exit PARSE_ROOTDOCUMENT+1 #);
  PARSE_ANCHOR: (* PARSEACTION *)(# exit PARSE_DOCUMENT+1 #);
  PARSE_ENCODE: (* PARSEACTION *)(# exit PARSE_ANCHOR+1 #);
  PARSE_DECODE: (* PARSEACTION *)(# exit PARSE_ENCODE+1 #);
  PARSE_PATH_FROM_URL: (* PARSEACTION *)(# exit PARSE_DECODE+1 #);
  PARSE_URL_FROM_PATH: (* PARSEACTION *)(# exit PARSE_PATH_FROM_URL+1 #);
  PARSE_MIME: (* PARSEACTION *)(# exit PARSE_URL_FROM_PATH+1 #);
  PARSE_SERVER: (* PARSEACTION *)(# exit PARSE_MIME+1 #);
  PARSE_SCHEMA: (* PARSEACTION *)(# exit PARSE_SERVER+1 #);
  PARSE_SITE: (* PARSEACTION *)(# exit PARSE_SCHEMA+1 #);
  PARSE_DOMAIN: (* PARSEACTION *)(# exit PARSE_SITE+1 #);
  PARSE_LOCATION: (* PARSEACTION *)(# exit PARSE_DOMAIN+1 #);
  PARSE_SECURITY_DOMAIN: (* PARSEACTION *)(# exit PARSE_LOCATION+1 #);

  PSUACTION: IntegerObject(# (* enum _tagPSUACTION *) #);
  PSU_DEFAULT: (* PSUACTION *)(# exit 1 #);
  PSU_SECURITY_URL_ONLY: (* PSUACTION *)(# exit PSU_DEFAULT+1 #);

  QUERYOPTION: IntegerObject(# (* enum _tagQUERYOPTION *) #);
  QUERY_EXPIRATION_DATE: (* QUERYOPTION *)(# exit 1 #);
  QUERY_TIME_OF_LAST_CHANGE: (* QUERYOPTION *)(# exit QUERY_EXPIRATION_DATE+1 #);
  QUERY_CONTENT_ENCODING: (* QUERYOPTION *)(# exit QUERY_TIME_OF_LAST_CHANGE+1 #);
  QUERY_CONTENT_TYPE: (* QUERYOPTION *)(# exit QUERY_CONTENT_ENCODING+1 #);
  QUERY_REFRESH: (* QUERYOPTION *)(# exit QUERY_CONTENT_TYPE+1 #);
  QUERY_RECOMBINE: (* QUERYOPTION *)(# exit QUERY_REFRESH+1 #);
  QUERY_CAN_NAVIGATE: (* QUERYOPTION *)(# exit QUERY_RECOMBINE+1 #);
  QUERY_USES_NETWORK: (* QUERYOPTION *)(# exit QUERY_CAN_NAVIGATE+1 #);
  QUERY_IS_CACHED: (* QUERYOPTION *)(# exit QUERY_USES_NETWORK+1 #);
  QUERY_IS_INSTALLEDENTRY: (* QUERYOPTION *)(# exit QUERY_IS_CACHED+1 #);
  QUERY_IS_CACHED_OR_MAPPED: (* QUERYOPTION *)(# exit QUERY_IS_INSTALLEDENTRY+1 #);
  QUERY_USES_CACHE: (* QUERYOPTION *)(# exit QUERY_IS_CACHED_OR_MAPPED+1 #);

  (* #endif *)
  (* #define IOInet               IInternet             *)
  (* #define IOInetBindInfo       IInternetBindInfo     *)
  (* #define IOInetProtocolRoot   IInternetProtocolRoot *)
  (* #define IOInetProtocol       IInternetProtocol     *)
  (* #define IOInetProtocolSink   IInternetProtocolSink *)
  (* #define IOInetProtocolInfo   IInternetProtocolInfo *)
  (* #define IOInetSession        IInternetSession      *)
  (* #define IOInetPriority       IInternetPriority     *)
  (* #define IOInetThreadSwitch   IInternetThreadSwitch *)
  (* #define LPOINET              LPIINTERNET              *)
  (* #define LPOINETPROTOCOLINFO  LPIINTERNETPROTOCOLINFO  *)
  (* #define LPOINETBINDINFO      LPIINTERNETBINDINFO      *)
  (* #define LPOINETPROTOCOLROOT  LPIINTERNETPROTOCOLROOT  *)
  (* #define LPOINETPROTOCOL      LPIINTERNETPROTOCOL      *)
  (* #define LPOINETPROTOCOLSINK  LPIINTERNETPROTOCOLSINK  *)
  (* #define LPOINETSESSION       LPIINTERNETSESSION       *)
  (* #define LPOINETTHREADSWITCH  LPIINTERNETTHREADSWITCH  *)
  (* #define LPOINETPRIORITY      LPIINTERNETPRIORITY      *)
  (* #define LPOINETPROTOCOLINFO  LPIINTERNETPROTOCOLINFO  *)
  (* #define IID_IOInet               IID_IInternet             *)
  (* #define IID_IOInetBindInfo       IID_IInternetBindInfo     *)
  (* #define IID_IOInetProtocolRoot   IID_IInternetProtocolRoot *)
  (* #define IID_IOInetProtocol       IID_IInternetProtocol     *)
  (* #define IID_IOInetProtocolSink   IID_IInternetProtocolSink *)
  (* #define IID_IOInetProtocolInfo   IID_IInternetProtocolInfo *)
  (* #define IID_IOInetSession        IID_IInternetSession      *)
  (* #define IID_IOInetPriority       IID_IInternetPriority     *)
  (* #define IID_IOInetThreadSwitch   IID_IInternetThreadSwitch *)
  (* #define INET_E_USE_DEFAULT_PROTOCOLHANDLER _HRESULT_TYPEDEF_(0x800C0011L)       *)
  (* #define INET_E_USE_DEFAULT_SETTING         _HRESULT_TYPEDEF_(0x800C0012L)       *)
  (* #define INET_E_DEFAULT_ACTION              INET_E_USE_DEFAULT_PROTOCOLHANDLER   *)
  (* #define INET_E_QUERYOPTION_UNKNOWN         _HRESULT_TYPEDEF_(0x800C0013L)       *)
  (* #define INET_E_REDIRECTING                 _HRESULT_TYPEDEF_(0x800C0014L)       *)
  (* #define OInetParseUrl               CoInternetParseUrl                *)
  (* #define OInetCombineUrl             CoInternetCombineUrl              *)
  (* #define OInetCompareUrl             CoInternetCompareUrl              *)
  (* #define OInetQueryInfo              CoInternetQueryInfo               *)
  (* #define OInetGetSession             CoInternetGetSession              *)
  (* // *)
  (* // Static Protocol flags *)
  (* // *)
  (* #define PROTOCOLFLAG_NO_PICS_CHECK     0x00000001 *)
  (*  *)
  (* // Creates the security manager object. The first argument is the Service provider *)
  (* // to allow for delegation *)
  (* STDAPI CoInternetCreateSecurityManager(IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved); *)
  (*  *)
  (* STDAPI CoInternetCreateZoneManager(IServiceProvider *pSP, IInternetZoneManager **ppZM, DWORD dwReserved); *)
  (*  *)
  (*  *)
  (* // Security manager CLSID's *)
  (* EXTERN_C const IID CLSID_InternetSecurityManager;   *)
  (* EXTERN_C const IID CLSID_InternetZoneManager;   *)
  (* // This service is used for delegation support on the Security Manager interface *)
  (* #define SID_SInternetSecurityManager         IID_IInternetSecurityManager *)
  (*  *)
  (* #define SID_SInternetHostSecurityManager     IID_IInternetHostSecurityManager *)
  (*  *)
  (* #ifndef _LPINTERNETSECURITYMGRSITE_DEFINED *)
  (* #define _LPINTERNETSECURITYMGRSITE_DEFINED *)

  IInternetSecurityMgrSite_IID: (# exit '79eac9ed-baf9-11ce-8c82-00aa004ba90b' #);

  IInternetSecurityMgrSite: IUnknown
    (* IInternetSecurityMgrSite Interface *)
    (# <<SLOT IInternetSecurityMgrSiteLib: attributes>>;
       GetWindow:<
         (# result: @int32 (* HRESULT *);
            phwnd: ^int32Holder (* *HWND *); 
         enter phwnd[]
         exit result
         #);
       EnableModeless:<
         (# result: @int32 (* HRESULT *);
            fEnable: @int32 (* BOOL *); 
         enter fEnable
         exit result
         #);
    #);
  (* #endif *)
  (* #ifndef _LPINTERNETSECURITYMANANGER_DEFINED *)
  (* #define _LPINTERNETSECURITYMANANGER_DEFINED *)

  IInternetSecurityManager_IID: (# exit '79eac9ee-baf9-11ce-8c82-00aa004ba90b' #);

  IInternetSecurityManager: IUnknown
    (* IInternetSecurityManager Interface *)
    (# <<SLOT IInternetSecurityManagerLib: attributes>>;
       SetSecuritySite:<
         (# result: @int32 (* HRESULT *);
            pSite: ^IInternetSecurityMgrSite (* *IInternetSecurityMgrSite *); 
         enter pSite[]
         exit result
         #);
       GetSecuritySite:<
         (# result: @int32 (* HRESULT *);
            ppSite: ^IInternetSecurityMgrSiteHolder (* **IInternetSecurityMgrSite *); 
         enter ppSite[]
         exit result
         #);
       MapUrlToZone:<
         (# result: @int32 (* HRESULT *);
            pwszUrl: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            pdwZone: ^int32uHolder (* *DWORD *); 
            dwFlags: @int32u (* DWORD *); 
         enter (pwszUrl, pdwZone[], dwFlags)
         exit result
         #);
       (* // MapUrlToZone returns the zone index given a URL *)
       (* #define MAX_SIZE_SECURITY_ID 512 // bytes *)
       GetSecurityId:<
         (# result: @int32 (* HRESULT *);
            pwszUrl: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            pbSecurityId: ^int8uHolder (* *BYTE *); 
            pcbSecurityId: ^int32uHolder (* *DWORD *); 
            dwReserved: @int32u (* DWORD *); 
         enter (pwszUrl, pbSecurityId[], pcbSecurityId[], dwReserved)
         exit result
         #);
       ProcessUrlAction:<
         (# result: @int32 (* HRESULT *);
            pwszUrl: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            dwAction: @int32u (* DWORD *); 
            pPolicy: ^int8uHolder (* *BYTE *); 
            cbPolicy: @int32u (* DWORD *); 
            pContext: ^int8uHolder (* *BYTE *); 
            cbContext: @int32u (* DWORD *); 
            dwFlags: @int32u (* DWORD *); 
            dwReserved: @int32u (* DWORD *); 
         enter (pwszUrl, dwAction, pPolicy[], cbPolicy, pContext[], cbContext, dwFlags, dwReserved)
         exit result
         #);
       (* // This is the wrapper function that most clients will use. *)
       (* // It figures out the current Policy for the passed in Action, *)
       (* // and puts up UI if the current Policy indicates that the user *)
       (* // should be queried. It returns back the Policy which the caller *)
       (* // will use to determine if the action should be allowed *)
       QueryCustomPolicy:<
         (# result: @int32 (* HRESULT *);
            pwszUrl: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            guidKey: @int32 (* REFGUID *); 
            ppPolicy: ^int8uHolder (* **BYTE *); 
            pcbPolicy: ^int32uHolder (* *DWORD *); 
            pContext: ^int8uHolder (* *BYTE *); 
            cbContext: @int32u (* DWORD *); 
            dwReserved: @int32u (* DWORD *); 
         enter (pwszUrl, guidKey, ppPolicy[], pcbPolicy[], pContext[], cbContext, dwReserved)
         exit result
         #);
       (* // This is the wrapper function to conveniently read a custom policy. *)
       SetZoneMapping:<
         (# result: @int32 (* HRESULT *);
            dwZone: @int32u (* DWORD *); 
            lpszPattern: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            dwFlags: @int32u (* DWORD *); 
         enter (dwZone, lpszPattern, dwFlags)
         exit result
         #);
       (* // SetZoneMapping *)
       (* //    lpszPattern: string denoting a URL pattern *)
       (* //        Examples of valid patterns:    *)
       (* //            *://*.msn.com              *)
       (* //            http://*.sony.co.jp        *)
       (* //            *://et.msn.com             *)
       (* //            ftp://157.54.23.41/        *)
       (* //            https://localsvr           *)
       (* //            file:\\localsvr\share      *)
       (* //            *://157.54.100-200.*       *)
       (* //        Examples of invalid patterns:  *)
       (* //            http://*.lcs.mit.edu       *)
       (* //            ftp://*                    *)
       (* //    dwFlags: SZM_FLAGS values          *)
       GetZoneMappings:<
         (# result: @int32 (* HRESULT *);
            dwZone: @int32u (* DWORD *); 
            ppenumString: ^IEnumStringHolder (* **IEnumString *); 
            dwFlags: @int32u (* DWORD *); 
         enter (dwZone, ppenumString[], dwFlags)
         exit result
         #);
    #);
  PUAF: IntegerObject(# #);
  PUAF_DEFAULT: (* PUAF *)(# exit 0x00000000 #);
  PUAF_NOUI: (* PUAF *)(# exit 0x00000001 #);
  PUAF_ISFILE: (* PUAF *)(# exit 0x00000002 #);
  PUAF_WARN_IF_DENIED: (* PUAF *)(# exit 0x00000004 #);
  PUAF_FORCEUI_FOREGROUND: (* PUAF *)(# exit 0x00000008 #);
  PUAF_CHECK_TIFS: (* PUAF *)(# exit 0x00000010 #);

  SZM_FLAGS: IntegerObject(# #);
  SZM_CREATE: (* SZM_FLAGS *)(# exit 0x00000000 #);
  SZM_DELETE: (* SZM_FLAGS *)(# exit 0x00000001 #);

  (* #endif *)
  (* #ifndef _LPINTERNETHOSTSECURITYMANANGER_DEFINED *)
  (* #define _LPINTERNETHOSTSECURITYMANANGER_DEFINED *)
  (* //This is the interface MSHTML exposes to its clients *)
  (* //The clients need not pass in a URL to these functions *)
  (* //since MSHTML maintains the notion of the current URL *)

  IInternetHostSecurityManager_IID: (# exit '3af280b6-cb3f-11d0-891e-00c04fb6bfc4' #);

  IInternetHostSecurityManager: IUnknown
    (* IInternetHostSecurityManager Interface *)
    (# <<SLOT IInternetHostSecurityManagerLib: attributes>>;
       GetSecurityId:<
         (# result: @int32 (* HRESULT *);
            pbSecurityId: ^int8uHolder (* *BYTE *); 
            pcbSecurityId: ^int32uHolder (* *DWORD *); 
            dwReserved: @int32u (* DWORD *); 
         enter (pbSecurityId[], pcbSecurityId[], dwReserved)
         exit result
         #);
       ProcessUrlAction:<
         (# result: @int32 (* HRESULT *);
            dwAction: @int32u (* DWORD *); 
            pPolicy: ^int8uHolder (* *BYTE *); 
            cbPolicy: @int32u (* DWORD *); 
            pContext: ^int8uHolder (* *BYTE *); 
            cbContext: @int32u (* DWORD *); 
            dwFlags: @int32u (* DWORD *); 
            dwReserved: @int32u (* DWORD *); 
         enter (dwAction, pPolicy[], cbPolicy, pContext[], cbContext, dwFlags, dwReserved)
         exit result
         #);
       QueryCustomPolicy:<
         (# result: @int32 (* HRESULT *);
            guidKey: @int32 (* REFGUID *); 
            ppPolicy: ^int8uHolder (* **BYTE *); 
            pcbPolicy: ^int32uHolder (* *DWORD *); 
            pContext: ^int8uHolder (* *BYTE *); 
            cbContext: @int32u (* DWORD *); 
            dwReserved: @int32u (* DWORD *); 
         enter (guidKey, ppPolicy[], pcbPolicy[], pContext[], cbContext, dwReserved)
         exit result
         #);
    #);
  (* #endif *)
  (*  *)
  (* // The zone manager maintains policies for a set of standard actions.  *)
  (* // These actions are identified by integral values (called action indexes) *)
  (* // specified below. *)
  (*  *)
  (* // Minimum legal value for an action     *)
  (* #define URLACTION_MIN                                          0x00001000 *)
  (*  *)
  (* #define URLACTION_DOWNLOAD_MIN                                 0x00001000 *)
  (* #define URLACTION_DOWNLOAD_SIGNED_ACTIVEX                      0x00001001 *)
  (* #define URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX                    0x00001004 *)
  (* #define URLACTION_DOWNLOAD_CURR_MAX                            0x00001004 *)
  (* #define URLACTION_DOWNLOAD_MAX                                 0x000011FF *)
  (*  *)
  (* #define URLACTION_ACTIVEX_MIN                                  0x00001200 *)
  (* #define URLACTION_ACTIVEX_RUN                                  0x00001200 *)
  (* #define URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY               0x00001201 // aggregate next four *)
  (* #define URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY                 0x00001202 // *)
  (* #define URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY               0x00001203 // *)
  (* #define URLACTION_SCRIPT_OVERRIDE_SAFETY                       0x00001401 // *)
  (* #define URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY               0x00001204 // *)
  (* #define URLACTION_ACTIVEX_TREATASUNTRUSTED                     0x00001205 *)
  (* #define URLACTION_ACTIVEX_CURR_MAX                             0x00001205 *)
  (* #define URLACTION_ACTIVEX_MAX                                  0x000013ff *)
  (*  *)
  (* #define URLACTION_SCRIPT_MIN                                   0x00001400 *)
  (* #define URLACTION_SCRIPT_RUN                                   0x00001400 *)
  (* #define URLACTION_SCRIPT_JAVA_USE                              0x00001402 *)
  (* #define URLACTION_SCRIPT_SAFE_ACTIVEX                          0x00001405 *)
  (* #define URLACTION_SCRIPT_CURR_MAX                              0x00001405 *)
  (* #define URLACTION_SCRIPT_MAX                                   0x000015ff *)
  (*  *)
  (* #define URLACTION_HTML_MIN                                     0x00001600 *)
  (* #define URLACTION_HTML_SUBMIT_FORMS                            0x00001601 // aggregate next two *)
  (* #define URLACTION_HTML_SUBMIT_FORMS_FROM                       0x00001602 // *)
  (* #define URLACTION_HTML_SUBMIT_FORMS_TO                         0x00001603 // *)
  (* #define URLACTION_HTML_FONT_DOWNLOAD                           0x00001604 *)
  (* #define URLACTION_HTML_JAVA_RUN                                0x00001605 // derive from Java custom policy *)
  (* #define URLACTION_HTML_CURR_MAX                                0x00001605 *)
  (* #define URLACTION_HTML_MAX                                     0x000017ff *)
  (*  *)
  (* #define URLACTION_SHELL_MIN                                    0x00001800 *)
  (* #define URLACTION_SHELL_INSTALL_DTITEMS                        0x00001800 *)
  (* #define URLACTION_SHELL_MOVE_OR_COPY                           0x00001802 *)
  (* #define URLACTION_SHELL_FILE_DOWNLOAD                          0x00001803 *)
  (* #define URLACTION_SHELL_VERB                                   0x00001804 *)
  (* #define URLACTION_SHELL_WEBVIEW_VERB                           0x00001805 *)
  (* #define URLACTION_SHELL_CURR_MAX                               0x00001805 *)
  (* #define URLACTION_SHELL_MAX                                    0x000019ff *)
  (*  *)
  (* #define URLACTION_NETWORK_MIN                                  0x00001A00 *)
  (*  *)
  (* #define URLACTION_CREDENTIALS_USE                              0x00001A00 *)
  (* #define URLPOLICY_CREDENTIALS_SILENT_LOGON_OK        0x00000000 *)
  (* #define URLPOLICY_CREDENTIALS_MUST_PROMPT_USER       0x00010000 *)
  (* #define URLPOLICY_CREDENTIALS_CONDITIONAL_PROMPT     0x00020000 *)
  (* #define URLPOLICY_CREDENTIALS_ANONYMOUS_ONLY         0x00030000 *)
  (*  *)
  (* #define URLACTION_AUTHENTICATE_CLIENT                          0x00001A01 *)
  (* #define URLPOLICY_AUTHENTICATE_CLEARTEXT_OK          0x00000000 *)
  (* #define URLPOLICY_AUTHENTICATE_CHALLENGE_RESPONSE    0x00010000 *)
  (* #define URLPOLICY_AUTHENTICATE_MUTUAL_ONLY           0x00030000 *)
  (*  *)
  (*  *)
  (* #define URLACTION_NETWORK_CURR_MAX                             0x00001A01 *)
  (* #define URLACTION_NETWORK_MAX                                  0x00001Bff *)
  (*  *)
  (*  *)
  (* #define URLACTION_JAVA_MIN                                     0x00001C00 *)
  (* #define URLACTION_JAVA_PERMISSIONS                             0x00001C00 *)
  (* #define URLPOLICY_JAVA_PROHIBIT                      0x00000000 *)
  (* #define URLPOLICY_JAVA_HIGH                          0x00010000 *)
  (* #define URLPOLICY_JAVA_MEDIUM                        0x00020000 *)
  (* #define URLPOLICY_JAVA_LOW                           0x00030000 *)
  (* #define URLPOLICY_JAVA_CUSTOM                        0x00800000 *)
  (* #define URLACTION_JAVA_CURR_MAX                                0x00001C00 *)
  (* #define URLACTION_JAVA_MAX                                     0x00001Cff *)
  (*  *)
  (*  *)
  (* // The following Infodelivery actions should have no default policies *)
  (* // in the registry.  They assume that no default policy means fall *)
  (* // back to the global restriction.  If an admin sets a policy per *)
  (* // zone, then it overrides the global restriction. *)
  (*  *)
  (* #define URLACTION_INFODELIVERY_MIN                           0x00001D00 *)
  (* #define URLACTION_INFODELIVERY_NO_ADDING_CHANNELS            0x00001D00 *)
  (* #define URLACTION_INFODELIVERY_NO_EDITING_CHANNELS           0x00001D01 *)
  (* #define URLACTION_INFODELIVERY_NO_REMOVING_CHANNELS          0x00001D02 *)
  (* #define URLACTION_INFODELIVERY_NO_ADDING_SUBSCRIPTIONS       0x00001D03 *)
  (* #define URLACTION_INFODELIVERY_NO_EDITING_SUBSCRIPTIONS      0x00001D04 *)
  (* #define URLACTION_INFODELIVERY_NO_REMOVING_SUBSCRIPTIONS     0x00001D05 *)
  (* #define URLACTION_INFODELIVERY_NO_CHANNEL_LOGGING            0x00001D06 *)
  (* #define URLACTION_INFODELIVERY_CURR_MAX                      0x00001D06 *)
  (* #define URLACTION_INFODELIVERY_MAX                           0x00001Dff *)
  (* #define URLACTION_CHANNEL_SOFTDIST_MIN                       0x00001E00 *)
  (* #define URLACTION_CHANNEL_SOFTDIST_PERMISSIONS               0x00001E05 *)
  (* #define URLPOLICY_CHANNEL_SOFTDIST_PROHIBIT          0x00010000 *)
  (* #define URLPOLICY_CHANNEL_SOFTDIST_PRECACHE          0x00020000 *)
  (* #define URLPOLICY_CHANNEL_SOFTDIST_AUTOINSTALL       0x00030000 *)
  (* #define URLACTION_CHANNEL_SOFTDIST_MAX                       0x00001Eff *)
  (*  *)
  (* // For each action specified above the system maintains *)
  (* // a set of policies for the action.  *)
  (* // The only policies supported currently are permissions (i.e. is something allowed) *)
  (* // and logging status.  *)
  (* // IMPORTANT: If you are defining your own policies don't overload the meaning of the *)
  (* // loword of the policy. You can use the hiword to store any policy bits which are only *)
  (* // meaningful to your action. *)
  (* // For an example of how to do this look at the URLPOLICY_JAVA above *)
  (*  *)
  (* // Permissions  *)
  (* #define URLPOLICY_ALLOW                0x00 *)
  (* #define URLPOLICY_QUERY                0x01 *)
  (* #define URLPOLICY_DISALLOW             0x03 *)
  (*  *)
  (* // Notifications are not done when user already queried. *)
  (* #define URLPOLICY_NOTIFY_ON_ALLOW      0x10 *)
  (* #define URLPOLICY_NOTIFY_ON_DISALLOW   0x20 *)
  (*  *)
  (* // Logging is done regardless of whether user was queried. *)
  (* #define URLPOLICY_LOG_ON_ALLOW         0x40 *)
  (* #define URLPOLICY_LOG_ON_DISALLOW      0x80 *)
  (*  *)
  (* #define URLPOLICY_MASK_PERMISSIONS     0x0f *)
  (* #define GetUrlPolicyPermissions(dw)        (dw & URLPOLICY_MASK_PERMISSIONS) *)
  (* #define SetUrlPolicyPermissions(dw,dw2)    ((dw) = ((dw) & ~(URLPOLICY_MASK_PERMISSIONS)) | (dw2)) *)
  (*  *)
  (*  *)
  (* // The ordinal #'s that define the predefined zones internet explorer knows about.  *)
  (* // When we support user-defined zones their zone numbers should be between  *)
  (* // URLZONE_USER_MIN and URLZONE_USER_MAX *)
  (* #ifndef _LPINTERNETZONEMANAGER_DEFINED *)
  (* #define _LPINTERNETZONEMANAGER_DEFINED *)

  IInternetZoneManager_IID: (# exit '79eac9ef-baf9-11ce-8c82-00aa004ba90b' #);

  IInternetZoneManager: IUnknown
    (* IInternetZoneManager Interface *)
    (# <<SLOT IInternetZoneManagerLib: attributes>>;
       GetZoneAttributes:<
         (# result: @int32 (* HRESULT *);
            dwZone: @int32u (* DWORD *); 
            pZoneAttributes: ^struct__ZONEATTRIBUTES (* *ZONEATTRIBUTES *); 
         enter (dwZone, pZoneAttributes[])
         exit result
         #);
       (* // Gets the zone attributes (information in registry other than actual security *)
       (* // policies associated with the zone).  Zone attributes are fixed as: *)
       SetZoneAttributes:<
         (# result: @int32 (* HRESULT *);
            dwZone: @int32u (* DWORD *); 
            pZoneAttributes: ^struct__ZONEATTRIBUTES (* *ZONEATTRIBUTES *); 
         enter (dwZone, pZoneAttributes[])
         exit result
         #);
       (* // Sets the zone attributes (information in registry other than actual security *)
       (* // policies associated with the zone).  Zone attributes as above. *)
       (* // Returns S_OK or ??? if failed to write the zone attributes. *)
       (* /* Registry Flags *)
       (*  *)
       (*     When reading, default behavior is: *)
       (*         If HKLM allows override and HKCU value exists *)
       (*             Then use HKCU value *)
       (*             Else use HKLM value *)
       (*     When writing, default behavior is same as HKCU *)
       (*         If HKLM allows override *)
       (*            Then Write to HKCU *)
       (*            Else Fail *)
       (* */ *)
       GetZoneCustomPolicy:<
         (# result: @int32 (* HRESULT *);
            dwZone: @int32u (* DWORD *); 
            guidKey: @int32 (* REFGUID *); 
            ppPolicy: ^int8uHolder (* **BYTE *); 
            pcbPolicy: ^int32uHolder (* *DWORD *); 
            urlZoneReg: @int32 (* URLZONEREG *); 
         enter (dwZone, guidKey, ppPolicy[], pcbPolicy[], urlZoneReg)
         exit result
         #);
       (* // Gets a named custom policy associated with a zone; *)
       (* // e.g. the Java VM settings can be defined with a unique key such as 'Java'. *)
       (* // Custom policy support is intended to allow extensibility from the predefined *)
       (* // set of policies that IE4 has built in. *)
       (* //  *)
       (* // pwszKey is the string name designating the custom policy.  Components are *)
       (* //   responsible for having unique names. *)
       (* // ppPolicy is the callee allocated buffer for the policy byte blob; caller is *)
       (* //   responsible for freeing this buffer eventually. *)
       (* // pcbPolicy is the size of the byte blob returned. *)
       (* // dwRegFlags determines how registry is accessed (see above). *)
       (* // Returns S_OK if key is found and buffer allocated; ??? if key is not found (no buffer alloced). *)
       SetZoneCustomPolicy:<
         (# result: @int32 (* HRESULT *);
            dwZone: @int32u (* DWORD *); 
            guidKey: @int32 (* REFGUID *); 
            pPolicy: ^int8uHolder (* *BYTE *); 
            cbPolicy: @int32u (* DWORD *); 
            urlZoneReg: @int32 (* URLZONEREG *); 
         enter (dwZone, guidKey, pPolicy[], cbPolicy, urlZoneReg)
         exit result
         #);
       (* // Sets a named custom policy associated with a zone; *)
       (* // e.g. the Java VM settings can be defined with a unique key such as 'Java'. *)
       (* // Custom policy support is intended to allow extensibility from the predefined *)
       (* // set of policies that IE4 has built in.   *)
       (* //  *)
       (* // pwszKey is the string name designating the custom policy.  Components are *)
       (* //   responsible for having unique names. *)
       (* // ppPolicy is the caller allocated buffer for the policy byte blob. *)
       (* // pcbPolicy is the size of the byte blob to be set. *)
       (* // dwRegFlags determines if HTCU or HKLM is set. *)
       (* // Returns S_OK or ??? if failed to write the zone custom policy. *)
       GetZoneActionPolicy:<
         (# result: @int32 (* HRESULT *);
            dwZone: @int32u (* DWORD *); 
            dwAction: @int32u (* DWORD *); 
            pPolicy: ^int8uHolder (* *BYTE *); 
            cbPolicy: @int32u (* DWORD *); 
            urlZoneReg: @int32 (* URLZONEREG *); 
         enter (dwZone, dwAction, pPolicy[], cbPolicy, urlZoneReg)
         exit result
         #);
       (* // Gets action policy associated with a zone, the builtin, fixed-length policies info. *)
       (*  *)
       (* // dwAction is the action code for the action as defined above. *)
       (* // pPolicy is the caller allocated buffer for the policy data. *)
       (* // cbPolicy is the size of the caller allocated buffer. *)
       (* // dwRegFlags determines how registry is accessed (see above). *)
       (* // Returns S_OK if action is valid; ??? if action is not valid. *)
       SetZoneActionPolicy:<
         (# result: @int32 (* HRESULT *);
            dwZone: @int32u (* DWORD *); 
            dwAction: @int32u (* DWORD *); 
            pPolicy: ^int8uHolder (* *BYTE *); 
            cbPolicy: @int32u (* DWORD *); 
            urlZoneReg: @int32 (* URLZONEREG *); 
         enter (dwZone, dwAction, pPolicy[], cbPolicy, urlZoneReg)
         exit result
         #);
       PromptAction:<
         (# result: @int32 (* HRESULT *);
            dwAction: @int32u (* DWORD *); 
            hwndParent: ^int32Holder (* HWND *); 
            pwszUrl: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            pwszText: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            dwPromptFlags: @int32u (* DWORD *); 
         enter (dwAction, hwndParent[], pwszUrl, pwszText, dwPromptFlags)
         exit result
         #);
       LogAction:<
         (# result: @int32 (* HRESULT *);
            dwAction: @int32u (* DWORD *); 
            pwszUrl: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            pwszText: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            dwLogFlags: @int32u (* DWORD *); 
         enter (dwAction, pwszUrl, pwszText, dwLogFlags)
         exit result
         #);
       CreateZoneEnumerator:<
         (# result: @int32 (* HRESULT *);
            pdwEnum: ^int32uHolder (* *DWORD *); 
            pdwCount: ^int32uHolder (* *DWORD *); 
            dwFlags: @int32u (* DWORD *); 
         enter (pdwEnum[], pdwCount[], dwFlags)
         exit result
         #);
       GetZoneAt:<
         (# result: @int32 (* HRESULT *);
            dwEnum: @int32u (* DWORD *); 
            dwIndex: @int32u (* DWORD *); 
            pdwZone: ^int32uHolder (* *DWORD *); 
         enter (dwEnum, dwIndex, pdwZone[])
         exit result
         #);
       DestroyZoneEnumerator:<
         (# result: @int32 (* HRESULT *);
            dwEnum: @int32u (* DWORD *); 
         enter dwEnum
         exit result
         #);
       CopyTemplatePoliciesToZone:<
         (# result: @int32 (* HRESULT *);
            dwTemplate: @int32u (* DWORD *); 
            dwZone: @int32u (* DWORD *); 
            dwReserved: @int32u (* DWORD *); 
         enter (dwTemplate, dwZone, dwReserved)
         exit result
         #);
    #);
  URLZONE: IntegerObject(# (* enum tagURLZONE *) #);
  URLZONE_PREDEFINED_MIN: (* URLZONE *)(# exit 0 #);
  URLZONE_LOCAL_MACHINE: (* URLZONE *)(# exit 0 #);
  URLZONE_INTRANET: (* URLZONE *)(# exit URLZONE_LOCAL_MACHINE+1 #);
  URLZONE_TRUSTED: (* URLZONE *)(# exit URLZONE_INTRANET+1 #);
  URLZONE_INTERNET: (* URLZONE *)(# exit URLZONE_TRUSTED+1 #);
  URLZONE_UNTRUSTED: (* URLZONE *)(# exit URLZONE_INTERNET+1 #);
  URLZONE_PREDEFINED_MAX: (* URLZONE *)(# exit 999 #);
  URLZONE_USER_MIN: (* URLZONE *)(# exit 1000 #);
  URLZONE_USER_MAX: (* URLZONE *)(# exit 10000 #);

  URLTEMPLATE: IntegerObject(# (* enum tagURLTEMPLATE *) #);
  URLTEMPLATE_CUSTOM: (* URLTEMPLATE *)(# exit 0x000000 #);
  URLTEMPLATE_PREDEFINED_MIN: (* URLTEMPLATE *)(# exit 0x10000 #);
  URLTEMPLATE_LOW: (* URLTEMPLATE *)(# exit 0x10000 #);
  URLTEMPLATE_MEDIUM: (* URLTEMPLATE *)(# exit 0x11000 #);
  URLTEMPLATE_HIGH: (* URLTEMPLATE *)(# exit 0x12000 #);
  URLTEMPLATE_PREDEFINED_MAX: (* URLTEMPLATE *)(# exit 0x20000 #);

  MAX_ZONE_PATH: (# exit 260 #);
  MAX_ZONE_DESCRIPTION: (# exit 200 #);

  ZAFLAGS: IntegerObject(# #);
  ZAFLAGS_CUSTOM_EDIT: (* ZAFLAGS *)(# exit 0x00000001 #);
  ZAFLAGS_ADD_SITES: (* ZAFLAGS *)(# exit 0x00000002 #);
  ZAFLAGS_REQUIRE_VERIFICATION: (* ZAFLAGS *)(# exit 0x00000004 #);
  ZAFLAGS_INCLUDE_PROXY_OVERRIDE: (* ZAFLAGS *)(# exit 0x00000008 #);
  ZAFLAGS_INCLUDE_INTRANET_SITES: (* ZAFLAGS *)(# exit 0x00000010 #);
  ZAFLAGS_NO_UI: (* ZAFLAGS *)(# exit 0x00000020 #);
  ZAFLAGS_SUPPORTS_VERIFICATION: (* ZAFLAGS *)(# exit 0x00000040 #);
  ZAFLAGS_UNC_AS_INTRANET: (* ZAFLAGS *)(# exit 0x00000080 #);

  ZONEATTRIBUTES: struct__ZONEATTRIBUTES(# #);
  struct__ZONEATTRIBUTES: DATA
    (# cbSize: @int32u (* ULONG *);
       szDisplayName: ^wcharHolder (* WCHAR *);
       szDescription: ^wcharHolder (* WCHAR *);
       szIconPath: ^wcharHolder (* WCHAR *);
       dwTemplateMinLevel: @int32u (* DWORD *);
       dwTemplateRecommended: @int32u (* DWORD *);
       dwTemplateCurrentLevel: @int32u (* DWORD *);
       dwFlags: @int32u (* DWORD *);
    #);
  URLZONEREG: IntegerObject(# (* enum _URLZONEREG *) #);
  URLZONEREG_DEFAULT: (* URLZONEREG *)(# exit 0 #);
  URLZONEREG_HKLM: (* URLZONEREG *)(# exit URLZONEREG_DEFAULT+1 #);
  URLZONEREG_HKCU: (* URLZONEREG *)(# exit URLZONEREG_HKLM+1 #);

  (* #endif *)
  (* EXTERN_C const IID CLSID_SoftDistExt;   *)
  (* #ifndef _LPSOFTDISTEXT_DEFINED *)
  (* #define _LPSOFTDISTEXT_DEFINED *)
  (*  *)
  (* #define SOFTDIST_FLAG_USAGE_EMAIL        0x00000001 *)
  (* #define SOFTDIST_FLAG_USAGE_PRECACHE     0x00000002 *)
  (* #define SOFTDIST_FLAG_USAGE_AUTOINSTALL  0x00000004 *)
  (* #define SOFTDIST_FLAG_DELETE_SUBSCRIPTION 0x00000008 *)
  (*  *)
  (*  *)
  (* #define SOFTDIST_ADSTATE_NONE	        0x00000000 *)
  (* #define SOFTDIST_ADSTATE_AVAILABLE       0x00000001 *)
  (* #define SOFTDIST_ADSTATE_DOWNLOADED	    0x00000002 *)
  (* #define SOFTDIST_ADSTATE_INSTALLED		0x00000003 *)
  (*  *)
  CODEBASEHOLD: struct__tagCODEBASEHOLD(# #);
  struct__tagCODEBASEHOLD: DATA
    (# cbSize: @int32u (* ULONG *);
       szDistUnit: @wcharHolder (* *LPWSTR *);
       szCodeBase: @wcharHolder (* *LPWSTR *);
       dwVersionMS: @int32u (* DWORD *);
       dwVersionLS: @int32u (* DWORD *);
       dwStyle: @int32u (* DWORD *);
    #);
  SOFTDISTINFO: struct__tagSOFTDISTINFO(# #);
  struct__tagSOFTDISTINFO: DATA
    (# cbSize: @int32u (* ULONG *);
       dwFlags: @int32u (* DWORD *);
       dwAdState: @int32u (* DWORD *);
       szTitle: @wcharHolder (* *LPWSTR *);
       szAbstract: @wcharHolder (* *LPWSTR *);
       szHREF: @wcharHolder (* *LPWSTR *);
       dwInstalledVersionMS: @int32u (* DWORD *);
       dwInstalledVersionLS: @int32u (* DWORD *);
       dwUpdateVersionMS: @int32u (* DWORD *);
       dwUpdateVersionLS: @int32u (* DWORD *);
       dwAdvertisedVersionMS: @int32u (* DWORD *);
       dwAdvertisedVersionLS: @int32u (* DWORD *);
       dwReserved: @int32u (* DWORD *);
    #);

  ISoftDistExt_IID: (# exit 'B15B8DC1-C7E1-11d0-8680-00AA00BDCB71' #);

  ISoftDistExt: IUnknown
    (* ISoftDistExt Interface *)
    (# <<SLOT ISoftDistExtLib: attributes>>;
       ProcessSoftDist:<
         (# result: @int32 (* HRESULT *);
            szCDFURL: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            pSoftDistElement: ^IXMLElement (* *IXMLElement *); 
            lpsdi: ^struct__tagSOFTDISTINFO (* LPSOFTDISTINFO *); 
         enter (szCDFURL, pSoftDistElement[], lpsdi[])
         exit result
         #);
       GetFirstCodeBase:<
         (# result: @int32 (* HRESULT *);
            szCodeBase: ^textHolder (* *LPWSTR *); 
            dwMaxSize: ^int32uHolder (* LPDWORD *); 
         enter (szCodeBase[], dwMaxSize[])
         exit result
         #);
       GetNextCodeBase:<
         (# result: @int32 (* HRESULT *);
            szCodeBase: ^textHolder (* *LPWSTR *); 
            dwMaxSize: ^int32uHolder (* LPDWORD *); 
         enter (szCodeBase[], dwMaxSize[])
         exit result
         #);
       AsyncInstallDistributionUnit:<
         (# result: @int32 (* HRESULT *);
            pbc: ^IBindCtx (* *IBindCtx *); 
            pvReserved: ^int32Holder (* LPVOID *); 
            flags: @int32u (* DWORD *); 
            lpcbh: ^struct__tagCODEBASEHOLD (* LPCODEBASEHOLD *); 
         enter (pbc[], pvReserved[], flags, lpcbh[])
         exit result
         #);
    #);
  (* STDAPI GetSoftwareUpdateInfo( LPCWSTR szDistUnit, LPSOFTDISTINFO psdi ); *)
  (* STDAPI SetSoftwareUpdateAdvertisementState( LPCWSTR szDistUnit, DWORD dwAdState, DWORD dwAdvertisedVersionMS, DWORD dwAdvertisedVersionLS ); *)
  (* #endif *)
  (* #ifndef _LPDATAFILTER_DEFINED *)
  (* #define _LPDATAFILTER_DEFINED *)

  IDataFilter_IID: (# exit '69d14c80-c18e-11d0-a9ce-006097942311' #);

  IDataFilter: IUnknown
    (# <<SLOT IDataFilterLib: attributes>>;
       DoEncode:<
         (# result: @int32 (* HRESULT *);
            dwFlags: @int32u (* DWORD *); 
            lInBufferSize: @int32 (* LONG *); 
            pbInBuffer: ^int8uHolder (* *BYTE *); 
            lOutBufferSize: @int32 (* LONG *); 
            pbOutBuffer: ^int8uHolder (* *BYTE *); 
            lInBytesAvailable: @int32 (* LONG *); 
            plInBytesRead: ^int32Holder (* *LONG *); 
            plOutBytesWritten: ^int32Holder (* *LONG *); 
            dwReserved: @int32u (* DWORD *); 
         enter (dwFlags, lInBufferSize, pbInBuffer[], lOutBufferSize, pbOutBuffer[], lInBytesAvailable, plInBytesRead[], plOutBytesWritten[], dwReserved)
         exit result
         #);
       DoDecode:<
         (# result: @int32 (* HRESULT *);
            dwFlags: @int32u (* DWORD *); 
            lInBufferSize: @int32 (* LONG *); 
            pbInBuffer: ^int8uHolder (* *BYTE *); 
            lOutBufferSize: @int32 (* LONG *); 
            pbOutBuffer: ^int8uHolder (* *BYTE *); 
            lInBytesAvailable: @int32 (* LONG *); 
            plInBytesRead: ^int32Holder (* *LONG *); 
            plOutBytesWritten: ^int32Holder (* *LONG *); 
            dwReserved: @int32u (* DWORD *); 
         enter (dwFlags, lInBufferSize, pbInBuffer[], lOutBufferSize, pbOutBuffer[], lInBytesAvailable, plInBytesRead[], plOutBytesWritten[], dwReserved)
         exit result
         #);
       SetEncodingLevel:<
         (# result: @int32 (* HRESULT *);
            dwEncLevel: @int32u (* DWORD *); 
         enter dwEncLevel
         exit result
         #);
    #);
  (* #endif *)
  (* #ifndef _LPENCODINGFILTERFACTORY_DEFINED *)
  (* #define _LPENCODINGFILTERFACTORY_DEFINED *)
  PROTOCOLFILTERDATA: struct__tagPROTOCOLFILTERDATA(# #);
  struct__tagPROTOCOLFILTERDATA: DATA
    (# cbSize: @int32u (* DWORD *);
       pProtocolSink: ^IInternetProtocolSink (* IInternetProtocolSink *);
       pProtocol: ^IInternetProtocol (* IInternetProtocol *);
       pUnk: ^IUnknown (* IUnknown *);
       dwFilterFlags: @int32u (* DWORD *);
    #);

  IEncodingFilterFactory_IID: (# exit '70bdde00-c18e-11d0-a9ce-006097942311' #);

  IEncodingFilterFactory: IUnknown
    (# <<SLOT IEncodingFilterFactoryLib: attributes>>;
       FindBestFilter:<
         (# result: @int32 (* HRESULT *);
            pwzCodeIn: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            pwzCodeOut: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            info: @struct__tagDATAINFO (* DATAINFO *); 
            ppDF: ^IDataFilterHolder (* **IDataFilter *); 
         enter (pwzCodeIn, pwzCodeOut, info, ppDF[])
         exit result
         #);
       GetDefaultFilter:<
         (# result: @int32 (* HRESULT *);
            pwzCodeIn: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            pwzCodeOut: [0]@char (* ^text NYI *) (* LPCWSTR *); 
            ppDF: ^IDataFilterHolder (* **IDataFilter *); 
         enter (pwzCodeIn, pwzCodeOut, ppDF[])
         exit result
         #);
    #);
  DATAINFO: struct__tagDATAINFO(# #);
  struct__tagDATAINFO: DATA
    (# ulTotalSize: @int32u (* ULONG *);
       ulavrPacketSize: @int32u (* ULONG *);
       ulConnectSpeed: @int32u (* ULONG *);
       ulProcessorSpeed: @int32u (* ULONG *);
    #);
  (* #endif *)
  (* #ifndef _HITLOGGING_DEFINED *)
  (* #define _HITLOGGING_DEFINED *)
  (* // Logging-specific apis *)
  (* #ifdef UNICODE                                                        *)
  (* #define IsLoggingEnabled         IsLoggingEnabledW                    *)
  (* #else                                                                 *)
  (* #define IsLoggingEnabled         IsLoggingEnabledA                    *)
  (* #endif // !UNICODE                                                    *)
  HIT_LOGGING_INFO: struct__tagHIT_LOGGING_INFO(# #);
  struct__tagHIT_LOGGING_INFO: DATA
    (# dwStructSize: @int32u (* DWORD *);
       lpszLoggedUrlName: @charHolder (* *LPSTR *);
       StartTime: @struct__SYSTEMTIME (* SYSTEMTIME *);
       EndTime: @struct__SYSTEMTIME (* SYSTEMTIME *);
       lpszExtendedInfo: @charHolder (* *LPSTR *);
    #);
  (* #endif *)

  (* Holders *)

  BINDINFOHolder: Holder
    (# value: @BINDINFO; #);
  struct__tagBINDINFOHolder: Holder
    (# value: @struct__tagBINDINFO; #);
  REMSECURITY_ATTRIBUTESHolder: Holder
    (# value: @REMSECURITY_ATTRIBUTES; #);
  struct__REMSECURITY_ATTRIBUTESHolder: Holder
    (# value: @struct__REMSECURITY_ATTRIBUTES; #);
  RemBINDINFOHolder: Holder
    (# value: @RemBINDINFO; #);
  struct__tagRemBINDINFOHolder: Holder
    (# value: @struct__tagRemBINDINFO; #);
  RemFORMATETCHolder: Holder
    (# value: @RemFORMATETC; #);
  struct_tagRemFORMATETCHolder: Holder
    (# value: @struct_tagRemFORMATETC; #);
  PROTOCOLDATAHolder: Holder
    (# value: @PROTOCOLDATA; #);
  struct__tagPROTOCOLDATAHolder: Holder
    (# value: @struct__tagPROTOCOLDATA; #);
  ZONEATTRIBUTESHolder: Holder
    (# value: @ZONEATTRIBUTES; #);
  struct__ZONEATTRIBUTESHolder: Holder
    (# value: @struct__ZONEATTRIBUTES; #);
  CODEBASEHOLDHolder: Holder
    (# value: @CODEBASEHOLD; #);
  struct__tagCODEBASEHOLDHolder: Holder
    (# value: @struct__tagCODEBASEHOLD; #);
  SOFTDISTINFOHolder: Holder
    (# value: @SOFTDISTINFO; #);
  struct__tagSOFTDISTINFOHolder: Holder
    (# value: @struct__tagSOFTDISTINFO; #);
  PROTOCOLFILTERDATAHolder: Holder
    (# value: @PROTOCOLFILTERDATA; #);
  struct__tagPROTOCOLFILTERDATAHolder: Holder
    (# value: @struct__tagPROTOCOLFILTERDATA; #);
  DATAINFOHolder: Holder
    (# value: @DATAINFO; #);
  struct__tagDATAINFOHolder: Holder
    (# value: @struct__tagDATAINFO; #);
  HIT_LOGGING_INFOHolder: Holder
    (# value: @HIT_LOGGING_INFO; #);
  struct__tagHIT_LOGGING_INFOHolder: Holder
    (# value: @struct__tagHIT_LOGGING_INFO; #);


  (* Reference Holders *)

  IPersistMonikerHolder: refHolder
    (# type:: IPersistMoniker #);
  IBindProtocolHolder: refHolder
    (# type:: IBindProtocol #);
  IBindingHolder: refHolder
    (# type:: IBinding #);
  IBindStatusCallbackHolder: refHolder
    (# type:: IBindStatusCallback #);
  IAuthenticateHolder: refHolder
    (# type:: IAuthenticate #);
  IHttpNegotiateHolder: refHolder
    (# type:: IHttpNegotiate #);
  IWindowForBindingUIHolder: refHolder
    (# type:: IWindowForBindingUI #);
  ICodeInstallHolder: refHolder
    (# type:: ICodeInstall #);
  IWinInetInfoHolder: refHolder
    (# type:: IWinInetInfo #);
  IHttpSecurityHolder: refHolder
    (# type:: IHttpSecurity #);
  IWinInetHttpInfoHolder: refHolder
    (# type:: IWinInetHttpInfo #);
  IBindHostHolder: refHolder
    (# type:: IBindHost #);
  IInternetHolder: refHolder
    (# type:: IInternet #);
  IInternetBindInfoHolder: refHolder
    (# type:: IInternetBindInfo #);
  IInternetProtocolRootHolder: refHolder
    (# type:: IInternetProtocolRoot #);
  IInternetProtocolHolder: refHolder
    (# type:: IInternetProtocol #);
  IInternetProtocolSinkHolder: refHolder
    (# type:: IInternetProtocolSink #);
  IInternetSessionHolder: refHolder
    (# type:: IInternetSession #);
  IInternetThreadSwitchHolder: refHolder
    (# type:: IInternetThreadSwitch #);
  IInternetPriorityHolder: refHolder
    (# type:: IInternetPriority #);
  IInternetProtocolInfoHolder: refHolder
    (# type:: IInternetProtocolInfo #);
  IInternetSecurityMgrSiteHolder: refHolder
    (# type:: IInternetSecurityMgrSite #);
  IInternetSecurityManagerHolder: refHolder
    (# type:: IInternetSecurityManager #);
  IInternetHostSecurityManagerHolder: refHolder
    (# type:: IInternetHostSecurityManager #);
  IInternetZoneManagerHolder: refHolder
    (# type:: IInternetZoneManager #);
  ISoftDistExtHolder: refHolder
    (# type:: ISoftDistExt #);
  IDataFilterHolder: refHolder
    (# type:: IDataFilter #);
  IEncodingFilterFactoryHolder: refHolder
    (# type:: IEncodingFilterFactory #);

