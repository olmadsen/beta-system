ORIGIN '../dragdrop';
INCLUDE '~beta/win32lib/winerror'
        '~beta/sysutils/cstring'
        '~beta/guienv/private/winnt/guienv_ntiprivate'
        'additionslib'
        '~beta/comlib/comtypes';
BUILD default '$$/dragdrop_nti.obj' 'external/dragdrop_nti.c' 'betacc $0 $1';
-- private: Descriptor --
(#
   Handle2Pointer: external
     (# hglobal: @int32; cptr: @int32 enter hglobal do callc exit cptr #);
   theHandle:
     (# handle: @integer; theInterfaceObject: ^InterfaceObject
     enter theInterfaceObject[]
     do
        (if theInterfaceObject[] <> none then
            theInterfaceObject.InterfaceObjectID->handle
         else
            'theHandle: theCanvas[]=none'->putline
        if)
     exit handle
     #);
   IDropTargetType: IDropTarget
     (#
        tempFormatETC: @struct_tagFORMATETC;
        tempSTGMedium: @STGMEDIUM;
        tempIEnumFORMATETC: ^IEnumFORMATETC;
        tempIEnumFORMATETCHolder: @IEnumFORMATETCHolder;
        refCount: @integer;
        ;
        supportedTypes:
        (* The types (e.g., CF_TEXT) that are supported by the drag-data *) [0]
        @integer;
        modifiers: (* OR of some of MK_SHIFT, MK_CONTROL, MK_LBUTTON, ... *)
          @integer;
        preferredType: (* e.g., CF_TEXT *) @integer;
        action: (* move/copy/none/... *) @int32;
        ;
        QueryInterface::< 
          (# 
          do
             'DropTarget: QueryInterface called - we have not implemented it!'
               ->putline
          #);
        AddRef::<  (#  do refCount+1->refCount->result #);
        Release::<  (#  do refCount-1->refCount->result #);
        ;
        DragEnter::< 
          (# hr: @Hresult
          do
             get_supportedTypes:
             (* Asks the dataobject what types it support. Answer is in supportedTypes. *)
               (# 
               do
                  0->supportedTypes.new;
                  (DATADIR_GET,tempIEnumFORMATETCHolder[])
                    ->pDataObj.EnumFormatEtc->hr;
                  ;
                  (if hr.value = S_OK then
                      tempIEnumFORMATETCHolder->tempIEnumFORMATETC[];
                      tempIEnumFORMATETC.reset;
                      enum_loop:
                        (# 
                        do
                           (1,tempFORMATETC[],none )->tempIEnumFORMATETC.next
                             ->hr;
                           (if hr.value = S_OK then
                               1->supportedTypes.extend;
                               tempFORMATETC.cfFormat
                                 ->supportedTypes[supportedTypes.range];
                               restart enum_loop
                            else
                               leave enum_loop
                           if)
                        #);
                      tempIEnumFORMATETC.Release;
                      none ->tempIEnumFORMATETC[];
                      S_OK->result
                   else
                      write_errormsg:
                        (# 
                        do
                           'pDataObj.EnumFormatEtc: IKKE OK'->putline;
                           handle_error:
                             (# 
                             do
                                (if hr.value
                                 // E_INVALIDARG then
                                    'E_INVALIDARG'->putline
                                 // E_OUTOFMEMORY then
                                    'E_OUTOFMEMORY'->putline
                                 // E_NOTIMPL then
                                    'E_NOTIMPL'->putline
                                 // OLE_S_USEREG then
                                    'OLE_S_USEREG'->putline
                                 else
                                    'EnumFormatEtc: hr er underlig: '->puttext;
                                    hr.value->putint;
                                    newline
                                if)
                             #)
                        #);
                      E_UNEXPECTED->result
                  if)
               #);
             grfKeyState->modifiers;
             (supportedTypes,grfKeyState,pdwEffect)->media
               ->(preferredType,action)
          #);
        DragOver::< 
          (# 
          do
             (if grfKeyState <> modifiers then
             (* modifiers changed since last time - ask user for action again *)
                 grfKeyState->modifiers;
                 (supportedTypes,grfKeyState,pdwEffect)->media
                   ->(preferredType,action)
             if);
             ;
             (if preferredType = 0 then (* none of the types can be accepted *)
                 DROPEFFECT_NONE->pdwEffect
              else
                 action->pdwEffect
             if);
             S_OK->result
          #);
        DragLeave::<  (#  do S_OK->result #);
        Drop::< 
          (# hr: @Hresult
          do
             preferredType->tempFormatETC.cfFormat;
             none ->tempFormatETC.ptd[];
             DVASPECT_CONTENT->tempFormatETC.dwAspect;
             - 1->tempFormatETC.lindex;
             TYMED_HGLOBAL->tempFormatETC.tymed;
             (tempFormatETC[],tempSTGMedium[])->pDataObj.GetData->hr;
             ;
             (if hr.value = S_OK then
                 (if grfKeyState <> modifiers then
                 (* modifiers changed since last time - ask user for action again *)
                     (supportedTypes,grfKeyState,pdwEffect)->media
                       ->(preferredType,action)
                 if);
                 (preferredType,action,tempSTGMedium.hglobal)
                   ->THIS(DropTarget).drop;
                 HUSK_AT_FRIGOERE_DATA_FRA_MEMORY_med_pUnkForRelease:
                   (#  #);
                 action
                   ->pdwEffect
                   (* If e.g. action is DROPEFFECT_MOVE, then
                    the source should be told so - in order to delete the selection. *)
                   ;
                 S_OK->result
              else
                 write_debug:
                   (# 
                   do
                      ' (GetData: '->puttext;
                      (if hr.value
                       // S_OK then
                          'S_OK'->puttext
                       // DV_E_LINDEX then
                          'DV_E_LINDEX'->puttext
                       // DV_E_FORMATETC then
                          'DV_E_FORMATETC'->puttext
                       // DV_E_TYMED then
                          'DV_E_TYMED'->puttext
                       // DV_E_DVASPECT then
                          'DV_E_DVASPECT'->puttext
                       // OLE_E_NOTRUNNING then
                          'OLE_E_NOTRUNNING'->puttext
                       // STG_E_MEDIUMFULL then
                          'STG_E_MEDIUMFULL'->puttext
                       // S_FALSE then
                          'S_FALSE'->puttext
                       else
                          'hr er underlig: '->puttext; hr.value->putint
                      if);
                      ').'->putline
                   #);
                 E_INVALIDARG->result
             if);
             
          #)
     #);
   pDropTarget: ^IDropTargetType;
   initialised: @boolean;
   init:
     (# 
     do
        (if not initialised then
            true->initialised; &private.IDropTargetType[]->private.pDropTarget[]
         else
            'COleDropTarget.private.init: already initialised!'->putline
        if)
     #)
#)  

-- register: DoPart --
do
     (# hr: @HRESULT
     do
        (if not private.initialised then private.init if);
        (THIS(InterfaceObject)[]->private.theHandle,private.pDropTarget[])
          ->MyRegisterDragDrop->hr;
        (if hr.succeeded then
            INNER register
         else
            write_errormsg:
              (# 
              do
                 'RegisterDragDrop failed!'->putline;
                 (if hr.value
                  // S_OK then
                     'S_OK'->putline
                  // DRAGDROP_E_INVALIDHWND then
                     'DRAGDROP_E_INVALIDHWND'->putline
                  // DRAGDROP_E_ALREADYREGISTERED then
                     'DRAGDROP_E_ALREADYREGISTERED'->putline
                  else
                     'hr er underlig'->putline
                 if)
              #);
            onError
        if)
     #)  

-- revoke: DoPart --
do
     (# hr: @HRESULT
     do
        (if not private.initialised then private.init if);
        (THIS(InterfaceObject)[]->private.theHandle)->RevokeDragDrop->hr;
        (if hr.succeeded then
            INNER revoke
         else
            write_errormsg:
              (# 
              do
                 'RevokeDragDrop failed!'->putline;
                 (if hr.value
                  // S_OK then
                     'S_OK'->putline
                  // DRAGDROP_E_INVALIDHWND then
                     'DRAGDROP_E_INVALIDHWND'->putline
                  // DRAGDROP_E_NOTREGISTERED then
                     'DRAGDROP_E_NOTREGISTERED'->putline
                  else
                     'hr er underlig'->putline
                 if)
              #);
            onError
        if)
     #)  

-- media: DoPart --
do
   (if DROPEFFECT_MOVE->actionIsSupported then (* MOVE is default action *)
       DROPEFFECT_MOVE->action
    else
       (if DROPEFFECT_COPY->actionIsSupported then
           DROPEFFECT_COPY->action
        else
           (if DROPEFFECT_LINK->actionIsSupported then
               DROPEFFECT_LINK->action
            else
               DROPEFFECT_NONE->action
           if)
       if)
   if);
   ;
   (if (MK_CONTROL->modifierIsPressed) then
       (if (MK_SHIFT->modifierIsPressed) then (* CTRL+SHIFT means LINK *)
           (if (DROPEFFECT_LINK->actionIsSupported) then
               DROPEFFECT_LINK->action
           if)
        else
       (* CTRL alone means COPY *)
           (if (DROPEFFECT_COPY->actionIsSupported) then
               DROPEFFECT_COPY->action
           if)
       if)
   if);
   INNER media  

-- drop: DoPart --
do INNER  

-- dropAsText: DoPart --
do
     (# str: @cstring
     do objectHandle->private.Handle2Pointer->str.charptr; str.get->t[]
     #)  

