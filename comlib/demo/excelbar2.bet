ORIGIN '~beta/basiclib/systemenv';
INCLUDE '~beta/comlib/comlib';
INCLUDE '~beta/comlib/dispatchhelp';
INCLUDE '~beta/comlib/MsApplication/EXCEL8/Excel01';
INCLUDE '~beta/basiclib/random';

(* Like excelbar, except that all values are changed simultaneously *)

--LIB: attributes--
trace_com: (# exit false #);
trace_vb: (# exit true #);

numPacks: (# exit 8 #);
numSeries: (# exit 4 #);

VB:
  (# stmt: ^text
  enter stmt[]
  do (if trace_vb then
         'VB: ' -> puttext;
         stmt[] -> putline;
     if);
  #);

--PROGRAM: descriptor--
systemenv
(# CLSID_XL: ^CLSID;
   clsstr: @BSTR;
   IID_IDispatch: @IID;
   hr: @HRESULT;
   status: @boolean;
   
   pDispExcelApp, pdispWorkBooks, pdispWorkBook, pdispWorksheet, 
   pdispRange, pdispCharts, pDispChart, pDispAxes, pDispLegend: ^IDispatch;
   
   mydata: @COM
     (# varg, varg1, varg2: @VARIANT (* specialization of DATA *);
        vResult: @VARIANT (* specialization of DATA *);
     #);
   
   dParms: @DispatchParams;
   Packs: [numPacks*numSeries]^IntegerObject;

   excel_progid: (# exit 'Excel.Application' #);
   
   getrandom: @
     (# max: @integer;
        init:
          (# 
          do (21,42) -> setall;
          #);
        io: ^IntegerObject;
     enter max
     do &IntegerObject[] ->io[];
        (1,max) -> ignuin -> io.value;
     exit io[]
     #);
   
   CleanUp:
     (# 
     do (if trace_com then
            '\nClean up:' -> putline;
            'Releasing interfaces' -> putline;
        if);
        (if pDispExcelApp[]<>NONE then 
            pDispExcelApp.Release; 
        if);
        (if pdispWorkBooks[]<>NONE then 
            pdispWorkBooks.Release; 
        if);
        (if pdispWorkBook[]<>NONE then 
            pdispWorkBook.Release; 
        if);
        (if pdispWorksheet[]<>NONE then 
            pdispWorksheet.Release; 
        if);
        (if pdispRange[]<>NONE then 
            pdispRange.Release; 
        if);
        (if pdispCharts[]<>NONE then 
            pdispCharts.Release; 
        if);
        (if pdispChart[]<>NONE then 
            pdispChart.Release; 
        if);
        (if pdispAxes[]<>NONE then 
            pdispAxes.Release; 
        if);
        (if pdispLegend[]<>NONE then 
            pdispLegend.Release; 
        if);
        dparms.release;
        (if trace_com then
            'CoUninitialize'->putline;
        if);
        CoUninitialize;
        (if trace_com then
            'CoUninitialize done'->putline;
        if);
     #);
   
   setCategoryLabels:
     (# catNo: @integer;
        name: ^text;
        Labels: [numPacks]^Text;
     do (for i:numPacks repeat
             'pack' -> name[];
             catNo+1 -> catNo -> name.putint;
             name[] -> Labels[i][];
        for);
        
        'set r = ws.Range("A2:A9")' -> VB;
        dparms.release;
        (NONE, 'A2:A9') -> dparms.putString;
        (pDispWorksheet[], 'Range', dparms[], mydata.vResult[]) 
          -> PropertyGetByName
          -> status;
        (if not status then
            'setCategoryLabels failed' -> putline;
            leave setCategoryLabels;
        if);
        mydata.vResult[] -> VARIANT_init(# do pDispval -> pDispRange[] #);
        
        'r.Value = Array(...)' -> VB;
        dparms.release;
        (NONE, (8,1), Labels) -> dparms.putStringArray;
        (pDispRange[], 'Value', dparms[]) 
          -> PropertyPutByName
          -> status;
        (if not status then
            'setCategoryLabels failed' -> putline;
            leave setCategoryLabels;
        if);
        dparms.release;
     #);

   SetRandomCellValues:
     (# max: @integer;
     enter max
     do (* Update list of integers *)
        (for i:Packs.range repeat
             max->getrandom -> Packs[i][];
        for);
        
        dparms.release;
        (* Get range and assign new values *)
        'set r = ws.Range("B2:E9")' -> VB;
        (NONE, 'B2:E9') -> dparms.putString;
        (pdispWorkSheet[], 'Range', dparms[], mydata.varg2[]) 
          -> PropertyGetByName 
          -> status;
        (if not status then
            leave SetRandomCellValues;
        if);
        dparms.release;
        mydata.varg2[] -> VARIANT_init(# do pdispVal->pdispRange[] #);
        
        'r.Value = Array(...)' -> VB;
        (NONE, (8,4), Packs) -> dparms.putInt16Array;
        (pdispRange[], 'Value', dparms[]) 
          -> PropertyPutByName 
          -> status;
        dparms.release;
        (if not status then
            leave SetRandomCellValues;
        if);
        Save;
        (if not status then
            leave SetRandomCellValues;
        if);
     #);
   
   Save:
     (# 
     do 'wb.Saved = TRUE' -> VB;
        (*  so that Excel won\'t ask whether to save doc on close *)
        (NONE, true) -> dParms.putBoolean;
        (pDispWorkBook[], 'Saved', dparms[]) -> PropertyPutByName -> status;
     #);
   
do getrandom.init;
   
   ControlExcel:
     (# 
     do 0->CoInitialize;   
        excel_progid -> clsstr.setText;
        clsstr[] -> CLSIDFromProgID -> CLSID_XL[];
        IDispatch_IID -> IID_IDispatch; 
        
        (if trace_com then
            'Create component and get dispinterface'->putLine;
        if);
        (CLSID_XL[], NONE, CLSCTX_LOCAL_SERVER, IID_IDispatch[])
          -> CoCreateInstance->pDispExcelApp[];
        
        (if pDispExcelApp[]<>NONE then
            (if trace_com then
                'Succeeded creating component.'->putLine;
            if);
         else
            'failed creating component.'->putLine;
            leave ControlExcel;
        if);

        (if trace_com then
            'Invoking pDispExcelApp.Visible:' -> putline;
        if);
        (NONE, true) -> dParms.putBoolean;
        (pDispExcelApp[], 'Visible', dparms[]) -> PropertyPutByName -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        
        'set wbs = [application].Workbooks' -> VB;
   
        (pDispExcelApp[], 'Workbooks', dparms[], mydata.varg1[]) 
          -> PropertyGetByName 
          -> status;
        (if not status then
            leave ControlExcel;
        if);
        mydata.varg1[] -> VARIANT_init(# do pdispVal->pdispWorkbooks[] #);
        
        'set wb = wbs.Add(Template := xlWorksheet)' -> VB;
        ('Template', xlWorksheet) -> dParms.putInt16;
        (pdispWorkbooks[], 'Add', dparms[], DISPATCH_METHOD, mydata.varg2[]) 
          -> InvokeByName
          -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        mydata.varg2[] -> VARIANT_init(# do pdispVal->pdispWorkBook[] #);
        
        'set ws = wb.Worksheets(1)' -> VB;
        (NONE,1) -> dParms.putInt16;
        (pdispWorkBook[], 'Worksheets', dparms[], mydata.varg2[]) 
          -> PropertyGetByName 
          -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        mydata.varg2[] -> VARIANT_init(# do pdispVal->pdispWorkSheet[] #);
        
        'set r = ws.Range("B1:E1")' -> VB;
        (NONE, 'B1:E1') -> dparms.putString;
        (pdispWorkSheet[], 'Range', dparms[], mydata.varg2[]) 
          -> PropertyGetByName 
          -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        mydata.varg2[] -> VARIANT_init(# do pdispVal->pdispRange[] #);
        
        'r.Value = Array("Enroute", "Lost", "Failures", "Successes")' -> VB;
        (NONE, (8), ('Enroute', 'Lost', 'Failures', 'Successes'))
          -> dparms.putStringArray;
        (pdispRange[], 'Value', dparms[]) 
          -> PropertyPutByName 
          -> status;
        dparms.release;
        (if not status then
            leave ControlExcel;
        if);
        
        SetCategoryLabels;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;

        20 -> SetRandomCellValues;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        
        'set sourceRange= ws.Range("A1:E9")' -> VB;
        (NONE, 'A1:E9') -> dparms.putString;
        (pdispWorkSheet[], 'Range', dparms[], mydata.varg2[]) 
          -> PropertyGetByName 
          -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        mydata.varg2[] -> VARIANT_init(# do pdispVal->pdispRange[] #);
        
        'set crts = wb.Charts' -> VB;
        (pdispWorkbook[], 'Charts', dparms[], mydata.varg2[]) 
          -> PropertyGetByName 
          -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        mydata.varg2[] -> VARIANT_init(# do pdispVal->pdispCharts[] #);
        
        'set crt = crts.Add' -> VB;
        (pdispCharts[], 'Add', dparms[], DISPATCH_METHOD, mydata.varg2[]) 
          -> InvokeByName
          -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        mydata.varg2[] -> VARIANT_init(# do pdispVal->pdispChart[] #);
        
        'crt.ChartWizard source := sourceRange, gallery := xlBarStacked, _\n'
        '    format := 1, plotBy := xlColums, categoryLabels := 1, _\n'
        '    seriesLabels := 1, haslegend := 1, title := "Packets"'
          -> VB;
        ('valueTitle', 'Count'    )    -> dparms.putString;
        ('categoryTitle', 'Packet')    -> dparms.putString;
        ('title', 'Packet Statistics') -> dparms.putString;
        ('hasLegend', 1)               -> dParms.putInt16;
        ('seriesLabels', 1)            -> dParms.putInt16;
        ('categoryLabels', 1)          -> dParms.putInt16;
        ('plotBy', xlColumns)          -> dParms.putInt16;
        (* Nice Formats: 3 (counts), 5 (percentages), 9+10 (with lines) *)
        ('format', 3)                  -> dParms.putInt16;
        ('gallery', xlBar(*Stacked?*)) -> dParms.putInt16;
        ('source', pDispRange[])       -> dParms.putDispatch;
        (pdispChart[], 'ChartWizard', dparms[], DISPATCH_METHOD, NONE) 
          -> InvokeByName
          -> status;
        dparms.release;
        (if not status then
            leave ControlExcel;
        if);
        
        'crt.ApplyDataLabels Type:=xlDataLabelsShowValue, LegendKey:=False'
          ->VB;
        ('legendKey', FALSE)             -> dParms.putBoolean;
        ('type', xlDataLabelsShowValue) -> dParms.putint16;
        (pdispChart[], 'ApplyDataLabels', dparms[], DISPATCH_METHOD, NONE) 
          -> InvokeByName
          -> status;
        dparms.release;
        (if not status then
            leave ControlExcel;
        if);
        
        'set ax = crt.Axes(xlValue)' -> VB;
        (NONE, xlValue) -> dparms.putInt16;
        (pdispChart[], 'Axes', dparms[], DISPATCH_METHOD, mydata.varg2[]) 
          -> InvokeByName
          -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        mydata.varg2[] -> VARIANT_init(# do pdispVal->pdispAxes[] #);
        
        'ax.HasMajorGridlines = True' -> VB;
        (NONE, TRUE) -> dParms.putBoolean;
        (pDispAxes[], 'HasMajorgridlines', dparms[]) 
          -> PropertyPutByName 
          -> status;
        dparms.release;
        (if not status then
            leave ControlExcel;
        if);
        
        'set lgnd = crt.Legend' -> VB;
        (pdispChart[], 'Legend', dparms[], mydata.varg2[]) 
          -> PropertyGetByName
          -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        mydata.varg2[] -> VARIANT_init(# do pdispVal->pdispLegend[] #);
        
        'lgnd.Position = xlLegendPositionTop' -> VB;
        (NONE, xlLegendPositionTop) -> dParms.putInt16;
        (pDispLegend[], 'Position', dparms[]) 
          -> PropertyPutByName 
          -> status;
        dparms.release;
        (if not status then
            leave ControlExcel;
        if);
        
        Save;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        
        'Type <RETURN> to start animation: ' -> puttext;
        getline;
        (for time:30 repeat
             'Update#'->puttext;
             time->putint;
             ': '->putline;
             time+20 -> setRandomCellValues;
             (if not status then
                 leave ControlExcel;
             if);
             (if time<30 then 2->sleep if);
        for);
     #);
   
   CleanUp;
   
#)



