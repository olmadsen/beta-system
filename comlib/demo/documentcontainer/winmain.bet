ORIGIN '~beta/guienv/guienv';
INCLUDE 'debuglib'
        '~beta/guienv/private/winnt/guienv_ntiprivate'
        '~beta/comlib/comlib'
        '~beta/comlib/OleIdl'
        '~beta/comlib/docobj'
        '~beta/win32lib/winerror'
        'additionslib'
        '~beta/win32lib/windowmanagement';
-- program: Descriptor --
guienv(#
   relax: (#  do (if false then '.'->put; (* 0.2->sleep *)  if) #);
   debug: @winmainDebug;
   resource: (* Svarer til C++ filen resource.h. Indeholder konstanter. *) @
     (# IDM_FILECLOSE: (#  exit 102 #) #);
   ;
   CImpOleClientSite: IOleClientSite
     (#
        PROTECTED: (#  #);
        m_cRef: (* =ULONG *) @integer;
        m_pSite: (* =class CSite* *) ^CSite;
        m_pUnkOuter: (* LPUNKNOWN *) ^IUnknown;
        ;
        ;
        PUBLIC: (#  #);
        constructor:
          (# pSite: ^CSite; pUnkOuter: (* = LPUNKNOWN *) ^IUnknown
          enter (pSite[],pUnkOuter[])
          do
             debug.locate2Msg
               (#  do 'IOleClientSite.constructor'->putline #);
             0->m_cRef;
             pSite[]->m_pSite[];
             pUnkOuter[]->m_pUnkOuter[]
          #);
        destructor:
          (# 
          do
             debug.locate2Msg (#  do 'IOleClientSite.destructor'->putline #)
          #);
        QueryInterface::< 
          (# 
          do
             relax;
             'OleClientSite.QueryInterface'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do '++IOleClientSite.QueryInterface'->msg.append #);
             (if true then
                 (riid[],ppvObject[])->m_pUnkOuter.QueryInterface->result
              else
                 E_NOINTERFACE->result
             if);
             ;
             (if false then
                 '======> IOleClientSite.QueryInterface returns: '->puttext;
                 result->debug.myprint
             if);
             'OleClientSite.QueryInterface'->debug.locateMsg.out
          #);
        AddRef::< 
          (# 
          do
             relax;
             'OleClientSite.AddRef'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do '--IOleClientSite.AddRef'->msg.append #);
             m_cRef+1->m_cRef;
             m_pUnkOuter.AddRef->result;
             'OleClientSite.AddRef'->debug.locateMsg.out
          #);
        Release::< 
          (# 
          do
             relax;
             'OleClientSite.Release'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do '--IOleClientSite.Release'->msg.append #);
             m_cRef-1->m_cRef;
             m_pUnkOuter.Release->result;
             'OleClientSite.Release'->debug.locateMsg.out
          #);
        ;
        SaveObject::< 
          (# 
          do
             relax;
             'OleClientSite.SaveObject'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IOleClientSite.SaveObject'->msg.append #);
             NO_ERROR->result;
             'OleClientSite.SaveObject'->debug.locateMsg.out
          #);
        GetMoniker::< 
          (# 
          do
             relax;
             'OleClientSite.GetMoniker'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IOleClientSite.GetMoniker'->msg.append #);
             E_NOTIMPL->result;
             'OleClientSite.GetMoniker'->debug.locateMsg.out
          #);
        GetContainer::< 
          (# 
          do
             relax;
             'OleClientSite.GetContainer'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IOleClientSite.GetContainer'->msg.append #);
             none ->ppContainer;
             E_NOINTERFACE->result;
             'OleClientSite.GetContainer'->debug.locateMsg.out
          #);
        ShowObject::< 
          (# 
          do
             relax;
             'OleClientSite.ShowObject'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IOleClientSite.ShowObject'->msg.append #);
             NO_ERROR->result;
             'OleClientSite.ShowObject'->debug.locateMsg.out
          #);
        OnShowWindow::< 
          (# 
          do
             relax;
             'OleClientSite.OnShowWindow'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IOleClientSite.OnShowWindow'->msg.append #);
             NO_ERROR->result;
             'OleClientSite.OnShowWindow'->debug.locateMsg.out
          #);
        RequestNewObjectLayout::< 
          (# 
          do
             relax;
             'OleClientSite.RequestNewObjectLayout'->debug.locateMsg.in;
             debug.interfaceMsg
               (# 
               do 'IOleClientSite.RequestNewObjectLayout'->msg.append
               #);
             E_NOTIMPL->result;
             'OleClientSite.RequestNewObjectLayout'->debug.locateMsg.out
          #)
     #);
   CImpAdviseSink: IAdviseSink
     (#
        PROTECTED: (#  #);
        m_cRef: (* =ULONG *) @integer;
        m_pSite: (* =class CSite* *) ^CSite;
        m_pUnkOuter: (* LPUNKNOWN *) ^IUnknown;
        ;
        ;
        PUBLIC: (#  #);
        constructor:
          (# pSite: ^CSite; pUnkOuter: (* = LPUNKNOWN *) ^IUnknown
          enter (pSite[],pUnkOuter[])
          do
             debug.locate2Msg
               (#  do 'IAdviseSink.constructor'->putline #);
             0->m_cRef;
             pSite[]->m_pSite[];
             pUnkOuter[]->m_pUnkOuter[]
          #);
        destructor:
          (# 
          do debug.locate2Msg (#  do 'IAdviseSink.destructor'->putline #)
          #);
        QueryInterface::< 
          (# 
          do
             relax;
             'AdviseSink.QueryInterface'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do '++IAdviseSink.QueryInterface'->msg.append #);
             (riid[],ppvObject[])->m_pUnkOuter.QueryInterface->result;
             'AdviseSink.QueryInterface'->debug.locateMsg.out
          #);
        AddRef::< 
          (# 
          do
             relax;
             'AdviseSink.AddRef'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do '--IAdviseSink.AddRef'->msg.append #);
             m_cRef+1->m_cRef;
             m_pUnkOuter.AddRef->result;
             'AdviseSink.AddRef'->debug.locateMsg.out
          #);
        Release::< 
          (# 
          do
             relax;
             'AdviseSink.Release'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do '--IAdviseSink.Release'->msg.append #);
             m_cRef-1->m_cRef;
             m_pUnkOuter.Release->result;
             'AdviseSink.AddRef'->debug.locateMsg.out
          #);
        ;
        OnDataChange::< 
          (# 
          do
             relax;
             'AdviseSink.OnDataChange'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IAdviseSink.OnDataChange'->msg.append #);
             'AdviseSink.OnDataChange'->debug.locateMsg.out
          #);
        OnViewChange::< 
          (# 
          do
             relax;
             'AdviseSink.OnViewChange'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IAdviseSink.OnViewChange'->msg.append #);
             'AdviseSink.OnViewChange'->debug.locateMsg.out
          #);
        OnRename::< 
          (# 
          do
             relax;
             'AdviseSink.OnRename'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IAdviseSink.OnRename'->msg.append #);
             'AdviseSink.OnRename'->debug.locateMsg.out
          #);
        OnSave::< 
          (# 
          do
             relax;
             'AdviseSink.OnSave'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IAdviseSink.OnSave'->msg.append #);
             'AdviseSink.OnSave'->debug.locateMsg.out
          #);
        OnClose::< 
          (# hwnd: @int32holder
          do (* m_pSite.m_pFR.Close *)
             relax;
             'AdviseSink.OnClose'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IAdviseSink.OnClose'->msg.append #);
             ;
             hwnd[]->m_pSite.m_pFR.theOleInPlaceFrame.GetWindow;
             (hwnd,WM_COMMAND,resource.IDM_FILECLOSE %bor 0,0)->PostMessage;
             'AdviseSink.OnClose'->debug.locateMsg.out
          #)
     #);
   CImpOleInPlaceSite: IOleInPlaceSite
     (#
        PROTECTED: (#  #);
        m_cRef: (* =ULONG *) @integer;
        m_pSite: (* =class CSite* *) ^CSite;
        m_pUnkOuter: (* LPUNKNOWN *) ^IUnknown;
        ;
        ;
        PUBLIC: (#  #);
        constructor:
          (# pSite: ^CSite; pUnkOuter: (* = LPUNKNOWN *) ^IUnknown
          enter (pSite[],pUnkOuter[])
          do
             debug.locate2Msg
               (#  do 'IOleInPlaceSite.constructor'->putline #);
             0->m_cRef;
             pSite[]->m_pSite[];
             pUnkOuter[]->m_pUnkOuter[]
          #);
        destructor:
          (# 
          do
             debug.locate2Msg
               (#  do 'IOleInPlaceSite.destructor'->putline #)
          #);
        QueryInterface::< 
          (# 
          do
             relax;
             'OleInPlaceSite.QueryInterface'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do '++IOleInPlaceSite.QueryInterface'->msg.append #);
             (riid[],ppvObject[])->m_pUnkOuter.QueryInterface->result;
             'OleInPlaceSite.QueryInterface'->debug.locateMsg.out
          #);
        AddRef::< 
          (# 
          do
             relax;
             'OleInPlaceSite.AddRef'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do '--IOleInPlaceSite.AddRef'->msg.append #);
             m_cRef+1->m_cRef;
             m_pUnkOuter.AddRef->result;
             'OleInPlaceSite.AddRef'->debug.locateMsg.out
          #);
        Release::< 
          (# 
          do
             relax;
             'OleInPlaceSite.Release'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do '--IOleInPlaceSite.Release'->msg.append #);
             m_cRef-1->m_cRef;
             m_pUnkOuter.Release->result;
             'OleInPlaceSite.Release'->debug.locateMsg.out
          #);
        ;
        GetWindow::< 
          (# 
          do
             relax;
             'OleInPlaceSite.GetWindow'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IOleInPlaceSite.GetWindow'->msg.append #);
             m_pSite.m_hWnd->phwnd;
             NOERROR->result;
             'OleInPlaceSite.GetWindow'->debug.locateMsg.out
          #);
        ContextSensitiveHelp::< 
          (# 
          do
             relax;
             'OleInPlaceSite.ContextSensitiveHelp'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IOleInPlaceSite.ContextSensitiveHelp'->msg.append #);
             NOERROR->result;
             'OleInPlaceSite.ContextSensitiveHelp'->debug.locateMsg.out
          #);
        CanInPlaceActivate::< 
          (# 
          do
             relax;
             'OleInPlaceSite.CanInPlaceActivate'->debug.locateMsg.in;
             debug.interfaceMsg
               (# 
               do
                  '----------------------------------------------\n'
                    ->msg.append;
                  'IOleInPlaceSite.CanInPlaceActivate'->msg.append
               #);
             NOERROR->result;
             'OleInPlaceSite.CanInPlaceActivate'->debug.locateMsg.out
          #);
        OnInPlaceActivate::< 
          (# IID_IOleIPObject: @IID
          do
             relax;
             'OleInPlaceSite.OnInPlaceActivate'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IOleInPlaceSite.OnInPlaceActivate'->msg.append #);
             ;
             IOleInPlaceObject_IID->IID_IOleIPObject;
             debug.callToObjectMsg
               (# 
               do
                  'IOleInPlaceSite.OnInPlaceActivate: kald til queryinterface'
                    ->msg.append
               #);
             (m_pSite.m_pObj[],IID_IOleIPObject[])->Query
               ->m_pSite.m_pIOleIPObject[];
             debug.callToObjectMsg
               (# 
               do
                  'IOleInPlaceSite.OnInPlaceActivate: kald returneret'
                    ->msg.append
               #);
             ;
             NOERROR->result;
             'OleInPlaceSite.OnInPlaceActivate'->debug.locateMsg.out
          #);
        OnInPlaceDeactivate::< 
          (# 
          do
             relax;
             'OleInPlaceSite.OnInPlaceDeactivate'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IOleInPlaceSite.OnInPlaceDeactivate'->msg.append #);
             'Kalder CSite.Activate med DISCARDUNDOSTATE'->putline;
             OLEIVERB_DISCARDUNDOSTATE->m_pSite.Activate;
             'Kalder CSite.Activate med DISCARDUNDOSTATE - returneret'->putline;
             ReleaseInterface: (* macro ReleaseInterface expanded *)
               (# pt: ^IUnknown
               do
                  m_pSite.m_pIOleIPObject[]->pt[];
                  (if pt[] <> none then
                      debug.callToObjectMsg
                        (# 
                        do
                           'IOleInPlaceSite.OnInPlaceDeactivate: kald til Release'
                             ->msg.append
                        #);
                      pt.Release;
                      debug.callToObjectMsg
                        (# 
                        do
                           'IOleInPlaceSite.OnInPlaceDeactivate: kald returneret'
                             ->msg.append
                        #)
                  if)
               #);
             NOERROR->result;
             'OleInPlaceSite.OnInPlaceDeactivate'->debug.locateMsg.out
          #);
        OnUIActivate::< 
          (# 
          do
             relax;
             'OleInPlaceSite.OnUIActivate'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IOleInPlaceSite.OnUIActivate'->msg.append #);
             NOERROR->result;
             'OleInPlaceSite.OnUIActivate'->debug.locateMsg.out
          #);
        OnUIDeactivate::< 
          (# 
          do
             relax;
             'OleInPlaceSite.OnUIDeactivate'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IOleInPlaceSite.OnUIDeactivate'->msg.append #);
             'SetFocus(m_pSite->m_pFR->Window());  m_pSite.m_pFR.SetMenu'
               ->putline;
             NOERROR->result;
             'OleInPlaceSite.OnUIDeactivate'->debug.locateMsg.out
          #);
        DeactivateAndUndo::< 
          (# 
          do
             relax;
             'OleInPlaceSite.DeactivateAndUndo'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IOleInPlaceSite.DeactivateAndUndo'->msg.append #);
             debug.callToObjectMsg
               (# 
               do
                  'IOleInPlaceSite.DeactivateAndUndo: kald til InPlaceDeactivate'
                    ->msg.append
               #);
             m_pSite.m_pIOleIPObject.InPlaceDeactivate;
             debug.callToObjectMsg
               (# 
               do
                  'IOleInPlaceSite.DeactivateAndUndo: kald returneret'
                    ->msg.append
               #);
             NOERROR->result;
             'OleInPlaceSite.DeactivateAndUndo'->debug.locateMsg.out
          #);
        DiscardUndoState::< 
          (# 
          do
             relax;
             'OleInPlaceSite.DiscardUndoState'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IOleInPlaceSite.DiscardUndoState'->msg.append #);
             E_NOTIMPL->result;
             'OleInPlaceSite.DiscardUndoState'->debug.locateMsg.out
          #);
        GetWindowContext::< 
          (# IID_IOleInPlaceFrame: @IID; anInt32Holder: @int32holder; 
          do
             relax;
             'OleInPlaceSite.GetWindowContext'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IOleInPlaceSite.GetWindowContext'->msg.append #);
             ;
             none ->ppDoc;
             ;
             IOleInPlaceFrame_IID->IID_IOleInPlaceFrame;
             (m_pSite.m_pFR[],IID_IOleInPlaceFrame[])->Query->ppFrame;
             ;
             (if lprcPosRect[] <> none then
                 (if true then
                     (m_pSite.m_hWnd,lprcPosRect[])->GetClientRect2
                  else
                     m_pSite.m_hWnd->anInt32Holder;
                     (anInt32Holder[],lprcPosRect[])->GetClientRect3
                 if);
                 debug.debugMsg
                   (# 
                   do
                      'GetWindowContext: GetClientRect='->msg.append;
                      lprcPosRect.top->msg.putint;
                      ','->msg.append;
                      lprcPosRect.bottom->msg.putint;
                      ','->msg.append;
                      lprcPosRect.left->msg.putint;
                      ','->msg.append;
                      lprcPosRect.right->msg.putint
                   #)
             if);
             ;
             lprcPosRect.left->lprcClipRect.left;
             lprcPosRect.right->lprcClipRect.right;
             lprcPosRect.top->lprcClipRect.top;
             lprcPosRect.bottom->lprcClipRect.bottom;
             ;
             20->lpFrameInfo.cb;
             false->lpFrameInfo.fMDIApp;
             m_pSite.m_pFR.Window_->lpFrameInfo.hwndFrame;
             m_pSite.m_pFR.Accelerators->lpFrameInfo.haccel;
             CACCELERATORS->lpFrameInfo.cAccelEntries;
             ;
             NOERROR->result;
             'OleInPlaceSite.GetWindowContext'->debug.locateMsg.out
          #);
        Scroll::< 
          (# 
          do
             relax;
             'OleInPlaceSite.Scroll'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IOleInPlaceSite.Scroll'->msg.append #);
             E_NOTIMPL->result;
             'OleInPlaceSite.Scroll'->debug.locateMsg.out
          #);
        OnPosRectChange::< 
          (# 
          do
             relax;
             'OleInPlaceSite.OnPosRectChange'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IOleInPlaceSite.OnPosRectChange'->msg.append #);
             E_NOTIMPL->result;
             'OleInPlaceSite.OnPosRectChange'->debug.locateMsg.out
          #)
     #);
   CImpOleDocumentSite: IOleDocumentSite
     (#
        PROTECTED: (#  #);
        m_cRef: (* =ULONG *) @integer;
        m_pSite: (* =class CSite* *) ^CSite;
        m_pUnkOuter: (* LPUNKNOWN *) ^IUnknown;
        ;
        ;
        PUBLIC: (#  #);
        constructor:
          (# pSite: ^CSite; pUnkOuter: (* = LPUNKNOWN *) ^IUnknown
          enter (pSite[],pUnkOuter[])
          do
             debug.locate2Msg
               (#  do 'IOleDocumentSite.constructor'->putline #);
             0->m_cRef;
             pSite[]->m_pSite[];
             pUnkOuter[]->m_pUnkOuter[]
          #);
        destructor:
          (# 
          do
             debug.locate2Msg
               (#  do 'IOleDocumentSite.destructor'->putline #)
          #);
        QueryInterface::< 
          (# 
          do
             relax;
             'OleDocumentSite.QueryInterface'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do '++IOleDocumentSite.QueryInterface'->msg.append #);
             (riid[],ppvObject[])->m_pUnkOuter.QueryInterface->result;
             'OleDocumentSite.QueryInterface'->debug.locateMsg.out
          #);
        AddRef::< 
          (# 
          do
             relax;
             'OleDocumentSite.AddRef'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do '--IOleDocumentSite.AddRef'->msg.append #);
             m_cRef+1->m_cRef;
             m_pUnkOuter.AddRef->result;
             'OleDocumentSite.AddRef'->debug.locateMsg.out
          #);
        Release::< 
          (# 
          do
             relax;
             'OleDocumentSite.Release'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do '--IOleDocumentSite.Release'->msg.append #);
             m_cRef-1->m_cRef;
             m_pUnkOuter.Release->result;
             'OleDocumentSite.Release'->debug.locateMsg.out
          #);
        ;
        ActivateMe::< 
          (#
             pDoc: ^IOleDocument;
             IID_IOleDocument: @IID;
             anIOleDocumentViewHolder: @IOleDocumentViewHolder
          do
          (* Set the window size sensitive to new toolbars.
           GetClientRect(m_pSite->m_hWnd, &rc);
           pView->SetRect(&rc); *)
             'OleDocumentSite.ActivateMe'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do 'IOleDocumentSite.ActivateMe'->msg.append #);
             ;
             (if pViewToActivate[] = none then
             (* If we're passed a NULL view pointer, then try to get one from
              the document object (the object within us). *)
                 IOleDocument_IID->IID_IOleDocument;
                 debug.callToObjectMsg
                   (# 
                   do
                      'IOleDocumentSite.ActivateMe: kald til QueryInterface'
                        ->msg.append
                   #);
                 (m_pSite.m_pObj[],IID_IOleDocument[])->Query->pDoc[];
                 debug.callToObjectMsg
                   (# 
                   do
                      'IOleDocumentSite.ActivateMe: kald til QueryInterface returneret'
                        ->msg.append
                   #);
                 ;
                 pViewToActivate[]->anIOleDocumentViewHolder;
                 debug.callToObjectMsg
                   (# 
                   do
                      'IOleDocumentSite.ActivateMe: kald til CreateView'
                        ->msg.append
                   #);
                 (m_pSite.m_pImpIOleIPSite[],m_pSite.m_pIStream[],0,
                  anIOleDocumentViewHolder[])->pDoc.CreateView;
                 debug.callToObjectMsg
                   (# 
                   do
                      'IOleDocumentSite.ActivateMe: kald til CreateView returneret'
                        ->msg.append
                   #);
                 ;
                 debug.callToObjectMsg
                   (# 
                   do
                      'IOleDocumentSite.ActivateMe: kald til Release'
                        ->msg.append
                   #);
                 pDoc.Release;
                 debug.callToObjectMsg
                   (# 
                   do
                      'IOleDocumentSite.ActivateMe: kald til Release returneret'
                        ->msg.append
                   #)
              else
                 debug.callToObjectMsg
                   (# 
                   do
                      'IOleDocumentSite.ActivateMe: kald til SetInPlaceSite'
                        ->msg.append
                   #);
                 (m_pSite.m_pImpIOleIPSite[])
                   ->
                     pViewToActivate.SetInPlaceSite
                     (* make sure that the view has our client site *) ;
                 debug.callToObjectMsg
                   (# 
                   do
                      'IOleDocumentSite.ActivateMe: kald til SetInPlaceSite returneret'
                        ->msg.append
                   #);
                 debug.callToObjectMsg
                   (# 
                   do
                      'IOleDocumentSite.ActivateMe: kald til AddRef'->msg.append
                   #);
                 pViewToActivate.AddRef;
                 debug.callToObjectMsg
                   (# 
                   do
                      'IOleDocumentSite.ActivateMe: kald til AddRef returneret'
                        ->msg.append
                   #)
             if);
             ;
             true->m_pSite.m_fDocObj;
             pViewToActivate[]->m_pSite.m_pIOleDocView[];
             ;
             debug.callToObjectMsg
               (# 
               do
                  'IOleDocumentSite.ActivateMe: kald til UIActivate'->msg.append
               #);
             true
               ->
                 pViewToActivate.UIActivate
                 (* this sets up toolbars and menus first *) ;
             debug.callToObjectMsg
               (# 
               do
                  'IOleDocumentSite.ActivateMe: kald til UIActivate returneret'
                    ->msg.append
               #);
             ;
             ;
             debug.callToObjectMsg
               (# 
               do 'IOleDocumentSite.ActivateMe: kald til Show'->msg.append
               #);
             true->pViewToActivate.Show;
             debug.callToObjectMsg
               (# 
               do
                  'IOleDocumentSite.ActivateMe: kald til Show returneret'
                    ->msg.append
               #);
             ;
             NOERROR->result;
             'OleDocumentSite.ActivateMe'->debug.locateMsg.out
          #)
     #);
   CSite: IUnknown
     (#
        PRIVATE: (#  #);
        m_cRef: @integer (* originally ULONG *) ;
        m_dwID: @integer (* originally DWORD *) ;
        m_hWnd: @integer
        (* Client area window of parent.
         originally HWND *) ;
        ;
        m_pFR: ^CFrameType;
        ;
        m_fInitialized: (* Something here? *) @boolean;
        m_pIStorage:
        (* Storage for object.
         Originally LPSTORAGE *) ^IStorage;
        m_pIStream:
        (* Info stream for object.
         LPSTREAM *) ^IStream;
        ;
        m_pObj: ^IUnknown;
        m_pIOleObject: ^IOleObject;
        m_pIOleIPObject: ^IOleInPlaceObject;
        m_pIOleDocView: ^IOleDocumentView;
        ;
        m_fDocObj: (* Document object here? *) @boolean;
        ;
        m_pImpIOleClientSite: ^CImpOleClientSite;
        m_pImpIAdviseSink: ^CImpAdviseSink;
        m_pImpIOleIPSite: ^CImpOleInPlaceSite;
        m_pImpIOleDocumentSite: ^CImpOleDocumentSite;
        ;
        ;
        PROTECTED: (#  #);
        ObjectInitialize:
          (#
             pObj: ^IUnknown;
             result: @boolean;
             hr: @HResult;
             dw: @int32uHolder (* DWORD* *) ;
             IID_IOleObject: @IID
          enter pObj[]
          do
             relax;
             'CSite.ObjectInitialize'->debug.locateMsg.in;
             debug.locate2Msg
               (#  do 'CSite.ObjectInitialize'->putline #);
             return:
             (* When the C program says "return X", 
              we say "X->result; leave return". *)
               (# hr: @HResult
               do
                  (if pObj[] = none then false->result; leave return if);
                  pObj[]->m_pObj[];
                  ;
                  none
                    ->m_pIOleObject[]
                    (* We need an IOleObject most of the time, so get one here *)
                    ;
                  IOleObject_IID->IID_IOleObject;
                  debug.callToObjectMsg
                    (# 
                    do
                       'CSite.ObjectInitialize: kald til QueryInterface'
                         ->msg.append
                    #);
                  (pObj[],IID_IOleObject[])->Query->m_pIOleObject[];
                  debug.callToObjectMsg
                    (# 
                    do
                       'CSite.ObjectInitialize: kald til QueryInterface returneret'
                         ->msg.append
                    #);
                  ;
                  debug.callToObjectMsg
                    (# 
                    do
                       'CSite.ObjectInitialize: kald til SetClientSite'
                         ->msg.append
                    #);
                  m_pImpIOleClientSite[]->m_pIOleObject.SetClientSite
                    ->hr (* SetClientSite is critical for DocObjects *) ;
                  debug.callToObjectMsg
                    (# 
                    do
                       'CSite.ObjectInitialize: kald til SetClientSite returneret'
                         ->msg.append
                    #);
                  debug.debugMsg
                    (# 
                    do
                       (if hr.succeeded then
                           (if false then
                               'ObjectInitialize: SetClientSite succeeded'
                                 ->msg.append
                           if)
                        else
                           'ObjectInitialize: SetClientSite failed'->msg.append
                       if)
                    #);
                  debug.callToObjectMsg
                    (# 
                    do 'CSite.ObjectInitialize: kald til Advise'->msg.append
                    #);
                  (m_pImpIAdviseSink[],dw[])->m_pIOleObject.Advise->hr;
                  debug.callToObjectMsg
                    (# 
                    do
                       'CSite.ObjectInitialize: kald til Advise returneret'
                         ->msg.append
                    #);
                  debug.debugMsg
                    (# 
                    do
                       (if hr.succeeded then
                           (if false then
                               'ObjectInitialize: Advise succeeded'->msg.append
                           if)
                        else
                           'ObjectInitialize: Advise failed'->msg.append
                       if)
                    #);
                  ;
                  (if false then (none ,'Before OLERUN',none )->alertUser if);
                  m_pIOleObject[]
                    ->OleRun
                    (* This is to give PowerPoint a chance to initialize itself earlier *)
                    ;
                  (if false then (none ,'After OLERUN',none )->alertUser if);
                  true->result;
                  leave return
               #);
             'CSite.ObjectInitialize'->debug.locateMsg.out
          exit result
          #);
        ;
        ;
        PUBLIC: (#  #);
        constructor:
          (# dwID,hWnd: @integer; pFR: ^CFrameType
          enter (dwID,hWnd,pFR[])
          do
             debug.locate2Msg
               (#  do 'CSite.Constructor'->putline #);
             0->m_cRef;
             dwID->m_dwID;
             hWnd->m_hWnd;
             pFR[]->m_pFR[];
             ;
             0->m_fInitialized;
             none ->m_pIStorage[];
             ;
             none ->m_pObj[];
             ;
             none ->m_pIOleObject[];
             none ->m_pIOleIPObject[];
             none ->m_pIOleDocView[];
             ;
             none ->m_pImpIOleClientSite[];
             none ->m_pImpIAdviseSink[];
             none ->m_pImpIOleIPSite[];
             none ->m_pImpIOleDocumentSite[];
             ;
             false->m_fDocObj
          #);
        destructor:
          (# pt: ^IUnknown
          do
             debug.locate2Msg
               (#  do 'CSite.Destructor'->putline #);
             m_pImpIOleDocumentSite[]->pt[];
             none ->m_pImpIOleDocumentSite[];
             (if pt[] <> none then pt.Release if);
             ;
             m_pImpIOleIPSite[]->pt[];
             none ->m_pImpIOleIPSite[];
             (if pt[] <> none then pt.Release if);
             ;
             m_pImpIAdviseSink[]->pt[];
             none ->m_pImpIAdviseSink[];
             (if pt[] <> none then pt.Release if);
             ;
             m_pImpIOleClientSite[]->pt[];
             none ->m_pImpIOleClientSite[];
             (if pt[] <> none then pt.Release if)
          #);
        QueryInterface::< 
          (#
             Marshal_IID,Unknown_IID,OleClientSite_IID,AdviseSink_IID,
               OleWindow_IID,OleInPlaceSite_IID,OleDocumentSite_IID: @IID;
             init:
               (# 
               do
                  IUnknown_IID->Unknown_IID;
                  IOleClientSite_IID->OleClientSite_IID;
                  IAdviseSink_IID->AdviseSink_IID;
                  IOleWindow_IID->OleWindow_IID;
                  IOleInPlaceSite_IID->OleInPlaceSite_IID;
                  IOleDocumentSite_IID->OleDocumentSite_IID;
                  IMarshal_IID->Marshal_IID;
                  ;
                  (if false then
                      debug.debugMsg
                        (# 
                        do
                           'This QueryInterface supports: '->msg.append;
                           Unknown_IID->msg.append;
                           ', '->msg.append;
                           OleClientSite_IID->msg.append;
                           ', '->msg.append;
                           AdviseSink_IID->msg.append;
                           ', '->msg.append;
                           OleWindow_IID->msg.append;
                           ', '->msg.append;
                           OleInPlaceSite_IID->msg.append;
                           ', '->msg.append;
                           OleDocumentSite_IID->msg.append;
                           ;
                           (if false then
                               'The IID for IMarshal is '->msg.append;
                               Marshal_IID->msg.append
                           if)
                        #)
                  if)
               #);
             doAlertUser: (#  exit false #);
             ;
             aGUID: @GUID
          do
             relax;
             'CSite.QueryInterface'->debug.locateMsg.in;
             debug.interfaceMsg
               (#  do '++CSite.QueryInterface'->msg.append #);
             ;
             init;
             riid[]->aGUID.binary[];
             (if false then
                 debug.debugMsg
                   (# 
                   do
                      'Csite.QueryInterface: Request for interface '
                        ->msg.append;
                      aGUID->msg.append
                   #)
             if);
             ;
             none ->ppvObject;
             (if true
              // aGUID[]->Unknown_IID.equal then
                 debug.interfaceMsg (#  do '       -IUnknown'->msg.append #)
              // aGUID[]->OleClientSite_IID.equal then
                 debug.interfaceMsg
                   (#  do '       -IOleClientSite'->msg.append #)
              // aGUID[]->AdviseSink_IID.equal then
                 debug.interfaceMsg
                   (#  do '       -IAdviseSink'->msg.append #)
              // aGUID[]->OleWindow_IID.equal then
                 debug.interfaceMsg
                   (#  do '       -IOleWindow'->msg.append #)
              // aGUID[]->OleInPlaceSite_IID.equal then
                 debug.interfaceMsg
                   (#  do '       -IOleInPlaceSite'->msg.append #)
              // aGUID[]->OleDocumentSite_IID.equal then
                 debug.interfaceMsg
                   (#  do '       -IOleDocumentSite'->msg.append #)
             if);
             (if true
              // aGUID[]->Unknown_IID.equal then
                 THIS(IUnknown)[]->ppvObject;
                 (if doAlertUser then
                     (none ,'CSite.QueryInterface IUnknown',none )->alertUser
                 if)
              // aGUID[]->OleClientSite_IID.equal then
                 m_pImpIOleClientSite[]->ppvObject;
                 (if doAlertUser then
                     (none ,'CSite.QueryInterface IOleClientSite',none )
                       ->alertUser
                 if)
              // aGUID[]->AdviseSink_IID.equal then
                 m_pImpIAdviseSink[]->ppvObject;
                 (if doAlertUser then
                     (none ,'CSite.QueryInterface IAdviseSink',none )->alertUser
                 if)
              // aGUID[]->OleWindow_IID.equal
              // aGUID[]->OleInPlaceSite_IID.equal then
                 m_pImpIOleIPSite[]->ppvObject;
                 (if doAlertUser then
                     (none ,'CSite.QueryInterface IOleWindow/IOleInPlaceSite',
                      none )->alertUser
                 if)
              // aGUID[]->OleDocumentSite_IID.equal then
                 m_pImpIOleDocumentSite[]->ppvObject;
                 (if doAlertUser then
                     (none ,'CSite.QueryInterface IOleDocumentSite',none )
                       ->alertUser
                 if)
             if);
             ;
             (if ppvObject <> none then
                 ppvObject.ref.AddRef; NOERROR->result
              else
                 debug.interfaceMsg
                   (#  do '       -No such interface'->msg.append #);
                 E_NOINTERFACE->result;
                 (if doAlertUser then
                     (none ,'CSite.QueryInterface: No such interface!',none )
                       ->alertUser
                 if)
             if);
             'CSite.QueryInterface'->debug.locateMsg.out
          #);
        AddRef::< 
          (# 
          do
             relax;
             'CSite.AddRef'->debug.locateMsg.in;
             debug.interfaceMsg
               (# 
               do
                  '--CSite.AddRef ('->msg.append;
                  m_cRef+1->msg.putint;
                  ')'->msg.append
               #);
             m_cRef+1->m_cRef->result;
             'CSite.AddRef'->debug.locateMsg.out
          #);
        Release::< 
          (# 
          do
             relax;
             'CSite.Release'->debug.locateMsg.in;
             debug.interfaceMsg
               (# 
               do
                  '--CSite.Release ('->msg.append;
                  m_cRef-1->msg.putint;
                  ')'->msg.append
               #);
             m_cRef-1->m_cRef->result;
             (if m_cRef = 0 then
                 '====> CSite ref count is zero.'->putline
             if);
             'CSite.Release'->debug.locateMsg.out
          #);
        ;
        Create:
          (#
             filename: ^text;
             pIStorage: ^IStorage;
             result: @boolean;
             hr: @HResult;
             pObj: ^IUnknown;
             IID_IUnknown: @IID;
             anIUnknownHolder: @IUnknownHolder;
             awtext: @bstr
          enter (filename[],pIStorage[])
          do
             relax;
             'CSite.Create'->debug.locateMsg.in;
             debug.locate2Msg
               (#  do 'CSite.Create'->putline #);
             E_FAIL->hr;
             return:
             (* when the C program says "return something",
              we say "something->result; leave return" *)
               (# 
               do
                  pIStorage[]->CreateStorage
                    ->result
                    (* Create a new storage for this object (sets m_pIStorage) *)
                    ;
                  (if result = false then
                      'CSite.Create: CreateStorage failed'->putline;
                      leave return
                  if);
                  ;
                  IUnknown_IID->IID_IUnknown;
                  filename[]->awtext.setText;
                  pObj[]->anIUnknownHolder;
                  ((getGUID_NULL).binary[],awtext.wcharptr,
                   IID_IUnknown.binary[],OLERENDER_NONE,0 (* lpFormatEtc *) ,
                   none ,m_pIStorage[],anIUnknownHolder[])->OleCreateFromFile
                    ->hr;
                  anIUnknownHolder->pObj[];
                  debug.debugMsg
                    (# 
                    do
                       (if hr.failed then
                           'CSite.Create: OleCreateFromFile failed'->msg.append
                        else
                           (if false then
                               'CSite.Create: OleCreateFromFile succeeded'
                                 ->msg.append
                           if)
                       if)
                    #);
                  ;
                  (if hr.failed then
                  (* If creation didn't work, get rid of the element Open created. *)
                      pIStorage[]->Destroy; false->result; leave return
                  if);
                  ;
                  (if not (pObj[]->ObjectInitialize) then
                  (* We don't get the size if PatronObject data was seen already. *)
                      'ObjectInitialize returned false'->putline;
                      pIStorage[]->Destroy;
                      false->result;
                      leave return
                  if);
                  ;
                  true->m_fInitialized;
                  true->result;
                  leave return
               #);
             'CSite.Create'->debug.locateMsg.out
          exit result
          #);
        CreateStorage:
          (#
             result: @boolean;
             pIStorage: ^IStorage (* pointer to the parent storage *) ;
             hr: @HRESULT;
             dwMode: @int32uHolder (* DWORD* *) ;
             szName: @text;
             szName2: [0] @char (* ^text NYI *) (* OLECHAR* *) ;
             anIStorageHolder: @IStorageHolder;
             anIStreamHolder: @IStreamHolder;
             awtext: @bstr
          enter pIStorage[]
          do
             relax;
             'CSite.CreateStorage'->debug.locateMsg.in;
             debug.locate2Msg
               (#  do 'CSite.CreateStorage'->putline #);
             (STGM_TRANSACTED %Bor STGM_READWRITE %Bor STGM_SHARE_EXCLUSIVE)
               ->dwMode;
             ;
             return:
             (* When the C program says "return X", 
              we say "X->result; leave return". *)
               (# 
               do
                  (if pIStorage[] = none then
                      'CSite.CreateStorage: pIStorage[]=none'->putline;
                      false->result;
                      leave return
                  if);
                  ;
                  'Site '
                    ->szName (* wsprintf(szName, TEXT("Site %lu"), m_dwID); *) ;
                  m_dwID->szName.putint;
                  szName->szName2;
                  ;
                  m_pIStorage[]->anIStorageHolder;
                  debug.callToObjectMsg
                    (# 
                    do
                       'CSite.CreateStorage: kald til CreateStorage'->msg.append
                    #);
                  (szName2,dwMode,0,0,anIStorageHolder[])
                    ->pIStorage.CreateStorage->hr;
                  debug.callToObjectMsg
                    (# 
                    do
                       'CSite.CreateStorage: kald til CreateStorage returneret'
                         ->msg.append
                    #);
                  anIStorageHolder->m_pIStorage[];
                  (if hr.failed then
                      'CreateStorage failed'->putline;
                      false->result;
                      leave return
                  if);
                  ;
                  (STGM_DIRECT %Bor STGM_READWRITE %Bor STGM_SHARE_EXCLUSIVE)
                    ->dwMode
                    (* Create stream for the object; name is irrelevant *) ;
                  'DocObjInfo'->awtext.settext;
                  debug.callToObjectMsg
                    (# 
                    do 'CSite.CreateStorage: kald til CreateStream'->msg.append
                    #);
                  (awtext.wcharptr,dwMode,0,0,anIStreamHolder[])
                    ->m_pIStorage.CreateStream->hr;
                  debug.callToObjectMsg
                    (# 
                    do
                       'CSite.CreateStorage: kald til CreateStream returneret'
                         ->msg.append
                    #);
                  anIStreamHolder->m_pIStream[];
                  (if hr.failed then
                  (* If we failed to create a stream in the file, do it in memory *)
                      'CreateStream failed'->putline;
                      'CreateStreamOnHGlobal kald'->putline
                  if);
                  ;
                  &CImpOleClientSite[]
                    ->m_pImpIOleClientSite[]
                    (* Create interface implementations *) ;
                  (THIS(CSite)[],THIS(IUnknown)[])
                    ->m_pImpIOleClientSite.constructor;
                  &CImpAdviseSink[]->m_pImpIAdviseSink[];
                  (THIS(CSite)[],THIS(IUnknown)[])
                    ->m_pImpIAdviseSink.constructor;
                  &CImpOleInPlaceSite[]->m_pImpIOleIPSite[];
                  (THIS(CSite)[],THIS(IUnknown)[])
                    ->m_pImpIOleIPSite.constructor;
                  &CImpOleDocumentSite[]->m_pImpIOleDocumentSite[];
                  (THIS(CSite)[],THIS(IUnknown)[])
                    ->m_pImpIOleDocumentSite.constructor;
                  ;
                  (if (m_pImpIOleClientSite[] = none ) or
                  (m_pImpIAdviseSink[] = none ) or (m_pImpIOleIPSite[] = none )
                  or (m_pImpIOleDocumentSite[] = none ) then
                      false->result; leave return
                  if);
                  ;
                  true->result;
                  leave return
               #);
             'CSite.CreateStorage'->debug.locateMsg.out
          exit result
          #);
        Close:
          (# fCommit: @boolean
          enter fCommit
          do
             relax;
             'CSite.Close'->debug.locateMsg.in;
             debug.locate2Msg
               (#  do 'CSite.Close'->putline #);
             (if m_pIOleIPObject[] <> none then
                 m_pIOleIPObject.InPlaceDeactivate
             if);
             ;
             ReleaseInterface: (* expanded macro *)
               (# pt: ^IUnknown
               do
                  m_pIOleDocView[]->pt[];
                  none ->m_pIOleDocView[];
                  (if pt[] <> none then
                      debug.callToObjectMsg
                        (# 
                        do 'CSite.Close: kald til Release'->msg.append
                        #);
                      pt.Release;
                      debug.callToObjectMsg
                        (# 
                        do
                           'CSite.Close: kald til Release returneret'
                             ->msg.append
                        #)
                  if)
               #);
             ;
             (if m_pIOleObject[] <> none then
                 (if fCommit then
                     debug.callToObjectMsg
                       (#  do 'CSite.Close: kald til Close'->msg.append #);
                     OLECLOSE_SAVEIFDIRTY->m_pIOleObject.close;
                     debug.callToObjectMsg
                       (# 
                       do 'CSite.Close: kald til Close returneret'->msg.append
                       #)
                  else
                     debug.callToObjectMsg
                       (#  do 'CSite.Close: kald til Close'->msg.append #);
                     OLECLOSE_NOSAVE->m_pIOleObject.close;
                     debug.callToObjectMsg
                       (# 
                       do 'CSite.Close: kald til Close returneret'->msg.append
                       #)
                 if);
                 ReleaseInterface: (* expanded macro *)
                   (# pt: ^IUnknown
                   do
                      m_pIOleObject[]->pt[];
                      none ->m_pIOleObject[];
                      (if pt[] <> none then
                          debug.callToObjectMsg
                            (# 
                            do 'CSite.Close: kald til Release'->msg.append
                            #);
                          pt.Release;
                          debug.callToObjectMsg
                            (# 
                            do
                               'CSite.Close: kald til Release returneret'
                                 ->msg.append
                            #)
                      if)
                   #)
             if);
             ;
             ReleaseInterface: (* expanded macro *)
               (# pt: ^IUnknown
               do
                  m_pObj[]->pt[];
                  none ->m_pObj[];
                  (if pt[] <> none then
                      debug.callToObjectMsg
                        (# 
                        do 'CSite.Close: kald til Release'->msg.append
                        #);
                      pt.Release;
                      debug.callToObjectMsg
                        (# 
                        do
                           'CSite.Close: kald til Release returneret'
                             ->msg.append
                        #)
                  if)
               #);
             ReleaseInterface: (* expanded macro *)
               (# pt: ^IUnknown
               do
                  m_pIStream[]->pt[];
                  none ->m_pIStream[];
                  (if pt[] <> none then
                      debug.callToObjectMsg
                        (# 
                        do 'CSite.Close: kald til Release'->msg.append
                        #);
                      pt.Release;
                      debug.callToObjectMsg
                        (# 
                        do
                           'CSite.Close: kald til Release returneret'
                             ->msg.append
                        #)
                  if)
               #);
             ReleaseInterface: (* expanded macro *)
               (# pt: ^IUnknown
               do
                  m_pIStorage[]->pt[];
                  none ->m_pIStorage[];
                  (if pt[] <> none then
                      debug.callToObjectMsg
                        (# 
                        do 'CSite.Close: kald til Release'->msg.append
                        #);
                      pt.Release;
                      debug.callToObjectMsg
                        (# 
                        do
                           'CSite.Close: kald til Release returneret'
                             ->msg.append
                        #)
                  if)
               #);
             'CSite.Close'->debug.locateMsg.out
          #);
        Update:
          (# IID_IPersistStorage: @IID; pIPS: ^IPersistStorage
          do
             relax;
             'CSite.Update'->debug.locateMsg.in;
             debug.locate2Msg
               (#  do 'CSite.Update'->putline #);
             return:
               (# 
               do
                  (if m_pIStorage[] <> none then leave return if);
                  ;
                  IPersistStorage_IID->IID_IPersistStorage;
                  debug.callToObjectMsg
                    (# 
                    do 'CSite.Update: kald til QueryInterface'->msg.append
                    #);
                  (m_pObj[],IID_IPersistStorage[])->Query->pIPS[];
                  debug.callToObjectMsg
                    (# 
                    do
                       'CSite.Update: kald til QueryInterface returneret'
                         ->msg.append
                    #);
                  (pIPS[],m_pIStorage[],true)->OleSave;
                  debug.callToObjectMsg
                    (# 
                    do
                       'CSite.Update: kald til SaveCompleted+Release'
                         ->msg.append
                    #);
                  none ->pIPS.SaveCompleted;
                  pIPS.Release;
                  debug.callToObjectMsg
                    (# 
                    do
                       'CSite.Update: kald til SaveCompleted+Release returneret'
                         ->msg.append
                    #);
                  ;
                  STGC_DEFAULT->m_pIStorage.Commit;
                  leave return
               #);
             'CSite.Update'->debug.locateMsg.out
          #);
        Destroy:
          (# pIStorage: ^IStorage
          enter pIStorage[]
          do
             relax;
             'CSite.Destroy'->debug.locateMsg.in;
             debug.locate2Msg
               (#  do 'CSite.Destroy'->putline #);
             return:
               (#
                  szName2: @text;
                  szName: [0] @char (* ^text NYI *) (* OLECHAR* *)
               do
                  (if pIStorage[] = none then leave return if);
                  ;
                  (if m_pObj[] <> none then false->close if);
                  ;
                  'Site '->szName2;
                  m_dwID->szName2.putint;
                  szName2->szName;
                  szName->pIStorage.DestroyElement;
                  ;
                  leave return
               #);
             'CSite.Destroy'->debug.locateMsg.out
          #);
        rc: @struct_tagRECT;
        Activate:
          (# iVerb: @int32; aint32holder: @int32Holder; hr: @HResult
          enter iVerb
          do
             relax;
             'CSite.Activate start'->putline;
             'CSite.Activate'->debug.locateMsg.in;
             debug.locate2Msg
               (#  do 'CSite.Activate'->putline #);
             (* m_hWnd->aint32holder *)
             ;
             '1'->putline;
             (if true then
                 (m_hWnd,rc[])->GetClientRect2
              else
                 m_hWnd->Aint32holder;
                 (aInt32Holder[],rc[])->GetClientRect3;
                 aint32holder->m_hWnd
             if);
             '2'->putline;
             debug.debugMsg
               (# 
               do
                  'Activate> GetClientRect: '->msg.append;
                  rc.top->msg.putint;
                  ','->msg.append;
                  rc.bottom->msg.putint;
                  ','->msg.append;
                  rc.left->msg.putint;
                  ','->msg.append;
                  rc.right->msg.putint
               #);
             (* 16->malloc->theNtRectPtr;
              (if theNtRectPtr <> 0 then
              (windowID,theNtRectPtr)->GetClientRect; theNtRectPtr->free; 
              else
              false->didSomething; 
              if);    aint32holder->m_hWnd;
              *)
             ;
             '3'->putline;
             m_hWnd->Aint32holder;
             (if false then
                 (none ,'Calling OleObject.DoVerb... ',none )->alertUser
             if);
             debug.callToObjectMsg
               (#  do 'CSite.Activate: kald til DoVerb'->msg.append #);
             '4'->putline;
             (iVerb,none ,m_pImpIOleClientSite[],0,m_hwnd (*aInt32holder[]*) ,
              rc[])->m_pIOleObject.DoVerb->hr;
             '5'->putline;
             debug.callToObjectMsg
               (# 
               do 'CSite.Activate: kald til DoVerb returneret'->msg.append
               #);
             (if false then
                 (none ,'AFTER calling OleObject.DoVerb... ',none )->alertUser
             if);
             aint32holder->m_hWnd;
             debug.debugMsg
               (# 
               do
                  (if hr.succeeded then
                      'OleObject.DoVerb succeeded'->msg.append;
                      (if false then
                          (none ,'OleObject.DoVerb succeeded',none )->alertUser
                      if)
                   else
                      'OleObject.DoVerb failed '->msg.append;
                      (if false then
                          (none ,'OleObject.DoVerb failed',none )->alertUser
                      if);
                      (if false then
                          'OleObject.DoVerb failed '->puttext;
                          hr.value->debug.myprint
                      if)
                  if)
               #);
             'CSite.Activate'->debug.locateMsg.out;
             'CSite.Activate slut'->putline
          #);
        UpdateObjectRects:
          (# 
          do
             relax;
             'CSite.UpdateObjectRects'->debug.locateMsg.in;
             debug.locate2Msg
               (#  do 'CSite.UpdateObjectRects'->putline #);
             return:
               (# 
               do
                  (if m_pIOleDocView[] = none then leave return if);
                  ;
                  'GetClientRect(m_hWnd, &rc)'->putline;
                  'm_pIOleDocView->SetRect(&rc)'->putline
               #);
             'CSite.UpdateObjectRects'->debug.locateMsg.out
          #)
     #);
   ;
   CFrameType: IUnknown
     (#
        PROTECTED: (#  #);
        m_hInst: (* Task instance.
                  =HINSTANCE *) (#  exit uienvHInstance #);
        m_hWnd: (* Window handle of the window.
                 =HWND *)
          (# handle: @integer
          do
             (if mainWindow[] <> none then
                 mainWindow.InterfaceObjectID->handle;
                 debug.debugMsg
                   (# 
                   do 'CFrame.m_hWnd: handle='->msg.append; handle->msg.putint
                   #)
              else
                 debug.debugMsg
                   (#  do 'CFrame.m_hWnd: mainWindow[]=none'->msg.append #);
                 117->handle
             if)
          exit handle
          #);
        mainWindowType: window
          (#
             open::< 
               (# 
               do (486,338)->size; clientCanvas.open; 'Doc Framer'->title
               #);
             eventHandler::< 
               (# onAboutToClose::<  (#  do onExit #) #);
             menubarType:: 
               (#
                  fileMenu: @menu
                    (#
                       openItem: @menuItem
                         (#
                            eventHandler:: 
                              (# onSelect::  (#  do onOpen;  #);  #);
                            open::  (#  do '&Open'->name; 'o'->key #)
                         #);
                       closeItem: @menuItem
                         (#
                            eventHandler:: 
                              (# onSelect::  (#  do onClose #);  #);
                            open::  (#  do '&Close'->name; 'c'->key #)
                         #);
                       exitItem: @menuItem
                         (#
                            eventHandler:: 
                              (# onSelect::  (#  do onExit #);  #);
                            open::  (#  do 'E&xit'->name; 'x'->key;  #)
                         #);
                       sep1: @separator;
                       open:: 
                         (# 
                         do
                            '&File'->name;
                            openItem.open;
                            openItem[]->append;
                            closeItem.open;
                            closeItem[]->append;
                            sep1.open;
                            sep1[]->append;
                            exitItem.open;
                            exitItem[]->append
                         #)
                    #);
                  shortcutsMenu: @menu
                    (#
                       shortcut1Item: @menuItem
                         (#
                            eventHandler:: 
                              (# onSelect::  (#  do onShortcut1 #);  #);
                            open::  (#  do 'Shortcut &1'->name; '1'->key #)
                         #);
                       open:: 
                         (# 
                         do
                            'Shortcuts'->name;
                            Shortcut1Item.open;
                            Shortcut1Item[]->append
                         #)
                    #);
                  open::< 
                    (# 
                    do
                       fileMenu.open;
                       fileMenu[]->append;
                       ShortcutsMenu.open;
                       ShortcutsMenu[]->append;
                       INNER
                    #)
               #);
             clientCanvas: @canvas
               (#
                  open::< 
                    (# 
                    do
                       4->border.style;
                       true->border.visible;
                       (449,287)->size;
                       (18,32)->position;
                       
                    #);
                  eventHandler::< 
                    (#
                       onEnableTarget::< 
                         (#  do 'WINDOW: onEnableTarget'->putline #);
                       onActivate::< 
                         (# 
                         do (if false then 'WINDOW: onActivate'->putline if)
                         #)
                    #)
               #);
             ;
             onOpen:<
               (# filename: ^text; fOK: @boolean
               do
                  fileSelectionDialog (#  do '*'->filter[] #)->filename[];
                  (if filename[] <> none then
                      'onOpen: "'->puttext;
                      filename[]->puttext;
                      '".'->putline;
                      filename[]->CreateObject->fOK
                   else
                  (* Cancelled *)
                      
                  if)
               #);
             onClose:< (#  do THIS(CFrameType).close #);
             onExit:<
               (# 
               do 'PostMessage(hWnd, WM_CLOSE, 0, 0L)'; debug.close; terminate
               #);
             ;
             onShortcut1:<
               (# filename: ^text; ok: @boolean
               do
                  'c:\\beta\\r4.2dev\\comlib\\demo\\documentcontainer\\__Bitmap.bmp'
                    ->filename[];
                  'onShortcut1: "'->puttext;
                  filename[]->puttext;
                  '".'->putline;
                  filename[]->CreateObject->ok
               #)
          #);
        mainWindow: ^mainWindowType;
        m_cRef: (* =ULONG *) @integer;
        ;
        m_hInstPrev:
        (* WinMain parameters.
         =HINSTANCE *) @integer;
        m_pszCmdLine: (* =LPTSTR *) @ (#  #);
        m_nCmdShow: (* =int *) @integer;
        ;
        m_phMenu: (* Popup menu handles.
                   =HMENU* *)
          (#  exit mainWindow.private.theWin32Menubar.interfaceObjectID #);
        m_hAccel: (* Accelerators.
                   =HACCEL *) @integer;
        m_hWndClient: (* Client area window.
                       =HWND *)
          (# handle: @integer
          do
             (if mainWindow[] <> none then
                 mainWindow.clientCanvas.InterfaceObjectID->handle;
                 debug.debugMsg
                   (# 
                   do
                      (if false then
                          'CFrame.m_hWndClient: handle='->msg.append;
                          handle->msg.putint
                      if)
                   #)
              else
                 'CFrame.m_hWndClient: mainWindow[]=none'->putline
             if)
          exit handle
          #);
        ;
        m_fInitialized:
        (* OleInitialize called?.
         =BOOL *) @boolean;
        m_pIStorage: (* Temp file for all needs.
                      =IStorage* *) ^IStorage;
        m_dwIDCounter: (* For site IDs.
                        =DWORD *) @integer;
        ;
        m_hMenuOrg: (* Original menu.
                     =HMENU *) @integer;
        m_hMenuTop: (* Currently shown menu.
                     =HMENU *) @integer;
        m_hMenuHelp: (* Special Help menu.
                      =HMENU *) @integer;
        m_fUsingOurHelp:
        (* Help menu in use?
         =BOOL *) @boolean;
        m_fInObjectHelp:
        (* Object's menu found?
         =BOOL *) @boolean;
        m_fOurMenuShowing:
        (* Our menu up?
         =BOOL *) @boolean;
        ;
        m_fHaveObject: (* For menu enabling.
                        =BOOL *) @boolean;
        m_hWndObj: (* UI Active object.
                    =HWND *) @integer;
        ;
        m_pSite:
        (* Site holding object.
         =class CSite * *) ^CSite;
        m_bwIP: (* In/place tool allocations.
                 =BORDERWIDTHS *) @integer;
        m_fInContextHelp:
        (* In context help mode?
         =BOOL *) @boolean;
        ;
        m_pIOleIPActiveObject: (* =IOleInPlaceActiveObject* *)
          ^IOleInPlaceActiveObject;
        ;
        ;
        PROTECTED_: (#  #);
        RegisterAllClasses:
        (*
         /*
         * CFrame::RegisterAllClasses
         *
         * Purpose:
         *  Registers all classes used in this application.
         *
         * Return Value:
         *  BOOL            TRUE if registration succeeded, FALSE otherwise.
         */
         
         BOOL CFrame::RegisterAllClasses(void)
         {
         WNDCLASS        wc;
         
         //Field that are the same for all windows.
         wc.style         = CS_HREDRAW | CS_VREDRAW;
         wc.hInstance     = m_hInst;
         wc.cbClsExtra    = 0;
         
         //Register the Frame window
         wc.lpfnWndProc   = FrameWndProc;
         wc.cbWndExtra    = CBFRAMEWNDEXTRA;
         wc.hIcon         = LoadIcon(m_hInst, TEXT("Icon"));
         wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
         wc.hbrBackground = NULL;
         wc.lpszMenuName  = MAKEINTRESOURCE(IDR_MENU);
         wc.lpszClassName = SZCLASSFRAME;
         
         if (!RegisterClass(&wc))
         return FALSE;
         
         
         //Register the do-nothing Client window
         wc.lpfnWndProc   = ClientWndProc;
         wc.cbWndExtra    = CBCLIENTWNDEXTRA;
         wc.hIcon         = NULL;
         wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
         wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
         wc.lpszMenuName  = NULL;
         wc.lpszClassName = SZCLASSCLIENT;
         
         if (!RegisterClass(&wc))
         return FALSE;
         
         return TRUE;
         }
         *)
          (# result: @boolean
          do
             'CFrame.RegisterAllClasses'->debug.locateMsg.in;
             debug.locate2Msg
               (# 
               do 'CFrame.RegisterAllClasses (not implemented)'->putline
               #);
             'CFrame.RegisterAllClasses'->debug.locateMsg.out
          exit result
          #);
        CreateObject:
          (# filename: ^text; result: @boolean
          enter filename[]
          do
             relax;
             'CFrame.CreateObject'->debug.locateMsg.in;
             debug.locate2Msg
               (# 
               do
                  'CFrame.CreateObject (filename='->puttext;
                  filename[]->puttext;
                  ')'->putline
               #);
             return:
               (# 
               do
                  &CSite[]->m_pSite[];
                  m_dwIDCounter+1->m_dwIDCounter;
                  (m_dwIDCounter,m_hWndClient,THIS(CFrameType)[])
                    ->m_pSite.constructor;
                  m_pSite.AddRef;
                  ;
                  (filename[],m_pIStorage[])->m_pSite.Create->result;
                  (if not result then
                      'CFrame.CreateObject: m_pSite.Create returned false'
                        ->putline;
                      leave return
                  if);
                  ;
                  true->m_fHaveObject;
                  ;
                  'Kalder CSite.Activate med SHOW'->putline;
                  OLEIVERB_SHOW->m_pSite.Activate;
                  'Kalder CSite.Activate med SHOW - returneret'->putline;
                  ;
                  (m_hWndClient,0,true)->InvalidateRect;
                  m_hWndClient->UpdateWindow;
                  true->result;
                  leave return
               #);
             'CFrame.CreateObject'->debug.locateMsg.out
          exit result
          #);
        ResizeClientWindow:
          (# 
          do
             'CFrame.ResizeClientWindow'->debug.locateMsg.in;
             debug.locate2Msg
               (#  do 'CFrame.ResizeClientWindow'->putline #);
             'CFrame.ResizeClientWindow'->debug.locateMsg.out
          #);
        ;
        ;
        PUBLIC_: (#  #);
        Instance:
        (*
         inline HINSTANCE Instance(void)
         { return m_hInst; }
         *) (#  exit m_hInst #);
        Window_:
        (*
         inline HWND      Window(void)
         { return m_hWnd; }        
         *) (#  exit m_hWnd #);
        Accelerators:
        (*
         inline HACCEL    Accelerators(void)
         { return m_hAccel; }        
         *) (#  exit m_hAccel #);
        Init:
          (#
             result: @boolean;
             hr: @HRESULT;
             anIStorageHolder: @IStorageHolder;
             docFileMode: @integer
          do
             relax;
             'CFrame.Init'->debug.locateMsg.in;
             debug.locate2Msg
               (#  do 'CFrame.Init'->putline #);
             return:
               (# abc: (#  #); hMenu: @integer
               do (* 1. Initialize OLE *)
                  0->OleInitialize->hr;
                  (if hr.succeeded then
                      true->m_fInitialized
                   else
                      false->result; leave return
                  if);
                  ;
                  (* 2. Register window classes *)
                  (if m_hInstPrev = 0 then
                      (if not RegisterAllClasses then
                          false->result; leave return
                      if)
                  if);
                  ;
                  (* 3. Create the main window and client-area window *)
                  &MainWindowType[]->mainWindow[];
                  mainWindow.open;
                  mainWindow.private.theWin32Menubar.InterfaceObjectID->hMenu
                    ->m_hMenuOrg;
                  (if false then
                      'hMenuOrg: '->puttext; m_hMenuOrg->putint; newline
                  if);
                  ;
                  (* 4. Allocate menu array for use with in-place menu merging. *)
                  abc;
                  (* Also load the special help menu *)
                  abc;
                  ;
                  (* 5. Load accelerators *)
                  abc;
                  ;
                  (* 6. Make us all visible. *)
                  abc;
                  ;
                  (* 7. Create a temp file for all embedded files. Note that in this
                   sample we don't save any changes to DocObjects because we
                   don't manage any storage directly. *)
                  STGM_TRANSACTED %Bor STGM_READWRITE %Bor STGM_SHARE_EXCLUSIVE
                  %Bor
                    STGM_CREATE
                  %Bor
                    STGM_DELETEONRELEASE->docFileMode;
                  (none ,docFileMode,0,anIStorageHolder[])->StgCreateDocfile
                    ->hr;
                  anIStorageHolder->m_pIStorage[];
                  (if m_pIStorage[] = none then
                      'CFrame.Init: StgCreateDocFile failed'->putline
                  if);
                  (if hr.failed then false->result; leave return if);
                  ;
                  true->result;
                  leave return
               #);
             &COleInPlaceFrame[]->theOleInPlaceFrame[];
             'CFrame.Init'->debug.locateMsg.out
          exit result
          #);
        Close:
          (# pSite: ^CSite
          do
             relax;
             'CFrame.Close'->debug.locateMsg.in;
             debug.locate2Msg
               (#  do 'CFrame.Close'->putline #);
             (if m_pSite[] <> none then
                 m_pSite[]->pSite[] (* Prevents reentry *) ;
                 none ->m_pSite[];
                 ;
                 false->pSite.close (* Frees the object *) ;
                 m_pIStorage[]->pSite.destroy (* cleans up the storage *) ;
                 pSite.release (* frees the site *)
             if);
             ;
             false->m_fHaveObject;
             ;
             mainWindow.update;
             'CFrame.Close'->debug.locateMsg.out
          #);
        ;
        ;
        PUBLIC: (* se framer.h *) (#  #);
        constructor:
          (#
             hInst: @integer;
             hInstPrev: @integer;
             pszCmdLine: ^text;
             nCmdShow: @integer
          enter (hInst,hInstPrev,pszCmdLine[],nCmdShow)
          do (* hInst->m_hInst;
              0->m_hWnd;*)
             debug.locate2Msg
               (#  do 'CFrame.Constructor'->putline #);
             hInstPrev->m_hInstPrev;
             nCmdShow->m_nCmdShow;
             ;
             0->m_hAccel;
             ;
             false->m_fInitialized;
             none ->m_pIStorage[];
             0->m_dwIDCounter;
             ;
             0->m_hMenuOrg;
             0->m_hMenuTop;
             0->m_hMenuHelp;
             false->m_fInObjectHelp;
             false->m_fUsingOurHelp;
             ;
             false->m_fHaveObject;
             0->m_hWndObj;
             ;
             none ->m_pSite[];
             true->m_fOurMenuShowing;
             SHOULD_HANDLE_SetRect: (#  #);
             false->m_fInContextHelp;
             none ->m_pIOleIPActiveObject[]
          #);
        destructor:
          (# 
          do
             debug.locate2Msg
               (#  do 'CFrame.Destructor'->putline #);
             ;
             (* (if m_hWndClient[] <> none then
              m_hWndClient[]->DestroyWindow
              if)*)
             ;
             ReleaseInterface: (* expanded macro *)
               (# pt: ^IUnknown
               do
                  m_pIStorage[]->pt[];
                  none ->m_pIStorage[];
                  (if pt[] <> none then pt.Release if)
               #)
               (* Frees the temp file *)
               ;
             ;
             (* m_pSite cleaned up in Close
              Accelerators freed automatically *)
             ;
             'DestroyMenu'
             (* Destroy the special help menu *)
             ;
             'free menu handle array';
             ;
             (if m_fInitialized then OleUninitialize if)
          #);
        QueryInterface::< 
          (#
             Unknown_IID,OleInPlaceUIWindow_IID,OleWindow_IID,
               OleInPlaceFrame_IID,OleCommandTarget_IID: @IID;
             init:
               (# 
               do
                  IUnknown_IID->Unknown_IID;
                  IOleInPlaceUIWindow_IID->OleInPlaceUIWindow_IID;
                  IOleWindow_IID->OleWindow_IID;
                  IOleInPlaceFrame_IID->OleInPlaceFrame_IID;
                  IOleCommandTarget_IID->OleCommandTarget_IID;
                  ;
                  (if false then
                      debug.debugMsg
                        (# 
                        do
                           'CFrame.QueryInterface supports: '->msg.append;
                           Unknown_IID->msg.append;
                           ', '->msg.append;
                           OleInPlaceUIWindow_IID->msg.append;
                           ', '->msg.append;
                           OleWindow_IID->msg.append;
                           ', '->msg.append;
                           OleInPlaceFrame_IID->msg.append;
                           ', '->msg.append;
                           OleCommandTarget_IID->msg.append
                        #)
                  if)
               #);
             doAlertUser: (#  exit false #);
             ;
             aGUID: @GUID
          do
             relax;
             debug.interfaceMsg
               (#  do '++CFrame.QueryInterface'->msg.append #);
             ;
             init;
             riid[]->aGUID.binary[];
             (if false then
                 debug.debugMsg
                   (# 
                   do
                      'CFrame.QueryInterface: Request for interface '
                        ->msg.append;
                      aGUID->msg.append
                   #)
             if);
             ;
             none ->ppvObject;
             (if true
              // aGUID[]->Unknown_IID.equal then
                 debug.interfaceMsg
                   (#  do '        -IUnknown'->msg.append #)
              // aGUID[]->OleInPlaceUIWindow_IID.equal then
                 debug.interfaceMsg
                   (#  do '        -IOleInPlaceUIWindow'->msg.append #)
              // aGUID[]->OleWindow_IID.equal then
                 debug.interfaceMsg
                   (#  do '        -IOleWindow'->msg.append #)
              // aGUID[]->OleInPlaceFrame_IID.equal then
                 debug.interfaceMsg
                   (#  do '        -IOleInPlaceFrame'->msg.append #)
              // aGUID[]->OleCommandTarget_IID.equal then
                 debug.interfaceMsg
                   (#  do '        -IOleCommandTarget'->msg.append #)
             if);
             (if true
              // aGUID[]->Unknown_IID.equal
              // aGUID[]->OleInPlaceUIWindow_IID.equal
              // aGUID[]->OleWindow_IID.equal
              // aGUID[]->OleInPlaceFrame_IID.equal then
                 (if false then
                     debug.interfaceMsg
                       (# 
                       do
                          '        -IUnknown / IOleInPlaceUIWindow / IOleWindow / IOleInPlaceFrame'
                            ->msg.append
                       #)
                 if);
                 theOleInPlaceFrame[]->ppvObject;
                 (if doAlertUser then
                     (none ,
                      'CFrame.QueryInterface:\nIUnknown / IOleInPlaceUIWindow / IOleWindow / IOleInPlaceFrame',
                      none )->alertUser
                 if)
              // aGUID[]->OleCommandTarget_IID.equal then
                 (if false then
                     debug.interfaceMsg
                       (#  do '        -IOleCommandTarget'->msg.append #)
                 if);
                 theOleCommandTarget[]->ppvObject;
                 (if doAlertUser then
                     (none ,'CFrame.QueryInterface IOleCommandTarget',none )
                       ->alertUser
                 if)
             if);
             ;
             (if ppvObject <> none then
                 ppvObject.ref.AddRef; NOERROR->result
              else
                 debug.interfaceMsg
                   (#  do '        -No such interface'->msg.append #);
                 E_NOINTERFACE->result;
                 (if doAlertUser then
                     (none ,'CFrame.QueryInterface: No such interface!',none )
                       ->alertUser
                 if)
             if)
          #);
        AddRef::< 
          (# 
          do
             relax;
             debug.interfaceMsg
               (# 
               do
                  '--CFrame.AddRef ('->msg.append;
                  m_cRef+1->msg.putint;
                  ')'->msg.append
               #);
             m_cRef+1->m_cRef->result
          #);
        Release::< 
          (# 
          do
             relax;
             debug.interfaceMsg
               (# 
               do
                  '--CFrame.Release ('->msg.append;
                  m_cRef-1->msg.putint;
                  ')'->msg.append
               #);
             m_cRef-1->m_cRef->result
          #);
        ;
        theOleInPlaceFrame: ^COleInPlaceFrame;
        COleInPlaceFrame: IOleInPlaceFrame
          (#
             QueryInterface::< 
               (# 
               do
                  relax;
                  (riid[],ppvObject[])->THIS(CFrameType).QueryInterface->result
               #);
             AddRef::<  (#  do relax; THIS(CFrameType).AddRef->result #);
             Release::<  (#  do relax; THIS(CFrameType).Release->result #);
             ;
             GetWindow::< 
               (# 
               do
                  relax;
                  debug.interfaceMsg
                    (#  do 'OleInPlaceFrame.GetWindow'->msg.append #);
                  m_hWnd->phWnd;
                  NOERROR->result
               #);
             ContextSensitiveHelp::< 
               (# 
               do
                  relax;
                  debug.interfaceMsg
                    (# 
                    do 'OleInPlaceFrame.ContextSensitiveHelp'->msg.append
                    #);
                  return:
                    (# 
                    do
                       (if m_pIOleIPActiveObject[] = none then
                       (* Don't bother if there is no active object since we don't do
                        context help on our own. *)
                           NOERROR->result; leave return
                       if);
                       ;
                       (if m_fInContextHelp <> fEnterMode then
                           fEnterMode->m_fInContextHelp;
                           fEnterMode
                             ->m_pIOleIPActiveObject.ContextSensitiveHelp
                       if);
                       ;
                       NOERROR->result;
                       leave return
                    #)
               #);
             GetBorder::< 
               (# anInt32Holder: @int32holder
               do
                  relax;
                  debug.interfaceMsg
                    (#  do 'OleInPlaceFrame.GetBorder'->msg.append #);
                  return:
                    (# 
                    do
                       (if lpRectBorder[] = none then
                           E_INVALIDARG->result; leave return
                       if);
                       ;
                       (if true then
                           (m_hWnd,lpRectBorder[])->GetClientRect2
                        else
                           m_hWnd->anInt32Holder;
                           (anInt32Holder[],lpRectBorder[])->GetClientRect3
                       if);
                       NOERROR->result;
                       leave return
                    #)
               #);
             RequestBorderSpace::< 
               (# 
               do (* Framer has no border space restrictions *)
                  relax;
                  debug.interfaceMsg
                    (# 
                    do 'OleInPlaceFrame.RequestBorderSpace'->msg.append
                    #);
                  NOERROR->result
               #);
             SetBorderSpace::< 
               (# 
               do
                  relax;
                  debug.interfaceMsg
                    (#  do 'OleInPlaceFrame.SetBorderSpace'->msg.append #);
                  ;
                  (if pBorderWidths[] = none then
                      'SetBorderSpace: SetMenu, SetRect, GetClientRect kald'
                        ->putline
                   else
                      'SetBorderSpace: GetClientRect kald m.m.'->putline
                  if);
                  'SetBorderSpace: ResizeClientWindow call'->putline;
                  NOERROR->result
               #);
             SetActiveObject::< 
               (# anInt32Holder: ^int32holder
               do
                  relax;
                  debug.interfaceMsg
                    (#  do 'OleInPlaceFrame.SetActiveObject'->msg.append #);
                  ;
                  (if m_pIOleIPActiveObject[] <> none then
                      m_pIOleIPActiveObject.Release
                  if);
                  ;
                  pActiveObject[]
                    ->m_pIOleIPActiveObject[]
                    (* NULLs m_pIOleIPActiveObject if pActiveObj is NULL *) ;
                  ;
                  (if m_pIOleIPActiveObject[] <> none then
                      debug.callToObjectMsg
                        (# 
                        do
                           'CFrame.SetActivateObject: kald til AddRef'
                             ->msg.append
                        #);
                      m_pIOleIPActiveObject.AddRef;
                      debug.callToObjectMsg
                        (# 
                        do
                           'CFrame.SetActivateObject: kald til AddRef returneret'
                             ->msg.append
                        #)
                  if);
                  ;
                  &int32holder[]->anInt32Holder[];
                  m_hWndObj->anInt32Holder;
                  debug.callToObjectMsg
                    (# 
                    do
                       'CFrame.SetActivateObject: kald til GetWindow'
                         ->msg.append
                    #);
                  anInt32Holder[]->m_pIOleIPActiveObject.GetWindow;
                  debug.callToObjectMsg
                    (# 
                    do
                       'CFrame.SetActivateObject: kald til GetWindow returneret'
                         ->msg.append
                    #);
                  anInt32Holder->m_hWndObj;
                  NOERROR->result
               #);
             InsertMenus::< 
               (# 
               do
                  relax;
                  debug.interfaceMsg
                    (#  do 'OleInPlaceFrame.InsertMenus'->msg.append #);
                  'InsertMenus not implemented (1)'
                    ->putline
                    (*(interfaceObjectID,position - 1,
                     MF_BYPOSITION + MF_POPUP + MF_STRING, theWin32Menu.interfaceObjectID,name) 
                     -> InsertMenu -> result;*) ;
                  (hmenuShared,0,MF_BYPOSITION %bor MF_POPUP,m_phMenu,'&File2')
                    ->InsertMenu->putint;
                  newline;
                  'InsertMenus not implemented'
                    ->putline
                    (*(interfaceObjectID,position - 1,
                     MF_BYPOSITION + MF_POPUP + MF_STRING, theWin32Menu.interfaceObjectID,name) 
                     -> InsertMenu -> result;*) ;
                  NOERROR->result
               #);
             SetMenu::< 
               (# 
               do
                  relax;
                  debug.interfaceMsg
                    (#  do 'OleInPlaceFrame.SetMenu'->msg.append #);
                  'SetMenu not implemented'->putline
               #);
             RemoveMenus::< 
               (# 
               do
                  relax;
                  debug.interfaceMsg
                    (#  do 'OleInPlaceFrame.RemoveMenus'->msg.append #);
                  'RemoveMenus not implemented'->putline
               #);
             SetStatusText::< 
               (# 
               do
                  relax;
                  debug.interfaceMsg
                    (#  do 'OleInPlaceFrame.SetStatusText'->msg.append #);
                  E_NOTIMPL->result (* We have no status line... *)
               #);
             EnableModeless::< 
               (# 
               do
                  relax;
                  debug.interfaceMsg
                    (#  do 'OleInPlaceFrame.EnableModeless'->msg.append #);
                  NOERROR->result
               #);
             TranslateAccelerator::< 
               (# 
               do
                  relax;
                  debug.interfaceMsg
                    (# 
                    do 'OleInPlaceFrame.TranslateAccelerator'->msg.append
                    #);
                  'TranslateAccelerator not implemented'->putline;
                  S_FALSE->result
               #)
          #);
        theOleCommandTarget: @COleCommandTarget;
        COleCommandTarget: IOleCommandTarget
          (# QueryStatus::<  (#  #); Exec::<  (#  #) #)
     #);
   CFrame: ^CFrameType
do
   debug.open;
   &CFrameType[]->CFrame[];
   (uienvHInstance,117,none ,0)->CFrame.constructor;
   CFrame.Init
#)  

