ORIGIN '~beta/guienv/guienv';
INCLUDE 'debuglib'
        '~beta/guienv/private/winnt/guienv_ntiprivate'
        '~beta/comlib/comlib'
        '~beta/comlib/OleIdl'
        '~beta/comlib/docobj'
        '~beta/win32lib/winerror'
        'additionslib'
        '~beta/win32lib/windowmanagement';
-- program: Descriptor --
guienv
  (#
     debug: @winmainDebug;
     resource: @
       (#
          IDM_FILECLOSE: (* Ligger i C++ filen resource.h. *)
            (#  exit 102 #);
          OLECMDERR_E_UNKNOWNGROUP:
          (* Denne burde vaere defineret i docobj.bet *)
            (#  exit OLE_E_LAST+5 #)
       #);
     ;
     CImpOleClientSite: IOleClientSite
       (#
          PROTECTED: (#  #);
          m_cRef: (* =ULONG *) @integer;
          m_pSite: (* =class CSite* *) ^CSite;
          m_pUnkOuter: (* LPUNKNOWN *) ^IUnknown;
          ;
          ;
          PUBLIC: (#  #);
          constructor:
            (# pSite: ^CSite; pUnkOuter: (* = LPUNKNOWN *) ^IUnknown
            enter (pSite[],pUnkOuter[])
            do 0->m_cRef; pSite[]->m_pSite[]; pUnkOuter[]->m_pUnkOuter[]
            #);
          destructor: (#  do  #);
          QueryInterface::< 
            (# 
            do
               'OleClientSite.QueryInterface'->debug.locateMsg.in;
               '++IOleClientSite.QueryInterface'->debug.interfaceMsg;
               (if true then
                   (riid[],ppvObject[])->m_pUnkOuter.QueryInterface->result
                else
                   E_NOINTERFACE->result
               if);
               ;
               (if false then
                   '======> IOleClientSite.QueryInterface returns: '->puttext;
                   result->debug.myprint
               if);
               'OleClientSite.QueryInterface'->debug.locateMsg.out
            #);
          AddRef::< 
            (# 
            do
               'OleClientSite.AddRef'->debug.locateMsg.in;
               '--IOleClientSite.AddRef'->debug.interfaceMsg;
               m_cRef+1->m_cRef;
               m_pUnkOuter.AddRef->result;
               'OleClientSite.AddRef'->debug.locateMsg.out
            #);
          Release::< 
            (# 
            do
               'OleClientSite.Release'->debug.locateMsg.in;
               '--IOleClientSite.Release'->debug.interfaceMsg;
               m_cRef-1->m_cRef;
               m_pUnkOuter.Release->result;
               'OleClientSite.Release'->debug.locateMsg.out
            #);
          ;
          SaveObject::< 
            (# 
            do
               'OleClientSite.SaveObject'->debug.locateMsg.in;
               'IOleClientSite.SaveObject'->debug.interfaceMsg;
               NO_ERROR->result;
               'OleClientSite.SaveObject'->debug.locateMsg.out
            #);
          GetMoniker::< 
            (# 
            do
               'OleClientSite.GetMoniker'->debug.locateMsg.in;
               'IOleClientSite.GetMoniker'->debug.interfaceMsg;
               E_NOTIMPL->result;
               'OleClientSite.GetMoniker'->debug.locateMsg.out
            #);
          GetContainer::< 
            (# 
            do
               'OleClientSite.GetContainer'->debug.locateMsg.in;
               'IOleClientSite.GetContainer'->debug.interfaceMsg;
               none ->ppContainer;
               E_NOINTERFACE->result;
               'OleClientSite.GetContainer'->debug.locateMsg.out
            #);
          ShowObject::< 
            (# 
            do
               'OleClientSite.ShowObject'->debug.locateMsg.in;
               'IOleClientSite.ShowObject'->debug.interfaceMsg;
               NO_ERROR->result;
               'OleClientSite.ShowObject'->debug.locateMsg.out
            #);
          OnShowWindow::< 
            (# 
            do
               'OleClientSite.OnShowWindow'->debug.locateMsg.in;
               'IOleClientSite.OnShowWindow'->debug.interfaceMsg;
               NO_ERROR->result;
               'OleClientSite.OnShowWindow'->debug.locateMsg.out
            #);
          RequestNewObjectLayout::< 
            (# 
            do
               'OleClientSite.RequestNewObjectLayout'->debug.locateMsg.in;
               'IOleClientSite.RequestNewObjectLayout'->debug.interfaceMsg;
               E_NOTIMPL->result;
               'OleClientSite.RequestNewObjectLayout'->debug.locateMsg.out
            #)
       #);
     CImpAdviseSink: IAdviseSink
       (#
          PROTECTED: (#  #);
          m_cRef: (* =ULONG *) @integer;
          m_pSite: (* =class CSite* *) ^CSite;
          m_pUnkOuter: (* LPUNKNOWN *) ^IUnknown;
          ;
          ;
          PUBLIC: (#  #);
          constructor:
            (# pSite: ^CSite; pUnkOuter: (* = LPUNKNOWN *) ^IUnknown
            enter (pSite[],pUnkOuter[])
            do 0->m_cRef; pSite[]->m_pSite[]; pUnkOuter[]->m_pUnkOuter[]
            #);
          destructor: (#  do  #);
          QueryInterface::< 
            (# 
            do
               'AdviseSink.QueryInterface'->debug.locateMsg.in;
               '++IAdviseSink.QueryInterface'->debug.interfaceMsg;
               (riid[],ppvObject[])->m_pUnkOuter.QueryInterface->result;
               'AdviseSink.QueryInterface'->debug.locateMsg.out
            #);
          AddRef::< 
            (# 
            do
               'AdviseSink.AddRef'->debug.locateMsg.in;
               '--IAdviseSink.AddRef'->debug.interfaceMsg;
               m_cRef+1->m_cRef;
               m_pUnkOuter.AddRef->result;
               'AdviseSink.AddRef'->debug.locateMsg.out
            #);
          Release::< 
            (# 
            do
               'AdviseSink.Release'->debug.locateMsg.in;
               '--IAdviseSink.Release'->debug.interfaceMsg;
               m_cRef-1->m_cRef;
               m_pUnkOuter.Release->result;
               'AdviseSink.AddRef'->debug.locateMsg.out
            #);
          ;
          OnDataChange::< 
            (# 
            do
               'AdviseSink.OnDataChange'->debug.locateMsg.in;
               'IAdviseSink.OnDataChange'->debug.interfaceMsg;
               'AdviseSink.OnDataChange'->debug.locateMsg.out
            #);
          OnViewChange::< 
            (# 
            do
               'AdviseSink.OnViewChange'->debug.locateMsg.in;
               'IAdviseSink.OnViewChange'->debug.interfaceMsg;
               'AdviseSink.OnViewChange'->debug.locateMsg.out
            #);
          OnRename::< 
            (# 
            do
               'AdviseSink.OnRename'->debug.locateMsg.in;
               'IAdviseSink.OnRename'->debug.interfaceMsg;
               'AdviseSink.OnRename'->debug.locateMsg.out
            #);
          OnSave::< 
            (# 
            do
               'AdviseSink.OnSave'->debug.locateMsg.in;
               'IAdviseSink.OnSave'->debug.interfaceMsg;
               'AdviseSink.OnSave'->debug.locateMsg.out
            #);
          OnClose::< 
            (# hwnd: @int32holder
            do (* m_pSite.m_pFR.Close *)
               'AdviseSink.OnClose'->debug.locateMsg.in;
               'IAdviseSink.OnClose'->debug.interfaceMsg;
               ;
               (if false (* Forenkling - virker fint for C++ *) then
                   hwnd[]->m_pSite.m_pFR.theOleInPlaceFrame.GetWindow;
                   (hwnd,WM_COMMAND,resource.IDM_FILECLOSE %bor 0,0)
                     ->PostMessage;
                   'AdviseSink.OnClose'->debug.locateMsg.out
               if)
            #)
       #);
     CImpOleInPlaceSite: IOleInPlaceSite
       (#
          PROTECTED: (#  #);
          m_cRef: (* =ULONG *) @integer;
          m_pSite: (* =class CSite* *) ^CSite;
          m_pUnkOuter: (* LPUNKNOWN *) ^IUnknown;
          ;
          ;
          PUBLIC: (#  #);
          constructor:
            (# pSite: ^CSite; pUnkOuter: (* = LPUNKNOWN *) ^IUnknown
            enter (pSite[],pUnkOuter[])
            do 0->m_cRef; pSite[]->m_pSite[]; pUnkOuter[]->m_pUnkOuter[]
            #);
          destructor: (#  do  #);
          QueryInterface::< 
            (# 
            do
               'OleInPlaceSite.QueryInterface'->debug.locateMsg.in;
               '++IOleInPlaceSite.QueryInterface'->debug.interfaceMsg;
               (riid[],ppvObject[])->m_pUnkOuter.QueryInterface->result;
               'OleInPlaceSite.QueryInterface'->debug.locateMsg.out
            #);
          AddRef::< 
            (# 
            do
               'OleInPlaceSite.AddRef'->debug.locateMsg.in;
               '--IOleInPlaceSite.AddRef'->debug.interfaceMsg;
               m_cRef+1->m_cRef;
               m_pUnkOuter.AddRef->result;
               'OleInPlaceSite.AddRef'->debug.locateMsg.out
            #);
          Release::< 
            (# 
            do
               'OleInPlaceSite.Release'->debug.locateMsg.in;
               '--IOleInPlaceSite.Release'->debug.interfaceMsg;
               m_cRef-1->m_cRef;
               m_pUnkOuter.Release->result;
               'OleInPlaceSite.Release'->debug.locateMsg.out
            #);
          ;
          GetWindow::< 
            (# 
            do
               'OleInPlaceSite.GetWindow'->debug.locateMsg.in;
               'IOleInPlaceSite.GetWindow'->debug.interfaceMsg;
               m_pSite.m_hWnd->phwnd;
               (if false then
                   debugprint:
                     (# AnInt32: @int32
                     do
                        'GetWindow: windowhandle='->puttext;
                        phwnd->anInt32;
                        anInt32->debug.myprint;
                        newline
                     #)
               if);
               NOERROR->result;
               'OleInPlaceSite.GetWindow'->debug.locateMsg.out
            #);
          ContextSensitiveHelp::< 
            (# 
            do
               'OleInPlaceSite.ContextSensitiveHelp'->debug.locateMsg.in;
               'IOleInPlaceSite.ContextSensitiveHelp'->debug.interfaceMsg;
               NOERROR->result;
               'OleInPlaceSite.ContextSensitiveHelp'->debug.locateMsg.out
            #);
          CanInPlaceActivate::< 
            (# 
            do
               'OleInPlaceSite.CanInPlaceActivate'->debug.locateMsg.in;
               '----------------------------------------------\nIOleInPlaceSite.CanInPlaceActivate'
                 ->debug.interfaceMsg;
               NOERROR->result;
               'OleInPlaceSite.CanInPlaceActivate'->debug.locateMsg.out
            #);
          OnInPlaceActivate::< 
            (# IID_IOleIPObject: @IID
            do
               'OleInPlaceSite.OnInPlaceActivate'->debug.locateMsg.in;
               'IOleInPlaceSite.OnInPlaceActivate'->debug.interfaceMsg;
               ;
               IOleInPlaceObject_IID->IID_IOleIPObject;
               debug.callToObjectMsg
                 (# 
                 do
                    'IOleInPlaceSite.OnInPlaceActivate: kald til queryinterface'
                      ->msg.append
                 #);
               (m_pSite.m_pObj[],IID_IOleIPObject[])->Query
                 ->m_pSite.m_pIOleIPObject[];
               (if m_pSite.m_pIOleIPObject[] = none then
                   'OnInPlaceActivate: Query efter OleIPObject gav intet resultat'
                     ->putline
               if);
               debug.callToObjectMsg
                 (# 
                 do
                    'IOleInPlaceSite.OnInPlaceActivate: kald returneret'
                      ->msg.append
                 #);
               ;
               NOERROR->result;
               'OleInPlaceSite.OnInPlaceActivate'->debug.locateMsg.out
            #);
          OnInPlaceDeactivate::< 
            (# 
            do
               'OleInPlaceSite.OnInPlaceDeactivate'->debug.locateMsg.in;
               'IOleInPlaceSite.OnInPlaceDeactivate'->debug.interfaceMsg;
               'Kalder CSite.Activate med DISCARDUNDOSTATE'->putline;
               OLEIVERB_DISCARDUNDOSTATE->m_pSite.Activate;
               'Kalder CSite.Activate med DISCARDUNDOSTATE - returneret'
                 ->putline;
               ReleaseInterface: (* macro ReleaseInterface expanded *)
                 (# pt: ^IUnknown
                 do
                    m_pSite.m_pIOleIPObject[]->pt[];
                    none ->m_pSite.m_pIOleIPObject[];
                    (if pt[] <> none then
                        debug.callToObjectMsg
                          (# 
                          do
                             'IOleInPlaceSite.OnInPlaceDeactivate: kald til Release'
                               ->msg.append
                          #);
                        pt.Release;
                        debug.callToObjectMsg
                          (# 
                          do
                             'IOleInPlaceSite.OnInPlaceDeactivate: kald returneret'
                               ->msg.append
                          #)
                    if)
                 #);
               NOERROR->result;
               'OleInPlaceSite.OnInPlaceDeactivate'->debug.locateMsg.out
            #);
          OnUIActivate::< 
            (# 
            do
               'OleInPlaceSite.OnUIActivate'->debug.locateMsg.in;
               'IOleInPlaceSite.OnUIActivate'->debug.interfaceMsg;
               NOERROR->result;
               'OleInPlaceSite.OnUIActivate'->debug.locateMsg.out
            #);
          OnUIDeactivate::< 
            (# 
            do
               'OleInPlaceSite.OnUIDeactivate'->debug.locateMsg.in;
               'IOleInPlaceSite.OnUIDeactivate'->debug.interfaceMsg;
               NOERROR->result;
               'OleInPlaceSite.OnUIDeactivate'->debug.locateMsg.out
            #);
          DeactivateAndUndo::< 
            (# 
            do
               'OleInPlaceSite.DeactivateAndUndo'->debug.locateMsg.in;
               'IOleInPlaceSite.DeactivateAndUndo'->debug.interfaceMsg;
               debug.callToObjectMsg
                 (# 
                 do
                    'IOleInPlaceSite.DeactivateAndUndo: kald til InPlaceDeactivate'
                      ->msg.append
                 #);
               (if false then m_pSite.m_pIOleIPObject.InPlaceDeactivate if);
               debug.callToObjectMsg
                 (# 
                 do
                    'IOleInPlaceSite.DeactivateAndUndo: kald returneret'
                      ->msg.append
                 #);
               NOERROR->result;
               'OleInPlaceSite.DeactivateAndUndo'->debug.locateMsg.out
            #);
          DiscardUndoState::< 
            (# 
            do
               'OleInPlaceSite.DiscardUndoState'->debug.locateMsg.in;
               'IOleInPlaceSite.DiscardUndoState'->debug.interfaceMsg;
               E_NOTIMPL->result;
               'OleInPlaceSite.DiscardUndoState'->debug.locateMsg.out
            #);
          GetWindowContext::< 
            (# IID_IOleInPlaceFrame: @IID; anInt32Holder: @int32holder; 
            do
               'OleInPlaceSite.GetWindowContext'->debug.locateMsg.in;
               'IOleInPlaceSite.GetWindowContext'->debug.interfaceMsg;
               ;
               none ->ppDoc;
               ;
               IOleInPlaceFrame_IID->IID_IOleInPlaceFrame;
               (m_pSite.m_pFR[],IID_IOleInPlaceFrame[])->Query->ppFrame;
               ;
               (if lprcPosRect[] <> none then
                   (if true then
                       (m_pSite.m_hWnd,lprcPosRect[])->GetClientRect2
                    else
                       m_pSite.m_hWnd->anInt32Holder;
                       (anInt32Holder[],lprcPosRect[])->GetClientRect3
                   if);
                   debug.debugMsg
                     (# 
                     do
                        'GetWindowContext: GetClientRect='->msg.append;
                        lprcPosRect.top->msg.putint;
                        ','->msg.append;
                        lprcPosRect.bottom->msg.putint;
                        ','->msg.append;
                        lprcPosRect.left->msg.putint;
                        ','->msg.append;
                        lprcPosRect.right->msg.putint
                     #)
               if);
               ;
               lprcPosRect.left->lprcClipRect.left;
               lprcPosRect.right->lprcClipRect.right;
               lprcPosRect.top->lprcClipRect.top;
               lprcPosRect.bottom->lprcClipRect.bottom;
               ;
               (if false (* forenkling - virker for C++ *) then
                   20->lpFrameInfo.cb;
                   false->lpFrameInfo.fMDIApp;
                   m_pSite.m_pFR.Window_->lpFrameInfo.hwndFrame;
                   m_pSite.m_pFR.Accelerators->lpFrameInfo.haccel;
                   CACCELERATORS->lpFrameInfo.cAccelEntries
               if);
               ;
               NOERROR->result;
               'OleInPlaceSite.GetWindowContext'->debug.locateMsg.out
            #);
          Scroll::< 
            (# 
            do
               'OleInPlaceSite.Scroll'->debug.locateMsg.in;
               'IOleInPlaceSite.Scroll'->debug.interfaceMsg;
               E_NOTIMPL->result;
               'OleInPlaceSite.Scroll'->debug.locateMsg.out
            #);
          OnPosRectChange::< 
            (# 
            do
               'OleInPlaceSite.OnPosRectChange'->debug.locateMsg.in;
               'IOleInPlaceSite.OnPosRectChange'->debug.interfaceMsg;
               E_NOTIMPL->result;
               'OleInPlaceSite.OnPosRectChange'->debug.locateMsg.out
            #)
       #);
     CImpOleDocumentSite: IOleDocumentSite
       (#
          PROTECTED: (#  #);
          m_cRef: (* =ULONG *) @integer;
          m_pSite: (* =class CSite* *) ^CSite;
          m_pUnkOuter: (* LPUNKNOWN *) ^IUnknown;
          ;
          ;
          PUBLIC: (#  #);
          constructor:
            (# pSite: ^CSite; pUnkOuter: (* = LPUNKNOWN *) ^IUnknown
            enter (pSite[],pUnkOuter[])
            do 0->m_cRef; pSite[]->m_pSite[]; pUnkOuter[]->m_pUnkOuter[]
            #);
          destructor: (#  do  #);
          QueryInterface::< 
            (# 
            do
               'OleDocumentSite.QueryInterface'->debug.locateMsg.in;
               '++IOleDocumentSite.QueryInterface'->debug.interfaceMsg;
               (riid[],ppvObject[])->m_pUnkOuter.QueryInterface->result;
               'OleDocumentSite.QueryInterface'->debug.locateMsg.out
            #);
          AddRef::< 
            (# 
            do
               'OleDocumentSite.AddRef'->debug.locateMsg.in;
               '--IOleDocumentSite.AddRef'->debug.interfaceMsg;
               m_cRef+1->m_cRef;
               m_pUnkOuter.AddRef->result;
               'OleDocumentSite.AddRef'->debug.locateMsg.out
            #);
          Release::< 
            (# 
            do
               'OleDocumentSite.Release'->debug.locateMsg.in;
               '--IOleDocumentSite.Release'->debug.interfaceMsg;
               m_cRef-1->m_cRef;
               m_pUnkOuter.Release->result;
               'OleDocumentSite.Release'->debug.locateMsg.out
            #);
          ;
          ActivateMe::< 
            (#
               pDoc: ^IOleDocument;
               IID_IOleDocument: @IID;
               anIOleDocumentViewHolder: @IOleDocumentViewHolder;
               hr: @HResult
            do
            (* Set the window size sensitive to new toolbars.
             GetClientRect(m_pSite->m_hWnd, &rc);
             pView->SetRect(&rc); *)
               'KOMMER VI OVERHOVEDET HERTIL???'->putline;
               'OleDocumentSite.ActivateMe'->debug.locateMsg.in;
               debug.interfaceMsg
                 (#  do 'IOleDocumentSite.ActivateMe'->msg.append #);
               ;
               (if false (* forenkling - virker for C++ *) then
                   (if pViewToActivate[] = none then
                   (* If we're passed a NULL view pointer, then try to get one from
                    the document object (the object within us). *)
                       IOleDocument_IID->IID_IOleDocument;
                       debug.callToObjectMsg
                         (# 
                         do
                            'IOleDocumentSite.ActivateMe: kald til QueryInterface'
                              ->msg.append
                         #);
                       (m_pSite.m_pObj[],IID_IOleDocument[])->Query->pDoc[];
                       (if pDoc[] = none then
                           '-------ActivateMe: Query for IOleDocument gav intet resultat'
                             ->putline
                       if);
                       debug.callToObjectMsg
                         (# 
                         do
                            'IOleDocumentSite.ActivateMe: kald til QueryInterface returneret'
                              ->msg.append
                         #);
                       ;
                       debug.callToObjectMsg
                         (# 
                         do
                            'IOleDocumentSite.ActivateMe: kald til CreateView'
                              ->msg.append
                         #);
                       pViewToActivate[]->anIOleDocumentViewHolder;
                       (m_pSite.m_pImpIOleIPSite[],m_pSite.m_pIStream[],0,
                        anIOleDocumentViewHolder[])->pDoc.CreateView->hr;
                       anIOleDocumentViewHolder->pViewToActivate[];
                       (if hr.failed then
                           '----- ActivateMe: pDoc.CreateView failed'->putline
                       if);
                       debug.callToObjectMsg
                         (# 
                         do
                            'IOleDocumentSite.ActivateMe: kald til CreateView returneret'
                              ->msg.append
                         #);
                       ;
                       debug.callToObjectMsg
                         (# 
                         do
                            'IOleDocumentSite.ActivateMe: kald til Release'
                              ->msg.append
                         #);
                       pDoc.Release;
                       debug.callToObjectMsg
                         (# 
                         do
                            'IOleDocumentSite.ActivateMe: kald til Release returneret'
                              ->msg.append
                         #)
                    else
                       debug.callToObjectMsg
                         (# 
                         do
                            'IOleDocumentSite.ActivateMe: kald til SetInPlaceSite'
                              ->msg.append
                         #);
                       (m_pSite.m_pImpIOleIPSite[])
                         ->
                           pViewToActivate.SetInPlaceSite
                           (* make sure that the view has our client site *) ;
                       debug.callToObjectMsg
                         (# 
                         do
                            'IOleDocumentSite.ActivateMe: kald til SetInPlaceSite returneret'
                              ->msg.append
                         #);
                       debug.callToObjectMsg
                         (# 
                         do
                            'IOleDocumentSite.ActivateMe: kald til AddRef'
                              ->msg.append
                         #);
                       pViewToActivate.AddRef;
                       debug.callToObjectMsg
                         (# 
                         do
                            'IOleDocumentSite.ActivateMe: kald til AddRef returneret'
                              ->msg.append
                         #)
                   if);
                   ;
                   true->m_pSite.m_fDocObj;
                   pViewToActivate[]->m_pSite.m_pIOleDocView[];
                   ;
                   debug.callToObjectMsg
                     (# 
                     do
                        'IOleDocumentSite.ActivateMe: kald til UIActivate'
                          ->msg.append
                     #);
                   true
                     ->
                       pViewToActivate.UIActivate
                       (* this sets up toolbars and menus first *) ;
                   debug.callToObjectMsg
                     (# 
                     do
                        'IOleDocumentSite.ActivateMe: kald til UIActivate returneret'
                          ->msg.append
                     #);
                   ;
                   ;
                   debug.callToObjectMsg
                     (# 
                     do
                        'IOleDocumentSite.ActivateMe: kald til Show'->msg.append
                     #);
                   true->pViewToActivate.Show;
                   debug.callToObjectMsg
                     (# 
                     do
                        'IOleDocumentSite.ActivateMe: kald til Show returneret'
                          ->msg.append
                     #)
               if);
               ;
               ;
               NOERROR->result;
               'OleDocumentSite.ActivateMe'->debug.locateMsg.out
            #)
       #);
     CSite: IUnknown
       (#
          PRIVATE: (#  #);
          m_cRef: @integer (* originally ULONG *) ;
          m_dwID: @integer (* originally DWORD *) ;
          m_hWnd: @integer
          (* Client area window of parent.
           originally HWND *) ;
          ;
          m_pFR: ^CFrameType;
          ;
          m_fInitialized: (* Something here? *) @boolean;
          m_pIStorage: (* Storage for object.
                        Originally LPSTORAGE *) ^IStorage;
          m_pIStream: (* Info stream for object.
                       LPSTREAM *) ^IStream;
          ;
          m_pObj: ^IUnknown;
          m_pIOleObject: ^IOleObject;
          m_pIOleIPObject: ^IOleInPlaceObject;
          m_pIOleDocView: ^IOleDocumentView;
          ;
          m_fDocObj: (* Document object here? *) @boolean;
          ;
          m_pImpIOleClientSite: ^CImpOleClientSite;
          m_pImpIAdviseSink: ^CImpAdviseSink;
          m_pImpIOleIPSite: ^CImpOleInPlaceSite;
          m_pImpIOleDocumentSite: ^CImpOleDocumentSite;
          ;
          ;
          PROTECTED: (#  #);
          ObjectInitialize:
            (#
               pObj: ^IUnknown;
               result: @boolean;
               hr: @HResult;
               dw: @int32uHolder (* DWORD* *) ;
               IID_IOleObject: @IID
            enter pObj[]
            do
               'CSite.ObjectInitialize'->debug.locateMsg.in;
               return:
               (* When the C program says "return X", 
                we say "X->result; leave return". *)
                 (# hr: @HResult
                 do
                    (if pObj[] = none then false->result; leave return if);
                    pObj[]->m_pObj[];
                    ;
                    none
                      ->m_pIOleObject[]
                      (* We need an IOleObject most of the time, so get one here *)
                      ;
                    IOleObject_IID->IID_IOleObject;
                    debug.callToObjectMsg
                      (# 
                      do
                         'CSite.ObjectInitialize: kald til QueryInterface'
                           ->msg.append
                      #);
                    (pObj[],IID_IOleObject[])->Query->m_pIOleObject[];
                    debug.callToObjectMsg
                      (# 
                      do
                         'CSite.ObjectInitialize: kald til QueryInterface returneret'
                           ->msg.append
                      #);
                    ;
                    debug.callToObjectMsg
                      (# 
                      do
                         'CSite.ObjectInitialize: kald til SetClientSite'
                           ->msg.append
                      #);
                    m_pImpIOleClientSite[]->m_pIOleObject.SetClientSite
                      ->hr (* SetClientSite is critical for DocObjects *) ;
                    debug.callToObjectMsg
                      (# 
                      do
                         'CSite.ObjectInitialize: kald til SetClientSite returneret'
                           ->msg.append
                      #);
                    debug.debugMsg
                      (# 
                      do
                         (if hr.succeeded then
                             (if false then
                                 'ObjectInitialize: SetClientSite succeeded'
                                   ->msg.append
                             if)
                          else
                             'ObjectInitialize: SetClientSite failed'
                               ->msg.append
                         if)
                      #);
                    debug.callToObjectMsg
                      (# 
                      do 'CSite.ObjectInitialize: kald til Advise'->msg.append
                      #);
                    (m_pImpIAdviseSink[],dw[])->m_pIOleObject.Advise->hr;
                    debug.callToObjectMsg
                      (# 
                      do
                         'CSite.ObjectInitialize: kald til Advise returneret'
                           ->msg.append
                      #);
                    debug.debugMsg
                      (# 
                      do
                         (if hr.succeeded then
                             (if false then
                                 'ObjectInitialize: Advise succeeded'
                                   ->msg.append
                             if)
                          else
                             'ObjectInitialize: Advise failed'->msg.append
                         if)
                      #);
                    ;
                    (if false then
                        (none ,'Before OLERUN',none )->alertUser
                    if);
                    m_pIOleObject[]
                      ->OleRun
                      (* This is to give PowerPoint a chance to initialize itself earlier *)
                      ;
                    (if false then
                        (none ,'After OLERUN',none )->alertUser
                    if);
                    true->result;
                    leave return
                 #);
               'CSite.ObjectInitialize'->debug.locateMsg.out
            exit result
            #);
          ;
          ;
          PUBLIC: (#  #);
          constructor:
            (# dwID,hWnd: @integer; pFR: ^CFrameType
            enter (dwID,hWnd,pFR[])
            do
               0->m_cRef;
               dwID->m_dwID;
               hWnd->m_hWnd;
               pFR[]->m_pFR[];
               ;
               0->m_fInitialized;
               none ->m_pIStorage[];
               ;
               none ->m_pObj[];
               ;
               none ->m_pIOleObject[];
               none ->m_pIOleIPObject[];
               none ->m_pIOleDocView[];
               ;
               none ->m_pImpIOleClientSite[];
               none ->m_pImpIAdviseSink[];
               none ->m_pImpIOleIPSite[];
               none ->m_pImpIOleDocumentSite[];
               ;
               false->m_fDocObj
            #);
          destructor:
            (# pt: ^IUnknown
            do
               m_pImpIOleDocumentSite[]->pt[];
               none ->m_pImpIOleDocumentSite[];
               (if pt[] <> none then pt.Release if);
               ;
               m_pImpIOleIPSite[]->pt[];
               none ->m_pImpIOleIPSite[];
               (if pt[] <> none then pt.Release if);
               ;
               m_pImpIAdviseSink[]->pt[];
               none ->m_pImpIAdviseSink[];
               (if pt[] <> none then pt.Release if);
               ;
               m_pImpIOleClientSite[]->pt[];
               none ->m_pImpIOleClientSite[];
               (if pt[] <> none then pt.Release if)
            #);
          QueryInterface::< 
            (#
               Marshal_IID,Unknown_IID,OleClientSite_IID,AdviseSink_IID,
                 OleWindow_IID,OleInPlaceSite_IID,OleDocumentSite_IID: @IID;
               init:
                 (# 
                 do
                    IUnknown_IID->Unknown_IID;
                    IOleClientSite_IID->OleClientSite_IID;
                    IAdviseSink_IID->AdviseSink_IID;
                    IOleWindow_IID->OleWindow_IID;
                    IOleInPlaceSite_IID->OleInPlaceSite_IID;
                    IOleDocumentSite_IID->OleDocumentSite_IID;
                    IMarshal_IID->Marshal_IID;
                    ;
                    (if false then
                        debug.debugMsg
                          (# 
                          do
                             'This QueryInterface supports: '->msg.append;
                             Unknown_IID->msg.append;
                             ', '->msg.append;
                             OleClientSite_IID->msg.append;
                             ', '->msg.append;
                             AdviseSink_IID->msg.append;
                             ', '->msg.append;
                             OleWindow_IID->msg.append;
                             ', '->msg.append;
                             OleInPlaceSite_IID->msg.append;
                             ', '->msg.append;
                             OleDocumentSite_IID->msg.append;
                             ;
                             (if false then
                                 'The IID for IMarshal is '->msg.append;
                                 Marshal_IID->msg.append
                             if)
                          #)
                    if)
                 #);
               doAlertUser: (#  exit false #);
               ;
               aGUID: @GUID
            do
               'CSite.QueryInterface'->debug.locateMsg.in;
               '++CSite.QueryInterface'->debug.interfaceMsg;
               ;
               init;
               riid[]->aGUID.binary[];
               (if false then
                   debug.debugMsg
                     (# 
                     do
                        'Csite.QueryInterface: Request for interface '
                          ->msg.append;
                        aGUID->msg.append
                     #)
               if);
               ;
               none ->ppvObject;
               (if true
                // aGUID[]->Unknown_IID.equal then
                   '       -IUnknown'->debug.interfaceMsg
                // aGUID[]->OleClientSite_IID.equal then
                   '       -IOleClientSite'->debug.interfaceMsg
                // aGUID[]->AdviseSink_IID.equal then
                   '       -IAdviseSink'->debug.interfaceMsg
                // aGUID[]->OleWindow_IID.equal then
                   '       -IOleWindow'->debug.interfaceMsg
                // aGUID[]->OleInPlaceSite_IID.equal then
                   '       -IOleInPlaceSite'->debug.interfaceMsg
                // aGUID[]->OleDocumentSite_IID.equal then
                   '       -IOleDocumentSite'->debug.interfaceMsg
               if);
               (if true
                // aGUID[]->Unknown_IID.equal then
                   THIS(IUnknown)[]->ppvObject;
                   (if doAlertUser then
                       (none ,'CSite.QueryInterface IUnknown',none )->alertUser
                   if)
                // aGUID[]->OleClientSite_IID.equal then
                   m_pImpIOleClientSite[]->ppvObject;
                   (if doAlertUser then
                       (none ,'CSite.QueryInterface IOleClientSite',none )
                         ->alertUser
                   if)
                // aGUID[]->AdviseSink_IID.equal then
                   m_pImpIAdviseSink[]->ppvObject;
                   (if doAlertUser then
                       (none ,'CSite.QueryInterface IAdviseSink',none )
                         ->alertUser
                   if)
                // aGUID[]->OleWindow_IID.equal
                // aGUID[]->OleInPlaceSite_IID.equal then
                   m_pImpIOleIPSite[]->ppvObject;
                   (if doAlertUser then
                       (none ,'CSite.QueryInterface IOleWindow/IOleInPlaceSite',
                        none )->alertUser
                   if)
                // aGUID[]->OleDocumentSite_IID.equal then
                   m_pImpIOleDocumentSite[]->ppvObject;
                   (if doAlertUser then
                       (none ,'CSite.QueryInterface IOleDocumentSite',none )
                         ->alertUser
                   if)
               if);
               ;
               (if ppvObject <> none then
                   ppvObject.ref.AddRef; NOERROR->result
                else
                   '       -No such interface'->debug.interfaceMsg;
                   E_NOINTERFACE->result;
                   (if doAlertUser then
                       (none ,'CSite.QueryInterface: No such interface!',none )
                         ->alertUser
                   if)
               if);
               'CSite.QueryInterface'->debug.locateMsg.out
            #);
          AddRef::< 
            (# 
            do
               'CSite.AddRef'->debug.locateMsg.in;
               debug.interfaceMsg
                 (# 
                 do
                    '--CSite.AddRef ('->msg.append;
                    m_cRef+1->msg.putint;
                    ')'->msg.append
                 #);
               m_cRef+1->m_cRef->result;
               'CSite.AddRef'->debug.locateMsg.out
            #);
          Release::< 
            (# 
            do
               'CSite.Release'->debug.locateMsg.in;
               debug.interfaceMsg
                 (# 
                 do
                    '--CSite.Release ('->msg.append;
                    m_cRef-1->msg.putint;
                    ')'->msg.append
                 #);
               m_cRef-1->m_cRef->result;
               (if m_cRef = 0 then
                   '====> CSite ref count is zero.'->putline
               if);
               'CSite.Release'->debug.locateMsg.out
            #);
          ;
          Create:
            (#
               filename: ^text;
               pIStorage: ^IStorage;
               result: @boolean;
               hr: @HResult;
               pObj: ^IUnknown;
               IID_IUnknown: @IID;
               anIUnknownHolder: @IUnknownHolder;
               awtext: @bstr
            enter (filename[],pIStorage[])
            do
               'CSite.Create'->debug.locateMsg.in;
               E_FAIL->hr;
               return:
               (* when the C program says "return something",
                we say "something->result; leave return" *)
                 (# 
                 do
                    pIStorage[]->CreateStorage
                      ->result
                      (* Create a new storage for this object (sets m_pIStorage) *)
                      ;
                    (if result = false then
                        'CSite.Create: CreateStorage failed'->putline;
                        leave return
                    if);
                    ;
                    IUnknown_IID->IID_IUnknown;
                    filename[]->awtext.setText;
                    pObj[]->anIUnknownHolder;
                    ((getGUID_NULL).binary[],awtext.wcharptr,
                     IID_IUnknown.binary[],OLERENDER_NONE,0 (* lpFormatEtc *) ,
                     none ,m_pIStorage[],anIUnknownHolder[])->OleCreateFromFile
                      ->hr;
                    anIUnknownHolder->pObj[];
                    debug.debugMsg
                      (# 
                      do
                         (if hr.failed then
                             'CSite.Create: OleCreateFromFile failed'
                               ->msg.append
                          else
                             (if false then
                                 'CSite.Create: OleCreateFromFile succeeded'
                                   ->msg.append
                             if)
                         if)
                      #);
                    ;
                    (if hr.failed then
                    (* If creation didn't work, get rid of the element Open created. *)
                        pIStorage[]->Destroy; false->result; leave return
                    if);
                    ;
                    (if not (pObj[]->ObjectInitialize) then
                    (* We don't get the size if PatronObject data was seen already. *)
                        'ObjectInitialize returned false'->putline;
                        pIStorage[]->Destroy;
                        false->result;
                        leave return
                    if);
                    ;
                    true->m_fInitialized;
                    true->result;
                    leave return
                 #);
               'CSite.Create'->debug.locateMsg.out
            exit result
            #);
          CreateStorage:
            (#
               result: @boolean;
               pIStorage: ^IStorage (* pointer to the parent storage *) ;
               hr: @HRESULT;
               dwMode: @int32uHolder (* DWORD* *) ;
               szName: @text;
               szName2: [0] @char (* ^text NYI *) (* OLECHAR* *) ;
               anIStorageHolder: @IStorageHolder;
               anIStreamHolder: @IStreamHolder;
               awtext: @bstr
            enter pIStorage[]
            do
               'CSite.CreateStorage'->debug.locateMsg.in;
               (STGM_TRANSACTED %Bor STGM_READWRITE %Bor STGM_SHARE_EXCLUSIVE)
                 ->dwMode;
               ;
               return:
               (* When the C program says "return X", 
                we say "X->result; leave return". *)
                 (# 
                 do
                    (if pIStorage[] = none then
                        'CSite.CreateStorage: pIStorage[]=none'->putline;
                        false->result;
                        leave return
                    if);
                    ;
                    'Site '
                      ->szName (* wsprintf(szName, TEXT("Site %lu"), m_dwID); *)
                      ;
                    m_dwID->szName.putint;
                    szName->szName2;
                    ;
                    m_pIStorage[]->anIStorageHolder;
                    debug.callToObjectMsg
                      (# 
                      do
                         'CSite.CreateStorage: kald til CreateStorage'
                           ->msg.append
                      #);
                    (szName2,dwMode,0,0,anIStorageHolder[])
                      ->pIStorage.CreateStorage->hr;
                    debug.callToObjectMsg
                      (# 
                      do
                         'CSite.CreateStorage: kald til CreateStorage returneret'
                           ->msg.append
                      #);
                    anIStorageHolder->m_pIStorage[];
                    (if hr.failed then
                        'CreateStorage failed'->putline;
                        false->result;
                        leave return
                    if);
                    ;
                    (STGM_DIRECT %Bor STGM_READWRITE %Bor STGM_SHARE_EXCLUSIVE)
                      ->dwMode
                      (* Create stream for the object; name is irrelevant *) ;
                    'DocObjInfo'->awtext.settext;
                    debug.callToObjectMsg
                      (# 
                      do
                         'CSite.CreateStorage: kald til CreateStream'
                           ->msg.append
                      #);
                    (awtext.wcharptr,dwMode,0,0,anIStreamHolder[])
                      ->m_pIStorage.CreateStream->hr;
                    debug.callToObjectMsg
                      (# 
                      do
                         'CSite.CreateStorage: kald til CreateStream returneret'
                           ->msg.append
                      #);
                    anIStreamHolder->m_pIStream[];
                    (if hr.failed then
                    (* If we failed to create a stream in the file, do it in memory *)
                        'CreateStream failed'->putline;
                        'CreateStreamOnHGlobal kald'->putline
                    if);
                    ;
                    &CImpOleClientSite[]
                      ->m_pImpIOleClientSite[]
                      (* Create interface implementations *) ;
                    (THIS(CSite)[],THIS(IUnknown)[])
                      ->m_pImpIOleClientSite.constructor;
                    &CImpAdviseSink[]->m_pImpIAdviseSink[];
                    (THIS(CSite)[],THIS(IUnknown)[])
                      ->m_pImpIAdviseSink.constructor;
                    &CImpOleInPlaceSite[]->m_pImpIOleIPSite[];
                    (THIS(CSite)[],THIS(IUnknown)[])
                      ->m_pImpIOleIPSite.constructor;
                    &CImpOleDocumentSite[]->m_pImpIOleDocumentSite[];
                    (THIS(CSite)[],THIS(IUnknown)[])
                      ->m_pImpIOleDocumentSite.constructor;
                    ;
                    (if (m_pImpIOleClientSite[] = none ) or
                    (m_pImpIAdviseSink[] = none ) or
                    (m_pImpIOleIPSite[] = none ) or
                    (m_pImpIOleDocumentSite[] = none ) then
                        false->result; leave return
                    if);
                    ;
                    true->result;
                    leave return
                 #);
               'CSite.CreateStorage'->debug.locateMsg.out
            exit result
            #);
          Close:
            (# fCommit: @boolean
            enter fCommit
            do
               'CSite.Close'->debug.locateMsg.in;
               (if m_pIOleIPObject[] <> none then
                   m_pIOleIPObject.InPlaceDeactivate
               if);
               ;
               ReleaseInterface: (* expanded macro *)
                 (# pt: ^IUnknown
                 do
                    m_pIOleDocView[]->pt[];
                    none ->m_pIOleDocView[];
                    (if pt[] <> none then
                        debug.callToObjectMsg
                          (# 
                          do 'CSite.Close: kald til Release'->msg.append
                          #);
                        pt.Release;
                        debug.callToObjectMsg
                          (# 
                          do
                             'CSite.Close: kald til Release returneret'
                               ->msg.append
                          #)
                    if)
                 #);
               ;
               (if m_pIOleObject[] <> none then
                   (if fCommit then
                       debug.callToObjectMsg
                         (# 
                         do 'CSite.Close: kald til Close'->msg.append
                         #);
                       OLECLOSE_SAVEIFDIRTY->m_pIOleObject.close;
                       debug.callToObjectMsg
                         (# 
                         do
                            'CSite.Close: kald til Close returneret'->msg.append
                         #)
                    else
                       debug.callToObjectMsg
                         (# 
                         do 'CSite.Close: kald til Close'->msg.append
                         #);
                       OLECLOSE_NOSAVE->m_pIOleObject.close;
                       debug.callToObjectMsg
                         (# 
                         do
                            'CSite.Close: kald til Close returneret'->msg.append
                         #)
                   if);
                   ReleaseInterface: (* expanded macro *)
                     (# pt: ^IUnknown
                     do
                        m_pIOleObject[]->pt[];
                        none ->m_pIOleObject[];
                        (if pt[] <> none then
                            debug.callToObjectMsg
                              (# 
                              do 'CSite.Close: kald til Release'->msg.append
                              #);
                            pt.Release;
                            debug.callToObjectMsg
                              (# 
                              do
                                 'CSite.Close: kald til Release returneret'
                                   ->msg.append
                              #)
                        if)
                     #)
               if);
               ;
               ReleaseInterface: (* expanded macro *)
                 (# pt: ^IUnknown
                 do
                    m_pObj[]->pt[];
                    none ->m_pObj[];
                    (if pt[] <> none then
                        debug.callToObjectMsg
                          (# 
                          do 'CSite.Close: kald til Release'->msg.append
                          #);
                        pt.Release;
                        debug.callToObjectMsg
                          (# 
                          do
                             'CSite.Close: kald til Release returneret'
                               ->msg.append
                          #)
                    if)
                 #);
               ReleaseInterface: (* expanded macro *)
                 (# pt: ^IUnknown
                 do
                    m_pIStream[]->pt[];
                    none ->m_pIStream[];
                    (if pt[] <> none then
                        debug.callToObjectMsg
                          (# 
                          do 'CSite.Close: kald til Release'->msg.append
                          #);
                        pt.Release;
                        debug.callToObjectMsg
                          (# 
                          do
                             'CSite.Close: kald til Release returneret'
                               ->msg.append
                          #)
                    if)
                 #);
               ReleaseInterface: (* expanded macro *)
                 (# pt: ^IUnknown
                 do
                    m_pIStorage[]->pt[];
                    none ->m_pIStorage[];
                    (if pt[] <> none then
                        debug.callToObjectMsg
                          (# 
                          do 'CSite.Close: kald til Release'->msg.append
                          #);
                        pt.Release;
                        debug.callToObjectMsg
                          (# 
                          do
                             'CSite.Close: kald til Release returneret'
                               ->msg.append
                          #)
                    if)
                 #);
               'CSite.Close'->debug.locateMsg.out
            #);
          Update:
            (# IID_IPersistStorage: @IID; pIPS: ^IPersistStorage
            do
               'CSite.Update'->debug.locateMsg.in;
               return:
                 (# 
                 do
                    (if m_pIStorage[] <> none then leave return if);
                    ;
                    IPersistStorage_IID->IID_IPersistStorage;
                    debug.callToObjectMsg
                      (# 
                      do 'CSite.Update: kald til QueryInterface'->msg.append
                      #);
                    (m_pObj[],IID_IPersistStorage[])->Query->pIPS[];
                    debug.callToObjectMsg
                      (# 
                      do
                         'CSite.Update: kald til QueryInterface returneret'
                           ->msg.append
                      #);
                    (pIPS[],m_pIStorage[],true)->OleSave;
                    debug.callToObjectMsg
                      (# 
                      do
                         'CSite.Update: kald til SaveCompleted+Release'
                           ->msg.append
                      #);
                    none ->pIPS.SaveCompleted;
                    pIPS.Release;
                    debug.callToObjectMsg
                      (# 
                      do
                         'CSite.Update: kald til SaveCompleted+Release returneret'
                           ->msg.append
                      #);
                    ;
                    STGC_DEFAULT->m_pIStorage.Commit;
                    leave return
                 #);
               'CSite.Update'->debug.locateMsg.out
            #);
          Destroy:
            (# pIStorage: ^IStorage
            enter pIStorage[]
            do
               'CSite.Destroy'->debug.locateMsg.in;
               return:
                 (#
                    szName2: @text;
                    szName: [0] @char (* ^text NYI *) (* OLECHAR* *)
                 do
                    (if pIStorage[] = none then leave return if);
                    ;
                    (if m_pObj[] <> none then false->close if);
                    ;
                    'Site '->szName2;
                    m_dwID->szName2.putint;
                    szName2->szName;
                    szName->pIStorage.DestroyElement;
                    ;
                    leave return
                 #);
               'CSite.Destroy'->debug.locateMsg.out
            #);
          rc: @struct_tagRECT;
          Activate:
            (# iVerb: @int32; aint32holder: @int32Holder; hr: @HResult
            enter iVerb
            do
               'CSite.Activate'->debug.locateMsg.in;
               (* m_hWnd->aint32holder *)
               ;
               (if true then
                   (m_hWnd,rc[])->GetClientRect2
                else
                   m_hWnd->Aint32holder;
                   (aInt32Holder[],rc[])->GetClientRect3;
                   aint32holder->m_hWnd
               if);
               debug.debugMsg
                 (# 
                 do
                    'Activate> GetClientRect: '->msg.append;
                    rc.top->msg.putint;
                    ','->msg.append;
                    rc.bottom->msg.putint;
                    ','->msg.append;
                    rc.left->msg.putint;
                    ','->msg.append;
                    rc.right->msg.putint
                 #);
               (* 16->malloc->theNtRectPtr;
                (if theNtRectPtr <> 0 then
                (windowID,theNtRectPtr)->GetClientRect; theNtRectPtr->free; 
                else
                false->didSomething; 
                if);    aint32holder->m_hWnd;
                *)
               ;
               m_hWnd->Aint32holder;
               (if false then
                   (none ,'Calling OleObject.DoVerb... ',none )->alertUser
               if);
               debug.callToObjectMsg
                 (#  do 'CSite.Activate: kald til DoVerb'->msg.append #);
               (iVerb,none ,m_pImpIOleClientSite[],0,m_hwnd (*aInt32holder[]*) ,
                rc[])->m_pIOleObject.DoVerb->hr;
               debug.callToObjectMsg
                 (# 
                 do 'CSite.Activate: kald til DoVerb returneret'->msg.append
                 #);
               (if false then
                   (none ,'AFTER calling OleObject.DoVerb... ',none )->alertUser
               if);
               aint32holder->m_hWnd;
               debug.debugMsg
                 (# 
                 do
                    (if hr.succeeded then
                        'OleObject.DoVerb succeeded'->msg.append;
                        (if false then
                            (none ,'OleObject.DoVerb succeeded',none )
                              ->alertUser
                        if)
                     else
                        'OleObject.DoVerb failed '->msg.append;
                        (if false then
                            (none ,'OleObject.DoVerb failed',none )->alertUser
                        if);
                        (if false then
                            'OleObject.DoVerb failed '->puttext;
                            hr.value->debug.myprint
                        if)
                    if)
                 #);
               'CSite.Activate'->debug.locateMsg.out
            #);
          UpdateObjectRects:
            (# 
            do
               'CSite.UpdateObjectRects'->debug.locateMsg.in;
               return:
                 (# 
                 do
                    (if m_pIOleDocView[] = none then leave return if);
                    ;
                    'GetClientRect(m_hWnd, &rc)'->putline;
                    'm_pIOleDocView->SetRect(&rc)'->putline
                 #);
               'CSite.UpdateObjectRects'->debug.locateMsg.out
            #)
       #);
     CFrameType: IUnknown
       (#
          PROTECTED: (#  #);
          m_hInst: (* Task instance.
                    =HINSTANCE *) (#  exit uienvHInstance #);
          m_hWnd: (* Window handle of the window.
                   =HWND *)
            (# handle: @integer
            do
               (if mainWindow[] <> none then
                   mainWindow.InterfaceObjectID->handle;
                   debug.debugMsg
                     (# 
                     do
                        'CFrame.m_hWnd: handle='->msg.append; handle->msg.putint
                     #)
                else
                   debug.debugMsg
                     (# 
                     do 'CFrame.m_hWnd: mainWindow[]=none'->msg.append
                     #);
                   117->handle
               if)
            exit handle
            #);
          m_cRef: (* =ULONG *) @integer;
          ;
          m_hInstPrev: (* WinMain parameters.
                        =HINSTANCE *) @integer;
          m_pszCmdLine: (* =LPTSTR *) @ (#  #);
          m_nCmdShow: (* =int *) @integer;
          ;
          m_phMenu: (* Popup menu handles.
                     =HMENU* *)
            (# 
            exit mainWindow.private.theWin32Menubar.interfaceObjectID
            #);
          m_hAccel: (* Accelerators.
                     =HACCEL *) @integer;
          m_hWndClient: (* Client area window.
                         =HWND *)
            (# handle: @integer
            do
               (if mainWindow[] <> none then
                   mainWindow.clientCanvas.InterfaceObjectID->handle;
                   debug.debugMsg
                     (# 
                     do
                        (if false then
                            'CFrame.m_hWndClient: handle='->msg.append;
                            handle->msg.putint
                        if)
                     #)
                else
                   'CFrame.m_hWndClient: mainWindow[]=none'->putline
               if)
            exit handle
            #);
          ;
          m_fInitialized: (* OleInitialize called?.
                           =BOOL *) @boolean;
          m_pIStorage:
          (* Temp file for all needs.
           =IStorage* *) ^IStorage;
          m_dwIDCounter: (* For site IDs.
                          =DWORD *) @integer;
          ;
          m_hMenuOrg: (* Original menu.
                       =HMENU *) @integer;
          m_hMenuTop: (* Currently shown menu.
                       =HMENU *) @integer;
          m_hMenuHelp: (* Special Help menu.
                        =HMENU *) @integer;
          m_fUsingOurHelp: (* Help menu in use?
                            =BOOL *) @boolean;
          m_fInObjectHelp: (* Object's menu found?
                            =BOOL *) @boolean;
          m_fOurMenuShowing: (* Our menu up?
                              =BOOL *) @boolean;
          ;
          m_fHaveObject: (* For menu enabling.
                          =BOOL *) @boolean;
          m_hWndObj: (* UI Active object.
                      =HWND *) @integer;
          ;
          m_pSite: (* Site holding object.
                    =class CSite * *) ^CSite;
          m_bwIP:
          (* In/place tool allocations.
           =BORDERWIDTHS *) @integer;
          m_fInContextHelp: (* In context help mode?
                             =BOOL *) @boolean;
          ;
          m_pIOleIPActiveObject: (* =IOleInPlaceActiveObject* *)
            ^IOleInPlaceActiveObject;
          ;
          ;
          PROTECTED_: (#  #);
          RegisterAllClasses:
          (*
           /*
           * CFrame::RegisterAllClasses
           *
           * Purpose:
           *  Registers all classes used in this application.
           *
           * Return Value:
           *  BOOL            TRUE if registration succeeded, FALSE otherwise.
           */
           
           BOOL CFrame::RegisterAllClasses(void)
           {
           WNDCLASS        wc;
           
           //Field that are the same for all windows.
           wc.style         = CS_HREDRAW | CS_VREDRAW;
           wc.hInstance     = m_hInst;
           wc.cbClsExtra    = 0;
           
           //Register the Frame window
           wc.lpfnWndProc   = FrameWndProc;
           wc.cbWndExtra    = CBFRAMEWNDEXTRA;
           wc.hIcon         = LoadIcon(m_hInst, TEXT("Icon"));
           wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
           wc.hbrBackground = NULL;
           wc.lpszMenuName  = MAKEINTRESOURCE(IDR_MENU);
           wc.lpszClassName = SZCLASSFRAME;
           
           if (!RegisterClass(&wc))
           return FALSE;
           
           
           //Register the do-nothing Client window
           wc.lpfnWndProc   = ClientWndProc;
           wc.cbWndExtra    = CBCLIENTWNDEXTRA;
           wc.hIcon         = NULL;
           wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
           wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
           wc.lpszMenuName  = NULL;
           wc.lpszClassName = SZCLASSCLIENT;
           
           if (!RegisterClass(&wc))
           return FALSE;
           
           return TRUE;
           }
           *)
            (# result: @boolean
            do
               'CFrame.RegisterAllClasses'->debug.locateMsg.in;
               'CFrame.RegisterAllClasses'->debug.locateMsg.out
            exit result
            #);
          CreateObject:
            (# filename: ^text; result: @boolean
            enter filename[]
            do
               'CFrame.CreateObject'->debug.locateMsg.in;
               return:
                 (# 
                 do
                    &CSite[]->m_pSite[];
                    m_dwIDCounter+1->m_dwIDCounter;
                    (m_dwIDCounter,m_hWndClient,THIS(CFrameType)[])
                      ->m_pSite.constructor;
                    m_pSite.AddRef;
                    ;
                    (filename[],m_pIStorage[])->m_pSite.Create->result;
                    (if not result then
                        'CFrame.CreateObject: m_pSite.Create returned false'
                          ->putline;
                        leave return
                    if);
                    ;
                    true->m_fHaveObject;
                    ;
                    (if false then
                        'Kalder CSite.Activate med SHOW'->putline
                    if);
                    OLEIVERB_SHOW->m_pSite.Activate;
                    (if false then
                        'Kalder CSite.Activate med SHOW - returneret'->putline
                    if);
                    ;
                    (m_hWndClient,0,true)->InvalidateRect;
                    m_hWndClient->UpdateWindow;
                    true->result;
                    leave return
                 #);
               'CFrame.CreateObject'->debug.locateMsg.out
            exit result
            #);
          ResizeClientWindow:
            (# 
            do
               'CFrame.ResizeClientWindow'->debug.locateMsg.in;
               'CFrame.ResizeClientWindow'->debug.locateMsg.out
            #);
          ;
          ;
          PUBLIC_: (#  #);
          Instance:
          (*
           inline HINSTANCE Instance(void)
           { return m_hInst; }
           *) (#  exit m_hInst #);
          Window_:
          (*
           inline HWND      Window(void)
           { return m_hWnd; }        
           *) (#  exit m_hWnd #);
          Accelerators:
          (*
           inline HACCEL    Accelerators(void)
           { return m_hAccel; }        
           *) (#  exit m_hAccel #);
          Init:
            (#
               result: @boolean;
               hr: @HRESULT;
               anIStorageHolder: @IStorageHolder;
               docFileMode: @integer
            do
               'CFrame.Init'->debug.locateMsg.in;
               return:
                 (# abc: (#  #); hMenu: @integer
                 do (* 1. Initialize OLE *)
                    0->OleInitialize->hr;
                    (if hr.succeeded then
                        true->m_fInitialized
                     else
                        false->result; leave return
                    if);
                    ;
                    (* 2. Register window classes *)
                    (if m_hInstPrev = 0 then
                        (if not RegisterAllClasses then
                            false->result; leave return
                        if)
                    if);
                    ;
                    (* 3. Create the main window and client-area window *)
                    &MainWindowType[]->mainWindow[];
                    mainWindow.open;
                    mainWindow.private.theWin32Menubar.InterfaceObjectID->hMenu
                      ->m_hMenuOrg;
                    (if false then
                        'hMenuOrg: '->puttext; m_hMenuOrg->putint; newline
                    if);
                    ;
                    (* 4. Allocate menu array for use with in-place menu merging. *)
                    abc;
                    (* Also load the special help menu *)
                    abc;
                    ;
                    (* 5. Load accelerators *)
                    abc;
                    ;
                    (* 6. Make us all visible. *)
                    abc;
                    ;
                    (* 7. Create a temp file for all embedded files. Note that in this
                     sample we don't save any changes to DocObjects because we
                     don't manage any storage directly. *)
                    STGM_TRANSACTED %Bor STGM_READWRITE
                    %Bor
                      STGM_SHARE_EXCLUSIVE
                    %Bor
                      STGM_CREATE
                    %Bor
                      STGM_DELETEONRELEASE->docFileMode;
                    (none ,docFileMode,0,anIStorageHolder[])->StgCreateDocfile
                      ->hr;
                    anIStorageHolder->m_pIStorage[];
                    (if m_pIStorage[] = none then
                        'CFrame.Init: StgCreateDocFile failed'->putline
                    if);
                    (if hr.failed then false->result; leave return if);
                    ;
                    true->result;
                    leave return
                 #);
               &COleInPlaceFrame[]->theOleInPlaceFrame[];
               'CFrame.Init'->debug.locateMsg.out
            exit result
            #);
          Close:
            (# pSite: ^CSite
            do
               'CFrame.Close'->debug.locateMsg.in;
               (if m_pSite[] <> none then
                   m_pSite[]->pSite[] (* Prevents reentry *) ;
                   none ->m_pSite[];
                   ;
                   false->pSite.close (* Frees the object *) ;
                   m_pIStorage[]->pSite.destroy (* cleans up the storage *) ;
                   pSite.release (* frees the site *)
               if);
               ;
               false->m_fHaveObject;
               ;
               mainWindow.update;
               'CFrame.Close'->debug.locateMsg.out
            #);
          ;
          ;
          PUBLIC: (* se framer.h *) (#  #);
          constructor:
            (#
               hInst: @integer;
               hInstPrev: @integer;
               pszCmdLine: ^text;
               nCmdShow: @integer
            enter (hInst,hInstPrev,pszCmdLine[],nCmdShow)
            do (* hInst->m_hInst;
                0->m_hWnd;*)
               hInstPrev->m_hInstPrev;
               nCmdShow->m_nCmdShow;
               ;
               0->m_hAccel;
               ;
               false->m_fInitialized;
               none ->m_pIStorage[];
               0->m_dwIDCounter;
               ;
               0->m_hMenuOrg;
               0->m_hMenuTop;
               0->m_hMenuHelp;
               false->m_fInObjectHelp;
               false->m_fUsingOurHelp;
               ;
               false->m_fHaveObject;
               0->m_hWndObj;
               ;
               none ->m_pSite[];
               true->m_fOurMenuShowing;
               SHOULD_HANDLE_SetRect: (#  #);
               false->m_fInContextHelp;
               none ->m_pIOleIPActiveObject[]
            #);
          destructor:
            (# 
            do
               ReleaseInterface: (* expanded macro *)
                 (# pt: ^IUnknown
                 do
                    m_pIStorage[]->pt[];
                    none ->m_pIStorage[];
                    (if pt[] <> none then pt.Release if)
                 #)
                 (* Frees the temp file *)
                 ;
               (if m_fInitialized then OleUninitialize if)
            #);
          QueryInterface::< 
            (#
               Unknown_IID,OleInPlaceUIWindow_IID,OleWindow_IID,
                 OleInPlaceFrame_IID,OleCommandTarget_IID: @IID;
               init:
                 (# 
                 do
                    IUnknown_IID->Unknown_IID;
                    IOleInPlaceUIWindow_IID->OleInPlaceUIWindow_IID;
                    IOleWindow_IID->OleWindow_IID;
                    IOleInPlaceFrame_IID->OleInPlaceFrame_IID;
                    IOleCommandTarget_IID->OleCommandTarget_IID;
                    ;
                    (if false then
                        debug.debugMsg
                          (# 
                          do
                             'CFrame.QueryInterface supports: '->msg.append;
                             Unknown_IID->msg.append;
                             ', '->msg.append;
                             OleInPlaceUIWindow_IID->msg.append;
                             ', '->msg.append;
                             OleWindow_IID->msg.append;
                             ', '->msg.append;
                             OleInPlaceFrame_IID->msg.append;
                             ', '->msg.append;
                             OleCommandTarget_IID->msg.append
                          #)
                    if)
                 #);
               doAlertUser: (#  exit false #);
               ;
               aGUID: @GUID
            do
               '++CFrame.QueryInterface'->debug.interfaceMsg;
               ;
               init;
               riid[]->aGUID.binary[];
               (if false then
                   debug.debugMsg
                     (# 
                     do
                        'CFrame.QueryInterface: Request for interface '
                          ->msg.append;
                        aGUID->msg.append
                     #)
               if);
               ;
               none ->ppvObject;
               (if true
                // aGUID[]->Unknown_IID.equal then
                   '        -IUnknown'->debug.interfaceMsg
                // aGUID[]->OleInPlaceUIWindow_IID.equal then
                   '        -IOleInPlaceUIWindow'->debug.interfaceMsg
                // aGUID[]->OleWindow_IID.equal then
                   '        -IOleWindow'->debug.interfaceMsg
                // aGUID[]->OleInPlaceFrame_IID.equal then
                   '        -IOleInPlaceFrame'->debug.interfaceMsg
                // aGUID[]->OleCommandTarget_IID.equal then
                   '        -IOleCommandTarget'->debug.interfaceMsg
               if);
               (if true
                // aGUID[]->Unknown_IID.equal
                // aGUID[]->OleInPlaceUIWindow_IID.equal
                // aGUID[]->OleWindow_IID.equal
                // aGUID[]->OleInPlaceFrame_IID.equal then
                   (if false then
                       '        -IUnknown / IOleInPlaceUIWindow / IOleWindow / IOleInPlaceFrame'
                         ->debug.interfaceMsg
                   if);
                   theOleInPlaceFrame[]->ppvObject;
                   (if doAlertUser then
                       (none ,
                        'CFrame.QueryInterface:\nIUnknown / IOleInPlaceUIWindow / IOleWindow / IOleInPlaceFrame',
                        none )->alertUser
                   if)
                // aGUID[]->OleCommandTarget_IID.equal then
                   (if false then
                       '        -IOleCommandTarget'->debug.interfaceMsg
                   if);
                   theOleCommandTarget[]->ppvObject;
                   (if doAlertUser then
                       (none ,'CFrame.QueryInterface IOleCommandTarget',none )
                         ->alertUser
                   if)
               if);
               ;
               (if ppvObject <> none then
                   ppvObject.ref.AddRef; NOERROR->result
                else
                   '        -No such interface'->debug.interfaceMsg;
                   E_NOINTERFACE->result;
                   (if doAlertUser then
                       (none ,'CFrame.QueryInterface: No such interface!',none )
                         ->alertUser
                   if)
               if)
            #);
          AddRef::< 
            (# 
            do
               debug.interfaceMsg
                 (# 
                 do
                    '--CFrame.AddRef ('->msg.append;
                    m_cRef+1->msg.putint;
                    ')'->msg.append
                 #);
               m_cRef+1->m_cRef->result
            #);
          Release::< 
            (# 
            do
               debug.interfaceMsg
                 (# 
                 do
                    '--CFrame.Release ('->msg.append;
                    m_cRef-1->msg.putint;
                    ')'->msg.append
                 #);
               m_cRef-1->m_cRef->result
            #);
          ;
          theOleInPlaceFrame: ^COleInPlaceFrame;
          COleInPlaceFrame: IOleInPlaceFrame
            (#
               QueryInterface::< 
                 (# 
                 do
                    (riid[],ppvObject[])->THIS(CFrameType).QueryInterface
                      ->result
                 #);
               AddRef::<  (#  do THIS(CFrameType).AddRef->result #);
               Release::<  (#  do THIS(CFrameType).Release->result #);
               ;
               GetWindow::< 
                 (# 
                 do
                    'OleInPlaceFrame.GetWindow'->debug.interfaceMsg;
                    m_hWnd->phWnd;
                    NOERROR->result
                 #);
               ContextSensitiveHelp::< 
                 (# 
                 do
                    'OleInPlaceFrame.ContextSensitiveHelp'->debug.interfaceMsg;
                    NOERROR->result
                 #);
               GetBorder::< 
                 (# 
                 do
                    'OleInPlaceFrame.GetBorder'->debug.interfaceMsg;
                    NOERROR->result
                 #);
               RequestBorderSpace::< 
                 (# 
                 do
                    'OleInPlaceFrame.RequestBorderSpace'->debug.interfaceMsg;
                    NOERROR->result
                 #);
               SetBorderSpace::< 
                 (# 
                 do
                    'OleInPlaceFrame.SetBorderSpace'->debug.interfaceMsg;
                    NOERROR->result
                 #);
               SetActiveObject::< 
                 (# 
                 do
                    'OleInPlaceFrame.SetActiveObject'->debug.interfaceMsg;
                    NOERROR->result
                 #);
               InsertMenus::< 
                 (# 
                 do
                    'OleInPlaceFrame.InsertMenus'->debug.interfaceMsg;
                    NOERROR->result
                 #);
               SetMenu::< 
                 (# 
                 do
                    'OleInPlaceFrame.SetMenu'->debug.interfaceMsg;
                    NOERROR->result
                 #);
               RemoveMenus::< 
                 (# 
                 do
                    'OleInPlaceFrame.RemoveMenus'->debug.interfaceMsg;
                    NOERROR->result
                 #);
               SetStatusText::< 
                 (# 
                 do
                    'OleInPlaceFrame.SetStatusText'->debug.interfaceMsg;
                    E_NOTIMPL->result (* We have no status line... *)
                 #);
               EnableModeless::< 
                 (# 
                 do
                    'OleInPlaceFrame.EnableModeless'->debug.interfaceMsg;
                    NOERROR->result
                 #);
               TranslateAccelerator::< 
                 (# 
                 do
                    'OleInPlaceFrame.TranslateAccelerator'->debug.interfaceMsg;
                    S_FALSE->result
                 #)
            #);
          theOleCommandTarget: @COleCommandTarget;
          COleCommandTarget: IOleCommandTarget
            (#
               QueryStatus::< 
                 (#  do resource.OLECMDERR_E_UNKNOWNGROUP->result #);
               Exec::<  (#  do resource.OLECMDERR_E_UNKNOWNGROUP->result #)
            #)
       #);
     CFrame: ^CFrameType;
     ;
     Framework_Interface: @
       (#
          CreateObject:
            (# filename: ^text; fOK: @boolean
            enter filename[]
            do filename[]->CFrame.CreateObject->fOK
            exit fOK
            #);
          Close: (#  do CFrame.close #)
       #);
     ;
     mainWindowType: window
       (#
          open::< 
            (# 
            do (486,338)->size; clientCanvas.open; 'Doc Framer'->title
            #);
          eventHandler::<  (# onAboutToClose::<  (#  do onExit #) #);
          menubarType:: 
            (#
               fileMenu: @menu
                 (#
                    openItem: @menuItem
                      (#
                         eventHandler:: 
                           (# onSelect::  (#  do onOpen;  #);  #);
                         open::  (#  do '&Open'->name; 'o'->key #)
                      #);
                    closeItem: @menuItem
                      (#
                         eventHandler:: 
                           (# onSelect::  (#  do onClose #);  #);
                         open::  (#  do '&Close'->name; 'c'->key #)
                      #);
                    exitItem: @menuItem
                      (#
                         eventHandler:: 
                           (# onSelect::  (#  do onExit #);  #);
                         open::  (#  do 'E&xit'->name; 'x'->key;  #)
                      #);
                    sep1: @separator;
                    open:: 
                      (# 
                      do
                         '&File'->name;
                         openItem.open;
                         openItem[]->append;
                         closeItem.open;
                         closeItem[]->append;
                         sep1.open;
                         sep1[]->append;
                         exitItem.open;
                         exitItem[]->append
                      #)
                 #);
               shortcutsMenu: @menu
                 (#
                    shortcut1Item: @menuItem
                      (#
                         eventHandler:: 
                           (# onSelect::  (#  do onShortcut1 #);  #);
                         open::  (#  do 'Shortcut &1'->name; '1'->key #)
                      #);
                    open:: 
                      (# 
                      do
                         'Shortcuts'->name;
                         Shortcut1Item.open;
                         Shortcut1Item[]->append
                      #)
                 #);
               open::< 
                 (# 
                 do
                    fileMenu.open;
                    fileMenu[]->append;
                    ShortcutsMenu.open;
                    ShortcutsMenu[]->append;
                    INNER
                 #)
            #);
          clientCanvas: @canvas
            (#
               open::< 
                 (# 
                 do
                    4->border.style;
                    true->border.visible;
                    (449,287)->size;
                    (18,32)->position;
                    
                 #);
               eventHandler::< 
                 (#
                    onEnableTarget::< 
                      (#  do 'WINDOW: onEnableTarget'->putline #);
                    onActivate::< 
                      (# 
                      do (if false then 'WINDOW: onActivate'->putline if)
                      #)
                 #)
            #);
          ;
          onOpen:<
            (# filename: ^text; fOK: @boolean
            do
               fileSelectionDialog (#  do '*'->filter[] #)->filename[];
               (if filename[] <> none then
                   'onOpen: "'->puttext;
                   filename[]->puttext;
                   '".'->putline;
                   filename[]->Framework_Interface.CreateObject->fOK
                else
               (* Cancelled *)
                   
               if)
            #);
          onClose:< (#  do Framework_Interface.close #);
          onExit:<
            (# 
            do 'PostMessage(hWnd, WM_CLOSE, 0, 0L)'; debug.close; terminate
            #);
          ;
          onShortcut1:<
            (# filename: ^text; ok: @boolean
            do
               'c:\\beta\\r4.2dev\\comlib\\demo\\documentcontainer\\__Bitmap.bmp'
                 ->filename[];
               'onShortcut1: "'->puttext;
               filename[]->puttext;
               '".'->putline;
               filename[]->Framework_Interface.CreateObject->ok
            #)
       #);
     mainWindow: ^mainWindowType
  do
     debug.open;
     &CFrameType[]->CFrame[];
     (uienvHInstance,117,none ,0)->CFrame.constructor;
     CFrame.Init
  #)  

