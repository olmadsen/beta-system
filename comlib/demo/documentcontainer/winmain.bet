ORIGIN '~beta/guienv/guienvall';
INCLUDE '~beta/guienv/private/winnt/guienv_ntiprivate'
        '~beta/comlib/comlib'
        '~beta/comlib/oleidl'
        '~beta/comlib/docobj'
        '~beta/win32lib/winerror'
        'additionslib'
        '~beta/win32lib/windowmanagement';
-- program: Descriptor --
guienv
  (#
     debug: (#  exit true #);
     debugMsg: (#  do (if debug then INNER if) #);
     CImpOleClientSite: IOleClientSite
       (#
          PROTECTED: (#  #);
          m_cRef: (* =ULONG *) @integer;
          m_pSite: (* =class CSite* *) ^CSite;
          m_pUnkOuter: (* LPUNKNOWN *) ^IUnknown;
          ;
          ;
          PUBLIC: (#  #);
          constructor:
          (*
           CImpIOleClientSite::CImpIOleClientSite(PCSite pSite, LPUNKNOWN pUnkOuter)
           {
           m_cRef=0;
           m_pSite=pSite;
           m_pUnkOuter=pUnkOuter;
           return;
           }
           *)
            (# pSite: ^CSite; pUnkOuter: (* = LPUNKNOWN *) ^IUnknown
            enter (pSite[],pUnkOuter[])
            do
               debugMsg
                 (#  do '--> IOleClientSite.constructor'->putline #);
               0->m_cRef;
               pSite[]->m_pSite[];
               pUnkOuter[]->m_pUnkOuter[]
            #);
          destructor:
          (* 
           CImpIOleClientSite::~CImpIOleClientSite(void)
           {return;}
           *)
            (# 
            do debugMsg (#  do '--> IOleClientSite.destructor'->putline #)
            #);
          QueryInterface::<
          (*
           STDMETHODIMP CImpIOleClientSite::QueryInterface(REFIID riid, void **ppv)
           {return m_pUnkOuter->QueryInterface(riid, ppv);}
           *) 
            (# 
            do
               debugMsg
                 (#  do '--> IOleClientSite.QueryInterface'->putline #)
            exit (riid[],ppvObject[])->m_pUnkOuter.QueryInterface
            #);
          AddRef::<
          (*
           STDMETHODIMP_(ULONG) CImpIOleClientSite::AddRef(void)
           {
           ++m_cRef;
           return m_pUnkOuter->AddRef();
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do '--> IOleClientSite.AddRef'->putline #);
               m_cRef+1->m_cRef
            exit m_pUnkOuter.AddRef
            #);
          Release::<
          (*
           STDMETHODIMP_(ULONG) CImpIOleClientSite::Release(void)
           {
           --m_cRef;
           return m_pUnkOuter->Release();
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do '--> IOleClientSite.Release'->putline #);
               m_cRef-1->m_cRef
            exit m_pUnkOuter.Release
            #);
          ;
          SaveObject::<
          (*
           STDMETHODIMP CImpIOleClientSite::SaveObject(void)
           {
           return NOERROR;
           }
           *) 
            (# 
            do '--> IOleClientSite.SaveObject'->putline; NO_ERROR->result
            #);
          GetMoniker::<
          (*
           STDMETHODIMP CImpIOleClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhich, LPMONIKER *ppmk)
           {return E_NOTIMPL;}
           *) 
            (# 
            do '--> IOleClientSite.GetMoniker'->putline; E_NOTIMPL->result
            #);
          GetContainer::<
          (*
           STDMETHODIMP CImpIOleClientSite::GetContainer(LPOLECONTAINER * ppContainer)
           {
           *ppContainer=NULL;
           return E_NOINTERFACE;
           }
           *) 
            (# 
            do
               '--> IOleClientSite.GetContainer'->putline;
               none ->ppContainer;
               E_NOTIMPL->result
            #);
          ShowObject::<
          (*
           STDMETHODIMP CImpIOleClientSite::ShowObject(void)
           {return NOERROR;}
           *) 
            (# 
            do '--> IOleClientSite.ShowObject'->putline; NO_ERROR->result
            #);
          OnShowWindow::<
          (*
           STDMETHODIMP CImpIOleClientSite::OnShowWindow(BOOL fShow)
           {return NOERROR;}
           *) 
            (# 
            do '--> IOleClientSite.OnShowWindow'->putline; NO_ERROR->result
            #);
          RequestNewObjectLayout::<
          (*
           STDMETHODIMP CImpIOleClientSite::RequestNewObjectLayout(void)
           {return E_NOTIMPL;}
           *) 
            (# 
            do
               '--> IOleClientSite.RequestNewObjectLayout'->putline;
               E_NOTIMPL->result
            #)
       #);
     CImpAdviseSink: IAdviseSink
       (#
          PROTECTED: (#  #);
          m_cRef: (* =ULONG *) @integer;
          m_pSite: (* =class CSite* *) ^CSite;
          m_pUnkOuter: (* LPUNKNOWN *) ^IUnknown;
          ;
          ;
          PUBLIC: (#  #);
          constructor:
          (*
           CImpIAdviseSink::CImpIAdviseSink(PCSite pSite
           , LPUNKNOWN pUnkOuter)
           {
           m_cRef=0;
           m_pSite=pSite;
           m_pUnkOuter=pUnkOuter;
           return;
           }
           *)
            (# pSite: ^CSite; pUnkOuter: (* = LPUNKNOWN *) ^IUnknown
            enter (pSite[],pUnkOuter[])
            do
               debugMsg
                 (#  do '--> IAdviseSink.constructor'->putline #);
               0->m_cRef;
               pSite[]->m_pSite[];
               pUnkOuter[]->m_pUnkOuter[]
            #);
          destructor:
          (*
           CImpIAdviseSink::~CImpIAdviseSink(void)
           {
           return;
           }
           *)
            (# 
            do debugMsg (#  do '--> IAdviseSink.destructor'->putline #)
            #);
          QueryInterface::<
          (*
           STDMETHODIMP CImpIAdviseSink::QueryInterface(REFIID riid, void **ppv)
           {
           return m_pUnkOuter->QueryInterface(riid, ppv);
           }
           *) 
            (# 
            do debugMsg (#  do '--> IAdviseSink.QueryInterface'->putline #)
            exit (riid[],ppvObject[])->m_pUnkOuter.QueryInterface
            #);
          AddRef::<
          (*
           STDMETHODIMP_(ULONG) CImpIAdviseSink::AddRef(void)
           {
           ++m_cRef;
           return m_pUnkOuter->AddRef();
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do '--> IAdviseSink.AddRef'->putline #);
               m_cRef+1->m_cRef
            exit m_pUnkOuter.AddRef
            #);
          Release::<
          (*
           STDMETHODIMP_(ULONG) CImpIAdviseSink::Release(void)
           {
           --m_cRef;
           return m_pUnkOuter->Release();
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do '--> IAdviseSink.Release'->putline #);
               m_cRef-1->m_cRef
            exit m_pUnkOuter.Release
            #);
          ;
          OnDataChange::<
          (*
           STDMETHODIMP_(void) CImpIAdviseSink::OnDataChange(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM)
           {return;}
           *) 
            (# 
            do debugMsg (#  do '--> IAdviseSink.OnDataChange'->putline #)
            #);
          OnViewChange::<
          (*
           STDMETHODIMP_(void) CImpIAdviseSink::OnViewChange(DWORD dwAspect, LONG lindex)
           {return;}
           *) 
            (# 
            do debugMsg (#  do '--> IAdviseSink.OnViewChange'->putline #)
            #);
          OnRename::<
          (*
           STDMETHODIMP_(void) CImpIAdviseSink::OnRename(LPMONIKER pmk)
           {return;}
           *) 
            (# 
            do debugMsg (#  do '--> IAdviseSink.OnRename'->putline #)
            #);
          OnSave::<
          (*
           STDMETHODIMP_(void) CImpIAdviseSink::OnSave(void)
           {return;}
           *) 
            (# 
            do debugMsg (#  do '--> IAdviseSink.OnSave'->putline #)
            #);
          OnClose::<
          (*
           /*
           * CImpIAdviseSink::OnClose
           *
           * Purpose:
           *  Informs the advise sink that the OLE object has closed and is
           *  no longer bound in any way.  We use this to do a File/Close
           *  to delete the object since we don't hold onto any.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  None
           */
           
           STDMETHODIMP_(void) CImpIAdviseSink::OnClose(void)
           {
           //This does the same as File/Close
           //Not quite because CFrame::Close requires some synchronous
           //calls that will fail if done here, so just post a message to
           //do this
           //m_pSite->m_pFR->Close();
           
           HWNDhwnd;
           m_pSite->m_pFR->GetWindow(&hwnd);
           PostMessage(
           hwnd, 
           WM_COMMAND,
           MAKELONG(IDM_FILECLOSE, 0),
           0);
           return;
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do 'IAdviseSink.OnClose'->putline #);
               'ACTION missing'->putline
            #)
       #);
     CImpOleInPlaceSite: IOleInPlaceSite
       (#
          PROTECTED: (#  #);
          m_cRef: (* =ULONG *) @integer;
          m_pSite: (* =class CSite* *) ^CSite;
          m_pUnkOuter: (* LPUNKNOWN *) ^IUnknown;
          ;
          ;
          PUBLIC: (#  #);
          constructor:
          (*
           /*
           * CImpIOleInPlaceSite::CImpIOleInPlaceSite
           * CImpIOleInPlaceSite::~CImpIOleInPlaceSite
           *
           * Parameters (Constructor):
           *  pSite           PCSite of the site we're in.
           *  pUnkOuter       LPUNKNOWN to which we delegate.
           */
           
           CImpIOleInPlaceSite::CImpIOleInPlaceSite(PCSite pSite
           , LPUNKNOWN pUnkOuter)
           {
           m_cRef=0;
           m_pSite=pSite;
           m_pUnkOuter=pUnkOuter;
           return;
           }
           *)
            (# pSite: ^CSite; pUnkOuter: (* = LPUNKNOWN *) ^IUnknown
            enter (pSite[],pUnkOuter[])
            do
               debugMsg
                 (#  do '--> IOleInPlaceSite.constructor'->putline #);
               0->m_cRef;
               pSite[]->m_pSite[];
               pUnkOuter[]->m_pUnkOuter[]
            #);
          destructor:
          (*
           CImpIOleInPlaceSite::~CImpIOleInPlaceSite(void)
           {
           return;
           }
           *)
            (# 
            do debugMsg (#  do '--> IOleInPlaceSite.destructor'->putline #)
            #);
          QueryInterface::<
          (*
           STDMETHODIMP CImpIOleInPlaceSite::QueryInterface(REFIID riid, void **ppv)
           {return m_pUnkOuter->QueryInterface(riid, ppv);}
           *) 
            (# 
            do
               debugMsg
                 (#  do '--> IOleInPlaceSite.QueryInterface'->putline #)
            exit (riid[],ppvObject[])->m_pUnkOuter.QueryInterface
            #);
          AddRef::<
          (*
           STDMETHODIMP_(ULONG) CImpIOleInPlaceSite::AddRef(void)
           {
           ++m_cRef;
           return m_pUnkOuter->AddRef();
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do '--> IOleInPlaceSite.AddRef'->putline #);
               m_cRef+1->m_cRef
            exit m_pUnkOuter.AddRef
            #);
          Release::<
          (*
           STDMETHODIMP_(ULONG) CImpIOleInPlaceSite::Release(void)
           {
           --m_cRef;
           return m_pUnkOuter->Release();
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do '--> IOleInPlaceSite.Release'->putline #);
               m_cRef-1->m_cRef
            exit m_pUnkOuter.Release
            #);
          ;
          GetWindow::<
          (*
           /*
           * CImpIOleInPlaceActiveObject::GetWindow
           *
           * Purpose:
           *  Retrieves the handle of the window associated with the object
           *  on which this interface is implemented.
           *
           * Parameters:
           *  phWnd           HWND * in which to store the window handle.
           *
           * Return Value:
           *  HRESULT         NOERROR if successful, E_FAIL if there is no
           *                  window.
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::GetWindow(HWND *phWnd)
           {
           //This is the client-area window in the frame
           *phWnd=m_pSite->m_hWnd;
           return NOERROR;
           }
           *) 
            (# 
            do debugMsg (#  do '--> IOleInPlaceSite.GetWindow'->putline #)
            exit m_pSite.m_hWnd
            #);
          ContextSensitiveHelp::<
          (*
           /*
           * CImpIOleInPlaceActiveObject::ContextSensitiveHelp
           *
           * Purpose:
           *  Instructs the object on which this interface is implemented to
           *  enter or leave a context-sensitive help mode.
           *
           * Parameters:
           *  fEnterMode      BOOL TRUE to enter the mode, FALSE otherwise.
           *
           * Return Value:
           *  HRESULT         NOERROR
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::ContextSensitiveHelp(BOOL fEnterMode)
           {return NOERROR;}
           *) 
            (# 
            do
               debugMsg
                 (# 
                 do '--> IOleInPlaceSite.ContextSensitiveHelp'->putline
                 #);
               NOERROR->result
            #);
          CanInPlaceActivate::<
          (*
           /*
           * CImpIOleInPlaceSite::CanInPlaceActivate
           *
           * Purpose:
           *  Answers the server whether or not we can currently in-place
           *  activate its object.  By implementing this interface we say
           *  that we support in-place activation, but through this function
           *  we indicate whether the object can currently be activated
           *  in-place.  Iconic aspects, for example, cannot, meaning we
           *  return S_FALSE.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  HRESULT         NOERROR if we can in-place activate the object
           *                  in this site, S_FALSE if not.
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::CanInPlaceActivate(void)
           {    
           /*
           * We can always in-place activate--no restrictions for DocObjects.
           * We don't worry about other cases since CSite only ever creates
           * embedded files.
           */
           return NOERROR;
           }
           *) 
            (# 
            do
               debugMsg
                 (# 
                 do '--> IOleInPlaceSite.CanInPlaceActivate'->putline
                 #);
               NOERROR->result
            #);
          OnInPlaceActivate::<
          (*
           /*
           * CImpIOleInPlaceSite::OnInPlaceActivate
           *
           * Purpose:
           *  Informs the container that an object is being activated in-place
           *  such that the container can prepare appropriately.  The
           *  container does not, however, make any user interface changes at
           *  this point.  See OnUIActivate.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  HRESULT         NOERROR or an appropriate error code.
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::OnInPlaceActivate(void)
           {    
           m_pSite->m_pObj->QueryInterface(IID_IOleInPlaceObject
           , (void ** )&m_pSite->m_pIOleIPObject);
           
           return NOERROR;
           }
           *) 
            (# IID_IOleIPObject: @IID
            do
               debugMsg
                 (#  do '--> IOleInPlaceSite.OnInPlaceActivate'->putline #);
               ;
               IOleInPlaceObject_IID->IID_IOleIPObject;
               (m_pSite.m_pObj[],IID_IOleIPObject[])->Query
                 ->m_pSite.m_pIOleIPObject[];
               ;
               NOERROR->result
            #);
          OnInPlaceDeactivate::<
          (*
           /*
           * CImpIOleInPlaceSite::OnInPlaceDeactivate
           *
           * Purpose:
           *  Notifies the container that the object has deactivated itself
           *  from an in-place state.  Opposite of OnInPlaceActivate.  The
           *  container does not change any UI at this point.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  HRESULT         NOERROR or an appropriate error code.
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::OnInPlaceDeactivate(void)
           {
           /*
           * Since we don't have an Undo command, we can tell the object
           * right away to discard its Undo state.
           */
           m_pSite->Activate(OLEIVERB_DISCARDUNDOSTATE);
           ReleaseInterface(m_pSite->m_pIOleIPObject);
           return NOERROR;
           }
           *) 
            (# 
            do
               debugMsg
                 (# 
                 do '--> IOleInPlaceSite.OnInPlaceDeactivate'->putline
                 #);
               OLEIVERB_DISCARDUNDOSTATE->m_pSite.Activate;
               ReleaseInterface: (* macro ReleaseInterface expanded *)
                 (# pt: ^IUnknown
                 do
                    m_pSite.m_pIOleIPObject[]->pt[];
                    (if pt[] <> none then pt.Release if)
                 #);
               NOERROR->result
            #);
          OnUIActivate::<
          (*
           /*
           * CImpIOleInPlaceSite::OnUIActivate
           *
           * Purpose:
           *  Informs the container that the object is going to start munging
           *  around with user interface, like replacing the menu.  The
           *  container should remove any relevant UI in preparation.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  HRESULT         NOERROR or an appropriate error code.
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::OnUIActivate(void)
           {
           //No state we have to set up here.
           return NOERROR;
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do '--> IOleInPlaceSite.OnUIActivate'->putline #);
               NOERROR->result
            #);
          OnUIDeactivate::<
          (*
           /*
           * CImpIOleInPlaceSite::OnUIDeactivate
           *
           * Purpose:
           *  Informs the container that the object is deactivating its
           *  in-place user interface at which time the container may
           *  reinstate its own.  Opposite of OnUIActivate.
           *
           * Parameters:
           *  fUndoable       BOOL indicating if the object will actually
           *                  perform an Undo if the container calls
           *                  ReactivateAndUndo.
           *
           * Return Value:
           *  HRESULT         NOERROR or an appropriate error code.
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::OnUIDeactivate(BOOL fUndoable)
           {
           //Set focus back to the frame
           SetFocus(m_pSite->m_pFR->Window());
           
           //Show our menu again
           m_pSite->m_pFR->SetMenu(NULL, NULL, NULL);
           
           return NOERROR;
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do '--> IOleInPlaceSite.OnUIDeactivate'->putline #);
               'SetFocus(m_pSite->m_pFR->Window());  m_pSite.m_pFR.SetMenu'
                 ->putline;
               NOERROR->result
            #);
          DeactivateAndUndo::<
          (*
           /*
           * CImpIOleInPlaceSite::DeactivateAndUndo
           *
           * Purpose:
           *  If immediately after activation the object does an Undo, the
           *  action being undone is the activation itself, and this call
           *  informs the container that this is, in fact, what happened.
           *  The container should call IOleInPlaceObject::UIDeactivate.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  HRESULT         NOERROR or an appropriate error code.
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::DeactivateAndUndo(void)
           {
           m_pSite->m_pIOleIPObject->InPlaceDeactivate();
           return NOERROR;
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do '--> IOleInPlaceSite.DeactivateAndUndo'->putline #);
               m_pSite.m_pIOleIPObject.InPlaceDeactivate;
               NOERROR->result
            #);
          DiscardUndoState::<
          (*
           /*
           * CImpIOleInPlaceSite::DiscardUndoState
           *
           * Purpose:
           *  Informs the container that something happened in the object
           *  that means the container should discard any undo information
           *  it currently maintains for the object.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  HRESULT         NOERROR or an appropriate error code.
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::DiscardUndoState(void)
           {
           return E_NOTIMPL;
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do '--> IOleInPlaceSite.DiscardUndoState'->putline #);
               E_NOTIMPL->result
            #);
          GetWindowContext::<
          (*
           /*
           * CImpIOleInPlaceSite::GetWindowContext
           *
           * Purpose:
           *  Provides an in-place object with pointers to the frame and
           *  document level in-place interfaces (IOleInPlaceFrame and
           *  IOleInPlaceUIWindow) such that the object can do border
           *  negotiation and so forth.  Also requests the position and
           *  clipping rectangles of the object in the container and a
           *  pointer to an OLEINPLACEFRAME info structure which contains
           *  accelerator information.
           *
           *  Note that the two interfaces this call returns are not
           *  available through QueryInterface on IOleInPlaceSite since they
           *  live with the frame and document, but not the site.
           *
           * Parameters:
           *  ppIIPFrame      LPOLEINPLACEFRAME * in which to return the
           *                  AddRef'd pointer to the container's
           *                  IOleInPlaceFrame.
           *  ppIIPUIWindow   LPOLEINPLACEUIWINDOW * in which to return
           *                  the AddRef'd pointer to the container document's
           *                  IOleInPlaceUIWindow.
           *  prcPos          LPRECT in which to store the object's position.
           *  prcClip         LPRECT in which to store the object's visible
           *                  region.
           *  pFI             LPOLEINPLACEFRAMEINFO to fill with accelerator
           *                  stuff.
           *
           * Return Value:
           *  HRESULT         NOERROR
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::GetWindowContext
           (LPOLEINPLACEFRAME *ppIIPFrame, LPOLEINPLACEUIWINDOW
           *ppIIPUIWindow, LPRECT prcPos, LPRECT prcClip
           , LPOLEINPLACEFRAMEINFO pFI)
           {
           *ppIIPUIWindow=NULL;
           m_pSite->m_pFR->QueryInterface(IID_IOleInPlaceFrame
           , (void ** )ppIIPFrame);
           
           if (NULL!=prcPos)
           GetClientRect(m_pSite->m_hWnd, prcPos);
           
           *prcClip=*prcPos;
           
           pFI->cb=sizeof(OLEINPLACEFRAMEINFO);
           pFI->fMDIApp=FALSE;
           pFI->hwndFrame=m_pSite->m_pFR->Window();
           pFI->haccel=m_pSite->m_pFR->Accelerators();
           pFI->cAccelEntries=CACCELERATORS;
           
           return NOERROR;
           }
           *) 
            (# IID_IOleInPlaceFrame: @IID
            do
               debugMsg
                 (#  do 'IOleInPlaceSite.GetWindowContext'->putline #);
               ;
               none ->ppDoc;
               ;
               IOleInPlaceFrame_IID->IID_IOleInPlaceFrame;
               (m_pSite.m_pFR.tempOleInPlaceFrame[],IID_IOleInPlaceFrame[])
                 ->Query->ppFrame;
               ;
               (*   (if lprcPosRect[] <> none then
                (m_pSite.m_hWnd,lprcPosRect[])->GetClientRect
                if); *)
               ;
               'GetWindowContext: der mangler en masse.'->putline;
               ;
               NOERROR->result
            #);
          Scroll::<
          (*
           /*
           * CImpIOleInPlaceSite::Scroll
           *
           * Purpose:
           *  Asks the container to scroll the document, and thus the object,
           *  by the given amounts in the sz parameter.
           *
           * Parameters:
           *  sz              SIZE containing signed horizontal and vertical
           *                  extents by which the container should scroll.
           *                  These are in device units.
           *
           * Return Value:
           *  HRESULT         NOERROR
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::Scroll(SIZE sz)
           {
           //Not needed for DocObjects
           return E_NOTIMPL;
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do 'IOleInPlaceSite.Scroll'->putline #);
               E_NOTIMPL->result
            #);
          OnPosRectChange::<
          (*
           /*
           * CImpIOleInPlaceSite::OnPosRectChange
           *
           * Purpose:
           *  Informs the container that the in-place object was resized.
           *  The container must call IOleInPlaceObject::SetObjectRects.
           *  This does not change the site's rectangle in any case.
           *
           * Parameters:
           *  prcPos          LPCRECT containing the new size of the object.
           *
           * Return Value:
           *  HRESULT         NOERROR
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::OnPosRectChange(LPCRECT prcPos)
           {
           //Not needed for DocObjects
           return E_NOTIMPL;
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do 'IOleInPlaceSite.OnPosRectChange'->putline #);
               E_NOTIMPL->result
            #)
       #);
     CImpOleDocumentSite: IOleDocumentSite
       (#
          PROTECTED: (#  #);
          m_cRef: (* =ULONG *) @integer;
          m_pSite: (* =class CSite* *) ^CSite;
          m_pUnkOuter: (* LPUNKNOWN *) ^IUnknown;
          ;
          ;
          PUBLIC: (#  #);
          constructor:
          (*
           /*
           * CImpIOleDocumentSite::CImpIOleDocumentSite
           * CImpIOleDocumentSite::~CImpIOleDocumentSite
           *
           * Parameters (Constructor):
           *  pSite           PCSite of the site we're in.
           *  pUnkOuter       LPUNKNOWN to which we delegate.
           */
           
           CImpIOleDocumentSite::CImpIOleDocumentSite(PCSite pSite
           , LPUNKNOWN pUnkOuter)
           {
           m_cRef=0;
           m_pSite=pSite;
           m_pUnkOuter=pUnkOuter;
           return;
           }
           *)
            (# pSite: ^CSite; pUnkOuter: (* = LPUNKNOWN *) ^IUnknown
            enter (pSite[],pUnkOuter[])
            do
               debugMsg
                 (#  do '--> IOleDocumentSite.constructor'->putline #);
               0->m_cRef;
               pSite[]->m_pSite[];
               pUnkOuter[]->m_pUnkOuter[]
            #);
          destructor:
          (*
           CImpIOleDocumentSite::~CImpIOleDocumentSite(void)
           {
           return;
           }
           *)
            (# 
            do
               debugMsg (#  do '--> IOleDocumentSite.destructor'->putline #)
            #);
          QueryInterface::<
          (*
           STDMETHODIMP CImpIOleDocumentSite::QueryInterface(REFIID riid
           , void **ppv)
           {
           return m_pUnkOuter->QueryInterface(riid, ppv);
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do '--> IOleDocumentSite.QueryInterface'->putline #)
            exit (riid[],ppvObject[])->m_pUnkOuter.QueryInterface
            #);
          AddRef::<
          (*
           STDMETHODIMP_(ULONG) CImpIOleDocumentSite::AddRef(void)
           {
           ++m_cRef;
           return m_pUnkOuter->AddRef();
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do '--> IOleDocumentSite.AddRef'->putline #);
               m_cRef+1->m_cRef
            exit m_pUnkOuter.AddRef
            #);
          Release::<
          (*
           STDMETHODIMP_(ULONG) CImpIOleDocumentSite::Release(void)
           {
           --m_cRef;
           return m_pUnkOuter->Release();
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do '--> IOleDocumentSite.Release'->putline #);
               m_cRef-1->m_cRef
            exit m_pUnkOuter.Release
            #);
          ;
          ActivateMe::<
          (*
           /*
           * CImpIOleDocumentsite::ActivateMe
           *
           * Purpose:
           *  Instructs the container to activate the object in this site as
           *  a document object.
           *
           * Parameters:
           *  pView           IOleDocumentView * of the object to activate.
           *
           * Return Value:
           *  HRESULT         NOERROR if successful, error code otherwise.
           */
           
           STDMETHODIMP CImpIOleDocumentSite::ActivateMe(IOleDocumentView *pView)
           {
           RECT                rc;
           IOleDocument*       pDoc;
           
           /*
           * If we're passed a NULL view pointer, then try to get one from
           * the document object (the object within us).
           */
           if (NULL==pView)
           {
           
           if (FAILED(m_pSite->m_pObj->QueryInterface(IID_IOleDocument
           , (void ** )&pDoc)))
           return E_FAIL;
           
           if (FAILED(pDoc->CreateView(m_pSite->m_pImpIOleIPSite
           , m_pSite->m_pIStream, 0, &pView)))            
           return E_OUTOFMEMORY;
           
           // Release doc pointer since CreateView is a good com method that addrefs
           pDoc->Release();
           }        
           else
           {
           //Make sure that the view has our client site
           pView->SetInPlaceSite(m_pSite->m_pImpIOleIPSite);
           
           //We're holding onto the pointer, so AddRef it.
           pView->AddRef();
           }
           
           
           /*
           * Activation steps, now that we have a view:
           *
           *  1.  Call IOleDocumentView::SetInPlaceSite (assume done since
           *      either the view already knows, or IOleDocument::CreateView
           *      has done it already.
           *
           *  2.  Call IOleDocumentView::SetRect to give a bunch of space to
           *      the view.  In our case this is the whole client area of
           *      the CPages window.  (Patron doesn't use SetRectComplex)
           *
           *  3.  Call IOleDocumentView::Show to make the thing visible.
           *
           *  4.  Call IOleDocumentView::UIActivate to finish the job.
           *
           */
           
           m_pSite->m_fDocObj=TRUE;
           m_pSite->m_pIOleDocView=pView;
           
           //This sets up toolbars and menus first    
           pView->UIActivate(TRUE);
           
           //Set the window size sensitive to new toolbars
           GetClientRect(m_pSite->m_hWnd, &rc);
           pView->SetRect(&rc);
           
           //Makes it all active
           pView->Show(TRUE);    
           return NOERROR;
           }
           *) 
            (#
               pDoc: ^IOleDocument;
               IID_IOleDocument: @IID;
               anIOleDocumentViewHolder: @IOleDocumentViewHolder
            do
               debugMsg
                 (#  do '--> IOleDocumentSite.ActivateMe'->putline #);
               ;
               (if pViewToActivate[] = none then
               (* If we're passed a NULL view pointer, then try to get one from
                the document object (the object within us). *)
                   IOleDocument_IID->IID_IOleDocument;
                   (m_pSite.m_pObj[],IID_IOleDocument[])->Query->pDoc[];
                   ;
                   pViewToActivate[]->anIOleDocumentViewHolder;
                   (m_pSite.m_pImpIOleIPSite[],m_pSite.m_pIStream[],0,
                    anIOleDocumentViewHolder[])->pDoc.CreateView;
                   ;
                   pDoc.Release
                else
                   (m_pSite.m_pImpIOleIPSite[])
                     ->
                       pViewToActivate.SetInPlaceSite
                       (* make sure that the view has our client site *) ;
                   pViewToActivate.AddRef
               if);
               ;
               true->m_pSite.m_fDocObj;
               pViewToActivate[]->m_pSite.m_pIOleDocView[];
               ;
               true
                 ->
                   pViewToActivate.UIActivate
                   (* this sets up toolbars and menus first *) ;
               ;
               (* Set the window size sensitive to new toolbars.
                GetClientRect(m_pSite->m_hWnd, &rc);
                pView->SetRect(&rc); *)
               ;
               true->pViewToActivate.Show;
               ;
               NOERROR->result
            #)
       #);
     CSite: IUnknown
       (#
          PRIVATE: (#  #);
          m_cRef: @integer (* originally ULONG *) ;
          m_dwID: @integer (* originally DWORD *) ;
          m_hWnd: @integer
          (* Client area window of parent.
           originally HWND *) ;
          ;
          m_pFR: ^CFrameType;
          ;
          m_fInitialized: (* Something here? *) @boolean;
          m_pIStorage:
          (* Storage for object.
           Originally LPSTORAGE *) ^IStorage;
          m_pIStream:
          (* Info stream for object.
           LPSTREAM *) ^IStream;
          ;
          m_pObj: ^IUnknown;
          m_pIOleObject: ^IOleObject;
          m_pIOleIPObject: ^IOleInPlaceObject;
          m_pIOleDocView: ^IOleDocumentView;
          ;
          m_fDocObj: (* Document object here? *) @boolean;
          ;
          m_pImpIOleClientSite: ^CImpOleClientSite;
          m_pImpIAdviseSink: ^CImpAdviseSink;
          m_pImpIOleIPSite: ^CImpOleInPlaceSite;
          m_pImpIOleDocumentSite: ^CImpOleDocumentSite;
          ;
          ;
          PROTECTED: (#  #);
          ObjectInitialize:
          (*
           /*
           * CSite::ObjectInitialize
           * (Protected)
           *
           * Purpose:
           *  Performs operations necessary after creating an object or
           *  reloading one from storage.
           *
           * Parameters:
           *  pObj            LPUNKNOWN of the object in this tenant.
           *  pFE             LPFORMATETC describing the graphic here.
           *  dwData          DWORD extra data.  If pFE->dwAspect==
           *                  DVASPECT_ICON then this is the iconic metafile.
           *
           * Return Value:
           *  BOOL            TRUE if the function succeeded, FALSE otherwise.
           */
           
           BOOL CSite::ObjectInitialize(LPUNKNOWN pObj)
           {
           HRESULT         hr;
           DWORD           dw;
           
           if (NULL==pObj)
           return FALSE;
           
           m_pObj=pObj;
           
           //We need an IOleObject most of the time, so get one here.
           m_pIOleObject=NULL;
           hr=pObj->QueryInterface(IID_IOleObject, (void ** )&m_pIOleObject);         
           
           /*
           * Follow up object creation with advises and so forth.  If
           * we cannot get IOleObject here, then we know we can't do
           * any IOleObject actions from here on--object is static.
           */
           if (FAILED(hr))
           return TRUE;
           
           //SetClientSite is critical for DocObjects
           m_pIOleObject->SetClientSite(m_pImpIOleClientSite);
           m_pIOleObject->Advise(m_pImpIAdviseSink, &dw);
           
           //This is to give PowerPoint a chance to initialize itself earlier
           OleRun(m_pIOleObject);
           return TRUE;
           }
           *)
            (#
               pObj: ^IUnknown;
               result: @boolean;
               hr: @HResult;
               dw: @int32uHolder (* DWORD* *) ;
               IID_IOleObject: @IID
            enter pObj[]
            do
               debugMsg
                 (#  do '--> CSite.ObjectInitialize'->putline #);
               return:
               (* When the C program says "return X", 
                we say "X->result; leave return". *)
                 (# 
                 do
                    (if pObj[] = none then false->result; leave return if);
                    pObj[]->m_pObj[];
                    ;
                    none
                      ->m_pIOleObject[]
                      (* We need an IOleObject most of the time, so get one here *)
                      ;
                    IOleObject_IID->IID_IOleObject;
                    (pObj[],IID_IOleObject[])->Query->m_pIOleObject[];
                    ;
                    m_pImpIOleClientSite[]
                      ->
                        m_pIOleObject.SetClientSite
                        (* SetClientSite is critical for DocObjects *) ;
                    (m_pImpIAdviseSink[],dw[])->m_pIOleObject.Advise;
                    ;
                    m_pIOleObject[]
                      ->OleRun
                      (* This is to give PowerPoint a chance to initialize itself earlier *)
                      ;
                    true->result;
                    leave return
                 #)
            exit result
            #);
          ;
          ;
          PUBLIC: (#  #);
          constructor:
          (*
           /*
           * CSite::CSite
           * CSite::~CSite
           *
           * Constructor Parameters:
           *  dwID            DWORD identifer for this site.
           *  hWnd            HWND of the window associated with the site
           *  pFR             PCFrame to the parent structure.
           */
           
           CSite::CSite(DWORD dwID, HWND hWnd, PCFrame pFR)
           {
           m_cRef=0;
           m_dwID=dwID;
           m_hWnd=hWnd;
           m_pFR=pFR;
           
           m_fInitialized=0;
           m_pIStorage=NULL;
           
           m_pObj=NULL;
           
           m_pIOleObject=NULL;
           m_pIOleIPObject=NULL;
           m_pIOleDocView=NULL;
           
           m_pImpIOleClientSite=NULL;
           m_pImpIAdviseSink=NULL;
           m_pImpIOleIPSite=NULL;
           m_pImpIOleDocumentSite=NULL;
           
           m_fDocObj=FALSE;
           return;
           }
           *)
            (# dwID,hWnd: @integer; pFR: ^CFrameType
            enter (dwID,hWnd,pFR[])
            do
               debugMsg
                 (#  do '--> CSite.Constructor'->putline #);
               0->m_cRef;
               dwID->m_dwID;
               hWnd->m_hWnd;
               pFR[]->m_pFR[];
               ;
               0->m_fInitialized;
               none ->m_pIStorage[];
               ;
               none ->m_pObj[];
               ;
               none ->m_pIOleObject[];
               none ->m_pIOleIPObject[];
               none ->m_pIOleDocView[];
               ;
               none ->m_pImpIOleClientSite[];
               none ->m_pImpIAdviseSink[];
               none ->m_pImpIOleIPSite[];
               none ->m_pImpIOleDocumentSite[];
               ;
               false->m_fDocObj
            #);
          destructor:
          (*
           CSite::~CSite(void)
           {
           //Object pointers cleaned up in Close.
           
           //We delete our own interfaces since we control them
           DeleteInterfaceImp(m_pImpIOleDocumentSite);
           DeleteInterfaceImp(m_pImpIOleIPSite);
           DeleteInterfaceImp(m_pImpIAdviseSink);
           DeleteInterfaceImp(m_pImpIOleClientSite);
           return;
           }
           *)
            (# pt: ^IUnknown
            do
               debugMsg
                 (#  do '--> CSite.Destructor'->putline #);
               m_pImpIOleDocumentSite[]->pt[];
               none ->m_pImpIOleDocumentSite[];
               (if pt[] <> none then pt.Release if);
               ;
               m_pImpIOleIPSite[]->pt[];
               none ->m_pImpIOleIPSite[];
               (if pt[] <> none then pt.Release if);
               ;
               m_pImpIAdviseSink[]->pt[];
               none ->m_pImpIAdviseSink[];
               (if pt[] <> none then pt.Release if);
               ;
               m_pImpIOleClientSite[]->pt[];
               none ->m_pImpIOleClientSite[];
               (if pt[] <> none then pt.Release if)
            #);
          QueryInterface::<
          (*
           STDMETHODIMP CSite::QueryInterface(REFIID riid, void **ppv)
           {
           *ppv=NULL;
           
           if (IID_IUnknown==riid)
           *ppv=this;
           
           if (IID_IOleClientSite==riid)
           *ppv=m_pImpIOleClientSite;
           
           if (IID_IAdviseSink==riid)
           *ppv=m_pImpIAdviseSink;
           
           if (IID_IOleWindow==riid || IID_IOleInPlaceSite==riid)
           *ppv=m_pImpIOleIPSite;
           
           if (IID_IOleDocumentSite==riid)
           *ppv=m_pImpIOleDocumentSite;
           
           if (NULL!=*ppv)
           {
           ((LPUNKNOWN)*ppv)->AddRef();
           return NOERROR;
           }
           
           return ResultFromScode(E_NOINTERFACE);
           }
           *) 
            (# riidText: ^text; tempGUID: @GUID
            do
               debugMsg
                 (#  do '--> CSite.QueryInterface'->putline #);
               ;
               riid[]->tempGUID.binary[];
               tempGUID.getAsText->riidText[];
               '==> riid='->puttext;
               riidText[]->putline;
               none ->ppvObject;
               ;
               (if IUnknown_IID->riidText.equalNCS then
                   THIS(IUnknown)[]->ppvObject
               if);
               (if IOleClientSite_IID->riidText.equalNCS then
                   m_pImpIOleClientSite[]->ppvObject
               if);
               (if IAdviseSink_IID->riidText.equalNCS then
                   m_pImpIAdviseSink[]->ppvObject
               if);
               (if IOleWindow_IID->riidText.equalNCS then
                   m_pImpIOleIPSite[]->ppvObject
               if);
               (if IOleDocumentSite_IID->riidText.equalNCS then
                   m_pImpIOleDocumentSite[]->ppvObject
               if);
               ;
               (if ppvObject <> none then
                   (ppvObject).AddRef; NOERROR->result
                else
                   E_NOINTERFACE->result
               if)
            #);
          AddRef::<
          (*
           STDMETHODIMP_(ULONG) CSite::AddRef(void)
           {
           return ++m_cRef;
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do '--> CSite.AddRef'->putline #);
               m_cRef+1->m_cRef
            exit m_cRef
            #);
          Release::<
          (*
           STDMETHODIMP_(ULONG) CSite::Release(void)
           {
           if (0!=--m_cRef)
           return m_cRef;
           
           delete this;
           return 0;
           }
           *) 
            (# 
            do
               debugMsg
                 (#  do '--> CSite.Release'->putline #);
               m_cRef-1->m_cRef
            exit m_cRef
            #);
          ;
          Create:
          (*
           /*
           * CSite::Create
           *
           * Purpose:
           *  Asks the site to instantiate an object given a filename.
           *  This goes through OleCreateFromFile and will either create
           *  an embedded object or a package (embedded) object.  When
           *  activated, this will either launch the app and activate
           *  as a DocObject, launch the app and open the file, or fail
           *  because no app can open the file.
           *
           * Parameters:
           *  pszFile         LPTSTR of the file from which to create the object.
           *  pIStorage       IStorage * of the parent storage in which we're
           *                  to create an IStorage for the new object.
           *  dwID            DWORD identifier for this site.
           *
           * Return Value:
           *  BOOL            Result of the creation.
           */
           
           BOOL CSite::Create(LPTSTR pszFile, IStorage *pIStorage)
           {
           HRESULT             hr=E_FAIL;
           LPUNKNOWN           pObj;
           
           //Create a new storage for this object (sets m_pIStorage)
           if (!CreateStorage(pIStorage))
           return FALSE;
           
           //Now create an object from the file
           #ifdef UNICODE    
           hr=OleCreateFromFile(CLSID_NULL, pszFile, IID_IUnknown
           , OLERENDER_NONE, NULL, NULL, m_pIStorage, (void ** )&pObj);
           #else
           OLECHAR     szFile[512];    //Assumption on string length
           
           MultiByteToWideChar(CP_ACP, 0, pszFile, -1, szFile, 512);    
           hr=OleCreateFromFile(CLSID_NULL, szFile, IID_IUnknown
           , OLERENDER_NONE, NULL, NULL, m_pIStorage, (void ** )&pObj);
           #endif
           
           //If creation didn't work, get rid of the element Open created.
           if (FAILED(hr))
           {
           Destroy(pIStorage);
           return FALSE;
           }
           
           //We don't get the size if PatronObject data was seen already.
           if (!ObjectInitialize(pObj))
           {
           Destroy(pIStorage);
           return FALSE;
           }
           
           m_fInitialized=TRUE;
           return TRUE;
           }
           *)
            (#
               filename: ^text;
               pIStorage: ^IStorage;
               result: @boolean;
               hr: @HResult;
               pObj: ^IUnknown;
               IID_IUnknown: @IID;
               anIUnknownHolder: @IUnknownHolder;
               awtext: @bstr
            enter (filename[],pIStorage[])
            do
               debugMsg
                 (#  do '--> CSite.Create'->putline #);
               E_FAIL->hr;
               return:
               (* when the C program says "return something",
                we say "something->result; leave return" *)
                 (# 
                 do
                    pIStorage[]->CreateStorage
                      ->result
                      (* Create a new storage for this object (sets m_pIStorage) *)
                      ;
                    (if result = false then
                        'CSite.Create: CreateStorage failed'->putline;
                        leave return
                    if);
                    ;
                    IUnknown_IID->IID_IUnknown;
                    filename[]->awtext.setText;
                    pObj[]->anIUnknownHolder;
                    ((getGUID_NULL).binary[],awtext.wcharptr,
                     IID_IUnknown.binary[],OLERENDER_NONE,0 (* lpFormatEtc *) ,
                     none ,m_pIStorage[],anIUnknownHolder[])->OleCreateFromFile
                      ->hr;
                    anIUnknownHolder->pObj[];
                    (if hr.failed then
                        'CSite.Create: OleCreateFromFile failed'->putline
                    if);
                    ;
                    (if hr.failed then
                    (* If creation didn't work, get rid of the element Open created. *)
                        pIStorage[]->Destroy; false->result; leave return
                    if);
                    ;
                    (if not (pObj[]->ObjectInitialize) then
                    (* We don't get the size if PatronObject data was seen already. *)
                        pIStorage[]->Destroy; false->result; leave return
                    if);
                    ;
                    true->m_fInitialized;
                    true->result;
                    leave return
                 #)
            exit result
            #);
          CreateStorage:
          (*
           /*
           * CSite::CreateStorage
           *
           * Purpose:
           *  Creates an sub-storage within a given parent storage,
           *  setting m_pIStorage.
           *
           * Parameters:
           *  pIStorage       IStorage * of the parent storage
           *
           * Return Value:
           *  BOOL            TRUE if creation succeeds, FALSE otherwise.
           */
           
           BOOL CSite::CreateStorage(IStorage *pIStorage)
           {
           HRESULT     hr;
           DWORD       dwMode=STGM_TRANSACTED | STGM_READWRITE
           | STGM_SHARE_EXCLUSIVE;
           TCHAR       szName[32];
           
           if (NULL==pIStorage)
           return FALSE;
           
           /*
           * Attempt to open the storage under this ID.  If there is
           * none, then create it.  In either case we end up with an
           * IStorage that we either save in pPage or release.
           */
           wsprintf(szName, TEXT("Site %lu"), m_dwID);
           
           #ifdef UNICODE
           hr=pIStorage->CreateStorage(szName, dwMode, 0, 0, &m_pIStorage);
           #else
           OLECHAR  szwName[32];
           MultiByteToWideChar(CP_ACP, 0, szName, -1, szwName, 32);    
           hr=pIStorage->CreateStorage(szwName, dwMode, 0, 0, &m_pIStorage);
           #endif
           
           if (FAILED(hr))
           return FALSE;
           
           //Create stream for the object; name is irrelevant
           dwMode=STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
           #ifdef UNICODE
           hr=m_pIStorage->CreateStream(TEXT("\003DocObjInfo"), dwMode, 0, 0
           , &m_pIStream);
           #else    
           MultiByteToWideChar(CP_ACP, 0, "\003DocObjInfo", -1, szwName, 32);    
           hr=m_pIStorage->CreateStream(szwName, dwMode, 0, 0, &m_pIStream);
           #endif
           
           //If we failed to create a stream in the file, do it in memory
           if (FAILED(hr))
           {
           if (FAILED(CreateStreamOnHGlobal(NULL, TRUE, &m_pIStream)))
           return FALSE;
           }
           
           //Create interface implementations
           m_pImpIOleClientSite=new CImpIOleClientSite(this, this);
           m_pImpIAdviseSink=new CImpIAdviseSink(this, this);
           m_pImpIOleIPSite=new CImpIOleInPlaceSite(this, this);
           m_pImpIOleDocumentSite=new CImpIOleDocumentSite(this, this);
           
           if (NULL==m_pImpIOleClientSite || NULL==m_pImpIAdviseSink
           || NULL==m_pImpIOleIPSite || NULL==m_pImpIOleDocumentSite)
           return FALSE;
           
           return TRUE;
           }
           *)
            (#
               result: @boolean;
               pIStorage: ^IStorage (* pointer to the parent storage *) ;
               hr: @HRESULT;
               dwMode: @int32uHolder (* DWORD* *) ;
               szName: @text;
               szName2: [0] @char (* ^text NYI *) (* OLECHAR* *) ;
               anIStorageHolder: @IStorageHolder;
               anIStreamHolder: @IStreamHolder;
               awtext: @bstr
            enter pIStorage[]
            do
               debugMsg
                 (#  do '--> CSite.CreateStorage'->putline #);
               (STGM_TRANSACTED %Bor STGM_READWRITE %Bor STGM_SHARE_EXCLUSIVE)
                 ->dwMode;
               ;
               return:
               (* When the C program says "return X", 
                we say "X->result; leave return". *)
                 (# 
                 do
                    (if pIStorage[] = none then
                        'CSite.CreateStorage: pIStorage[]=none'->putline;
                        false->result;
                        leave return
                    if);
                    ;
                    'Site '
                      ->szName (* wsprintf(szName, TEXT("Site %lu"), m_dwID); *)
                      ;
                    m_dwID->szName.putint;
                    szName->szName2;
                    ;
                    m_pIStorage[]->anIStorageHolder;
                    (szName2,dwMode,0,0,anIStorageHolder[])
                      ->pIStorage.CreateStorage->hr;
                    anIStorageHolder->m_pIStorage[];
                    (if hr.failed then false->result; leave return if);
                    ;
                    (STGM_DIRECT %Bor STGM_READWRITE %Bor STGM_SHARE_EXCLUSIVE)
                      ->dwMode
                      (* Create stream for the object; name is irrelevant *) ;
                    'DocObjInfo'->awtext.settext;
                    (awtext.wcharptr,dwMode,0,0,anIStreamHolder[])
                      ->m_pIStorage.CreateStream->hr;
                    anIStreamHolder->m_pIStream[];
                    (if hr.failed then
                    (* If we failed to create a stream in the file, do it in memory *)
                        'CreateStreamOnHGlobal kald'->putline
                    if);
                    ;
                    &CImpOleClientSite[]
                      ->m_pImpIOleClientSite[]
                      (* Create interface implementations *) ;
                    (THIS(CSite)[],THIS(IUnknown)[])
                      ->m_pImpIOleClientSite.constructor;
                    &CImpAdviseSink[]->m_pImpIAdviseSink[];
                    (THIS(CSite)[],THIS(IUnknown)[])
                      ->m_pImpIAdviseSink.constructor;
                    &CImpOleInPlaceSite[]->m_pImpIOleIPSite[];
                    (THIS(CSite)[],THIS(IUnknown)[])
                      ->m_pImpIOleIPSite.constructor;
                    &CImpOleDocumentSite[]->m_pImpIOleDocumentSite[];
                    (THIS(CSite)[],THIS(IUnknown)[])
                      ->m_pImpIOleDocumentSite.constructor;
                    ;
                    (if (m_pImpIOleClientSite[] = none ) or
                    (m_pImpIAdviseSink[] = none ) or
                    (m_pImpIOleIPSite[] = none ) or
                    (m_pImpIOleDocumentSite[] = none ) then
                        false->result; leave return
                    if);
                    ;
                    true->result;
                    leave return
                 #)
            exit result
            #);
          Close:
          (*
           /*
           * CSite::Close
           *
           * Purpose:
           *  Possibly commits the storage, then releases it, afterwards
           *  frees alls the object pointers.
           *
           * Parameters:
           *  fCommit         BOOL indicating if we're to commit.
           *
           * Return Value:
           *  None
           */
           
           void CSite::Close(BOOL fCommit)
           {
           //OnInPlaceDeactivate releases this pointer.
           if (NULL!=m_pIOleIPObject)
           m_pIOleIPObject->InPlaceDeactivate();
           
           ReleaseInterface(m_pIOleDocView);
           
           if (NULL!=m_pIOleObject)
           {
           m_pIOleObject->Close(fCommit
           ? OLECLOSE_SAVEIFDIRTY : OLECLOSE_NOSAVE);
           ReleaseInterface(m_pIOleObject);
           }
           
           ReleaseInterface(m_pObj);
           ReleaseInterface(m_pIStream);
           ReleaseInterface(m_pIStorage);
           
           return;
           }
           *)
            (# fCommit: @boolean
            enter fCommit
            do
               debugMsg
                 (#  do '--> CSite.Close'->putline #);
               (if m_pIOleIPObject[] <> none then
                   m_pIOleIPObject.InPlaceDeactivate
               if);
               ;
               ReleaseInterface: (* expanded macro *)
                 (# pt: ^IUnknown
                 do
                    m_pIOleDocView[]->pt[];
                    none ->m_pIOleDocView[];
                    (if pt[] <> none then pt.Release if)
                 #);
               ;
               (if m_pIOleObject[] <> none then
                   (if fCommit then
                       OLECLOSE_SAVEIFDIRTY->m_pIOleObject.close
                    else
                       OLECLOSE_NOSAVE->m_pIOleObject.close
                   if);
                   ReleaseInterface: (* expanded macro *)
                     (# pt: ^IUnknown
                     do
                        m_pIOleObject[]->pt[];
                        none ->m_pIOleObject[];
                        (if pt[] <> none then pt.Release if)
                     #)
               if);
               ;
               ReleaseInterface: (* expanded macro *)
                 (# pt: ^IUnknown
                 do
                    m_pObj[]->pt[];
                    none ->m_pObj[];
                    (if pt[] <> none then pt.Release if)
                 #);
               ReleaseInterface: (* expanded macro *)
                 (# pt: ^IUnknown
                 do
                    m_pIStream[]->pt[];
                    none ->m_pIStream[];
                    (if pt[] <> none then pt.Release if)
                 #);
               ReleaseInterface: (* expanded macro *)
                 (# pt: ^IUnknown
                 do
                    m_pIStorage[]->pt[];
                    none ->m_pIStorage[];
                    (if pt[] <> none then pt.Release if)
                 #)
            #);
          Update:
          (*
           /*
           * CSite::Update
           *
           * Purpose:
           *  Forces a commit on the object's storage
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  None
           */
           
           void CSite::Update(void)
           {
           LPPERSISTSTORAGE    pIPS;
           
           if (NULL!=m_pIStorage)
           return;
           
           m_pObj->QueryInterface(IID_IPersistStorage, (void ** )&pIPS);
           OleSave(pIPS, m_pIStorage, TRUE);
           pIPS->SaveCompleted(NULL);
           pIPS->Release();
           
           m_pIStorage->Commit(STGC_DEFAULT);
           return;
           }
           *)
            (# IID_IPersistStorage: @IID; pIPS: ^IPersistStorage
            do
               debugMsg
                 (#  do '--> CSite.Update'->putline #);
               return:
                 (# 
                 do
                    (if m_pIStorage[] <> none then leave return if);
                    ;
                    IPersistStorage_IID->IID_IPersistStorage;
                    (m_pObj[],IID_IPersistStorage[])->Query->pIPS[];
                    (pIPS[],m_pIStorage[],true)->OleSave;
                    none ->pIPS.SaveCompleted;
                    pIPS.Release;
                    ;
                    STGC_DEFAULT->m_pIStorage.Commit;
                    leave return
                 #)
            #);
          Destroy:
          (*
           /*
           * CSite::Destroy
           *
           * Purpose:
           *  Removes this storage from the parent storage.  The caller should
           *  eventually delete this CSite object to free the object herein.
           *  Nothing is committed when being destroyed.
           *
           * Parameters:
           *  pIStorage       IStorage * of the parent
           *
           * Return Value:
           *  None
           */
           
           void CSite::Destroy(IStorage *pIStorage)
           {
           TCHAR     szName[32];
           
           if (NULL==pIStorage)
           return;
           
           if (NULL!=m_pObj)
           Close(FALSE);
           
           wsprintf(szName, TEXT("Site %lu"), m_dwID);
           #ifdef UNICODE
           pIStorage->DestroyElement(szName);
           #else
           OLECHAR  szwName[32];
           MultiByteToWideChar(CP_ACP, 0, szName, -1, szwName, 512);    
           pIStorage->DestroyElement(szwName);    
           #endif
           return;
           }
           *)
            (# pIStorage: ^IStorage
            enter pIStorage[]
            do
               debugMsg
                 (#  do '--> CSite.Destroy'->putline #);
               return:
                 (#
                    szName2: @text;
                    szName: [0] @char (* ^text NYI *) (* OLECHAR* *)
                 do
                    (if pIStorage[] = none then leave return if);
                    ;
                    (if m_pObj[] <> none then false->close if);
                    ;
                    'Site '->szName2;
                    m_dwID->szName2.putint;
                    szName2->szName;
                    szName->pIStorage.DestroyElement;
                    ;
                    leave return
                 #)
            #);
          rc: @struct_tagRECT;
          Activate:
          (*
           /*
           * CSite::Activate
           *
           * Purpose:
           *  Activates a verb on the object living in the site.
           *
           * Parameters:
           *  iVerb           LONG of the verb to execute.
           *
           * Return Value:
           *  None
           */
           
           void CSite::Activate(LONG iVerb)
           {
           CHourglass *pHour;
           RECT        rc;
           
           pHour=new CHourglass;
           
           GetClientRect(m_hWnd, &rc);
           m_pIOleObject->DoVerb(iVerb, NULL, m_pImpIOleClientSite, 0
           , m_hWnd, &rc);
           
           delete pHour;
           return;
           }
           *)
            (# iVerb: @int32; aint32holder: @int32Holder
            enter iVerb
            do
               debugMsg
                 (#  do '--> CSite.Activate'->putline #);
               m_hWnd->aint32holder;
               (aint32holder[],rc[])->GetClientRect;
               aint32holder->m_hWnd;
               ;
               m_hWnd->Aint32holder;
               (iVerb,none ,m_pImpIOleClientSite[],0,aint32holder[],rc[])
                 ->m_pIOleObject.DoVerb;
               aint32holder->m_hWnd
            #);
          UpdateObjectRects:
          (*
           /*
           * CSite::UpdateObjectRects
           *
           * Purpose:
           *  Informs the site that the client area window was resized and
           *  that the site needs to also tell the DocObject of the resize.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  None
           */
           
           void CSite::UpdateObjectRects(void)
           {
           RECT    rc;
           
           if (NULL==m_pIOleDocView)
           return;
           
           GetClientRect(m_hWnd, &rc);
           m_pIOleDocView->SetRect(&rc);
           return;
           }
           *)
            (# 
            do
               debugMsg
                 (#  do '--> CSite.UpdateObjectRects'->putline #);
               return:
                 (# 
                 do
                    (if m_pIOleDocView[] = none then leave return if);
                    ;
                    'GetClientRect(m_hWnd, &rc)'->putline;
                    'm_pIOleDocView->SetRect(&rc)'->putline
                 #)
            #)
       #);
     ;
     CFrameType:
       (#
          PROTECTED: (#  #);
          m_hInst: (* Task instance.
                    =HINSTANCE *) (#  exit uienvHInstance #);
          m_hWnd: (* Window handle of the window.
                   =HWND *)
            (# handle: @integer
            do
               (if mainWindow[] <> none then
                   mainWindow.InterfaceObjectID->handle
                else
                   117->handle
               if)
            exit handle
            #);
          mainWindowType: window
            (#
               open::< 
                 (# 
                 do (486,338)->size; clientCanvas.open; 'Doc Framer'->title
                 #);
               eventHandler::< 
                 (# onAboutToClose::<  (#  do onExit #) #);
               menubarType:: 
                 (#
                    fileMenu: @menu
                      (#
                         openItem: @menuItem
                           (#
                              eventHandler:: 
                                (# onSelect::  (#  do onOpen;  #);  #);
                              open::  (#  do '&Open'->name; 'o'->key #)
                           #);
                         closeItem: @menuItem
                           (#
                              eventHandler:: 
                                (# onSelect::  (#  do onClose #);  #);
                              open::  (#  do '&Close'->name; 'c'->key #)
                           #);
                         exitItem: @menuItem
                           (#
                              eventHandler:: 
                                (# onSelect::  (#  do onExit #);  #);
                              open::  (#  do 'E&xit'->name; 'x'->key;  #)
                           #);
                         sep1: @separator;
                         open:: 
                           (# 
                           do
                              '&File'->name;
                              openItem.open;
                              openItem[]->append;
                              closeItem.open;
                              closeItem[]->append;
                              sep1.open;
                              sep1[]->append;
                              exitItem.open;
                              exitItem[]->append
                           #)
                      #);
                    open::< 
                      (#  do fileMenu.open; fileMenu[]->append; INNER #)
                 #);
               clientCanvas: @canvas
                 (#
                    open::< 
                      (# 
                      do
                         4->border.style;
                         true->border.visible;
                         (449,287)->size;
                         (18,32)->position;
                         
                      #)
                 #);
               ;
               onOpen:<
                 (# filename: ^text; fOK: @boolean
                 do
                    fileSelectionDialog (#  do '*'->filter[] #)->filename[];
                    (if filename[] <> none then
                        filename[]->CreateObject->fOK
                     else
                    (* Cancelled *)
                        
                    if)
                 #);
               onClose:< (#  do THIS(CFrameType).close #);
               onExit:<
                 (#  do 'PostMessage(hWnd, WM_CLOSE, 0, 0L)'; terminate #)
            #);
          mainWindow: ^window;
          m_cRef: (* =ULONG *) @integer;
          ;
          m_hInstPrev: (* WinMain parameters.
                        =HINSTANCE *) @integer;
          m_pszCmdLine: (* =LPTSTR *) @ (#  #);
          m_nCmdShow: (* =int *) @integer;
          ;
          m_phMenu: (* Popup menu handles.
                     =HMENU* *) @integer;
          m_hAccel: (* Accelerators.
                     =HACCEL *) @integer;
          m_hWndClient: (* Client area window.
                         =HWND *) @integer;
          ;
          m_fInitialized: (* OleInitialize called?.
                           =BOOL *) @boolean;
          m_pIStorage:
          (* Temp file for all needs.
           =IStorage* *) ^IStorage;
          m_dwIDCounter: (* For site IDs.
                          =DWORD *) @integer;
          ;
          m_hMenuOrg: (* Original menu.
                       =HMENU *) @integer;
          m_hMenuTop: (* Currently shown menu.
                       =HMENU *) @integer;
          m_hMenuHelp: (* Special Help menu.
                        =HMENU *) @integer;
          m_fUsingOurHelp: (* Help menu in use?
                            =BOOL *) @boolean;
          m_fInObjectHelp: (* Object's menu found?
                            =BOOL *) @boolean;
          m_fOurMenuShowing: (* Our menu up?
                              =BOOL *) @boolean;
          ;
          m_fHaveObject:
          (* For menu enabling.
           =BOOL *) @boolean;
          m_hWndObj: (* UI Active object.
                      =HWND *) @integer;
          ;
          m_pSite: (* Site holding object.
                    =class CSite * *) ^CSite;
          m_bwIP:
          (* In/place tool allocations.
           =BORDERWIDTHS *) @integer;
          m_fInContextHelp: (* In context help mode?
                             =BOOL *) @boolean;
          ;
          m_pIOleIPActiveObject: (* =IOleInPlaceActiveObject* *)
            ^IOleInPlaceActiveObject;
          ;
          ;
          PROTECTED_: (#  #);
          RegisterAllClasses:
          (*
           /*
           * CFrame::RegisterAllClasses
           *
           * Purpose:
           *  Registers all classes used in this application.
           *
           * Return Value:
           *  BOOL            TRUE if registration succeeded, FALSE otherwise.
           */
           
           BOOL CFrame::RegisterAllClasses(void)
           {
           WNDCLASS        wc;
           
           //Field that are the same for all windows.
           wc.style         = CS_HREDRAW | CS_VREDRAW;
           wc.hInstance     = m_hInst;
           wc.cbClsExtra    = 0;
           
           //Register the Frame window
           wc.lpfnWndProc   = FrameWndProc;
           wc.cbWndExtra    = CBFRAMEWNDEXTRA;
           wc.hIcon         = LoadIcon(m_hInst, TEXT("Icon"));
           wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
           wc.hbrBackground = NULL;
           wc.lpszMenuName  = MAKEINTRESOURCE(IDR_MENU);
           wc.lpszClassName = SZCLASSFRAME;
           
           if (!RegisterClass(&wc))
           return FALSE;
           
           
           //Register the do-nothing Client window
           wc.lpfnWndProc   = ClientWndProc;
           wc.cbWndExtra    = CBCLIENTWNDEXTRA;
           wc.hIcon         = NULL;
           wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
           wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
           wc.lpszMenuName  = NULL;
           wc.lpszClassName = SZCLASSCLIENT;
           
           if (!RegisterClass(&wc))
           return FALSE;
           
           return TRUE;
           }
           *)
            (# result: @boolean
            do
               debugMsg
                 (# 
                 do '--> CFrame.RegisterAllClasses (not implemented)'->putline
                 #)
            exit result
            #);
          CreateObject:
          (*
           /*
           * CFrame::CreateObject
           *
           * Purpose:
           *  Creates a site and has it create an object based on a filename.
           *
           * Parameters:
           *  pszFile         LPTSTR pointing to the filename from which to
           *                  create the object.
           *
           * Return Value:
           *  BOOL            TRUE if successful, FALSE otherwise.
           */
           
           BOOL CFrame::CreateObject(LPTSTR pszFile)
           {    
           m_pSite=new CSite(++m_dwIDCounter, m_hWndClient, this);
           
           if (NULL==m_pSite)
           return FALSE;
           
           m_pSite->AddRef();  //So we can free with Release
           
           /*
           * Now tell the site to create an object in it using the filename
           * and the storage we opened.  The site will create a sub-storage
           * for the doc object's use.
           */
           if (!m_pSite->Create(pszFile, m_pIStorage))
           return FALSE;
           
           m_fHaveObject=TRUE;
           
           //We created the thing, now activate it with "Show"
           m_pSite->Activate(OLEIVERB_SHOW);
           
           //Force repaint to show "have object" message
           InvalidateRect(m_hWndClient, NULL, TRUE);
           UpdateWindow(m_hWndClient);
           return TRUE;        
           }
           *)
            (# filename: ^text; result: @boolean
            enter filename[]
            do
               debugMsg
                 (# 
                 do
                    '--> CFrame.CreateObject (filename='->puttext;
                    filename[]->puttext;
                    ')'->putline
                 #);
               &CSite[]->m_pSite[];
               m_dwIDCounter+1->m_dwIDCounter;
               (m_dwIDCounter,m_hWndClient,THIS(CFrameType)[])
                 ->m_pSite.constructor;
               m_pSite.AddRef;
               ;
               (filename[],m_pIStorage[])->m_pSite.Create->result;
               (if result then
                   true->m_fHaveObject;
                   OLEIVERB_SHOW->m_pSite.Activate;
                   'Sjove kommandoer: InvalidateRect og updateWindow'->putline
               if)
            exit result
            #);
          ResizeClientWindow:
          (*
           /*
           * CFrame::ResizeClientWindow
           *
           * Purpose:
           *Resizes the client-area window according to current toolbar sizes
           *  and the frame window size.
           *
           * Parameters:
           *x,y,cx,cyUINT origin and dimensions of the window
           *
           * Return Value:
           *None
           */
           
           void CFrame::ResizeClientWindow(UINT x, UINT y, UINT cx, UINT cy)
           {
           SetWindowPos(m_hWndClient, NULL, x, y, cx, cy    
           , SWP_NOZORDER | SWP_NOACTIVATE);
           
           //Tell the site to tell the object.
           if (NULL!=m_pSite)
           m_pSite->UpdateObjectRects();
           
           return;
           }
           *)
            (# 
            do debugMsg (#  do '--> CFrame.ResizeClientWindow'->putline #)
            #);
          ;
          ;
          PUBLIC_: (#  #);
          Instance:
          (*
           inline HINSTANCE Instance(void)
           { return m_hInst; }
           *) (#  exit m_hInst #);
          Window_:
          (*
           inline HWND      Window(void)
           { return m_hWnd; }        
           *) (#  exit m_hWnd #);
          Accelerators:
          (*
           inline HACCEL    Accelerators(void)
           { return m_hAccel; }        
           *) (#  exit m_hAccel #);
          Init:
          (*
           /*
           * CFrame::Init
           *
           * Purpose:
           *  Initializer for a CFrame object containing anything prone to
           *  failure.
           *
           * Parameters:
           *  cMenus          UINT number of menus on the frame
           *  x, y, cx, cy    int location and size of frame window 
           *
           * Return Value:
           *  BOOL            TRUE if initialization succeeded, FALSE
           *                  otherwise. If FALSE is returned, the caller must
           *                  guarantee that the destructor is called promptly
           *                  to insure cleanup.
           */
           
           BOOL CFrame::Init(UINT cMenus, int x, int y, int cx, int cy)
           {
           HMENU               hMenu;
           UINT                uTemp;
           RECT                rc;
           
           //1.  Initialize OLE
           if (SUCCEEDED(OleInitialize(NULL)))
           m_fInitialized=TRUE;
           else
           return FALSE;
           
           
           //2.  Register window classes
           if (NULL==m_hInstPrev)
           {
           if (!RegisterAllClasses())
           return FALSE;
           }
           
           
           //3.  Create the main window and client-area window
           m_hWnd=CreateWindow(SZCLASSFRAME, TEXT("DocObject Framer")
           , WS_MINIMIZEBOX | WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN
           , x, y, cx, cy, NULL, NULL, m_hInst, this);
           
           if (NULL==m_hWnd)
           return FALSE;
           
           GetClientRect(m_hWnd, &rc);
           
           m_hWndClient=CreateWindow(SZCLASSCLIENT, SZCLASSCLIENT
           , WS_CHILD | WS_CLIPCHILDREN | WS_VISIBLE | WS_CLIPSIBLINGS
           , rc.left, rc.top, rc.right-rc.left
           , rc.bottom-rc.top, m_hWnd, NULL, m_hInst, this);
           
           if (NULL==m_hWndClient)
           return FALSE;
           
           //4. Allocate menu array for use with in-place menu merging.
           m_phMenu=new HMENU[cMenus];
           hMenu=GetMenu(m_hWnd);
           m_hMenuOrg=hMenu;
           
           for (uTemp=0; uTemp < cMenus; uTemp++)
           m_phMenu[uTemp]=GetSubMenu(hMenu, uTemp);
           
           //Also load the special help menu
           m_hMenuHelp=LoadMenu(m_hInst
           , MAKEINTRESOURCE(IDR_MENUHELP));
           
           //5.  Load accelerators
           m_hAccel=LoadAccelerators(m_hInst
           , MAKEINTRESOURCE(IDR_ACCELERATORS));
           
           if (NULL==m_hAccel)
           return FALSE;
           
           
           //6.  Make us all visible.
           ShowWindow(m_hWnd, m_nCmdShow);
           UpdateWindow(m_hWnd);
           
           
           /*
           * 7.  Create a temp file for all embedded files.  Note that in this
           *     sample we don't save any changes to DocObjects because we 
           *     don't manage any storage directly.
           */  
           if (FAILED(StgCreateDocfile(NULL, STGM_TRANSACTED | STGM_READWRITE
           | STGM_SHARE_EXCLUSIVE | STGM_CREATE| STGM_DELETEONRELEASE
           , 0, &m_pIStorage)))
           return FALSE;
           
           return TRUE;
           }
           *)
            (#
               result: @boolean;
               hr: @HRESULT;
               anIStorageHolder: @IStorageHolder;
               docFileMode: @integer
            do
               debugMsg
                 (#  do '--> CFrame.Init'->putline #);
               return:
                 (# 
                 do (* 1. Initialize OLE *)
                    0->OleInitialize->hr;
                    (if hr.succeeded then
                        true->m_fInitialized
                     else
                        false->result; leave return
                    if);
                    ;
                    (* 2. Register window classes *)
                    (if m_hInstPrev = 0 then
                        (if not RegisterAllClasses then
                            false->result; leave return
                        if)
                    if);
                    ;
                    (* 3. Create the main window and client-area window *)
                    &MainWindowType[]->mainWindow[];
                    mainWindow.open;
                    ;
                    (* 4. Allocate menu array for use with in-place menu merging.
                     5. Load accelerators
                     6. Make us all visible *)
                    ;
                    (* 7. Create a temp file for all embedded files. Note that in this sample
                     we don't save any changes to DocObjects because we don't
                     manage any storage directly. *)
                    STGM_TRANSACTED %Bor STGM_READWRITE
                    %Bor
                      STGM_SHARE_EXCLUSIVE
                    %Bor
                      STGM_CREATE
                    %Bor
                      STGM_DELETEONRELEASE->docFileMode;
                    (none ,docFileMode,0,anIStorageHolder[])->StgCreateDocfile
                      ->hr;
                    anIStorageHolder->m_pIStorage[];
                    (if m_pIStorage[] = none then
                        'CFrame.Init: StgCreateDocFile failed'->putline
                    if);
                    (if hr.failed then false->result; leave return if);
                    ;
                    true->result;
                    leave return
                 #)
            exit result
            #);
          Close:
          (*
           /*
           * CFrame::Close
           *
           * Purpose:
           *  Handles File/Close by freeing the object and resetting the
           *  application state.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  None
           */
           
           void CFrame::Close(void)
           {    
           RECTrc;
           
           if (NULL!=m_pSite)
           {
           CSite *pSite=m_pSite;        //Prevents reentry
           m_pSite=NULL;
           
           pSite->Close(FALSE);         //Frees the object
           pSite->Destroy(m_pIStorage); //Cleans up the storage
           pSite->Release();            //Frees the site        
           }
           
           m_fHaveObject=FALSE;
           SetRect(&m_bwIP, 0, 0, 0, 0);
           
           GetClientRect(m_hWnd, &rc);
           ResizeClientWindow(rc.left, rc.top, rc.right-rc.left
           , rc.bottom-rc.top);
           
           //Force repaint to remove "have object" message
           InvalidateRect(m_hWndClient, NULL, TRUE);
           UpdateWindow(m_hWndClient);
           
           return;        
           }
           *)
            (# pSite: ^CSite
            do
               debugMsg
                 (#  do '--> CFrame.Close'->putline #);
               (if m_pSite[] <> none then
                   m_pSite[]->pSite[] (* Prevents reentry *) ;
                   none ->m_pSite[];
                   ;
                   false->pSite.close (* Frees the object *) ;
                   m_pIStorage[]->pSite.destroy (* cleans up the storage *) ;
                   pSite.release (* frees the site *)
               if);
               ;
               false->m_fHaveObject
            #);
          ;
          ;
          PUBLIC: (* se framer.h *) (#  #);
          constructor:
          (*
           /*
           * CFrame::CFrame
           * CFrame::~CFrame
           *
           * Constructor Parameters:
           *  hInst           HINSTANCE from WinMain
           *  hInstPrev       HINSTANCE from WinMain
           *  pszCmdLine      LPSTR from WinMain
           *  nCmdShow        int from WinMain
           */
           
           CFrame::CFrame(HINSTANCE hInst, HINSTANCE hInstPrev
           , LPSTR pszCmdLine, int nCmdShow)    
           {
           m_hInst=hInst;
           m_hWnd=NULL;
           m_hInstPrev=hInstPrev;
           m_nCmdShow=nCmdShow;
           
           m_phMenu=NULL;
           m_hAccel=NULL;
           m_hWndClient=NULL;
           
           m_fInitialized=FALSE;
           m_pIStorage=NULL;
           m_dwIDCounter=0;
           
           m_hMenuOrg=NULL;
           m_hMenuTop=NULL;
           m_hMenuHelp=NULL;
           m_fInObjectHelp=FALSE;
           m_fUsingOurHelp=FALSE;
           
           m_fHaveObject=FALSE;
           m_hWndObj=NULL;
           
           m_pSite=NULL;
           m_fOurMenuShowing=TRUE;
           SetRect(&m_bwIP, 0, 0, 0, 0);
           m_fInContextHelp=FALSE;
           m_pIOleIPActiveObject=NULL;
           
           return;
           }
           *)
            (#
               hInst: @integer;
               hInstPrev: @integer;
               pszCmdLine: ^text;
               nCmdShow: @integer
            enter (hInst,hInstPrev,pszCmdLine[],nCmdShow)
            do (* hInst->m_hInst;
                0->m_hWnd;*)
               debugMsg
                 (#  do '--> CFrame.Constructor'->putline #);
               hInstPrev->m_hInstPrev;
               nCmdShow->m_nCmdShow;
               ;
               0->m_phMenu;
               0->m_hAccel;
               0->m_hWndClient;
               ;
               false->m_fInitialized;
               none ->m_pIStorage[];
               0->m_dwIDCounter;
               ;
               0->m_hMenuOrg;
               0->m_hMenuTop;
               0->m_hMenuHelp;
               false->m_fInObjectHelp;
               false->m_fUsingOurHelp;
               ;
               false->m_fHaveObject;
               0->m_hWndObj;
               ;
               none ->m_pSite[];
               true->m_fOurMenuShowing;
               SHOULD_HANDLE_SetRect: (#  #);
               false->m_fInContextHelp;
               none ->m_pIOleIPActiveObject[]
            #);
          destructor:
          (*
           CFrame::~CFrame(void)
           {
           if (NULL!=m_hWndClient)
           DestroyWindow(m_hWndClient);
           
           //Frees the temp file.
           ReleaseInterface(m_pIStorage);
           
           //m_pSite cleaned up in Close
           
           //Accelerators freed automatically.
           
           //Destroy the special help menu
           if (NULL!=m_hMenuHelp)
           DestroyMenu(m_hMenuHelp);
           
           //Free the menu handle array
           if (NULL!=m_phMenu)
           delete []((UINT * )m_phMenu);
           
           if (m_fInitialized)
           OleUninitialize();
           
           return;
           }
           *)
            (# 
            do
               debugMsg
                 (#  do '--> CFrame.Destructor'->putline #);
               ;
               (* (if m_hWndClient[] <> none then
                m_hWndClient[]->DestroyWindow
                if)*)
               ;
               ReleaseInterface: (* expanded macro *)
                 (# pt: ^IUnknown
                 do
                    m_pIStorage[]->pt[];
                    none ->m_pIStorage[];
                    (if pt[] <> none then pt.Release if)
                 #)
                 (* Frees the temp file *)
                 ;
               ;
               (* m_pSite cleaned up in Close
                Accelerators freed automatically *)
               ;
               'DestroyMenu'
               (* Destroy the special help menu *)
               ;
               'free menu handle array';
               ;
               (if m_fInitialized then OleUninitialize if)
            #);
          QueryInterface:
          (*
           STDMETHODIMP CFrame::QueryInterface(REFIID riid, void **ppv)
           {
           /*
           * We only know IOleInPlaceFrame and its base interfaces as well
           * as a bogus IOleCommandTarget to make PowerPoint happy.
           */
           *ppv=NULL;
           
           if (IID_IUnknown==riid || IID_IOleInPlaceUIWindow==riid
           || IID_IOleWindow==riid || IID_IOleInPlaceFrame==riid)
           *ppv=(IOleInPlaceFrame * )this;
           
           if (IID_IOleCommandTarget==riid)
           *ppv=(IOleCommandTarget * )this;
           
           if (NULL!=*ppv)
           {
           ((LPUNKNOWN)*ppv)->AddRef();
           return NOERROR;
           }
           
           return E_NOINTERFACE;
           }
           *)
            (# 
            do
               debugMsg
                 (#  do '--> CFrame.QueryInterface'->putline #);
               '(must be further binding)'->putline
            #);
          AddRef:
          (*
           STDMETHODIMP_(ULONG) CFrame::AddRef(void)
           {
           return ++m_cRef;
           }
           *)
            (# 
            do
               debugMsg
                 (#  do '--> CFrame.AddRef'->putline #);
               '(must be further binding)'->putline
            #);
          Release:
          (*
           STDMETHODIMP_(ULONG) CFrame::Release(void)
           {
           //Nothing special happening here--frame's life if user-controlled.
           return --m_cRef;
           }
           *)
            (# 
            do
               debugMsg
                 (#  do 'CFrame.Release'->putline #);
               '(must be further binding)'->putline
            #);
          ;
          VIRTUELLE_MANGLER:
          (* 
           CFrame nedarver fra to interfaces. Jeg ved ikke, hvordan dette klares.
           *) (#  #);
          COleInPlaceFrame: IOleInPlaceFrame
            (#
               GetWindow::<  (#  #);
               ContextSensitiveHelp::<  (#  #);
               GetBorder::<  (#  #);
               RequestBorderSpace::<  (#  #);
               SetBorderSpace::<  (#  #);
               SetActiveObject::<  (#  #);
               InsertMenus::<  (#  #);
               SetMenu::<  (#  #);
               RemoveMenus::<  (#  #);
               SetStatusText::<  (#  #);
               EnableModeless::<  (#  #);
               TranslateAccelerator::<  (#  #)
            #);
          tempOleInPlaceFrame: ^COleInPlaceFrame;
          COleCommandTarget: IOleCommandTarget
            (# QueryStatus::<  (#  #); Exec::<  (#  #) #)
       #);
     CFrame: ^CFrameType
  do
     &CFrameType[]->CFrame[];
     (uienvHInstance,117,none ,0)->CFrame.constructor;
     CFrame.Init
  #)  

