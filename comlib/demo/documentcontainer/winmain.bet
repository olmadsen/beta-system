ORIGIN '~beta/guienv/guienvsystemenv';
INCLUDE '~beta/guienv/private/winnt/guienv_ntiprivate'
        '~beta/basiclib/file'
        '~beta/containers/sets'
        '~beta/comlib/comlib'
        '~beta/comlib/OleIdl'
        '~beta/comlib/docobj'
        '~beta/win32lib/winerror'
        'additionslib'
        '~beta/win32lib/windowmanagement';
BUILD default '$$/winmaindemomisc.obj' 'external/winmaindemomisc.cpp' 'betacc $0 $1';
-- program: Descriptor --
systemEnv
  (#
     myprint: external (# hr: @integer;  enter hr do callc;  #);
     ;
     openFiles:
       (# 
       do
          'debug.txt'->debugFile.name;
          debugFile.openWrite;
          'debug-locate.txt'->locateFile.name;
          locateFile.openWrite;
          'debug-interface.txt'->interfaceFile.name;
          interfaceFile.openWrite;
          'debug-calltoobjects.txt'->callToObjectFile.name;
          callToObjectFile.openWrite;
          locateMsg.open
       #);
     closeFiles:
       (# 
       do
          debugFile.close;
          locateFile.close;
          interfaceFile.close;
          callToObjectFile.close;
          locateMsg.close
       #);
     debug: (#  exit false #);
     debugFile: @file;
     debugMsg:
       (# msg: @text
       do
          (if debug then
              INNER ;
              (if (msg[] <> none ) and not msg.empty then
                  msg[]->debugFile.putline; debugFile.flush
              if)
          if)
       #);
     ;
     locate: (#  exit false #);
     locateFile: @file;
     locate2msg: (#  do (if locate then INNER if) #);
     ;
     locateMsg: @
     (* skal bruges som den foerste og den sidste kommando i hver metode. *)
       (#
          private: @
            (#
               thefile: @file;
               indentlist: @set
                 (# element::  (# msg: ^text; indent: @integer #) #);
               currentIndent:
                 (# result: @integer
                 do
                    - 1->result;
                    indentlist.scan
                      (# 
                      do
                         (if current.indent > result then
                             current.indent->result
                         if)
                      #)
                 exit result
                 #);
               makeIndentString:
                 (# indent: @integer; str: ^text
                 enter indent
                 do &text[]->str[]; (for indent repeat ' '->str.append for)
                 exit str[]
                 #)
            #);
          open:
            (# 
            do
               'debug-locate.txt'->private.thefile.name;
               private.thefile.openWrite
            #);
          close: (#  do private.thefile.close #);
          in:
            (#
               msg: ^text;
               newIndentListElm: ^private.indentlist.element;
               oldIndent,newIndent: @integer
            enter msg[]
            do
               (if (msg[] <> none ) and not msg.empty then
                   private.currentIndent->oldIndent;
                   oldIndent+2->newIndent;
                   ;
                   &private.indentlist.element[]->newIndentListElm[];
                   msg.copy->newIndentListElm.msg[];
                   newIndent->newIndentListElm.indent;
                   newIndentListElm[]->private.indentlist.insert;
                   ;
                   '+ '->msg.prepend;
                   newIndent->private.makeIndentString->msg.prepend;
                   ;
                   msg.makeUC;
                   msg[]->private.thefile.putline;
                   private.thefile.flush
               if)
            #);
          out:
            (# msg: ^text; theIndentListElm: ^private.indentlist.element
            enter msg[]
            do
               (if (msg[] <> none ) and not msg.empty then
                   private.indentlist.find
                     (#
                        predicate:: 
                          (#  do msg[]->current.msg.equal->value #)
                     #)->theIndentListElm[];
                   ;
                   '- '->msg.prepend;
                   (if theIndentListElm[] <> none then
                       theIndentListElm[]->private.indentlist.delete;
                       theIndentListElm.indent->private.makeIndentString
                         ->msg.prepend
                    else
                       '+++++ could not find this element in indentlist +++++ '
                         ->msg.prepend
                   if);
                   ;
                   msg[]->private.thefile.putline;
                   private.thefile.flush
               if)
            #)
       #);
     ;
     interfacedebug: (#  exit true #);
     interfaceFile: @file;
     interfaceMsg:
     (* udskriver en besked, naar et COM-interface er blevet kaldt. *)
       (# msg: @text
       do
          (if interfacedebug then
              INNER ;
              (if (msg[] <> none ) and not msg.empty then
                  msg[]->interfaceFile.putline; interfaceFile.flush
              if)
          if)
       #);
     ;
     callToObjectDebug: (#  exit true #);
     callToObjectFile: @file;
     callToObjectMsg:
     (* bruges til at udskrive foer/efter et kald til server-objektet. *)
       (# msg: @text
       do
          (if callToObjectDebug then
              INNER ;
              (if (msg[] <> none ) and not msg.empty then
                  msg[]->callToObjectFile.putline; callToObjectFile.flush
              if)
          if)
       #);
     ;
     resource: (* Svarer til C++ filen resource.h. Indeholder konstanter. *) @
       (# IDM_FILECLOSE: (#  exit 102 #) #);
     CImpOleClientSite: IOleClientSite
       (#
          PROTECTED: (#  #);
          m_cRef: (* =ULONG *) @integer;
          m_pSite: (* =class CSite* *) ^CSite;
          m_pUnkOuter: (* LPUNKNOWN *) ^IUnknown;
          ;
          ;
          PUBLIC: (#  #);
          constructor:
          (*
           CImpIOleClientSite::CImpIOleClientSite(PCSite pSite, LPUNKNOWN pUnkOuter)
           {
           m_cRef=0;
           m_pSite=pSite;
           m_pUnkOuter=pUnkOuter;
           return;
           }
           *)
            (# pSite: ^CSite; pUnkOuter: (* = LPUNKNOWN *) ^IUnknown
            enter (pSite[],pUnkOuter[])
            do
               locate2msg
                 (#  do 'IOleClientSite.constructor'->putline #);
               0->m_cRef;
               pSite[]->m_pSite[];
               pUnkOuter[]->m_pUnkOuter[]
            #);
          destructor:
          (* 
           CImpIOleClientSite::~CImpIOleClientSite(void)
           {return;}
           *)
            (# 
            do locate2msg (#  do 'IOleClientSite.destructor'->putline #)
            #);
          QueryInterface::<
          (*
           STDMETHODIMP CImpIOleClientSite::QueryInterface(REFIID riid, void **ppv)
           {return m_pUnkOuter->QueryInterface(riid, ppv);}
           *) 
            (# 
            do
               'OleClientSite.QueryInterface'->locateMsg.in;
               interfaceMsg
                 (#  do '++IOleClientSite.QueryInterface'->msg.append #);
               (if true then
                   (riid[],ppvObject[])->m_pUnkOuter.QueryInterface->result
                else
                   E_NOINTERFACE->result
               if);
               ;
               (if false then
                   '======> IOleClientSite.QueryInterface returns: '->puttext;
                   result->myprint
               if);
               'OleClientSite.QueryInterface'->locateMsg.out
            #);
          AddRef::<
          (*
           STDMETHODIMP_(ULONG) CImpIOleClientSite::AddRef(void)
           {
           ++m_cRef;
           return m_pUnkOuter->AddRef();
           }
           *) 
            (# 
            do
               'OleClientSite.AddRef'->locateMsg.in;
               interfaceMsg
                 (#  do '--IOleClientSite.AddRef'->msg.append #);
               m_cRef+1->m_cRef;
               m_pUnkOuter.AddRef->result;
               'OleClientSite.AddRef'->locateMsg.out
            #);
          Release::<
          (*
           STDMETHODIMP_(ULONG) CImpIOleClientSite::Release(void)
           {
           --m_cRef;
           return m_pUnkOuter->Release();
           }
           *) 
            (# 
            do
               'OleClientSite.Release'->locateMsg.in;
               interfaceMsg
                 (#  do '--IOleClientSite.Release'->msg.append #);
               m_cRef-1->m_cRef;
               m_pUnkOuter.Release->result;
               'OleClientSite.Release'->locateMsg.out
            #);
          ;
          SaveObject::<
          (*
           STDMETHODIMP CImpIOleClientSite::SaveObject(void)
           {
           return NOERROR;
           }
           *) 
            (# 
            do
               'OleClientSite.SaveObject'->locateMsg.in;
               interfaceMsg
                 (#  do 'IOleClientSite.SaveObject'->msg.append #);
               NO_ERROR->result;
               'OleClientSite.SaveObject'->locateMsg.out
            #);
          GetMoniker::<
          (*
           STDMETHODIMP CImpIOleClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhich, LPMONIKER *ppmk)
           {return E_NOTIMPL;}
           *) 
            (# 
            do
               'OleClientSite.GetMoniker'->locateMsg.in;
               interfaceMsg
                 (#  do 'IOleClientSite.GetMoniker'->msg.append #);
               E_NOTIMPL->result;
               'OleClientSite.GetMoniker'->locateMsg.out
            #);
          GetContainer::<
          (*
           STDMETHODIMP CImpIOleClientSite::GetContainer(LPOLECONTAINER * ppContainer)
           {
           *ppContainer=NULL;
           return E_NOINTERFACE;
           }
           *) 
            (# 
            do
               'OleClientSite.GetContainer'->locateMsg.in;
               interfaceMsg
                 (#  do 'IOleClientSite.GetContainer'->msg.append #);
               none ->ppContainer;
               E_NOINTERFACE->result;
               'OleClientSite.GetContainer'->locateMsg.out
            #);
          ShowObject::<
          (*
           STDMETHODIMP CImpIOleClientSite::ShowObject(void)
           {return NOERROR;}
           *) 
            (# 
            do
               'OleClientSite.ShowObject'->locateMsg.in;
               interfaceMsg
                 (#  do 'IOleClientSite.ShowObject'->msg.append #);
               NO_ERROR->result;
               'OleClientSite.ShowObject'->locateMsg.out
            #);
          OnShowWindow::<
          (*
           STDMETHODIMP CImpIOleClientSite::OnShowWindow(BOOL fShow)
           {return NOERROR;}
           *) 
            (# 
            do
               'OleClientSite.OnShowWindow'->locateMsg.in;
               interfaceMsg
                 (#  do 'IOleClientSite.OnShowWindow'->msg.append #);
               NO_ERROR->result;
               'OleClientSite.OnShowWindow'->locateMsg.out
            #);
          RequestNewObjectLayout::<
          (*
           STDMETHODIMP CImpIOleClientSite::RequestNewObjectLayout(void)
           {return E_NOTIMPL;}
           *) 
            (# 
            do
               'OleClientSite.RequestNewObjectLayout'->locateMsg.in;
               interfaceMsg
                 (# 
                 do 'IOleClientSite.RequestNewObjectLayout'->msg.append
                 #);
               E_NOTIMPL->result;
               'OleClientSite.RequestNewObjectLayout'->locateMsg.out
            #)
       #);
     CImpAdviseSink: IAdviseSink
       (#
          PROTECTED: (#  #);
          m_cRef: (* =ULONG *) @integer;
          m_pSite: (* =class CSite* *) ^CSite;
          m_pUnkOuter: (* LPUNKNOWN *) ^IUnknown;
          ;
          ;
          PUBLIC: (#  #);
          constructor:
          (*
           CImpIAdviseSink::CImpIAdviseSink(PCSite pSite
           , LPUNKNOWN pUnkOuter)
           {
           m_cRef=0;
           m_pSite=pSite;
           m_pUnkOuter=pUnkOuter;
           return;
           }
           *)
            (# pSite: ^CSite; pUnkOuter: (* = LPUNKNOWN *) ^IUnknown
            enter (pSite[],pUnkOuter[])
            do
               locate2msg
                 (#  do 'IAdviseSink.constructor'->putline #);
               0->m_cRef;
               pSite[]->m_pSite[];
               pUnkOuter[]->m_pUnkOuter[]
            #);
          destructor:
          (*
           CImpIAdviseSink::~CImpIAdviseSink(void)
           {
           return;
           }
           *)
            (# 
            do locate2msg (#  do 'IAdviseSink.destructor'->putline #)
            #);
          QueryInterface::<
          (*
           STDMETHODIMP CImpIAdviseSink::QueryInterface(REFIID riid, void **ppv)
           {
           return m_pUnkOuter->QueryInterface(riid, ppv);
           }
           *) 
            (# 
            do
               'AdviseSink.QueryInterface'->locateMsg.in;
               interfaceMsg
                 (#  do '++IAdviseSink.QueryInterface'->msg.append #);
               (riid[],ppvObject[])->m_pUnkOuter.QueryInterface->result;
               'AdviseSink.QueryInterface'->locateMsg.out
            #);
          AddRef::<
          (*
           STDMETHODIMP_(ULONG) CImpIAdviseSink::AddRef(void)
           {
           ++m_cRef;
           return m_pUnkOuter->AddRef();
           }
           *) 
            (# 
            do
               'AdviseSink.AddRef'->locateMsg.in;
               interfaceMsg
                 (#  do '--IAdviseSink.AddRef'->msg.append #);
               m_cRef+1->m_cRef;
               m_pUnkOuter.AddRef->result;
               'AdviseSink.AddRef'->locateMsg.out
            #);
          Release::<
          (*
           STDMETHODIMP_(ULONG) CImpIAdviseSink::Release(void)
           {
           --m_cRef;
           return m_pUnkOuter->Release();
           }
           *) 
            (# 
            do
               'AdviseSink.Release'->locateMsg.in;
               interfaceMsg
                 (#  do '--IAdviseSink.Release'->msg.append #);
               m_cRef-1->m_cRef;
               m_pUnkOuter.Release->result;
               'AdviseSink.AddRef'->locateMsg.out
            #);
          ;
          OnDataChange::<
          (*
           STDMETHODIMP_(void) CImpIAdviseSink::OnDataChange(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM)
           {return;}
           *) 
            (# 
            do
               'AdviseSink.OnDataChange'->locateMsg.in;
               interfaceMsg
                 (#  do 'IAdviseSink.OnDataChange'->msg.append #);
               'AdviseSink.OnDataChange'->locateMsg.out
            #);
          OnViewChange::<
          (*
           STDMETHODIMP_(void) CImpIAdviseSink::OnViewChange(DWORD dwAspect, LONG lindex)
           {return;}
           *) 
            (# 
            do
               'AdviseSink.OnViewChange'->locateMsg.in;
               interfaceMsg
                 (#  do 'IAdviseSink.OnViewChange'->msg.append #);
               'AdviseSink.OnViewChange'->locateMsg.out
            #);
          OnRename::<
          (*
           STDMETHODIMP_(void) CImpIAdviseSink::OnRename(LPMONIKER pmk)
           {return;}
           *) 
            (# 
            do
               'AdviseSink.OnRename'->locateMsg.in;
               interfaceMsg
                 (#  do 'IAdviseSink.OnRename'->msg.append #);
               'AdviseSink.OnRename'->locateMsg.out
            #);
          OnSave::<
          (*
           STDMETHODIMP_(void) CImpIAdviseSink::OnSave(void)
           {return;}
           *) 
            (# 
            do
               'AdviseSink.OnSave'->locateMsg.in;
               interfaceMsg
                 (#  do 'IAdviseSink.OnSave'->msg.append #);
               'AdviseSink.OnSave'->locateMsg.out
            #);
          OnClose::<
          (*
           /*
           * CImpIAdviseSink::OnClose
           *
           * Purpose:
           *  Informs the advise sink that the OLE object has closed and is
           *  no longer bound in any way.  We use this to do a File/Close
           *  to delete the object since we don't hold onto any.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  None
           */
           
           STDMETHODIMP_(void) CImpIAdviseSink::OnClose(void)
           {
           //This does the same as File/Close
           //Not quite because CFrame::Close requires some synchronous
           //calls that will fail if done here, so just post a message to
           //do this
           //m_pSite->m_pFR->Close();
           
           HWNDhwnd;
           m_pSite->m_pFR->GetWindow(&hwnd);
           PostMessage(
           hwnd, 
           WM_COMMAND,
           MAKELONG(IDM_FILECLOSE, 0),
           0);
           return;
           }
           *) 
            (# hwnd: @int32holder
            do
               'AdviseSink.OnClose'->locateMsg.in;
               interfaceMsg
                 (#  do 'IAdviseSink.OnClose'->msg.append #);
               (* m_pSite.m_pFR.Close *)
               ;
               hwnd[]->m_pSite.m_pFR.theOleInPlaceFrame.GetWindow;
               (hwnd,WM_COMMAND,resource.IDM_FILECLOSE %bor 0,0)->PostMessage;
               'AdviseSink.OnClose'->locateMsg.out
            #)
       #);
     CImpOleInPlaceSite: IOleInPlaceSite
       (#
          PROTECTED: (#  #);
          m_cRef: (* =ULONG *) @integer;
          m_pSite: (* =class CSite* *) ^CSite;
          m_pUnkOuter: (* LPUNKNOWN *) ^IUnknown;
          ;
          ;
          PUBLIC: (#  #);
          constructor:
          (*
           /*
           * CImpIOleInPlaceSite::CImpIOleInPlaceSite
           * CImpIOleInPlaceSite::~CImpIOleInPlaceSite
           *
           * Parameters (Constructor):
           *  pSite           PCSite of the site we're in.
           *  pUnkOuter       LPUNKNOWN to which we delegate.
           */
           
           CImpIOleInPlaceSite::CImpIOleInPlaceSite(PCSite pSite
           , LPUNKNOWN pUnkOuter)
           {
           m_cRef=0;
           m_pSite=pSite;
           m_pUnkOuter=pUnkOuter;
           return;
           }
           *)
            (# pSite: ^CSite; pUnkOuter: (* = LPUNKNOWN *) ^IUnknown
            enter (pSite[],pUnkOuter[])
            do
               locate2msg
                 (#  do 'IOleInPlaceSite.constructor'->putline #);
               0->m_cRef;
               pSite[]->m_pSite[];
               pUnkOuter[]->m_pUnkOuter[]
            #);
          destructor:
          (*
           CImpIOleInPlaceSite::~CImpIOleInPlaceSite(void)
           {
           return;
           }
           *)
            (# 
            do locate2msg (#  do 'IOleInPlaceSite.destructor'->putline #)
            #);
          QueryInterface::<
          (*
           STDMETHODIMP CImpIOleInPlaceSite::QueryInterface(REFIID riid, void **ppv)
           {return m_pUnkOuter->QueryInterface(riid, ppv);}
           *) 
            (# 
            do
               'OleInPlaceSite.QueryInterface'->locateMsg.in;
               interfaceMsg
                 (#  do '++IOleInPlaceSite.QueryInterface'->msg.append #);
               (riid[],ppvObject[])->m_pUnkOuter.QueryInterface->result;
               'OleInPlaceSite.QueryInterface'->locateMsg.out
            #);
          AddRef::<
          (*
           STDMETHODIMP_(ULONG) CImpIOleInPlaceSite::AddRef(void)
           {
           ++m_cRef;
           return m_pUnkOuter->AddRef();
           }
           *) 
            (# 
            do
               'OleInPlaceSite.AddRef'->locateMsg.in;
               interfaceMsg
                 (#  do '--IOleInPlaceSite.AddRef'->msg.append #);
               m_cRef+1->m_cRef;
               m_pUnkOuter.AddRef->result;
               'OleInPlaceSite.AddRef'->locateMsg.out
            #);
          Release::<
          (*
           STDMETHODIMP_(ULONG) CImpIOleInPlaceSite::Release(void)
           {
           --m_cRef;
           return m_pUnkOuter->Release();
           }
           *) 
            (# 
            do
               'OleInPlaceSite.Release'->locateMsg.in;
               interfaceMsg
                 (#  do '--IOleInPlaceSite.Release'->msg.append #);
               m_cRef-1->m_cRef;
               m_pUnkOuter.Release->result;
               'OleInPlaceSite.Release'->locateMsg.out
            #);
          ;
          GetWindow::<
          (*
           /*
           * CImpIOleInPlaceActiveObject::GetWindow
           *
           * Purpose:
           *  Retrieves the handle of the window associated with the object
           *  on which this interface is implemented.
           *
           * Parameters:
           *  phWnd           HWND * in which to store the window handle.
           *
           * Return Value:
           *  HRESULT         NOERROR if successful, E_FAIL if there is no
           *                  window.
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::GetWindow(HWND *phWnd)
           {
           //This is the client-area window in the frame
           *phWnd=m_pSite->m_hWnd;
           return NOERROR;
           }
           *) 
            (# 
            do
               'OleInPlaceSite.GetWindow'->locateMsg.in;
               interfaceMsg
                 (#  do 'IOleInPlaceSite.GetWindow'->msg.append #);
               m_pSite.m_hWnd->phwnd;
               NOERROR->result;
               'OleInPlaceSite.GetWindow'->locateMsg.out
            #);
          ContextSensitiveHelp::<
          (*
           /*
           * CImpIOleInPlaceActiveObject::ContextSensitiveHelp
           *
           * Purpose:
           *  Instructs the object on which this interface is implemented to
           *  enter or leave a context-sensitive help mode.
           *
           * Parameters:
           *  fEnterMode      BOOL TRUE to enter the mode, FALSE otherwise.
           *
           * Return Value:
           *  HRESULT         NOERROR
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::ContextSensitiveHelp(BOOL fEnterMode)
           {return NOERROR;}
           *) 
            (# 
            do
               'OleInPlaceSite.ContextSensitiveHelp'->locateMsg.in;
               interfaceMsg
                 (# 
                 do 'IOleInPlaceSite.ContextSensitiveHelp'->msg.append
                 #);
               NOERROR->result;
               'OleInPlaceSite.ContextSensitiveHelp'->locateMsg.out
            #);
          CanInPlaceActivate::<
          (*
           /*
           * CImpIOleInPlaceSite::CanInPlaceActivate
           *
           * Purpose:
           *  Answers the server whether or not we can currently in-place
           *  activate its object.  By implementing this interface we say
           *  that we support in-place activation, but through this function
           *  we indicate whether the object can currently be activated
           *  in-place.  Iconic aspects, for example, cannot, meaning we
           *  return S_FALSE.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  HRESULT         NOERROR if we can in-place activate the object
           *                  in this site, S_FALSE if not.
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::CanInPlaceActivate(void)
           {    
           /*
           * We can always in-place activate--no restrictions for DocObjects.
           * We don't worry about other cases since CSite only ever creates
           * embedded files.
           */
           return NOERROR;
           }
           *) 
            (# 
            do
               'OleInPlaceSite.CanInPlaceActivate'->locateMsg.in;
               interfaceMsg
                 (# 
                 do
                    '----------------------------------------------\n'
                      ->msg.append;
                    'IOleInPlaceSite.CanInPlaceActivate'->msg.append
                 #);
               NOERROR->result;
               'OleInPlaceSite.CanInPlaceActivate'->locateMsg.out
            #);
          OnInPlaceActivate::<
          (*
           /*
           * CImpIOleInPlaceSite::OnInPlaceActivate
           *
           * Purpose:
           *  Informs the container that an object is being activated in-place
           *  such that the container can prepare appropriately.  The
           *  container does not, however, make any user interface changes at
           *  this point.  See OnUIActivate.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  HRESULT         NOERROR or an appropriate error code.
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::OnInPlaceActivate(void)
           {    
           m_pSite->m_pObj->QueryInterface(IID_IOleInPlaceObject
           , (void ** )&m_pSite->m_pIOleIPObject);
           
           return NOERROR;
           }
           *) 
            (# IID_IOleIPObject: @IID
            do
               'OleInPlaceSite.OnInPlaceActivate'->locateMsg.in;
               interfaceMsg
                 (#  do 'IOleInPlaceSite.OnInPlaceActivate'->msg.append #);
               ;
               IOleInPlaceObject_IID->IID_IOleIPObject;
               callToObjectMsg
                 (# 
                 do
                    'IOleInPlaceSite.OnInPlaceActivate: kald til queryinterface'
                      ->msg.append
                 #);
               (m_pSite.m_pObj[],IID_IOleIPObject[])->Query
                 ->m_pSite.m_pIOleIPObject[];
               callToObjectMsg
                 (# 
                 do
                    'IOleInPlaceSite.OnInPlaceActivate: kald returneret'
                      ->msg.append
                 #);
               ;
               NOERROR->result;
               'OleInPlaceSite.OnInPlaceActivate'->locateMsg.out
            #);
          OnInPlaceDeactivate::<
          (*
           /*
           * CImpIOleInPlaceSite::OnInPlaceDeactivate
           *
           * Purpose:
           *  Notifies the container that the object has deactivated itself
           *  from an in-place state.  Opposite of OnInPlaceActivate.  The
           *  container does not change any UI at this point.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  HRESULT         NOERROR or an appropriate error code.
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::OnInPlaceDeactivate(void)
           {
           /*
           * Since we don't have an Undo command, we can tell the object
           * right away to discard its Undo state.
           */
           m_pSite->Activate(OLEIVERB_DISCARDUNDOSTATE);
           ReleaseInterface(m_pSite->m_pIOleIPObject);
           return NOERROR;
           }
           *) 
            (# 
            do
               'OleInPlaceSite.OnInPlaceDeactivate'->locateMsg.in;
               interfaceMsg
                 (# 
                 do 'IOleInPlaceSite.OnInPlaceDeactivate'->msg.append
                 #);
               OLEIVERB_DISCARDUNDOSTATE->m_pSite.Activate;
               ReleaseInterface: (* macro ReleaseInterface expanded *)
                 (# pt: ^IUnknown
                 do
                    m_pSite.m_pIOleIPObject[]->pt[];
                    (if pt[] <> none then
                        callToObjectMsg
                          (# 
                          do
                             'IOleInPlaceSite.OnInPlaceDeactivate: kald til Release'
                               ->msg.append
                          #);
                        pt.Release;
                        callToObjectMsg
                          (# 
                          do
                             'IOleInPlaceSite.OnInPlaceDeactivate: kald returneret'
                               ->msg.append
                          #)
                    if)
                 #);
               NOERROR->result;
               'OleInPlaceSite.OnInPlaceDeactivate'->locateMsg.out
            #);
          OnUIActivate::<
          (*
           /*
           * CImpIOleInPlaceSite::OnUIActivate
           *
           * Purpose:
           *  Informs the container that the object is going to start munging
           *  around with user interface, like replacing the menu.  The
           *  container should remove any relevant UI in preparation.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  HRESULT         NOERROR or an appropriate error code.
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::OnUIActivate(void)
           {
           //No state we have to set up here.
           return NOERROR;
           }
           *) 
            (# 
            do
               'OleInPlaceSite.OnUIActivate'->locateMsg.in;
               interfaceMsg
                 (#  do 'IOleInPlaceSite.OnUIActivate'->msg.append #);
               NOERROR->result;
               'OleInPlaceSite.OnUIActivate'->locateMsg.out
            #);
          OnUIDeactivate::<
          (*
           /*
           * CImpIOleInPlaceSite::OnUIDeactivate
           *
           * Purpose:
           *  Informs the container that the object is deactivating its
           *  in-place user interface at which time the container may
           *  reinstate its own.  Opposite of OnUIActivate.
           *
           * Parameters:
           *  fUndoable       BOOL indicating if the object will actually
           *                  perform an Undo if the container calls
           *                  ReactivateAndUndo.
           *
           * Return Value:
           *  HRESULT         NOERROR or an appropriate error code.
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::OnUIDeactivate(BOOL fUndoable)
           {
           //Set focus back to the frame
           SetFocus(m_pSite->m_pFR->Window());
           
           //Show our menu again
           m_pSite->m_pFR->SetMenu(NULL, NULL, NULL);
           
           return NOERROR;
           }
           *) 
            (# 
            do
               'OleInPlaceSite.OnUIDeactivate'->locateMsg.in;
               interfaceMsg
                 (#  do 'IOleInPlaceSite.OnUIDeactivate'->msg.append #);
               'SetFocus(m_pSite->m_pFR->Window());  m_pSite.m_pFR.SetMenu'
                 ->putline;
               NOERROR->result;
               'OleInPlaceSite.OnUIDeactivate'->locateMsg.out
            #);
          DeactivateAndUndo::<
          (*
           /*
           * CImpIOleInPlaceSite::DeactivateAndUndo
           *
           * Purpose:
           *  If immediately after activation the object does an Undo, the
           *  action being undone is the activation itself, and this call
           *  informs the container that this is, in fact, what happened.
           *  The container should call IOleInPlaceObject::UIDeactivate.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  HRESULT         NOERROR or an appropriate error code.
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::DeactivateAndUndo(void)
           {
           m_pSite->m_pIOleIPObject->InPlaceDeactivate();
           return NOERROR;
           }
           *) 
            (# 
            do
               'OleInPlaceSite.DeactivateAndUndo'->locateMsg.in;
               interfaceMsg
                 (#  do 'IOleInPlaceSite.DeactivateAndUndo'->msg.append #);
               callToObjectMsg
                 (# 
                 do
                    'IOleInPlaceSite.DeactivateAndUndo: kald til InPlaceDeactivate'
                      ->msg.append
                 #);
               m_pSite.m_pIOleIPObject.InPlaceDeactivate;
               callToObjectMsg
                 (# 
                 do
                    'IOleInPlaceSite.DeactivateAndUndo: kald returneret'
                      ->msg.append
                 #);
               NOERROR->result;
               'OleInPlaceSite.DeactivateAndUndo'->locateMsg.out
            #);
          DiscardUndoState::<
          (*
           /*
           * CImpIOleInPlaceSite::DiscardUndoState
           *
           * Purpose:
           *  Informs the container that something happened in the object
           *  that means the container should discard any undo information
           *  it currently maintains for the object.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  HRESULT         NOERROR or an appropriate error code.
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::DiscardUndoState(void)
           {
           return E_NOTIMPL;
           }
           *) 
            (# 
            do
               'OleInPlaceSite.DiscardUndoState'->locateMsg.in;
               interfaceMsg
                 (#  do 'IOleInPlaceSite.DiscardUndoState'->msg.append #);
               E_NOTIMPL->result;
               'OleInPlaceSite.DiscardUndoState'->locateMsg.out
            #);
          GetWindowContext::<
          (*
           /*
           * CImpIOleInPlaceSite::GetWindowContext
           *
           * Purpose:
           *  Provides an in-place object with pointers to the frame and
           *  document level in-place interfaces (IOleInPlaceFrame and
           *  IOleInPlaceUIWindow) such that the object can do border
           *  negotiation and so forth.  Also requests the position and
           *  clipping rectangles of the object in the container and a
           *  pointer to an OLEINPLACEFRAME info structure which contains
           *  accelerator information.
           *
           *  Note that the two interfaces this call returns are not
           *  available through QueryInterface on IOleInPlaceSite since they
           *  live with the frame and document, but not the site.
           *
           * Parameters:
           *  ppIIPFrame      LPOLEINPLACEFRAME * in which to return the
           *                  AddRef'd pointer to the container's
           *                  IOleInPlaceFrame.
           *  ppIIPUIWindow   LPOLEINPLACEUIWINDOW * in which to return
           *                  the AddRef'd pointer to the container document's
           *                  IOleInPlaceUIWindow.
           *  prcPos          LPRECT in which to store the object's position.
           *  prcClip         LPRECT in which to store the object's visible
           *                  region.
           *  pFI             LPOLEINPLACEFRAMEINFO to fill with accelerator
           *                  stuff.
           *
           * Return Value:
           *  HRESULT         NOERROR
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::GetWindowContext
           (LPOLEINPLACEFRAME *ppIIPFrame, LPOLEINPLACEUIWINDOW
           *ppIIPUIWindow, LPRECT prcPos, LPRECT prcClip
           , LPOLEINPLACEFRAMEINFO pFI)
           {
           *ppIIPUIWindow=NULL;
           m_pSite->m_pFR->QueryInterface(IID_IOleInPlaceFrame
           , (void ** )ppIIPFrame);
           
           if (NULL!=prcPos)
           GetClientRect(m_pSite->m_hWnd, prcPos);
           
           *prcClip=*prcPos;
           
           pFI->cb=sizeof(OLEINPLACEFRAMEINFO);
           pFI->fMDIApp=FALSE;
           pFI->hwndFrame=m_pSite->m_pFR->Window();
           pFI->haccel=m_pSite->m_pFR->Accelerators();
           pFI->cAccelEntries=CACCELERATORS;
           
           return NOERROR;
           }
           *) 
            (# IID_IOleInPlaceFrame: @IID; anInt32Holder: @int32holder
            do
               'OleInPlaceSite.GetWindowContext'->locateMsg.in;
               interfaceMsg
                 (#  do 'IOleInPlaceSite.GetWindowContext'->msg.append #);
               ;
               none ->ppDoc;
               ;
               IOleInPlaceFrame_IID->IID_IOleInPlaceFrame;
               (m_pSite.m_pFR[],IID_IOleInPlaceFrame[])->Query->ppFrame;
               ;
               (if lprcPosRect[] <> none then
                   m_pSite.m_hWnd->anInt32Holder;
                   (anInt32Holder[],lprcPosRect[])->GetClientRect3
               if);
               ;
               lprcPosRect.left->lprcClipRect.left;
               lprcPosRect.right->lprcClipRect.right;
               lprcPosRect.top->lprcClipRect.top;
               lprcPosRect.bottom->lprcClipRect.bottom;
               ;
               20->lpFrameInfo.cb;
               false->lpFrameInfo.fMDIApp;
               m_pSite.m_pFR.Window_->lpFrameInfo.hwndFrame;
               m_pSite.m_pFR.Accelerators->lpFrameInfo.haccel;
               CACCELERATORS->lpFrameInfo.cAccelEntries;
               ;
               NOERROR->result;
               'OleInPlaceSite.GetWindowContext'->locateMsg.out
            #);
          Scroll::<
          (*
           /*
           * CImpIOleInPlaceSite::Scroll
           *
           * Purpose:
           *  Asks the container to scroll the document, and thus the object,
           *  by the given amounts in the sz parameter.
           *
           * Parameters:
           *  sz              SIZE containing signed horizontal and vertical
           *                  extents by which the container should scroll.
           *                  These are in device units.
           *
           * Return Value:
           *  HRESULT         NOERROR
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::Scroll(SIZE sz)
           {
           //Not needed for DocObjects
           return E_NOTIMPL;
           }
           *) 
            (# 
            do
               'OleInPlaceSite.Scroll'->locateMsg.in;
               interfaceMsg
                 (#  do 'IOleInPlaceSite.Scroll'->msg.append #);
               E_NOTIMPL->result;
               'OleInPlaceSite.Scroll'->locateMsg.out
            #);
          OnPosRectChange::<
          (*
           /*
           * CImpIOleInPlaceSite::OnPosRectChange
           *
           * Purpose:
           *  Informs the container that the in-place object was resized.
           *  The container must call IOleInPlaceObject::SetObjectRects.
           *  This does not change the site's rectangle in any case.
           *
           * Parameters:
           *  prcPos          LPCRECT containing the new size of the object.
           *
           * Return Value:
           *  HRESULT         NOERROR
           */
           
           STDMETHODIMP CImpIOleInPlaceSite::OnPosRectChange(LPCRECT prcPos)
           {
           //Not needed for DocObjects
           return E_NOTIMPL;
           }
           *) 
            (# 
            do
               'OleInPlaceSite.OnPosRectChange'->locateMsg.in;
               interfaceMsg
                 (#  do 'IOleInPlaceSite.OnPosRectChange'->msg.append #);
               E_NOTIMPL->result;
               'OleInPlaceSite.OnPosRectChange'->locateMsg.out
            #)
       #);
     CImpOleDocumentSite: IOleDocumentSite
       (#
          PROTECTED: (#  #);
          m_cRef: (* =ULONG *) @integer;
          m_pSite: (* =class CSite* *) ^CSite;
          m_pUnkOuter: (* LPUNKNOWN *) ^IUnknown;
          ;
          ;
          PUBLIC: (#  #);
          constructor:
          (*
           /*
           * CImpIOleDocumentSite::CImpIOleDocumentSite
           * CImpIOleDocumentSite::~CImpIOleDocumentSite
           *
           * Parameters (Constructor):
           *  pSite           PCSite of the site we're in.
           *  pUnkOuter       LPUNKNOWN to which we delegate.
           */
           
           CImpIOleDocumentSite::CImpIOleDocumentSite(PCSite pSite
           , LPUNKNOWN pUnkOuter)
           {
           m_cRef=0;
           m_pSite=pSite;
           m_pUnkOuter=pUnkOuter;
           return;
           }
           *)
            (# pSite: ^CSite; pUnkOuter: (* = LPUNKNOWN *) ^IUnknown
            enter (pSite[],pUnkOuter[])
            do
               locate2msg
                 (#  do 'IOleDocumentSite.constructor'->putline #);
               0->m_cRef;
               pSite[]->m_pSite[];
               pUnkOuter[]->m_pUnkOuter[]
            #);
          destructor:
          (*
           CImpIOleDocumentSite::~CImpIOleDocumentSite(void)
           {
           return;
           }
           *)
            (# 
            do locate2msg (#  do 'IOleDocumentSite.destructor'->putline #)
            #);
          QueryInterface::<
          (*
           STDMETHODIMP CImpIOleDocumentSite::QueryInterface(REFIID riid
           , void **ppv)
           {
           return m_pUnkOuter->QueryInterface(riid, ppv);
           }
           *) 
            (# 
            do
               'OleDocumentSite.QueryInterface'->locateMsg.in;
               interfaceMsg
                 (#  do '++IOleDocumentSite.QueryInterface'->msg.append #);
               (riid[],ppvObject[])->m_pUnkOuter.QueryInterface->result;
               'OleDocumentSite.QueryInterface'->locateMsg.out
            #);
          AddRef::<
          (*
           STDMETHODIMP_(ULONG) CImpIOleDocumentSite::AddRef(void)
           {
           ++m_cRef;
           return m_pUnkOuter->AddRef();
           }
           *) 
            (# 
            do
               'OleDocumentSite.AddRef'->locateMsg.in;
               interfaceMsg
                 (#  do '--IOleDocumentSite.AddRef'->msg.append #);
               m_cRef+1->m_cRef;
               m_pUnkOuter.AddRef->result;
               'OleDocumentSite.AddRef'->locateMsg.out
            #);
          Release::<
          (*
           STDMETHODIMP_(ULONG) CImpIOleDocumentSite::Release(void)
           {
           --m_cRef;
           return m_pUnkOuter->Release();
           }
           *) 
            (# 
            do
               'OleDocumentSite.Release'->locateMsg.in;
               interfaceMsg
                 (#  do '--IOleDocumentSite.Release'->msg.append #);
               m_cRef-1->m_cRef;
               m_pUnkOuter.Release->result;
               'OleDocumentSite.Release'->locateMsg.out
            #);
          ;
          ActivateMe::<
          (*
           /*
           * CImpIOleDocumentsite::ActivateMe
           *
           * Purpose:
           *  Instructs the container to activate the object in this site as
           *  a document object.
           *
           * Parameters:
           *  pView           IOleDocumentView * of the object to activate.
           *
           * Return Value:
           *  HRESULT         NOERROR if successful, error code otherwise.
           */
           
           STDMETHODIMP CImpIOleDocumentSite::ActivateMe(IOleDocumentView *pView)
           {
           RECT                rc;
           IOleDocument*       pDoc;
           
           /*
           * If we're passed a NULL view pointer, then try to get one from
           * the document object (the object within us).
           */
           if (NULL==pView)
           {
           
           if (FAILED(m_pSite->m_pObj->QueryInterface(IID_IOleDocument
           , (void ** )&pDoc)))
           return E_FAIL;
           
           if (FAILED(pDoc->CreateView(m_pSite->m_pImpIOleIPSite
           , m_pSite->m_pIStream, 0, &pView)))            
           return E_OUTOFMEMORY;
           
           // Release doc pointer since CreateView is a good com method that addrefs
           pDoc->Release();
           }        
           else
           {
           //Make sure that the view has our client site
           pView->SetInPlaceSite(m_pSite->m_pImpIOleIPSite);
           
           //We're holding onto the pointer, so AddRef it.
           pView->AddRef();
           }
           
           
           /*
           * Activation steps, now that we have a view:
           *
           *  1.  Call IOleDocumentView::SetInPlaceSite (assume done since
           *      either the view already knows, or IOleDocument::CreateView
           *      has done it already.
           *
           *  2.  Call IOleDocumentView::SetRect to give a bunch of space to
           *      the view.  In our case this is the whole client area of
           *      the CPages window.  (Patron doesn't use SetRectComplex)
           *
           *  3.  Call IOleDocumentView::Show to make the thing visible.
           *
           *  4.  Call IOleDocumentView::UIActivate to finish the job.
           *
           */
           
           m_pSite->m_fDocObj=TRUE;
           m_pSite->m_pIOleDocView=pView;
           
           //This sets up toolbars and menus first    
           pView->UIActivate(TRUE);
           
           //Set the window size sensitive to new toolbars
           GetClientRect(m_pSite->m_hWnd, &rc);
           pView->SetRect(&rc);
           
           //Makes it all active
           pView->Show(TRUE);    
           return NOERROR;
           }
           *) 
            (#
               pDoc: ^IOleDocument;
               IID_IOleDocument: @IID;
               anIOleDocumentViewHolder: @IOleDocumentViewHolder
            do
               'OleDocumentSite.ActivateMe'->locateMsg.in;
               interfaceMsg
                 (#  do 'IOleDocumentSite.ActivateMe'->msg.append #);
               ;
               (if pViewToActivate[] = none then
               (* If we're passed a NULL view pointer, then try to get one from
                the document object (the object within us). *)
                   IOleDocument_IID->IID_IOleDocument;
                   callToObjectMsg
                     (# 
                     do
                        'IOleDocumentSite.ActivateMe: kald til QueryInterface'
                          ->msg.append
                     #);
                   (m_pSite.m_pObj[],IID_IOleDocument[])->Query->pDoc[];
                   callToObjectMsg
                     (# 
                     do
                        'IOleDocumentSite.ActivateMe: kald til QueryInterface returneret'
                          ->msg.append
                     #);
                   ;
                   pViewToActivate[]->anIOleDocumentViewHolder;
                   callToObjectMsg
                     (# 
                     do
                        'IOleDocumentSite.ActivateMe: kald til CreateView'
                          ->msg.append
                     #);
                   (m_pSite.m_pImpIOleIPSite[],m_pSite.m_pIStream[],0,
                    anIOleDocumentViewHolder[])->pDoc.CreateView;
                   callToObjectMsg
                     (# 
                     do
                        'IOleDocumentSite.ActivateMe: kald til CreateView returneret'
                          ->msg.append
                     #);
                   ;
                   callToObjectMsg
                     (# 
                     do
                        'IOleDocumentSite.ActivateMe: kald til Release'
                          ->msg.append
                     #);
                   pDoc.Release;
                   callToObjectMsg
                     (# 
                     do
                        'IOleDocumentSite.ActivateMe: kald til Release returneret'
                          ->msg.append
                     #)
                else
                   callToObjectMsg
                     (# 
                     do
                        'IOleDocumentSite.ActivateMe: kald til SetInPlaceSite'
                          ->msg.append
                     #);
                   (m_pSite.m_pImpIOleIPSite[])
                     ->
                       pViewToActivate.SetInPlaceSite
                       (* make sure that the view has our client site *) ;
                   callToObjectMsg
                     (# 
                     do
                        'IOleDocumentSite.ActivateMe: kald til SetInPlaceSite returneret'
                          ->msg.append
                     #);
                   callToObjectMsg
                     (# 
                     do
                        'IOleDocumentSite.ActivateMe: kald til AddRef'
                          ->msg.append
                     #);
                   pViewToActivate.AddRef;
                   callToObjectMsg
                     (# 
                     do
                        'IOleDocumentSite.ActivateMe: kald til AddRef returneret'
                          ->msg.append
                     #)
               if);
               ;
               true->m_pSite.m_fDocObj;
               pViewToActivate[]->m_pSite.m_pIOleDocView[];
               ;
               callToObjectMsg
                 (# 
                 do
                    'IOleDocumentSite.ActivateMe: kald til UIActivate'
                      ->msg.append
                 #);
               true
                 ->
                   pViewToActivate.UIActivate
                   (* this sets up toolbars and menus first *) ;
               callToObjectMsg
                 (# 
                 do
                    'IOleDocumentSite.ActivateMe: kald til UIActivate returneret'
                      ->msg.append
                 #);
               ;
               (* Set the window size sensitive to new toolbars.
                GetClientRect(m_pSite->m_hWnd, &rc);
                pView->SetRect(&rc); *)
               ;
               callToObjectMsg
                 (# 
                 do 'IOleDocumentSite.ActivateMe: kald til Show'->msg.append
                 #);
               true->pViewToActivate.Show;
               callToObjectMsg
                 (# 
                 do
                    'IOleDocumentSite.ActivateMe: kald til Show returneret'
                      ->msg.append
                 #);
               ;
               NOERROR->result;
               'OleDocumentSite.ActivateMe'->locateMsg.out
            #)
       #);
     CSite: IUnknown
       (#
          PRIVATE: (#  #);
          m_cRef: @integer (* originally ULONG *) ;
          m_dwID: @integer (* originally DWORD *) ;
          m_hWnd: @integer
          (* Client area window of parent.
           originally HWND *) ;
          ;
          m_pFR: ^CFrameType;
          ;
          m_fInitialized: (* Something here? *) @boolean;
          m_pIStorage:
          (* Storage for object.
           Originally LPSTORAGE *) ^IStorage;
          m_pIStream:
          (* Info stream for object.
           LPSTREAM *) ^IStream;
          ;
          m_pObj: ^IUnknown;
          m_pIOleObject: ^IOleObject;
          m_pIOleIPObject: ^IOleInPlaceObject;
          m_pIOleDocView: ^IOleDocumentView;
          ;
          m_fDocObj: (* Document object here? *) @boolean;
          ;
          m_pImpIOleClientSite: ^CImpOleClientSite;
          m_pImpIAdviseSink: ^CImpAdviseSink;
          m_pImpIOleIPSite: ^CImpOleInPlaceSite;
          m_pImpIOleDocumentSite: ^CImpOleDocumentSite;
          ;
          ;
          PROTECTED: (#  #);
          ObjectInitialize:
          (*
           /*
           * CSite::ObjectInitialize
           * (Protected)
           *
           * Purpose:
           *  Performs operations necessary after creating an object or
           *  reloading one from storage.
           *
           * Parameters:
           *  pObj            LPUNKNOWN of the object in this tenant.
           *  pFE             LPFORMATETC describing the graphic here.
           *  dwData          DWORD extra data.  If pFE->dwAspect==
           *                  DVASPECT_ICON then this is the iconic metafile.
           *
           * Return Value:
           *  BOOL            TRUE if the function succeeded, FALSE otherwise.
           */
           
           BOOL CSite::ObjectInitialize(LPUNKNOWN pObj)
           {
           HRESULT         hr;
           DWORD           dw;
           
           if (NULL==pObj)
           return FALSE;
           
           m_pObj=pObj;
           
           //We need an IOleObject most of the time, so get one here.
           m_pIOleObject=NULL;
           hr=pObj->QueryInterface(IID_IOleObject, (void ** )&m_pIOleObject);         
           
           /*
           * Follow up object creation with advises and so forth.  If
           * we cannot get IOleObject here, then we know we can't do
           * any IOleObject actions from here on--object is static.
           */
           if (FAILED(hr))
           return TRUE;
           
           //SetClientSite is critical for DocObjects
           m_pIOleObject->SetClientSite(m_pImpIOleClientSite);
           m_pIOleObject->Advise(m_pImpIAdviseSink, &dw);
           
           //This is to give PowerPoint a chance to initialize itself earlier
           OleRun(m_pIOleObject);
           return TRUE;
           }
           *)
            (#
               pObj: ^IUnknown;
               result: @boolean;
               hr: @HResult;
               dw: @int32uHolder (* DWORD* *) ;
               IID_IOleObject: @IID
            enter pObj[]
            do
               'CSite.ObjectInitialize'->locateMsg.in;
               locate2msg
                 (#  do 'CSite.ObjectInitialize'->putline #);
               return:
               (* When the C program says "return X", 
                we say "X->result; leave return". *)
                 (# hr: @HResult
                 do
                    (if pObj[] = none then false->result; leave return if);
                    pObj[]->m_pObj[];
                    ;
                    none
                      ->m_pIOleObject[]
                      (* We need an IOleObject most of the time, so get one here *)
                      ;
                    IOleObject_IID->IID_IOleObject;
                    callToObjectMsg
                      (# 
                      do
                         'CSite.ObjectInitialize: kald til QueryInterface'
                           ->msg.append
                      #);
                    (pObj[],IID_IOleObject[])->Query->m_pIOleObject[];
                    callToObjectMsg
                      (# 
                      do
                         'CSite.ObjectInitialize: kald til QueryInterface returneret'
                           ->msg.append
                      #);
                    ;
                    callToObjectMsg
                      (# 
                      do
                         'CSite.ObjectInitialize: kald til SetClientSite'
                           ->msg.append
                      #);
                    m_pImpIOleClientSite[]->m_pIOleObject.SetClientSite
                      ->hr (* SetClientSite is critical for DocObjects *) ;
                    callToObjectMsg
                      (# 
                      do
                         'CSite.ObjectInitialize: kald til SetClientSite returneret'
                           ->msg.append
                      #);
                    debugMsg
                      (# 
                      do
                         (if hr.succeeded then
                             (if false then
                                 'ObjectInitialize: SetClientSite succeeded'
                                   ->msg.append
                             if)
                          else
                             'ObjectInitialize: SetClientSite failed'
                               ->msg.append
                         if)
                      #);
                    callToObjectMsg
                      (# 
                      do 'CSite.ObjectInitialize: kald til Advise'->msg.append
                      #);
                    (m_pImpIAdviseSink[],dw[])->m_pIOleObject.Advise->hr;
                    callToObjectMsg
                      (# 
                      do
                         'CSite.ObjectInitialize: kald til Advise returneret'
                           ->msg.append
                      #);
                    debugMsg
                      (# 
                      do
                         (if hr.succeeded then
                             (if false then
                                 'ObjectInitialize: Advise succeeded'
                                   ->msg.append
                             if)
                          else
                             'ObjectInitialize: Advise failed'->msg.append
                         if)
                      #);
                    ;
                    (if false then
                        (none ,'Before OLERUN',none )->alertUser
                    if);
                    m_pIOleObject[]
                      ->OleRun
                      (* This is to give PowerPoint a chance to initialize itself earlier *)
                      ;
                    (if false then
                        (none ,'After OLERUN',none )->alertUser
                    if);
                    true->result;
                    leave return
                 #);
               'CSite.ObjectInitialize'->locateMsg.out
            exit result
            #);
          ;
          ;
          PUBLIC: (#  #);
          constructor:
          (*
           /*
           * CSite::CSite
           * CSite::~CSite
           *
           * Constructor Parameters:
           *  dwID            DWORD identifer for this site.
           *  hWnd            HWND of the window associated with the site
           *  pFR             PCFrame to the parent structure.
           */
           
           CSite::CSite(DWORD dwID, HWND hWnd, PCFrame pFR)
           {
           m_cRef=0;
           m_dwID=dwID;
           m_hWnd=hWnd;
           m_pFR=pFR;
           
           m_fInitialized=0;
           m_pIStorage=NULL;
           
           m_pObj=NULL;
           
           m_pIOleObject=NULL;
           m_pIOleIPObject=NULL;
           m_pIOleDocView=NULL;
           
           m_pImpIOleClientSite=NULL;
           m_pImpIAdviseSink=NULL;
           m_pImpIOleIPSite=NULL;
           m_pImpIOleDocumentSite=NULL;
           
           m_fDocObj=FALSE;
           return;
           }
           *)
            (# dwID,hWnd: @integer; pFR: ^CFrameType
            enter (dwID,hWnd,pFR[])
            do
               locate2msg
                 (#  do 'CSite.Constructor'->putline #);
               0->m_cRef;
               dwID->m_dwID;
               hWnd->m_hWnd;
               pFR[]->m_pFR[];
               ;
               0->m_fInitialized;
               none ->m_pIStorage[];
               ;
               none ->m_pObj[];
               ;
               none ->m_pIOleObject[];
               none ->m_pIOleIPObject[];
               none ->m_pIOleDocView[];
               ;
               none ->m_pImpIOleClientSite[];
               none ->m_pImpIAdviseSink[];
               none ->m_pImpIOleIPSite[];
               none ->m_pImpIOleDocumentSite[];
               ;
               false->m_fDocObj
            #);
          destructor:
          (*
           CSite::~CSite(void)
           {
           //Object pointers cleaned up in Close.
           
           //We delete our own interfaces since we control them
           DeleteInterfaceImp(m_pImpIOleDocumentSite);
           DeleteInterfaceImp(m_pImpIOleIPSite);
           DeleteInterfaceImp(m_pImpIAdviseSink);
           DeleteInterfaceImp(m_pImpIOleClientSite);
           return;
           }
           *)
            (# pt: ^IUnknown
            do
               locate2msg
                 (#  do 'CSite.Destructor'->putline #);
               m_pImpIOleDocumentSite[]->pt[];
               none ->m_pImpIOleDocumentSite[];
               (if pt[] <> none then pt.Release if);
               ;
               m_pImpIOleIPSite[]->pt[];
               none ->m_pImpIOleIPSite[];
               (if pt[] <> none then pt.Release if);
               ;
               m_pImpIAdviseSink[]->pt[];
               none ->m_pImpIAdviseSink[];
               (if pt[] <> none then pt.Release if);
               ;
               m_pImpIOleClientSite[]->pt[];
               none ->m_pImpIOleClientSite[];
               (if pt[] <> none then pt.Release if)
            #);
          QueryInterface::<
          (*
           STDMETHODIMP CSite::QueryInterface(REFIID riid, void **ppv)
           {
           *ppv=NULL;
           
           if (IID_IUnknown==riid)
           *ppv=this;
           
           if (IID_IOleClientSite==riid)
           *ppv=m_pImpIOleClientSite;
           
           if (IID_IAdviseSink==riid)
           *ppv=m_pImpIAdviseSink;
           
           if (IID_IOleWindow==riid || IID_IOleInPlaceSite==riid)
           *ppv=m_pImpIOleIPSite;
           
           if (IID_IOleDocumentSite==riid)
           *ppv=m_pImpIOleDocumentSite;
           
           if (NULL!=*ppv)
           {
           ((LPUNKNOWN)*ppv)->AddRef();
           return NOERROR;
           }
           
           return ResultFromScode(E_NOINTERFACE);
           }
           *) 
            (#
               Marshal_IID,Unknown_IID,OleClientSite_IID,AdviseSink_IID,
                 OleWindow_IID,OleInPlaceSite_IID,OleDocumentSite_IID: @IID;
               init:
                 (# 
                 do
                    IUnknown_IID->Unknown_IID;
                    IOleClientSite_IID->OleClientSite_IID;
                    IAdviseSink_IID->AdviseSink_IID;
                    IOleWindow_IID->OleWindow_IID;
                    IOleInPlaceSite_IID->OleInPlaceSite_IID;
                    IOleDocumentSite_IID->OleDocumentSite_IID;
                    IMarshal_IID->Marshal_IID;
                    ;
                    (if false then
                        debugMsg
                          (# 
                          do
                             'This QueryInterface supports: '->msg.append;
                             Unknown_IID->msg.append;
                             ', '->msg.append;
                             OleClientSite_IID->msg.append;
                             ', '->msg.append;
                             AdviseSink_IID->msg.append;
                             ', '->msg.append;
                             OleWindow_IID->msg.append;
                             ', '->msg.append;
                             OleInPlaceSite_IID->msg.append;
                             ', '->msg.append;
                             OleDocumentSite_IID->msg.append;
                             ;
                             (if false then
                                 'The IID for IMarshal is '->msg.append;
                                 Marshal_IID->msg.append
                             if)
                          #)
                    if)
                 #);
               doAlertUser: (#  exit false #);
               ;
               aGUID: @GUID
            do
               'CSite.QueryInterface'->locateMsg.in;
               interfaceMsg
                 (#  do '++CSite.QueryInterface'->msg.append #);
               ;
               init;
               riid[]->aGUID.binary[];
               (if false then
                   debugMsg
                     (# 
                     do
                        'Csite.QueryInterface: Request for interface '
                          ->msg.append;
                        aGUID->msg.append
                     #)
               if);
               ;
               none ->ppvObject;
               (if true
                // aGUID[]->Unknown_IID.equal then
                   interfaceMsg (#  do '       -IUnknown'->msg.append #)
                // aGUID[]->OleClientSite_IID.equal then
                   interfaceMsg
                     (#  do '       -IOleClientSite'->msg.append #)
                // aGUID[]->AdviseSink_IID.equal then
                   interfaceMsg (#  do '       -IAdviseSink'->msg.append #)
                // aGUID[]->OleWindow_IID.equal then
                   interfaceMsg (#  do '       -IOleWindow'->msg.append #)
                // aGUID[]->OleInPlaceSite_IID.equal then
                   interfaceMsg
                     (#  do '       -IOleInPlaceSite'->msg.append #)
                // aGUID[]->OleDocumentSite_IID.equal then
                   interfaceMsg
                     (#  do '       -IOleDocumentSite'->msg.append #)
               if);
               (if true
                // aGUID[]->Unknown_IID.equal then
                   THIS(IUnknown)[]->ppvObject;
                   (if doAlertUser then
                       (none ,'CSite.QueryInterface IUnknown',none )->alertUser
                   if)
                // aGUID[]->OleClientSite_IID.equal then
                   m_pImpIOleClientSite[]->ppvObject;
                   (if doAlertUser then
                       (none ,'CSite.QueryInterface IOleClientSite',none )
                         ->alertUser
                   if)
                // aGUID[]->AdviseSink_IID.equal then
                   m_pImpIAdviseSink[]->ppvObject;
                   (if doAlertUser then
                       (none ,'CSite.QueryInterface IAdviseSink',none )
                         ->alertUser
                   if)
                // aGUID[]->OleWindow_IID.equal
                // aGUID[]->OleInPlaceSite_IID.equal then
                   m_pImpIOleIPSite[]->ppvObject;
                   (if doAlertUser then
                       (none ,'CSite.QueryInterface IOleWindow/IOleInPlaceSite',
                        none )->alertUser
                   if)
                // aGUID[]->OleDocumentSite_IID.equal then
                   m_pImpIOleDocumentSite[]->ppvObject;
                   (if doAlertUser then
                       (none ,'CSite.QueryInterface IOleDocumentSite',none )
                         ->alertUser
                   if)
               if);
               ;
               (if ppvObject <> none then
                   ppvObject.ref.AddRef; NOERROR->result
                else
                   interfaceMsg
                     (#  do '       -No such interface'->msg.append #);
                   E_NOINTERFACE->result;
                   (if doAlertUser then
                       (none ,'CSite.QueryInterface: No such interface!',none )
                         ->alertUser
                   if)
               if);
               'CSite.QueryInterface'->locateMsg.out
            #);
          AddRef::<
          (*
           STDMETHODIMP_(ULONG) CSite::AddRef(void)
           {
           return ++m_cRef;
           }
           *) 
            (# 
            do
               'CSite.AddRef'->locateMsg.in;
               interfaceMsg
                 (#  do '--CSite.AddRef'->msg.append #);
               m_cRef+1->m_cRef->result;
               'CSite.AddRef'->locateMsg.out
            #);
          Release::<
          (*
           STDMETHODIMP_(ULONG) CSite::Release(void)
           {
           if (0!=--m_cRef)
           return m_cRef;
           
           delete this;
           return 0;
           }
           *) 
            (# 
            do
               'CSite.Release'->locateMsg.in;
               interfaceMsg
                 (#  do '--CSite.Release'->msg.append #);
               m_cRef-1->m_cRef->result;
               'CSite.Release'->locateMsg.out
            #);
          ;
          Create:
          (*
           /*
           * CSite::Create
           *
           * Purpose:
           *  Asks the site to instantiate an object given a filename.
           *  This goes through OleCreateFromFile and will either create
           *  an embedded object or a package (embedded) object.  When
           *  activated, this will either launch the app and activate
           *  as a DocObject, launch the app and open the file, or fail
           *  because no app can open the file.
           *
           * Parameters:
           *  pszFile         LPTSTR of the file from which to create the object.
           *  pIStorage       IStorage * of the parent storage in which we're
           *                  to create an IStorage for the new object.
           *  dwID            DWORD identifier for this site.
           *
           * Return Value:
           *  BOOL            Result of the creation.
           */
           
           BOOL CSite::Create(LPTSTR pszFile, IStorage *pIStorage)
           {
           HRESULT             hr=E_FAIL;
           LPUNKNOWN           pObj;
           
           //Create a new storage for this object (sets m_pIStorage)
           if (!CreateStorage(pIStorage))
           return FALSE;
           
           //Now create an object from the file
           #ifdef UNICODE    
           hr=OleCreateFromFile(CLSID_NULL, pszFile, IID_IUnknown
           , OLERENDER_NONE, NULL, NULL, m_pIStorage, (void ** )&pObj);
           #else
           OLECHAR     szFile[512];    //Assumption on string length
           
           MultiByteToWideChar(CP_ACP, 0, pszFile, -1, szFile, 512);    
           hr=OleCreateFromFile(CLSID_NULL, szFile, IID_IUnknown
           , OLERENDER_NONE, NULL, NULL, m_pIStorage, (void ** )&pObj);
           #endif
           
           //If creation didn't work, get rid of the element Open created.
           if (FAILED(hr))
           {
           Destroy(pIStorage);
           return FALSE;
           }
           
           //We don't get the size if PatronObject data was seen already.
           if (!ObjectInitialize(pObj))
           {
           Destroy(pIStorage);
           return FALSE;
           }
           
           m_fInitialized=TRUE;
           return TRUE;
           }
           *)
            (#
               filename: ^text;
               pIStorage: ^IStorage;
               result: @boolean;
               hr: @HResult;
               pObj: ^IUnknown;
               IID_IUnknown: @IID;
               anIUnknownHolder: @IUnknownHolder;
               awtext: @bstr
            enter (filename[],pIStorage[])
            do
               'CSite.Create'->locateMsg.in;
               locate2msg
                 (#  do 'CSite.Create'->putline #);
               E_FAIL->hr;
               return:
               (* when the C program says "return something",
                we say "something->result; leave return" *)
                 (# 
                 do
                    pIStorage[]->CreateStorage
                      ->result
                      (* Create a new storage for this object (sets m_pIStorage) *)
                      ;
                    (if result = false then
                        'CSite.Create: CreateStorage failed'->putline;
                        leave return
                    if);
                    ;
                    IUnknown_IID->IID_IUnknown;
                    filename[]->awtext.setText;
                    pObj[]->anIUnknownHolder;
                    ((getGUID_NULL).binary[],awtext.wcharptr,
                     IID_IUnknown.binary[],OLERENDER_NONE,0 (* lpFormatEtc *) ,
                     none ,m_pIStorage[],anIUnknownHolder[])->OleCreateFromFile
                      ->hr;
                    anIUnknownHolder->pObj[];
                    debugMsg
                      (# 
                      do
                         (if hr.failed then
                             'CSite.Create: OleCreateFromFile failed'
                               ->msg.append
                          else
                             (if false then
                                 'CSite.Create: OleCreateFromFile succeeded'
                                   ->msg.append
                             if)
                         if)
                      #);
                    ;
                    (if hr.failed then
                    (* If creation didn't work, get rid of the element Open created. *)
                        pIStorage[]->Destroy; false->result; leave return
                    if);
                    ;
                    (if not (pObj[]->ObjectInitialize) then
                    (* We don't get the size if PatronObject data was seen already. *)
                        'ObjectInitialize returned false'->putline;
                        pIStorage[]->Destroy;
                        false->result;
                        leave return
                    if);
                    ;
                    true->m_fInitialized;
                    true->result;
                    leave return
                 #);
               'CSite.Create'->locateMsg.out
            exit result
            #);
          CreateStorage:
          (*
           /*
           * CSite::CreateStorage
           *
           * Purpose:
           *  Creates an sub-storage within a given parent storage,
           *  setting m_pIStorage.
           *
           * Parameters:
           *  pIStorage       IStorage * of the parent storage
           *
           * Return Value:
           *  BOOL            TRUE if creation succeeds, FALSE otherwise.
           */
           
           BOOL CSite::CreateStorage(IStorage *pIStorage)
           {
           HRESULT     hr;
           DWORD       dwMode=STGM_TRANSACTED | STGM_READWRITE
           | STGM_SHARE_EXCLUSIVE;
           TCHAR       szName[32];
           
           if (NULL==pIStorage)
           return FALSE;
           
           /*
           * Attempt to open the storage under this ID.  If there is
           * none, then create it.  In either case we end up with an
           * IStorage that we either save in pPage or release.
           */
           wsprintf(szName, TEXT("Site %lu"), m_dwID);
           
           #ifdef UNICODE
           hr=pIStorage->CreateStorage(szName, dwMode, 0, 0, &m_pIStorage);
           #else
           OLECHAR  szwName[32];
           MultiByteToWideChar(CP_ACP, 0, szName, -1, szwName, 32);    
           hr=pIStorage->CreateStorage(szwName, dwMode, 0, 0, &m_pIStorage);
           #endif
           
           if (FAILED(hr))
           return FALSE;
           
           //Create stream for the object; name is irrelevant
           dwMode=STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
           #ifdef UNICODE
           hr=m_pIStorage->CreateStream(TEXT("\003DocObjInfo"), dwMode, 0, 0
           , &m_pIStream);
           #else    
           MultiByteToWideChar(CP_ACP, 0, "\003DocObjInfo", -1, szwName, 32);    
           hr=m_pIStorage->CreateStream(szwName, dwMode, 0, 0, &m_pIStream);
           #endif
           
           //If we failed to create a stream in the file, do it in memory
           if (FAILED(hr))
           {
           if (FAILED(CreateStreamOnHGlobal(NULL, TRUE, &m_pIStream)))
           return FALSE;
           }
           
           //Create interface implementations
           m_pImpIOleClientSite=new CImpIOleClientSite(this, this);
           m_pImpIAdviseSink=new CImpIAdviseSink(this, this);
           m_pImpIOleIPSite=new CImpIOleInPlaceSite(this, this);
           m_pImpIOleDocumentSite=new CImpIOleDocumentSite(this, this);
           
           if (NULL==m_pImpIOleClientSite || NULL==m_pImpIAdviseSink
           || NULL==m_pImpIOleIPSite || NULL==m_pImpIOleDocumentSite)
           return FALSE;
           
           return TRUE;
           }
           *)
            (#
               result: @boolean;
               pIStorage: ^IStorage (* pointer to the parent storage *) ;
               hr: @HRESULT;
               dwMode: @int32uHolder (* DWORD* *) ;
               szName: @text;
               szName2: [0] @char (* ^text NYI *) (* OLECHAR* *) ;
               anIStorageHolder: @IStorageHolder;
               anIStreamHolder: @IStreamHolder;
               awtext: @bstr
            enter pIStorage[]
            do
               'CSite.CreateStorage'->locateMsg.in;
               locate2msg
                 (#  do 'CSite.CreateStorage'->putline #);
               (STGM_TRANSACTED %Bor STGM_READWRITE %Bor STGM_SHARE_EXCLUSIVE)
                 ->dwMode;
               ;
               return:
               (* When the C program says "return X", 
                we say "X->result; leave return". *)
                 (# 
                 do
                    (if pIStorage[] = none then
                        'CSite.CreateStorage: pIStorage[]=none'->putline;
                        false->result;
                        leave return
                    if);
                    ;
                    'Site '
                      ->szName (* wsprintf(szName, TEXT("Site %lu"), m_dwID); *)
                      ;
                    m_dwID->szName.putint;
                    szName->szName2;
                    ;
                    m_pIStorage[]->anIStorageHolder;
                    callToObjectMsg
                      (# 
                      do
                         'CSite.CreateStorage: kald til CreateStorage'
                           ->msg.append
                      #);
                    (szName2,dwMode,0,0,anIStorageHolder[])
                      ->pIStorage.CreateStorage->hr;
                    callToObjectMsg
                      (# 
                      do
                         'CSite.CreateStorage: kald til CreateStorage returneret'
                           ->msg.append
                      #);
                    anIStorageHolder->m_pIStorage[];
                    (if hr.failed then
                        'CreateStorage failed'->putline;
                        false->result;
                        leave return
                    if);
                    ;
                    (STGM_DIRECT %Bor STGM_READWRITE %Bor STGM_SHARE_EXCLUSIVE)
                      ->dwMode
                      (* Create stream for the object; name is irrelevant *) ;
                    'DocObjInfo'->awtext.settext;
                    callToObjectMsg
                      (# 
                      do
                         'CSite.CreateStorage: kald til CreateStream'
                           ->msg.append
                      #);
                    (awtext.wcharptr,dwMode,0,0,anIStreamHolder[])
                      ->m_pIStorage.CreateStream->hr;
                    callToObjectMsg
                      (# 
                      do
                         'CSite.CreateStorage: kald til CreateStream returneret'
                           ->msg.append
                      #);
                    anIStreamHolder->m_pIStream[];
                    (if hr.failed then
                    (* If we failed to create a stream in the file, do it in memory *)
                        'CreateStream failed'->putline;
                        'CreateStreamOnHGlobal kald'->putline
                    if);
                    ;
                    &CImpOleClientSite[]
                      ->m_pImpIOleClientSite[]
                      (* Create interface implementations *) ;
                    (THIS(CSite)[],THIS(IUnknown)[])
                      ->m_pImpIOleClientSite.constructor;
                    &CImpAdviseSink[]->m_pImpIAdviseSink[];
                    (THIS(CSite)[],THIS(IUnknown)[])
                      ->m_pImpIAdviseSink.constructor;
                    &CImpOleInPlaceSite[]->m_pImpIOleIPSite[];
                    (THIS(CSite)[],THIS(IUnknown)[])
                      ->m_pImpIOleIPSite.constructor;
                    &CImpOleDocumentSite[]->m_pImpIOleDocumentSite[];
                    (THIS(CSite)[],THIS(IUnknown)[])
                      ->m_pImpIOleDocumentSite.constructor;
                    ;
                    (if (m_pImpIOleClientSite[] = none ) or
                    (m_pImpIAdviseSink[] = none ) or
                    (m_pImpIOleIPSite[] = none ) or
                    (m_pImpIOleDocumentSite[] = none ) then
                        false->result; leave return
                    if);
                    ;
                    true->result;
                    leave return
                 #);
               'CSite.CreateStorage'->locateMsg.out
            exit result
            #);
          Close:
          (*
           /*
           * CSite::Close
           *
           * Purpose:
           *  Possibly commits the storage, then releases it, afterwards
           *  frees alls the object pointers.
           *
           * Parameters:
           *  fCommit         BOOL indicating if we're to commit.
           *
           * Return Value:
           *  None
           */
           
           void CSite::Close(BOOL fCommit)
           {
           //OnInPlaceDeactivate releases this pointer.
           if (NULL!=m_pIOleIPObject)
           m_pIOleIPObject->InPlaceDeactivate();
           
           ReleaseInterface(m_pIOleDocView);
           
           if (NULL!=m_pIOleObject)
           {
           m_pIOleObject->Close(fCommit
           ? OLECLOSE_SAVEIFDIRTY : OLECLOSE_NOSAVE);
           ReleaseInterface(m_pIOleObject);
           }
           
           ReleaseInterface(m_pObj);
           ReleaseInterface(m_pIStream);
           ReleaseInterface(m_pIStorage);
           
           return;
           }
           *)
            (# fCommit: @boolean
            enter fCommit
            do
               'CSite.Close'->locateMsg.in;
               locate2msg
                 (#  do 'CSite.Close'->putline #);
               (if m_pIOleIPObject[] <> none then
                   m_pIOleIPObject.InPlaceDeactivate
               if);
               ;
               ReleaseInterface: (* expanded macro *)
                 (# pt: ^IUnknown
                 do
                    m_pIOleDocView[]->pt[];
                    none ->m_pIOleDocView[];
                    (if pt[] <> none then
                        callToObjectMsg
                          (# 
                          do 'CSite.Close: kald til Release'->msg.append
                          #);
                        pt.Release;
                        callToObjectMsg
                          (# 
                          do
                             'CSite.Close: kald til Release returneret'
                               ->msg.append
                          #)
                    if)
                 #);
               ;
               (if m_pIOleObject[] <> none then
                   (if fCommit then
                       callToObjectMsg
                         (# 
                         do 'CSite.Close: kald til Close'->msg.append
                         #);
                       OLECLOSE_SAVEIFDIRTY->m_pIOleObject.close;
                       callToObjectMsg
                         (# 
                         do
                            'CSite.Close: kald til Close returneret'->msg.append
                         #)
                    else
                       callToObjectMsg
                         (# 
                         do 'CSite.Close: kald til Close'->msg.append
                         #);
                       OLECLOSE_NOSAVE->m_pIOleObject.close;
                       callToObjectMsg
                         (# 
                         do
                            'CSite.Close: kald til Close returneret'->msg.append
                         #)
                   if);
                   ReleaseInterface: (* expanded macro *)
                     (# pt: ^IUnknown
                     do
                        m_pIOleObject[]->pt[];
                        none ->m_pIOleObject[];
                        (if pt[] <> none then
                            callToObjectMsg
                              (# 
                              do 'CSite.Close: kald til Release'->msg.append
                              #);
                            pt.Release;
                            callToObjectMsg
                              (# 
                              do
                                 'CSite.Close: kald til Release returneret'
                                   ->msg.append
                              #)
                        if)
                     #)
               if);
               ;
               ReleaseInterface: (* expanded macro *)
                 (# pt: ^IUnknown
                 do
                    m_pObj[]->pt[];
                    none ->m_pObj[];
                    (if pt[] <> none then
                        callToObjectMsg
                          (# 
                          do 'CSite.Close: kald til Release'->msg.append
                          #);
                        pt.Release;
                        callToObjectMsg
                          (# 
                          do
                             'CSite.Close: kald til Release returneret'
                               ->msg.append
                          #)
                    if)
                 #);
               ReleaseInterface: (* expanded macro *)
                 (# pt: ^IUnknown
                 do
                    m_pIStream[]->pt[];
                    none ->m_pIStream[];
                    (if pt[] <> none then
                        callToObjectMsg
                          (# 
                          do 'CSite.Close: kald til Release'->msg.append
                          #);
                        pt.Release;
                        callToObjectMsg
                          (# 
                          do
                             'CSite.Close: kald til Release returneret'
                               ->msg.append
                          #)
                    if)
                 #);
               ReleaseInterface: (* expanded macro *)
                 (# pt: ^IUnknown
                 do
                    m_pIStorage[]->pt[];
                    none ->m_pIStorage[];
                    (if pt[] <> none then
                        callToObjectMsg
                          (# 
                          do 'CSite.Close: kald til Release'->msg.append
                          #);
                        pt.Release;
                        callToObjectMsg
                          (# 
                          do
                             'CSite.Close: kald til Release returneret'
                               ->msg.append
                          #)
                    if)
                 #);
               'CSite.Close'->locateMsg.out
            #);
          Update:
          (*
           /*
           * CSite::Update
           *
           * Purpose:
           *  Forces a commit on the object's storage
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  None
           */
           
           void CSite::Update(void)
           {
           LPPERSISTSTORAGE    pIPS;
           
           if (NULL!=m_pIStorage)
           return;
           
           m_pObj->QueryInterface(IID_IPersistStorage, (void ** )&pIPS);
           OleSave(pIPS, m_pIStorage, TRUE);
           pIPS->SaveCompleted(NULL);
           pIPS->Release();
           
           m_pIStorage->Commit(STGC_DEFAULT);
           return;
           }
           *)
            (# IID_IPersistStorage: @IID; pIPS: ^IPersistStorage
            do
               'CSite.Update'->locateMsg.in;
               locate2msg
                 (#  do 'CSite.Update'->putline #);
               return:
                 (# 
                 do
                    (if m_pIStorage[] <> none then leave return if);
                    ;
                    IPersistStorage_IID->IID_IPersistStorage;
                    callToObjectMsg
                      (# 
                      do 'CSite.Update: kald til QueryInterface'->msg.append
                      #);
                    (m_pObj[],IID_IPersistStorage[])->Query->pIPS[];
                    callToObjectMsg
                      (# 
                      do
                         'CSite.Update: kald til QueryInterface returneret'
                           ->msg.append
                      #);
                    (pIPS[],m_pIStorage[],true)->OleSave;
                    callToObjectMsg
                      (# 
                      do
                         'CSite.Update: kald til SaveCompleted+Release'
                           ->msg.append
                      #);
                    none ->pIPS.SaveCompleted;
                    pIPS.Release;
                    callToObjectMsg
                      (# 
                      do
                         'CSite.Update: kald til SaveCompleted+Release returneret'
                           ->msg.append
                      #);
                    ;
                    STGC_DEFAULT->m_pIStorage.Commit;
                    leave return
                 #);
               'CSite.Update'->locateMsg.out
            #);
          Destroy:
          (*
           /*
           * CSite::Destroy
           *
           * Purpose:
           *  Removes this storage from the parent storage.  The caller should
           *  eventually delete this CSite object to free the object herein.
           *  Nothing is committed when being destroyed.
           *
           * Parameters:
           *  pIStorage       IStorage * of the parent
           *
           * Return Value:
           *  None
           */
           
           void CSite::Destroy(IStorage *pIStorage)
           {
           TCHAR     szName[32];
           
           if (NULL==pIStorage)
           return;
           
           if (NULL!=m_pObj)
           Close(FALSE);
           
           wsprintf(szName, TEXT("Site %lu"), m_dwID);
           #ifdef UNICODE
           pIStorage->DestroyElement(szName);
           #else
           OLECHAR  szwName[32];
           MultiByteToWideChar(CP_ACP, 0, szName, -1, szwName, 512);    
           pIStorage->DestroyElement(szwName);    
           #endif
           return;
           }
           *)
            (# pIStorage: ^IStorage
            enter pIStorage[]
            do
               'CSite.Destroy'->locateMsg.in;
               locate2msg
                 (#  do 'CSite.Destroy'->putline #);
               return:
                 (#
                    szName2: @text;
                    szName: [0] @char (* ^text NYI *) (* OLECHAR* *)
                 do
                    (if pIStorage[] = none then leave return if);
                    ;
                    (if m_pObj[] <> none then false->close if);
                    ;
                    'Site '->szName2;
                    m_dwID->szName2.putint;
                    szName2->szName;
                    szName->pIStorage.DestroyElement;
                    ;
                    leave return
                 #);
               'CSite.Destroy'->locateMsg.out
            #);
          rc: @struct_tagRECT;
          Activate:
          (*
           /*
           * CSite::Activate
           *
           * Purpose:
           *  Activates a verb on the object living in the site.
           *
           * Parameters:
           *  iVerb           LONG of the verb to execute.
           *
           * Return Value:
           *  None
           */
           
           void CSite::Activate(LONG iVerb)
           {
           CHourglass *pHour;
           RECT        rc;
           
           pHour=new CHourglass;
           
           GetClientRect(m_hWnd, &rc);
           m_pIOleObject->DoVerb(iVerb, NULL, m_pImpIOleClientSite, 0
           , m_hWnd, &rc);
           
           delete pHour;
           return;
           }
           *)
            (# iVerb: @int32; aint32holder: @int32Holder; hr: @HResult
            enter iVerb
            do
               'CSite.Activate'->locateMsg.in;
               locate2msg
                 (#  do 'CSite.Activate'->putline #);
               (* m_hWnd->aint32holder *)
               ;
               m_hWnd->Aint32holder;
               (aInt32Holder[],rc[])->GetClientRect3;
               aint32holder->m_hWnd;
               debugMsg
                 (# 
                 do
                    (if false then
                        'GetClientRect3: '->msg.append;
                        rc.top->msg.putint;
                        ','->msg.append;
                        rc.bottom->msg.putint;
                        ','->msg.append;
                        rc.left->msg.putint;
                        ','->msg.append;
                        rc.right->msg.putint
                    if)
                 #);
               (* 16->malloc->theNtRectPtr;
                (if theNtRectPtr <> 0 then
                (windowID,theNtRectPtr)->GetClientRect; theNtRectPtr->free; 
                else
                false->didSomething; 
                if);    aint32holder->m_hWnd;
                *)
               ;
               m_hWnd->Aint32holder;
               (if false then
                   (none ,'Calling OleObject.DoVerb... ',none )->alertUser
               if);
               callToObjectMsg
                 (#  do 'CSite.Activate: kald til DoVerb'->msg.append #);
               (iVerb,none ,m_pImpIOleClientSite[],0,aInt32holder[],rc[])
                 ->m_pIOleObject.DoVerb->hr;
               callToObjectMsg
                 (# 
                 do 'CSite.Activate: kald til DoVerb returneret'->msg.append
                 #);
               (if false then
                   (none ,'AFTER calling OleObject.DoVerb... ',none )->alertUser
               if);
               aint32holder->m_hWnd;
               debugMsg
                 (# 
                 do
                    (if hr.succeeded then
                        'OleObject.DoVerb succeeded'->msg.append;
                        (if false then
                            (none ,'OleObject.DoVerb succeeded',none )
                              ->alertUser
                        if)
                     else
                        'OleObject.DoVerb failed '->msg.append;
                        (if false then
                            (none ,'OleObject.DoVerb failed',none )->alertUser
                        if);
                        (if false then
                            'OleObject.DoVerb failed '->puttext;
                            hr.value->myprint
                        if)
                    if)
                 #);
               'CSite.Activate'->locateMsg.out
            #);
          UpdateObjectRects:
          (*
           /*
           * CSite::UpdateObjectRects
           *
           * Purpose:
           *  Informs the site that the client area window was resized and
           *  that the site needs to also tell the DocObject of the resize.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  None
           */
           
           void CSite::UpdateObjectRects(void)
           {
           RECT    rc;
           
           if (NULL==m_pIOleDocView)
           return;
           
           GetClientRect(m_hWnd, &rc);
           m_pIOleDocView->SetRect(&rc);
           return;
           }
           *)
            (# 
            do
               'CSite.UpdateObjectRects'->locateMsg.in;
               locate2msg
                 (#  do 'CSite.UpdateObjectRects'->putline #);
               return:
                 (# 
                 do
                    (if m_pIOleDocView[] = none then leave return if);
                    ;
                    'GetClientRect(m_hWnd, &rc)'->putline;
                    'm_pIOleDocView->SetRect(&rc)'->putline
                 #);
               'CSite.UpdateObjectRects'->locateMsg.out
            #)
       #);
     ;
     CFrameType: IUnknown
       (#
          PROTECTED: (#  #);
          m_hInst: (* Task instance.
                    =HINSTANCE *) (#  exit uienvHInstance #);
          m_hWnd: (* Window handle of the window.
                   =HWND *)
            (# handle: @integer
            do
               (if mainWindow[] <> none then
                   mainWindow.InterfaceObjectID->handle;
                   debugMsg
                     (# 
                     do
                        'CFrame.m_hWnd: handle='->msg.append; handle->msg.putint
                     #)
                else
                   debugMsg
                     (# 
                     do 'CFrame.m_hWnd: mainWindow[]=none'->msg.append
                     #);
                   117->handle
               if)
            exit handle
            #);
          m_cRef: (* =ULONG *) @integer;
          ;
          m_hInstPrev: (* WinMain parameters.
                        =HINSTANCE *) @integer;
          m_pszCmdLine: (* =LPTSTR *) @ (#  #);
          m_nCmdShow: (* =int *) @integer;
          ;
          m_phMenu: (* Popup menu handles.
                     =HMENU* *)
            (# 
            exit mainWindow.private.theWin32Menubar.interfaceObjectID
            #);
          m_hAccel: (* Accelerators.
                     =HACCEL *) @integer;
          m_hWndClient: (* Client area window.
                         =HWND *)
            (# handle: @integer
            do
               (if mainWindow[] <> none then
                   mainWindow.clientCanvas.InterfaceObjectID->handle;
                   debugMsg
                     (# 
                     do
                        (if false then
                            'CFrame.m_hWndClient: handle='->msg.append;
                            handle->msg.putint
                        if)
                     #)
                else
                   'CFrame.m_hWndClient: mainWindow[]=none'->putline
               if)
            exit handle
            #);
          ;
          m_fInitialized: (* OleInitialize called?.
                           =BOOL *) @boolean;
          m_pIStorage:
          (* Temp file for all needs.
           =IStorage* *) ^IStorage;
          m_dwIDCounter: (* For site IDs.
                          =DWORD *) @integer;
          ;
          m_hMenuOrg: (* Original menu.
                       =HMENU *) @integer;
          m_hMenuTop: (* Currently shown menu.
                       =HMENU *) @integer;
          m_hMenuHelp: (* Special Help menu.
                        =HMENU *) @integer;
          m_fUsingOurHelp: (* Help menu in use?
                            =BOOL *) @boolean;
          m_fInObjectHelp: (* Object's menu found?
                            =BOOL *) @boolean;
          m_fOurMenuShowing: (* Our menu up?
                              =BOOL *) @boolean;
          ;
          m_fHaveObject:
          (* For menu enabling.
           =BOOL *) @boolean;
          m_hWndObj: (* UI Active object.
                      =HWND *) @integer;
          ;
          m_pSite: (* Site holding object.
                    =class CSite * *) ^CSite;
          m_bwIP:
          (* In/place tool allocations.
           =BORDERWIDTHS *) @integer;
          m_fInContextHelp: (* In context help mode?
                             =BOOL *) @boolean;
          ;
          m_pIOleIPActiveObject: (* =IOleInPlaceActiveObject* *)
            ^IOleInPlaceActiveObject;
          ;
          ;
          PROTECTED_: (#  #);
          RegisterAllClasses:
          (*
           /*
           * CFrame::RegisterAllClasses
           *
           * Purpose:
           *  Registers all classes used in this application.
           *
           * Return Value:
           *  BOOL            TRUE if registration succeeded, FALSE otherwise.
           */
           
           BOOL CFrame::RegisterAllClasses(void)
           {
           WNDCLASS        wc;
           
           //Field that are the same for all windows.
           wc.style         = CS_HREDRAW | CS_VREDRAW;
           wc.hInstance     = m_hInst;
           wc.cbClsExtra    = 0;
           
           //Register the Frame window
           wc.lpfnWndProc   = FrameWndProc;
           wc.cbWndExtra    = CBFRAMEWNDEXTRA;
           wc.hIcon         = LoadIcon(m_hInst, TEXT("Icon"));
           wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
           wc.hbrBackground = NULL;
           wc.lpszMenuName  = MAKEINTRESOURCE(IDR_MENU);
           wc.lpszClassName = SZCLASSFRAME;
           
           if (!RegisterClass(&wc))
           return FALSE;
           
           
           //Register the do-nothing Client window
           wc.lpfnWndProc   = ClientWndProc;
           wc.cbWndExtra    = CBCLIENTWNDEXTRA;
           wc.hIcon         = NULL;
           wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
           wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
           wc.lpszMenuName  = NULL;
           wc.lpszClassName = SZCLASSCLIENT;
           
           if (!RegisterClass(&wc))
           return FALSE;
           
           return TRUE;
           }
           *)
            (# result: @boolean
            do
               'CFrame.RegisterAllClasses'->locateMsg.in;
               locate2msg
                 (# 
                 do 'CFrame.RegisterAllClasses (not implemented)'->putline
                 #);
               'CFrame.RegisterAllClasses'->locateMsg.out
            exit result
            #);
          CreateObject:
          (*
           /*
           * CFrame::CreateObject
           *
           * Purpose:
           *  Creates a site and has it create an object based on a filename.
           *
           * Parameters:
           *  pszFile         LPTSTR pointing to the filename from which to
           *                  create the object.
           *
           * Return Value:
           *  BOOL            TRUE if successful, FALSE otherwise.
           */
           
           BOOL CFrame::CreateObject(LPTSTR pszFile)
           {    
           m_pSite=new CSite(++m_dwIDCounter, m_hWndClient, this);
           
           if (NULL==m_pSite)
           return FALSE;
           
           m_pSite->AddRef();  //So we can free with Release
           
           /*
           * Now tell the site to create an object in it using the filename
           * and the storage we opened.  The site will create a sub-storage
           * for the doc object's use.
           */
           if (!m_pSite->Create(pszFile, m_pIStorage))
           return FALSE;
           
           m_fHaveObject=TRUE;
           
           //We created the thing, now activate it with "Show"
           m_pSite->Activate(OLEIVERB_SHOW);
           
           //Force repaint to show "have object" message
           InvalidateRect(m_hWndClient, NULL, TRUE);
           UpdateWindow(m_hWndClient);
           return TRUE;        
           }
           *)
            (# filename: ^text; result: @boolean
            enter filename[]
            do
               'CFrame.CreateObject'->locateMsg.in;
               locate2msg
                 (# 
                 do
                    'CFrame.CreateObject (filename='->puttext;
                    filename[]->puttext;
                    ')'->putline
                 #);
               return:
                 (# 
                 do
                    &CSite[]->m_pSite[];
                    m_dwIDCounter+1->m_dwIDCounter;
                    (m_dwIDCounter,m_hWndClient,THIS(CFrameType)[])
                      ->m_pSite.constructor;
                    m_pSite.AddRef;
                    ;
                    (filename[],m_pIStorage[])->m_pSite.Create->result;
                    (if not result then
                        'CFrame.CreateObject: m_pSite.Create returned false'
                          ->putline;
                        leave return
                    if);
                    ;
                    true->m_fHaveObject;
                    ;
                    OLEIVERB_SHOW->m_pSite.Activate;
                    ;
                    (m_hWndClient,0,true)->InvalidateRect;
                    m_hWndClient->UpdateWindow;
                    true->result;
                    leave return
                 #);
               'CFrame.CreateObject'->locateMsg.out
            exit result
            #);
          ResizeClientWindow:
          (*
           /*
           * CFrame::ResizeClientWindow
           *
           * Purpose:
           *Resizes the client-area window according to current toolbar sizes
           *  and the frame window size.
           *
           * Parameters:
           *x,y,cx,cyUINT origin and dimensions of the window
           *
           * Return Value:
           *None
           */
           
           void CFrame::ResizeClientWindow(UINT x, UINT y, UINT cx, UINT cy)
           {
           SetWindowPos(m_hWndClient, NULL, x, y, cx, cy    
           , SWP_NOZORDER | SWP_NOACTIVATE);
           
           //Tell the site to tell the object.
           if (NULL!=m_pSite)
           m_pSite->UpdateObjectRects();
           
           return;
           }
           *)
            (# 
            do
               'CFrame.ResizeClientWindow'->locateMsg.in;
               locate2msg
                 (#  do 'CFrame.ResizeClientWindow'->putline #);
               'CFrame.ResizeClientWindow'->locateMsg.out
            #);
          ;
          ;
          PUBLIC_: (#  #);
          Instance:
          (*
           inline HINSTANCE Instance(void)
           { return m_hInst; }
           *) (#  exit m_hInst #);
          Window_:
          (*
           inline HWND      Window(void)
           { return m_hWnd; }        
           *) (#  exit m_hWnd #);
          Accelerators:
          (*
           inline HACCEL    Accelerators(void)
           { return m_hAccel; }        
           *) (#  exit m_hAccel #);
          Init:
          (*
           /*
           * CFrame::Init
           *
           * Purpose:
           *  Initializer for a CFrame object containing anything prone to
           *  failure.
           *
           * Parameters:
           *  cMenus          UINT number of menus on the frame
           *  x, y, cx, cy    int location and size of frame window 
           *
           * Return Value:
           *  BOOL            TRUE if initialization succeeded, FALSE
           *                  otherwise. If FALSE is returned, the caller must
           *                  guarantee that the destructor is called promptly
           *                  to insure cleanup.
           */
           
           BOOL CFrame::Init(UINT cMenus, int x, int y, int cx, int cy)
           {
           HMENU               hMenu;
           UINT                uTemp;
           RECT                rc;
           
           //1.  Initialize OLE
           if (SUCCEEDED(OleInitialize(NULL)))
           m_fInitialized=TRUE;
           else
           return FALSE;
           
           
           //2.  Register window classes
           if (NULL==m_hInstPrev)
           {
           if (!RegisterAllClasses())
           return FALSE;
           }
           
           
           //3.  Create the main window and client-area window
           m_hWnd=CreateWindow(SZCLASSFRAME, TEXT("DocObject Framer")
           , WS_MINIMIZEBOX | WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN
           , x, y, cx, cy, NULL, NULL, m_hInst, this);
           
           if (NULL==m_hWnd)
           return FALSE;
           
           GetClientRect(m_hWnd, &rc);
           
           m_hWndClient=CreateWindow(SZCLASSCLIENT, SZCLASSCLIENT
           , WS_CHILD | WS_CLIPCHILDREN | WS_VISIBLE | WS_CLIPSIBLINGS
           , rc.left, rc.top, rc.right-rc.left
           , rc.bottom-rc.top, m_hWnd, NULL, m_hInst, this);
           
           if (NULL==m_hWndClient)
           return FALSE;
           
           //4. Allocate menu array for use with in-place menu merging.
           m_phMenu=new HMENU[cMenus];
           hMenu=GetMenu(m_hWnd);
           m_hMenuOrg=hMenu;
           
           for (uTemp=0; uTemp < cMenus; uTemp++)
           m_phMenu[uTemp]=GetSubMenu(hMenu, uTemp);
           
           //Also load the special help menu
           m_hMenuHelp=LoadMenu(m_hInst
           , MAKEINTRESOURCE(IDR_MENUHELP));
           
           //5.  Load accelerators
           m_hAccel=LoadAccelerators(m_hInst
           , MAKEINTRESOURCE(IDR_ACCELERATORS));
           
           if (NULL==m_hAccel)
           return FALSE;
           
           
           //6.  Make us all visible.
           ShowWindow(m_hWnd, m_nCmdShow);
           UpdateWindow(m_hWnd);
           
           
           /*
           * 7.  Create a temp file for all embedded files.  Note that in this
           *     sample we don't save any changes to DocObjects because we 
           *     don't manage any storage directly.
           */  
           if (FAILED(StgCreateDocfile(NULL, STGM_TRANSACTED | STGM_READWRITE
           | STGM_SHARE_EXCLUSIVE | STGM_CREATE| STGM_DELETEONRELEASE
           , 0, &m_pIStorage)))
           return FALSE;
           
           return TRUE;
           }
           *)
            (#
               result: @boolean;
               hr: @HRESULT;
               anIStorageHolder: @IStorageHolder;
               docFileMode: @integer
            do
               'CFrame.Init'->locateMsg.in;
               locate2msg
                 (#  do 'CFrame.Init'->putline #);
               return:
                 (# abc: (#  #); hMenu: @integer
                 do (* 1. Initialize OLE *)
                    0->OleInitialize->hr;
                    (if hr.succeeded then
                        true->m_fInitialized
                     else
                        false->result; leave return
                    if);
                    ;
                    (* 2. Register window classes *)
                    (if m_hInstPrev = 0 then
                        (if not RegisterAllClasses then
                            false->result; leave return
                        if)
                    if);
                    ;
                    (* 3. Create the main window and client-area window *)
                    &MainWindowType[]->mainWindow[];
                    mainWindow.open;
                    mainWindow.private.theWin32Menubar.InterfaceObjectID->hMenu
                      ->m_hMenuOrg;
                    (if false then
                        'hMenuOrg: '->puttext; m_hMenuOrg->putint; newline
                    if);
                    ;
                    (* 4. Allocate menu array for use with in-place menu merging. *)
                    abc;
                    (* Also load the special help menu *)
                    abc;
                    ;
                    (* 5. Load accelerators *)
                    abc;
                    ;
                    (* 6. Make us all visible. *)
                    abc;
                    ;
                    (* 7. Create a temp file for all embedded files. Note that in this
                     sample we don't save any changes to DocObjects because we
                     don't manage any storage directly. *)
                    STGM_TRANSACTED %Bor STGM_READWRITE
                    %Bor
                      STGM_SHARE_EXCLUSIVE
                    %Bor
                      STGM_CREATE
                    %Bor
                      STGM_DELETEONRELEASE->docFileMode;
                    (none ,docFileMode,0,anIStorageHolder[])->StgCreateDocfile
                      ->hr;
                    anIStorageHolder->m_pIStorage[];
                    (if m_pIStorage[] = none then
                        'CFrame.Init: StgCreateDocFile failed'->putline
                    if);
                    (if hr.failed then false->result; leave return if);
                    ;
                    true->result;
                    leave return
                 #);
               &COleInPlaceFrame[]->theOleInPlaceFrame[];
               'CFrame.Init'->locateMsg.out
            exit result
            #);
          Close:
          (*
           /*
           * CFrame::Close
           *
           * Purpose:
           *  Handles File/Close by freeing the object and resetting the
           *  application state.
           *
           * Parameters:
           *  None
           *
           * Return Value:
           *  None
           */
           
           void CFrame::Close(void)
           {    
           RECTrc;
           
           if (NULL!=m_pSite)
           {
           CSite *pSite=m_pSite;        //Prevents reentry
           m_pSite=NULL;
           
           pSite->Close(FALSE);         //Frees the object
           pSite->Destroy(m_pIStorage); //Cleans up the storage
           pSite->Release();            //Frees the site        
           }
           
           m_fHaveObject=FALSE;
           SetRect(&m_bwIP, 0, 0, 0, 0);
           
           GetClientRect(m_hWnd, &rc);
           ResizeClientWindow(rc.left, rc.top, rc.right-rc.left
           , rc.bottom-rc.top);
           
           //Force repaint to remove "have object" message
           InvalidateRect(m_hWndClient, NULL, TRUE);
           UpdateWindow(m_hWndClient);
           
           return;        
           }
           *)
            (# pSite: ^CSite
            do
               'CFrame.Close'->locateMsg.in;
               locate2msg
                 (#  do 'CFrame.Close'->putline #);
               (if m_pSite[] <> none then
                   m_pSite[]->pSite[] (* Prevents reentry *) ;
                   none ->m_pSite[];
                   ;
                   false->pSite.close (* Frees the object *) ;
                   m_pIStorage[]->pSite.destroy (* cleans up the storage *) ;
                   pSite.release (* frees the site *)
               if);
               ;
               false->m_fHaveObject;
               ;
               mainWindow.update;
               'CFrame.Close'->locateMsg.out
            #);
          ;
          ;
          PUBLIC: (* se framer.h *) (#  #);
          constructor:
          (*
           /*
           * CFrame::CFrame
           * CFrame::~CFrame
           *
           * Constructor Parameters:
           *  hInst           HINSTANCE from WinMain
           *  hInstPrev       HINSTANCE from WinMain
           *  pszCmdLine      LPSTR from WinMain
           *  nCmdShow        int from WinMain
           */
           
           CFrame::CFrame(HINSTANCE hInst, HINSTANCE hInstPrev
           , LPSTR pszCmdLine, int nCmdShow)    
           {
           m_hInst=hInst;
           m_hWnd=NULL;
           m_hInstPrev=hInstPrev;
           m_nCmdShow=nCmdShow;
           
           m_phMenu=NULL;
           m_hAccel=NULL;
           m_hWndClient=NULL;
           
           m_fInitialized=FALSE;
           m_pIStorage=NULL;
           m_dwIDCounter=0;
           
           m_hMenuOrg=NULL;
           m_hMenuTop=NULL;
           m_hMenuHelp=NULL;
           m_fInObjectHelp=FALSE;
           m_fUsingOurHelp=FALSE;
           
           m_fHaveObject=FALSE;
           m_hWndObj=NULL;
           
           m_pSite=NULL;
           m_fOurMenuShowing=TRUE;
           SetRect(&m_bwIP, 0, 0, 0, 0);
           m_fInContextHelp=FALSE;
           m_pIOleIPActiveObject=NULL;
           
           return;
           }
           *)
            (#
               hInst: @integer;
               hInstPrev: @integer;
               pszCmdLine: ^text;
               nCmdShow: @integer
            enter (hInst,hInstPrev,pszCmdLine[],nCmdShow)
            do (* hInst->m_hInst;
                0->m_hWnd;*)
               locate2msg
                 (#  do 'CFrame.Constructor'->putline #);
               hInstPrev->m_hInstPrev;
               nCmdShow->m_nCmdShow;
               ;
               0->m_hAccel;
               ;
               false->m_fInitialized;
               none ->m_pIStorage[];
               0->m_dwIDCounter;
               ;
               0->m_hMenuOrg;
               0->m_hMenuTop;
               0->m_hMenuHelp;
               false->m_fInObjectHelp;
               false->m_fUsingOurHelp;
               ;
               false->m_fHaveObject;
               0->m_hWndObj;
               ;
               none ->m_pSite[];
               true->m_fOurMenuShowing;
               SHOULD_HANDLE_SetRect: (#  #);
               false->m_fInContextHelp;
               none ->m_pIOleIPActiveObject[]
            #);
          destructor:
          (*
           CFrame::~CFrame(void)
           {
           if (NULL!=m_hWndClient)
           DestroyWindow(m_hWndClient);
           
           //Frees the temp file.
           ReleaseInterface(m_pIStorage);
           
           //m_pSite cleaned up in Close
           
           //Accelerators freed automatically.
           
           //Destroy the special help menu
           if (NULL!=m_hMenuHelp)
           DestroyMenu(m_hMenuHelp);
           
           //Free the menu handle array
           if (NULL!=m_phMenu)
           delete []((UINT * )m_phMenu);
           
           if (m_fInitialized)
           OleUninitialize();
           
           return;
           }
           *)
            (# 
            do
               locate2msg
                 (#  do 'CFrame.Destructor'->putline #);
               ;
               (* (if m_hWndClient[] <> none then
                m_hWndClient[]->DestroyWindow
                if)*)
               ;
               ReleaseInterface: (* expanded macro *)
                 (# pt: ^IUnknown
                 do
                    m_pIStorage[]->pt[];
                    none ->m_pIStorage[];
                    (if pt[] <> none then pt.Release if)
                 #)
                 (* Frees the temp file *)
                 ;
               ;
               (* m_pSite cleaned up in Close
                Accelerators freed automatically *)
               ;
               'DestroyMenu'
               (* Destroy the special help menu *)
               ;
               'free menu handle array';
               ;
               (if m_fInitialized then OleUninitialize if)
            #);
          QueryInterface::<
          (*
           STDMETHODIMP CFrame::QueryInterface(REFIID riid, void **ppv)
           {
           /*
           * We only know IOleInPlaceFrame and its base interfaces as well
           * as a bogus IOleCommandTarget to make PowerPoint happy.
           */
           *ppv=NULL;
           
           if (IID_IUnknown==riid || IID_IOleInPlaceUIWindow==riid
           || IID_IOleWindow==riid || IID_IOleInPlaceFrame==riid)
           *ppv=(IOleInPlaceFrame * )this;
           
           if (IID_IOleCommandTarget==riid)
           *ppv=(IOleCommandTarget * )this;
           
           if (NULL!=*ppv)
           {
           ((LPUNKNOWN)*ppv)->AddRef();
           return NOERROR;
           }
           
           return E_NOINTERFACE;
           }
           *) 
            (#
               Unknown_IID,OleInPlaceUIWindow_IID,OleWindow_IID,
                 OleInPlaceFrame_IID,OleCommandTarget_IID: @IID;
               init:
                 (# 
                 do
                    IUnknown_IID->Unknown_IID;
                    IOleInPlaceUIWindow_IID->OleInPlaceUIWindow_IID;
                    IOleWindow_IID->OleWindow_IID;
                    IOleInPlaceFrame_IID->OleInPlaceFrame_IID;
                    IOleCommandTarget_IID->OleCommandTarget_IID;
                    ;
                    (if true then
                        debugMsg
                          (# 
                          do
                             'CFrame.QueryInterface supports: '->msg.append;
                             Unknown_IID->msg.append;
                             ', '->msg.append;
                             OleInPlaceUIWindow_IID->msg.append;
                             ', '->msg.append;
                             OleWindow_IID->msg.append;
                             ', '->msg.append;
                             OleInPlaceFrame_IID->msg.append;
                             ', '->msg.append;
                             OleCommandTarget_IID->msg.append
                          #)
                    if)
                 #);
               doAlertUser: (#  exit false #);
               ;
               aGUID: @GUID
            do
               interfaceMsg
                 (#  do '++CFrame.QueryInterface'->msg.append #);
               ;
               init;
               riid[]->aGUID.binary[];
               (if true then
                   debugMsg
                     (# 
                     do
                        'CFrame.QueryInterface: Request for interface '
                          ->msg.append;
                        aGUID->msg.append
                     #)
               if);
               ;
               none ->ppvObject;
               (if true
                // aGUID[]->Unknown_IID.equal then
                   interfaceMsg (#  do '        -IUnknown'->msg.append #)
                // aGUID[]->OleInPlaceUIWindow_IID.equal then
                   interfaceMsg
                     (#  do '        -IOleInPlaceUIWindow'->msg.append #)
                // aGUID[]->OleWindow_IID.equal then
                   interfaceMsg (#  do '        -IOleWindow'->msg.append #)
                // aGUID[]->OleInPlaceFrame_IID.equal then
                   interfaceMsg
                     (#  do '        -IOleInPlaceFrame'->msg.append #)
                // aGUID[]->OleCommandTarget_IID.equal then
                   interfaceMsg
                     (#  do '        -IOleCommandTarget'->msg.append #)
               if);
               (if true
                // aGUID[]->Unknown_IID.equal
                // aGUID[]->OleInPlaceUIWindow_IID.equal
                // aGUID[]->OleWindow_IID.equal
                // aGUID[]->OleInPlaceFrame_IID.equal then
                   (if false then
                       interfaceMsg
                         (# 
                         do
                            '        -IUnknown / IOleInPlaceUIWindow / IOleWindow / IOleInPlaceFrame'
                              ->msg.append
                         #)
                   if);
                   theOleInPlaceFrame[]->ppvObject;
                   (if doAlertUser then
                       (none ,
                        'CFrame.QueryInterface:\nIUnknown / IOleInPlaceUIWindow / IOleWindow / IOleInPlaceFrame',
                        none )->alertUser
                   if)
                // aGUID[]->OleCommandTarget_IID.equal then
                   (if false then
                       interfaceMsg
                         (#  do '        -IOleCommandTarget'->msg.append #)
                   if);
                   theOleCommandTarget[]->ppvObject;
                   (if doAlertUser then
                       (none ,'CFrame.QueryInterface IOleCommandTarget',none )
                         ->alertUser
                   if)
               if);
               ;
               (if ppvObject <> none then
                   ppvObject.ref.AddRef; NOERROR->result
                else
                   interfaceMsg
                     (#  do '        -No such interface'->msg.append #);
                   E_NOINTERFACE->result;
                   (if doAlertUser then
                       (none ,'CFrame.QueryInterface: No such interface!',none )
                         ->alertUser
                   if)
               if)
            #);
          AddRef::<
          (*
           STDMETHODIMP_(ULONG) CFrame::AddRef(void)
           {
           return ++m_cRef;
           }
           *) 
            (# 
            do
               interfaceMsg
                 (# 
                 do
                    '--CFrame.AddRef ('->msg.append;
                    m_cRef+1->msg.putint;
                    ')'->msg.append
                 #);
               m_cRef+1->m_cRef->result
            #);
          Release::<
          (*
           STDMETHODIMP_(ULONG) CFrame::Release(void)
           {
           //Nothing special happening here--frame's life if user-controlled.
           return --m_cRef;
           }
           *) 
            (# 
            do
               interfaceMsg
                 (# 
                 do
                    '--CFrame.Release ('->msg.append;
                    m_cRef-1->msg.putint;
                    ')'->msg.append
                 #);
               m_cRef-1->m_cRef->result
            #);
          ;
          theOleInPlaceFrame: ^COleInPlaceFrame;
          COleInPlaceFrame: IOleInPlaceFrame
            (#
               QueryInterface::< 
                 (# 
                 do
                    (riid[],ppvObject[])->THIS(CFrameType).QueryInterface
                      ->result
                 #);
               AddRef::<  (#  do THIS(CFrameType).AddRef->result #);
               Release::<  (#  do THIS(CFrameType).Release->result #);
               ;
               GetWindow::<
               (* /*
                * CFrame::GetWindow
                *
                * Purpose:
                *  Retrieves the handle of the window associated with the object
                *  on which this interface is implemented.
                *
                * Parameters:
                *  phWnd           HWND * in which to store the window handle.
                *
                * Return Value:
                *  HRESULT         NOERROR if successful, E_FAIL if there is no
                *                  window.
                */
                
                STDMETHODIMP CFrame::GetWindow(HWND *phWnd)
                {
                *phWnd=m_hWnd;
                return NOERROR;
                } *) 
                 (# 
                 do
                    interfaceMsg
                      (#  do 'OleInPlaceFrame.GetWindow'->msg.append #);
                    m_hWnd->phWnd;
                    NOERROR->result
                 #);
               ContextSensitiveHelp::<
               (* /*
                * CFrame::ContextSensitiveHelp
                *
                * Purpose:
                *  Instructs the object on which this interface is implemented to
                *  enter or leave a context-sensitive help mode.
                *
                * Parameters:
                *  fEnterMode      BOOL TRUE to enter the mode, FALSE otherwise.
                *
                * Return Value:
                *  HRESULT         NOERROR
                */
                
                STDMETHODIMP CFrame::ContextSensitiveHelp(BOOL fEnterMode)
                {
                /*
                * Don't bother if there is no active object since we don't do
                * context help on our own.
                */
                if (NULL==m_pIOleIPActiveObject)
                return NOERROR;
                
                //If the state changes, notify the active object.
                if (m_fInContextHelp!=fEnterMode)
                {
                m_fInContextHelp=fEnterMode;
                m_pIOleIPActiveObject->ContextSensitiveHelp(fEnterMode);
                }
                
                return NOERROR;
                }
                *) 
                 (# 
                 do
                    interfaceMsg
                      (# 
                      do 'OleInPlaceFrame.ContextSensitiveHelp'->msg.append
                      #);
                    return:
                      (# 
                      do
                         (if m_pIOleIPActiveObject[] = none then
                         (* Don't bother if there is no active object since we don't do
                          context help on our own. *)
                             NOERROR->result; leave return
                         if);
                         ;
                         (if m_fInContextHelp <> fEnterMode then
                             fEnterMode->m_fInContextHelp;
                             fEnterMode
                               ->m_pIOleIPActiveObject.ContextSensitiveHelp
                         if);
                         ;
                         NOERROR->result;
                         leave return
                      #)
                 #);
               GetBorder::<
               (* /*
                * CFrame::GetBorder
                *
                * Purpose:
                *  Returns the rectangle in which the container is willing to
                *  negotiate about an object's adornments.
                *
                * Parameters:
                *  prcBorder       LPRECT in which to store the rectangle.
                *
                * Return Value:
                *  HRESULT         NOERROR if all is well, INPLACE_E_NOTOOLSPACE
                *                  if there is no negotiable space.
                */
                
                STDMETHODIMP CFrame::GetBorder(LPRECT prcBorder)
                {
                if (NULL==prcBorder)
                return E_INVALIDARG;
                
                //We return all the client area space
                GetClientRect(m_hWnd, prcBorder);
                return NOERROR;
                }
                *) 
                 (# anInt32Holder: @int32holder
                 do
                    interfaceMsg
                      (#  do 'OleInPlaceFrame.GetBorder'->msg.append #);
                    return:
                      (# 
                      do
                         (if lpRectBorder[] = none then
                             E_INVALIDARG->result; leave return
                         if);
                         ;
                         m_hWnd->anInt32Holder;
                         (anInt32Holder[],lpRectBorder[])->GetClientRect3;
                         NOERROR->result;
                         leave return
                      #)
                 #);
               RequestBorderSpace::<
               (* /*
                * CFrame::RequestBorderSpace
                *
                * Purpose:
                *  Asks the container if it can surrender the amount of space
                *  in pBW that the object would like for it's adornments.  The
                *  container does nothing but validate the spaces on this call.
                *
                * Parameters:
                *  pBW             LPCBORDERWIDTHS containing the requested space.
                *                  The values are the amount of space requested
                *                  from each side of the relevant window.
                *
                * Return Value:
                *  HRESULT         NOERROR if we can give up space,
                *                  INPLACE_E_NOTOOLSPACE otherwise.
                */
                
                STDMETHODIMP CFrame::RequestBorderSpace(LPCBORDERWIDTHS pBW)
                {
                //Framer has no border space restrictions
                return NOERROR;
                }
                *) 
                 (# 
                 do (* Framer has no border space restrictions *)
                    interfaceMsg
                      (# 
                      do 'OleInPlaceFrame.RequestBorderSpace'->msg.append
                      #);
                    NOERROR->result
                 #);
               SetBorderSpace::<
               (* /*
                * CFrame::SetBorderSpace
                *
                * Purpose:
                *  Called when the object now officially requests that the
                *  container surrender border space it previously allowed
                *  in RequestBorderSpace.  The container should resize windows
                *  appropriately to surrender this space.
                *
                * Parameters:
                *  pBW             LPCBORDERWIDTHS containing the amount of space
                *                  from each side of the relevant window that the
                *                  object is now reserving.
                *
                * Return Value:
                *  HRESULT         NOERROR
                */
                
                STDMETHODIMP CFrame::SetBorderSpace(LPCBORDERWIDTHS pBW)
                {
                RECT            rc;
                
                /*
                * Since we have no tools, we can accept anything the object sends
                * and must therefore adjust the client-area window accordingly.
                */
                
                /*
                * If pBW is NULL, the object is not interested in tools, so we
                * don't have to do anything.  In either case we need to save
                * the toolspace allocations in order to resize the client window
                * correctly.
                */
                if (NULL==pBW)
                {
                if (!m_fOurMenuShowing)
                SetMenu(NULL, NULL, NULL);
                
                SetRect(&m_bwIP, 0, 0, 0, 0);
                GetClientRect( m_hWnd, &rc );
                }
                else
                {
                GetClientRect(m_hWnd, &rc);
                rc.left  +=pBW->left;
                rc.right -=pBW->right;
                rc.top   +=pBW->top;
                rc.bottom-=pBW->bottom;
                
                m_bwIP=*pBW;
                }
                
                ResizeClientWindow(rc.left, rc.top, rc.right-rc.left
                , rc.bottom-rc.top);
                
                return NOERROR;
                }
                *) 
                 (# 
                 do
                    interfaceMsg
                      (# 
                      do 'OleInPlaceFrame.SetBorderSpace'->msg.append
                      #);
                    ;
                    (if pBorderWidths[] = none then
                        'SetBorderSpace: SetMenu, SetRect, GetClientRect kald'
                          ->putline
                     else
                        'SetBorderSpace: GetClientRect kald m.m.'->putline
                    if);
                    'SetBorderSpace: ResizeClientWindow call'->putline;
                    NOERROR->result
                 #);
               SetActiveObject::<
               (* /*
                * CFrame::SetActiveObject
                *
                * Purpose:
                *  Provides the container with the object's IOleInPlaceActiveObject
                *  pointer
                *
                * Parameters:
                *  pIIPActiveObj   LPOLEINPLACEACTIVEOBJECT of interest.
                *  pszObj          LPCOLESTR naming the object.  Not used.
                *
                * Return Value:
                *  HRESULT         NOERROR
                */
                
                STDMETHODIMP CFrame::SetActiveObject
                (LPOLEINPLACEACTIVEOBJECT pIIPActiveObj, LPCOLESTR pszObj)
                {
                if (NULL!=m_pIOleIPActiveObject)
                m_pIOleIPActiveObject->Release();
                
                //NULLs m_pIOleIPActiveObject if pIIPActiveObj is NULL
                m_pIOleIPActiveObject=pIIPActiveObj;
                
                if (NULL!=m_pIOleIPActiveObject)
                m_pIOleIPActiveObject->AddRef();
                
                m_pIOleIPActiveObject->GetWindow(&m_hWndObj);
                return NOERROR;
                }
                *) 
                 (# anInt32Holder: ^int32holder
                 do
                    interfaceMsg
                      (# 
                      do 'OleInPlaceFrame.SetActiveObject'->msg.append
                      #);
                    ;
                    (if m_pIOleIPActiveObject[] <> none then
                        m_pIOleIPActiveObject.Release
                    if);
                    ;
                    pActiveObject[]
                      ->m_pIOleIPActiveObject[]
                      (* NULLs m_pIOleIPActiveObject if pActiveObj is NULL *) ;
                    ;
                    (if m_pIOleIPActiveObject[] <> none then
                        callToObjectMsg
                          (# 
                          do
                             'CFrame.SetActivateObject: kald til AddRef'
                               ->msg.append
                          #);
                        m_pIOleIPActiveObject.AddRef;
                        callToObjectMsg
                          (# 
                          do
                             'CFrame.SetActivateObject: kald til AddRef returneret'
                               ->msg.append
                          #)
                    if);
                    ;
                    &int32holder[]->anInt32Holder[];
                    m_hWndObj->anInt32Holder;
                    callToObjectMsg
                      (# 
                      do
                         'CFrame.SetActivateObject: kald til GetWindow'
                           ->msg.append
                      #);
                    anInt32Holder[]->m_pIOleIPActiveObject.GetWindow;
                    callToObjectMsg
                      (# 
                      do
                         'CFrame.SetActivateObject: kald til GetWindow returneret'
                           ->msg.append
                      #);
                    anInt32Holder->m_hWndObj;
                    NOERROR->result
                 #);
               InsertMenus::<
               (* /*
                * CFrame::InsertMenus
                *
                * Purpose:
                *  Instructs the container to place its in-place menu items where
                *  necessary in the given menu and to fill in elements 0, 2, and 4
                *  of the OLEMENUGROUPWIDTHS array to indicate how many top-level
                *  items are in each group.
                *
                * Parameters:
                *  hMenu           HMENU in which to add popups.
                *  pMGW            LPOLEMENUGROUPWIDTHS in which to store the
                *                  width of each container menu group.
                *
                * Return Value:
                *  HRESULT         NOERROR
                */
                
                STDMETHODIMP CFrame::InsertMenus(HMENU hMenu
                , LPOLEMENUGROUPWIDTHS pMGW)
                {    
                //Copy our File menu into the shared menu.    
                InsertMenu(hMenu, 0, MF_BYPOSITION | MF_POPUP, (UINT)m_phMenu[0]
                , TEXT("&File"));
                
                pMGW->width[0]=1;
                pMGW->width[2]=0;
                pMGW->width[4]=0;
                
                /*
                * Add the special help menu which is the first item in
                * the m_hMenuHelp popup that's sitting around.
                */
                InsertMenu(hMenu, 1, MF_BYPOSITION | MF_POPUP
                , (UINT)m_hMenuHelp, TEXT("&Help"));
                
                //Tell the object we added our Help menu
                pMGW->width[5]=1;    
                return NOERROR;
                }
                *) 
                 (# 
                 do
                    interfaceMsg
                      (#  do 'OleInPlaceFrame.InsertMenus'->msg.append #);
                    'InsertMenus not implemented (1)'
                      ->putline
                      (*(interfaceObjectID,position - 1,
                       MF_BYPOSITION + MF_POPUP + MF_STRING, theWin32Menu.interfaceObjectID,name) 
                       -> InsertMenu -> result;*) ;
                    (hmenuShared,0,MF_BYPOSITION %bor MF_POPUP,m_phMenu,
                     '&File2')->InsertMenu->putint;
                    newline;
                    'InsertMenus not implemented'
                      ->putline
                      (*(interfaceObjectID,position - 1,
                       MF_BYPOSITION + MF_POPUP + MF_STRING, theWin32Menu.interfaceObjectID,name) 
                       -> InsertMenu -> result;*) ;
                    NOERROR->result
                 #);
               SetMenu::<
               (* /*
                * CFrame::SetMenu
                *
                * Purpose:
                *  Instructs the container to replace whatever menu it's currently
                *  using with the given menu and to call OleSetMenuDescritor so OLE
                *  knows to whom to dispatch messages.
                *
                * Parameters:
                *  hMenu           HMENU to show.
                *  hOLEMenu        HOLEMENU to the menu descriptor.
                *  hWndObj         HWND of the active object to which messages are
                *                  dispatched.
                *
                * Return Value:
                *  HRESULT         NOERROR
                */
                
                STDMETHODIMP CFrame::SetMenu(HMENU hMenu, HOLEMENU hOLEMenu
                , HWND hWndObj)
                {
                HRESULT         hr;
                
                /*
                * Our responsibilities here are to put the menu on the frame
                * window and call OleSetMenuDescriptor.
                */
                
                if (NULL==hMenu)
                {
                //Prevent redundant calls, or debug warnings on startup.
                if (NULL==m_hMenuTop)
                return NOERROR;
                
                hMenu=m_hMenuTop;
                m_hMenuTop=NULL;
                m_fOurMenuShowing=TRUE;
                }
                else
                {
                m_hMenuTop=m_hMenuOrg;
                m_fOurMenuShowing=FALSE;
                
                /*
                * Check if our Help menu has anything added to it.  If so, then
                * remember to forward menu messages.  If not, remove the Help
                * menu altogether (destroying it after removing our normal Help
                * popup, as we also do in RemoveMenus.
                */
                if (CHELPITEMS!=GetMenuItemCount(m_hMenuHelp))
                m_fUsingOurHelp=TRUE;
                else
                {
                UINTi, cItems;
                
                cItems=GetMenuItemCount(hMenu);
                
                //Find m_hMenuHelp in the menu and remove it.
                for (i=0; i < cItems; i++)
                {
                if (GetSubMenu(hMenu, i)==m_hMenuHelp)
                {
                RemoveMenu(hMenu, i, MF_BYPOSITION);
                break;
                }
                }
                }
                }
                
                if (NULL!=hMenu)
                ::SetMenu(m_hWnd, hMenu);
                
                DrawMenuBar(m_hWnd);
                
                hr=OleSetMenuDescriptor(hOLEMenu, m_hWnd, hWndObj, NULL, NULL);
                return hr;
                }
                *) 
                 (# 
                 do
                    interfaceMsg
                      (#  do 'OleInPlaceFrame.SetMenu'->msg.append #);
                    'SetMenu not implemented'->putline
                 #);
               RemoveMenus::<
               (* /*
                * CFrame::RemoveMenus
                *
                * Purpose:
                *  Asks the container to remove any menus it put into hMenu in
                *  InsertMenus.
                *
                * Parameters:
                *  hMenu           HMENU from which to remove the container's
                *                  items.
                *
                * Return Value:
                *  HRESULT         NOERROR
                */
                
                STDMETHODIMP CFrame::RemoveMenus(HMENU hMenu)
                {
                int         cItems, i, j;
                HMENU       hMenuT;
                
                /*
                * To be defensive, loop through this menu removing anything
                * we recognize (that is, anything in m_phMenu) just in case
                * the server didn't clean it up right.  At least we can
                * give ourselves the prophylactic benefit.
                */
                
                if (NULL==hMenu)
                return NOERROR;
                
                cItems=GetMenuItemCount(hMenu);
                
                /*
                * Walk backwards down the menu.  For each popup, see if it
                * matches any other popup we know about, and if so, remove
                * it from the shared menu.
                */
                for (i=cItems; i >=0; i--)
                {
                hMenuT=GetSubMenu(hMenu, i);
                
                for (j=0; j <= CMENUS; j++)
                {
                //Remove any owned popup, or our special help menu
                if (hMenuT==m_phMenu[j]
                || (hMenuT==m_hMenuHelp && m_hMenuHelp!=NULL))
                RemoveMenu(hMenu, i, MF_BYPOSITION);
                }
                }
                
                m_fUsingOurHelp=FALSE;
                
                //The menu should now be empty.
                return NOERROR;
                }
                *) 
                 (# 
                 do
                    interfaceMsg
                      (#  do 'OleInPlaceFrame.RemoveMenus'->msg.append #);
                    'RemoveMenus not implemented'->putline
                 #);
               SetStatusText::<
               (* /*
                * CFrame::SetStatusText
                *
                * Purpose:
                *  Asks the container to place some text in a status line, if one
                *  exists.  If the container does not have a status line it
                *  should return E_FAIL here in which case the object could
                *  display its own.
                *
                * Parameters:
                *  pszText         LPCOLESTR to display.
                *
                * Return Value:
                *  HRESULT         NOERROR if successful, S_TRUNCATED if not all
                *                  of the text could be displayed, or E_FAIL if
                *                  the container has no status line.
                */
                
                STDMETHODIMP CFrame::SetStatusText(LPCOLESTR pszText)
                {
                //We have no status line...
                return E_NOTIMPL;
                }
                *) 
                 (# 
                 do
                    interfaceMsg
                      (#  do 'OleInPlaceFrame.SetStatusText'->msg.append #);
                    E_NOTIMPL->result (* We have no status line... *)
                 #);
               EnableModeless::<
               (* /*
                * CFrame::EnableModeless
                *
                * Purpose:
                *  Instructs the container to show or hide any modeless popup
                *  windows that it may be using.
                *
                * Parameters:
                *  fEnable         BOOL indicating to enable/show the windows
                *                  (TRUE) or to hide them (FALSE).
                *
                * Return Value:
                *  HRESULT         NOERROR
                */
                
                STDMETHODIMP CFrame::EnableModeless(BOOL fEnable)
                {
                return NOERROR;
                }
                *) 
                 (# 
                 do
                    interfaceMsg
                      (# 
                      do 'OleInPlaceFrame.EnableModeless'->msg.append
                      #);
                    NOERROR->result
                 #);
               TranslateAccelerator::<
               (* /*
                * CFrame::TranslateAccelerator
                *
                * Purpose:
                *  When dealing with an in-place object from an EXE server, this
                *  is called to give the container a chance to process accelerators
                *  after the server has looked at the message.
                *
                * Parameters:
                *  pMSG            LPMSG for the container to examine.
                *  wID             WORD the identifier in the container's
                *                  accelerator table (from IOleInPlaceSite
                *                  ::GetWindowContext) for this message (OLE does
                *                  some translation before calling).
                *
                * Return Value:
                *  HRESULT         NOERROR if the keystroke was used,
                *                  S_FALSE otherwise.
                */
                
                STDMETHODIMP CFrame::TranslateAccelerator(LPMSG pMSG, WORD wID)
                {
                /*
                * wID already has anything translated from m_hAccel for us,
                * so we can just check for the commands we want and process
                * them instead of calling TranslateAccelerator which would be
                * redundant and which also has a possibility of dispatching to
                * the wrong window.
                */
                if (IDM_ENTERCONTEXTHELP==wID || IDM_ESCAPECONTEXTHELP==wID)
                {
                //wID properly expands to 32-bits
                OnCommand(m_hWnd, (WPARAM)wID, 0L);
                return NOERROR;
                }
                
                return S_FALSE;
                }
                *) 
                 (# 
                 do
                    interfaceMsg
                      (# 
                      do 'OleInPlaceFrame.TranslateAccelerator'->msg.append
                      #);
                    'TranslateAccelerator not implemented'->putline;
                    S_FALSE->result
                 #)
            #);
          theOleCommandTarget: @COleCommandTarget;
          COleCommandTarget: IOleCommandTarget
            (# QueryStatus::<  (#  #); Exec::<  (#  #) #)
       #);
     CFrame: ^CFrameType;
     ;
     UI: @UItype;
     UItype: guienv
       (#
          mainWindowType: window
            (#
               open::< 
                 (# 
                 do (486,338)->size; clientCanvas.open; 'Doc Framer'->title
                 #);
               eventHandler::< 
                 (# onAboutToClose::<  (#  do onExit #) #);
               menubarType:: 
                 (#
                    fileMenu: @menu
                      (#
                         openItem: @menuItem
                           (#
                              eventHandler:: 
                                (# onSelect::  (#  do onOpen;  #);  #);
                              open::  (#  do '&Open'->name; 'o'->key #)
                           #);
                         closeItem: @menuItem
                           (#
                              eventHandler:: 
                                (# onSelect::  (#  do onClose #);  #);
                              open::  (#  do '&Close'->name; 'c'->key #)
                           #);
                         exitItem: @menuItem
                           (#
                              eventHandler:: 
                                (# onSelect::  (#  do onExit #);  #);
                              open::  (#  do 'E&xit'->name; 'x'->key;  #)
                           #);
                         sep1: @separator;
                         open:: 
                           (# 
                           do
                              '&File'->name;
                              openItem.open;
                              openItem[]->append;
                              closeItem.open;
                              closeItem[]->append;
                              sep1.open;
                              sep1[]->append;
                              exitItem.open;
                              exitItem[]->append
                           #)
                      #);
                    shortcutsMenu: @menu
                      (#
                         shortcut1Item: @menuItem
                           (#
                              eventHandler:: 
                                (# onSelect::  (#  do onShortcut1 #); 
                                #);
                              open:: 
                                (#  do 'Shortcut &1'->name; '1'->key #)
                           #);
                         open:: 
                           (# 
                           do
                              'Shortcuts'->name;
                              Shortcut1Item.open;
                              Shortcut1Item[]->append
                           #)
                      #);
                    open::< 
                      (# 
                      do
                         fileMenu.open;
                         fileMenu[]->append;
                         ShortcutsMenu.open;
                         ShortcutsMenu[]->append;
                         INNER
                      #)
                 #);
               clientCanvas: @canvas
                 (#
                    open::< 
                      (# 
                      do
                         4->border.style;
                         true->border.visible;
                         (449,287)->size;
                         (18,32)->position;
                         
                      #);
                    eventHandler::< 
                      (#
                         onEnableTarget::< 
                           (#  do 'WINDOW: onEnableTarget'->putline #);
                         onActivate::< 
                           (# 
                           do
                              (if false then 'WINDOW: onActivate'->putline if)
                           #)
                      #)
                 #);
               ;
               onOpen:<
                 (# filename: ^text; fOK: @boolean
                 do
                    fileSelectionDialog (#  do '*'->filter[] #)->filename[];
                    (if filename[] <> none then
                        filename[]->CreateObject->fOK
                     else
                    (* Cancelled *)
                        
                    if)
                 #);
               onClose:< (#  do THIS(CFrameType).close #);
               onExit:<
                 (# 
                 do 'PostMessage(hWnd, WM_CLOSE, 0, 0L)'; closeFiles; terminate
                 #);
               ;
               onShortcut1:<
                 (# 
                 do
                    'c:\\beta\\r4.2dev\\comlib\\demo\\documentcontainer\\__Bitmap.bmp'
                      ->CreateObject
                 #)
            #);
          mainWindow: ^mainWindowType
       #);
     windowEnvType:: UItype;
     setWindowEnv::  (#  do UI[]->theWindowEnv[] #)
  do
     openFiles;
     &CFrameType[]->CFrame[];
     (uienvHInstance,117,none ,0)->CFrame.constructor;
     CFrame.Init
  #)  

