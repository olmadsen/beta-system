ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/basiclib/file'
        '~beta/containers/sets';
BUILD default '$$/winmaindemomisc.obj' 'external/winmaindemomisc.cpp' 'betacc $0 $1';
-- lib: Attributes --
WinmainDebug:
  (#
     private: @
       (#
          filesOpen: @boolean;
          ;
          debug: (#  exit true #);
          debugFile: @file;
          ;
          locate: (#  exit false #);
          locateFile: @file;
          ;
          interfacedebug: (#  exit true #);
          interfaceFile: @file;
          ;
          callToObjectDebug: (#  exit true #);
          callToObjectFile: @file
       #);
     open:
       (# 
       do
          'debug.txt'->private.debugFile.name;
          private.debugFile.openWrite;
          'debug-locate.txt'->private.locateFile.name;
          private.locateFile.openWrite;
          'debug-interface.txt'->private.interfaceFile.name;
          private.interfaceFile.openWrite;
          'debug-calltoobjects.txt'->private.callToObjectFile.name;
          private.callToObjectFile.openWrite;
          locateMsg.open;
          true->private.filesOpen
       #);
     close:
       (# 
       do
          false->private.filesOpen;
          private.debugFile.close;
          private.locateFile.close;
          private.interfaceFile.close;
          private.callToObjectFile.close;
          locateMsg.close
       #);
     ;
     debugMsg:
       (# msg: @text
       do
          (if private.filesOpen and private.debug then
              INNER ;
              (if (msg[] <> none ) and not msg.empty then
                  msg[]->private.debugFile.putline; private.debugFile.flush
              if)
          if)
       #);
     locate2msg: (#  do (if private.locate then INNER if) #);
     locateMsg: @
     (* skal bruges som den foerste og den sidste kommando i hver metode. *)
       (#
          private: @
            (#
               thefile: @file;
               indentlist: @set
                 (# element::  (# msg: ^text; indent: @integer #) #);
               currentIndent:
                 (# result: @integer
                 do
                    - 1->result;
                    indentlist.scan
                      (# 
                      do
                         (if current.indent > result then
                             current.indent->result
                         if)
                      #)
                 exit result
                 #);
               makeIndentString:
                 (# indent: @integer; str: ^text
                 enter indent
                 do &text[]->str[]; (for indent repeat ' '->str.append for)
                 exit str[]
                 #);
               fileOpen: @boolean
            #);
          open:
            (# 
            do
               'debug-locate.txt'->private.thefile.name;
               private.thefile.openWrite;
               true->private.fileOpen
            #);
          close: (#  do false->private.fileOpen; private.thefile.close #);
          in:
            (#
               msg: ^text;
               newIndentListElm: ^private.indentlist.element;
               oldIndent,newIndent: @integer
            enter msg[]
            do
               (if (private.fileOpen) and (msg[] <> none ) and (not msg.empty)
                then
                   private.currentIndent->oldIndent;
                   oldIndent+4->newIndent;
                   ;
                   &private.indentlist.element[]->newIndentListElm[];
                   msg.copy->newIndentListElm.msg[];
                   newIndent->newIndentListElm.indent;
                   newIndentListElm[]->private.indentlist.insert;
                   ;
                   '+ '->msg.prepend;
                   newIndent->private.makeIndentString->msg.prepend;
                   ;
                   msg.makeUC;
                   msg[]->private.thefile.putline;
                   private.thefile.flush
               if)
            #);
          out:
            (# msg: ^text; theIndentListElm: ^private.indentlist.element
            enter msg[]
            do
               (if (private.fileOpen) and (msg[] <> none ) and (not msg.empty)
                then
                   private.indentlist.find
                     (#
                        predicate:: 
                          (#  do msg[]->current.msg.equal->value #)
                     #)->theIndentListElm[];
                   ;
                   '- '->msg.prepend;
                   (if theIndentListElm[] <> none then
                       theIndentListElm[]->private.indentlist.delete;
                       theIndentListElm.indent->private.makeIndentString
                         ->msg.prepend
                    else
                       '+++++ could not find this element in indentlist +++++ '
                         ->msg.prepend
                   if);
                   ;
                   msg[]->private.thefile.putline;
                   private.thefile.flush
               if)
            #)
       #);
     interfaceMsg:
     (* udskriver en besked, naar et COM-interface er blevet kaldt. *)
       (# msg: ^text
       enter msg[]
       do
          (if private.filesOpen then
              (if private.interfacedebug then
                  (if msg[] = none then &text[]->msg[] if);
                  INNER interfaceMsg;
                  (if (msg[] <> none ) and not msg.empty then
                      (if false then
                          'debug-interface: "'->puttext;
                          msg[]->puttext;
                          '".'->putline
                      if);
                      msg[]->private.interfaceFile.putline;
                      private.interfaceFile.flush
                  if)
              if)
          if)
       #);
     callToObjectMsg:
     (* bruges til at udskrive foer/efter et kald til server-objektet. *)
       (# msg: @text
       do
          (if private.filesOpen then
              (if private.callToObjectDebug then
                  INNER ;
                  (if (msg[] <> none ) and not msg.empty then
                      msg[]->private.callToObjectFile.putline;
                      private.callToObjectFile.flush
                  if)
              if)
          if)
       #);
     ;
     myprint: external (# hr: @integer;  enter hr do callc;  #)
  #)  

