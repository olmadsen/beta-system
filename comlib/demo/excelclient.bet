ORIGIN '~beta/comlib/comlib';
INCLUDE '~beta/comlib/dispatchhelp';
INCLUDE '~beta/comlib/MsApplication/Excel8';

--PROGRAM: descriptor--
(# CLSID_XL: ^CLSID;
   clsstr: @BSTR;
   IID_IDispatch: @IID;
   hr: @HRESULT;
   params: @DISPPARAMS;
   varg, varg1, varg2: @VARIANT;
   status: @boolean;
   
   pDispExcelApp, pdispWorkBooks, pdispWorkBook, pdispWorksheet, 
   pdispRange, pdispCharts, pDispChart: ^IDispatch;
   
   excel_progid: (# exit 'Excel.Application' #);
   
   use_dual: (# exit false #);
   
   CleanUp:
     (# 
     do '\nClean up:' -> putline;
        'Releasing interfaces' -> putline;
        (if pDispExcelApp[]<>NONE then 
            pDispExcelApp.Release; 
        if);
        (if pdispWorkBooks[]<>NONE then 
            pdispWorkBooks.Release; 
        if);
        (if pdispWorkBook[]<>NONE then 
            pdispWorkBook.Release; 
        if);
        (if pdispWorksheet[]<>NONE then 
            pdispWorksheet.Release; 
        if);
        (if pdispRange[]<>NONE then 
            pdispRange.Release; 
        if);
        (if pdispCharts[]<>NONE then 
            pdispCharts.Release; 
        if);
        (if pdispChart[]<>NONE then 
            pdispChart.Release; 
        if);
        dparms.release;
        'CoUninitialize'->putline;
        CoUninitialize;
        'CoUninitialize done'->putline;
     #);
   
   putRangeReal:
     (# name: ^text;
        value: @real;
        vResult: @VARIANT;
        status: @boolean;
        pDispRange: ^IDispatch;
     enter (name[], value)
     do true -> status;
        dparms.release;
        (NONE, name[]) -> dparms.putString;
        (pDispWorksheet[], 'Range', dparms[], vResult[]) 
          -> PropertyGetByName
          -> status;
        (if not status then
            'putRangeReal failed' -> putline;
            leave putRangeReal;
        if);
        vResult[] -> VARIANT_init(# do pDispval -> pDispRange[] #);
        
        dparms.release;
        (NONE, value) -> dparms.putReal;
        (pDispRange[], 'Value', dparms[]) 
          -> PropertyPutByName
          -> status;
        (if not status then
            'putRangeReal failed' -> putline;
            leave putRangeReal;
        if); 
     exit status
     #);
   
   dParms: @DispatchParams;
   
   Values: @TextList;
do ControlExcel:
     (# 
     do 0->CoInitialize;   
        excel_progid -> clsstr.setText;
        clsstr[] -> CLSIDFromProgID -> CLSID_XL[];
        IDispatch_IID -> IID_IDispatch; 
        
        'Create component and get dispinterface'->putLine;
        (CLSID_XL[], NONE, CLSCTX_LOCAL_SERVER, IID_IDispatch[])
          -> CoCreateInstance->pDispExcelApp[];
        
        (if pDispExcelApp[]<>NONE then
            'Succeeded creating component.'->putLine;
         else
            'failed creating component.'->putLine;
            leave ControlExcel;
        if);

        (*'Setting pDispExcelApp.Width:' -> putline;
        (NONE, 600.0) -> dParms.putReal;
        (pDispExcelApp[], 'Width', dparms[]) -> PropertyPutByName -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;*)
        
        'Invoking pDispExcelApp.Visible:' -> putline;
        (NONE, true) -> dParms.putBoolean;
        (pDispExcelApp[], 'Visible', dparms[]) -> PropertyPutByName -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        
        'Adding a sheet to the workbook' -> putline;
        (pDispExcelApp[], 'Workbooks', dparms[], varg1[]) 
          -> PropertyGetByName 
          -> status;
        (if not status then
            leave ControlExcel;
        if);
        
        'Invoking pDispExcelApp.WorkBooks.Add:' -> putline;
        varg1[] -> VARIANT_init(# do pdispVal->pdispWorkbooks[] #);
        (if use_dual then 
            (# dual: ^Workbooks;
               RHS: @int32holder;
            do 'Calling Add using vtable' -> putline;
               pdispWorkbooks[] -> dual[]; (* should be a QIF? *)
               (*(varg, lcid, RHS[]) -> dual.add -> hr;*)
            #);
            (if hr.succeeded then
                'pdispWorkbooks.Add(template:=xlWorksheet) succeeded' 
                  -> putline;
             else
                ('pdispWorkbooks.Add(template:=xlWorksheet) failed',hr.value) 
                  -> ComErrorMessage;
                leave ControlExcel;
            if);
         else
            'Calling Add using invoke' -> putline;
            ('Template', xlWorksheet) -> dParms.putInt16;
            (pdispWorkbooks[], 'Add', dparms[], DISPATCH_METHOD, varg2[]) 
              -> InvokeByName
              -> status;
            (if not status then
                leave ControlExcel;
            if);
            dparms.release;
            varg2[] -> VARIANT_init(# do pdispVal->pdispWorkBook[] #);
        if);
        
        'Getting WorkSheets(1)' -> putline;
        (NONE,1) -> dParms.putInt16;
        (pdispWorkBook[], 'Worksheets', dparms[], varg2[]) 
          -> PropertyGetByName 
          -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        varg2[] -> VARIANT_init(# do pdispVal->pdispWorkSheet[] #);
        
        'Getting WorkSheet(1).Range("A1:D1")' -> putline;
        (NONE, 'A1:D1') -> dparms.putString;
        (pdispWorkSheet[], 'Range', dparms[], varg2[]) 
          -> PropertyGetByName 
          -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        varg2[] -> VARIANT_init(# do pdispVal->pdispRange[] #);
        
        'Setting WorkSheet(1).Range("A1:D1").Value = Array("North", "South", "East", "West")' 
          -> putline;
        Values.init;
        'North' -> values.append;
        'South' -> values.append;
        'East' -> values.append;
        'West' -> values.append;
        (NONE, Values[]) -> dparms.putStringArray;
        (pdispRange[], 'Value', dparms[]) 
          -> PropertyPutByName 
          -> status;
        dparms.release;
        (if not status then
            leave ControlExcel;
        if);
        
        'ws.range("A2") = 5.2' -> putline;
        ('A2', 5.2) -> putRangeReal -> status;
        (if not status then
            leave ControlExcel;
        if);
        'ws.range("B2") = 10.0' -> putline;
        ('B2', 10.0) -> putRangeReal -> status;
        (if not status then
            leave ControlExcel;
        if);
        'ws.range("C2") = 8.0' -> putline;
        ('C2', 8.0) -> putRangeReal -> status;
        (if not status then
            leave ControlExcel;
        if);
        'ws.range("D2") = 20.0' -> putline;
        ('D2', 20.0) -> putRangeReal -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        
        'Set sourceRange= ws.Range("A1:D2")' -> putline;
        (NONE, 'A1:D2') -> dparms.putString;
        (pdispWorkSheet[], 'Range', dparms[], varg2[]) 
          -> PropertyGetByName 
          -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        varg2[] -> VARIANT_init(# do pdispVal->pdispRange[] #);
        
        'set crt = wb.Charts.Add' -> putline;
        (pdispWorkbook[], 'Charts', dparms[], varg2[]) 
          -> PropertyGetByName 
          -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        varg2[] -> VARIANT_init(# do pdispVal->pdispCharts[] #);
        
        (pdispCharts[], 'Add', dparms[], DISPATCH_METHOD, varg2[]) 
          -> InvokeByName
          -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        varg2[] -> VARIANT_init(# do pdispVal->pdispChart[] #);
        
        
        'Setting Workbook.Saved = TRUE (so that Excel won\'t ask whether to save doc on close):' -> putline;
        (NONE, true) -> dParms.putBoolean;
        (pDispWorkBook[], 'Saved', dparms[]) -> PropertyPutByName -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
        
        
     #);
   
   CleanUp;
   
#)



