ORIGIN '~beta/comlib/comlib';
INCLUDE '~beta/basiclib/external';
INCLUDE '~beta/sysutils/wstring';
INCLUDE '~beta/win32lib/winnt';
INCLUDE '~beta/comlib/oleauto';
INCLUDE '~beta/comlib/OAIdl';
INCLUDE '~beta/comlib/MsApplication/Excel8';

--PROGRAM: descriptor--
(# CLSID_XL: ^CLSID;
   clsstr: @BSTR;
   IID_IDispatch: @IID;
   hr: @HRESULT;
   params: @DISPPARAMS;
   varg, varg1, varg2: @VARIANT;
   status: @boolean;
   
   pDispExcelApp, pdispWorkBooks, pdispWorkBook, pdispWorksheet, 
   pdispRange, pdispCrt: ^IDispatch;
   
   excel_progid: (# exit 'Excel.Application' #);
   
   use_dual: (# exit false #);
   
   CleanUp:
     (# 
     do 'Awaiting key-press before releasing interface: ' -> puttext;
        getline;
        'Releasing interfaces' -> putline;
        (if pDispExcelApp[]<>NONE then 
            pDispExcelApp.Release; 
        if);
        (if pdispWorkBooks[]<>NONE then 
            pdispWorkBooks.Release; 
        if);
        (if pdispWorkBook[]<>NONE then 
            pdispWorkBook.Release; 
        if);
        (if pdispWorksheet[]<>NONE then 
            pdispWorksheet.Release; 
        if);
        (if pdispRange[]<>NONE then 
            pdispRange.Release; 
        if);
        (if pdispCrt[]<>NONE then 
            pdispCrt.Release; 
        if);
        dparms.release;
        'CoUninitialize'->putline;
        CoUninitialize;
        'CoUninitialize done'->putline;
     #);
   
   DispatchParams: 
     (# varg: @VARIANT;
        rgvarg: @ExternalRepetition
          (# elementSize::(# do 16->value (* sizeof(VARIANT) *) #);
             inxCopy:
               (# inx: @int32;
               enter (inx)
               do (%getlongAt (@@varg + 0))  %putLongAt (ptr+4*inx+0);
                  (%getlongAt (@@varg + 4))  %putLongAt (ptr+4*inx+4);
                  (%getlongAt (@@varg + 8))  %putLongAt (ptr+4*inx+8);
                  (%getlongAt (@@varg + 12)) %putLongAt (ptr+4*inx+12);
               #);
          #);
        alpszArgNames: @ExternalRepetition
          (# elementSize::(# do 4->value (* sizeof( OLECHAR* ) *)#)#);
        rgdispidNamedArgs: @ExternalRepetition
          (# elementSize::(# do 4->value (* sizeof( DISPID* ) *)#)#);
        cArgs, cNamedArgs, maxArgs, maxNamedArgs: @integer;
        
        release:
          (# wstr: @wstring;
          do (0,0,0,0,0,0) -> varg;
             rgvarg.free;
             (for i:cNamedArgs repeat
                  (i-1) -> alpszArgNames.inxget -> wstr; wstr.free;
             for);
             alpszArgNames.free;
             rgdispidNamedArgs.free;
             0 -> cArgs -> cNamedArgs -> maxArgs -> maxNamedArgs;
          #);
        
        check: 
          (# name: ^text;
             add: @integer;
          enter (name[])
          do (if cArgs+1>maxArgs then
                 ((2*rgvarg.range, cArgs+1) -> max) -> maxArgs;
                 maxArgs - rgvarg.range -> add;
                 add -> rgvarg.extend;
             if);
             (if alpszArgNames.range=0 then
                 (* Make room for member name *)
                 1 -> alpszArgNames.new;
                 1 -> rgdispidNamedArgs.new;
             if);
             (if (name[]<>NONE) and (cNamedArgs+1>maxNamedArgs) then
                 ((2*alpszArgNames.range, cNamedArgs+1) -> max) -> maxNamedArgs;
                 maxNamedArgs+1 - alpszArgNames.range -> add;
                 add -> alpszArgNames.extend;
                 add -> rgdispidNamedArgs.extend;
             if);
             INNER;
          #);
        put: check
          (# wstr: @wstring;
          do (* If there is a name, add it *)
             (if name[]<>NONE then
                 (* First increment namecounter. Deliberately done before
                  * argument is put, since arguments come from index 1 
                  * (index 0 is for member name).
                  *)
                 cNamedArgs+1 -> cNamedArgs;
                 name[] -> wstr.set;
                 (wstr, cNamedArgs) -> alpszArgNames.inxPut;
             if);
             (* Specializations fill in varg in INNER *)
             INNER;
             cArgs -> rgvarg.inxCopy;
             cArgs+1 -> cArgs;
          #);
        
        putInt16: put
          (# value: @int16
          enter (value)
          do varg[]->VARIANT_init
             (# 
             do VT_I2 -> vt;
                value -> iVal;
             #);
          #);
        putBoolean: put
          (# value: @boolean
          enter (value)
          do varg[]->VARIANT_init
             (# 
             do VT_BOOL -> vt;
                (if value then
                    VARIANT_TRUE -> bool;
                 else
                    VARIANT_FALSE -> bool;
                if);                    
             #);
          #);
     #);
   
   CallInvoke:
     (# pdisp: ^IDispatch;
        member: ^text;
        params: ^DispatchParams;
        dParms: @DISPPARAMS;
        wAction: @integer;
        vReturn: ^VARIANT;
        cNamedArgs: @integer;
        dispidMember: @integer;
        hr: @HRESULT;
        status: @boolean;
        lcid: @integer;
     enter (pdisp[], member[], params[], wAction, vReturn[])
     do true -> status;
        LOCALE_USER_DEFAULT -> lcid;
        params.cNamedArgs -> cNamedArgs;
        (* Look up DISPIDs of member name, and any possibly arguments
         * previously put to params.
         *)
        member[] -> params.check
        (# wstr: @wstring;
        do name[] -> wstr.set; 
           (wstr, 0) -> params.alpszArgNames.inxPut;
        #);
        (# dummy:@char do (IID_NULL, params.alpszArgNames, 1+cNamedArgs, lcid, params.rgdispidNamedArgs)
          -> pDisp.GetIdsOfNames
             -> hr; #);
        (if hr.succeeded then
            0->params.rgdispidNamedArgs.inxGet -> dispidmember;
            'Got Id for \'' -> puttext;
            member[]->puttext;
            '\': ' -> puttext;
            dispidMember -> putint;
            newline;
         else
            ('GetIdsOfNames Failed', hr.value) -> ComErrorMessage;
            false -> status;
            leave CallInvoke;
        if);
        
        (* If doing a propertyput, we need to put adjust the first argument
         * to have a named arg of DISPID_PROPERTYPUT
         *)
        (if (wAction %Band DISPATCH_PROPERTYPUT) <> 0 then
            (* PROPERTY_PUT only have 1 named arg besides the "member name" *)
            1 -> cNamedArgs; 
            (DISPID_PROPERTYPUT, 1) -> params.rgdispidNamedArgs.inxPut;
        if);
        
        (* Now fill in the DISPPARAMS structure *)
        params.rgdispidNamedArgs + 4 -> dparms.rgdispidNamedArgs;
        params.rgvarg -> dparms.rgvarg;
        params.cArgs -> dparms.cArgs;
        cNamedArgs -> dparms.cNamedArgs;
        
        (* Finally call invoke *)
        (# dummy: @char do 
           (dispidMember, IID_NULL, lcid, wAction, dParms[], vReturn[], NONE, NONE)
             -> pDisp.Invoke
             -> hr;
        #);
        (if hr.succeeded then
            'Invoke succeeded' -> putline;
         else
            ('Invoke Failed', hr.value) -> ComErrorMessage;
            false -> status;
            leave CallInvoke;
        if);
     exit status
     #);
   
   dParms: @DispatchParams;
   
do ControlExcel:
     (# 
     do 0->CoInitialize;   
        excel_progid -> clsstr.setText;
        clsstr[] -> CLSIDFromProgID -> CLSID_XL[];
        IDispatch_IID -> IID_IDispatch; 
   
        'Create component and get dispinterface'->putLine;
        (CLSID_XL[], NONE, CLSCTX_LOCAL_SERVER, IID_IDispatch[])
          -> CoCreateInstance->pDispExcelApp[];
        
        (if pDispExcelApp[]<>NONE then
            'Succeeded creating component.'->putLine;
         else
            'failed creating component.'->putLine;
            leave ControlExcel;
        if);

        'Invoking pDispExcelApp.Visible:' -> putline;
        (NONE, true) -> dParms.putBoolean;
        (pDispExcelApp[], 'Visible', dparms[], DISPATCH_PROPERTYPUT, NONE) 
          -> CallInvoke
          -> status;
        (if not status then
            leave ControlExcel;
        if);
        dparms.release;
       
       'Adding a sheet to the workbook' -> putline;
       (pDispExcelApp[], 'Workbooks', dparms[], DISPATCH_PROPERTYGET, varg1[]) 
          -> CallInvoke
          -> status;
        (if not status then
           leave ControlExcel;
       if);
        
       'Invoking pDispExcelApp.WorkBooks.Add:' -> putline;
       varg1[] -> VARIANT_init(# do pdispVal->pdispWorkbooks[] #);
        (if use_dual then 
            (# dual: ^Workbooks;
               RHS: @int32holder;
            do 'Calling Add using vtable' -> putline;
               pdispWorkbooks[] -> dual[]; (* should be a QIF? *)
               (*(varg, lcid, RHS[]) -> dual.add -> hr;*)
            #);
            (if hr.succeeded then
                'pdispWorkbooks.Add(template:=xlWorksheet) succeeded' 
                  -> putline;
             else
                ('pdispWorkbooks.Add(template:=xlWorksheet) failed',hr.value) 
                  -> ComErrorMessage;
                leave ControlExcel;
           if);
        else
            'Calling Add using invoke' -> putline;
            ('Template', xlWorksheet) -> dParms.putInt16;
            (pdispWorkbooks[], 'Add', dparms[], DISPATCH_METHOD, varg2[]) 
              -> CallInvoke
              -> status;
            (if not status then
                leave ControlExcel;
            if);
            dparms.release;
            varg2[] -> VARIANT_init(# do pdispVal->pdispWorkBook[] #);
       if);
     #);
   
   CleanUp;
   
#)



