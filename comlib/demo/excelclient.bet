ORIGIN '~beta/comlib/comlib';
INCLUDE '~beta/basiclib/external';
INCLUDE '~beta/sysutils/wstring';
INCLUDE '~beta/win32lib/winnt';
INCLUDE '~beta/comlib/oleauto';
INCLUDE '~beta/comlib/OAIdl';
INCLUDE '~beta/comlib/MsApplication/Excel8';

--PROGRAM: descriptor--
(# CLSID_XL: ^CLSID;
   clsstr: @BSTR;
   lcid: @integer;
   IID_IDispatch: @IID;
   hr: @HRESULT;
   dispid: @int32holder;
   wstr, error: @wstring;
   rgszNames: @ExternalRepetition(# elementSize::(# do 4->value #)#);
   params: @DISPPARAMS;
   varg, varg1, varg2: @VARIANT;
   
   pDispExcelApp, pdispWorkBooks, pdispWorkBook, pdispWorksheet, pdispRange, pdispCrt: 
     ^IDispatch;
   
   excel_progid: (# exit 'Excel.Application' #);
   
   use_abstraction: (# exit true #);
   
   use_dual: (# exit false (* does NOT work?? *)#);
   dual: ^Workbooks;
   RHS: @int32holder;
   
   DispatchParams: 
     (# varg: @VARIANT;
        rgvarg: @ExternalRepetition
          (# elementSize::(# do 16->value (* sizeof(VARIANT) *) #);
             inxCopy:
               (# inx: @int32;
               enter (inx)
               do (%getlongAt (@@varg + 0))  %putLongAt (ptr+4*inx+0);
                  (%getlongAt (@@varg + 4))  %putLongAt (ptr+4*inx+4);
                  (%getlongAt (@@varg + 8))  %putLongAt (ptr+4*inx+8);
                  (%getlongAt (@@varg + 12)) %putLongAt (ptr+4*inx+12);
               #);
          #);
        alpszArgNames: @ExternalRepetition
          (# elementSize::(# do 4->value (* sizeof( OLECHAR* ) *)#)#);
        rgdispidNamedArgs: @ExternalRepetition
          (# elementSize::(# do 4->value (* sizeof( DISPID* ) *)#)#);
        cArgs, cNamedArgs, maxArgs, maxNamedArgs: @integer;
        
        release:
          (# 
          #);
        
        check: 
          (# name: ^text;
             add: @integer;
          enter (name[])
          do (if cArgs+1>maxArgs then
                 ((2*rgvarg.range, cArgs+1) -> max) -> maxArgs;
                 maxArgs - rgvarg.range -> add;
                 add -> rgvarg.extend;
             if);
             (if (name[]<>NONE) and (cNamedArgs+1>maxNamedArgs) then
                 ((2*alpszArgNames.range, cNamedArgs+1) -> max) -> maxNamedArgs;
                 maxNamedArgs - alpszArgNames.range -> add;
                 add -> alpszArgNames.extend;
                 add -> rgdispidNamedArgs.extend;
             if);
             INNER;
          #);
        put: check
          (# wstr: @wstring;
          do (* If there is a name, add it *)
             (if name[]<>NONE then
                 (* First increment namecounter. Deliberately done before
                  * argument is put, since arguments come from index 1 
                  * (index 0 is for member name).
                  *)
                 cNamedArgs+1 -> cNamedArgs;
                 name[] -> wstr.set;
                 (wstr, cNamedArgs) -> alpszArgNames.inxPut;
             if);
             (* Specializations fill in varg in INNER *)
             INNER;
             cArgs -> rgvarg.inxCopy;
             cArgs+1 -> cArgs;
          #);
        
        putInt16: put
          (# value: @int16
          enter (value)
          do varg[]->VARIANT_init
             (# 
             do VT_I2 -> vt;
                value -> iVal;
             #);
          #);
        putBoolean: put
          (# value: @boolean
          enter (value)
          do varg[]->VARIANT_init
             (# 
             do VT_BOOL -> vt;
                (if value then
                    VARIANT_TRUE -> bool;
                 else
                    VARIANT_FALSE -> bool;
                if);                    
             #);
          #);
     #);
   
   CallInvoke:
     (# pdisp: ^IDispatch;
        member: ^text;
        params: ^DispatchParams;
        dParms: @DISPPARAMS;
        wAction: @integer;
        vReturn: ^VARIANT;
        cNamedArgs: @integer;
        dispidMember: @integer;
        hr: @HRESULT;
     enter (pdisp[], member[], params[], wAction, vReturn[])
     do params.cNamedArgs -> cNamedArgs;
        (* Look up DISPIDs of member name, and any possibly arguments
         * previously put to params.
         *)
        member[] -> params.check
        (# 
        do name[] -> wstr.set; 
           (wstr, 0) -> params.alpszArgNames.inxPut;
        #);
        (# dummy:@char do (IID_NULL, params.alpszArgNames, 1+cNamedArgs, lcid, params.rgdispidNamedArgs)
          -> pDisp.GetIdsOfNames
             -> hr; #);
        (if hr.succeeded then
            0->params.rgdispidNamedArgs.inxGet -> dispidmember;
            'Got Id for \'' -> puttext;
            member[]->puttext;
            '\': ' -> puttext;
            dispidMember -> putint;
            newline;
         else
            ('GetIdsOfNames Failed', hr.value) -> ComErrorMessage;
            leave CallInvoke;
        if);
        
        (* If doing a propertyput, we need to put adjust the first argument
         * to have a named arg of DISPID_PROPERTYPUT
         *)
        (if (wAction %Band DISPATCH_PROPERTYPUT) <> 0 then
            (* PROPERTY_PUT only have 1 named arg besides the "member name" *)
            1 -> cNamedArgs; 
            (DISPID_PROPERTYPUT, 1) -> params.rgdispidNamedArgs.inxPut;
        if);
        
        (* Now fill in the DISPPARAMS structure *)
        (# dummy: @char do 
           
           params.rgdispidNamedArgs + 4 -> dparms.rgdispidNamedArgs;
        params.rgvarg -> dparms.rgvarg;
        params.cArgs -> dparms.cArgs;
           cNamedArgs -> dparms.cNamedArgs;
           '@@dparms: ' -> puttext; @@dparms -> putint; newline;
           'params.cArgs: ' ->puttext; params.cArgs -> putint; newline;
           'dparms.cArgs: ' ->puttext; dparms.cArgs -> putint; newline;
        #);
        (* Finally call invoke *)
        (# dummy: @char do (dispidMember, IID_NULL, lcid, wAction, dParms[], vReturn[], NONE, NONE)
         -> pDisp.Invoke
             -> hr;#);
        (if hr.succeeded then
            'Invoke succeeded' -> putline;
            'Awaiting key-press: ' -> puttext;
            getline;
         else
            ('Invoke Failed', hr.value) -> ComErrorMessage;
        if);
     #);
   
   GetDispId:
     (# Name: ^text;
        pDisp: ^IDispatch
     enter (name[], pDisp[])
     do wstr.init;
        Name[] -> wstr.set;
        1 -> rgszNames.new;
        (wstr,0) -> rgszNames.inxPut;
        (*(IID_NULL, rgszNames, 1, LOCALE_SYSTEM_DEFAULT, dispid[])
          -> pDisp.GetIdsOfNames
          -> hr;*)
        (if hr.succeeded then
            'Got Id for \'' -> puttext;
            Name[]->puttext;
            '\': ' -> puttext;
            dispid.value -> putint;
            newline;
         else
            ('GetIdsOfNames Failed', hr.value) -> ComErrorMessage;
        if);
        wstr.free;
        rgszNames.free;
     #);
   
   dParms: @DispatchParams;
   
do 0->CoInitialize;
   LOCALE_USER_DEFAULT -> lcid;
   
   excel_progid -> clsstr.setText;
   clsstr[] -> CLSIDFromProgID -> CLSID_XL[];
   IDispatch_IID -> IID_IDispatch; 
   
   'Create component and get dispinterface'->putLine;
   
   (CLSID_XL[], NONE, CLSCTX_LOCAL_SERVER, IID_IDispatch[])
     -> CoCreateInstance->pDispExcelApp[];
   
   'CoCreateInstance done'->putLine;

   (if pDispExcelApp[]<>NONE then
       'Succeeded creating component.'->putLine;
       
       'Invoking pDispExcelApp.Visible:' -> putline;
       (if use_abstraction then
           (NONE, true) -> dParms.putBoolean;
           (pDispExcelApp[], 'Visible', dparms[], DISPATCH_PROPERTYPUT, NONE) 
             -> CallInvoke;
        else
            'Invoking pDispExcelApp.Visible: Getting DispId' -> putline;
           ('Visible', pDispExcelApp[]) -> GetDispId;
           'Invoking pDispExcelApp.Visible: Calling Invoke' -> putline;
           (* Set up parameters for Invoke *)
           1 -> rgszNames.new;
           (DISPID_PROPERTYPUT,0) -> rgszNames.inxPut;
           varg[]->VARIANT_init
           (# 
           do VT_BOOL -> vt;
              VARIANT_TRUE -> bool;
           #);
           @@varg -> params.rgvarg; (* Now we're getting insecure! *)
           rgszNames->params.rgdispidNamedArgs;
           1->params.cArgs;
           1->params.cNamedArgs;
           (dispid.value, IID_NULL, lcid, DISPATCH_PROPERTYPUT, params[], NONE, NONE, NONE)
             -> pDispExcelApp.Invoke
             -> hr;
           (if hr.succeeded then
               'Invoke succeeded' -> putline;
            else
               ('Invoke Failed', hr.value) -> ComErrorMessage;
           if);
           rgszNames.free;
       if);
       
       'Adding a sheet to the workbook' -> putline;
       
       (* Set up parameters for Invoke *)
       'Getting DispId' -> putline;
       ('Workbooks', pDispExcelApp[]) -> GetDispId;
       
       'Calling Invoke' -> putline;
       
       (* Set up parameters for Invoke *)
       0->params.cArgs;
       0->params.cNamedArgs;
       (dispid.value, IID_NULL, lcid, DISPATCH_PROPERTYGET, params[], varg1[], NONE, NONE)
         -> pDispExcelApp.Invoke
         -> hr;
       (if hr.succeeded then
           'PropertyGet("Workbooks") succeeded' -> putline;
        else
           ('PropertyGet("Workbooks")', hr.value) -> ComErrorMessage;
       if);
       
       'Invoking pDispExcelApp.WorkBooks.Add: Getting DispId' -> putline;
       varg1[] -> VARIANT_init(# do pdispVal->pdispWorkbooks[] #);
       
       ('Add', pdispWorkbooks[]) -> GetDispId;
       
       'Invoking pDispExcelApp.Workbooks.Add: ' -> putline;
       
       (* Set up parameters for Invoke *)
       wstr.init;
       'Template' -> wstr.set;
       1 -> rgszNames.new;
       ((*wstr*)0 (* dispid of "Template" *),0) -> rgszNames.inxPut;
       varg[]->VARIANT_init
       (# 
       do VT_I2 -> vt;
          xlWorksheet -> iVal;
       #);
       rgszNames->params.rgdispidNamedArgs;
       1->params.cArgs;
       1->params.cNamedArgs;
       @@varg -> params.rgvarg; (* Now we're getting insecure! *)
       
       (if use_dual then 
           'Calling Add using vtable' -> putline;
           pdispWorkbooks[] -> dual[]; (* should be a QIF *)
           (*(# dummy:@char do (varg, lcid, RHS[]) -> dual.add -> hr;#);*)
           (if hr.succeeded then
               'pdispWorkbooks.Add(template:=xlWorksheet) succeeded' -> putline;
            else
               ('pdispWorkbooks.Add(template:=xlWorksheet) failed', hr.value) -> ComErrorMessage;
           if);
        else
           'Calling Add using Invoke' -> putline;
           (dispid.value, IID_NULL, lcid, DISPATCH_METHOD, params[], varg2[], NONE, NONE)
             -> pdispWorkbooks.Invoke
             -> hr;
           (if hr.succeeded then
               'pdispExcelApp.Workbooks.Add(template:=xlWorksheet) succeeded' -> putline;
               varg2[] -> VARIANT_init(# do pdispVal->pdispWorkBook[] #);
            else
               ('pdispExcelApp.Workbooks.Add(template:=xlWorksheet) failed', hr.value) -> ComErrorMessage;
           if);
       if);
       
       rgszNames.free;
       wstr.free;
       
       
       
       
       
       'Awaiting key-press before releasing interface: ' -> puttext;
       getline;
       
       'Releasing interfaces' -> putline;
       (if pDispExcelApp[]<>NONE then 
           pDispExcelApp.Release; 
           'Succeeded releasing dispinterface'->putline;
       if);
    else
       'Could not create component'->putline;
   if); 
   'CoUninitialize'->putline;
   CoUninitialize;
   'CoUninitialize done'->putline;
#)



