(* BETA interface generated from "E:\users\datpete\beta\r5.1\comlib\OleIdl.Idl"
 * with options: -F -q 
 *)
ORIGIN '~beta/comlib/comtypes';
INCLUDE 'ObjIdl';
--LIB: attributes-- ;
  (* //+------------------------------------------------------------------------- *)
  (* // *)
  (* //  Microsoft Windows *)
  (* //  Copyright (C) Microsoft Corporation, 1992-1997. *)
  (* // *)
  (* //-------------------------------------------------------------------------- *)

  IOleAdviseHolder_IID: (# exit '00000111-0000-0000-C000-000000000046' #);

  IOleAdviseHolder: IUnknown
    (# <<SLOT IOleAdviseHolderLib: attributes>>;
       Advise:<
         (# result: @int32 (* HRESULT *);
            pAdvise: ^IAdviseSink (* IAdviseSink* *); 
            pdwConnection: ^int32uHolder (* DWORD* *); 
         enter (pAdvise[], pdwConnection[])
         do INNER;
         exit result
         #);
       Unadvise:<
         (# result: @int32 (* HRESULT *);
            dwConnection: @int32u (* DWORD *); 
         enter dwConnection
         do INNER;
         exit result
         #);
       EnumAdvise:<
         (# result: @int32 (* HRESULT *);
            ppenumAdvise: ^IEnumSTATDATAHolder (* IEnumSTATDATA** *); 
         enter ppenumAdvise[]
         do INNER;
         exit result
         #);
       SendOnRename:<
         (# result: @int32 (* HRESULT *);
            pmk: ^IMoniker (* IMoniker* *); 
         enter pmk[]
         do INNER;
         exit result
         #);
       SendOnSave:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       SendOnClose:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
    #);

  IOleCache_IID: (# exit '0000011e-0000-0000-C000-000000000046' #);

  IOleCache: IUnknown
    (# <<SLOT IOleCacheLib: attributes>>;
       Cache:<
         (# result: @int32 (* HRESULT *);
            pformatetc: ^struct_tagFORMATETC (* FORMATETC* *); 
            _advf: @int32u (* DWORD *); 
            pdwConnection: ^int32uHolder (* DWORD* *); 
         enter (pformatetc[], _advf, pdwConnection[])
         do INNER;
         exit result
         #);
       Uncache:<
         (# result: @int32 (* HRESULT *);
            dwConnection: @int32u (* DWORD *); 
         enter dwConnection
         do INNER;
         exit result
         #);
       EnumCache:<
         (# result: @int32 (* HRESULT *);
            ppenumSTATDATA: ^IEnumSTATDATAHolder (* IEnumSTATDATA** *); 
         enter ppenumSTATDATA[]
         do INNER;
         exit result
         #);
       InitCache:<
         (# result: @int32 (* HRESULT *);
            pDataObject: ^IDataObject (* IDataObject* *); 
         enter pDataObject[]
         do INNER;
         exit result
         #);
       SetData:<
         (# result: @int32 (* HRESULT *);
            pformatetc: ^struct_tagFORMATETC (* FORMATETC* *); 
            pmedium: ^struct_tagSTGMEDIUM (* STGMEDIUM* *); 
            fRelease: @int32 (* BOOL *); 
         enter (pformatetc[], pmedium[], fRelease)
         do INNER;
         exit result
         #);
    #);

  IOleCache2_IID: (# exit '00000128-0000-0000-C000-000000000046' #);

  IOleCache2: IOleCache
    (# <<SLOT IOleCache2Lib: attributes>>;
       UpdateCache:<
         (# result: @int32 (* HRESULT *);
            pDataObject: ^IDataObject (* LPDATAOBJECT *); 
            grfUpdf: @int32u (* DWORD *); 
            pReserved: @int32 (* LPVOID *); 
         enter (pDataObject[], grfUpdf, pReserved[])
         do INNER;
         exit result
         #);
       RemoteUpdateCache: (* call_as(UpdateCache) *)
         (# result: @int32 (* HRESULT *);
            pDataObject: ^IDataObject (* LPDATAOBJECT *); 
            grfUpdf: @int32u (* DWORD *); 
            pReserved: @int32u (* DWORD *); 
         enter (pDataObject[], grfUpdf, pReserved)
         do INNER;
         exit result
         #);
       DiscardCache:<
         (# result: @int32 (* HRESULT *);
            dwDiscardOptions: @int32u (* DWORD *); 
         enter dwDiscardOptions
         do INNER;
         exit result
         #);
    #);
  UPDFCACHE_NODATACACHE: (# exit 0x00000001 #);
  UPDFCACHE_ONSAVECACHE: (# exit 0x00000002 #);
  UPDFCACHE_ONSTOPCACHE: (# exit 0x00000004 #);
  UPDFCACHE_NORMALCACHE: (# exit 0x00000008 #);
  UPDFCACHE_IFBLANK: (# exit 0x00000010 #);
  UPDFCACHE_ONLYIFBLANK: (# exit 0x80000000 #);
  UPDFCACHE_IFBLANKORONSAVECACHE: (# exit (UPDFCACHE_IFBLANK %Bor UPDFCACHE_ONSAVECACHE) #);
  UPDFCACHE_ALL: (# exit (((UPDFCACHE_ONLYIFBLANK))) #);
  UPDFCACHE_ALLBUTNODATACACHE: (# exit (UPDFCACHE_ALL %Band ((UPDFCACHE_NODATACACHE))) #);
  enum_DISCARDCACHE: IntegerObject(# (* enum tagDISCARDCACHE *) #);
  DISCARDCACHE_SAVEIFDIRTY: (* DISCARDCACHE *)(# exit 0 #);
  DISCARDCACHE_NOSAVE: (* DISCARDCACHE *)(# exit 1 #);


  IOleCacheControl_IID: (# exit '00000129-0000-0000-C000-000000000046' #);

  IOleCacheControl: IUnknown
    (# <<SLOT IOleCacheControlLib: attributes>>;
       OnRun:<
         (# result: @int32 (* HRESULT *);
            pDataObject: ^IDataObject (* LPDATAOBJECT *); 
         enter pDataObject[]
         do INNER;
         exit result
         #);
       OnStop:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
    #);

  IParseDisplayName_IID: (# exit '0000011a-0000-0000-C000-000000000046' #);

  IParseDisplayName: IUnknown
    (# <<SLOT IParseDisplayNameLib: attributes>>;
       ParseDisplayName:<
         (# result: @int32 (* HRESULT *);
            pbc: ^IBindCtx (* IBindCtx* *); 
            pszDisplayName: [0]@char (* ^text NYI *) (* LPOLESTR *); 
            pchEaten: ^int32uHolder (* ULONG* *); 
            ppmkOut: ^IMonikerHolder (* IMoniker** *); 
         enter (pbc[], pszDisplayName, pchEaten[], ppmkOut[])
         do INNER;
         exit result
         #);
    #);

  IOleContainer_IID: (# exit '0000011b-0000-0000-C000-000000000046' #);

  IOleContainer: IParseDisplayName
    (# <<SLOT IOleContainerLib: attributes>>;
       EnumObjects:<
         (# result: @int32 (* HRESULT *);
            grfFlags: @int32u (* DWORD *); 
            ppenum: ^IEnumUnknownHolder (* IEnumUnknown** *); 
         enter (grfFlags, ppenum[])
         do INNER;
         exit result
         #);
       LockContainer:<
         (# result: @int32 (* HRESULT *);
            fLock: @int32 (* BOOL *); 
         enter fLock
         do INNER;
         exit result
         #);
    #);

  IOleClientSite_IID: (# exit '00000118-0000-0000-C000-000000000046' #);

  IOleClientSite: IUnknown
    (# <<SLOT IOleClientSiteLib: attributes>>;
       SaveObject:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       GetMoniker:<
         (# result: @int32 (* HRESULT *);
            dwAssign: @int32u (* DWORD *); 
            dwWhichMoniker: @int32u (* DWORD *); 
            ppmk: ^IMonikerHolder (* IMoniker** *); 
         enter (dwAssign, dwWhichMoniker, ppmk[])
         do INNER;
         exit result
         #);
       GetContainer:<
         (# result: @int32 (* HRESULT *);
            ppContainer: ^IOleContainerHolder (* IOleContainer** *); 
         enter ppContainer[]
         do INNER;
         exit result
         #);
       ShowObject:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       OnShowWindow:<
         (# result: @int32 (* HRESULT *);
            fShow: @int32 (* BOOL *); 
         enter fShow
         do INNER;
         exit result
         #);
       RequestNewObjectLayout:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
    #);

  IOleObject_IID: (# exit '00000112-0000-0000-C000-000000000046' #);

  IOleObject: IUnknown
    (# <<SLOT IOleObjectLib: attributes>>;
       SetClientSite:<
         (# result: @int32 (* HRESULT *);
            pClientSite: ^IOleClientSite (* IOleClientSite* *); 
         enter pClientSite[]
         do INNER;
         exit result
         #);
       GetClientSite:<
         (# result: @int32 (* HRESULT *);
            ppClientSite: ^IOleClientSiteHolder (* IOleClientSite** *); 
         enter ppClientSite[]
         do INNER;
         exit result
         #);
       SetHostNames:<
         (# result: @int32 (* HRESULT *);
            szContainerApp: [0]@char (* ^text NYI *) (* LPCOLESTR *); 
            szContainerObj: [0]@char (* ^text NYI *) (* LPCOLESTR *); 
         enter (szContainerApp, szContainerObj)
         do INNER;
         exit result
         #);
       Close:<
         (# result: @int32 (* HRESULT *);
            dwSaveOption: @int32u (* DWORD *); 
         enter dwSaveOption
         do INNER;
         exit result
         #);
       SetMoniker:<
         (# result: @int32 (* HRESULT *);
            dwWhichMoniker: @int32u (* DWORD *); 
            pmk: ^IMoniker (* IMoniker* *); 
         enter (dwWhichMoniker, pmk[])
         do INNER;
         exit result
         #);
       GetMoniker:<
         (# result: @int32 (* HRESULT *);
            dwAssign: @int32u (* DWORD *); 
            dwWhichMoniker: @int32u (* DWORD *); 
            ppmk: ^IMonikerHolder (* IMoniker** *); 
         enter (dwAssign, dwWhichMoniker, ppmk[])
         do INNER;
         exit result
         #);
       InitFromData:<
         (# result: @int32 (* HRESULT *);
            pDataObject: ^IDataObject (* IDataObject* *); 
            fCreation: @int32 (* BOOL *); 
            dwReserved: @int32u (* DWORD *); 
         enter (pDataObject[], fCreation, dwReserved)
         do INNER;
         exit result
         #);
       GetClipboardData:<
         (# result: @int32 (* HRESULT *);
            dwReserved: @int32u (* DWORD *); 
            ppDataObject: ^IDataObjectHolder (* IDataObject** *); 
         enter (dwReserved, ppDataObject[])
         do INNER;
         exit result
         #);
       DoVerb:<
         (# result: @int32 (* HRESULT *);
            iVerb: @int32 (* LONG *); 
            _lpmsg: ^struct_tagMSG (* LPMSG *); 
            pActiveSite: ^IOleClientSite (* IOleClientSite* *); 
            lindex: @int32 (* LONG *); 
            hwndParent: @int32 (* HWND *); 
            lprcPosRect: ^struct_tagRECT (* LPCRECT *); 
         enter (iVerb, _lpmsg[], pActiveSite[], lindex, hwndParent[], lprcPosRect[])
         do INNER;
         exit result
         #);
       EnumVerbs:<
         (# result: @int32 (* HRESULT *);
            ppEnumOleVerb: ^IEnumOLEVERBHolder (* IEnumOLEVERB** *); 
         enter ppEnumOleVerb[]
         do INNER;
         exit result
         #);
       Update:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       IsUpToDate:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       GetUserClassID:<
         (# result: @int32 (* HRESULT *);
            pClsid: ^GUIDdata (* CLSID* *); 
         enter pClsid[]
         do INNER;
         exit result
         #);
       GetUserType:<
         (# result: @int32 (* HRESULT *);
            dwFormOfType: @int32u (* DWORD *); 
            pszUserType: ^textHolder (* LPOLESTR* *); 
         enter (dwFormOfType, pszUserType[])
         do INNER;
         exit result
         #);
       SetExtent:<
         (# result: @int32 (* HRESULT *);
            dwDrawAspect: @int32u (* DWORD *); 
            _psizel: ^struct_tagSIZEL (* SIZEL* *); 
         enter (dwDrawAspect, _psizel[])
         do INNER;
         exit result
         #);
       GetExtent:<
         (# result: @int32 (* HRESULT *);
            dwDrawAspect: @int32u (* DWORD *); 
            _psizel: ^struct_tagSIZEL (* SIZEL* *); 
         enter (dwDrawAspect, _psizel[])
         do INNER;
         exit result
         #);
       Advise:<
         (# result: @int32 (* HRESULT *);
            pAdvSink: ^IAdviseSink (* IAdviseSink* *); 
            pdwConnection: ^int32uHolder (* DWORD* *); 
         enter (pAdvSink[], pdwConnection[])
         do INNER;
         exit result
         #);
       Unadvise:<
         (# result: @int32 (* HRESULT *);
            dwConnection: @int32u (* DWORD *); 
         enter dwConnection
         do INNER;
         exit result
         #);
       EnumAdvise:<
         (# result: @int32 (* HRESULT *);
            ppenumAdvise: ^IEnumSTATDATAHolder (* IEnumSTATDATA** *); 
         enter ppenumAdvise[]
         do INNER;
         exit result
         #);
       GetMiscStatus:<
         (# result: @int32 (* HRESULT *);
            dwAspect: @int32u (* DWORD *); 
            pdwStatus: ^int32uHolder (* DWORD* *); 
         enter (dwAspect, pdwStatus[])
         do INNER;
         exit result
         #);
       SetColorScheme:<
         (# result: @int32 (* HRESULT *);
            pLogpal: ^struct_tagLOGPALETTE (* LOGPALETTE* *); 
         enter pLogpal[]
         do INNER;
         exit result
         #);
    #);
  enum_OLEGETMONIKER: IntegerObject(# (* enum tagOLEGETMONIKER *) #);
  OLEGETMONIKER_ONLYIFTHERE: (* OLEGETMONIKER *)(# exit 1 #);
  OLEGETMONIKER_FORCEASSIGN: (* OLEGETMONIKER *)(# exit 2 #);
  OLEGETMONIKER_UNASSIGN: (* OLEGETMONIKER *)(# exit 3 #);
  OLEGETMONIKER_TEMPFORUSER: (* OLEGETMONIKER *)(# exit 4 #);

  enum_OLEWHICHMK: IntegerObject(# (* enum tagOLEWHICHMK *) #);
  OLEWHICHMK_CONTAINER: (* OLEWHICHMK *)(# exit 1 #);
  OLEWHICHMK_OBJREL: (* OLEWHICHMK *)(# exit 2 #);
  OLEWHICHMK_OBJFULL: (* OLEWHICHMK *)(# exit 3 #);

  enum_USERCLASSTYPE: IntegerObject(# (* enum tagUSERCLASSTYPE *) #);
  USERCLASSTYPE_FULL: (* USERCLASSTYPE *)(# exit 1 #);
  USERCLASSTYPE_SHORT: (* USERCLASSTYPE *)(# exit 2 #);
  USERCLASSTYPE_APPNAME: (* USERCLASSTYPE *)(# exit 3 #);

  enum_OLEMISC: IntegerObject(# (* enum tagOLEMISC *) #);
  OLEMISC_RECOMPOSEONRESIZE: (* OLEMISC *)(# exit 0x00000001 #);
  OLEMISC_ONLYICONIC: (* OLEMISC *)(# exit 0x00000002 #);
  OLEMISC_INSERTNOTREPLACE: (* OLEMISC *)(# exit 0x00000004 #);
  OLEMISC_STATIC: (* OLEMISC *)(# exit 0x00000008 #);
  OLEMISC_CANTLINKINSIDE: (* OLEMISC *)(# exit 0x00000010 #);
  OLEMISC_CANLINKBYOLE1: (* OLEMISC *)(# exit 0x00000020 #);
  OLEMISC_ISLINKOBJECT: (* OLEMISC *)(# exit 0x00000040 #);
  OLEMISC_INSIDEOUT: (* OLEMISC *)(# exit 0x00000080 #);
  OLEMISC_ACTIVATEWHENVISIBLE: (* OLEMISC *)(# exit 0x00000100 #);
  OLEMISC_RENDERINGISDEVICEINDEPENDENT: (* OLEMISC *)(# exit 0x00000200 #);
  OLEMISC_INVISIBLEATRUNTIME: (* OLEMISC *)(# exit 0x00000400 #);
  OLEMISC_ALWAYSRUN: (* OLEMISC *)(# exit 0x00000800 #);
  OLEMISC_ACTSLIKEBUTTON: (* OLEMISC *)(# exit 0x00001000 #);
  OLEMISC_ACTSLIKELABEL: (* OLEMISC *)(# exit 0x00002000 #);
  OLEMISC_NOUIACTIVATE: (* OLEMISC *)(# exit 0x00004000 #);
  OLEMISC_ALIGNABLE: (* OLEMISC *)(# exit 0x00008000 #);
  OLEMISC_SIMPLEFRAME: (* OLEMISC *)(# exit 0x00010000 #);
  OLEMISC_SETCLIENTSITEFIRST: (* OLEMISC *)(# exit 0x00020000 #);
  OLEMISC_IMEMODE: (* OLEMISC *)(# exit 0x00040000 #);
  OLEMISC_IGNOREACTIVATEWHENVISIBLE: (* OLEMISC *)(# exit 0x00080000 #);
  OLEMISC_WANTSTOMENUMERGE: (* OLEMISC *)(# exit 0x00100000 #);
  OLEMISC_SUPPORTSMULTILEVELUNDO: (* OLEMISC *)(# exit 0x00200000 #);

  enum_OLECLOSE: IntegerObject(# (* enum tagOLECLOSE *) #);
  OLECLOSE_SAVEIFDIRTY: (* OLECLOSE *)(# exit 0 #);
  OLECLOSE_NOSAVE: (* OLECLOSE *)(# exit 1 #);
  OLECLOSE_PROMPTSAVE: (* OLECLOSE *)(# exit 2 #);


  IOLETypes_IID: (# exit 'B0916C84-7416-101A-BCEA-08002B2B79EF' #);

  IOLETypes: COM
    (# <<SLOT IOLETypesLib: attributes>>;
    #);
  enum_OLERENDER: IntegerObject(# (* enum tagOLERENDER *) #);
  OLERENDER_NONE: (* OLERENDER *)(# exit 0 #);
  OLERENDER_DRAW: (* OLERENDER *)(# exit 1 #);
  OLERENDER_FORMAT: (* OLERENDER *)(# exit 2 #);
  OLERENDER_ASIS: (* OLERENDER *)(# exit 3 #);

  OBJECTDESCRIPTOR: struct_tagOBJECTDESCRIPTOR(# #);
  struct_tagOBJECTDESCRIPTOR: DATA
    (# cbSize: @int32u (* ULONG *);
       _clsid: @GUIDdata (* CLSID *);
       dwDrawAspect: @int32u (* DWORD *);
       sizel: @struct_tagSIZEL (* SIZEL *);
       pointl: @struct__POINTL (* POINTL *);
       dwStatus: @int32u (* DWORD *);
       dwFullUserTypeName: @int32u (* DWORD *);
       dwSrcOfCopy: @int32u (* DWORD *);
    #);
  LINKSRCDESCRIPTOR: struct_tagOBJECTDESCRIPTOR(# #);

  IOleWindow_IID: (# exit '00000114-0000-0000-C000-000000000046' #);

  IOleWindow: IUnknown
    (# <<SLOT IOleWindowLib: attributes>>;
       GetWindow:<
         (# result: @int32 (* HRESULT *);
            phwnd: ^int32Holder (* HWND* *); 
         enter phwnd[]
         do INNER;
         exit result
         #);
       ContextSensitiveHelp:<
         (# result: @int32 (* HRESULT *);
            fEnterMode: @int32 (* BOOL *); 
         enter fEnterMode
         do INNER;
         exit result
         #);
    #);

  IOleLink_IID: (# exit '0000011d-0000-0000-C000-000000000046' #);

  IOleLink: IUnknown
    (# <<SLOT IOleLinkLib: attributes>>;
       SetUpdateOptions:<
         (# result: @int32 (* HRESULT *);
            dwUpdateOpt: @int32u (* DWORD *); 
         enter dwUpdateOpt
         do INNER;
         exit result
         #);
       GetUpdateOptions:<
         (# result: @int32 (* HRESULT *);
            pdwUpdateOpt: ^int32uHolder (* DWORD* *); 
         enter pdwUpdateOpt[]
         do INNER;
         exit result
         #);
       SetSourceMoniker:<
         (# result: @int32 (* HRESULT *);
            pmk: ^IMoniker (* IMoniker* *); 
            rclsid: ^GUIDdata (* REFCLSID *); 
         enter (pmk[], rclsid[])
         do INNER;
         exit result
         #);
       GetSourceMoniker:<
         (# result: @int32 (* HRESULT *);
            ppmk: ^IMonikerHolder (* IMoniker** *); 
         enter ppmk[]
         do INNER;
         exit result
         #);
       SetSourceDisplayName:<
         (# result: @int32 (* HRESULT *);
            pszStatusText: [0]@char (* ^text NYI *) (* LPCOLESTR *); 
         enter pszStatusText
         do INNER;
         exit result
         #);
       GetSourceDisplayName:<
         (# result: @int32 (* HRESULT *);
            ppszDisplayName: ^textHolder (* LPOLESTR* *); 
         enter ppszDisplayName[]
         do INNER;
         exit result
         #);
       BindToSource:<
         (# result: @int32 (* HRESULT *);
            bindflags: @int32u (* DWORD *); 
            pbc: ^IBindCtx (* IBindCtx* *); 
         enter (bindflags, pbc[])
         do INNER;
         exit result
         #);
       BindIfRunning:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       GetBoundSource:<
         (# result: @int32 (* HRESULT *);
            ppunk: ^IUnknownHolder (* IUnknown** *); 
         enter ppunk[]
         do INNER;
         exit result
         #);
       UnbindSource:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       Update:<
         (# result: @int32 (* HRESULT *);
            pbc: ^IBindCtx (* IBindCtx* *); 
         enter pbc[]
         do INNER;
         exit result
         #);
    #);
  enum_OLEUPDATE: IntegerObject(# (* enum tagOLEUPDATE *) #);
  OLEUPDATE_ALWAYS: (* OLEUPDATE *)(# exit 1 #);
  OLEUPDATE_ONCALL: (* OLEUPDATE *)(# exit 3 #);

  enum_OLELINKBIND: IntegerObject(# (* enum tagOLELINKBIND *) #);
  OLELINKBIND_EVENIFCLASSDIFF: (* OLELINKBIND *)(# exit 1 #);


  IOleItemContainer_IID: (# exit '0000011c-0000-0000-C000-000000000046' #);

  IOleItemContainer: IOleContainer
    (# <<SLOT IOleItemContainerLib: attributes>>;
       GetObject:<
         (# result: @int32 (* HRESULT *);
            pszItem: [0]@char (* ^text NYI *) (* LPOLESTR *); 
            dwSpeedNeeded: @int32u (* DWORD *); 
            pbc: ^IBindCtx (* IBindCtx* *); 
            riid: ^GUIDdata (* REFIID *); 
            ppvObject: ^IUnknownHolder (* void** *); 
         enter (pszItem, dwSpeedNeeded, pbc[], riid[], ppvObject[])
         do INNER;
         exit result
         #);
       GetObjectStorage:<
         (# result: @int32 (* HRESULT *);
            pszItem: [0]@char (* ^text NYI *) (* LPOLESTR *); 
            pbc: ^IBindCtx (* IBindCtx* *); 
            riid: ^GUIDdata (* REFIID *); 
            ppvStorage: ^IUnknownHolder (* void** *); 
         enter (pszItem, pbc[], riid[], ppvStorage[])
         do INNER;
         exit result
         #);
       IsRunning:<
         (# result: @int32 (* HRESULT *);
            pszItem: [0]@char (* ^text NYI *) (* LPOLESTR *); 
         enter pszItem
         do INNER;
         exit result
         #);
    #);
  enum_BINDSPEED: IntegerObject(# (* enum tagBINDSPEED *) #);
  BINDSPEED_INDEFINITE: (* BINDSPEED *)(# exit 1 #);
  BINDSPEED_MODERATE: (* BINDSPEED *)(# exit 2 #);
  BINDSPEED_IMMEDIATE: (* BINDSPEED *)(# exit 3 #);

  enum_OLECONTF: IntegerObject(# (* enum tagOLECONTF *) #);
  OLECONTF_EMBEDDINGS: (* OLECONTF *)(# exit 1 #);
  OLECONTF_LINKS: (* OLECONTF *)(# exit 2 #);
  OLECONTF_OTHERS: (* OLECONTF *)(# exit 4 #);
  OLECONTF_ONLYUSER: (* OLECONTF *)(# exit 8 #);
  OLECONTF_ONLYIFRUNNING: (* OLECONTF *)(# exit 16 #);


  IOleInPlaceUIWindow_IID: (# exit '00000115-0000-0000-C000-000000000046' #);

  IOleInPlaceUIWindow: IOleWindow
    (# <<SLOT IOleInPlaceUIWindowLib: attributes>>;
       GetBorder:<
         (# result: @int32 (* HRESULT *);
            lprectBorder: ^struct_tagRECT (* LPRECT *); 
         enter lprectBorder[]
         do INNER;
         exit result
         #);
       RequestBorderSpace:<
         (# result: @int32 (* HRESULT *);
            pborderwidths: ^struct_tagRECT (* LPCBORDERWIDTHS *); 
         enter pborderwidths[]
         do INNER;
         exit result
         #);
       SetBorderSpace:<
         (# result: @int32 (* HRESULT *);
            pborderwidths: ^struct_tagRECT (* LPCBORDERWIDTHS *); 
         enter pborderwidths[]
         do INNER;
         exit result
         #);
       SetActiveObject:<
         (# result: @int32 (* HRESULT *);
            pActiveObject: ^IOleInPlaceActiveObject (* IOleInPlaceActiveObject* *); 
            pszObjName: [0]@char (* ^text NYI *) (* LPCOLESTR *); 
         enter (pActiveObject[], pszObjName)
         do INNER;
         exit result
         #);
    #);

  IOleInPlaceActiveObject_IID: (# exit '00000117-0000-0000-C000-000000000046' #);

  IOleInPlaceActiveObject: IOleWindow
    (# <<SLOT IOleInPlaceActiveObjectLib: attributes>>;
       TranslateAccelerator:<
         (# result: @int32 (* HRESULT *);
            _lpmsg: ^struct_tagMSG (* LPMSG *); 
         enter _lpmsg[]
         do INNER;
         exit result
         #);
       RemoteTranslateAccelerator: (* call_as(TranslateAccelerator) *)
         (# result: @int32 (* HRESULT *);
         do INNER;
         exit result
         #);
       OnFrameWindowActivate:<
         (# result: @int32 (* HRESULT *);
            fActivate: @int32 (* BOOL *); 
         enter fActivate
         do INNER;
         exit result
         #);
       OnDocWindowActivate:<
         (# result: @int32 (* HRESULT *);
            fActivate: @int32 (* BOOL *); 
         enter fActivate
         do INNER;
         exit result
         #);
       ResizeBorder:<
         (# result: @int32 (* HRESULT *);
            prcBorder: ^struct_tagRECT (* LPCRECT *); 
            pUIWindow: ^IOleInPlaceUIWindow (* IOleInPlaceUIWindow* *); 
            fFrameWindow: @int32 (* BOOL *); 
         enter (prcBorder[], pUIWindow[], fFrameWindow)
         do INNER;
         exit result
         #);
       RemoteResizeBorder: (* call_as(ResizeBorder) *)
         (# result: @int32 (* HRESULT *);
            prcBorder: ^struct_tagRECT (* LPCRECT *); 
            riid: ^GUIDdata (* REFIID *); 
            pUIWindow: ^IOleInPlaceUIWindow (* IOleInPlaceUIWindow* *); 
            fFrameWindow: @int32 (* BOOL *); 
         enter (prcBorder[], riid[], pUIWindow[], fFrameWindow)
         do INNER;
         exit result
         #);
       EnableModeless:<
         (# result: @int32 (* HRESULT *);
            fEnable: @int32 (* BOOL *); 
         enter fEnable
         do INNER;
         exit result
         #);
    #);

  IOleInPlaceFrame_IID: (# exit '00000116-0000-0000-C000-000000000046' #);

  IOleInPlaceFrame: IOleInPlaceUIWindow
    (# <<SLOT IOleInPlaceFrameLib: attributes>>;
       InsertMenus:<
         (# result: @int32 (* HRESULT *);
            hmenuShared: @int32 (* HMENU *); 
            lpMenuWidths: ^struct_tagOleMenuGroupWidths (* LPOLEMENUGROUPWIDTHS *); 
         enter (hmenuShared[], lpMenuWidths[])
         do INNER;
         exit result
         #);
       SetMenu:<
         (# result: @int32 (* HRESULT *);
            hmenuShared: @int32 (* HMENU *); 
            _holemenu: @int32 (* HOLEMENU *); 
            hwndActiveObject: @int32 (* HWND *); 
         enter (hmenuShared[], _holemenu[], hwndActiveObject[])
         do INNER;
         exit result
         #);
       RemoveMenus:<
         (# result: @int32 (* HRESULT *);
            hmenuShared: @int32 (* HMENU *); 
         enter hmenuShared[]
         do INNER;
         exit result
         #);
       SetStatusText:<
         (# result: @int32 (* HRESULT *);
            pszStatusText: [0]@char (* ^text NYI *) (* LPCOLESTR *); 
         enter pszStatusText
         do INNER;
         exit result
         #);
       EnableModeless:<
         (# result: @int32 (* HRESULT *);
            fEnable: @int32 (* BOOL *); 
         enter fEnable
         do INNER;
         exit result
         #);
       TranslateAccelerator:<
         (# result: @int32 (* HRESULT *);
            _lpmsg: ^struct_tagMSG (* LPMSG *); 
            wID: @int16u (* WORD *); 
         enter (_lpmsg[], wID)
         do INNER;
         exit result
         #);
    #);
  OLEINPLACEFRAMEINFO: struct_tagOIFI(# #);
  struct_tagOIFI: DATA
    (# cb: @int32u (* UINT *);
       fMDIApp: @int32 (* BOOL *);
       hwndFrame: @int32Holder (* HWND* *);
       haccel: @int32Holder (* HACCEL* *);
       cAccelEntries: @int32u (* UINT *);
    #);
  OLEMENUGROUPWIDTHS: struct_tagOleMenuGroupWidths(# #);
  struct_tagOleMenuGroupWidths: DATA
    (# width: ^int32Holder (* LONG *);
    #);

  IOleInPlaceObject_IID: (# exit '00000113-0000-0000-C000-000000000046' #);

  IOleInPlaceObject: IOleWindow
    (# <<SLOT IOleInPlaceObjectLib: attributes>>;
       InPlaceDeactivate:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       UIDeactivate:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       SetObjectRects:<
         (# result: @int32 (* HRESULT *);
            lprcPosRect: ^struct_tagRECT (* LPCRECT *); 
            lprcClipRect: ^struct_tagRECT (* LPCRECT *); 
         enter (lprcPosRect[], lprcClipRect[])
         do INNER;
         exit result
         #);
       ReactivateAndUndo:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
    #);

  IOleInPlaceSite_IID: (# exit '00000119-0000-0000-C000-000000000046' #);

  IOleInPlaceSite: IOleWindow
    (# <<SLOT IOleInPlaceSiteLib: attributes>>;
       CanInPlaceActivate:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       OnInPlaceActivate:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       OnUIActivate:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       GetWindowContext:<
         (# result: @int32 (* HRESULT *);
            ppFrame: ^IOleInPlaceFrameHolder (* IOleInPlaceFrame** *); 
            ppDoc: ^IOleInPlaceUIWindowHolder (* IOleInPlaceUIWindow** *); 
            lprcPosRect: ^struct_tagRECT (* LPRECT *); 
            lprcClipRect: ^struct_tagRECT (* LPRECT *); 
            lpFrameInfo: ^struct_tagOIFI (* LPOLEINPLACEFRAMEINFO *); 
         enter (ppFrame[], ppDoc[], lprcPosRect[], lprcClipRect[], lpFrameInfo[])
         do INNER;
         exit result
         #);
       Scroll:<
         (# result: @int32 (* HRESULT *);
            scrollExtant: @struct_tagSIZE (* SIZE *); 
         enter scrollExtant
         do INNER;
         exit result
         #);
       OnUIDeactivate:<
         (# result: @int32 (* HRESULT *);
            fUndoable: @int32 (* BOOL *); 
         enter fUndoable
         do INNER;
         exit result
         #);
       OnInPlaceDeactivate:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       DiscardUndoState:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       DeactivateAndUndo:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       OnPosRectChange:<
         (# result: @int32 (* HRESULT *);
            lprcPosRect: ^struct_tagRECT (* LPCRECT *); 
         enter lprcPosRect[]
         do INNER;
         exit result
         #);
    #);

  IContinue_IID: (# exit '0000012a-0000-0000-C000-000000000046' #);

  IContinue: IUnknown
    (# <<SLOT IContinueLib: attributes>>;
       FContinue:<
         (# result: @int32 (* HRESULT *);
         do INNER;
         exit result
         #);
    #);

  IViewObject_IID: (# exit '0000010d-0000-0000-C000-000000000046' #);

  IViewObject: IUnknown
    (# <<SLOT IViewObjectLib: attributes>>;
       Draw:<
         (# result: @int32 (* HRESULT *);
            dwDrawAspect: @int32u (* DWORD *); 
            lindex: @int32 (* LONG *); 
            pvAspect: ^IUnknown (* void* *); 
            ptd: ^struct_tagDVTARGETDEVICE (* DVTARGETDEVICE* *); 
            hdcTargetDev: @int32 (* HDC *); 
            hdcDraw: @int32 (* HDC *); 
            lprcBounds: ^struct__RECTL (* LPCRECTL *); 
            lprcWBounds: ^struct__RECTL (* LPCRECTL *); 
            ___________pfnContinue: @int32 (* ___________pfnContinue *); 
            dwContinue: @int32u (* DWORD *); 
         enter (dwDrawAspect, lindex, pvAspect[], ptd[], hdcTargetDev[], hdcDraw[], lprcBounds[], lprcWBounds[], ___________pfnContinue, dwContinue)
         do INNER;
         exit result
         #);
       RemoteDraw: (* call_as(Draw) *)
         (# result: @int32 (* HRESULT *);
            dwDrawAspect: @int32u (* DWORD *); 
            lindex: @int32 (* LONG *); 
            pvAspect: @int32u (* DWORD *); 
            ptd: ^struct_tagDVTARGETDEVICE (* DVTARGETDEVICE* *); 
            hdcTargetDev: @int32u (* DWORD *); 
            hdcDraw: @int32u (* DWORD *); 
            lprcBounds: ^struct__RECTL (* LPCRECTL *); 
            lprcWBounds: ^struct__RECTL (* LPCRECTL *); 
            pContinue: ^IContinue (* IContinue* *); 
         enter (dwDrawAspect, lindex, pvAspect, ptd[], hdcTargetDev, hdcDraw, lprcBounds[], lprcWBounds[], pContinue[])
         do INNER;
         exit result
         #);
       GetColorSet:<
         (# result: @int32 (* HRESULT *);
            dwDrawAspect: @int32u (* DWORD *); 
            lindex: @int32 (* LONG *); 
            pvAspect: ^IUnknown (* void* *); 
            ptd: ^struct_tagDVTARGETDEVICE (* DVTARGETDEVICE* *); 
            hicTargetDev: @int32 (* HDC *); 
            ppColorSet: ^struct_tagLOGPALETTEHolder (* LOGPALETTE** *); 
         enter (dwDrawAspect, lindex, pvAspect[], ptd[], hicTargetDev[], ppColorSet[])
         do INNER;
         exit result
         #);
       RemoteGetColorSet: (* call_as(GetColorSet) *)
         (# result: @int32 (* HRESULT *);
            dwDrawAspect: @int32u (* DWORD *); 
            lindex: @int32 (* LONG *); 
            pvAspect: @int32u (* DWORD *); 
            ptd: ^struct_tagDVTARGETDEVICE (* DVTARGETDEVICE* *); 
            hicTargetDev: @int32u (* DWORD *); 
            ppColorSet: ^struct_tagLOGPALETTEHolder (* LOGPALETTE** *); 
         enter (dwDrawAspect, lindex, pvAspect, ptd[], hicTargetDev, ppColorSet[])
         do INNER;
         exit result
         #);
       Freeze:<
         (# result: @int32 (* HRESULT *);
            dwDrawAspect: @int32u (* DWORD *); 
            lindex: @int32 (* LONG *); 
            pvAspect: ^IUnknown (* void* *); 
            pdwFreeze: ^int32uHolder (* DWORD* *); 
         enter (dwDrawAspect, lindex, pvAspect[], pdwFreeze[])
         do INNER;
         exit result
         #);
       RemoteFreeze: (* call_as(Freeze) *)
         (# result: @int32 (* HRESULT *);
            dwDrawAspect: @int32u (* DWORD *); 
            lindex: @int32 (* LONG *); 
            pvAspect: @int32u (* DWORD *); 
            pdwFreeze: ^int32uHolder (* DWORD* *); 
         enter (dwDrawAspect, lindex, pvAspect, pdwFreeze[])
         do INNER;
         exit result
         #);
       Unfreeze:<
         (# result: @int32 (* HRESULT *);
            dwFreeze: @int32u (* DWORD *); 
         enter dwFreeze
         do INNER;
         exit result
         #);
       SetAdvise:<
         (# result: @int32 (* HRESULT *);
            aspects: @int32u (* DWORD *); 
            _advf: @int32u (* DWORD *); 
            pAdvSink: ^IAdviseSink (* IAdviseSink* *); 
         enter (aspects, _advf, pAdvSink[])
         do INNER;
         exit result
         #);
       GetAdvise:<
         (# result: @int32 (* HRESULT *);
            pAspects: ^int32uHolder (* DWORD* *); 
            pAdvf: ^int32uHolder (* DWORD* *); 
            ppAdvSink: ^IAdviseSinkHolder (* IAdviseSink** *); 
         enter (pAspects[], pAdvf[], ppAdvSink[])
         do INNER;
         exit result
         #);
       RemoteGetAdvise: (* call_as(GetAdvise) *)
         (# result: @int32 (* HRESULT *);
            pAspects: ^int32uHolder (* DWORD* *); 
            pAdvf: ^int32uHolder (* DWORD* *); 
            ppAdvSink: ^IAdviseSinkHolder (* IAdviseSink** *); 
         enter (pAspects[], pAdvf[], ppAdvSink[])
         do INNER;
         exit result
         #);
    #);

  IViewObject2_IID: (# exit '00000127-0000-0000-C000-000000000046' #);

  IViewObject2: IViewObject
    (# <<SLOT IViewObject2Lib: attributes>>;
       GetExtent:<
         (# result: @int32 (* HRESULT *);
            dwDrawAspect: @int32u (* DWORD *); 
            lindex: @int32 (* LONG *); 
            ptd: ^struct_tagDVTARGETDEVICE (* DVTARGETDEVICE* *); 
            _lpsizel: ^struct_tagSIZEL (* LPSIZEL *); 
         enter (dwDrawAspect, lindex, ptd[], _lpsizel[])
         do INNER;
         exit result
         #);
    #);

  IDropSource_IID: (# exit '00000121-0000-0000-C000-000000000046' #);

  IDropSource: IUnknown
    (# <<SLOT IDropSourceLib: attributes>>;
       QueryContinueDrag:<
         (# result: @int32 (* HRESULT *);
            fEscapePressed: @int32 (* BOOL *); 
            grfKeyState: @int32u (* DWORD *); 
         enter (fEscapePressed, grfKeyState)
         do INNER;
         exit result
         #);
       GiveFeedback:<
         (# result: @int32 (* HRESULT *);
            dwEffect: @int32u (* DWORD *); 
         enter dwEffect
         do INNER;
         exit result
         #);
    #);

  IDropTarget_IID: (# exit '00000122-0000-0000-C000-000000000046' #);

  IDropTarget: IUnknown
    (# <<SLOT IDropTargetLib: attributes>>;
         (* // default inset-width of the hot zone, in pixels *)
         (* //   typical use: GetProfileInt(\"windows\",\"DragScrollInset\",DD_DEFSCROLLINSET) *)
         (* // default delay before scrolling, in milliseconds *)
         (* //   typical use: GetProfileInt(\"windows\",\"DragScrollDelay\",DD_DEFSCROLLDELAY) *)
         (* // default scroll interval, in milliseconds *)
         (* //   typical use: GetProfileInt(\"windows\",\"DragScrollInterval\", DD_DEFSCROLLINTERVAL) *)
         (* // default delay before dragging should start, in milliseconds *)
         (* //   typical use: GetProfileInt(\"windows\", \"DragDelay\", DD_DEFDRAGDELAY) *)
         (* // default minimum distance (radius) before dragging should start, in pixels *)
         (* //   typical use: GetProfileInt(\"windows\", \"DragMinDist\", DD_DEFDRAGMINDIST) *)
       DragEnter:<
         (# result: @int32 (* HRESULT *);
            pDataObj: ^IDataObject (* IDataObject* *); 
            grfKeyState: @int32u (* DWORD *); 
            pt: @struct__POINTL (* POINTL *); 
            pdwEffect: ^int32uHolder (* DWORD* *); 
         enter (pDataObj[], grfKeyState, pt, pdwEffect[])
         do INNER;
         exit result
         #);
       DragOver:<
         (# result: @int32 (* HRESULT *);
            grfKeyState: @int32u (* DWORD *); 
            pt: @struct__POINTL (* POINTL *); 
            pdwEffect: ^int32uHolder (* DWORD* *); 
         enter (grfKeyState, pt, pdwEffect[])
         do INNER;
         exit result
         #);
       DragLeave:<
         (# result: @int32 (* HRESULT *);
            (* No parameters *); 
         do INNER;
         exit result
         #);
       Drop:<
         (# result: @int32 (* HRESULT *);
            pDataObj: ^IDataObject (* IDataObject* *); 
            grfKeyState: @int32u (* DWORD *); 
            pt: @struct__POINTL (* POINTL *); 
            pdwEffect: ^int32uHolder (* DWORD* *); 
         enter (pDataObj[], grfKeyState, pt, pdwEffect[])
         do INNER;
         exit result
         #);
    #);
  MK_ALT: (# exit 0x0020 #);
  DROPEFFECT_NONE: (# exit 0 #);
  DROPEFFECT_COPY: (# exit 1 #);
  DROPEFFECT_MOVE: (# exit 2 #);
  DROPEFFECT_LINK: (# exit 4 #);
  DROPEFFECT_SCROLL: (# exit 0x80000000 #);
  DD_DEFSCROLLINSET: (# exit 11 #);
  DD_DEFSCROLLDELAY: (# exit 50 #);
  DD_DEFSCROLLINTERVAL: (# exit 50 #);
  DD_DEFDRAGDELAY: (# exit 200 #);
  DD_DEFDRAGMINDIST: (# exit 2 #);

  IEnumOLEVERB_IID: (# exit '00000104-0000-0000-C000-000000000046' #);

  IEnumOLEVERB: IUnknown
    (# <<SLOT IEnumOLEVERBLib: attributes>>;
       Next:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^struct_tagOLEVERB (* LPOLEVERB *); 
            pceltFetched: ^int32uHolder (* ULONG* *); 
         enter (celt, rgelt[], pceltFetched[])
         do INNER;
         exit result
         #);
       RemoteNext: (* call_as(Next) *)
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
            rgelt: ^struct_tagOLEVERB (* LPOLEVERB *); 
            pceltFetched: ^int32uHolder (* ULONG* *); 
         enter (celt, rgelt[], pceltFetched[])
         do INNER;
         exit result
         #);
       Skip:<
         (# result: @int32 (* HRESULT *);
            celt: @int32u (* ULONG *); 
         enter celt
         do INNER;
         exit result
         #);
       Reset:<
         (# result: @int32 (* HRESULT *);
         do INNER;
         exit result
         #);
       Clone:<
         (# result: @int32 (* HRESULT *);
            ppenum: ^IEnumOLEVERBHolder (* IEnumOLEVERB** *); 
         enter ppenum[]
         do INNER;
         exit result
         #);
    #);
  OLEVERB: struct_tagOLEVERB(# #);
  struct_tagOLEVERB: DATA
    (# lVerb: @int32 (* LONG *);
       lpszVerbName: @wcharHolder (* LPOLESTR* *);
       fuFlags: @int32u (* DWORD *);
       grfAttribs: @int32u (* DWORD *);
    #);
  enum_OLEVERBATTRIB: IntegerObject(# (* enum tagOLEVERBATTRIB *) #);
  OLEVERBATTRIB_NEVERDIRTIES: (* OLEVERBATTRIB *)(# exit 1 #);
  OLEVERBATTRIB_ONCONTAINERMENU: (* OLEVERBATTRIB *)(# exit 2 #);


  (* Holders *)

  OBJECTDESCRIPTORHolder: Holder
    (# value: @OBJECTDESCRIPTOR; #);
  struct_tagOBJECTDESCRIPTORHolder: Holder
    (# value: @struct_tagOBJECTDESCRIPTOR; #);
  LINKSRCDESCRIPTORHolder: Holder
    (# value: @LINKSRCDESCRIPTOR; #);
  OLEINPLACEFRAMEINFOHolder: Holder
    (# value: @OLEINPLACEFRAMEINFO; #);
  struct_tagOIFIHolder: Holder
    (# value: @struct_tagOIFI; #);
  OLEMENUGROUPWIDTHSHolder: Holder
    (# value: @OLEMENUGROUPWIDTHS; #);
  struct_tagOleMenuGroupWidthsHolder: Holder
    (# value: @struct_tagOleMenuGroupWidths; #);
  OLEVERBHolder: Holder
    (# value: @OLEVERB; #);
  struct_tagOLEVERBHolder: Holder
    (# value: @struct_tagOLEVERB; #);


  (* Reference Holders *)

  IOleAdviseHolderHolder: refHolder
    (# type:: IOleAdviseHolder #);
  IOleCacheHolder: refHolder
    (# type:: IOleCache #);
  IOleCache2Holder: refHolder
    (# type:: IOleCache2 #);
  IOleCacheControlHolder: refHolder
    (# type:: IOleCacheControl #);
  IParseDisplayNameHolder: refHolder
    (# type:: IParseDisplayName #);
  IOleContainerHolder: refHolder
    (# type:: IOleContainer #);
  IOleClientSiteHolder: refHolder
    (# type:: IOleClientSite #);
  IOleObjectHolder: refHolder
    (# type:: IOleObject #);
  IOLETypesHolder: refHolder
    (# type:: IOLETypes #);
  IOleWindowHolder: refHolder
    (# type:: IOleWindow #);
  IOleLinkHolder: refHolder
    (# type:: IOleLink #);
  IOleItemContainerHolder: refHolder
    (# type:: IOleItemContainer #);
  IOleInPlaceUIWindowHolder: refHolder
    (# type:: IOleInPlaceUIWindow #);
  IOleInPlaceActiveObjectHolder: refHolder
    (# type:: IOleInPlaceActiveObject #);
  IOleInPlaceFrameHolder: refHolder
    (# type:: IOleInPlaceFrame #);
  IOleInPlaceObjectHolder: refHolder
    (# type:: IOleInPlaceObject #);
  IOleInPlaceSiteHolder: refHolder
    (# type:: IOleInPlaceSite #);
  IContinueHolder: refHolder
    (# type:: IContinue #);
  IViewObjectHolder: refHolder
    (# type:: IViewObject #);
  IViewObject2Holder: refHolder
    (# type:: IViewObject2 #);
  IDropSourceHolder: refHolder
    (# type:: IDropSource #);
  IDropTargetHolder: refHolder
    (# type:: IDropTarget #);
  IEnumOLEVERBHolder: refHolder
    (# type:: IEnumOLEVERB #);

