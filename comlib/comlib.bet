ORIGIN '~beta/basiclib/v1.6/betaenv';
BODY 'private/comlibbody';
BUILD nti '$$/errormessage.obj' 'errormessage.cpp' 'betacc $0 $1';     
--LIB: attributes--

(* Holder patterns for predefined BETA types *)

integerHolder: Holder
  (# value: @integer #);
shortIntHolder: Holder
  (# value: @shortInt #);
charHolder: Holder
  (# value: @char #);
booleanHolder: Holder
  (# value: @boolean #);
realHolder: Holder
  (# value: @real #);
int8Holder: Holder
  (# value: @int8 #);
int8uHolder: Holder
  (# value: @int8u #);
int16Holder: Holder
  (# value: @int16 #);
int16uHolder: Holder
  (# value: @int16u #);
int32Holder: Holder
  (# value: @int32 #);
int32uHolder: Holder
  (# value: @int32u #);
int64Holder: Holder
  (# value: @int64 #);
int64uHolder: Holder
  (# value: @int64u #);


HRESULT: IntegerObject
  (# 
     succeeded: (# exit value>=0 #);
     failed: (# exit value<0 #);
  #);

SUCCEEDED: 
  (# Hresult: @Integer; 
  enter Hresult
  exit (Hresult>=0)
  #);

GUID:
  (# (* The C type is:
      * typedef struct _GUID
      * {
      *   unsigned long Data1;
      *   unsigned short Data2;
      *   unsigned short Data3;
      *   unsigned char Data4[8];
      * } GUID;
      *)
     traceGUID: (# exit false #);
     Binary: [16]@Char;
     setFromText:
       (* Accepts this format only; no checking!
        * '32bb8320-b41b-11cf-a6bb-0080c7b2d682'
        * FIXME: there are standard COM functions we could call.
        *)
       (# <<SLOT GUIDsetFromTextLib: attributes>>;
          t: ^Text; p: @Integer;
       enter T[]
       <<SLOT GUIDSetFromTextDP: dopart>>   
       #);
     getAsText:
       (# T: ^Text;
       <<SLOT GUIDGetAsTextDP: dopart>>
       exit T[]
       #);
  enter setFromText
  exit getAsText
  #);     

CLSID: GUID(# #);
IID: GUID(# #);

IUnknown: COM   
  (# QueryInterface:< 
       (# hres, iidref, ppv: @Integer;
       enter (iidref, ppv)
       exit hres
       #);
     AddRef:< object;
     Release:< object;
     
     Query: 
       (# theIID: ^IID;  
          Iptr: ^IUnknown;
          Hresult: @integer;
       enter theIID[]
       do (@@theIID.Binary[1], @@Iptr)->QueryInterface->Hresult;
          (if not (Hresult->SUCCEEDED) then
              NONE->Iptr[];
          if);
       exit Iptr[]
       #);
  #);

IDispatch: IUnknown
  (# 
     GetTypeInfoCount:<
       (# 
       #);
     GetTypeInfo:<
       (# 
       #);
     GetIDsOfNames:<
       (# 
       #);
     Invoke:<
       (# 
       #);
  #);

CoInitialize: external
  (# LPVoid,hresult: @Integer;
  enter LPVoid
  do CallStd;
  exit hresult
  #);
CoUninitialize: external
  (# 
  do CallStd;
  #);


CoCreateInstance:
  (# theclsid: ^CLSID; 
     outer: ^IUnknown;
     Flags: @Integer;
     theiid: ^IID;
     Iptr: ^IUnknown;
     hr: @Integer;
     CoCreateInstance: external
       (# pUnkOuter: ^IUnknown;
          rclsid, dwClsContext, riid, ppv, hr: @Integer;
       enter (rclsid, pUnkOuter[], dwClsContext, riid, ppv)
       do callStd
       exit hr
       #);
  enter (theclsid[], outer[], Flags, theiid[])
  do (@@theclsid.Binary[1], outer[], Flags, @@theiid.Binary[1], @@Iptr)
       -> CoCreateInstance->hr;
     (if not (hr->SUCCEEDED) then
         ('cocreateinstance failed', hr) -> ComErrorMessage;
         NONE->Iptr[];
     if);
  exit Iptr[]
  #);
          
CLSCTX_INPROC_SERVER: (# exit 1 #);

ComErrorMessage: external
  (# msg: [0]@char;
     hr: @integer;
  enter (msg, hr)
  do CallC
  #)

