ORIGIN 'ObjIdl'; 
INCLUDE 'comtypes';
BODY 'private/comlibbody';
--LIB: attributes--

(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-98
 *       All rights reserved.
 *)

CoInitialize: external
  (# LPVoid,hresult: @Int32;
  enter LPVoid
  do CallStd; 
  exit hresult
  #);
CoUninitialize: external
  (# 
  do CallStd;
  #);

CLSIDFromProgID: 
  (# progid: ^BSTR;
     theclsid: ^CLSID;
  enter progid[]
  do <<SLOT CLSIDFromProgID: descriptor>>
  exit theclsid[]
  #);

CoCreateInstance:
  (# theclsid: ^CLSID; 
     outer: ^IUnknown;
     Flags: @Int32;
     theiid: ^IID;
     Iptr: ^IUnknown;
  enter (theclsid[], outer[], Flags, theiid[])
  do <<SLOT CoCreateInstance: descriptor>>   
  exit Iptr[]
  #);


(* ole2.h *)
OLEIVERB_SHOW: (#  exit - 1 #);
OLEIVERB_DISCARDUNDOSTATE: (#  exit - 6 #);
(* WINOLEAPI OleInitialize(LPVOID pvReserved); *)
OleInitialize: external
  (# pvReserved: @integer;
     hResult: @integer;
  enter pvReserved
  do CallStd;
  exit hResult
  #);

(* WINOLEAPI_(void) OleUninitialize(void); *)
OleUninitialize: external
  (# 
  do CallStd;
  #);

(* Drag/Drop APIs *)

(* Clipboard APIs *)

OleSetClipboard: external
  (# pDataObj: @integer; (* LPDATAOBJECT *)
     hRes: @integer;
  enter pDataObj
  do callStd;
  exit hRes
  #);

OleGetClipboard: external
  (# ppDataObj: @integer;
     hRes: @integer;
  enter ppDataObj
  do callStd
  exit hRes
  #);

OleFlushClipboard: external
  (# hRes: @integer;
  do callStd;
  exit hRes
  #);

OleIsCurrentClipboard: external
  (# pDataObj: @integer; (* LPDATAOBJECT *)
     hRes: @integer;
  enter pDataObj
  do callStd;
  exit hRes
  #);

(* objbase.h *)
CoRegisterClassObject: external
  
  (# rclsid: @integer
       (* Class identifier (CLSID) to be registered *);
     pUnk: @integer
       (* Pointer to the class object *);
     dwClsContext: @integer
       (* Context for running executable code *);
     flags: @integer
       (* How to connect to the class object *);
     lpdwRegister: @integer
       (* Pointer to the value returned *);
     result: @integer
       (* This function supports the standard return values E_INVALIDARG,
        * E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following: S_OK:
        * The class object was registered successfully.  CO_E_OBJISREG:
        * Already registered in the class object table.
        *); 
  enter (rclsid,pUnk,dwClsContext,flags,lpdwRegister)
  do callStd;
  exit result
  #);

CoRevokeClassObject: external
  (# lpdwRegister: @integer
       (* Pointer to the value returned in CoRegisterClassObject *);
     result: @integer;
  enter lpdwRegister
  do callStd
  exit result
  #);

(* oleauto.h *)
RegisterActiveObject:
  (# 
     punk: ^IUnknown; (* IUnknown FAR* *)
     rclsid: ^CLSID; (* REFCLSID *)
     dwFlags: @Int32; (* DWORD *)
     pdwRegister: ^int32uHolder; (* unsigned long FAR* *)
     result: @Int32;
  enter (punk[], rclsid[], dwFlags, pdwRegister[])
  do <<SLOT RegisterActiveObject: descriptor>>
  exit result
  #);

RevokeActiveObject: external
  (# dwRegister: @integer; (* unsigned long *)
     pvReserved: @integer; (* void FAR *)
     result: @integer;
  enter (dwRegister, pvReserved)
  do callStd
  exit result
  #);


GetActiveObject: external
  (# 
     rclsid: ^CLSID; (* REFCLSID *)
     reserv1: @Int32; (* void FAR*  pvReserved *)
     ppunk: ^IUnknownHolder; (* IUnknown FAR* FAR* *)
     result: @Int32;
  enter (rclsid[], reserv1, ppunk[])
  do callStd
  exit result
  #);
     

(* SHLOBJ.H 
 *
 * Task allocator API
 *
 * All the shell extensions MUST use the task allocator (see OLE 2.0
 * programming guild for its definition) when they allocate or free
 * memory objects (mostly ITEMIDLIST) that are returned across any
 * shell interfaces. There are two ways to access the task allocator
 * from a shell extension depending on whether or not it is linked with
 * OLE32.DLL or not (purely for efficiency).
 *
 * (1) A shell extension which calls any OLE API (i.e., linked with
 *     OLE32.DLL) should call OLE's task allocator (by retrieving
 *     the task allocator by calling CoGetMalloc API).
 *
 * (2) A shell extension which does not call any OLE API (i.e., not linked
 *     with OLE32.DLL) should call the shell task allocator API (defined
 *     below), so that the shell can quickly loads it when OLE32.DLL is not
 *     loaded by any application at that point.
 *)

(* WINSHELLAPI HRESULT WINAPI SHGetMalloc(LPMALLOC * ppMalloc); *)
SHGetMalloc: external
  (# ppMalloc: @integer; 
     result: @integer;
  enter ppMalloc
  do callStd;
  exit result
  #);

(* WINSHELLAPI HRESULT WINAPI 
 * SHGetSpecialFolderLocation(HWND hwndOwner, int nFolder, LPITEMIDLIST *ppidl)
 * 
 * Caller should call SHFree to free the returned pidl.
 *)
SHGetSpecialFolderLocation: external
  (# hwndOwner: @integer;	
     nFolder: @integer; 	
     ppidl: @integer;
     result: @integer;
  enter (hwndOwner,nFolder,ppidl)
  do callStd;
  exit result
  #);

(* Helper function which returns a IShellFolder interface to the desktop
 * folder. This is equivalent to call CoCreateInstance with
 * CLSID_ShellDesktop.
 *
 *  CoCreateInstance(CLSID_Desktop, NULL,
 *                   CLSCTX_INPROC, IID_IShellFolder, &pshf);
 *
 * WINSHELLAPI HRESULT WINAPI SHGetDesktopFolder(LPSHELLFOLDER *ppshf);
 *)
SHGetDesktopFolder: external
  (# ppshf: @integer;
     result: @integer;
  enter ppshf
  do callStd;
  exit result
  #);

(* oledlg.h *)
OleUIAddVerbMenu: external
  (# lpOleObj,lpszShortType,hMenu,uPos,uIDVerbMin,uIDVerbMax,
     bAddConvert, idConvert, lphMenu: @integer;
     result: @integer;
  enter (lpOleObj, lpszShortType, hMenu, uPos, uIDVerbMin, uIDVerbMax, 
     bAddConvert, idConvert, lphMenu)
  do callStd;
  exit result
  #);

(* objbase.h *)
(*
 * Common typedefs for paramaters used in Storage API's, gleamed from
 * storage.h.
 * Also contains Storage error codes, which should be moved into the storage
 * idl files.
 *)

CWCSTORAGENAME: (# exit 32 #);

(* Storage instantiation modes *)
STGM_DIRECT: (# exit              0x00000000 #);
STGM_TRANSACTED: (# exit          0x00010000 #);
STGM_SIMPLE: (# exit              0x08000000 #);

STGM_READ: (# exit                0x00000000 #);
STGM_WRITE: (# exit               0x00000001 #);
STGM_READWRITE: (# exit           0x00000002 #);

STGM_SHARE_DENY_NONE: (# exit     0x00000040 #);
STGM_SHARE_DENY_READ: (# exit     0x00000030 #);
STGM_SHARE_DENY_WRITE: (# exit    0x00000020 #);
STGM_SHARE_EXCLUSIVE: (# exit     0x00000010 #);

STGM_PRIORITY: (# exit            0x00040000 #);
STGM_DELETEONRELEASE: (# exit     0x04000000 #);

STGM_NOSCRATCH: (# exit           0x00100000 #);


STGM_CREATE: (# exit              0x00001000 #);
STGM_CONVERT: (# exit             0x00020000 #);
STGM_FAILIFTHERE: (# exit         0x00000000 #);

STGM_NOSNAPSHOT: (# exit          0x00200000 #);

(* Storage API Prototypes *)

StgCreateDocfile: external
  (# result: @integer;
     pwcsName: [0]@wchar (* ^wtext NYI *);
     grfMode, reserved: @integer;
     ppstgOpen: ^IStorageHolder;
  enter (pwcsName, grfMode, reserved, ppstgOpen[])
  do callStd;
  exit result
  #);

StgOpenStorage: external
  (# pwcsName: [0]@wchar (* ^wtext NYI *);
     pstgPriority, grfMode, snbExclude, reserved: @integer;
     ppstgOpen: ^IStorageHolder;
     result: @integer;
  enter (pwcsName, pstgPriority, grfMode, snbExclude, reserved, ppstgOpen[])
  do callStd;
  exit result
  #);

StgIsStorageFile: external
  (# pwcsName: [0]@wchar (* ^wtext NYI *);
     result: @integer;
  enter pwcsName
  do callStd;
  exit result
  #);

ComErrorMessage: external
  (* Display "msg" followed by a human-readable explanation
   * of the error encoded in "hr".
   * Source: private/external/errormessage.cpp
   *)
  (# msg: [0]@char;
     hr: @int32;
  enter (msg, hr)
  do CallC
  #);

Query: 
  (* More user-friendly version of QueryInterface than the 
   * autogenerated one in Unknwn.bet.
   *)
  (# theIID: ^IID;  
     theUnknown, Iptr: ^IUnknown;
     hr: @HRESULT;
  enter (theUnknown[], theIID[])
  do <<SLOT IUnknownQuery: descriptor>>
  exit Iptr[]
  #);

SleepEx: external
  (# period (* In miliseconds *),
     flags (* just set to zero *): @Integer;
  enter (period, flags)
  do callStd
  #);

(* Other, from Christian *)
GetClientRect2: external
  (#
     hr: @int32;
     hWnd: @integer (* HWND *) ;
     lpRect: ^struct_tagRECT (* LPRECT *)
  enter (hWnd,lpRect[])
  do 'GetClientRect'->callStd
  exit hr
  #);
OleSave: external
  (#
     hr: @int32;
     pPS: ^IPersistStorage (* LPPERSISTSTORAGE *) ;
     pStg: ^IStorage (* LPSTORAGE *) ;
     fSameAsLoad: @boolean
  enter (pPS[],pStg[],fSameAsLoad)
  do callStd
  exit hr
  #);

OleRun: external
  (# hr: @int32; pUnknown: ^IUnknown (* LPUNKNOWN *)
  enter pUnknown[]
  do callStd
  exit hr
  #);

getGUID_NULL: (* a GUID containing only zeros *)
  (# aGUID: ^GUID
  do
     &GUID[]->aGUID[];
     aGUID.init;
     '00000000-0000-0000-0000-000000000000'->aGUID.setFromText
  exit aGUID[]
  #);

IID_NULL: (# exit (getGUID_NULL).binary[] #);
