(* BETA interface generated from "Excel04.Idl"
 * at Fri Mar 24 16:16:14 2000 with options: -F 
 *)
ORIGIN '~beta/comlib/comtypes';
INCLUDE 'Excel03';
--LIB: attributes-- ;

  IRange_IID: (# exit '00020846-0001-0000-C000-000000000046' #);

  IRange: IDispatch
    (# <<SLOT IRangeLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Activate:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       getAddIndent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putAddIndent:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       AddIndent: (* property *)
         (# enter putAddIndent exit getAddIndent #);
       getAddress:<
         (# result: @int32 (* HRESULT *);
            RowAbsolute: @int32 (* VARIANT *); 
            ColumnAbsolute: @int32 (* VARIANT *); 
            ReferenceStyle: @int32 (* XlReferenceStyle *); 
            External: @int32 (* VARIANT *); 
            RelativeTo: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^BSTRHolder (* BSTR* *); 
         enter (RowAbsolute, ColumnAbsolute, ReferenceStyle, External, RelativeTo, lcid, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getAddressLocal:<
         (# result: @int32 (* HRESULT *);
            RowAbsolute: @int32 (* VARIANT *); 
            ColumnAbsolute: @int32 (* VARIANT *); 
            ReferenceStyle: @int32 (* XlReferenceStyle *); 
            External: @int32 (* VARIANT *); 
            RelativeTo: @int32 (* VARIANT *); 
            RHS: ^BSTRHolder (* BSTR* *); 
         enter (RowAbsolute, ColumnAbsolute, ReferenceStyle, External, RelativeTo, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       AdvancedFilter:<
         (# result: @int32 (* HRESULT *);
            Action: @int32 (* XlFilterAction *); 
            CriteriaRange: @int32 (* VARIANT *); 
            CopyToRange: @int32 (* VARIANT *); 
            Unique: @int32 (* VARIANT *); 
         enter (Action, CriteriaRange, CopyToRange, Unique)
         do (* callStd *) INNER;
         exit result
         #);
       ApplyNames:<
         (# result: @int32 (* HRESULT *);
            _Names: @int32 (* VARIANT *); 
            IgnoreRelativeAbsolute: @int32 (* VARIANT *); 
            UseRowColumnNames: @int32 (* VARIANT *); 
            OmitColumn: @int32 (* VARIANT *); 
            OmitRow: @int32 (* VARIANT *); 
            Order: @int32 (* XlApplyNamesOrder *); 
            AppendLast: @int32 (* VARIANT *); 
         enter (_Names, IgnoreRelativeAbsolute, UseRowColumnNames, OmitColumn, OmitRow, Order, AppendLast)
         do (* callStd *) INNER;
         exit result
         #);
       ApplyOutlineStyles:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       getAreas:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Areas** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       AutoComplete:<
         (# result: @int32 (* HRESULT *);
            String: @int32 (* BSTR *); 
            RHS: ^BSTRHolder (* BSTR* *); 
         enter (String, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       AutoFill:<
         (# result: @int32 (* HRESULT *);
            Destination: @int32 (* Range* *); 
            Type: @int32 (* XlAutoFillType *); 
         enter (Destination[], Type)
         do (* callStd *) INNER;
         exit result
         #);
       AutoFilter:<
         (# result: @int32 (* HRESULT *);
            Field: @int32 (* VARIANT *); 
            Criteria1: @int32 (* VARIANT *); 
            Operator: @int32 (* XlAutoFilterOperator *); 
            Criteria2: @int32 (* VARIANT *); 
            VisibleDropDown: @int32 (* VARIANT *); 
         enter (Field, Criteria1, Operator, Criteria2, VisibleDropDown)
         do (* callStd *) INNER;
         exit result
         #);
       AutoFit:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       AutoFormat:<
         (# result: @int32 (* HRESULT *);
            Format: @int32 (* XlRangeAutoFormat *); 
            Number: @int32 (* VARIANT *); 
            _Font: @int32 (* VARIANT *); 
            Alignment: @int32 (* VARIANT *); 
            Border: @int32 (* VARIANT *); 
            Pattern: @int32 (* VARIANT *); 
            Width: @int32 (* VARIANT *); 
         enter (Format, Number, _Font, Alignment, Border, Pattern, Width)
         do (* callStd *) INNER;
         exit result
         #);
       AutoOutline:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       BorderAround:<
         (# result: @int32 (* HRESULT *);
            LineStyle: @int32 (* VARIANT *); 
            Weight: @int32 (* XlBorderWeight *); 
            ColorIndex: @int32 (* XlColorIndex *); 
            Color: @int32 (* VARIANT *); 
         enter (LineStyle, Weight, ColorIndex, Color)
         do (* callStd *) INNER;
         exit result
         #);
       getBorders:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Borders** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Calculate:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       getCells:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCharacters:<
         (# result: @int32 (* HRESULT *);
            Start: @int32 (* VARIANT *); 
            Length: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Characters** *); 
         enter (Start, Length, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       CheckSpelling:<
         (# result: @int32 (* HRESULT *);
            CustomDictionary: @int32 (* VARIANT *); 
            IgnoreUppercase: @int32 (* VARIANT *); 
            AlwaysSuggest: @int32 (* VARIANT *); 
            IgnoreInitialAlefHamza: @int32 (* VARIANT *); 
            IgnoreFinalYaa: @int32 (* VARIANT *); 
            SpellScript: @int32 (* VARIANT *); 
         enter (CustomDictionary, IgnoreUppercase, AlwaysSuggest, IgnoreInitialAlefHamza, IgnoreFinalYaa, SpellScript)
         do (* callStd *) INNER;
         exit result
         #);
       Clear:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       ClearContents:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       ClearFormats:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       ClearNotes:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       ClearOutline:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       getColumn:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       ColumnDifferences:<
         (# result: @int32 (* HRESULT *);
            Comparison: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Range** *); 
         enter (Comparison, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getColumns:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getColumnWidth:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putColumnWidth:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       ColumnWidth: (* property *)
         (# enter putColumnWidth exit getColumnWidth #);
       Consolidate:<
         (# result: @int32 (* HRESULT *);
            Sources: @int32 (* VARIANT *); 
            Function: @int32 (* VARIANT *); 
            TopRow: @int32 (* VARIANT *); 
            LeftColumn: @int32 (* VARIANT *); 
            CreateLinks: @int32 (* VARIANT *); 
         enter (Sources, Function, TopRow, LeftColumn, CreateLinks)
         do (* callStd *) INNER;
         exit result
         #);
       Copy:<
         (# result: @int32 (* HRESULT *);
            Destination: @int32 (* VARIANT *); 
         enter Destination
         do (* callStd *) INNER;
         exit result
         #);
       CopyFromRecordset:<
         (# result: @int32 (* HRESULT *);
            Data: ^IUnknown (* IUnknown* *); 
            MaxRows: @int32 (* VARIANT *); 
            MaxColumns: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* long* *); 
         enter (Data[], MaxRows, MaxColumns, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       CopyPicture:<
         (# result: @int32 (* HRESULT *);
            Appearance: @int32 (* XlPictureAppearance *); 
            Format: @int32 (* XlCopyPictureFormat *); 
         enter (Appearance, Format)
         do (* callStd *) INNER;
         exit result
         #);
       getCount:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       CreateNames:<
         (# result: @int32 (* HRESULT *);
            Top: @int32 (* VARIANT *); 
            Left: @int32 (* VARIANT *); 
            Bottom: @int32 (* VARIANT *); 
            Right: @int32 (* VARIANT *); 
         enter (Top, Left, Bottom, Right)
         do (* callStd *) INNER;
         exit result
         #);
       CreatePublisher:<
         (# result: @int32 (* HRESULT *);
            Edition: @int32 (* VARIANT *); 
            Appearance: @int32 (* XlPictureAppearance *); 
            ContainsPICT: @int32 (* VARIANT *); 
            ContainsBIFF: @int32 (* VARIANT *); 
            ContainsRTF: @int32 (* VARIANT *); 
            ContainsVALU: @int32 (* VARIANT *); 
         enter (Edition, Appearance, ContainsPICT, ContainsBIFF, ContainsRTF, ContainsVALU)
         do (* callStd *) INNER;
         exit result
         #);
       getCurrentArray:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCurrentRegion:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Cut:<
         (# result: @int32 (* HRESULT *);
            Destination: @int32 (* VARIANT *); 
         enter Destination
         do (* callStd *) INNER;
         exit result
         #);
       DataSeries:<
         (# result: @int32 (* HRESULT *);
            Rowcol: @int32 (* VARIANT *); 
            Type: @int32 (* XlDataSeriesType *); 
            Date: @int32 (* XlDataSeriesDate *); 
            Step: @int32 (* VARIANT *); 
            Stop: @int32 (* VARIANT *); 
            Trend: @int32 (* VARIANT *); 
         enter (Rowcol, Type, Date, Step, Stop, Trend)
         do (* callStd *) INNER;
         exit result
         #);
       get_Default:<
         (# result: @int32 (* HRESULT *);
            RowIndex: @int32 (* VARIANT *); 
            ColumnIndex: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^VARIANT (* VARIANT* *); 
         enter (RowIndex, ColumnIndex, lcid, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       put_Default:<
         (# result: @int32 (* HRESULT *);
            RowIndex: @int32 (* VARIANT *); 
            ColumnIndex: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: @int32 (* VARIANT *); 
         enter (RowIndex, ColumnIndex, lcid, RHS)
         do (* callStd *) INNER;
         exit result
         #);
       _Default: (* property *)
         (# enter put_Default exit get_Default #);
       Delete:<
         (# result: @int32 (* HRESULT *);
            Shift: @int32 (* VARIANT *); 
         enter Shift
         do (* callStd *) INNER;
         exit result
         #);
       getDependents:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       DialogBox:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getDirectDependents:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getDirectPrecedents:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       EditionOptions:<
         (# result: @int32 (* HRESULT *);
            Type: @int32 (* XlEditionType *); 
            Option: @int32 (* XlEditionOptionsOption *); 
            Name: @int32 (* VARIANT *); 
            Reference: @int32 (* VARIANT *); 
            Appearance: @int32 (* XlPictureAppearance *); 
            ChartSize: @int32 (* XlPictureAppearance *); 
            Format: @int32 (* VARIANT *); 
            RHS: ^VARIANT (* VARIANT* *); 
         enter (Type, Option, Name, Reference, Appearance, ChartSize, Format, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getEnd:<
         (# result: @int32 (* HRESULT *);
            Direction: @int32 (* XlDirection *); 
            RHS: ^int32Holder (* Range** *); 
         enter (Direction, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getEntireColumn:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getEntireRow:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       FillDown:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       FillLeft:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       FillRight:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       FillUp:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       Find:<
         (# result: @int32 (* HRESULT *);
            What: @int32 (* VARIANT *); 
            After: @int32 (* VARIANT *); 
            LookIn: @int32 (* VARIANT *); 
            LookAt: @int32 (* VARIANT *); 
            SearchOrder: @int32 (* VARIANT *); 
            SearchDirection: @int32 (* XlSearchDirection *); 
            MatchCase: @int32 (* VARIANT *); 
            MatchByte: @int32 (* VARIANT *); 
            MatchControlCharacters: @int32 (* VARIANT *); 
            MatchDiacritics: @int32 (* VARIANT *); 
            MatchKashida: @int32 (* VARIANT *); 
            MatchAlefHamza: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Range** *); 
         enter (What, After, LookIn, LookAt, SearchOrder, SearchDirection, MatchCase, MatchByte, MatchControlCharacters, MatchDiacritics, MatchKashida, MatchAlefHamza, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       FindNext:<
         (# result: @int32 (* HRESULT *);
            After: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Range** *); 
         enter (After, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       FindPrevious:<
         (# result: @int32 (* HRESULT *);
            After: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Range** *); 
         enter (After, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getFont:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Font** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getFormula:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^VARIANT (* VARIANT* *); 
         enter (lcid, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       putFormula:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* VARIANT *); 
         enter (lcid, RHS)
         do (* callStd *) INNER;
         exit result
         #);
       Formula: (* property *)
         (# enter putFormula exit getFormula #);
       getFormulaArray:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putFormulaArray:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       FormulaArray: (* property *)
         (# enter putFormulaArray exit getFormulaArray #);
       getFormulaLabel:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlFormulaLabel* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putFormulaLabel:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlFormulaLabel *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       FormulaLabel: (* property *)
         (# enter putFormulaLabel exit getFormulaLabel #);
       getFormulaHidden:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putFormulaHidden:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       FormulaHidden: (* property *)
         (# enter putFormulaHidden exit getFormulaHidden #);
       getFormulaLocal:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putFormulaLocal:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       FormulaLocal: (* property *)
         (# enter putFormulaLocal exit getFormulaLocal #);
       getFormulaR1C1:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^VARIANT (* VARIANT* *); 
         enter (lcid, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       putFormulaR1C1:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* VARIANT *); 
         enter (lcid, RHS)
         do (* callStd *) INNER;
         exit result
         #);
       FormulaR1C1: (* property *)
         (# enter putFormulaR1C1 exit getFormulaR1C1 #);
       getFormulaR1C1Local:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putFormulaR1C1Local:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       FormulaR1C1Local: (* property *)
         (# enter putFormulaR1C1Local exit getFormulaR1C1Local #);
       FunctionWizard:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       GoalSeek:<
         (# result: @int32 (* HRESULT *);
            Goal: @int32 (* VARIANT *); 
            ChangingCell: @int32 (* Range* *); 
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter (Goal, ChangingCell[], RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       Group:<
         (# result: @int32 (* HRESULT *);
            Start: @int32 (* VARIANT *); 
            End: @int32 (* VARIANT *); 
            By: @int32 (* VARIANT *); 
            Periods: @int32 (* VARIANT *); 
            RHS: ^VARIANT (* VARIANT* *); 
         enter (Start, End, By, Periods, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getHasArray:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getHasFormula:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getHeight:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getHidden:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putHidden:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Hidden: (* property *)
         (# enter putHidden exit getHidden #);
       getHorizontalAlignment:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putHorizontalAlignment:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       HorizontalAlignment: (* property *)
         (# enter putHorizontalAlignment exit getHorizontalAlignment #);
       getIndentLevel:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putIndentLevel:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       IndentLevel: (* property *)
         (# enter putIndentLevel exit getIndentLevel #);
       InsertIndent:<
         (# result: @int32 (* HRESULT *);
            InsertAmount: @int32 (* long *); 
         enter InsertAmount
         do (* callStd *) INNER;
         exit result
         #);
       Insert:<
         (# result: @int32 (* HRESULT *);
            Shift: @int32 (* VARIANT *); 
         enter Shift
         do (* callStd *) INNER;
         exit result
         #);
       getInterior:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Interior** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getItem:<
         (# result: @int32 (* HRESULT *);
            RowIndex: @int32 (* VARIANT *); 
            ColumnIndex: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^VARIANT (* VARIANT* *); 
         enter (RowIndex, ColumnIndex, lcid, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       putItem:<
         (# result: @int32 (* HRESULT *);
            RowIndex: @int32 (* VARIANT *); 
            ColumnIndex: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: @int32 (* VARIANT *); 
         enter (RowIndex, ColumnIndex, lcid, RHS)
         do (* callStd *) INNER;
         exit result
         #);
       Item: (* property *)
         (# enter putItem exit getItem #);
       Justify:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       getLeft:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getListHeaderRows:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       ListNames:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       getLocationInTable:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlLocationInTable* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getLocked:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putLocked:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Locked: (* property *)
         (# enter putLocked exit getLocked #);
       Merge:<
         (# result: @int32 (* HRESULT *);
            Across: @int32 (* VARIANT *); 
         enter Across
         do (* callStd *) INNER;
         exit result
         #);
       UnMerge:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       getMergeArea:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getMergeCells:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putMergeCells:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       MergeCells: (* property *)
         (# enter putMergeCells exit getMergeCells #);
       getName:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putName:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Name: (* property *)
         (# enter putName exit getName #);
       NavigateArrow:<
         (# result: @int32 (* HRESULT *);
            TowardPrecedent: @int32 (* VARIANT *); 
            ArrowNumber: @int32 (* VARIANT *); 
            LinkNumber: @int32 (* VARIANT *); 
         enter (TowardPrecedent, ArrowNumber, LinkNumber)
         do (* callStd *) INNER;
         exit result
         #);
       get_NewEnum:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IUnknownHolder (* IUnknown** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getNext:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       NoteText:<
         (# result: @int32 (* HRESULT *);
            Text: @int32 (* VARIANT *); 
            Start: @int32 (* VARIANT *); 
            Length: @int32 (* VARIANT *); 
            RHS: ^BSTRHolder (* BSTR* *); 
         enter (Text, Start, Length, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getNumberFormat:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putNumberFormat:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       NumberFormat: (* property *)
         (# enter putNumberFormat exit getNumberFormat #);
       getNumberFormatLocal:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putNumberFormatLocal:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       NumberFormatLocal: (* property *)
         (# enter putNumberFormatLocal exit getNumberFormatLocal #);
       getOffset:<
         (# result: @int32 (* HRESULT *);
            RowOffset: @int32 (* VARIANT *); 
            ColumnOffset: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Range** *); 
         enter (RowOffset, ColumnOffset, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getOrientation:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putOrientation:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Orientation: (* property *)
         (# enter putOrientation exit getOrientation #);
       getOutlineLevel:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putOutlineLevel:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       OutlineLevel: (* property *)
         (# enter putOutlineLevel exit getOutlineLevel #);
       getPageBreak:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putPageBreak:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* long *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       PageBreak: (* property *)
         (# enter putPageBreak exit getPageBreak #);
       Parse:<
         (# result: @int32 (* HRESULT *);
            ParseLine: @int32 (* VARIANT *); 
            Destination: @int32 (* VARIANT *); 
         enter (ParseLine, Destination)
         do (* callStd *) INNER;
         exit result
         #);
       PasteSpecial:<
         (# result: @int32 (* HRESULT *);
            Paste: @int32 (* XlPasteType *); 
            Operation: @int32 (* XlPasteSpecialOperation *); 
            SkipBlanks: @int32 (* VARIANT *); 
            Transpose: @int32 (* VARIANT *); 
         enter (Paste, Operation, SkipBlanks, Transpose)
         do (* callStd *) INNER;
         exit result
         #);
       getPivotField:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* PivotField** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getPivotItem:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* PivotItem** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getPivotTable:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* PivotTable** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getPrecedents:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getPrefixCharacter:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getPrevious:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       PrintOut:<
         (# result: @int32 (* HRESULT *);
            From: @int32 (* VARIANT *); 
            To: @int32 (* VARIANT *); 
            Copies: @int32 (* VARIANT *); 
            Preview: @int32 (* VARIANT *); 
            ActivePrinter: @int32 (* VARIANT *); 
            PrintToFile: @int32 (* VARIANT *); 
            Collate: @int32 (* VARIANT *); 
         enter (From, To, Copies, Preview, ActivePrinter, PrintToFile, Collate)
         do (* callStd *) INNER;
         exit result
         #);
       PrintPreview:<
         (# result: @int32 (* HRESULT *);
            EnableChanges: @int32 (* VARIANT *); 
         enter EnableChanges
         do (* callStd *) INNER;
         exit result
         #);
       getQueryTable:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* QueryTable** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getRange:<
         (# result: @int32 (* HRESULT *);
            Cell1: @int32 (* VARIANT *); 
            Cell2: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Range** *); 
         enter (Cell1, Cell2, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       RemoveSubtotal:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       Replace:<
         (# result: @int32 (* HRESULT *);
            What: @int32 (* VARIANT *); 
            Replacement: @int32 (* VARIANT *); 
            LookAt: @int32 (* VARIANT *); 
            SearchOrder: @int32 (* VARIANT *); 
            MatchCase: @int32 (* VARIANT *); 
            MatchByte: @int32 (* VARIANT *); 
            MatchControlCharacters: @int32 (* VARIANT *); 
            MatchDiacritics: @int32 (* VARIANT *); 
            MatchKashida: @int32 (* VARIANT *); 
            MatchAlefHamza: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter (What, Replacement, LookAt, SearchOrder, MatchCase, MatchByte, MatchControlCharacters, MatchDiacritics, MatchKashida, MatchAlefHamza, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getResize:<
         (# result: @int32 (* HRESULT *);
            RowSize: @int32 (* VARIANT *); 
            ColumnSize: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Range** *); 
         enter (RowSize, ColumnSize, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getRow:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       RowDifferences:<
         (# result: @int32 (* HRESULT *);
            Comparison: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Range** *); 
         enter (Comparison, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getRowHeight:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putRowHeight:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       RowHeight: (* property *)
         (# enter putRowHeight exit getRowHeight #);
       getRows:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Run:<
         (# result: @int32 (* HRESULT *);
            Arg1: @int32 (* VARIANT *); 
            Arg2: @int32 (* VARIANT *); 
            Arg3: @int32 (* VARIANT *); 
            Arg4: @int32 (* VARIANT *); 
            Arg5: @int32 (* VARIANT *); 
            Arg6: @int32 (* VARIANT *); 
            Arg7: @int32 (* VARIANT *); 
            Arg8: @int32 (* VARIANT *); 
            Arg9: @int32 (* VARIANT *); 
            Arg10: @int32 (* VARIANT *); 
            Arg11: @int32 (* VARIANT *); 
            Arg12: @int32 (* VARIANT *); 
            Arg13: @int32 (* VARIANT *); 
            Arg14: @int32 (* VARIANT *); 
            Arg15: @int32 (* VARIANT *); 
            Arg16: @int32 (* VARIANT *); 
            Arg17: @int32 (* VARIANT *); 
            Arg18: @int32 (* VARIANT *); 
            Arg19: @int32 (* VARIANT *); 
            Arg20: @int32 (* VARIANT *); 
            Arg21: @int32 (* VARIANT *); 
            Arg22: @int32 (* VARIANT *); 
            Arg23: @int32 (* VARIANT *); 
            Arg24: @int32 (* VARIANT *); 
            Arg25: @int32 (* VARIANT *); 
            Arg26: @int32 (* VARIANT *); 
            Arg27: @int32 (* VARIANT *); 
            Arg28: @int32 (* VARIANT *); 
            Arg29: @int32 (* VARIANT *); 
            Arg30: @int32 (* VARIANT *); 
            RHS: ^VARIANT (* VARIANT* *); 
         enter (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13, Arg14, Arg15, Arg16, Arg17, Arg18, Arg19, Arg20, Arg21, Arg22, Arg23, Arg24, Arg25, Arg26, Arg27, Arg28, Arg29, Arg30, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       Select:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       Show:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       ShowDependents:<
         (# result: @int32 (* HRESULT *);
            Remove: @int32 (* VARIANT *); 
         enter Remove
         do (* callStd *) INNER;
         exit result
         #);
       getShowDetail:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putShowDetail:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       ShowDetail: (* property *)
         (# enter putShowDetail exit getShowDetail #);
       ShowErrors:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       ShowPrecedents:<
         (# result: @int32 (* HRESULT *);
            Remove: @int32 (* VARIANT *); 
         enter Remove
         do (* callStd *) INNER;
         exit result
         #);
       getShrinkToFit:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putShrinkToFit:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       ShrinkToFit: (* property *)
         (# enter putShrinkToFit exit getShrinkToFit #);
       Sort:<
         (# result: @int32 (* HRESULT *);
            Key1: @int32 (* VARIANT *); 
            Order1: @int32 (* XlSortOrder *); 
            Key2: @int32 (* VARIANT *); 
            Type: @int32 (* VARIANT *); 
            Order2: @int32 (* XlSortOrder *); 
            Key3: @int32 (* VARIANT *); 
            Order3: @int32 (* XlSortOrder *); 
            Header: @int32 (* XlYesNoGuess *); 
            OrderCustom: @int32 (* VARIANT *); 
            MatchCase: @int32 (* VARIANT *); 
            Orientation: @int32 (* XlSortOrientation *); 
            SortMethod: @int32 (* XlSortMethod *); 
            IgnoreControlCharacters: @int32 (* VARIANT *); 
            IgnoreDiacritics: @int32 (* VARIANT *); 
            IgnoreKashida: @int32 (* VARIANT *); 
         enter (Key1, Order1, Key2, Type, Order2, Key3, Order3, Header, OrderCustom, MatchCase, Orientation, SortMethod, IgnoreControlCharacters, IgnoreDiacritics, IgnoreKashida)
         do (* callStd *) INNER;
         exit result
         #);
       SortSpecial:<
         (# result: @int32 (* HRESULT *);
            SortMethod: @int32 (* XlSortMethod *); 
            Key1: @int32 (* VARIANT *); 
            Order1: @int32 (* XlSortOrder *); 
            Type: @int32 (* VARIANT *); 
            Key2: @int32 (* VARIANT *); 
            Order2: @int32 (* XlSortOrder *); 
            Key3: @int32 (* VARIANT *); 
            Order3: @int32 (* XlSortOrder *); 
            Header: @int32 (* XlYesNoGuess *); 
            OrderCustom: @int32 (* VARIANT *); 
            MatchCase: @int32 (* VARIANT *); 
            Orientation: @int32 (* XlSortOrientation *); 
         enter (SortMethod, Key1, Order1, Type, Key2, Order2, Key3, Order3, Header, OrderCustom, MatchCase, Orientation)
         do (* callStd *) INNER;
         exit result
         #);
       getSoundNote:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* SoundNote** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       SpecialCells:<
         (# result: @int32 (* HRESULT *);
            Type: @int32 (* XlCellType *); 
            Value: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Range** *); 
         enter (Type, Value, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getStyle:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putStyle:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Style: (* property *)
         (# enter putStyle exit getStyle #);
       SubscribeTo:<
         (# result: @int32 (* HRESULT *);
            Edition: @int32 (* BSTR *); 
            Format: @int32 (* XlSubscribeToFormat *); 
         enter (Edition, Format)
         do (* callStd *) INNER;
         exit result
         #);
       Subtotal:<
         (# result: @int32 (* HRESULT *);
            GroupBy: @int32 (* long *); 
            Function: @int32 (* XlConsolidationFunction *); 
            TotalList: @int32 (* VARIANT *); 
            Replace: @int32 (* VARIANT *); 
            PageBreaks: @int32 (* VARIANT *); 
            SummaryBelowData: @int32 (* XlSummaryRow *); 
         enter (GroupBy, Function, TotalList, Replace, PageBreaks, SummaryBelowData)
         do (* callStd *) INNER;
         exit result
         #);
       getSummary:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Table:<
         (# result: @int32 (* HRESULT *);
            RowInput: @int32 (* VARIANT *); 
            ColumnInput: @int32 (* VARIANT *); 
         enter (RowInput, ColumnInput)
         do (* callStd *) INNER;
         exit result
         #);
       getText:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       TextToColumns:<
         (# result: @int32 (* HRESULT *);
            Destination: @int32 (* VARIANT *); 
            DataType: @int32 (* XlTextParsingType *); 
            TextQualifier: @int32 (* XlTextQualifier *); 
            ConsecutiveDelimiter: @int32 (* VARIANT *); 
            Tab: @int32 (* VARIANT *); 
            Semicolon: @int32 (* VARIANT *); 
            Comma: @int32 (* VARIANT *); 
            Space: @int32 (* VARIANT *); 
            Other: @int32 (* VARIANT *); 
            OtherChar: @int32 (* VARIANT *); 
            FieldInfo: @int32 (* VARIANT *); 
         enter (Destination, DataType, TextQualifier, ConsecutiveDelimiter, Tab, Semicolon, Comma, Space, Other, OtherChar, FieldInfo)
         do (* callStd *) INNER;
         exit result
         #);
       getTop:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Ungroup:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       getUseStandardHeight:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putUseStandardHeight:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       UseStandardHeight: (* property *)
         (# enter putUseStandardHeight exit getUseStandardHeight #);
       getUseStandardWidth:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putUseStandardWidth:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       UseStandardWidth: (* property *)
         (# enter putUseStandardWidth exit getUseStandardWidth #);
       getValidation:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Validation** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getValue:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^VARIANT (* VARIANT* *); 
         enter (lcid, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       putValue:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* VARIANT *); 
         enter (lcid, RHS)
         do (* callStd *) INNER;
         exit result
         #);
       Value: (* property *)
         (# enter putValue exit getValue #);
       getValue2:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^VARIANT (* VARIANT* *); 
         enter (lcid, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       putValue2:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* VARIANT *); 
         enter (lcid, RHS)
         do (* callStd *) INNER;
         exit result
         #);
       Value2: (* property *)
         (# enter putValue2 exit getValue2 #);
       getVerticalAlignment:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putVerticalAlignment:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       VerticalAlignment: (* property *)
         (# enter putVerticalAlignment exit getVerticalAlignment #);
       getWidth:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getWorksheet:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Worksheet** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getWrapText:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putWrapText:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       WrapText: (* property *)
         (# enter putWrapText exit getWrapText #);
       AddComment:<
         (# result: @int32 (* HRESULT *);
            Text: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Comment** *); 
         enter (Text, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getComment:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Comment** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       ClearComments:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       getPhonetic:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Phonetic** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getFormatConditions:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* FormatConditions** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getReadingOrder:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putReadingOrder:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* long *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       ReadingOrder: (* property *)
         (# enter putReadingOrder exit getReadingOrder #);
       getHyperlinks:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Hyperlinks** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IChartEvents_IID: (# exit '0002440F-0001-0000-C000-000000000046' #);

  IChartEvents: IDispatch
    (# <<SLOT IChartEventsLib: attributes>>;
       Activate:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       Deactivate:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       Resize:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       MouseDown:<
         (# result: @int32 (* HRESULT *);
            Button: @int32 (* XlMouseButton *); 
            Shift: @int32 (* long *); 
            X: @int32 (* long *); 
            Y: @int32 (* long *); 
         enter (Button, Shift, X, Y)
         do (* callStd *) INNER;
         exit result
         #);
       MouseUp:<
         (# result: @int32 (* HRESULT *);
            Button: @int32 (* XlMouseButton *); 
            Shift: @int32 (* long *); 
            X: @int32 (* long *); 
            Y: @int32 (* long *); 
         enter (Button, Shift, X, Y)
         do (* callStd *) INNER;
         exit result
         #);
       MouseMove:<
         (# result: @int32 (* HRESULT *);
            Button: @int32 (* XlMouseButton *); 
            Shift: @int32 (* long *); 
            X: @int32 (* long *); 
            Y: @int32 (* long *); 
         enter (Button, Shift, X, Y)
         do (* callStd *) INNER;
         exit result
         #);
       BeforeRightClick:<
         (# result: @int32 (* HRESULT *);
            Cancel: @int32 (* VARIANT_BOOL* *); 
         enter Cancel[]
         do (* callStd *) INNER;
         exit result
         #);
       DragPlot:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       DragOver:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       BeforeDoubleClick:<
         (# result: @int32 (* HRESULT *);
            ElementID: @int32 (* XlChartItem *); 
            Arg1: @int32 (* long *); 
            Arg2: @int32 (* long *); 
            Cancel: @int32 (* VARIANT_BOOL* *); 
         enter (ElementID, Arg1, Arg2, Cancel[])
         do (* callStd *) INNER;
         exit result
         #);
       Select:<
         (# result: @int32 (* HRESULT *);
            ElementID: @int32 (* XlChartItem *); 
            Arg1: @int32 (* long *); 
            Arg2: @int32 (* long *); 
         enter (ElementID, Arg1, Arg2)
         do (* callStd *) INNER;
         exit result
         #);
       SeriesChange:<
         (# result: @int32 (* HRESULT *);
            SeriesIndex: @int32 (* long *); 
            PointIndex: @int32 (* long *); 
         enter (SeriesIndex, PointIndex)
         do (* callStd *) INNER;
         exit result
         #);
       Calculate:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
    #);

  _Chart_IID: (# exit '000208D6-0000-0000-C000-000000000046' #);

  _Chart: IDispatch
    (# <<SLOT _ChartLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Application** *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       Activate:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
         enter lcid
         do INNER;
         exit result
         #);
       Copy:<
         (# result: @int32 (* HRESULT *);
            Before: @int32 (* VARIANT *); 
            After: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (Before, After, lcid)
         do INNER;
         exit result
         #);
       Delete:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
         enter lcid
         do INNER;
         exit result
         #);
       getCodeName:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       get_CodeName:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       put_CodeName:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* BSTR *); 
         enter RHS
         do INNER;
         exit result
         #);
       _CodeName: (* property *)
         (# enter put_CodeName exit get_CodeName #);
       getIndex:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* long* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       Move:<
         (# result: @int32 (* HRESULT *);
            Before: @int32 (* VARIANT *); 
            After: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (Before, After, lcid)
         do INNER;
         exit result
         #);
       getName:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       putName:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* BSTR *); 
         enter RHS
         do INNER;
         exit result
         #);
       Name: (* property *)
         (# enter putName exit getName #);
       getNext:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       getOnDoubleClick:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^BSTRHolder (* BSTR* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putOnDoubleClick:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* BSTR *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       OnDoubleClick: (* property *)
         (# enter putOnDoubleClick exit getOnDoubleClick #);
       getOnSheetActivate:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^BSTRHolder (* BSTR* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putOnSheetActivate:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* BSTR *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       OnSheetActivate: (* property *)
         (# enter putOnSheetActivate exit getOnSheetActivate #);
       getOnSheetDeactivate:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^BSTRHolder (* BSTR* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putOnSheetDeactivate:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* BSTR *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       OnSheetDeactivate: (* property *)
         (# enter putOnSheetDeactivate exit getOnSheetDeactivate #);
       getPageSetup:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* PageSetup** *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       getPrevious:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       PrintOut:<
         (# result: @int32 (* HRESULT *);
            From: @int32 (* VARIANT *); 
            To: @int32 (* VARIANT *); 
            Copies: @int32 (* VARIANT *); 
            Preview: @int32 (* VARIANT *); 
            ActivePrinter: @int32 (* VARIANT *); 
            PrintToFile: @int32 (* VARIANT *); 
            Collate: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (From, To, Copies, Preview, ActivePrinter, PrintToFile, Collate, lcid)
         do INNER;
         exit result
         #);
       PrintPreview:<
         (# result: @int32 (* HRESULT *);
            EnableChanges: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (EnableChanges, lcid)
         do INNER;
         exit result
         #);
       Protect:<
         (# result: @int32 (* HRESULT *);
            Password: @int32 (* VARIANT *); 
            DrawingObjects: @int32 (* VARIANT *); 
            Contents: @int32 (* VARIANT *); 
            Scenarios: @int32 (* VARIANT *); 
            UserInterfaceOnly: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (Password, DrawingObjects, Contents, Scenarios, UserInterfaceOnly, lcid)
         do INNER;
         exit result
         #);
       getProtectContents:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       getProtectDrawingObjects:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       getProtectionMode:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       _Dummy23:<
         (# (* No result *)
         do INNER;
         #);
       SaveAs:<
         (# result: @int32 (* HRESULT *);
            Filename: @int32 (* BSTR *); 
            FileFormat: @int32 (* VARIANT *); 
            Password: @int32 (* VARIANT *); 
            WriteResPassword: @int32 (* VARIANT *); 
            ReadOnlyRecommended: @int32 (* VARIANT *); 
            CreateBackup: @int32 (* VARIANT *); 
            AddToMru: @int32 (* VARIANT *); 
            TextCodepage: @int32 (* VARIANT *); 
            TextVisualLayout: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (Filename, FileFormat, Password, WriteResPassword, ReadOnlyRecommended, CreateBackup, AddToMru, TextCodepage, TextVisualLayout, lcid)
         do INNER;
         exit result
         #);
       Select:<
         (# result: @int32 (* HRESULT *);
            Replace: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (Replace, lcid)
         do INNER;
         exit result
         #);
       Unprotect:<
         (# result: @int32 (* HRESULT *);
            Password: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (Password, lcid)
         do INNER;
         exit result
         #);
       getVisible:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* XlSheetVisibility* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putVisible:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* XlSheetVisibility *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       Visible: (* property *)
         (# enter putVisible exit getVisible #);
       getShapes:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Shapes** *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       ApplyDataLabels:<
         (# result: @int32 (* HRESULT *);
            Type: @int32 (* XlDataLabelsType *); 
            LegendKey: @int32 (* VARIANT *); 
            AutoText: @int32 (* VARIANT *); 
            HasLeaderLines: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (Type, LegendKey, AutoText, HasLeaderLines, lcid)
         do INNER;
         exit result
         #);
       Arcs:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       getArea3DGroup:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* ChartGroup** *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       AreaGroups:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       AutoFormat:<
         (# result: @int32 (* HRESULT *);
            Gallery: @int32 (* long *); 
            Format: @int32 (* VARIANT *); 
         enter (Gallery, Format)
         do INNER;
         exit result
         #);
       getAutoScaling:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putAutoScaling:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* VARIANT_BOOL *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       AutoScaling: (* property *)
         (# enter putAutoScaling exit getAutoScaling #);
       Axes:<
         (# result: @int32 (* HRESULT *);
            Type: @int32 (* VARIANT *); 
            AxisGroup: @int32 (* XlAxisGroup *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Type, AxisGroup, lcid, RHS[])
         do INNER;
         exit result
         #);
       SetBackgroundPicture:<
         (# result: @int32 (* HRESULT *);
            Filename: @int32 (* BSTR *); 
         enter Filename
         do INNER;
         exit result
         #);
       getBar3DGroup:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* ChartGroup** *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       BarGroups:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       Buttons:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       getChartArea:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* ChartArea** *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       ChartGroups:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       ChartObjects:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       getChartTitle:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* ChartTitle** *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       ChartWizard:<
         (# result: @int32 (* HRESULT *);
            Source: @int32 (* VARIANT *); 
            Gallery: @int32 (* VARIANT *); 
            Format: @int32 (* VARIANT *); 
            PlotBy: @int32 (* VARIANT *); 
            CategoryLabels: @int32 (* VARIANT *); 
            SeriesLabels: @int32 (* VARIANT *); 
            HasLegend: @int32 (* VARIANT *); 
            Title: @int32 (* VARIANT *); 
            CategoryTitle: @int32 (* VARIANT *); 
            ValueTitle: @int32 (* VARIANT *); 
            ExtraTitle: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (Source, Gallery, Format, PlotBy, CategoryLabels, SeriesLabels, HasLegend, Title, CategoryTitle, ValueTitle, ExtraTitle, lcid)
         do INNER;
         exit result
         #);
       CheckBoxes:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       CheckSpelling:<
         (# result: @int32 (* HRESULT *);
            CustomDictionary: @int32 (* VARIANT *); 
            IgnoreUppercase: @int32 (* VARIANT *); 
            AlwaysSuggest: @int32 (* VARIANT *); 
            IgnoreInitialAlefHamza: @int32 (* VARIANT *); 
            IgnoreFinalYaa: @int32 (* VARIANT *); 
            SpellScript: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (CustomDictionary, IgnoreUppercase, AlwaysSuggest, IgnoreInitialAlefHamza, IgnoreFinalYaa, SpellScript, lcid)
         do INNER;
         exit result
         #);
       getColumn3DGroup:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* ChartGroup** *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       ColumnGroups:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       CopyPicture:<
         (# result: @int32 (* HRESULT *);
            Appearance: @int32 (* XlPictureAppearance *); 
            Format: @int32 (* XlCopyPictureFormat *); 
            Size: @int32 (* XlPictureAppearance *); 
            lcid: @int32 (* long *); 
         enter (Appearance, Format, Size, lcid)
         do INNER;
         exit result
         #);
       getCorners:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* Corners** *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       CreatePublisher:<
         (# result: @int32 (* HRESULT *);
            Edition: @int32 (* VARIANT *); 
            Appearance: @int32 (* XlPictureAppearance *); 
            Size: @int32 (* XlPictureAppearance *); 
            ContainsPICT: @int32 (* VARIANT *); 
            ContainsBIFF: @int32 (* VARIANT *); 
            ContainsRTF: @int32 (* VARIANT *); 
            ContainsVALU: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (Edition, Appearance, Size, ContainsPICT, ContainsBIFF, ContainsRTF, ContainsVALU, lcid)
         do INNER;
         exit result
         #);
       getDataTable:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* DataTable** *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       getDepthPercent:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* long* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putDepthPercent:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* long *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       DepthPercent: (* property *)
         (# enter putDepthPercent exit getDepthPercent #);
       Deselect:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
         enter lcid
         do INNER;
         exit result
         #);
       getDisplayBlanksAs:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* XlDisplayBlanksAs* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putDisplayBlanksAs:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* XlDisplayBlanksAs *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       DisplayBlanksAs: (* property *)
         (# enter putDisplayBlanksAs exit getDisplayBlanksAs #);
       DoughnutGroups:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       Drawings:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       DrawingObjects:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       DropDowns:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       getElevation:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* long* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putElevation:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* long *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       Elevation: (* property *)
         (# enter putElevation exit getElevation #);
       Evaluate:<
         (# result: @int32 (* HRESULT *);
            Name: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^VARIANT (* VARIANT* *); 
         enter (Name, lcid, RHS[])
         do INNER;
         exit result
         #);
       _Evaluate:<
         (# result: @int32 (* HRESULT *);
            Name: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^VARIANT (* VARIANT* *); 
         enter (Name, lcid, RHS[])
         do INNER;
         exit result
         #);
       getFloor:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* Floor** *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       getGapDepth:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* long* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putGapDepth:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* long *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       GapDepth: (* property *)
         (# enter putGapDepth exit getGapDepth #);
       GroupBoxes:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       GroupObjects:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       getHasAxis:<
         (# result: @int32 (* HRESULT *);
            Index1: @int32 (* VARIANT *); 
            Index2: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^VARIANT (* VARIANT* *); 
         enter (Index1, Index2, lcid, RHS[])
         do INNER;
         exit result
         #);
       putHasAxis:<
         (# result: @int32 (* HRESULT *);
            Index1: @int32 (* VARIANT *); 
            Index2: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: @int32 (* VARIANT *); 
         enter (Index1, Index2, lcid, RHS)
         do INNER;
         exit result
         #);
       HasAxis: (* property *)
         (# enter putHasAxis exit getHasAxis #);
       getHasDataTable:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       putHasDataTable:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do INNER;
         exit result
         #);
       HasDataTable: (* property *)
         (# enter putHasDataTable exit getHasDataTable #);
       getHasLegend:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putHasLegend:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* VARIANT_BOOL *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       HasLegend: (* property *)
         (# enter putHasLegend exit getHasLegend #);
       getHasTitle:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putHasTitle:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* VARIANT_BOOL *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       HasTitle: (* property *)
         (# enter putHasTitle exit getHasTitle #);
       getHeightPercent:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* long* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putHeightPercent:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* long *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       HeightPercent: (* property *)
         (# enter putHeightPercent exit getHeightPercent #);
       getHyperlinks:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Hyperlinks** *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       Labels:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       getLegend:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* Legend** *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       getLine3DGroup:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* ChartGroup** *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       LineGroups:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       Lines:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       ListBoxes:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       Location:<
         (# result: @int32 (* HRESULT *);
            Where: @int32 (* XlChartLocation *); 
            Name: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Chart** *); 
         enter (Where, Name, RHS[])
         do INNER;
         exit result
         #);
       OLEObjects:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       OptionButtons:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       Ovals:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       Paste:<
         (# result: @int32 (* HRESULT *);
            Type: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (Type, lcid)
         do INNER;
         exit result
         #);
       getPerspective:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* long* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putPerspective:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* long *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       Perspective: (* property *)
         (# enter putPerspective exit getPerspective #);
       Pictures:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       getPie3DGroup:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* ChartGroup** *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       PieGroups:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       getPlotArea:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* PlotArea** *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       getPlotVisibleOnly:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putPlotVisibleOnly:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* VARIANT_BOOL *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       PlotVisibleOnly: (* property *)
         (# enter putPlotVisibleOnly exit getPlotVisibleOnly #);
       RadarGroups:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       Rectangles:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       getRightAngleAxes:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^VARIANT (* VARIANT* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putRightAngleAxes:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* VARIANT *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       RightAngleAxes: (* property *)
         (# enter putRightAngleAxes exit getRightAngleAxes #);
       getRotation:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^VARIANT (* VARIANT* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putRotation:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* VARIANT *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       Rotation: (* property *)
         (# enter putRotation exit getRotation #);
       ScrollBars:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       SeriesCollection:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       getSizeWithWindow:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putSizeWithWindow:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* VARIANT_BOOL *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       SizeWithWindow: (* property *)
         (# enter putSizeWithWindow exit getSizeWithWindow #);
       getShowWindow:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       putShowWindow:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do INNER;
         exit result
         #);
       ShowWindow: (* property *)
         (# enter putShowWindow exit getShowWindow #);
       Spinners:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       getSubType:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* long* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putSubType:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* long *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       SubType: (* property *)
         (# enter putSubType exit getSubType #);
       getSurfaceGroup:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* ChartGroup** *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       TextBoxes:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       getType:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* long* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putType:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* long *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       Type: (* property *)
         (# enter putType exit getType #);
       getChartType:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlChartType* *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       putChartType:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlChartType *); 
         enter RHS
         do INNER;
         exit result
         #);
       ChartType: (* property *)
         (# enter putChartType exit getChartType #);
       ApplyCustomType:<
         (# result: @int32 (* HRESULT *);
            ChartType: @int32 (* XlChartType *); 
            TypeName: @int32 (* VARIANT *); 
         enter (ChartType, TypeName)
         do INNER;
         exit result
         #);
       getWalls:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* Walls** *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       getWallsAndGridlines2D:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putWallsAndGridlines2D:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* VARIANT_BOOL *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       WallsAndGridlines2D: (* property *)
         (# enter putWallsAndGridlines2D exit getWallsAndGridlines2D #);
       XYGroups:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, lcid, RHS[])
         do INNER;
         exit result
         #);
       getBarShape:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlBarShape* *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       putBarShape:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlBarShape *); 
         enter RHS
         do INNER;
         exit result
         #);
       BarShape: (* property *)
         (# enter putBarShape exit getBarShape #);
       getPlotBy:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlRowCol* *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       putPlotBy:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlRowCol *); 
         enter RHS
         do INNER;
         exit result
         #);
       PlotBy: (* property *)
         (# enter putPlotBy exit getPlotBy #);
       CopyChartBuild:<
         (# result: @int32 (* HRESULT *);
         do INNER;
         exit result
         #);
       getProtectFormatting:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       putProtectFormatting:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do INNER;
         exit result
         #);
       ProtectFormatting: (* property *)
         (# enter putProtectFormatting exit getProtectFormatting #);
       getProtectData:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       putProtectData:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do INNER;
         exit result
         #);
       ProtectData: (* property *)
         (# enter putProtectData exit getProtectData #);
       getProtectGoalSeek:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       putProtectGoalSeek:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do INNER;
         exit result
         #);
       ProtectGoalSeek: (* property *)
         (# enter putProtectGoalSeek exit getProtectGoalSeek #);
       getProtectSelection:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       putProtectSelection:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do INNER;
         exit result
         #);
       ProtectSelection: (* property *)
         (# enter putProtectSelection exit getProtectSelection #);
       GetChartElement:<
         (# result: @int32 (* HRESULT *);
            X: @int32 (* long *); 
            Y: @int32 (* long *); 
            ElementID: ^int32Holder (* long* *); 
            Arg1: ^int32Holder (* long* *); 
            Arg2: ^int32Holder (* long* *); 
         enter (X, Y, ElementID[], Arg1[], Arg2[])
         do INNER;
         exit result
         #);
       SetSourceData:<
         (# result: @int32 (* HRESULT *);
            Source: @int32 (* Range* *); 
            PlotBy: @int32 (* VARIANT *); 
         enter (Source[], PlotBy)
         do INNER;
         exit result
         #);
       Export:<
         (# result: @int32 (* HRESULT *);
            Filename: @int32 (* BSTR *); 
            FilterName: @int32 (* VARIANT *); 
            Interactive: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter (Filename, FilterName, Interactive, RHS[])
         do INNER;
         exit result
         #);
       Refresh:<
         (# result: @int32 (* HRESULT *);
         do INNER;
         exit result
         #);
    #);

  Sheets_IID: (# exit '000208D7-0000-0000-C000-000000000046' #);

  Sheets: IDispatch
    (# <<SLOT SheetsLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Application** *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       Add:<
         (# result: @int32 (* HRESULT *);
            Before: @int32 (* VARIANT *); 
            After: @int32 (* VARIANT *); 
            Count: @int32 (* VARIANT *); 
            Type: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Before, After, Count, Type, lcid, RHS[])
         do INNER;
         exit result
         #);
       Copy:<
         (# result: @int32 (* HRESULT *);
            Before: @int32 (* VARIANT *); 
            After: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (Before, After, lcid)
         do INNER;
         exit result
         #);
       getCount:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       Delete:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
         enter lcid
         do INNER;
         exit result
         #);
       FillAcrossSheets:<
         (# result: @int32 (* HRESULT *);
            _Range: @int32 (* Range* *); 
            Type: @int32 (* XlFillWith *); 
            lcid: @int32 (* long *); 
         enter (_Range[], Type, lcid)
         do INNER;
         exit result
         #);
       getItem:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, RHS[])
         do INNER;
         exit result
         #);
       Move:<
         (# result: @int32 (* HRESULT *);
            Before: @int32 (* VARIANT *); 
            After: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (Before, After, lcid)
         do INNER;
         exit result
         #);
       get_NewEnum:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IUnknownHolder (* IUnknown** *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       PrintOut:<
         (# result: @int32 (* HRESULT *);
            From: @int32 (* VARIANT *); 
            To: @int32 (* VARIANT *); 
            Copies: @int32 (* VARIANT *); 
            Preview: @int32 (* VARIANT *); 
            ActivePrinter: @int32 (* VARIANT *); 
            PrintToFile: @int32 (* VARIANT *); 
            Collate: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (From, To, Copies, Preview, ActivePrinter, PrintToFile, Collate, lcid)
         do INNER;
         exit result
         #);
       PrintPreview:<
         (# result: @int32 (* HRESULT *);
            EnableChanges: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (EnableChanges, lcid)
         do INNER;
         exit result
         #);
       Select:<
         (# result: @int32 (* HRESULT *);
            Replace: @int32 (* VARIANT *); 
            lcid: @int32 (* long *); 
         enter (Replace, lcid)
         do INNER;
         exit result
         #);
       getHPageBreaks:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* HPageBreaks** *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       getVPageBreaks:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VPageBreaks** *); 
         enter RHS[]
         do INNER;
         exit result
         #);
       getVisible:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: ^VARIANT (* VARIANT* *); 
         enter (lcid, RHS[])
         do INNER;
         exit result
         #);
       putVisible:<
         (# result: @int32 (* HRESULT *);
            lcid: @int32 (* long *); 
            RHS: @int32 (* VARIANT *); 
         enter (lcid, RHS)
         do INNER;
         exit result
         #);
       Visible: (* property *)
         (# enter putVisible exit getVisible #);
       get_Default:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, RHS[])
         do INNER;
         exit result
         #);
    #);

  (* Reference Holders *)

  IRangeHolder: refHolder
    (# type:: IRange #);
  IChartEventsHolder: refHolder
    (# type:: IChartEvents #);
  _ChartHolder: refHolder
    (# type:: _Chart #);
  SheetsHolder: refHolder
    (# type:: Sheets #);

