(* BETA interface generated from "EXCEL8\Excel13.Idl"
 * with options: -F -q 
 *)
ORIGIN '~beta/comlib/comtypes';
INCLUDE '~beta/comlib/MsApplication/EXCEL8/Excel12';
--LIB: attributes-- ;

  IMailer_IID: (# exit '000208D1-0001-0000-C000-000000000046' #);

  IMailer: IDispatch
    (# <<SLOT IMailerLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getBCCRecipients:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putBCCRecipients:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       BCCRecipients: (* property *)
         (# enter putBCCRecipients exit getBCCRecipients #);
       getCCRecipients:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putCCRecipients:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       CCRecipients: (* property *)
         (# enter putCCRecipients exit getCCRecipients #);
       getEnclosures:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putEnclosures:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Enclosures: (* property *)
         (# enter putEnclosures exit getEnclosures #);
       getReceived:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getSendDateTime:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* DATE* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getSender:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getSubject:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putSubject:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* BSTR *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Subject: (* property *)
         (# enter putSubject exit getSubject #);
       getToRecipients:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putToRecipients:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       ToRecipients: (* property *)
         (# enter putToRecipients exit getToRecipients #);
       getWhichAddress:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putWhichAddress:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       WhichAddress: (* property *)
         (# enter putWhichAddress exit getWhichAddress #);
    #);

  ICustomViews_IID: (# exit '00024422-0001-0000-C000-000000000046' #);

  ICustomViews: IDispatch
    (# <<SLOT ICustomViewsLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCount:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Item:<
         (# result: @int32 (* HRESULT *);
            ViewName: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* CustomView** *); 
         enter (ViewName, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       Add:<
         (# result: @int32 (* HRESULT *);
            ViewName: @int32 (* BSTR *); 
            PrintSettings: @int32 (* VARIANT *); 
            RowColSettings: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* CustomView** *); 
         enter (ViewName, PrintSettings, RowColSettings, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       get_Default:<
         (# result: @int32 (* HRESULT *);
            ViewName: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* CustomView** *); 
         enter (ViewName, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       get_NewEnum:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IUnknownHolder (* IUnknown** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
    #);

  ICustomView_IID: (# exit '00024423-0001-0000-C000-000000000046' #);

  ICustomView: IDispatch
    (# <<SLOT ICustomViewLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getName:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getPrintSettings:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getRowColSettings:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Show:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       Delete:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IFormatConditions_IID: (# exit '00024424-0001-0000-C000-000000000046' #);

  IFormatConditions: IDispatch
    (# <<SLOT IFormatConditionsLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCount:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Item:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* FormatCondition** *); 
         enter (Index, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       Add:<
         (# result: @int32 (* HRESULT *);
            Type: @int32 (* XlFormatConditionType *); 
            Operator: @int32 (* VARIANT *); 
            Formula1: @int32 (* VARIANT *); 
            Formula2: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* FormatCondition** *); 
         enter (Type, Operator, Formula1, Formula2, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       get_Default:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* FormatCondition** *); 
         enter (Index, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       get_NewEnum:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IUnknownHolder (* IUnknown** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Delete:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IFormatCondition_IID: (# exit '00024425-0001-0000-C000-000000000046' #);

  IFormatCondition: IDispatch
    (# <<SLOT IFormatConditionLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Modify:<
         (# result: @int32 (* HRESULT *);
            Type: @int32 (* XlFormatConditionType *); 
            Operator: @int32 (* VARIANT *); 
            Formula1: @int32 (* VARIANT *); 
            Formula2: @int32 (* VARIANT *); 
         enter (Type, Operator, Formula1, Formula2)
         do (* callStd *) INNER;
         exit result
         #);
       getType:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getOperator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getFormula1:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getFormula2:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getInterior:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Interior** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getBorders:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Borders** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getFont:<
         (# result: @int32 (* HRESULT *);
            RHS: ^FontHolder (* Font** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Delete:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IComments_IID: (# exit '00024426-0001-0000-C000-000000000046' #);

  IComments: IDispatch
    (# <<SLOT ICommentsLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCount:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Item:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* long *); 
            RHS: ^int32Holder (* Comment** *); 
         enter (Index, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       get_Default:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* long *); 
            RHS: ^int32Holder (* Comment** *); 
         enter (Index, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       get_NewEnum:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IUnknownHolder (* IUnknown** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IComment_IID: (# exit '00024427-0001-0000-C000-000000000046' #);

  IComment: IDispatch
    (# <<SLOT ICommentLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getAuthor:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getShape:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ShapeHolder (* Shape** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getVisible:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putVisible:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Visible: (* property *)
         (# enter putVisible exit getVisible #);
       Text:<
         (# result: @int32 (* HRESULT *);
            Text: @int32 (* VARIANT *); 
            Start: @int32 (* VARIANT *); 
            Overwrite: @int32 (* VARIANT *); 
            RHS: ^BSTRHolder (* BSTR* *); 
         enter (Text, Start, Overwrite, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       Delete:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       Next:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Comment** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Previous:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Comment** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IRefreshEvents_IID: (# exit '0002441B-0001-0000-C000-000000000046' #);

  IRefreshEvents: IDispatch
    (# <<SLOT IRefreshEventsLib: attributes>>;
       BeforeRefresh:<
         (# result: @int32 (* HRESULT *);
            Cancel: @int32 (* VARIANT_BOOL* *); 
         enter Cancel[]
         do (* callStd *) INNER;
         exit result
         #);
       AfterRefresh:<
         (# result: @int32 (* HRESULT *);
            Success: @int32 (* VARIANT_BOOL *); 
         enter Success
         do (* callStd *) INNER;
         exit result
         #);
    #);

  _IQueryTable_IID: (# exit '00024428-0001-0000-C000-000000000046' #);

  _IQueryTable: IDispatch
    (# <<SLOT _IQueryTableLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getName:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putName:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* BSTR *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Name: (* property *)
         (# enter putName exit getName #);
       getFieldNames:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putFieldNames:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       FieldNames: (* property *)
         (# enter putFieldNames exit getFieldNames #);
       getRowNumbers:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putRowNumbers:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       RowNumbers: (* property *)
         (# enter putRowNumbers exit getRowNumbers #);
       getFillAdjacentFormulas:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putFillAdjacentFormulas:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       FillAdjacentFormulas: (* property *)
         (# enter putFillAdjacentFormulas exit getFillAdjacentFormulas #);
       getHasAutoFormat:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putHasAutoFormat:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       HasAutoFormat: (* property *)
         (# enter putHasAutoFormat exit getHasAutoFormat #);
       getRefreshOnFileOpen:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putRefreshOnFileOpen:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       RefreshOnFileOpen: (* property *)
         (# enter putRefreshOnFileOpen exit getRefreshOnFileOpen #);
       getRefreshing:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getFetchedRowOverflow:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getBackgroundQuery:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putBackgroundQuery:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       BackgroundQuery: (* property *)
         (# enter putBackgroundQuery exit getBackgroundQuery #);
       CancelRefresh:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       getRefreshStyle:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCellInsertionMode* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putRefreshStyle:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlCellInsertionMode *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       RefreshStyle: (* property *)
         (# enter putRefreshStyle exit getRefreshStyle #);
       getEnableRefresh:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putEnableRefresh:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       EnableRefresh: (* property *)
         (# enter putEnableRefresh exit getEnableRefresh #);
       getSavePassword:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putSavePassword:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       SavePassword: (* property *)
         (# enter putSavePassword exit getSavePassword #);
       getDestination:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getConnection:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putConnection:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Connection: (* property *)
         (# enter putConnection exit getConnection #);
       getSql:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putSql:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Sql: (* property *)
         (# enter putSql exit getSql #);
       getPostText:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putPostText:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* BSTR *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       PostText: (* property *)
         (# enter putPostText exit getPostText #);
       getResultRange:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Delete:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       Refresh:<
         (# result: @int32 (* HRESULT *);
            BackgroundQuery: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter (BackgroundQuery, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getParameters:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Parameters** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getRecordset:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Recordset:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatch (* IDispatch* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getSaveData:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putSaveData:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       SaveData: (* property *)
         (# enter putSaveData exit getSaveData #);
       getTablesOnlyFromHTML:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putTablesOnlyFromHTML:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       TablesOnlyFromHTML: (* property *)
         (# enter putTablesOnlyFromHTML exit getTablesOnlyFromHTML #);
       getEnableEditing:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putEnableEditing:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       EnableEditing: (* property *)
         (# enter putEnableEditing exit getEnableEditing #);
    #);

  IQueryTables_IID: (# exit '00024429-0001-0000-C000-000000000046' #);

  IQueryTables: IDispatch
    (# <<SLOT IQueryTablesLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCount:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Add:<
         (# result: @int32 (* HRESULT *);
            Connection: @int32 (* VARIANT *); 
            Destination: @int32 (* Range* *); 
            Sql: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* QueryTable** *); 
         enter (Connection, Destination[], Sql, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       Item:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* QueryTable** *); 
         enter (Index, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       get_Default:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* QueryTable** *); 
         enter (Index, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       _NewEnum:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IUnknownHolder (* IUnknown** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IParameter_IID: (# exit '0002442A-0001-0000-C000-000000000046' #);

  IParameter: IDispatch
    (# <<SLOT IParameterLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getDataType:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlParameterDataType* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putDataType:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlParameterDataType *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       DataType: (* property *)
         (# enter putDataType exit getDataType #);
       getType:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlParameterType* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getPromptString:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getValue:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getSourceRange:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getName:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putName:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* BSTR *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Name: (* property *)
         (# enter putName exit getName #);
       SetParam:<
         (# result: @int32 (* HRESULT *);
            Type: @int32 (* XlParameterType *); 
            Value: @int32 (* VARIANT *); 
         enter (Type, Value)
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IParameters_IID: (# exit '0002442B-0001-0000-C000-000000000046' #);

  IParameters: IDispatch
    (# <<SLOT IParametersLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Add:<
         (# result: @int32 (* HRESULT *);
            _Name: @int32 (* BSTR *); 
            iDataType: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Parameter** *); 
         enter (_Name, iDataType, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getCount:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Item:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Parameter** *); 
         enter (Index, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       get_Default:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Parameter** *); 
         enter (Index, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       Delete:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       _NewEnum:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IUnknownHolder (* IUnknown** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IODBCError_IID: (# exit '0002442C-0001-0000-C000-000000000046' #);

  IODBCError: IDispatch
    (# <<SLOT IODBCErrorLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getSqlState:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getErrorString:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IODBCErrors_IID: (# exit '0002442D-0001-0000-C000-000000000046' #);

  IODBCErrors: IDispatch
    (# <<SLOT IODBCErrorsLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCount:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Item:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* long *); 
            RHS: ^int32Holder (* ODBCError** *); 
         enter (Index, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       get_Default:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* long *); 
            RHS: ^int32Holder (* ODBCError** *); 
         enter (Index, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       _NewEnum:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IUnknownHolder (* IUnknown** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IValidation_IID: (# exit '0002442F-0001-0000-C000-000000000046' #);

  IValidation: IDispatch
    (# <<SLOT IValidationLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Add:<
         (# result: @int32 (* HRESULT *);
            Type: @int32 (* XlDVType *); 
            AlertStyle: @int32 (* VARIANT *); 
            Operator: @int32 (* VARIANT *); 
            Formula1: @int32 (* VARIANT *); 
            Formula2: @int32 (* VARIANT *); 
         enter (Type, AlertStyle, Operator, Formula1, Formula2)
         do (* callStd *) INNER;
         exit result
         #);
       getAlertStyle:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getIgnoreBlank:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putIgnoreBlank:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       IgnoreBlank: (* property *)
         (# enter putIgnoreBlank exit getIgnoreBlank #);
       getIMEMode:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putIMEMode:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* long *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       IMEMode: (* property *)
         (# enter putIMEMode exit getIMEMode #);
       getInCellDropdown:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putInCellDropdown:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       InCellDropdown: (* property *)
         (# enter putInCellDropdown exit getInCellDropdown #);
       Delete:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       getErrorMessage:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putErrorMessage:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* BSTR *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       ErrorMessage: (* property *)
         (# enter putErrorMessage exit getErrorMessage #);
       getErrorTitle:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putErrorTitle:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* BSTR *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       ErrorTitle: (* property *)
         (# enter putErrorTitle exit getErrorTitle #);
       getInputMessage:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putInputMessage:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* BSTR *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       InputMessage: (* property *)
         (# enter putInputMessage exit getInputMessage #);
       getInputTitle:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putInputTitle:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* BSTR *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       InputTitle: (* property *)
         (# enter putInputTitle exit getInputTitle #);
       getFormula1:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getFormula2:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Modify:<
         (# result: @int32 (* HRESULT *);
            Type: @int32 (* VARIANT *); 
            AlertStyle: @int32 (* VARIANT *); 
            Operator: @int32 (* VARIANT *); 
            Formula1: @int32 (* VARIANT *); 
            Formula2: @int32 (* VARIANT *); 
         enter (Type, AlertStyle, Operator, Formula1, Formula2)
         do (* callStd *) INNER;
         exit result
         #);
       getOperator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getShowError:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putShowError:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       ShowError: (* property *)
         (# enter putShowError exit getShowError #);
       getShowInput:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putShowInput:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       ShowInput: (* property *)
         (# enter putShowInput exit getShowInput #);
       getType:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getValue:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IHyperlinks_IID: (# exit '00024430-0001-0000-C000-000000000046' #);

  IHyperlinks: IDispatch
    (# <<SLOT IHyperlinksLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Add:<
         (# result: @int32 (* HRESULT *);
            Anchor: ^IDispatch (* IDispatch* *); 
            Address: @int32 (* BSTR *); 
            SubAddress: @int32 (* VARIANT *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Anchor[], Address, SubAddress, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getCount:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getItem:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Hyperlink** *); 
         enter (Index, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       get_Default:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Hyperlink** *); 
         enter (Index, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       get_NewEnum:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IUnknownHolder (* IUnknown** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Delete:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IHyperlink_IID: (# exit '00024431-0001-0000-C000-000000000046' #);

  IHyperlink: IDispatch
    (# <<SLOT IHyperlinkLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getName:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getRange:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getShape:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ShapeHolder (* Shape** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getSubAddress:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putSubAddress:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* BSTR *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       SubAddress: (* property *)
         (# enter putSubAddress exit getSubAddress #);
       getAddress:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putAddress:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* BSTR *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Address: (* property *)
         (# enter putAddress exit getAddress #);
       getType:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       AddToFavorites:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       Delete:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       Follow:<
         (# result: @int32 (* HRESULT *);
            NewWindow: @int32 (* VARIANT *); 
            AddHistory: @int32 (* VARIANT *); 
            ExtraInfo: @int32 (* VARIANT *); 
            Method: @int32 (* VARIANT *); 
            HeaderInfo: @int32 (* VARIANT *); 
         enter (NewWindow, AddHistory, ExtraInfo, Method, HeaderInfo)
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IAutoFilter_IID: (# exit '00024432-0001-0000-C000-000000000046' #);

  IAutoFilter: IDispatch
    (# <<SLOT IAutoFilterLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getRange:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Range** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getFilters:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Filters** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IFilters_IID: (# exit '00024433-0001-0000-C000-000000000046' #);

  IFilters: IDispatch
    (# <<SLOT IFiltersLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCount:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       get_Default:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* long *); 
            RHS: ^int32Holder (* Filter** *); 
         enter (Index, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getItem:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* long *); 
            RHS: ^int32Holder (* Filter** *); 
         enter (Index, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       get_NewEnum:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IUnknownHolder (* IUnknown** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IFilter_IID: (# exit '00024434-0001-0000-C000-000000000046' #);

  IFilter: IDispatch
    (# <<SLOT IFilterLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getOn:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCriteria1:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getOperator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlAutoFilterOperator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCriteria2:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IAutoCorrect_IID: (# exit '000208D4-0001-0000-C000-000000000046' #);

  IAutoCorrect: IDispatch
    (# <<SLOT IAutoCorrectLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       AddReplacement:<
         (# result: @int32 (* HRESULT *);
            What: @int32 (* BSTR *); 
            Replacement: @int32 (* BSTR *); 
         enter (What, Replacement)
         do (* callStd *) INNER;
         exit result
         #);
       getCapitalizeNamesOfDays:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putCapitalizeNamesOfDays:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       CapitalizeNamesOfDays: (* property *)
         (# enter putCapitalizeNamesOfDays exit getCapitalizeNamesOfDays #);
       DeleteReplacement:<
         (# result: @int32 (* HRESULT *);
            What: @int32 (* BSTR *); 
         enter What
         do (* callStd *) INNER;
         exit result
         #);
       ReplacementList:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            RHS: ^VARIANT (* VARIANT* *); 
         enter (Index, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getReplaceText:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putReplaceText:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       ReplaceText: (* property *)
         (# enter putReplaceText exit getReplaceText #);
       getTwoInitialCapitals:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putTwoInitialCapitals:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       TwoInitialCapitals: (* property *)
         (# enter putTwoInitialCapitals exit getTwoInitialCapitals #);
       getCorrectSentenceCap:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putCorrectSentenceCap:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       CorrectSentenceCap: (* property *)
         (# enter putCorrectSentenceCap exit getCorrectSentenceCap #);
       getCorrectCapsLock:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putCorrectCapsLock:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       CorrectCapsLock: (* property *)
         (# enter putCorrectCapsLock exit getCorrectCapsLock #);
    #);

  IBorder_IID: (# exit '00020854-0001-0000-C000-000000000046' #);

  IBorder: IDispatch
    (# <<SLOT IBorderLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getColor:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putColor:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Color: (* property *)
         (# enter putColor exit getColor #);
       getColorIndex:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putColorIndex:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       ColorIndex: (* property *)
         (# enter putColorIndex exit getColorIndex #);
       getLineStyle:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putLineStyle:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       LineStyle: (* property *)
         (# enter putLineStyle exit getLineStyle #);
       getWeight:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putWeight:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Weight: (* property *)
         (# enter putWeight exit getWeight #);
    #);

  IInterior_IID: (# exit '00020870-0001-0000-C000-000000000046' #);

  IInterior: IDispatch
    (# <<SLOT IInteriorLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getColor:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putColor:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Color: (* property *)
         (# enter putColor exit getColor #);
       getColorIndex:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putColorIndex:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       ColorIndex: (* property *)
         (# enter putColorIndex exit getColorIndex #);
       getInvertIfNegative:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putInvertIfNegative:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       InvertIfNegative: (* property *)
         (# enter putInvertIfNegative exit getInvertIfNegative #);
       getPattern:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putPattern:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Pattern: (* property *)
         (# enter putPattern exit getPattern #);
       getPatternColor:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putPatternColor:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       PatternColor: (* property *)
         (# enter putPatternColor exit getPatternColor #);
       getPatternColorIndex:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putPatternColorIndex:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       PatternColorIndex: (* property *)
         (# enter putPatternColorIndex exit getPatternColorIndex #);
    #);

  IChartFillFormat_IID: (# exit '00024435-0001-0000-C000-000000000046' #);

  IChartFillFormat: IDispatch
    (# <<SLOT IChartFillFormatLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       OneColorGradient:<
         (# result: @int32 (* HRESULT *);
            _Style: @int32 (* MsoGradientStyle *); 
            _Variant: @int32 (* long *); 
            Degree: @int32 (* single *); 
         enter (_Style, _Variant, Degree)
         do (* callStd *) INNER;
         exit result
         #);
       TwoColorGradient:<
         (# result: @int32 (* HRESULT *);
            _Style: @int32 (* MsoGradientStyle *); 
            _Variant: @int32 (* long *); 
         enter (_Style, _Variant)
         do (* callStd *) INNER;
         exit result
         #);
       PresetTextured:<
         (# result: @int32 (* HRESULT *);
            PresetTexture: @int32 (* MsoPresetTexture *); 
         enter PresetTexture
         do (* callStd *) INNER;
         exit result
         #);
       Solid:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       Patterned:<
         (# result: @int32 (* HRESULT *);
            Pattern: @int32 (* MsoPatternType *); 
         enter Pattern
         do (* callStd *) INNER;
         exit result
         #);
       UserPicture:<
         (# result: @int32 (* HRESULT *);
            PictureFile: @int32 (* VARIANT *); 
            _PictureFormat: @int32 (* VARIANT *); 
            PictureStackUnit: @int32 (* VARIANT *); 
            PicturePlacement: @int32 (* VARIANT *); 
         enter (PictureFile, _PictureFormat, PictureStackUnit, PicturePlacement)
         do (* callStd *) INNER;
         exit result
         #);
       UserTextured:<
         (# result: @int32 (* HRESULT *);
            TextureFile: @int32 (* BSTR *); 
         enter TextureFile
         do (* callStd *) INNER;
         exit result
         #);
       PresetGradient:<
         (# result: @int32 (* HRESULT *);
            _Style: @int32 (* MsoGradientStyle *); 
            _Variant: @int32 (* long *); 
            PresetGradientType: @int32 (* MsoPresetGradientType *); 
         enter (_Style, _Variant, PresetGradientType)
         do (* callStd *) INNER;
         exit result
         #);
       getBackColor:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* ChartColorFormat** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getForeColor:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* ChartColorFormat** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getGradientColorType:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* MsoGradientColorType* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getGradientDegree:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* single* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getGradientStyle:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* MsoGradientStyle* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getGradientVariant:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getPattern:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* MsoPatternType* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getPresetGradientType:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* MsoPresetGradientType* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getPresetTexture:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* MsoPresetTexture* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getTextureName:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getTextureType:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* MsoTextureType* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getType:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* MsoFillType* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getVisible:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* MsoTriState* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putVisible:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* MsoTriState *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Visible: (* property *)
         (# enter putVisible exit getVisible #);
    #);

  IChartColorFormat_IID: (# exit '00024436-0001-0000-C000-000000000046' #);

  IChartColorFormat: IDispatch
    (# <<SLOT IChartColorFormatLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getSchemeColor:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putSchemeColor:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* long *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       SchemeColor: (* property *)
         (# enter putSchemeColor exit getSchemeColor #);
       getRGB:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       get_Default:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getType:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IAxis_IID: (# exit '00020848-0001-0000-C000-000000000046' #);

  IAxis: IDispatch
    (# <<SLOT IAxisLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getAxisBetweenCategories:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putAxisBetweenCategories:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       AxisBetweenCategories: (* property *)
         (# enter putAxisBetweenCategories exit getAxisBetweenCategories #);
       getAxisGroup:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlAxisGroup* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getAxisTitle:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* AxisTitle** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getBorder:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Border** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCategoryNames:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putCategoryNames:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       CategoryNames: (* property *)
         (# enter putCategoryNames exit getCategoryNames #);
       getCrosses:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlAxisCrosses* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putCrosses:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlAxisCrosses *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Crosses: (* property *)
         (# enter putCrosses exit getCrosses #);
       getCrossesAt:<
         (# result: @int32 (* HRESULT *);
            RHS: ^realHolder (* double* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putCrossesAt:<
         (# result: @int32 (* HRESULT *);
            RHS: @real (* double *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       CrossesAt: (* property *)
         (# enter putCrossesAt exit getCrossesAt #);
       Delete:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       getHasMajorGridlines:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putHasMajorGridlines:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       HasMajorGridlines: (* property *)
         (# enter putHasMajorGridlines exit getHasMajorGridlines #);
       getHasMinorGridlines:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putHasMinorGridlines:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       HasMinorGridlines: (* property *)
         (# enter putHasMinorGridlines exit getHasMinorGridlines #);
       getHasTitle:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putHasTitle:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       HasTitle: (* property *)
         (# enter putHasTitle exit getHasTitle #);
       getMajorGridlines:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Gridlines** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getMajorTickMark:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlTickMark* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putMajorTickMark:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlTickMark *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       MajorTickMark: (* property *)
         (# enter putMajorTickMark exit getMajorTickMark #);
       getMajorUnit:<
         (# result: @int32 (* HRESULT *);
            RHS: ^realHolder (* double* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putMajorUnit:<
         (# result: @int32 (* HRESULT *);
            RHS: @real (* double *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       MajorUnit: (* property *)
         (# enter putMajorUnit exit getMajorUnit #);
       getMajorUnitIsAuto:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putMajorUnitIsAuto:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       MajorUnitIsAuto: (* property *)
         (# enter putMajorUnitIsAuto exit getMajorUnitIsAuto #);
       getMaximumScale:<
         (# result: @int32 (* HRESULT *);
            RHS: ^realHolder (* double* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putMaximumScale:<
         (# result: @int32 (* HRESULT *);
            RHS: @real (* double *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       MaximumScale: (* property *)
         (# enter putMaximumScale exit getMaximumScale #);
       getMaximumScaleIsAuto:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putMaximumScaleIsAuto:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       MaximumScaleIsAuto: (* property *)
         (# enter putMaximumScaleIsAuto exit getMaximumScaleIsAuto #);
       getMinimumScale:<
         (# result: @int32 (* HRESULT *);
            RHS: ^realHolder (* double* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putMinimumScale:<
         (# result: @int32 (* HRESULT *);
            RHS: @real (* double *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       MinimumScale: (* property *)
         (# enter putMinimumScale exit getMinimumScale #);
       getMinimumScaleIsAuto:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putMinimumScaleIsAuto:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       MinimumScaleIsAuto: (* property *)
         (# enter putMinimumScaleIsAuto exit getMinimumScaleIsAuto #);
       getMinorGridlines:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Gridlines** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getMinorTickMark:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlTickMark* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putMinorTickMark:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlTickMark *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       MinorTickMark: (* property *)
         (# enter putMinorTickMark exit getMinorTickMark #);
       getMinorUnit:<
         (# result: @int32 (* HRESULT *);
            RHS: ^realHolder (* double* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putMinorUnit:<
         (# result: @int32 (* HRESULT *);
            RHS: @real (* double *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       MinorUnit: (* property *)
         (# enter putMinorUnit exit getMinorUnit #);
       getMinorUnitIsAuto:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putMinorUnitIsAuto:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       MinorUnitIsAuto: (* property *)
         (# enter putMinorUnitIsAuto exit getMinorUnitIsAuto #);
       getReversePlotOrder:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putReversePlotOrder:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       ReversePlotOrder: (* property *)
         (# enter putReversePlotOrder exit getReversePlotOrder #);
       getScaleType:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlScaleType* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putScaleType:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlScaleType *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       ScaleType: (* property *)
         (# enter putScaleType exit getScaleType #);
       Select:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       getTickLabelPosition:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlTickLabelPosition* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putTickLabelPosition:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlTickLabelPosition *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       TickLabelPosition: (* property *)
         (# enter putTickLabelPosition exit getTickLabelPosition #);
       getTickLabels:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* TickLabels** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getTickLabelSpacing:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putTickLabelSpacing:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* long *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       TickLabelSpacing: (* property *)
         (# enter putTickLabelSpacing exit getTickLabelSpacing #);
       getTickMarkSpacing:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putTickMarkSpacing:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* long *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       TickMarkSpacing: (* property *)
         (# enter putTickMarkSpacing exit getTickMarkSpacing #);
       getType:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlAxisType* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putType:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlAxisType *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Type: (* property *)
         (# enter putType exit getType #);
       getBaseUnit:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlTimeUnit* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putBaseUnit:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlTimeUnit *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       BaseUnit: (* property *)
         (# enter putBaseUnit exit getBaseUnit #);
       getBaseUnitIsAuto:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putBaseUnitIsAuto:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       BaseUnitIsAuto: (* property *)
         (# enter putBaseUnitIsAuto exit getBaseUnitIsAuto #);
       getMajorUnitScale:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlTimeUnit* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putMajorUnitScale:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlTimeUnit *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       MajorUnitScale: (* property *)
         (# enter putMajorUnitScale exit getMajorUnitScale #);
       getMinorUnitScale:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlTimeUnit* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putMinorUnitScale:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlTimeUnit *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       MinorUnitScale: (* property *)
         (# enter putMinorUnitScale exit getMinorUnitScale #);
       getCategoryType:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCategoryType* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putCategoryType:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlCategoryType *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       CategoryType: (* property *)
         (# enter putCategoryType exit getCategoryType #);
       getLeft:<
         (# result: @int32 (* HRESULT *);
            RHS: ^realHolder (* double* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getTop:<
         (# result: @int32 (* HRESULT *);
            RHS: ^realHolder (* double* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getWidth:<
         (# result: @int32 (* HRESULT *);
            RHS: ^realHolder (* double* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getHeight:<
         (# result: @int32 (* HRESULT *);
            RHS: ^realHolder (* double* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
    #);

  IChartTitle_IID: (# exit '00020849-0001-0000-C000-000000000046' #);

  IChartTitle: IDispatch
    (# <<SLOT IChartTitleLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getName:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Select:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       getBorder:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Border** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Delete:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       getInterior:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Interior** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getFill:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* ChartFillFormat** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCaption:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putCaption:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* BSTR *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Caption: (* property *)
         (# enter putCaption exit getCaption #);
       getCharacters:<
         (# result: @int32 (* HRESULT *);
            Start: @int32 (* VARIANT *); 
            Length: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Characters** *); 
         enter (Start, Length, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getFont:<
         (# result: @int32 (* HRESULT *);
            RHS: ^FontHolder (* Font** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getHorizontalAlignment:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putHorizontalAlignment:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       HorizontalAlignment: (* property *)
         (# enter putHorizontalAlignment exit getHorizontalAlignment #);
       getLeft:<
         (# result: @int32 (* HRESULT *);
            RHS: ^realHolder (* double* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putLeft:<
         (# result: @int32 (* HRESULT *);
            RHS: @real (* double *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Left: (* property *)
         (# enter putLeft exit getLeft #);
       getOrientation:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putOrientation:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Orientation: (* property *)
         (# enter putOrientation exit getOrientation #);
       getShadow:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putShadow:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Shadow: (* property *)
         (# enter putShadow exit getShadow #);
       getText:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putText:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* BSTR *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Text: (* property *)
         (# enter putText exit getText #);
       getTop:<
         (# result: @int32 (* HRESULT *);
            RHS: ^realHolder (* double* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putTop:<
         (# result: @int32 (* HRESULT *);
            RHS: @real (* double *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Top: (* property *)
         (# enter putTop exit getTop #);
       getVerticalAlignment:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putVerticalAlignment:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       VerticalAlignment: (* property *)
         (# enter putVerticalAlignment exit getVerticalAlignment #);
       getReadingOrder:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putReadingOrder:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* long *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       ReadingOrder: (* property *)
         (# enter putReadingOrder exit getReadingOrder #);
       getAutoScaleFont:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putAutoScaleFont:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       AutoScaleFont: (* property *)
         (# enter putAutoScaleFont exit getAutoScaleFont #);
    #);

  IAxisTitle_IID: (# exit '0002084A-0001-0000-C000-000000000046' #);

  IAxisTitle: IDispatch
    (# <<SLOT IAxisTitleLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getName:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Select:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       getBorder:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Border** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       Delete:<
         (# result: @int32 (* HRESULT *);
         do (* callStd *) INNER;
         exit result
         #);
       getInterior:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* Interior** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getFill:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* ChartFillFormat** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCaption:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putCaption:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* BSTR *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Caption: (* property *)
         (# enter putCaption exit getCaption #);
       getCharacters:<
         (# result: @int32 (* HRESULT *);
            Start: @int32 (* VARIANT *); 
            Length: @int32 (* VARIANT *); 
            RHS: ^int32Holder (* Characters** *); 
         enter (Start, Length, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getFont:<
         (# result: @int32 (* HRESULT *);
            RHS: ^FontHolder (* Font** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getHorizontalAlignment:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putHorizontalAlignment:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       HorizontalAlignment: (* property *)
         (# enter putHorizontalAlignment exit getHorizontalAlignment #);
       getLeft:<
         (# result: @int32 (* HRESULT *);
            RHS: ^realHolder (* double* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putLeft:<
         (# result: @int32 (* HRESULT *);
            RHS: @real (* double *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Left: (* property *)
         (# enter putLeft exit getLeft #);
       getOrientation:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putOrientation:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Orientation: (* property *)
         (# enter putOrientation exit getOrientation #);
       getShadow:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putShadow:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Shadow: (* property *)
         (# enter putShadow exit getShadow #);
       getText:<
         (# result: @int32 (* HRESULT *);
            RHS: ^BSTRHolder (* BSTR* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putText:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* BSTR *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Text: (* property *)
         (# enter putText exit getText #);
       getTop:<
         (# result: @int32 (* HRESULT *);
            RHS: ^realHolder (* double* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putTop:<
         (# result: @int32 (* HRESULT *);
            RHS: @real (* double *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Top: (* property *)
         (# enter putTop exit getTop #);
       getVerticalAlignment:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putVerticalAlignment:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       VerticalAlignment: (* property *)
         (# enter putVerticalAlignment exit getVerticalAlignment #);
       getReadingOrder:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putReadingOrder:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* long *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       ReadingOrder: (* property *)
         (# enter putReadingOrder exit getReadingOrder #);
       getAutoScaleFont:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putAutoScaleFont:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       AutoScaleFont: (* property *)
         (# enter putAutoScaleFont exit getAutoScaleFont #);
    #);

  IChartGroup_IID: (# exit '00020859-0001-0000-C000-000000000046' #);

  IChartGroup: IDispatch
    (# <<SLOT IChartGroupLib: attributes>>;
       getApplication:<
         (# result: @int32 (* HRESULT *);
            RHS: ^ApplicationHolder (* Application** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getCreator:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlCreator* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getParent:<
         (# result: @int32 (* HRESULT *);
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getAxisGroup:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlAxisGroup* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putAxisGroup:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlAxisGroup *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       AxisGroup: (* property *)
         (# enter putAxisGroup exit getAxisGroup #);
       getDoughnutHoleSize:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putDoughnutHoleSize:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* long *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       DoughnutHoleSize: (* property *)
         (# enter putDoughnutHoleSize exit getDoughnutHoleSize #);
       getDownBars:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* DownBars** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getDropLines:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* DropLines** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getFirstSliceAngle:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putFirstSliceAngle:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* long *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       FirstSliceAngle: (* property *)
         (# enter putFirstSliceAngle exit getFirstSliceAngle #);
       getGapWidth:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putGapWidth:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* long *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       GapWidth: (* property *)
         (# enter putGapWidth exit getGapWidth #);
       getHasDropLines:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putHasDropLines:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       HasDropLines: (* property *)
         (# enter putHasDropLines exit getHasDropLines #);
       getHasHiLoLines:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putHasHiLoLines:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       HasHiLoLines: (* property *)
         (# enter putHasHiLoLines exit getHasHiLoLines #);
       getHasRadarAxisLabels:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putHasRadarAxisLabels:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       HasRadarAxisLabels: (* property *)
         (# enter putHasRadarAxisLabels exit getHasRadarAxisLabels #);
       getHasSeriesLines:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putHasSeriesLines:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       HasSeriesLines: (* property *)
         (# enter putHasSeriesLines exit getHasSeriesLines #);
       getHasUpDownBars:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putHasUpDownBars:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       HasUpDownBars: (* property *)
         (# enter putHasUpDownBars exit getHasUpDownBars #);
       getHiLoLines:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* HiLoLines** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getIndex:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getOverlap:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putOverlap:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* long *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Overlap: (* property *)
         (# enter putOverlap exit getOverlap #);
       getRadarAxisLabels:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* TickLabels** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       SeriesCollection:<
         (# result: @int32 (* HRESULT *);
            Index: @int32 (* VARIANT *); 
            RHS: ^IDispatchHolder (* IDispatch** *); 
         enter (Index, RHS[])
         do (* callStd *) INNER;
         exit result
         #);
       getSeriesLines:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* SeriesLines** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getSubType:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putSubType:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* long *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       SubType: (* property *)
         (# enter putSubType exit getSubType #);
       getType:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putType:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* long *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Type: (* property *)
         (# enter putType exit getType #);
       getUpBars:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* UpBars** *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       getVaryByCategories:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putVaryByCategories:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       VaryByCategories: (* property *)
         (# enter putVaryByCategories exit getVaryByCategories #);
       getSizeRepresents:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlSizeRepresents* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putSizeRepresents:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlSizeRepresents *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       SizeRepresents: (* property *)
         (# enter putSizeRepresents exit getSizeRepresents #);
       getBubbleScale:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putBubbleScale:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* long *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       BubbleScale: (* property *)
         (# enter putBubbleScale exit getBubbleScale #);
       getShowNegativeBubbles:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putShowNegativeBubbles:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       ShowNegativeBubbles: (* property *)
         (# enter putShowNegativeBubbles exit getShowNegativeBubbles #);
       getSplitType:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* XlChartSplitType* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putSplitType:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* XlChartSplitType *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       SplitType: (* property *)
         (# enter putSplitType exit getSplitType #);
       getSplitValue:<
         (# result: @int32 (* HRESULT *);
            RHS: ^VARIANT (* VARIANT* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putSplitValue:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       SplitValue: (* property *)
         (# enter putSplitValue exit getSplitValue #);
       getSecondPlotSize:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* long* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putSecondPlotSize:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* long *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       SecondPlotSize: (* property *)
         (# enter putSecondPlotSize exit getSecondPlotSize #);
       getHas3DShading:<
         (# result: @int32 (* HRESULT *);
            RHS: ^int32Holder (* VARIANT_BOOL* *); 
         enter RHS[]
         do (* callStd *) INNER;
         exit result
         #);
       putHas3DShading:<
         (# result: @int32 (* HRESULT *);
            RHS: @int32 (* VARIANT_BOOL *); 
         enter RHS
         do (* callStd *) INNER;
         exit result
         #);
       Has3DShading: (* property *)
         (# enter putHas3DShading exit getHas3DShading #);
    #);

  (* Reference Holders *)

  IMailerHolder: refHolder
    (# type:: IMailer #);
  ICustomViewsHolder: refHolder
    (# type:: ICustomViews #);
  ICustomViewHolder: refHolder
    (# type:: ICustomView #);
  IFormatConditionsHolder: refHolder
    (# type:: IFormatConditions #);
  IFormatConditionHolder: refHolder
    (# type:: IFormatCondition #);
  ICommentsHolder: refHolder
    (# type:: IComments #);
  ICommentHolder: refHolder
    (# type:: IComment #);
  IRefreshEventsHolder: refHolder
    (# type:: IRefreshEvents #);
  _IQueryTableHolder: refHolder
    (# type:: _IQueryTable #);
  IQueryTablesHolder: refHolder
    (# type:: IQueryTables #);
  IParameterHolder: refHolder
    (# type:: IParameter #);
  IParametersHolder: refHolder
    (# type:: IParameters #);
  IODBCErrorHolder: refHolder
    (# type:: IODBCError #);
  IODBCErrorsHolder: refHolder
    (# type:: IODBCErrors #);
  IValidationHolder: refHolder
    (# type:: IValidation #);
  IHyperlinksHolder: refHolder
    (# type:: IHyperlinks #);
  IHyperlinkHolder: refHolder
    (# type:: IHyperlink #);
  IAutoFilterHolder: refHolder
    (# type:: IAutoFilter #);
  IFiltersHolder: refHolder
    (# type:: IFilters #);
  IFilterHolder: refHolder
    (# type:: IFilter #);
  IAutoCorrectHolder: refHolder
    (# type:: IAutoCorrect #);
  IBorderHolder: refHolder
    (# type:: IBorder #);
  IInteriorHolder: refHolder
    (# type:: IInterior #);
  IChartFillFormatHolder: refHolder
    (# type:: IChartFillFormat #);
  IChartColorFormatHolder: refHolder
    (# type:: IChartColorFormat #);
  IAxisHolder: refHolder
    (# type:: IAxis #);
  IChartTitleHolder: refHolder
    (# type:: IChartTitle #);
  IAxisTitleHolder: refHolder
    (# type:: IAxisTitle #);
  IChartGroupHolder: refHolder
    (# type:: IChartGroup #);

