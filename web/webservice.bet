ORIGIN '~beta/basiclib/basicsystemenv';
INCLUDE '~beta/process/streamgenerator';
INCLUDE '~beta/basiclib/textmatch';
INCLUDE 'textcollections';
BODY 'private/webservicebody';

-- SystemLib: Attributes --

BasicWebService:
  (# <<SLOT BasicWebServiceLib: Attributes>>;
     port: @integer;
     init:<
       (#
       enter port
       do port -> theSocketGenerator.bind;
          INNER
       #);
     dispatch:<
       (# request: ^HttpRequest;
          response: ^HttpResponse;
       enter request[]
       do INNER;
       exit response[]
       #);
     accept:
       (# socket: ^StreamSocket;
          request: ^HttpRequest;
          response: ^HttpResponse;
       do waitForEver -> theSocketGenerator.getStreamConnection -> socket[];
          socket[] -> parseRequest -> request[];
          request[] -> dispatch -> response[];
          (socket[], response[]) -> writeResponse;
          socket.close;
       #);
     parseRequest:
       (# socket: ^StreamSocket;
          request: ^HttpRequest;
       enter socket[]
       <<SLOT BasicWebServiceParseRequest: dopart>>
       exit request[]
       #);
     writeResponse:
       (# socket: ^StreamSocket;
          response: ^HttpResponse;
       enter (socket[], response[])
       <<SLOT BasicWebServiceWriteResponse: dopart>> 
       #);

     theSocketGenerator: @SocketGenerator;
  #);

HttpRequest:
  (# method: ^Text;
     headers: ^HeaderParameters;
     path: ^Text;
     query: ^QueryParameters;
     part: ^Text;
     body: ^Text;
  #);
HttpResponse:
  (# status: @integer;
     message: ^Text;
     headers: ^HeaderParameters;
     contentType: ^Text;
     body: ^Text;
  #);

QueryParameters: TextDictionary
  (# element:: TextList;
     lookupSingle:
       (# name: ^Text;
          values: ^TextList;
          value: ^Text;
       enter name[]
       do name[] -> lookup -> values[];
          (if values[] <> NONE then
             1 -> values.get -> value[];
          if);
       exit value[]
       #);
  #);
HeaderParameters: TextDictionary
  (# element:: Text;
  #);

WebService: BasicWebService
  (# handlers: @List
       (# element:: BasicRequestHandler;
       #);
     register:
       (# handler: ^BasicRequestHandler;
       enter handler[]
       do handler[] -> handlers.append;
       #);
     dispatch::
       (#
       do loop: handlers.scan
            (#
            do (if request[] -> current.matches then
                  request[] -> current.dispatch -> response[];
                  leave loop;
               if);
            #);
       #);
  #);

BasicRequestHandler:
  (# init:<
       (#
       do INNER;
       #);
     matches:<
       (# request: ^HttpRequest;
          value: @boolean;
       enter request[]
       do INNER;
       exit value
       #);
     dispatch:<
       (# request: ^HttpRequest;
          response: ^HttpResponse;
       enter request[]
       do INNER;
       exit response[]
       #);  
  #);
RequestHandler: BasicRequestHandler
  (# path: ^Text;
     RequestMethod:
       (# request: ^HttpRequest;
          response: ^HttpResponse;
       enter request[]
       do INNER;
       exit response[]
       #);
     get:< RequestMethod;
     put:< RequestMethod;
     post:< RequestMethod;
     delete:< RequestMethod;
     patch:< RequestMethod;

     matches::
       (# myPath: ^TextList;
          requestPath: ^TextList;
          my: ^Text;
          other: ^Text;
       do path[] -> parsePath -> myPath[];
          request.path[] -> parsePath -> requestPath[];
          (if myPath.size <= requestPath.size then
             true -> value;
             loop:
               (for index: myPath.size repeat
                  index -> myPath.get -> my[];
                  index -> requestPath.get -> other[];
                  (if NOT (my[] -> other.equal) then
                     false -> value;
                     leave loop;
                  if);
               for);
          if);
       #);
     dispatch::
       (# myPath: ^TextList;
          requestPath: ^TextList;
          restPath: ^Text;
          n: @integer;
       do path[] -> parsePath -> myPath[];
          request.path[] -> parsePath -> requestPath[];
          &Text[] -> restPath[];
          (requestPath.size - myPath.size) -> n;
          (for index: n repeat
             myPath.size + index -> requestPath.get -> restPath.putText;
             (if index <> n then
                '/' -> restPath.putText;
             if);
          for);
          restPath[] -> request.path[];
          (if true
            //'GET' -> request.method.equal then
               request[] -> get -> response[];
            //'PUT' -> request.method.equal then
               request[] -> put -> response[];
            //'POST' -> request.method.equal then
               request[] -> post -> response[];
            //'DELETE' -> request.method.equal then
               request[] -> delete -> response[];
            //'PATCH' -> request.method.equal then
               request[] -> patch -> response[];
          if);
       #);
     parsePath:
       (# input: ^Text;
          path: ^TextList;
       enter input[]
       do &TextList[] -> path[];
          ('/' -> input.split).scan
            (#
            do (if NOT current.empty then
                  current[] -> path.append;
               if);
            #);
       exit path[]
       #);
  #);