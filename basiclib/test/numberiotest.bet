ORIGIN '~beta/basiclib/betaenv';
INCLUDE '~beta/basiclib/numberio';
INCLUDE '~beta/basiclib/formatio';
--- program: descriptor ---
(# r,r2: @real; i2: @integer;
   chkI: 
     (# x,y: @integer; ch: @char 
     enter(x,y,ch)
     do (if x=y then ch->put else '!'->put if)
     #);
   chkR: 
     (* Note that comparions of reals as in X+Y
      * does in general not work satisfactory for floating point numbers.
      * E.g 1.11->x; 3.33->y; y-x->z; x=2.22 may be false
      *)
     (# x,y,z: @real; ch: @char 
     enter(x,y,ch)
     do x-y->z; (* The difference should be close to zero *)
        z->i;   (* round to nearest integer, should be zero *)
        (if i<0 then -i->i if);
        (if i=0 then ch->put else '!'->put if)
     #);
   chkT: 
     (# x,y: @text; ch: @char 
     enter(x,y,ch)
     do (if x[]->y.equalNCS then ch->put else '!'->put if)
     #);
   t,err: @text;
   getNum:
     (# T: @text;
        test:<
          (# err: ^text
          enter err[] 
          do INNER; (if err[]<>NONE then '!'->put if)
          #);
     enter T
     do (*T[]->puttext; ' is:'->puttext;*) 0->T.setPos;
	T.GetNumber
        (# IntegerValue::<
             (# do (*'\n\tInt='->puttext;*) value->i2(*->putInt*); #);
           basedValue::<
             (#
             do (*'\n\tbase='->puttext; base->putint;*)
                (*'\n\tintValue='->puttext;*) value->i2(*->putint*);
                (*'\n\tbasedValue='->puttext; (base,value)->putBased(# do true->upcase->uppercase #)*)
             #);
           realValue::<
             (#
             do (*'\n\tReal='->puttext;*) 
                value->r2(*->putreal(# do exp->style; 16->precision #)*);
                (*'\n\tr=   '->puttext; r->putreal(# do exp->style; 16->precision #);*)
             #);
           syntaxError::< (# do msg[]->test; true->continue #);
           baseError::< (# do msg[]->test; true->continue #)
        #);
     #);
   i, j: @integer;
   putI:
     (# s: @text;
        ch: @char
     enter ch     
     do ch->put; '['->put;
        t.clear;
        i->t.putHex(# do 8->width; true->zeroPadding #);
        (for j:4 repeat
             s.clear;(i,j)->s.putByteHex;
             (if (j*2-1,j*2)->t.sub->s.equalNCS then 0->put else '!'->put if)
        for);
        t.clear;
        i->t.putBinary(# do 32->width; true->zeroPadding #);
        (for j:4 repeat
             s.clear;(i,j)->s.putByteBinary;
             (if (j*8-7,j*8)->t.sub->s.equalNCS then 0->put else '!'->put if)
        for);
        ']'->put;
     #);
   putB:
     (# v,b: @integer
     enter (b,v)
     do t.clear;
        (b,v)->t.putBased(# do 10->width; true->zeropadding->uppercase #);
     #);
   putH:
     (# v,b: @integer
     enter (b,v)
     do t.clear;
        (b,v)->t.putBased(# do 10->width; true->zeropadding->uppercase #);
     #);
   getJ:
     (# t: @text; ch: @char
     enter ch
     do t.clear; i->t.putHex; t.reset; t.getHex->j;
        (if j=i then ch->put else '!'->put if);
        t.clear; i->t.putBinary; t.reset; t.getBinary->j;
        (if j=i then ch->put else '!'->put if);
     #)
   
do -2->r;
   (for i: 10 repeat
        t.clear; r -> t.putreal(# do exp->style; 16->precision #); t -> getNum;
        (r,r2,'a'+i-1)->chkR;
        r + 0.00005 -> r;
   for);
   
   -2->r;
   (for i: 10 repeat
        t.clear; r -> t.putreal(# do exp->style; 16->precision #); t -> getNum;
        (r,r2,'a'+i+9)->chkR;
        r + 0.5 -> r;
   for);

   '1'->getNum;
   (1,i2,'u')->chkI;
   '314'->getNum;
   (314,i2,'w')->chkI;
   
   '2x0101'->getNum;
   (2x0101,i2,'x')->chkI;
   '8x101'->getNum;
   (8x101,i2,'y')->chkI;
   '16xA0B'->getNum;
   (16xA0B,i2,'z')->chkI;
   '0X5A'->getNum;
   (0X5A,i2,'0')->chkI;
   
   '1200x80'->getNum (* give rise to a syntax-error exception *)
   (# test::
        (#
        do ('getNumber: Error in base - looking at: "1200"',err,'1')->chkT;
           NONE->err[]
        #)
   #);
   
   3.14->r; '3.14'->getNum;
   (3.14,r2,'2')->chkR;
   3.014->r; '3.014'->getNum;
   (3.014,r2,'3')->chkR;
   3.14E8->r; '3.14E8'->getNum;
   (3.14E8,r2,'4')->chkR;
   3.14E+8->r; '3.14E+8'->getNum;
   (3.14E+8,r2,'5')->chkR;
   3.14E-8->r; '3.14E-8'->getNum;
   (3.14E-8,r2,'6')->chkR;
   3.14E+08->r; '3.14E+08'->getNum;
   (3.14E+08,r2,'7')->chkR;
   3.14E-08->r; '3.14E-08'->getNum;
   (3.14E-08,r2,'8')->chkR;
   3e8->r; '3e8'->getNum;
   (3e8,r2,'9')->chkR;
   3e+8->r; '3e+8'->getNum;
   (3e+8,r2,'0')->chkR;
   3e-8->r; '3e-8'->getNum;
   (3e-8,r2,'A')->chkR;
   3.14E+80->r; '3.14E+80'->getNum;
   (3.14E+80,r2,'B')->chkR;
   3.14E-80->r; '3.14E-80'->getNum;
   (3.14E-80,r2,'C')->chkR;
   3.0010140E12->r; '3.0010140E12'->getNum;
   (3.0010140E12,r2,'D')->chkR;
   minReal->r; '2.2250738585072009E-308'->getNum;
   (r2,minReal,'E')->chkR;
   2.2250738585072015E-408->r;   '2.2250738585072015E-408'->getNum;
   (r2,0.0,'F')->chkR;
   
   maxReal->r; '1.7976931348623149E+308'->getNum;
   (*(r2,maxReal,'G')->chkR;*)
   maxReal->r; '1.7976931348623149E+408'->getNum;
   (*(r2,maxReal,'H')->chkR;*)
   
   -1.7976931348623158E+408->r;   '-1.7976931348623158E+408'->getNum;
   (*(-1.7976931348623158E+408,r2,'I')->chkR;*)
 
   '1.E+12'->getNum (* give rise to a syntax-error exception *)
   (# test::
        (#
        do ('getNumber: Syntax error - looking at: "E"',err,'J')->chkT;
           NONE->err[]
        #)
   #);
   
   t.clear; '%02x'->t.putFormat(# do 0->x #); ('00',t,'1')->chkT;
   
   (0,minint)->putB; ('-0x80000000',t,'K')->chkT;
   (0,-1)->putB; ('-0x0000001',t,'L')->chkT;
   (0,0)->putB; ('0x00000000',t,'M')->chkT;
   (0,1)->putB; ('0x00000001',t,'N')->chkT;
   (0,33554431)->putB; ('0x01FFFFFF',t,'O')->chkT;
   (0,67108863)->putB; ('0x03FFFFFF',t,'P')->chkT;
   (0,134217727)->putB; ('0x07FFFFFF',t,'Q')->chkT;
   (0,268435455)->putB; ('0x0FFFFFFF',t,'R')->chkT;
   (0,536870911)->putB; ('0x1FFFFFFF',t,'S')->chkT;
   (0,1073741823)->putB; ('0x3FFFFFFF',t,'T')->chkT;
   (0,2147483647)->putB; ('0x7FFFFFFF',t,'U')->chkT;
   (0,-1)->putB; ('-0x0000001',t,'V')->chkT;
   (0,maxint)->putB; ('0x7FFFFFFF',t,'W')->chkT;
   
   
   t.clear; 0x00->t.putHex(# do 2->width; true->zeroPadding #);
   ('00',t,'X')->chkT;
   t.clear; (16,0x00)->t.putBased(# do 5->width; true->zeropadding #);
   ('16x00',t,'Y')->chkT;
   
   t.clear; 0xe7090000->t.putHex(# do 8->width #);
   ('E7090000',t,'Z')->chkT;

   t.clear; (16,0xe7090000) -> t.putRadix(# do true->zeropadding; 8->width #);
   ('-18f70000',t,'0')->chkT;
   t.clear; (16,0xe7090000) -> t.putRadix(# do true->zeropadding; 8->width; false -> signed #);
   ('-18f70000',t,'1')->chkT;
   
   t.clear; 0xf0 -> t.puthex(# do 2->width; true->zeroPadding #);
   ('000000F0',t,'2')->chkT;
   t.clear; 0x0f -> t.puthex(# do 2->width; true->zeroPadding #);
   ('0000000F',t,'3')->chkT;
   
   (# p: @t.putRadix(# do 2->width; true->zeropadding #)
   do t.clear; (16,0xf0) -> p; ('F0',t,'4')->chkT;
      t.clear; (16,0xf0) -> p; ('F0',t,'5')->chkT;
   #);

   minint->i; '6'->putI; '7'->getJ;
   maxint->i; '8'->putI; '9'->getJ;

   127->i; '0'->putI; 'a'->getJ;
   -127->i; 'b'->putI; 'c'->getJ;
   
   128->i; 'd'->putI; 'e'->getJ;
   -128->i; 'f'->putI; 'g'->getJ;
   
   newline;
#)
