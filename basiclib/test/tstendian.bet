ORIGIN '~beta/basiclib/endian';
(* OBS! This program has NOT yet been tested on a big endian machine *)
---program:descriptor--
(# X,Y: @integer; R: [6] @integer
do  0x01020304->X; 
   (if isBigEndian//true then
       'I am BIG'->putline;
       (if (0->X.%getByte)//1 then 'a'->put else '!'->put if);
       (* Above line tos_converted from: (if X->TOS'%getByte[0]'//1 then 'a'->put else '!'->put if); *)
       @@X->byteSwapLong;
       (if (0->X.%getByte)//4 then 'b'->put else '!'->put if);
       (* Above line tos_converted from: (if X->TOS'%getByte[0]'//4 then 'b'->put else '!'->put if); *)
       @@X->byteSwapShort;
       (if (0->X.%getByte)//3 then 'c'->put else '!'->put if);
       (* Above line tos_converted from: (if X->TOS'%getByte[0]'//3 then 'c'->put else '!'->put if); *)
    else
       'I am small'->putline;
       (if (0->X.%getByte)//4 then 'a'->put else '!'->put if);
       (* Above line tos_converted from: (if X->TOS'%getByte[0]'//4 then 'a'->put else '!'->put if); *)
       @@X->byteSwapLong;
       (if (0->X.%getByte)//1 then 'b'->put else '!'->put if);
       (* Above line tos_converted from: (if X->TOS'%getByte[0]'//1 then 'b'->put else '!'->put if); *)
       @@X->byteSwapShort;
       (if (0->X.%getByte)//2 then 'c'->put else '!'->put if);
       (* Above line tos_converted from: (if X->TOS'%getByte[0]'//2 then 'c'->put else '!'->put if); *)

   if);
   '\n\nLinear byte sequence:\n'->puttext;
   (for i: R.range*4 repeat 
        ('a'-1+i, i-1) -> R.%putByte 
        (* Above line tos_converted from: (R,i-1,'a'-1+i)->TOS'%inxPutByte' *)
   for);
   (for I: R.range repeat 
        (0->R[i].%getByte)->put;
        (* Above line tos_converted from: R[i]->TOS'%getByte[0]'->put; *)
        (1->R[i].%getByte)->put;
        (* Above line tos_converted from: R[i]->TOS'%getByte[1]'->put; *)
        (2->R[i].%getByte)->put;
        (* Above line tos_converted from: R[i]->TOS'%getByte[2]'->put; *)
        (3->R[i].%getByte)->put;   
        (* Above line tos_converted from: R[i]->TOS'%getByte[3]'->put; *)
        newline
   for);
   '\nByte sequence swapped pr. long:\n'->puttext;
   (for i: R.range repeat
        @@R[i]->byteSwapLong
   for);
   (for I: R.range repeat 
        (0->R[i].%getByte)->put;
        (* Above line tos_converted from: R[i]->TOS'%getByte[0]'->put; *)
        (1->R[i].%getByte)->put;
        (* Above line tos_converted from: R[i]->TOS'%getByte[1]'->put; *)
        (2->R[i].%getByte)->put;
        (* Above line tos_converted from: R[i]->TOS'%getByte[2]'->put; *)
        (3->R[i].%getByte)->put;   
        (* Above line tos_converted from: R[i]->TOS'%getByte[3]'->put; *)
        newline
   for);
   '\nByte sequence swapped pr. second short:\n'->puttext;
   (for i: R.range repeat 
        @@R[i]->byteSwapShort
   for);
   (for I: R.range repeat 
        (0->R[i].%getByte)->put;
        (* Above line tos_converted from: R[i]->TOS'%getByte[0]'->put; *)
        (1->R[i].%getByte)->put;
        (* Above line tos_converted from: R[i]->TOS'%getByte[1]'->put; *)
        (2->R[i].%getByte)->put;
        (* Above line tos_converted from: R[i]->TOS'%getByte[2]'->put; *)
        (3->R[i].%getByte)->put;   
        (* Above line tos_converted from: R[i]->TOS'%getByte[3]'->put; *)
        newline
   for);

   (* R[2] =  e + f + g + h ->
    *         h + g + f + e ->
    *         g + h + f + e
    *)
   (if isLittleEndian//true then
       (if R[2]// 'e'*256*256*256 + 'f'*256*256 + 'h'*256 + 'g' then
           '\nOK:'->puttext
        else '\nNON OK:'->puttext
       if);
       'I am still small'->putline
    else
       (if R[2]// 'g'*256*256*256 + 'h'*256*256 + 'f'*256 + 'e' then
           'OK:'->puttext
        else '\nNON OK:'->puttext
       if);
       '\nI am still BIG'->putline       
   if)
#)
