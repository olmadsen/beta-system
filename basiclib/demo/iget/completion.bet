ORIGIN '~beta/basiclib/v1.6/iget';
(* Program showing how to program a getline from the
 * keyboard with TAB-completion (case insensitive) among a set of strings.
 * The completion routine could use regexp instead, and
 * the completion possibilities could also, e.g. be 
 * a directory listing.
 *)
--program: descriptor--
(# GetName: @GetLineWithCompletion
     (# possibilities::
          (# 
          do 'David'     -> add;
             'Dave'      -> add;
             'spider'    -> add;
             'Spiderman' -> add;
             'Carl'      -> add;
             'Carla'     -> add;
             'Madonna'   -> add;
             'Sean'      -> add;
          #)
     #);
   answer: ^text;          
do 'Enter name: '->puttext;
   GetName -> answer[];
   '\nYou gave me '''->puttext;
   answer[] -> puttext;
   '''.'->putline;
#)
       
       
--LIB: attributes--
GetLineWithCompletion:
  (# input: ^text;
     completers: [1]^text;
     ch: @char;
     numcompleters: @integer;
     possibilities:<
       (# 
          add:
            (# p: ^text;
            enter p[]
            do numcompleters+1->numcompleters;
               (if numcompleters>completers.range then
                   completers.range -> completers.extend;
               if);
               p[] -> completers[numcompleters][];
            #);
       do INNER;
       #);
     erase:
       (# 
       do ascii.bs -> put;
          ' '      -> put;
          ascii.bs -> put;
       #);
     nummatches, lastnummatches: @integer;
     casematch, lastcasematch: @boolean;
     candidate, lastmatchingcompleter, maxmatch: ^text;
  do possibilities;
     &text[] -> input[];
     loop:
     (# 
     do iget -> ch;
        (if ch
         // ascii.nl
         // ascii.cr then 
            ch -> put;
            leave loop;
         // ascii.del
         // ascii.bs then
            (if input.length>0 then
                (input.length,input.length) -> input.delete;
                erase;
            if);
         // ascii.ht then
            (* complete *)
            NONE -> maxmatch[];
            input.copy -> candidate[];
            0 -> lastnummatches -> nummatches;
            false -> casematch -> lastcasematch;
            findmatches:
              (# sub: ^text;
              do nummatches -> lastnummatches;
                 casematch -> lastcasematch;
                 0 -> nummatches;
                 false -> casematch;
                 NONE -> lastmatchingcompleter[];
                 (for i:numcompleters repeat
                      (if (candidate.length<=completers[i].length) and
                          ((1,candidate.length) -> completers[i].sub 
                            -> sub[] -> candidate.equalNCS) then
                          nummatches+1 -> nummatches;
                          (* Check if completer[i] has same case in 
                           * candidate prefix as lastmatchingcompleter
                           *)
                          (if nummatches=1 then true -> casematch; else
                              casematch and 
                              ((1,candidate.length) -> lastmatchingcompleter.sub -> sub.equal)
                                -> casematch;
                          if);
                          completers[i][]->lastmatchingcompleter[];
                      if)
                 for);
                 (if nummatches<lastnummatches then
                     (* the last candidate reduced the number of matches *)
                     (* We stop at the common prefix *)
                     lastcasematch -> casematch;
                     leave findmatches;
                 if);
                 (if nummatches>0 then
                     (if nummatches=1 then
                         lastmatchingcompleter[] -> maxmatch[];
                         leave findmatches;
                     if);
                     (* More that one possible match, try one more letter from the last *)
                     candidate.copy -> maxmatch[];
                     candidate.length+1 -> lastmatchingcompleter.inxGet -> candidate.put;
                     restart findmatches;
                 if)
              #);
            (if maxmatch[]<>NONE then
                (if casematch then
                    (* all candidates have same case: adjust to the actual case *)
                    (1,maxmatch.length) -> lastmatchingcompleter.sub -> maxmatch[];
                if);
                (for input.length repeat erase for);
                maxmatch.copy -> input[] -> screen.puttext;
            if);
         else
            ch -> input.put;
            ch -> put;
        if);
        restart loop;
     #);
  exit input[]
  #)
     
     
     
     
                            
