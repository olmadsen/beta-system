ORIGIN '~beta/basiclib/v1.4/betaenv';
-- INCLUDE 'Xrecordlib'
--- PROGRAM: DescriptorForm ---
(#
   (* This fragment is an example of using virtual patterns in BETA.  
    * The following classification hierarchy is defined in the  
    * library fragment 'recordlib'  
    * 1.  Record  
    * 2.  Person  
    * 3. Employee  
    * 3. Student  
    * 2. Book  
    * Record has a virtual (procedure) pattern:  
    * Display, that displays the attributes of a record.  
    * Display is further bound in the sub-patterns.  
    * The patterns NewRecord, NewPerson, etc may be used for  
    * generating new instances of the record-patterns.  
    * The pattern Register has two virtual attributes:  
    * regCat:< record, the elements in the register.  
    * Display, that displays the elements of the register.  
    *   
    * In this application two instances of Register are generated:  
    * Greg is a general register where regCat is not further bound  
    * Ereg is an employee register where only Emplyoee-records may  
    * be inserted  
    
    *** The following are declaring a number of reference variables ****)
   Birger,Lotte,PeterA,LarsB,ClausN,ElmerS,KimJ: ^Person;
   Bible: ^Book;
   Greg: @Register;
   Ereg: (* Greg is a general register for all types of Records *)
     @Register(* Ereg is a specific register only for Employee records
               (and subpatterns of Employee) *)
     (#
        RegCat::< Employee;
        Display::<
         (* a further binding of RegCat to restrict to
          Employee *) (# do '/Employee '->s.putText; INNER #);
     #);
do (* the following creates and instantiates a number of Record objects *)
   (0,'Bimmer Moller-Pedersen','Unknown',- 200,'Piccolo')->NewEmployee
     ->Birger[];
   (1,'Peter Andersen','male','missing M.D.')->NewStudent->peterA[];
   (2,'Lars Bak','male',1000000,'Garbage collector')->NewEmployee->LarsB[];
   (3,'Claus Norgaard','male',1000010,'Senior Coder')->NewEmployee->ClausN[];
   (4,'Elmer Sandvad','male',1000050,'Senior Supporter')->NewEmployee->ElmerS[];
   (5,'Kim Jensen M|ller','male',999990,'Painter')->NewEmployee->KimJ[];
   (6,'Lotte Guldbrandsen','female',6,'support')->NewEmployee->Lotte[];
   (9,'Kristensen et al.',
    'Object Oriented Programming in the BETA programming language')->NewBook
     ->Bible[];
   peterA[]->Lotte.spouse[];
   Lotte[]->peterA.spouse[];
   ;
   screen[]
     ->
       (* the following displayes the Birger, PeterA and Bible objects on the
        * screen *)Birger.Display;
   screen[]->(* not a nice view (: -) *)PeterA.Display;
   screen[]->Bible.Display;
   '==========================='->putLine;
   Greg.init;
   Ereg.init;
   Birger[]
     ->(*inserts all Record objects in the Greg and/or Ereg registers *)Greg.insert;
   Bible[]->Greg.insert;
   PeterA[]->Greg.insert;
   ClausN[]->Ereg.insert;
   LarsB[]->Ereg.insert;
   ElmerS[]->Ereg.insert;
   KimJ[]->Ereg.insert;
   screen[]
     ->(* displays the Greg and Ereg registers on the screen *)Greg.display;
   screen[]->Ereg.display;
   (if (LarsB[]->Ereg.has)(* test if LarsB is in the Ereg register *)
    // true then
       'LarsB in employee register'->putLine
    // false then
       'LarsB not in employee register'->putLine
   if);
   (if (LarsB[]->Greg.has)(* test if LarsB is in the Greg register *)
    // true then
       'LarsB in general register'->putLine
    // false then
       'LarsB not in general register'->putLine
   if);
#)
