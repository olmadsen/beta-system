ORIGIN '~beta/basiclib/v1.4/betaenv';
--- lib: Attributes ---
Record:
  (#
     (* Record objects contain two attributes: key and Display.  Key contains
      * the ID of this record (supplied by the programmar).  Display is a
      * virtual, enabling printing Records on the screen
      *)
     Key: @integer;
     Display:< (* declaration of a virtual (procedure) pattern  *)
       (# s: ^stream(* the input parameter is where to display this record *)
       enter s[]
       do
          s.newline;
          '-------------------'->s.putLine;
          'Record: Key      = '->s.putText;
          Key->s.putInt;
          s.newline;
          INNER
       #);
  #);
Person: Record
  (#
     (* Person is a suppattern of Record, declaring two additional attributes: 
      * Name and Sex.  Furthermore Display (inherited form Record) is extended
      * to print the Name and Sex attributes as well as the Key attribute.
      *)
     Name,Sex: @text;
     spouse: ^Person;
     Display::< (* a further binding of Display from Record *) 
       (#
       do
          'Person: Name     = '->s.putText;
          Name[]->s.putLine;
          '             Sex = '->s.putText;
          Sex[]->s.putLine;
          INNER
       #);
  #);
Employee: Person
  (# (* analog til Person *)
     Salary: @integer;
     Position: @text;
     Display::< 
       (#
       do
          'Employee: Salary   = '->s.putText;
          salary->s.putInt;
          s.newline;
          '          Position = '->s.putText;
          Position[]->s.putLine;
          INNER
       #);
  #);
Student: Person
  (# (* analog til Person *)
     Status: @text;
     Display::< 
       (#
       do 'Student: Status   = '->s.putText; Status[]->s.putLine; INNER
       #)
  #);
Book: Record
  (# (* analog til Person *)
     Author,Title: @text;
     Display::< 
       (#
       do
          'Book: Author   = '->s.putText;
          Author[]->s.putLine;
          '         Title = '->s.putText;
          Title[]->s.putLine;
          INNER
       #)
  #);
doc0: (*** Temporary initialization ***) (# #);
NewRecord: (* creation and initialization procedure for Record objects *)
  (# RegCat:< Record; Rec: ^RegCat; K: @integer; R: ^Record
  enter K
  do &RegCat[]->Rec[]; K->Rec.Key; INNER ; Rec[]->R[]
  exit R[]
  #);
NewPerson:
 NewRecord(* creation and initialization procedure for Person objects *)
  (# RegCat::< Person; N,S: @text
  enter (N,S)
  do N->Rec.Name; S->Rec.Sex; INNER ;
  #);
NewEmployee:
 NewPerson(* creation and initialization procedure for Employee objects *)
  (# RegCat::< Employee; S: @integer; P: @text
  enter (S,P)
  do S->Rec.Salary; P->Rec.Position; INNER ;
  #);
NewStudent:
 NewPerson(* creation and initialization procedure for Student objects *)
  (# RegCat::< Student; S: @text enter S do S->Rec.Status; INNER ; #);
NewBook: NewRecord(* creation and initialization procedure for Book objects *)
  (# RegCat::< Book; A,T: @text
  enter (A,T)
  do A->Rec.Author; T->Rec.Title; INNER ;
  #);
Register:
 (* This is a declaration of a register pattern.  Register objects will be able
  * to contain Records (or instances of suntarrerns of Record.
  *)
  (# (* Register *)
     regCat:< Record;
     regLst(* private pattern *):
      (* specifying the category of objects allowed in this
       register *) (# succ: ^regLst; elm: ^regCat #);
     head: ^regLst;
     init: (* private data *) (# do none ->head[] #);
     scan:
      (* walks through the register, executing INNIR for each element in the
       * register.  P will refer to the current element in the register.
       *)
       (# elm: ^regCat; p: ^regLst
       do
          head[]->P[];
          search :
          (if (P[] = none )
           // false then
              P.elm[]->elm[]; INNER ; P.succ[]->P[]; restart search
          if)
       #);
     Display:<
      (* display the entire register by printing header and trailer text,
       * and scanning the entire register in between, invoking display on
       * each element in the register.
       *)
       (# s: ^stream
       enter s[]
       do
          s.newline;
          '############ Register Display '->s.putText;
          INNER ;
          s.newline;
          scan
            (# do s[]->elm.display #);
          '############ End Register Display #######'->s.putLine
       #);
     Has:
      (* takes an object reference, and checks whether that object is in the
       * register
       *)
       (# E: ^regCat; found: @boolean;
       enter E[]
       do
          false->found;
          search : scan
            (#
            do (if E.key // elm.key then true->found; leave search if)
            #)
       exit found
       #);
     Insert:
      (* Takes an object reference and inserts that object in the register
       * (if not already in the register)
       *)
       (# E: ^regCat; P: ^regLst
       enter E[]
       do
          (if (E[]->Has)
           // false then
              &regLst[]->P[]; head[]->P.succ[]; E[]->P.elm[]; P[]->head[]
          if);
       #);
  #)  

