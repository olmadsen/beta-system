ORIGIN '~beta/basiclib/pcre';
INCLUDE '~beta/basiclib/formatio';
INCLUDE '~beta/containers/list';
--- program: descriptor ---
(#
   after: ^Text;
   tt: ^Text;
   success: @Boolean;
   regex: @Pcre;
   simpleMatch:
   (#
      cr: @Pcre;
      re: ^Text;
      sub: ^Text;
    enter (re[], sub[])
    do
       re[] -> cr;
       (if sub[] -> cr.match then
          '\'%s\' is matched by \'%s\'\n' ->
	     putFormat (# do re[] -> s; sub[] -> s; #);
       else
          '\'%s\' is not matched by \'%s\'\n' ->
	     putFormat (# do re[] -> s; sub[] -> s; #);
       if);
   #);
do ('^([a-zA-Z])[a-zA-Z_0-9]+$', 'p9') -> simpleMatch;
   ('^([a-zA-Z])[a-zA-Z_0-9]+$', 'This_is_a_variable_name_2') -> simpleMatch;
   ('^([a-zA-Z])[a-zA-Z_0-9]+$', '9p') -> simpleMatch;
   ('^([a-zA-Z])[a-zA-Z_0-9]+$', 'p 9') -> simpleMatch;
   'Wer der Philosophie Wissenschaftlichkeit im Sinne rationeller\nund argumentativ geschlossener Diskursivität abverlangt,\nwird die Frage, ob denn nun Dichter Philosophen seien, in\nletzter Instanz verneinen müssen.' -> tt[];
   '***Test text: \n%s\n' -> putFormat (# do tt[] -> s #);
   '[A-Z]' -> regex;
   '**First capital letter' -> putline;
   tt[] -> regex.match (# do 'Match \'%s\' (position %d-%d)\n' ->
                             putFormat (# do matchText -> s;
					     matchPos -> (d, d);
				       #);
		       #);
   '**First capital letter after position 10 in text' -> putline;
   tt[] -> regex.match (#    position:: (# do 10 -> p #);
                          do 'Match \'%s\' (position %d-%d)\n' ->
                             putFormat (# do matchText -> s;
					     matchPos -> (d, d);
				       #);
		       #);
   '**First capital letter after position 9 in text' -> putline;
   tt[] -> regex.match (#    position:: (# do 9 -> p #);
                          do 'Match \'%s\' (position %d-%d)\n' ->
                             putFormat (# do matchText -> s;
					     matchPos -> (d, d);
				       #);
		       #);
   '**All the capital letters in text' -> putline;
   tt[] -> regex.matchAll (#
                             do matchText -> putText;
		          #);
   putLine;
   '[aeiouäöü]{2,}' -> regex;
   '**First set of consecutive vowels' -> putline;
   tt[] -> regex.match (# do 'Match \'%s\' (position %d-%d)\n' ->
                             putFormat (# do matchText -> s;
					     matchPos -> (d, d);
				       #);
		       #);
   '**Job change' -> putline;
   (tt[], 'Informatiker') -> ('Dichter' -> Pcre).replace -> (success, after[]);
   after[] -> putLine;
   '**Childrens song version' -> putline;
   '[aäeioöuü]' -> regex;
   (tt[], 'i') -> ('[aäeioöuü]' -> Pcre).replaceAll -> (success, after[]);
   after[] -> putLine;
   '**Case insensitive and case preserving childrens song version' -> putline;
   '[AÄEIOÖUÜaäeioöuü]' -> regex;
   (tt[], 'i') -> regex.replaceAll (# rep:: (#
      do
         (if (matchtext).T[1] -> ascii.isupper then
             'A' -> r[];
         else
             'a' -> r[];
         if);
      #);
   #) -> (success, after[]);
   after[] -> putLine;
   '**Words' -> putline;
   '[ \\n,.]+' -> regex;
   tt[] -> regex.matchAll (# split:: (# do splitText -> putLine; #); #);
   '> Kan du spesifisere hva du mener med "naturtalent"/egnet?\n'
   '\n'
   'Thore kan sikkert det på egenhånd, men jeg pleier å si at bugs\n'
   'er hint fra maskinen til mennesket om at mennesket ikke har skjønt\n'
   'maskinen.  Et naturtalent av en programmerer skjønner maskinen.  En\n'
   'programmerer som sliter med bugs i månedsvis, burde ta et hint.' -> tt[];
   '***Test text: \n%s\n' -> putFormat (# do tt[] -> s #);
   '**HTMLise' -> putline;
   '[\n<>&]|[^ -~]' -> regex;
   (tt[], '') -> regex.replaceAll
   (#
      rep::
      (#
         mat: ^Text;
      do
         matchText -> mat[];
	 (if mat.T[1]
	     // '>' then '&gt;' -> r[];
	     // '<' then '&lt;' -> r[];
	     // '&' then '&amp;' -> r[];
	     // '\n' then '<br>\n' -> r[];
	 else
	    '' -> r[];
	    '&#%02x;' -> r.putformat (# do mat.T[1] -> x; #);
	 if);
       #);
    #) -> (success, after[]);
   after[] -> putLine;
   'root:x:0:0:root:/root:/bin/bash' -> tt[];
   '***Test text: \n%s\n' -> putFormat (# do tt[] -> s #);
   ':' -> regex;
   '**Split /etc/passwd entry into fields, put in a list, dump list' ->
        putLine;
   (# fieldlist: @list (# element :: Text #);
      name: ^Text;
      hash: ^Text;
      uid: ^Text;
      gid: ^Text;
      gecos: ^Text;
      home: ^Text;
      shell: ^Text;
   do tt[] -> regex.matchAll
      (#
      split:: (# do splitText -> fieldlist.append; #);
      #);
      fieldlist.scan (# do current[] -> putLine; #);
      '**Split /etc/passwd entry into named fields' -> putLine;
      tt[] -> regex.matchAll
      (#
         post::
	 (#
	 do ways7 -> (name[], hash[], uid[], gid[], gecos[], home[], shell[]);
	    (if matches <> 6 then 'Error parsing passwd line' -> putLine if);
	 #);
      #);
      'User name is %s, hashed password is %s, uid/gid is %s/%s\n' -> putFormat
      (#
      do name[] -> s; hash[] -> s; uid[] -> s; gid[] -> s;
      #);
      'Real name is \'%s\', home directory is %s, shell is "%s"\n' -> putFormat
      (#
      do gecos[] -> s; home[] -> s; shell[] -> s;
      #);
   #);
   (#
      nameSplit: @Pcre;
      stripFinalSpace: @Pcre;
      vonUndZu: @Pcre;
      senname: @Pcre;
      (* Use extended regexp syntax /x format in order to embed comments *)
      (* Note that to get a \ in the regexp you need \\ in the beta code *)
   do '(?x)                                  #  Extended regexp syntax   \n'
      '(?i)                                  #  Case independent pattern \n'
      '^                                     #  Start of name            \n'
      '(([a-z]+\\s+)+?)                      #  First names (not greedy) \n'
      '(([a-z]+)\\s+)?                       #  Middle name              \n'
      '([a-z]+)                              #  Surname                  \n'
      '$                                     #  End of name              \n'
           -> nameSplit;
      '^(.*?)\\s*$' -> stripFinalSpace;
      '^von|zu|van|de|del|da$' -> vonUndZu;
      'sen$' -> senName;
      'Lars  Balker Rasmussen\n'
      'Erik Haldane  Corry\n'
      'Flemming Gram  Christensen\n'
      'Mick Jagger\n'
      'Peter da Silva\n'
      'Lars von Trier\n'
      'Georg Jensen\n'
      'Jeeves\n'
      'William Jefferson Clinton' -> tt[];
      '***Test text: \n%s\n' -> putFormat (# do tt[] -> s #);
      '**Recognise given and surnames' -> putLine;
      tt[] -> ('\\s*\n\\s*' -> Pcre).matchAll
      (#
         split::   (* for each line in input *)
         (#
         do splitText -> nameSplit.match
            (# givenname: ^Text;
	       middlename: ^Text;
	       surname: ^Text;
	       noMatch::
	       (#
	       do '"%s"\n' -> putFormat (# do subject[] -> s #);
	       #);
	    do sub1 -> stripFinalSpace.match (# do sub1 -> givenname[] #);
	       sub4 -> middlename[];
	       sub5 -> surname[];
	       (if (middlename[] -> vonUndZu.match) or
	           ((surname[] -> senname.match) and
		    (middlename.lgth <> 0)) then
                   '"%s %s, %s"\n' -> putFormat
		   (#
		   do middlename[] -> s; surname[] -> s; givenname[] -> s;
		   #);
	       else
	           (if middlename.lgth <> 0 then
                       '"%s, %s %s"\n' -> putFormat
		       (#
		       do surname[] -> s; givenname[] -> s; middlename[] -> s;
		       #);
		   else
                       '"%s, %s"\n' -> putFormat
		       (#
		       do surname[] -> s; givenname[] -> s;
		       #);
		   if);
	       if);
	    #)
         #)
      #);
  #);
#)
