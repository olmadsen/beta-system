ORIGIN '~beta/basiclib/pcre';
INCLUDE '~beta/basiclib/formatio';
INCLUDE '~beta/containers/list';
--- program: descriptor ---
(#
   after: ^Text;
   tt: ^Text;
   success: @Boolean;
   regex: @Pcre;
   simpleMatch:
   (#
      cr: @Pcre;
      re: ^Text;
      sub: ^Text;
    enter (re[], sub[])
    do
       re[] -> cr;
       (if sub[] -> cr.match then
          '\'%s\' is matched by \'%s\'\n' ->
	     putFormat (# do re[] -> s; sub[] -> s; #);
       else
          '\'%s\' is not matched by \'%s\'\n' ->
	     putFormat (# do re[] -> s; sub[] -> s; #);
       if);
   #);
do ('^([a-zA-Z])[a-zA-Z_0-9]+$', 'p9') -> simpleMatch;
   ('^([a-zA-Z])[a-zA-Z_0-9]+$', 'This_is_a_variable_name_2') -> simpleMatch;
   ('^([a-zA-Z])[a-zA-Z_0-9]+$', '9p') -> simpleMatch;
   ('^([a-zA-Z])[a-zA-Z_0-9]+$', 'p 9') -> simpleMatch;
   'Wer der Philosophie Wissenschaftlichkeit im Sinne rationeller\nund argumentativ geschlossener Diskursivität abverlangt,\nwird die Frage, ob denn nun Dichter Philosophen seien, in\nletzter Instanz verneinen müssen.' -> tt[];
   '***Test text: \n%s\n' -> putFormat (# do tt[] -> s #);
   '[A-Z]' -> regex;
   '**First capital letter' -> putline;
   tt[] -> regex.match (# do 'Match \'%s\' (position %d-%d)\n' ->
                             putFormat (# do matchText -> s;
					     matchPos -> (d, d);
				       #);
		       #);
   '**First capital letter after position 10 in text' -> putline;
   tt[] -> regex.match (#    position:: (# do 10 -> value #);
                          do 'Match \'%s\' (position %d-%d)\n' ->
                             putFormat (# do matchText -> s;
					     matchPos -> (d, d);
				       #);
		       #);
   '**First capital letter after position 9 in text' -> putline;
   tt[] -> regex.match (#    position:: (# do 9 -> value #);
                          do 'Match \'%s\' (position %d-%d)\n' ->
                             putFormat (# do matchText -> s;
					     matchPos -> (d, d);
				       #);
		       #);
   '**All the capital letters in text' -> putline;
   tt[] -> regex.matchAll (#
                             do matchText -> putText;
		          #);
   putLine;
   '[aeiouäöü]{2,}' -> regex;
   '**First set of consecutive vowels' -> putline;
   tt[] -> regex.match (# do 'Match \'%s\' (position %d-%d)\n' ->
                             putFormat (# do matchText -> s;
					     matchPos -> (d, d);
				       #);
		       #);
   '**Job change' -> putline;
   (tt[], 'Informatiker') -> ('Dichter' -> Pcre).replace -> (success, after[]);
   after[] -> putLine;
   '**Childrens song version' -> putline;
   '[aäeioöuü]' -> regex;
   (tt[], 'i') -> ('[aäeioöuü]' -> Pcre).replaceAll -> (success, after[]);
   after[] -> putLine;
   '**Case insensitive and case preserving childrens song version' -> putline;
   '[AÄEIOÖUÜaäeioöuü]' -> regex;
   (tt[], 'i') -> regex.replaceAll (# rep:: (#
      do
         (if (matchtext).T[1] -> ascii.isupper then
             'A' -> value[];
         else
             'a' -> value[];
         if);
      #);
   #) -> (success, after[]);
   after[] -> putLine;
   '**Words' -> putline;
   '[ \\n,.]+' -> regex;
   tt[] -> regex.matchAll (# split:: (# do splitText -> putLine; #); #);
   '> Kan du spesifisere hva du mener med "naturtalent"/egnet?\n'
   '\n'
   'Thore kan sikkert det på egenhånd, men jeg pleier å si at\n'
   'bugs er hint fra maskinen til mennesket om at mennesket ikke\n'
   'har skjønt maskinen.  Et naturtalent av en programmerer\n'
   'skjønner maskinen.  En programmerer som sliter med bugs i\n'
   'månedsvis, burde ta et hint.' -> tt[];
   '***Test text: \n%s\n' -> putFormat (# do tt[] -> s #);
   '**HTMLise' -> putline;
   '[\n<>&]|[^ -~]' -> regex;
   (tt[], '') -> regex.replaceAll
   (#
      rep::
      (#
         mat: ^Text;
      do
         matchText -> mat[];
	 (if mat.T[1]
	     // '>' then '&gt;' -> value[];
	     // '<' then '&lt;' -> value[];
	     // '&' then '&amp;' -> value[];
	     // '\n' then '<br>\n' -> value[];
	 else
	    '' -> value[];
	    '&#%d;' -> value.putFormat (# do mat.T[1] -> d; #);
	 if);
       #);
    #) -> (success, after[]);
   after[] -> putLine;
   'root:x:0:0:Da Boss:/root:/bin/bash' -> tt[];
   '***Test text: \n%s\n' -> putFormat (# do tt[] -> s #);
   ':' -> regex;
   '**Split /etc/passwd entry into fields, put in a list, dump list' ->
        putLine;
   (# fieldlist: @list (# element :: Text #);
      name: ^Text;
      hash: ^Text;
      uid: ^Text;
      gid: ^Text;
      gecos: ^Text;
      home: ^Text;
      shell: ^Text;
   do tt[] -> regex.matchAll
      (#
      split:: (# do splitText -> fieldlist.append; #);
      #);
      fieldlist.scan (# do current[] -> putLine; #);
      '**Split /etc/passwd entry into named fields' -> putLine;
      tt[] -> regex.matchAll
      (#
         post::
	 (#
	 do ways7 -> (name[], hash[], uid[], gid[], gecos[], home[], shell[]);
	    (if matches <> 6 then 'Error parsing passwd line' -> putLine if);
	 #);
      #);
      'User name is %s, hashed password is %s, uid/gid is %s/%s\n' -> putFormat
      (#
      do name[] -> s; hash[] -> s; uid[] -> s; gid[] -> s;
      #);
      'Real name is \'%s\', home directory is %s, shell is "%s"\n' -> putFormat
      (#
      do gecos[] -> s; home[] -> s; shell[] -> s;
      #);
   #);

   (*
    * Compex example using subpatterns.  We have two options here, the
    * expression is caseless and also written in extended syntax.  For
    * illustrative purposes the CASELESS option is done with the options
    * method, while the extended syntax is specified with an embedded
    * ASCII string.
    * Note that the comments in the regular expression in the extended
    * syntax are started by # and ended by a newline
    *)
   (#
      nameSplit: @Pcre (# options:: (# do CASELESS #) #);
      stripFinalSpace: @Pcre;
      vonUndZu: @Pcre;
      senname: @Pcre;
      (* Use extended regexp syntax /x format in order to embed comments *)
      (* Note that to get a \ in the regexp you need \\ in the beta code *)
   do '(?x)                                  #  Extended regexp syntax   \n'
      '^                                     #  Start of name            \n'
      '(([a-z]+\\s+)+?)                      #  First names (not greedy) \n'
      '(([a-z]+)\\s+)?                       #  Middle name              \n'
      '([a-z]+)                              #  Surname                  \n'
      '$                                     #  End of name              \n'
           -> nameSplit;
      '^(.*?)\\s*$' -> stripFinalSpace;
      '^von|zu|van|de|del|da$' -> vonUndZu;
      'sen$' -> senName;
      'Lars  Balker Rasmussen\n'
      'Erik Haldane  Corry\n'
      'Flemming Gram  Christensen\n'
      'Mick Jagger\n'
      'Peter da Silva\n'
      'Lars von Trier\n'
      'Georg Jensen\n'
      'Jeeves\n'
      'William Jefferson Clinton' -> tt[];
      '***Test text: \n%s\n' -> putFormat (# do tt[] -> s #);
      '**Recognise given and surnames' -> putLine;
      tt[] -> ('\\s*\n\\s*' -> Pcre).matchAll
      (#
         split::   (* for each line in input *)
         (#
         do splitText -> nameSplit.match
            (# givenname: ^Text;
	       middlename: ^Text;
	       surname: ^Text;
	       noMatch::
	       (#
	       do '"%s"\n' -> putFormat (# do subject[] -> s #);
	       #);
	    do sub1 -> stripFinalSpace.match (# do sub1 -> givenname[] #);
	       sub4 -> middlename[];
	       sub5 -> surname[];
	       (if (middlename[] -> vonUndZu.match) or
	           ((surname[] -> senname.match) and
		    (middlename.lgth <> 0)) then
                   '"%s %s, %s"\n' -> putFormat
		   (#
		   do middlename[] -> s; surname[] -> s; givenname[] -> s;
		   #);
	       else
	           (if middlename.lgth <> 0 then
                       '"%s, %s %s"\n' -> putFormat
		       (#
		       do surname[] -> s; givenname[] -> s; middlename[] -> s;
		       #);
		   else
                       '"%s, %s"\n' -> putFormat
		       (#
		       do surname[] -> s; givenname[] -> s;
		       #);
		   if);
	       if);
	    #)
         #)
      #);
  #);
#)
