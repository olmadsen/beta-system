ORIGIN 'betaenv';
BODY 'private/substreamsbody'
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1995-96
 *       All rights reserved.
 *
 * This fragment implements a substream and a subtext pattern
 * The operations of substream and subtext are essentially the same
 * as the operations on stream, respectively, text.  See these patterns
 * in betaenv for a description of the semantics of the operations.
 *)
--- lib: attributes ---
substream: stream
  (# <<SLOT substreamLib: attributes>>;
     streamType:< stream;
     stm: (* the attached stream *) ^streamType;
     high, low: @integer;
     init:
       (#
       enter (stm[], low, high)
       do check
       #);
     attach:
       (# enter stm[] #);
     range:
       (#
       enter (low,high)
       do check; high-low+1->lgth
       exit (low,high)
       #);
     check:
       (#
       do (if true
           // stm[]=NONE then notAttachedError
           // low>high then illegalRangeError
           // low<0 then illegalRangeError
           // low>stm.length then illegalRangeError
           // high>stm.length then illegalRangeError
          if)
       #);
     length::<
       (# <<SLOT substreamLength: dopart>> #);
     eos::<
       (# <<SLOT substreamEos: dopart>> #);
     empty: booleanValue
       (# <<SLOT substreamEmpty: dopart>> #);
     copy:
       (# theCopy: ^substream;
          copyI: @<<SLOT substreamCopy: descriptor>>
       do copyI
       exit theCopy[]
       #);
     notAttachedError:< StreamException
       (* Raised when this(substream) is not attached to any stream.
        * Message: "The substream is not attached to any stream!".
        *)
       (# <<SLOT substreamNotAttachedError: dopart>> #);
     illegalRangeError:< StreamException
       (* Raised when the substream range specified does not lie
        * within the range of the attached stream.  Message: "The
        * substream range is not within the attached stream range!".
        *)
       (# <<SLOT substreamIllegalRangeError: dopart>> #);
     indexError:< StreamException
       (* Raised when the index goes outside the range of the
        * substream.  Message: "Index error in stream! (index <num>)".
        *)
       (# inx: @integer
       enter inx <<SLOT substreamIndexError: dopart>>
       #);
     EOSerror::<
       (* Raised from Get and Peek when the end of the substream is
        * passed.
        *)
       (# <<SLOT substreamEOSerror: dopart>> #);
     otherError::<
       (* Raised when an error other than the Index-/EOSerror occurs.
        *)
       (# <<SLOT substreamOtherError: dopart>> #);
     setpos::<
       (# <<SLOT substreamSetpos: dopart>> #);
     getpos::<
       (# <<SLOT substreamGetpos: dopart>> #);
     pos, lgth: (* private *) @integer;
  enter (attach,range)
  #);

subtext: substream
  (# <<SLOT subtextLib: attributes>>;
     streamType::< text;
     put::<
       (# <<SLOT substreamPut: dopart>> #);
     putText::<
       (# <<SLOT substreamPutText: dopart>> #);
     get::<
       (# <<SLOT substreamGet: dopart>> #);
     getAtom::<
       (# <<SLOT substreamGetAtom: dopart>> #);
     getLine::<
       (# <<SLOT substreamGetLine: dopart>> #);
     peek::<
       (# <<SLOT substreamPeek: dopart>> #);
     clear:
       (# <<SLOT substreamClear: dopart>> #);
     inxGet: charValue
       (# i: @integer
       enter i
       <<SLOT substreamInxget: dopart>>
       #);
     inxPut:
       (# ch: @char; i: @integer
       enter (ch,i)
       <<SLOT substreamInxput: dopart>>
       #);
     append:
       (# S1: ^streamType; S1lgt: @integer
       enter S1[]
       <<SLOT substreamAppend: dopart>>
       #);
     prepend:
       (# S1: ^streamType; S1lgt: @integer
       enter S1[]
       <<SLOT substreamPrepend: dopart>>
       #);
     scanAll:
       (# ch: @char
       <<SLOT substreamScanAll: dopart>>
       #);
     sub: 
       (# i,j: @integer
       enter (i,j)
       exit (i,j)->stm.sub
       #);
     insert:
       (# T1: ^streamType;
          inx: @integer;
          P: @integer
       enter (T1[],inx)
       <<SLOT substreamInsert: dopart>>
       #);
     delete:
       (# i,j: @integer
       enter (i,j)
       <<SLOT substreamDelete: dopart>>
       #);
     equal: booleanValue
       (# S1: ^streamType;
          S1pos, lgt: @integer;
          NCS:< booleanObject
       enter S1[]
       <<SLOT substreamEqual: dopart>>
       #);
     equalNCS: equal
       (* As 'equal', except the the comparison will be done Non
        * Case Sensitive
        *)
       (# NCS:: trueObject #);
     less: booleanValue
       (# S1: ^streamType;
          S1pos, lgt: @integer; ch, ch1: @char
       enter S1[]     
       <<SLOT substreamLess: dopart>>
       #);
     greater: booleanValue
       (# S1: ^streamType;
          S1pos, lgt: @integer; ch, ch1: @char
       enter S1[]
       <<SLOT substreamGreater: dopart>>
       #);
     makeLC:
       (# <<SLOT substreamMakeLC: dopart>> #);
     makeUC:
       (# <<SLOT substreamMakeUC: dopart>> #);
     find:
       (# ch: @char;
          inx: @integer;
          NCS:< booleanObject;
          from:< integerObject(# do pos->value; INNER from #)
       enter ch
       <<SLOT substreamFind: dopart>>
       #);
     findAll: find
       (# from:: (# do 0->value #)
       do INNER findAll
       #);
     findText:
       (# txt: ^text;
          inx: @integer;
          NCS:< booleanObject;
          from:< integerObject(# do pos->value; INNER from #)
       enter txt[]
       <<SLOT substreamFindText: dopart>>
       #);
     findTextAll: findText
       (# from:: (# do 0->value #)
       do INNER findTextAll
       #);
  exit stm.T[low:high]
  #);

putSubStream: screen.putSubstream(# do INNER putSubstream #)

--- textLib: attributes ---
subtxt:
  (# low,high: @integer;
     theSubtext: ^subtext
  enter (low,high)
  do &subtext[]->theSubtext[];
     (this(text)[],(low,high))->theSubtext;
     theSubtext.init
  exit theSubtext[]
  #)

--- streamLib: attributes ---
putSubstream:
  (# stm: ^substream;
     p: (*private*)@integer
  enter stm[]
  <<SLOT substreamPutSubstream: dopart>>
  #)
