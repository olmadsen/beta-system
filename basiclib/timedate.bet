ORIGIN '~beta/basiclib/v1.6/betaenv';
BODY 'private/timedatebody';

(* This library defines a 'time' (and thereby a date) and a 'period'
 * concept.
 * 
 * The library defines numerous operations on time and period values,
 * and time objects, including operations for comparisons, addition,
 * subtractions, printing and reading times and periods.
 * 
 * Given a time, you can ask for the year, day, etc. components of
 * that time, giving the date-related informations of a time.
 *)

--- lib:attributes ---
time:
  (# <<SLOT timeLib:attributes>>;
     
     (* Get and set the individual attributes of the time.
      * 
      * These are normalised, so that you can overflow attributes into
      * each other.  If you e.g. add 23 hours to a time representing
      * 7 o'clock one day, it becomes 6 o'clock the next day!  If you
      * subtract a day from the 1st of a month, you get the last day
      * of the previous month, and so on.
      *)
     
     year: (* set/get the year-component of this(time) *)
       (#
       enter (# value: @integer enter value <<SLOT timeEnterYear:dopart>> #)
       exit (# value: @integer <<SLOT timeExitYear:dopart>> exit value #)
       #);
     month: (* set/get the month-component of this(time). Range: [1-12] *)
       (#
       enter (# value: @integer enter value <<SLOT timeEnterMonth:dopart>> #)
       exit (# value: @integer <<SLOT timeExitMonth:dopart>> exit value #)
       #);
     day: (* set/get the day-component of this(time). Range: [1-..] *)
       (#
       enter (# value: @integer enter value <<SLOT timeEnterDay:dopart>> #)
       exit (# value: @integer <<SLOT timeExitDay:dopart>> exit value #)
       #);
     hour: (* set/get the hour-component of this(time) *)
       (#
       enter (# value: @integer enter value <<SLOT timeEnterHour:dopart>> #)
       exit (# value: @integer <<SLOT timeExitHour:dopart>> exit value #)
       #);
     minute: (* set/get the minute-component of this(time) *)
       (#
       enter (# value: @integer enter value <<SLOT timeEnterMinute:dopart>> #)
       exit (# value: @integer <<SLOT timeExitMinute:dopart>> exit value #)
       #);
     sec: (* set/get the sec-component of this(time) *)
       (#
       enter (# value: @integer enter value <<SLOT timeEnterSec:dopart>> #)
       exit (# value: @integer <<SLOT timeExitSec:dopart>> exit value #)
       #);
     weekday:
       (* Returns the weekday of this(time) as an integer.
        *    Sunday=1, Monday=2, Tuesday=3, etc.
        *)
       (#
       exit (# value: @integer <<SLOT timeExitWeekday:dopart>> exit value #)
       #);
     
     timePredicate: booleanValue(# other: @time enter other do INNER #);
     
     sameYear:
       (* returns true, iff this(time).year = other.year *)
       timePredicate(# <<SLOT timeSameYear:dopart>> #);
     sameMonth:
       (* returns true, if sameYear and this(time).month = other.month *)
       timePredicate(# <<SLOT timeSameMonth:dopart>> #);
     sameDay:
       (* returns true, if sameMonth and this(time).day = other.day *)
       timePredicate(# <<SLOT timeSameDay:dopart>> #);
     sameHour:
       (* returns true, if sameDay and this(time).hour = other.hour *)
       timePredicate(# <<SLOT timeSameHour:dopart>> #);
     sameMinute:
       (* returns true, if sameHour and this(time).minute = other.minute *)
       timePredicate(# <<SLOT timeSameMinute:dopart>> #);
     sameSec:
       (* returns true, if sameMinute and this(time).sec = other.sec *)
       timePredicate(# <<SLOT timeSameSec:dopart>> #);
     
     equal:
       (* returns true, iff this(time) = other *)
       sameSec(# #);
     
     before: (* returns true, iff this(time) < other *)
       timePredicate(# <<SLOT timeBefore:dopart>> #);
     after: (* returns true, iff this(time) > other *)
       timePredicate(# <<SLOT timeAfter:dopart>> #);

     between: booleanValue
       (* returns true, iff d1 <= this(time) <= d2 *)
       (# d1,d2: @time
       enter (d1,d2)
       <<SLOT timeBetween:dopart>>
       #);
     
     add: (* moves this(time) forward in time by period 'p' *)
       (# p: @period
       enter p
       <<SLOT timeAdd: dopart>>   
       #);
     
     sub: (* moves this(time) backwards in time by period 'p' *)
       (# p: @period
       enter p
       <<SLOT timeSub: dopart>>   
       #);
     
     private: @<<SLOT timePrivate:descriptor>>;

  enter (# year, month, day, hour, minute, sec: @integer;
        enter (year, month, day, hour, minute, sec) 
        <<SLOT timeEnterTime:dopart>> #)
  exit  (# year, month, day, hour, minute, sec: @integer;
        <<SLOT timeExitTime:dopart>>
        exit (year, month, day, hour, minute, sec) 
        #)
  #);

timeNow: (* get the time right now! *)
  (# t: @time;
  <<SLOT timeTimeNow:dopart>>
  exit t   
  #);

timeNowRef:
  (* as timeNow, except that it returns a time object reference *)
  (# t: ^time
  do &time[]->t[]; timeNow->t;
  exit t[]
  #);

timeMin: (* Mon Nov 24 12:00:00 -4713 *) 
  (# t: @time;
  <<SLOT timeTimeMin:dopart>>  
  exit t
  #);
                
timeMax: (* in principle infinity *)
  (# t: @time;
  <<SLOT timeTimeMax:dopart>>  
  exit t
  #);

timeRange: (* the range within which time objects will be normalized *)
  (# exit (timeMin, timeMax) #);

timeDifference:
  (* calculates the time difference (period) between the two times t1 and t2 *)
  (# t1, t2: @time; d: @period
  enter (t1,t2)
  <<SLOT timeDifference: dopart>>   
  exit d
  #);

period:
  (* Periods are used to represent a period of time.
   * 
   * Periods are measured in days, hours, minutes and seconds, and is
   * as such independent of months and years, since these measurements
   * are not time invariant (the length of a year varies, and the same
   * applies for months (28, 29, 30 or 31 days).
   * 
   * Periods can be used to represent the time difference between two
   * times, e.g. between Nov 28 22:45:15 1996 and Dec 3 23:15:30,
   * which is 05#00:30:15.
   * 
   * Periods are also used to represent a duration, e.g. the duration
   * of a standard lecture, 00#00:45:00.
   * 
   * You can add and subtract periods using pAdd and pSub
   * (e.g. '((0,01,30,00),p1)->pAdd->p2' adds one hour and 30 minutes
   * to the period 'p1' and returns the result in 'p2').
   * 
   * And you can measure the time difference between two times 't1'
   * and 't2' by '(t1,t2)->timeDifference->p'.  Finally, you can move
   * a time 't' forward or backwards in time by a given period 'p' by
   * 'p->t.add' and' p->t.sub'.
   *)
  (# <<SLOT periodLib: attributes>>;
     days, hours, minutes, seconds: @integer; 
  enter (days, hours, minutes, seconds)
  exit (days, hours, minutes, seconds)
  #);

pAdd: (* adds two periods and returns the result *)
  (# p1, p2, p3: @period
  enter (p1, p2)
  do p1.days+p2.days->p3.days;
     p1.hours+p2.hours->p3.hours;
     p1.minutes+p2.minutes->p3.minutes;
     p1.seconds+p2.seconds->p3.seconds;
  exit p3
  #);

pSub: (* subtracts two periods and returns the result *)
  (# p1, p2, p3: @period
  enter (p1, p2)
  do p1.days-p2.days->p3.days;
     p1.hours-p2.hours->p3.hours;
     p1.minutes-p2.minutes->p3.minutes;
     p1.seconds-p2.seconds->p3.seconds;
  exit p3
  #);

(* Input/Output utilities:
 *
 * Formats:
 *    Time:   Www Mmm Dd Yyyy Hh:Mm:Ss
 *    Date:   Www Mmm Dd Yyyy
 *    Clock:  Hh:Mm:Ss
 *    Period: Dd#Hh:Mm:Ss
 * 
 * where Www  is the weekday (Mon, Tue, etc.)
 *       Mmm  is the month (Jan, Feb, etc.)
 *       Dd   is the date
 *       Hh   is hours
 *       Mm   is minutes
 *       Ss   is seconds
 *       Yyyy is the year
 *)

putTime: (* prints a time value on screen *)
  screen.putTime(# do INNER #);
getTime: (* reads a time value from the keyboard *)
  keyboard.getTime(# do INNER #);

putDate: (* prints the date portion of a time value on screen *)
  screen.putDate(# do INNER #);
getDate:
  (* reads a date value from the keyboard.  The clock part of the
   * time value will be 00:00:00
   *)
  keyboard.getDate(# do INNER #);

putClock: (* prints the clock portion of a time value on screen *)
  screen.putClock(# do INNER #);
getClock:
  (* reads a clock value from the keyboard.  The date part of the
   * time value will be Jan 01, 0000.
   *)
  keyboard.getClock(# do INNER #);

putPeriod: (* prints a period value on screen *)
  screen.putPeriod(# #);
getPeriod: (* reads a period value from the keyboard *)
  keyboard.getPeriod(# #);

--- streamLib:attributes ---

putTime:  (* prints a time value on this(stream) *)
  (# t: @time;
  enter t
  <<SLOT timePutTime:dopart>>
  #);
getTime: (* reads a time value from this(stream) *)
  (# t: @time;
  <<SLOT timeGetTime:dopart>>
  exit t
  #);

putDate: (* prints the date portion of a time value on screen *)
  (# t: @time;
  enter t
  <<SLOT timePutDate:dopart>>
  #);
getDate:
  (* reads a date value from the keyboard.  The clock part of the
   * time value will be 00:00:00
   *)
  (# t: @time;
  <<SLOT timeGetDate:dopart>>
  exit t
  #);

putClock: (* prints the clock portion of a time value on screen *)
  (# t: @time;
  enter t
  <<SLOT timePutClock:dopart>>
  #);
getClock:
  (* reads a clock value from the keyboard.  The date part
   * of the time value will be Jan 01, 0000
   *)
  (# t: @time;
  <<SLOT timeGetClock:dopart>>
  exit t
  #);

putPeriod: (* prints a period value on this(stream) *)
  (# p: @period
  enter p
  <<SLOT timePutPeriod:dopart>>
  #);
getPeriod: (* prints a period value on this(stream) *)
  (# p: @period
  <<SLOT timeGetPeriod:dopart>>
  exit p
  #);

          
                       

