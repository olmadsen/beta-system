Subject: betaenv

Jeg har konstateret nogle mindre ting i forbindelse med dokumentationen:

        3) File/directory/ etc fragmenterne indeholder den samme, meget langt
kommentar.  Det burde v{re nog med den lange i file.bet, samt uddybende
kommentarer i directory, etc.

   Jorgen Lindskov Knudsen, Computer Science Department, Aarhus University

---------------------------------------------------------------------------

Subject: keyboard.get.

Skal g|res muligt at f} denne i "immediate mode", dvs s} man ikke beh|ver
at taste <RETURN>.
Kan g|res vha "curses" eller ioctl().

---------------------------------------------------------------------------

Subject: objectPool.strucScan.

strucScan mangler "enter type##", og er dermed ubrugelig.

  -- Soren

---------------------------------------------------------------------------

Subject: BETA -- stream: get; getLine

So geht's:
 
 
        einlesen : 
        (#  do          &Reservation[] -> R[];
                        'Name des Kunden: '-> putText;
                        get -> R.setname; getLine;              (***)
                        'Datum: ' -> putText;
                        getInt -> R.setdate;
 
                        'Kontrolle:' -> putText;
                        R.ausgeben -> (putInt, put); newLine;
 
                        (* Eintrag in das Register *)
                        R[] -> Res.insert;
 
                        'Noch ein Kunde? j/n '-> putText;
                        get -> c; getLine;                      (***)
                        exit c
   
        #)
 
 
Das 'get' isst genau ein zeichen, d.h. das NL-zeichen bleibt
im puffer stehen und wird bei der naechsten eingabe mitgelesen.
Wenn das fatalerweise wieder ein 'get' ist, bekommt 'get' eben
dieses NL zu lesen. Daher also das 'getLine'.
 
Zugegebenermassen sollte das bei den 'Basic Libraries' erklaert
sein, ich habe dazu aber nichts gefunden.


FILE
===========================================================================
 
Subject: File openwrite vs. openreadwrite

Forskellen pa file.openwrite og file.openreadwrite er i oejeblikket
at foestnaevnte trunkerer filen.

Er det en fornuftig konvention? Jeg mener ikke at man skal miste indholdet
bare fordi man kun oensker at skrive i filen. Praefixet 'open' giver ikke
rigtig nogen mening eftersom man starter med at fjerne  alt det der evt
fandtes i forvejen i filen. Noget man normalt goer v.h.a. 'create'.

Alternativt kunne man have en truncate operation eller en explicit
create.

-- Soren

---------------------------------------------------------------------------

Subject: basiclib/v1.2/file

EOSError eller lignende bliver ikke kaldt hvis man l{ser ud over
enden af en fil, i hvert fald med GetLine.

/j|rgen

---------------------------------------------------------------------------

Subject: CText.bet

stream baseret abstraktion af externe C strenge, om som bruger cstring i 
implementationen |nskes af bl.a. DIKU.

---------------------------------------------------------------------------

Subject: File (wilfred)

    I want to add some custom initialization to a file subclass:

     OpenRead::< (# do RecLocation.read #);
                      ^'OUTER'

    Of course, this should happen AFTER the file is opened.
    But the doc is right apparently, so I have to write
    this clumsy code:

     OpenRecFile: (# do OpenRead; RecLocation.read #);

    -> What is the rationale behind this design?
       Is there a better way to get the desired effect?

---------------------------------------------------------------------------

Subject: File.lock

Kan implementes vha fcntl(2).

---------------------------------------------------------------------------

Subject: File exceptions

Vi har tidligere diskuteret det uhensigtmaessige i at file exceptions skal
bindes naar man skaber filen, og ikke naar man kalder filens operationer.
Tidligere var dette ikke muligt da det ville foere til virtuelt prefix, men
med indfoerslen af final bindings i beta4.5 er dette ikke laengere et
problem.

Altsaa: Var det ikke en ide at lave final bindings paa alle file haandtag,
og faa flyttet exceptions derhen hvor de hoerer til ?

  -- Soren

---------------------------------------------------------------------------

Subject: findch og scan paa text

der findes en scan og en scanAll
og en findch men ikke findchAll.
Til gengaeld virker findch som en findchAll.

da jeg havde brug for en findch som skulle starte fra current pos
lavede jeg den vha. scan. men det drillede mig en del da jeg ikke
lige havde opdaget at jeg skulle binde while:

t.scan (#  while::< (# do true->value #); do ... #)

maaske har jeg sovet i timen
men kunne value ikke default vaere true?
saa man kan bruge scan som i gode gamle dage:-)

/Elmer

--------------------------------------------------------------------------

Enig.

findCh b|r v{re som scan (start fra pos), og der skal s} v{re en findChAll.

Scan skal vel v{re som loop (dvs. med s}vel while, som repeat virtuelle, og
while er default true).

   Jorgen Lindskov Knudsen


--------------------------------------------------------------------------
systemenv:
   Bug i xsystemenv bodies. Repetitions rIds,wIds,xIds og ioms skal extendes
   passende i pioInsertInner, hvis curFD+1 er for stor. 
   Se rettelse i ~beta/guienv/v1.2/private/X11/guienvxsystemenvbody.

   -- Soren

--------------------------------------------------------------------------

Nu er jeg igen blevet irriteret over, at texter ikke generelt er
'self-assignable'. :-)

Antag, at man har:

        tFoo: (# t: ^text ... exit t[] #)

og man har:

        s: @text;

s} er der ingen (nem) m_de at assigne 

        tFoo->s;  (* illegal, da tFoo exiter en text ref., og s's
                   * enter er seT, som siger enter T, hvor T er
                   * char-rep. i s. *)

Hvis man nu kunne skrive noget i stil med:

        (tFoo).->s; 

betydende evaluer tFoo, og derefter evaluer det objekt, tFoo
returnerer, s_ var alt godt igen :-)  Men det kan man ikke (endnu).

M_ jeg derfor foresl_, at vi i v1.5 indf_rer flg. nye text
operationer:

        text: stream
          (# ...
             set: (# ch: @char enter ch do clear; ch->put #);
             settext: (# t: ^text enter t[] do clear; t->puttext #); 
             setInt: (# i: @integer enter i do clear; i->putint #);
                (* og resten, svarende til putreal, etc *)
          #);

S_ kunne man skrive:

        tFoo->s.settext;

som er n{sten lige s} godt som tFoo->s.

---

Og s} skal vi lige huske at tilf|je put/getBoolean :-)


--- jlk

----------------------------------------------------------------------------

file_ntbody.bet + file_macbody.bet:
Implementer DiskEntrySetModTime.

----------------------------------------------------------------------------
