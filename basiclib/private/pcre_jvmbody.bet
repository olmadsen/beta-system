ORIGIN 'pcrebody';
INCLUDE 'betaenv_jvmbody';
INCLUDE 'PcreJvmHelper';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 2000-2003
 *       All rights reserved.
 *)

--LIB: attributes--
trace: (# exit false #);

---- PcrePrivate: descriptor ----
(# (* Private internal state *)
   compiled_regexp: @Integer;
   extra: @Integer;
   oVector: [1] @Integer;
   FIXME: [3]@integer;
#)

---- PcreInit: dopart ----
do (exp[],options) 
     -> PcreJvmHelper.initialize
     -> private.FIXME;
   (private.FIXME[1], private.FIXME[2], private.FIXME[3])
     -> (private.compiled_regexp, private.extra, subpatterns);
   (if trace then 
       'PcreInit: compiled_regexp: ' -> screen.puttext;
       private.compiled_regexp->screen.putint;
       ', extra: ' -> screen.puttext;
       private.extra->screen.putint;
       ', subpatterns: ' -> screen.puttext;
       subpatterns ->screen.putint;
       screen.newline;
   if);
   (if private.compiled_regexp=0 then
       'PcreInit: error handling' -> NYI;
    else
       ((subpatterns + 1) * 3) -> private.oVector.new;
   if);
   
---- PcreMatchPos: dopart ----
do private.oVector[1] + 1 -> start;
   private.oVector[2] -> end;

---- PcrePreMatchText: dopart ----
do (1, private.oVector[1]) -> subject.sub -> result[];

---- PcrePostMatchText: dopart ----
do (private.oVector[2] + 1, subject.lgth) -> subject.sub -> result[];

---- PcreSubMatchPos: dopart ----
do (if index <= subPatterns then
       private.oVector[index * 2 + 1] + 1 -> start;
       private.oVector[index * 2 + 2] -> end;
   if);

---- PcreSubMatchText: dopart ----
do index -> subMatchPos -> (start, end);
   (if start = 0 then
       (if opt %Band pcre_RETURN_NONE then
           NONE -> result[];
        else
           '' -> result[];
       if);
    else
       (start, end) -> subject.sub -> result[];
   if);
   
---- PcreMatch: dopart ----
do options -> opt;
   0 -> subMatchCounter;
   pre;
   private.oVector.range -> private.oVector.new;
   (if subject.T.range = 0 then 1 -> subject.T.extend; 0 -> subject.T[1] if);
   position - 1 -> psn;
   
   (private.compiled_regexp, 
   private.extra, 
   subject[], 
   subject.lgth,
   psn, 
   opt %Band pcre_NONBETAOPTIONS, 
   private.oVector[], 
   private.oVector.range) -> PcreJvmHelper.exec -> result;
   
   (result <> pcre_ERROR_NOMATCH) -> matched;
   (if matched then
       INNER;
    else
       noMatch;
   if);

---- PcreMatchAllPrivate: descriptor ----
(#
#)


---- PcreMatchAllPre: dopart ----
do 'pcre_jvmbody: PcreMatchAllPre' -> NYI;

---- PcreMatchAllSplitPos: dopart ----
do 'pcre_jvmbody: PcreMatchAllSplitPos' -> NYI;

---- PcreMatchAllSplit: dopart ----
do 'pcre_jvmbody: PcreMatchAllSplit' -> NYI;

---- PcreMatchAllNoMatch: dopart ----
do 'pcre_jvmbody: PcreMatchAllNoMatch' -> NYI;

---- PcreMatchAllSpn: dopart ----
do 'pcre_jvmbody: PcreMatchAllSpn' -> NYI;

---- PcreMatchAllRestn: dopart ----
do 'pcre_jvmbody: PcreMatchAllRestn' -> NYI;

---- PcreMatchAll: dopart ----
do 'pcre_jvmbody: PcreMatchAll' -> NYI;

---- PcreReplace: dopart ----
do (1, private.oVector[1]) -> subject.sub -> new[];
   replacement[] -> rep -> new.append;
   (private.oVector[2] + 1, subject.lgth) -> subject.sub -> new.append;
   INNER;
