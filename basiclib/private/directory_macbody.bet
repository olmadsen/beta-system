ORIGIN 'directorybody';
(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-96
 *       All rights reserved.
 *)
INCLUDE 'file_macbody';
INCLUDE '~beta/maclib/v3.1/morefiles';

-- DirectoryLib: Attributes --
CountEntries: External
  (# ID: @Integer; vRefNum: @ShortInt; NoOfEntries: @Integer; 
  enter (ID,vRefNum)
  do callC
  exit NoOfEntries
  #);
GetIndEntryName: External
  (# ID: @Integer; vRefNum: @ShortInt; inx: @Integer; name: @integer;
  	  res: @integer;
  enter (ID, vRefNum, inx, name)
  do callC
  exit res
  #);
numFiles: External
  (# Path: [1] @Char; NoOfFiles: @Integer; 
  enter Path
  do callC
  exit NoOfFiles
  #);
entryDelete:
  (# fs: ^FSSpec; p: ^Text; result: @ShortInt; 
  enter fs[]
  do
     (if HasFSSpecCalls
      // true then fs[]->FSpDelete->result; 
      else
         fs.name->p[]; (fs.vRefNum,fs.parID,p)->HDelete->result
     if);
     
  exit result
  #);
  

-- DirPrivate: Descriptor --
(# #)  

-- DirException: Descriptor --
(# 
do 'Directory exception for '''->msg.putText; Name->msg.putText; ''''->msg.put; 
#)  

-- DirTouch: Descriptor --
(# p: ^Text; res: @Integer; 
do
   entry.private.FSpCheckNil;
   (if entry.exists then
      (if entry.isDirectory then
	     error;
	  if);
   else
       entry.private.fs.name->p[];
       (if hasFSSpecCalls
        // true then
           (if p.length = 0 then
               entry.private.path[]->p[];
               (if ((0,0,p,entry.private.fs[])->MakeFSSpec)
                // 0 // - 43 then 
                else
                   error; 
               if);
               
           if);
           (entry.private.fs[],- 1,entry.private.dirID[])->FSpDirCreate
             ->res;
           TRUE->entry.private.FSSpecValid;
           
        else
           (if p.length = 0 then entry.private.path[]->p[];  if);
           (entry.private.fs.vRefNum,entry.private.fs.parID,p,
            entry.private.dirID[])->DirCreate->res;
           TRUE->entry.private.FSSpecValid;
		   TRUE -> entry.private.isDirectory;
           
       if);
       (if res
        // 0 then (* now we have a FSSpec; do not use private.path *)
        else
           error; 
       if);
       
   if);
   
#)  

-- DirNoOfEntries: DoPart --
do
   entry.private.FSpCheckNil;
   (entry.private.dirID,entry.private.fs.vRefNum)->CountEntries->Value;
     

-- DirEmpty: DoPart --
do (NoOfEntries = 0)->Value;   

-- DirDelete: Descriptor --
(# res: @Integer; 
do
   entry.private.FSpCheckNil;
   (if empty
    // true then
       entry.private.fs[]->entryDelete->res;
       (if res // 0 then  else error;  if);
       
    else
       error
   if);
   
#)  

-- DirCreateFile: DoPart --
do
     (# 
        makeFile:
          (# 
             fs: ^FSSpec;
             Creator: (# exit 'MPS '->Text2ResType #);
             Type: (# exit 'TEXT'->Text2ResType #);
             p: ^Text;
             result: @Integer;
             li: ^longInt;
          enter fs[]
          do
             (if HasFSSpecCalls
              // true then
                 (fs[],Creator,Type,- 1)->FSpCreate->result; 
              else
                 fs.name->p[];
				 (* OLM: 27/19/96: someone Please check this! *)
				 &longInt[] -> li[]; fs.parID->li;
                 (fs.vRefNum,fs.parID,p,Creator,Type)->HCreate->result;
                 
             if);
             
          exit result
          #);
        
     do
        entry.private.FSpCheckNil;
        &EntryDesc[]->newEntry[];
        &FSSpec[]->newEntry.private.fs[];
        (entry.private.fs.vRefNum,entry.private.dirID,name,
         newEntry.private.fs[])->MakeFSSpec;
        TRUE->newEntry.private.FSSpecValid;
        (if (newEntry.private.fs[]->makeFile) // 0 then  else error;  if);
        
     #);
     

-- DirDeleteFile: DoPart --
do
     (# fs: @FSSpec; res: @Integer; 
     do
        entry.private.FSpCheckNil;
        (entry.private.fs.vRefNum,entry.private.dirID,name,fs[])->MakeFSSpec
          ->res;
        (if res // 0 then fs[]->entryDelete->res;  if);
        (if res // 0 then  else error;  if);
        
     #);
     

-- DirCreateDir: DoPart --
do
     (# 
        makeDir:
          (# fs: ^FSSpec; dirID: ^LongInt; p: ^Text; result: @Integer; 
          enter (fs[],dirID[])
          do
             (if HasFSSpecCalls
              // true then
                 (fs[],- 1,dirID[])->FSpDirCreate->result; 
              else
                 fs.name->p[];
                 (fs.vRefNum,fs.parID,p,dirID[])->DirCreate->result;
                 
             if);
             
          exit result
          #);
        
     do
        entry.private.FSpCheckNil;
        (if Name[]
         // none then error
         else
            &EntryDesc[]->newEntry[];
            &FSSpec[]->newEntry.private.fs[];
            (entry.private.fs.vRefNum,entry.private.dirID,name,
             newEntry.private.fs[])->MakeFSSpec;
            (if ((newEntry.private.fs[],newEntry.private.dirID[])->makeDir)
             // 0 then
                newEntry.private.fs[]->FSpGetDirID->newEntry.private.dirID;
                TRUE->newEntry.private.FSSpecValid;
                
             else
                error; 
            if);
            
        if);
        
     #);
     

-- DirDeleteDir: DoPart --
do
     (# fs: @FSSpec; res: @Integer; 
     do
        entry.private.FSpCheckNil;
        (entry.private.fs.vRefNum,entry.private.dirID,name,fs[])->MakeFSSpec
          ->res;
        (if res // 0 then fs[]->entryDelete->res;  if);
        (if res // 0 then  else error;  if);
        
     #);
     

-- DirFindSelect: Descriptor --
(# do (if found[] // none then NotFoundException;  if);  #)  

-- DirFindDispatch: Descriptor --
(# 
do
   (if selectedInInner
    // false then
       (if true
        // found.isFile then whenfile;  // found.isDirectory then whendir; 
        else
           whenother; 
       if)
   if);
   
#)  

-- DirFindFullPath: Descriptor --
(# vRefnum: @integer;
   parID: @integer;
   error: @integer;
   spec: @FSSpec;
   path: ^text;
do 
   (if found[]
    // none then NotFoundException; 
    else
	   entry.private.fs.vRefnum -> vRefnum;
	   entry.private.dirID -> parID;
	   found.path -> path[];
	   (vRefnum, parID, path, spec[]) -> MakeFSSpec -> error;
	   (if (error = 0) OR (error = -43) then
	      spec[] -> convertToFullPath -> p[];
	   if);
   if)
#)  

-- DirFindGetFile: Descriptor --
(# 
do
   (if found[]
    // none then NotFoundException; 
    else
       &foundFile[]->f[]; found.private.fs[]->f.entry.private.fs[]; 
	   true -> f.entry.private.FSSpecValid;
   if);
   
#)  

-- DirFindGetDir: Descriptor --
(# 
do
   (if found[]
    // none then NotFoundException; 
    else
       &foundDir[]->d[];
       found.private.fs[]->d.entry.private.fs[];
       found.private.dirID->d.entry.private.dirID;
	   true -> d.entry.private.FSSpecValid;
	   entryIsDir -> d.entry.private.status;
   if);
   
#)  

-- DirFindEntry: Descriptor --
(# fs: ^FSSpec;
   p: ^text;
do
   (if candidate[]
    // none then 
    else
       entry.private.FSpCheckNil;
       &FSSpec[]->fs[];
       (if ((entry.private.fs.vRefNum,entry.private.dirID,candidate,fs[])->MakeFSSpec) 
	   // 0 then
           &foundDesc[]->found[];
           fs[]->found.private.fs[];
		   fs[] -> convertToFullPath -> p[];
		   p -> found.private.path;
           TRUE->found.private.FSSpecValid;
           (if (found.private.fs[]->FSpIsDir) then 
		   		found.private.fs[]->FSpGetDirID->found.private.dirID;
				entryIsDir -> found.private.status;
			else
				entryIsFile -> found.private.status;
           if);
           INNER findEntry;
           
        // - 43 then
           notFound; 
        else
           DirSearchException; 
       if);
       
   if);
   
#)  

-- DirScanFullPath: Descriptor --
(# vRefnum: @integer;
   parID: @integer;
   error: @integer;
   spec: @FSSpec;
   path: ^text;
do 
   (if found[]
    // none then NotFoundException; 
    else
	   entry.private.fs.vRefnum -> vRefnum;
	   entry.private.dirID -> parID;
	   found.path -> path[];
	   
	   (vRefnum, parID, path, spec[]) -> MakeFSSpec -> error;
		  
	   (if (error = 0) OR (error = -43) then
	      spec[] -> convertToFullPath -> p[];
	   if);
   if)
#)  

-- DirScanSelect: Descriptor --
(# do (if found[] // none then NotFoundException;  if);  #)  

-- DirScanDispatch: Descriptor --
(# 
do
   (if selectedInInner
    // false then
       (if true
        // found.isFile then whenfile;  // found.isDirectory then whendir; 
        else
           whenother; 
       if)
   if);
   
#)  

-- DirScanGetFile: Descriptor --
(#  p: ^text;
do
   (if found[]
    // none then NotFoundException; 
    else
       &foundFile[]->f[]; found.private.fs[]->f.entry.private.fs[]; 
	   true -> f.entry.private.fsspecvalid;(* datpete *)
	   foundFullPath -> p[];
	   p -> f.entry.private.path;
	   entryIsFile -> f.entry.private.status;
   if);
   
#)  

-- DirScanGetDir: Descriptor --
(# p: ^text;
do
   (if found[]
    // none then NotFoundException; 
    else
       &foundDir[]->d[];
       found.private.fs[]->d.entry.private.fs[];
       found.private.dirID->d.entry.private.dirID;
	   true -> d.entry.private.fsspecvalid;(* datpete *)
	   foundFullPath -> p[];
	   p -> d.entry.private.path;
	   entryIsDir -> d.entry.private.status;
       
   if);
   
#)  

-- DirScanEntries: Descriptor --
(# specs: [1] ^foundDesc; CurName: ^Text; res: @Integer;

do entry.private.FSpCheckNil;
   NoOfEntries->specs.new;
   (for i: specs.range repeat
     &foundDesc[]->specs[i][];
     &FSSpec[]->specs[i].private.fs[];
     (entry.private.dirID, entry.private.fs.vRefNum, 
	 i, @@specs[i].private.fs.R[1] + 6) -> GetIndEntryName -> res;
	 (if res = 0 then
	    entry.private.fs.vRefNum -> specs[i].private.fs.vRefNum;
		entry.private.dirID -> specs[i].private.fs.parid;
		specs[i].private.fs.name -> CurName[];
		CurName -> specs[i].private.path;
		(if CurName.length > longest then
			CurName.length -> longest;
		if);
		TRUE->specs[i].private.FSSpecValid;
		 (if (specs[i].private.fs[]->FSpIsDir) then 
			specs[i].private.fs[]->FSpGetDirID->specs[i].private.dirID;
			entryIsDir -> specs[i].private.status;
		 else
			entryIsFile -> specs[i].private.status;
		 if);
	 if);     
   for);
   (for i: specs.range repeat
     specs[i][]->found[];
     INNER scanEntries;
   for);
   
#)  

