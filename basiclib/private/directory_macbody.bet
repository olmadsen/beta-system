ORIGIN  'directorybody';
INCLUDE 'file_macbody';
(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1992-95
 *       All rights reserved.
 *)

-- DirectoryLib: attributes ---
Convert:
	(#	int: @Integer;
	enter int
	do	(@@int,int) -> TOS'%putShort[0]';
		@@int -> TOS'%adrGetSignedShort' -> int
	exit int
	#);
numFiles: External
	(#	thePath: [1] @Char;
		NoOfFiles: @Integer;
	enter thePath
	do callC
	exit NoOfFiles
	#);

-- DirPrivate: descriptor --
(#	DirID: @Integer;
#)

-- DirException: descriptor --
(# #)

-- DirTouch: descriptor--
(#	makedir: 
		(# result:cstruct
				(# bytesize::< (# do 4 -> value #);
				enter r[1]
				exit r[1]
				#);
			DIRCREATE: External
			  (# vRefNum: @ shortInt;
				 parentDirId: @integer;
				 directoryName: [1] @char;
				 r: ^result;
				 res: @shortInt
			  enter (vRefNum,parentDirId,directoryName,r[])
			  do pascal
			  exit res
			  #);
			r: @result;
			res: @integer;
		do (0,0,entry.private.path,r[]) -> DIRCREATE -> res;
			(if res<>0 then error if);
		#);
do (if not entry.exists then makedir if);
#)


-- DirNoOfEntries: descriptor --
(#	CountEntries: External
	(#	theID: @Integer;
		NoOfEntries: @Integer;
	enter theID
	do callC
	exit NoOfEntries
	#);
do private.DirID -> CountEntries -> Value;
#)

-- DirEmpty: descriptor --
(#	CountEntries: External
	(#	theID: @Integer;
		NoOfEntries: @Integer;
	enter theID
	do callC
	exit NoOfEntries
	#);
	total: @Integer;
do private.DirID -> CountEntries -> total;
	(total=0) -> Value;
#)

-- DirDelete: descriptor --
(# 
do 
#)

-- DirCreateFile: descriptor -- 
(#	Text2ResType:
		(# const3: (# exit 16777216 #);
			const2: (# exit 65536 #);
			const1: (# exit 256 #);
			newtxt: [4] @Char;
			result: @Integer;
		enter newtxt
		do	newtxt[1] * const3 -> result;
			(newtxt[2] * const2) + result -> result;
			(newtxt[3] * const1) + result -> result;
			newtxt[4] + result -> result;
		exit result
		#);
	Create: External
		(#	fileName: [1] @Char;
			vRefNum: @ShortInt;
			Creator,Type,error: @Integer;
		enter (fileName,vRefNum,Creator,Type)
		do 'CREATE' -> CallPascal
		exit error
		#);
	error,theCreator,theType: @Integer;
	NewFile: ^File;
do 'MPS ' -> Text2ResType -> theCreator;
	'TEXT' -> Text2ResType -> theType;
	(Name,0,theCreator,theType) -> Create -> Convert -> error;
	(if Error=0
		then
			&File[] -> NewFile[];
			NewFile.Entry[] -> newEntry[]
		else (* ERROR! *)
	if);
#)

-- DirDeleteFile: descriptor --
(# FSDelete: External
		(#	fileName: [1] @Char;
			vRefNum: @ShortInt;
			error: @Integer;
		enter (fileName,vRefNum)
		do	'FSDELETE' -> CallPascal
		exit error
		#);
	error: @Integer;
do (Name,0) -> FSDelete -> convert -> error;
	(if error<>0 then (* ERROR!! *) if);
#)

-- DirCreateDir: descriptor --
(#	DirCreate: External
		(#	vRefNum: @ShortInt;
			parentDirID: @Integer;
			directoryName: [1] @Char;
			createdDirID: ^LongInt;
			error: @Integer;
		enter (vRefNum,parentDirID,directoryName,createdDirID[])
		do 'DIRCREATE' -> CallPascal
		exit error
		#);
	error: @Integer;
	theDirID: @LongInt;
	NewDirectory: ^Directory;
do	(0,0,Name,theDirID[]) -> DirCreate -> Convert -> error;
	(if Error=0
		then
			&Directory[] -> NewDirectory[];
			theDirID -> NewDirectory.Private.DirID;
			NewDirectory.Entry[] -> newEntry[]
		else (* ERROR! *)
	if);
#)

-- DirDeleteDir: descriptor --
(# 
do 
#)

-- DirFindSelect: descriptor --
(# 
do 
#)

-- DirFindDispatch: descriptor --
(# 
do 
#)

-- DirFindFullPath: descriptor -- 
(# 
do 
#)

-- DirFindGetFile: descriptor --
(# 
do 
#)

-- DirFindGetDir: descriptor --
(# 
do 
#)

-- DirFindEntry: descriptor --
(# entryfullpath: @text;
do 
#)

-- DirScanFullPath: descriptor --
(# 
do 
#)

-- DirScanSelect: descriptor --
(# 
do 
#)

-- DirScanDispatch: descriptor --
(# 
do 
#)

-- DirScanGetFile: descriptor -- 
(# 
do 
#)

-- DirScanGetDir: descriptor --
(# 
do 
#)

-- DirScanEntries: descriptor -- 
(# 
   
#)
