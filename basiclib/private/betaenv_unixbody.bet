ORIGIN 'betaenvbody';
BUILD default '$$/basicio.o' 'external/basicio.c' '$CC -D$$ -c -o $0 $1';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1984-96
 *       All rights reserved.
 *
 *)
--betaenvbodyMDInitAscii: descriptor-- 
(#
do
   (* Initialize private.NonWhiteSpace. Offsett by one to allow test for
    * isNonWhiteSpace(0)
    *)
   (* From '!'(33) to '~'(126) is NonWhiteSpace *)
   (for ch: (126-33+1) repeat true->private.NonWhiteSpace[ch+33] for);
   (* From <inverted exclamation>(161) to <y umlaut>(255) is NonWhiteSpace 
    * (iso8859, Latin-1)
    *)
   (for ch: (255-161+1) repeat true->private.NonWhiteSpace[ch+161] for);

#)
--betaenvInitEnv: descriptor--
(# UnixScreen: Stream (* A standard UNIX screen *)
     (# EOFvalue: external(# eof: @integer exit eof #);
        Eos::< (#do true->value #); 
	OtherError::< (# do 'Screen error'->msg.puttext #);
        Get::< 
          (# do 'Warning: attempt to Get from the Screen' -> screen.putline; #);
	Put::< 
          (# PutToScreen: External(# ch: @char enter ch do CallC #);
	  do ch->PutToScreen;
	  #);
	PutText::< 
          (# PutTextToScreen: External(# str: @integer enter str #);
	  do (if txt.lgth > 0 then
                 (if txt.lgth < txt.T.range then 0 -> txt.T[txt.lgth+1] if);
                 @@txt.T[1]->PutTextToScreen;
             if)
          #);
      #);
   UnixKeyBoard: Stream (* A standard Unix keyboard *)
     (# Eos::<
       	  (# KeyboardEOS: External(# yes: @boolean do CallC exit yes #);
	  do KeyboardEOS->value
	  #);
	OtherError::< (#do 'Keyboard error'->msg.puttext #); (****????*)
        Put::< (# do 'Warning: attempt to Put to the Keyboard' -> screen.putline; #);
	Get::<
          (# GetFromKeyboard: External(# ch: @char do CallC exit ch #)
	  do GetFromKeyboard->ch
	  #);
        GetAtom::<
          (# KeyboardPeek: External(# ch: @char do CallC exit ch #);
	     GetFromKeyboard: External(# ch: @char do CallC exit ch #);
          do skipBlanks:
               (if KeyboardPeek->ascii.isWhiteSpace then
                   GetFromKeyboard; restart skipBlanks 
               if);
             scan:
               (if not (KeyboardPeek->ascii.isWhiteSpace) then
                   (if (txt.pos+1->txt.pos) > txt.T.range then txt.T.range+16->txt.T.extend if);
                   GetFromKeyboard->txt.T[txt.pos]; txt.lgth+1->txt.lgth;
                   restart scan
               if)
	  #);
        GetLine::<
          (# KeyboardPeek: External(# ch: @char do CallC exit ch #);
	     GetFromKeyboard: External(# ch: @char do CallC exit ch #);
          do scan:
               (if KeyboardPeek<>ascii.newline then
                   (if (txt.pos+1->txt.pos) > txt.T.range then txt.T.range+16->txt.T.extend if);
                   GetFromKeyboard->txt.T[txt.pos]; txt.lgth+1->txt.lgth;
                   restart scan
                else GetFromKeyboard
               if)
          #);
	Peek::<
	  (# KeyboardPeek: External(# ch: @char do CallC exit ch #)
	  do KeyboardPeek->ch
	  #);
     #);
do 
(*    getEOFvalue->EOFvalue;*)
    ascii.init;
    ascii.nl-> ascii.newline;
    &UnixScreen[]->screen[]; 
    &UnixKeyBoard[]->keyboard[];
#)
--betaenvbodyTerminateConsole: descriptor--
(##)
--betaenvTerminateEnv: descriptor--
(##)
