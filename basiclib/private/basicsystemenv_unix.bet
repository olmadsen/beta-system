ORIGIN 'basicsystemenvbody';
LIB_ITEM 'basicsystemenv';
INCLUDE '~beta/sysutils/iostate';
INCLUDE '~beta/sysutils/objinterface';
BUILD default '$$/systemenvExt.o' 'external/systemenvExt.c' '$CC -D$$ -c -o $0 $1';

(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1984-97
 *       All rights reserved.
 *
 *)

--- lib:attributes ---

pioReadBlocked:  (# exit 1 #);
pioWriteBlocked: (# exit 2 #);

pioReadReady: (# exit -1 #);
pioWriteReady: (# exit -2 #);
pioException: (# exit -3 #);

ExtsleepUntil: external (# due: @Real enter due #);
getTimeAsDouble: external 
  (# time: @Real; 
  exit time 
  #);

selectSockets: external
  (* In external/systemenvExt.c *)
  (# readCandidatesAdr, writeCandidatesAdr, exceptCandidatesAdr: @Integer;
     sec, usec: @Integer;
     readyCount: @Integer;
  enter (readCandidatesAdr, writeCandidatesAdr, exceptCandidatesAdr, sec, usec)
  exit readyCount
  #);

--- systemLib:attributes ---

SystemEnvKeyboard: Stream
  (# memcpy: external
       (# adrTarget: @Integer;
          adrSource: @Integer;
          byteCount: @Integer;
          out: @Integer;
       enter (adrTarget, adrSource, byteCount)
       exit out
       #);
     state: @IOmask;
     fd: @Integer;
     isClosed: @Boolean;

     MaxReadAhead: (# exit 8192 #); 
     (* Max count of bytes to buffer ahead in stream *)
     Buffer: @
       (# (* Copied and extended from Buffer in basicsocketbody.bet *)
          T: [0]@Char;
          putpos, getpos: @Integer;
          Expand: @
            (# len: @Integer;
            enter len
            do (if putpos + len >= T.range then len -> T.extend; if);
            #);
          (* put: @
           *  (# c: @char;
           *  enter c
           *  do putpos + 1 -> putpos;
           *     (if putpos > T.range then 16 -> T.extend  if);
           *     c -> T[putpos];
           *  #);
           * 
           *)
          get: @
            (# c: @char;
            do getpos + 1 -> getpos;
               T[getpos] -> c;
               (if getpos=putpos then 0 -> getpos; 0 -> putpos if)
            exit c
            #);
          AddedBytes: @
            (# len: @Integer;
            enter len
            do len+putpos->putpos;
            #);               
          getPutAdr: @
            (# adr: @Integer;
            do @@T[putpos + 1] -> adr;
            exit adr
            #);
          getFreeSpace: @
            (# space: @Integer;
            do T.range-putpos->space;
            exit space
            #);
          (* putMem: @
           *   (# adr,len,tmp: @Integer;
           *   enter (adr,len)
           *   do (@@T[putpos + 1], adr, len) -> memcpy;
           *      putpos + len -> putpos;
           *   #);
           * getMem: @
           *   (# adr,len,tmp: @Integer;
           *   enter len
           *   do @@T[getpos + 1] -> adr;
           *      getpos + len -> getpos;
           *      (if getpos=putpos then 0 -> getpos; 0 -> putpos if)
           *   exit adr
           *   #);
           * skip: @
           *   (# 
           *   do getpos + 1 -> getpos;
           *      (if getpos=putpos then 0 -> getpos; 0 -> putpos if)
           *   #)
           * length: @(# exit putpos-getpos #);
           *)
          isEmpty: @(# exit (putpos=0) #);
          peek: @(# exit T[getpos+1] #);  (* Allowed when not isEmpty *)
       #);

     FillOrBlock: @
       (# TryToFillBuffer: @
            (# read: external
                 (# fd, bufptr, nbytes, bytesread: @Integer;
                 enter (fd, bufptr, nbytes)
                 exit bytesread
                 #);
               len: @Integer;
               
            do MaxReadAhead -> Buffer.expand;
               (fd, Buffer.getPutAdr, Buffer.getFreeSpace)->read->len;
               (if len>0 then
                   len->Buffer.AddedBytes;
                else
                   (if len=0 then 
                       true->isClosed;
                    else
                       (* Blocked, but not closed *)
                       (* Maybe need to check errno here? *)
                   if);
               if);              
            #);
          
       do check: 
            (if (not isClosed) and Buffer.isEmpty then 
                TryToFillBuffer;
                (if (not isClosed) and Buffer.isEmpty then
                    state.block;
                    restart check;
                if)
            if);
       #);
     
     init: 
       (# getStandardInNonBlock: external (# fd: @Integer exit fd #);
       do getStandardInNonBlock -> fd;
          (if fd<0 then
              'Warning: Could not get nonblocking stdin'->screen.putLine;
              0->fd;
          if);
          fd -> state.AddReadFD;
       #);
     Eos::<
       (# 
       do FillOrBlock;
          isClosed->value;
       #);
     OtherError::< (#do 'BasicSystemEnv keyboard error'->msg.puttext #);
     Put::< 
       (# 
       do 'Warning: attempt to Put to the Keyboard' -> screen.putline; 
       #);
     Get::<
       (# 
       do FillOrBlock;
          (if not isClosed then
              Buffer.get -> ch
          if)
       #);
     Peek::<
       (#
       do FillOrBlock;
          (if not isClosed then
              Buffer.peek -> ch;
          if);
       #);
     GetLine::
       (# putT: ^text.put;
          putall: @ScanToNl(# do ch->putT #);
       do (* FIXME: this should be done more efficiently *)
          &txt.put[]->putT[]; putall;
       #);
  #);

--- installKeyboard:descriptor ---
(# kb: ^SystemEnvKeyboard;
do
   &SystemEnvKeyboard[] -> kb[] -> keyboard[]; 
   kb.init;
#)

--- BasicSystemEnvMDPriv:descriptor ---
(# 
   (* PIO
    * ===
    * 
    * pio implements UNIX non-blocking socket and pipe I/O *)
   
   pioinsert: @
     (# elm: ^IOmask;
        doInnerP: 
          (# elm: ^IOmask; 
          enter elm[]
          do INNER
          #);
        doInner: ^doInnerP;
     enter elm[]
     do 
        (if (piosize+1 -> piosize) > piotable.range then
            piotable.range -> piotable.extend;
        if);
        elm[] -> piotable[piosize][];
        (if doInner[]<>NONE then elm[] -> doInner if);
     #);
   piodelete: @
     (# elm: ^IOmask;
        doInnerP: 
          (# elm: ^IOmask;
          enter elm[]
          do INNER
          #);
        doInner: ^doInnerP;
     enter elm[]
     do 
        find:
          (for i:piosize repeat
               (if piotable[i][]=elm[] then
                   piotable[piosize][] -> piotable[i][];
                   NONE -> piotable[piosize][];
                   piosize-1-> piosize;
                   (if doInner[]<>NONE then elm[] -> doInner if);
                   leave find;
               if);
          for);
     #);
   piosize: @Integer;
   piotable: [8]^IOmask;
   
   pioPrivate: @<<SLOT pioPrivate:descriptor>>;
   
   check: @
     (* check handles pending I/O and makes the process sleep if 
      * there is currently nothing to do. *)
     (# pendingList:
          (# fds: [5]@Integer;
             ioms: [5]^IOmask;
             last: @Integer;
             
             append: @
               (# fd: @Integer;
                  iom: ^IOmask;
               enter (fd,iom[])
               do 
                  (if (last + 1 -> last) > fds.range then
                      5 -> fds.extend;
                      5 -> ioms.extend;
                  if);
                  fd -> fds[last];
                  iom[] -> ioms[last][];
               #);
             
             cont: 
               (# iom: ^IOmask; fd: @Integer;
               do (for i: last - 1 repeat
                       (if fds[i] >= 0 then
                           ioms[i][] -> iom[];
                           fds[i] -> fd;
                           INNER;
                       if);
                       NONE -> ioms[i][];
                  for);
                  0 -> last;
               #);
          #);
        
        readers: @pendingList
          (# continue: @cont 
               (# do (fd,pioReadReady) -> iom.continue #)
          #);
        writers: @pendingList
          (# continue: @cont 
               (# do (fd,pioWriteReady) -> iom.continue #)
          #);
        excepters: @pendingList
          (# continue: @cont 
               (# do (fd,pioException) -> iom.continue #)
          #);
        
        readyCount: @Integer;
        
        sec, usec: @Integer;
        
        scanPending: @
          (# cur: ^IOmask;
          do 
             (for i: piosize repeat
                  piotable[i][] -> cur[];
                  cur.scan
                  (# 
                  do
                     (if read then 
                         (curFD,cur[]) -> readers.append 
                     if);
                     (if write then 
                         (curFD,cur[]) -> writers.append 
                     if);
                     (if except then 
                         (curFD,cur[]) -> excepters.append 
                     if);
                  #);
             for)
          #);
        
        done: @Boolean;
        time: @Real;
     do doCheck:
          (if piosize=0 then 
              
              (if active.size=0 then
                  (* Nobody is active and there is no pending IO. 
                   * If nobody is sleeping we have a deadlock. *)
                  (if sleeping.size=0 then
                      (if blockedCount=0 then
                          true -> done; leave doCheck;
                       else
                          deadlocked;
                      if);
                   else
                      
                      (*** sleeping.firstDue -> ExtsleepUntil; ***)
                  if);
              if);
              
           else
              scanPending;
              
              (if active.size=0 then
                  (* Nobody is active so we can block until the first 
                   * sleeper is due or until some pending IO should
                   * be awakened. *)
                  
                  (if sleeping.size=0 then
                      (* Nobody is sleeping. We can wait foreever on pending
                       * IO. *)
                      -1 -> sec -> usec;
                   else
                      (if (sleeping.firstDue - secondCounter -> time) <= 0 then
                          0 -> sec -> usec
                       else
                          time->sec; (time-sec)*1000000->usec;
                      if);
                  if);
                  
               else
                  (* Someone else is active. Only do a poll. *)
                  0 -> sec -> usec;
              if);
              
              (* 'selectSockets' expect -1 terminated integer arrays: *)
              (-1,none) -> readers.append; 
              (-1,none) -> writers.append;
              (-1,none) -> excepters.append;
              
              0 -> sec -> usec;
              (@@readers.fds[1], @@writers.fds[1], @@excepters.fds[1], 
              sec, usec) -> selectSockets -> readyCount;
              
              (* Signal ready readers and writers. *)
              readers.continue;
              writers.continue;
              excepters.continue;
          if)
     exit done   
     #);
   
#)

--- secondCounterBody:dopart ---
do getTimeAsDouble -> now
   
--- basicsystemenv_objToComp:doPart ---
do O[]->objectToComponent->S[];
