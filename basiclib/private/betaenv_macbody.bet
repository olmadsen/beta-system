ORIGIN 'betaenvbody';
MDBODY default 'console_macbody';
OBJFILE default '$/betaenv_macbody.c.o';
RESOURCE default 'external/betaenv_macbody.rsrc';

-- betaenvbodyMDInitAscii: Descriptor --
(* initialize upCase and lowCase *)
  (# 
     UClc: @
       (# UC,lc: @integer
       enter (UC,lc)
       do UC->private.UPCASE[lc]; lc->private.lowCase[UC]; 
       #)
  do
     (128,138)->UClc;
     (* swedish ae *)
     (129,140)->UClc;
     (* danish aa *)
     (130,141)->UClc;
     (* french c *)
     (131,142)->UClc;
     (* french e *)
     (132,150)->UClc;
     (* strange n *)
     (133,154)->UClc;
     (* swedish o *)
     (134,159)->UClc;
     (* german U *)
     (174,190)->UClc;
     (* danish ae *)
     (175,191)->UClc;
     (* danish oe *)
     (202,32)->UClc;
     (* nonbreaking space *)
     (203,136)->UClc;
     (* funny french a *)
     (204,139)->UClc;
     (* funny french a *)
     (205,155)->UClc;
     (* funny french o *)
     (206,207)->UClc;
     (* french ae *)
     (* Initialize private.NonWhiteSpace. Offsett by one to allow test for
      * isNonWhiteSpace(0)
      *)
     (* From '!'(33) to '~'(126) is NonWhiteSpace *)
     (for ch: (126-33+1) repeat true->private.NonWhiteSpace[ch+33] for);
     (* From <inverted exclamation>(161) to <y umlaut>(255) is NonWhiteSpace 
      * in Macintosh ASCII table
      *)
     (for ch: (255-161+1) repeat true->private.NonWhiteSpace[ch+161] for);
     
  #)  

-- betaenvInitEnv: Descriptor --
(# 
   MPWScreen: Stream
     (# 
        Eos::< (# do False->value #);
        OtherError::< (# do 'OtherError in Screen '->msg.puttext #);
        Put::<
          (# PutToScreen: External (# ch: @integer enter ch do CallC #); 
          do ch->PutToScreen; 
          #);
        Get::<
          (# 
          do 'Warning: attempt to Get from the Screen'->screen.putline; 
          #);
        PutText::<
          (# PutTextToScreen: External (# t: @integer enter t #); 
          do
             (if txt.lgth > 0 then
                 (if txt.lgth < txt.T.range then 0->txt.T[txt.lgth+1] if);
                 @@ txt.T[1]->PutTextToScreen;
                 
             if)
          #);
        
     #);
   MPWKeyBoard: Stream
     (# 
        Eos::<
          (# 
             KeyboardEOS: External (# yes: @boolean do CallC exit yes #); 
          do KeyboardEOS->value; 
          #);
        OtherError::< (# do 'Keyboard error'->msg.puttext #);
        Get::<
          (# 
             GetFromKeyboard: External (# ch: @char;  do CallC exit ch #);
             
          do GetFromKeyboard->ch; 
          #);
        Peek::<
          (# KeyboardPeek: External (# ch: @char do CallC exit ch #)
          do KeyboardPeek->ch
          #);
        Put::<
          (# 
          do 'Warning: attempt to Put to the Keyboard'->screen.putline; 
          #);
        
     #);
   getStandAlone: external
     (# isRunningAlone: @integer do callC exit isRunningAlone #);
   
do
   ascii.init;
   ascii.cr->ascii.newLine;
   (if getStandAlone = 1 then
       <<SLOT StartConsole:Descriptor>>; 
    else
   (* a MPW tool *)
       &MPWScreen[]->screen[];
       &MPWKeyBoard[]->keyboard[];
       
   if)
#)  

-- betaenvTerminateEnv: Descriptor --
(# do TerminateConsole #)  

-- betaenvbodyTerminateConsole: Descriptor --
(# do TerminateConsole #)  

-- LIB: Attributes --
TerminateConsole: <<SLOT DoTerminateConsole:Descriptor>>  

