ORIGIN 'betaenvbody';
MDBODY  default 'console_macbody';

BUILD default ':$$:betaenv_ppc.obj' ':external:betaenv_ppc.c' 'mrc -proto strict -proto auto -o $0 $1';
BUILD default ':$$:basicio.obj' ':external:basicio.c' 'mrc -proto strict -proto auto -o $0 $1';

RESOURCE default 'external/betaenv_ppcbody.r'
-- betaenvbodyMDInitAscii: descriptor -- (* initialize upCase and lowCase *)
 (# UClc : @
	(# UC,lc : @integer
	enter (UC,lc)
	do UC -> private.UPCASE[lc]; lc -> private.lowCase[UC];
	#)
 do  (128,138) -> UClc; (* swedish ae *)     
	 (129,140) -> UClc; (* danish aa *)
	 (130,141) -> UClc; (* french c *)
	 (131,142) -> UClc; (* french e *)
	 (132,150) -> UClc; (* strange n *)
	 (133,154) -> UClc; (* swedish o *)     
	 (134,159) -> UClc; (* german U *)
	 (174,190) -> UClc; (* danish ae *)
	 (175,191) -> UClc; (* danish oe *)
	 (202, 32) -> UClc; (* nonbreaking space *)
	 (203,136) -> UClc; (* funny french a *)
	 (204,139) -> UClc; (* funny french a *)
	 (205,155) -> UClc; (* funny french o *)
	 (206,207) -> UClc; (* french ae *)
   (* Initialize private.NonWhiteSpace. Offsett by one to allow test for
    * isNonWhiteSpace(0)
    *)
   (* From '!'(33) to '~'(126) is NonWhiteSpace *)
   (for ch: (126-33+1) repeat true->private.NonWhiteSpace[ch+33] for);
   (* From <inverted exclamation>(161) to <y umlaut>(255) is NonWhiteSpace 
    * in Macintosh ASCII table
    *)
   (for ch: (255-161+1) repeat true->private.NonWhiteSpace[ch+161] for);
 #)

--betaenvinitEnv: descriptor--
   (# 
      MPWScreen: Stream (* A standard MPW screen *)
      (# Eos::< (#do False -> value #);
         OtherError::< (# do 'OtherError in Screen ' -> msg.puttext #);
         Put::< 
           (# PutToScreen: External(# ch: @integer enter ch do CallC #);
           do ch -> PutToScreen;
           #);
         Get::
          (# 
          do 'Warning: attempt to Get from the Screen' -> screen.putline; 
          #);
		 PutText:: (* For efficiency reasons. *)
           (# PutTextToScreen: External(# t: @integer enter t #);
           do (if Txt.lgth > 0 then
                 (if Txt.lgth < Txt.T.range then 0 -> Txt.T[Txt.lgth+1] if);
                 @@Txt.T[1]->PutTextToScreen;
             if)
           #);
      #);

      MPWKeyBoard: Stream (* A standard MPW keyboard *)
      (#
         Eos::
           (# KeyboardEOS: External (# yes: @boolean do CallC exit yes #);
           do KeyboardEOS -> value;
            #);
         OtherError:: (# do 'Keyboard Error'->msg.puttext #);
         Put::
          (# 
          do 'Warning: attempt to Put to the Keyboard' -> screen.putline;
          #);
		 Get::
           (# GetFromKeyboard: External (# ch: @char;  do CallC exit ch #);
           do GetFromKeyboard -> ch;
            #);
	     Peek::
	       (# KeyboardPeek: External(# ch: @char do CallC exit ch #)
	       do KeyboardPeek->ch
	       #);
         GetAtom::<
           (# KeyboardPeek: External(# ch: @char do CallC exit ch #);
	          GetFromKeyboard: External(# ch: @char do CallC exit ch #);
           do skipBlanks:
                (if KeyboardPeek->ascii.isWhiteSpace then
                    GetFromKeyboard; restart skipBlanks 
                if);
              scan:
                (if not (KeyboardPeek->ascii.isWhiteSpace) then
                    (if (txt.pos+1->txt.pos) > txt.T.range then txt.T.range+16->txt.T.extend if);
                    GetFromKeyboard->txt.T[txt.pos]; txt.lgth+1->txt.lgth;
                    restart scan
                if)
	       #);
         GetLine::<
           (# KeyboardPeek: External(# ch: @char do CallC exit ch #);
	          GetFromKeyboard: External(# ch: @char do CallC exit ch #);
           do scan:
                (if KeyboardPeek<>ascii.newline then
                    (if (txt.pos+1->txt.pos) > txt.T.range then txt.T.range+16->txt.T.extend if);
                    GetFromKeyboard->txt.T[txt.pos]; txt.lgth+1->txt.lgth;
                    restart scan
                 else GetFromKeyboard
                if)
           #);
       #);

    getStandAlone: external
	  (# isRunningAlone: @integer do callC exit isRunningAlone #);

   do 
      ascii.init;
      ascii.cr -> ascii.newLine;
      (if getStandAlone=1 then 
		  <<SLOT StartConsole: descriptor>>;
	   else
	      (* a MPW tool *)
		  &MPWScreen[] -> screen[]; 
		  &MPWKeyBoard[] -> keyboard[];
	  if)
   #)

-- betaenvterminateEnv: descriptor --
    (# do TerminateConsole #)

-- betaenvBodyTerminateConsole: descriptor --
    (# do TerminateConsole #)

-- LIB: attributes --

TerminateConsole: <<SLOT DoTerminateConsole: descriptor>>
