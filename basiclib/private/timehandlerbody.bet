ORIGIN '../timehandler';
INCLUDE 'basicsystemenvbody'
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1984-95
 *       All rights reserved.
 *
 *)

--- timeHandlerPrivate:descriptor --- 
(# 
   element: cyclicElm
     (# id: @Integer;
        obj: ^Object;
        sys: @| System (# do id -> punregister; obj #);
     #);
   
   timers: [5]^element;
   last: @Integer;
   
   nextId: @Integer;
   
   pregister: @
     (# reg: ^register;
        new: ^element;
     enter reg[]
     do 
        &element[] -> new[];
        nextId+1 -> nextId -> reg.id -> new.id;
        reg.obj[] -> new.obj[];
        (if (last+1 -> last) > timers.range then
            timers.range -> timers.extend;
        if);
        new[] -> timers[last][];
        new.sys[] -> new.s[];
        
        SE_SLEEPING -> new.sys.shstatus;
        private.sleeping[] -> new.sys.q[];
        new[] -> new.sys.ce[];
        
        (new[], reg.time) -> private.sleeping.putSleeper;
     #);
   
   punregister: @
     (# id: @Integer; timeOut: @Boolean;
     enter id
     do
        find: 
          (for i:last repeat
               (if timers[i].id=id then
                   (if timers[i].due<>0 then
                       (* Still in sleepingQueue. *)
                       timers[i][] -> private.sleeping.delete;
                       (* Do not use sleeping.remove. We do not want these
                        * elements to end up in the freelist. *)
                   if);
                   timers[last][] -> timers[i][];
                   none -> timers[last][];
                   last-1 -> last;
                   leave find;
               if);
          for);
     #);
   
   pinit: 
     (# 
     #);
   
#)

--- timeHandlerRegister:dopart ---
do THIS(register)[] -> timeHandlerPrivate.pregister

--- timeHandlerUnregister:dopart ---
do id -> timeHandlerPrivate.punregister

--- timeHandlerInit:dopart ---
do timeHandlerPrivate.pinit
   
