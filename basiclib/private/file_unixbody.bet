ORIGIN  'file_stdbody';
LIB_ITEM 'file';
INCLUDE '~beta/unixlib/unixinterface';
BUILD default '$$/fileInt_unix.o' 'external/fileInt_unix.c' '$CC -D$$ -c -o $0 $1';
(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1986-96
 *       All rights reserved.
 *
 * This fragment group is the UNIX dependent implementation of files.
 * It uses a lot of calls to external C-routines from UNIX.
 *)

--LIB:attributes--

trace_open:
  (# exit false #);

readMode: External
  (# result: @integer;
  do CallC
  exit result
  #);

writeCreateMode: External
  (* Open for writing, create if not existing *)
  (# result: @integer;
  do CallC
  exit result 
  #);

readWriteCreateMode: External
  (* Open for reading and  writing, create if not existing *)
  (# result: @integer;
  do CallC
  exit result
  #);

appendCreateMode: External
  (* Open for writing at the end, create if not existing *)
  (# result: @integer;
  do CallC
  exit result
  #);

readAppendCreateMode: External
  (* Open for reading and writing writing at the end, create if not existing *)
  (# result: @integer;
  do CallC
  exit result
  #);

noExecPerm: External
  (* Denotes creation of a file with read and write permission to all,
   * qua what is prevented by the current "umask".
   * Nobody is given execute permission to the file.
   *)
  (# result: @integer;
  do CallC
  exit result
  #);

execPerm: External
  (* Denotes creation of a file with read, write and exec permission to all,
   * qua what is prevented by the current "umask".
   *)
  (# result: @integer;
  do CallC
  exit result
  #);

EOFpeek: External
  (# unixStream: @integer;
     eof: @boolean;
  enter unixStream
  do CallC
  exit eof
  #);

deleteUnixFile: External
  (# path: [1]@char;
     status: @integer; (* -1 => error *)
  enter path
  exit status
  #);

createUnixFile: External
  (# path: [1]@char;
     status: @integer; (* -1 => error *)
  enter path
  exit status
  #);

renameUnixEntry: External
  (# newPath,oldPath: [1]@char;
     status: @integer; (* -1 => error *)
  enter(oldPath,newPath)
  exit status
  #);

chownUnixEntry: External
  (# path: [1]@char;
     uid, gid: @integer;
     status: @integer; (* -1 => error *)
  enter(path,uid,gid)
  exit status
  #);

(* Operations for abtaining information about and manipulating
 * individual entries.
 * The entries are named by their absolute path
 *)

entryExists: External
  (# path: [1]@char;
     followlinks: @boolean;
     status: @integer; (* -1 => error, 1 => exists, 0 => non-existing *)
  enter (path, followlinks)
  exit status
  #);

touchEntry: External
  (# path: [1]@char;
     status: @integer; (* -1 => error *)
  enter path
  exit status
  #);

isEntryDir: External
  (# path: [1]@char;
     follow: @boolean;
     isdir: @integer; (* -1 => error *)
  enter (path,follow)
  exit isdir
  #);
isEntryFile: External
  (# path: [1]@char;
     follow: @boolean;
     isfile: @integer; (* -1 => error *)
  enter (path,follow)
  exit isfile
  #);
getEntrySize: External
  (# path: [1]@char;
     follow: @boolean;
     size: @integer; (* -1 => error *)
  enter (path,follow)
  exit size
  #);
getEntryModtime: External
  (# path: [1]@char;
     follow: @boolean;
     time: @integer; (* -1 => error *)
  enter (path,follow)
  exit time
  #);
setEntryModtime: External
  (# path: [1]@char;
     time: @integer;
     status: @integer; (* -1 => error *)
  enter (path,time)
  exit status
  #);

changeProtection: External
  (# path: [1]@char;
     protectionBuffer: @integer; (* Start address of int-rep *)
     status: @integer; (* -1 => error *)
  enter(path,protectionBuffer)
  exit status
  #);

makeSymLink: External
  (* Make src point to dst. exits -1 if an error occurred *)
  (# src, dst: [1]@char;
     status: @integer;
     enter (src,dst)
  exit status
  #);

access: External
  (# path: [1]@char;
     mode: @integer;
     result: @integer;
  enter (path, mode)
  exit result
  #);

F_OK: (# exit 0 #);
R_OK: (# exit 4 #);
W_OK: (# exit 2 #);
X_OK: (# exit 1 #);

--DiskEntryException: dopart-- 
do 'Disk entry exception for \''->msg.puttext;
   path -> msg.puttext;
   '\''->msg.putline;
   'Error in system call: ' -> msg.puttext;
   getErrno -> errorstring -> msg.putline;
   INNER;

--DiskEntryPrivate: descriptor--
(# path: @text;
   pathchanged: @boolean;
   head, name, main, suf: ^text;
   follow: @boolean;
   followset: @boolean;
   checkfollow: 
     (# do (if not private.followset then true -> follow -> followset; if) #);
   decomposepath: 
     (# lastInx,len: @integer;
     do (if pathchanged then
	    (* decompose path *)
	    0->lastInx;
            path.lgth -> len;
            (* Search for last '/', ignoring a possible trailing one *)
            '/' -> path.findAll(# do (if inx<len then inx -> lastInx if) #);
	    (if lastInx=0 then
                (* no '/' found (except possible trailing one) *)
                path.copy -> name[];
                (if (len=1) and (path.T[1]='/') then
                    (* path was '/' treat specially on UNIX *)
                    '/' -> head[];
                 else
                    &text[]->head[];
                if);
	     else
                &text[]->name[];
                path.t[lastInx+1:len] -> name;
                (if lastInx=1 then
                    (* Only one '/' found, and this was at start of path.
                     * I.e. it is either '/foo' or '/foo/'.
                     * In both cases head='/' on UNIX.
                     *)
                    '/'->head[];
                 else
                    &text[]->head[];
                    path.t[1:lastInx-1] -> head;
                if);
	    if);
            (* Delete possible trailing '/' in name *)
            (if (name.lgth>1) and (name.t[name.lgth]='/') then 
                name.lgth-1->name.lgth->name.pos;
            if);
            
	    (* decompose name *)
            0->lastInx;
	    '.' -> name.findAll(# do inx -> lastInx #);
            &text[]->suf[];
	    (if lastInx=0 then 
                name.copy -> main[];
	     else
                &text[]->main[];
		name.t[1:lastInx-1] -> main;
		name.t[lastInx:name.lgth] -> suf;
	    if);
	    false -> pathchanged
	if);
     #);
#)

--DiskEntryPathHead: dopart--
do INNER; &text[]->h[]; private.decomposepath; private.head -> h 

--DiskEntryPathNamePref: dopart--
do INNER; &text[] -> p[]; private.decomposepath; private.main -> p

--DiskEntryPathNameSuf: dopart--
do INNER; &text[]->s[]; private.decomposepath; private.suf -> s

--DiskEntryPathNameExt: dopart--
do INNER;
   &text[]->e[]; 
   private.decomposepath; 
   private.suf.t[2:private.suf.length] -> e

--DiskEntryPathNameGet: dopart--
do INNER; &text[]->n[]; private.decomposepath; private.name -> n

--DiskEntryPathSet: dopart--
do INNER;
   (if p[]=NONE then &text[]->p[] if);
   p -> private.path;
   true -> private.pathchanged;
   private.checkfollow;

--DiskEntryPathGet: dopart--
do INNER; &text[]->p[]; private.path -> p

--DiskEntryExists: dopart--
do private.checkfollow;
   (if ((private.path, private.follow) -> entryExists)
    // 0  then false -> value;
    // 1  then true -> value;
    // -1 then error;
   if);

--DiskEntryTouch: dopart--
do INNER;
   (if (private.path -> touchEntry)=-1 then error if);
   
--DiskEntrySize: dopart--
do private.checkfollow;
   (if ((private.path, private.follow) -> getEntrySize -> value) = -1 then
       error
   if);

--DiskEntrySetModTime:dopart--
do (if ((private.path,time) -> setEntryModtime)=-1 then error if);
   
--DiskEntryGetModTime:dopart--
do private.checkfollow;
   (if ((private.path, private.follow) -> getEntryModtime -> time) = -1 then
       error
   if);

--DiskEntryRename: dopart--
do (if newpath[]=NONE then &text[]->newpath[] if);
   private.checkfollow;
   (if ((private.path, private.follow) -> entryExists) <> 1 then
       error
    else
       (if ((private.path, newpath) -> renameUnixEntry) = -1 then error
        else newpath -> private.path;
       if);
   if);

--DiskEntryReadable: dopart--
do (((private.path, R_OK) -> access) = 0) -> value

--DiskEntryWriteable: descriptor--
(# dir: @text;
do (if ((private.path, F_OK) -> access) = 0 then (* File exists *)
       (((private.path, W_OK) -> access) = 0) -> value
    else
       (* file does not exist; check if it can be created *)
       private.decomposepath; 
       private.head -> dir;
       (if dir.length=0 then '.' -> dir if);
       (((dir, W_OK + X_OK) -> access) = 0) -> value
   if)
#)

--DiskEntryIsDir: dopart--
do private.checkfollow;
   (if ((private.path, private.follow) -> isEntryDir)
    // -1 then error
    // 0 then false -> value
    // 1 then true -> value
   if);
   
--DiskEntryIsFile: dopart--
do private.checkfollow;
   (if ((private.path, private.follow) -> isEntryFile)
    // -1 then error
    // 0 then false -> value
    // 1 then true -> value
   if);

--FilePrivate:descriptor--
(# outputFile: @boolean; (* True iff this file is opened for writing. *)
   unixStream: @integer; (* UNIX FILE (cf. stdio.h)  pointer for file. *)
   UnixErrNo (* may contain UNIX variable 'errno'*) : @ integer; 
   index: @integer; (* The UNIX filedescriptor index *)
   
   ProcessError:
     (# msg: ^text
     enter msg[]
     do (if (getErrno->UnixErrNo)
	 // EPERM// EACCESS then msg[]->AccessError
	 // ENOENT then msg[]->NoSuchFileError
	 // EEXIST then msg[]->FileExistsError
	 // ENOSPC then msg[]->NoSpaceError
	 else
	    INNER
	if);
     #);
   
   SetUpUnixStream:
     (# type: @text;
     enter type
     do
	(if index>=0 then
	    (if ((index,type) -> fdopen -> unixStream) = 0 then
		processError(# do OtherError #);
	    if);
	if)
     #);
#)

--FileOtherException: dopart--
do 'Error in system call: ' -> msg.puttext;
   getErrno -> errorstring -> msg.putline;
   INNER

--FileTouch: dopart--
do entry.private.checkfollow;
   (if ((entry.private.path, entry.private.follow) -> entryExists) 
    // -1 then error;
    // 1 then (* entry exists - raise error if it is a directory *)
       (if ((entry.private.path, entry.private.follow) -> isEntryDir) = 1 then
           error;
       if)
    // 0 then
       (if (entry.private.path -> createunixfile) = -1 then error if);
   if);
   INNER;

--FileLength: dopart--
do entry.size -> value

--FileDoOpen:descriptor--
(# open:External
     (# mode,permission,index: @integer; name: [1]@char
     enter(name,mode,permission)
     do CallC
     exit index
     #);

do (if trace_open then
       'File.open: ' -> screen.puttext; entry.path->screen.puttext; ', mode='->screen.puttext; mode->screen.putint; screen.newline;
   if);
   (if exe then 
       (name,mode,execPerm)   -> open -> private.index
    else 
       (name,mode,noExecPerm) -> open -> private.index;
   if);
   (if private.index<0 then 
       private.processError(# do OtherError #);
   if);
#)

--FileOpenRead:dopart--
do INNER;
   (entry.private.path[], ReadMode,false) -> doOpen;
   (if private.index>=0 then 'r' -> private.SetUpUnixStream; if);

--FileOpenWrite:dopart--
do INNER;
   (entry.private.path[], WriteCreateMode,false) -> doOpen;
   (if private.index>=0 then 
       true -> private.outputFile; 
       'w' -> private.SetUpUnixStream
   if);
   
--FileOpenReadWrite:dopart--
do INNER;
   (entry.private.path[], readWriteCreateMode,false) -> doOpen;
   (if private.index>=0 then 
       true -> private.outputFile;
       'r+' -> private.SetUpUnixStream;
   if);
   
--FileOpenAppend:dopart--
do INNER;
   (entry.private.path[], appendCreateMode,false) -> doOpen;
   (if private.index>=0 then 
       true -> private.outputFile;
       'a' -> private.SetUpUnixStream;
   if);
   
--FileOpenReadAppend:dopart--
do INNER;
   (entry.private.path[], readAppendCreateMode,false) -> doOpen;
   (if private.index>=0 then 
       true -> private.outputFile;
       'a+' -> private.SetUpUnixStream;
   if);
   
--FileDelete:dopart--
do (if (entry.private.path ->&unlink)<0 then
       'Cannot delete file'->private.processError(#do msg[]->&OtherError#)
   if);
   INNER;

--FilePut:dopart--
do INNER put;
   (if ((ch,private.unixStream)->fputc)=EOFvalue then 
       private.processError(# do WriteError #)
   if);

--FileGet:dopart--
do private.unixStream -> fgetc -> ch;
   (if ch=EOFvalue then   (* Either a read error or simply end of file. *)
       (if private.unixStream -> EOFfunction then
	   EOSError;
	else
	   ReadError;
       if);
   if);
   INNER get

--FilePeek:dopart--
do private.unixStream -> fgetc -> ch;
   (if ((ch,private.unixStream) -> ungetc)=EOFvalue 
       then   (* Either a read error or simply end of file. *)
       (if private.unixStream -> EOFfunction then
	   EOSError;
	else
	   ReadError;
       if);
   if);
   INNER peek
   
--FilePutText:dopart--
do INNER puttext;
   (if txt.lgth > 0 then
       (if txt.lgth < txt.T.range then 0 -> txt.T[txt.lgth+1] if);
       (if ((@@txt.T[1],private.unixStream)->fputs) = EOFvalue then
           private.processError(# do WriteError #);
       if);
   if);

--FileGetAtom:dopart--
do (private.unixStream,false) -> GetStringFromFile-> txt;
   INNER getAtom

--FileGetLine:dopart--
do (private.unixStream,true) -> GetStringFromFile -> txt;
   (if EofInGetStringFromFile then missing_newline if);
   INNER getline
   
--FileGetPos:dopart--
do private.unixStream -> ftell -> value; INNER getpos
   
--FileSetPos:dopart--
do INNER setpos;
   (private.unixStream,p,mode) -> fseek -> newpos;      (* Ignore status. *)
   private.unixStream -> ftell -> newpos;  (* Get resulting absolute pos. *)
   
--FileEos:dopart--
do private.unixStream -> EOFpeek -> value;

--FileFlush:dopart--
do INNER;
   (if private.OutputFile then
       (if (private.unixStream->fflush)=EOFvalue then 
           'Cannot flush file'->private.processError(#do msg[]->&OtherError#) 
       if);
   if);

--FileClose:dopart--
do (if trace_open then
       'File.close: ' -> screen.puttext; entry.path->screen.putline;
   if);
   INNER;
   (* Position file at end; some unix'es (e.g. SGI) truncate
    * rest of file at close, if pos is not at end.
    *)
   (private.unixStream,0,FromEnd) -> fseek;
   (* Close the file *)
   (if (private.unixStream->fclose)=EOFvalue then 
       'Cannot close file'->private.processError(#do msg[]->&OtherError#) 
   if);
   (* Note that the fclose call closes both the unixStream and the
    * filedescriptor (private.index). 
    *)


