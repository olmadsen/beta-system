ORIGIN  'filebody';
INCLUDE '~beta/javalib/betahelpers';
INCLUDE '~beta/javalib/java/io/File';
INCLUDE '~beta/javalib/java/util/Date';
INCLUDE '~beta/javalib/java/io/RandomAccessFile';
INCLUDE '~beta/javalib/java/lang/System';

INCLUDE 'betaenv_jvmbody';
(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1986-96
 *       All rights reserved.
 *
 * This fragment group is the JVM dependent implementation of files.
 *)

(************************ DISKENTRY: ****************************) 

-- DiskEntryLib: attributes --
getParentDir:
  (# pjf: ^JavaFile
  do private.jfile.getParentFile -> pjf[];
     (if pjf[]=NONE then
         (* File.getParent can return NONE when the file is specified without
          * a directory.
          *)
         (if (private.jfile.isAbsolute) then
             (*JavaFile.separator*) 
             'directory.separator' -> System.getProperty_String -> JavaFile._init_String -> pjf[]
          else
             'user.dir' -> System.getProperty_String -> JavaFile._init_String -> pjf[]
         if);
     if);
  exit pjf[]
  #);

--DiskEntryException: dopart-- 
do 'Disk entry exception for \''->msg.puttext;
   path -> msg.puttext;
   '\''->msg.putline;
   'Error in system call: ' -> msg.puttext;
   (*getErrno -> errorstring -> msg.putline;*)
   INNER;

--DiskEntryPrivate: descriptor--
(# path: @text;
   jfile: ^JavaFile;
   
   pathchanged: @boolean;
   head, name, main, suf: ^text;
   
   decomposepath: 
     (# lastInx,len: @integer;
     do (if pathchanged then
	    (* decompose path *)
	    0->lastInx;
            path.lgth -> len;
            (* Search for last '/', ignoring a possible trailing one *)
            '/' -> path.findAll(# do (if inx<len then inx -> lastInx if) #);
            (if lastInx=0 then
                (* '/' not found. Try '\' instead *)
                '\\' -> path.findAll(# do (if inx<len then inx -> lastInx if) #);
            if);
	    (if lastInx=0 then
                (* no '/' or '\\' found (except possible trailing one) *)
                path.copy -> name[];
                (if (len=1) and (path.T[1]='/') then
                    (* path was '/' treat specially on UNIX *)
                    '/' -> head[];
                 else
                    &text[]->head[];
                if);
	     else
                &text[]->name[];
                path.t[lastInx+1:len] -> name;
                (if lastInx=1 then
                    (* Only one '/' found, and this was at start of path.
                     * I.e. it is either '/foo' or '/foo/'.
                     * In both cases head='/' on UNIX.
                     *)
                    '/'->head[];
                 else
                    &text[]->head[];
                    path.t[1:lastInx-1] -> head;
                if);
	    if);
            (* Delete possible trailing '/' in name *)
            (if (name.lgth>1) and (name.t[name.lgth]='/') then 
                name.lgth-1->name.lgth->name.pos;
            if);
            
	    (* decompose name *)
            0->lastInx;
	    '.' -> name.findAll(# do inx -> lastInx #);
            &text[]->suf[];
	    (if lastInx=0 then 
                name.copy -> main[];
	     else
                &text[]->main[];
		name.t[1:lastInx-1] -> main;
		name.t[lastInx:name.lgth] -> suf;
	    if);
	    false -> pathchanged
	if);
     #);

#)

--DiskEntryPathHead: dopart--
do INNER; &text[]->h[]; private.decomposepath; private.head -> h 

--DiskEntryPathNamePref: dopart--
do INNER; &text[] -> p[]; private.decomposepath; private.main -> p

--DiskEntryPathNameSuf: dopart--
do INNER; &text[]->s[]; private.decomposepath; private.suf -> s

--DiskEntryPathNameExt: dopart--
do INNER;
   &text[]->e[]; 
   private.decomposepath; 
   private.suf.t[2:private.suf.length] -> e

--DiskEntryPathNameGet: dopart--
do INNER; &text[]->n[]; private.decomposepath; private.name -> n

--DiskEntryPathSet: dopart--
do INNER;
   (if p[]=NONE then ''->p[] if);
   p -> private.path;
   p[] -> JavaFile._init_String -> private.jfile[];
   true -> private.pathchanged;

--DiskEntryPathGet: dopart--
do INNER; private.path.copy -> p[]

--DiskEntryExists: dopart--
do private.jfile.exists -> value
   
--DiskEntryTouch: dopart--
do INNER; (* Allow File/Directory to create itself *)
   (if private.jfile.exists then
       (Date._init).getTime -> private.jfile.setLastModified;
    else
       private.jfile.createNewFile;
   if);
   
--DiskEntrySize: dopart--
do private.jfile.length -> value

--DiskEntrySetModTime:dopart--
do (* FIXME: missing * for int64 *)
   (time -> BetaHelpers.int2longMul1000) -> private.jfile.setLastModified;
   
--DiskEntryGetModTime:dopart--
do (* FIXME: missing * for int64: *)
   private.jfile.lastModified -> BetaHelpers.long2intDiv1000 -> time
   
--DiskEntryRename: dopart--
do (if newpath[]<>NONE then
       newpath[] -> JavaFile._init_String -> private.jfile.RenameTo;
   if);

--DiskEntryReadable: dopart--
do private.jfile.canRead -> value

--DiskEntryWriteable: descriptor--
(# dir: ^JavaFile
do (if private.jfile.exists then
       private.jfile.canWrite -> value
    else
       getParentDir -> dir[];
       (dir[]<>NONE) 
       and (dir.exists)
       and (dir.isDirectory)
       and (dir.canWrite) -> value
   if)
#)

--DiskEntryIsDir: dopart--
do private.jfile.isDirectory -> value
   
--DiskEntryIsFile: dopart--
do private.jfile.isFile -> value
   
   
 (************************ FILE: ****************************) 

--FilePrivate:descriptor--
(# raf: ^RandomAccessFile;
   i: @integer;
#)

--FileOtherException: dopart--
do 'Error in system call: ' -> msg.puttext;
   (*getErrno -> errorstring -> msg.putline;*) 'FileOtherException' -> NYI;
   INNER

--FileTouch: dopart--
do entry.touch

--FileLength: dopart--
do entry.private.jfile.length -> value

--FileDoOpen:descriptor--
(# (* Not needed *) #)

--FileOpenRead:dopart--
do (entry.private.jfile[], 'r') -> RandomAccessFile._init_File_String -> private.raf[];
   0 -> private.raf.seek; (* position at beginning *)
   
--FileOpenWrite:dopart--
do (entry.private.jfile[], 'rw') -> RandomAccessFile._init_File_String -> private.raf[];
   0 -> private.raf.setLength; (* truncate *)
   
--FileOpenReadWrite:dopart--
do (entry.private.jfile[], 'rw') -> RandomAccessFile._init_File_String -> private.raf[];
   0 -> private.raf.setLength; (* truncate *)

--FileOpenAppend:dopart--
do (entry.private.jfile[], 'rw') -> RandomAccessFile._init_File_String -> private.raf[];
   private.raf.length -> private.raf.seek; (* position at end *)
   
--FileOpenReadAppend:dopart--
do (entry.private.jfile[], 'rw') -> RandomAccessFile._init_File_String -> private.raf[];
   private.raf.length -> private.raf.seek; (* position at end *)
   
--FileDelete:dopart--
do entry.private.jfile.delete

--FilePut:dopart--
do ch -> private.raf.write_I; 

--FileGet:dopart--
do private.raf.read -> ch;

--FilePeek:dopart--
do private.raf.read -> ch;
   (private.raf.getFilePointer->BetaHelpers.long2int) - 1
     -> private.raf.seek;
   
--FilePutText:dopart--
do txt[] -> private.raf.writeBytes

--FileGetAtom:dopart--
do (* Could probably use a FileTokenizer *)
   private.raf.read -> private.i;
   skipBlanks:
     (if private.i<> -1 then
           (if private.i->ascii.isWhiteSpace then
               private.raf.read -> private.i;
               restart skipBlanks;
            else
               scan:
                 (* atom not yet complete *)
                 (if txt.pos+1 > txt.T.range then
                     txt.T.range+16->txt.T.extend;
                     restart scan;
                  else
                     txt.pos+1->txt.pos;
                     private.i ->txt.T[txt.pos]; 
                     txt.lgth+1->txt.lgth;
                     (if private.i = -1 then
                         (* End of file - stop here *)
                      else
                         (if private.raf.read -> private.i ->ascii.isWhiteSpace then
                             (* end of atom - unread the whitespace and stop *)
                             (private.raf.getFilePointer->BetaHelpers.long2int) - 1
                               -> private.raf.seek;
                          else
                             restart scan;
                         if)
                     if)
                 if);
           if);
      else 
         (* EOF while skipping blanks *)
     if)

--FileGetLine:dopart--
do private.raf.readline -> txt[]
   
--FileGetPos:dopart--
do private.raf.getFilePointer -> value
   
--FileSetPos:dopart--
do INNER setpos;
   (if mode 
    // FromBeginning then p -> private.raf.seek
    // FromCurrent then
       p-(private.raf.getFilePointer->BetaHelpers.long2int) -> private.raf.seek
    // FromEnd then
       (private.raf.length->BetaHelpers.long2int) - p -> private.raf.seek
   if);
   private.raf.getFilePointer -> newpos (* Get resulting absolute pos. *)
   
--FileEos:dopart--
do (private.raf.getFilePointer->BetaHelpers.long2int) 
   = (private.raf.length->BetaHelpers.long2int)
     -> value;
   
--FileFlush:dopart--
do 'FileFlush' -> NYI;

--FileClose:dopart--
do private.raf.close;
   NONE -> private.raf[];
