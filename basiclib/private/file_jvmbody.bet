ORIGIN  'filebody';
INCLUDE '~beta/javalib/betahelpers';
INCLUDE '~beta/javalib/java/io/File';
INCLUDE '~beta/javalib/java/util/Date';
INCLUDE '~beta/javalib/java/io/PushbackInputStream';
INCLUDE '~beta/javalib/java/io/FileInputStream';
INCLUDE '~beta/javalib/java/io/PrintStream';
INCLUDE '~beta/javalib/java/io/FileOutputStream';

INCLUDE 'betaenv_jvmbody';
(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1986-96
 *       All rights reserved.
 *
 * This fragment group is the JVM dependent implementation of files.
 *)

--FileLib:attributes--
ensure_channel: booleanValue
  (# 
  do (if private.fc[]=NONE then
       (if private.fos[]<>NONE then
           private.fos.getChannel -> private.fc[];
        else
           (if private.fis[]<>NONE then
               private.fis.getChannel -> private.fc[];
           if);
       if)
     if);
     (if private.fc[]<>NONE then
         true -> value;
      else
         false -> value;
         'ensure_channel: could not get FileChannel - file not open?' -> screen.putline;
     if);
  #);

--DiskEntryException: dopart-- 
do 'Disk entry exception for \''->msg.puttext;
   path -> msg.puttext;
   '\''->msg.putline;
   'Error in system call: ' -> msg.puttext;
   (*getErrno -> errorstring -> msg.putline;*)
   INNER;

--DiskEntryPrivate: descriptor--
(# path: @text;
   jfile: ^JavaFile;
   
   pathchanged: @boolean;
   head, name, main, suf: ^text;
   
   decomposepath: 
     (# lastInx,len: @integer;
     do (if pathchanged then
	    (* decompose path *)
	    0->lastInx;
            path.lgth -> len;
            (* Search for last '/', ignoring a possible trailing one *)
            '/' -> path.findAll(# do (if inx<len then inx -> lastInx if) #);
	    (if lastInx=0 then
                (* no '/' found (except possible trailing one) *)
                path.copy -> name[];
                (if (len=1) and (path.T[1]='/') then
                    (* path was '/' treat specially on UNIX *)
                    '/' -> head[];
                 else
                    &text[]->head[];
                if);
	     else
                &text[]->name[];
                path.t[lastInx+1:len] -> name;
                (if lastInx=1 then
                    (* Only one '/' found, and this was at start of path.
                     * I.e. it is either '/foo' or '/foo/'.
                     * In both cases head='/' on UNIX.
                     *)
                    '/'->head[];
                 else
                    &text[]->head[];
                    path.t[1:lastInx-1] -> head;
                if);
	    if);
            (* Delete possible trailing '/' in name *)
            (if (name.lgth>1) and (name.t[name.lgth]='/') then 
                name.lgth-1->name.lgth->name.pos;
            if);
            
	    (* decompose name *)
            0->lastInx;
	    '.' -> name.findAll(# do inx -> lastInx #);
            &text[]->suf[];
	    (if lastInx=0 then 
                name.copy -> main[];
	     else
                &text[]->main[];
		name.t[1:lastInx-1] -> main;
		name.t[lastInx:name.lgth] -> suf;
	    if);
	    false -> pathchanged
	if);
     #);

#)

--DiskEntryPathHead: dopart--
do INNER; &text[]->h[]; private.decomposepath; private.head -> h 

--DiskEntryPathNamePref: dopart--
do INNER; &text[] -> p[]; private.decomposepath; private.main -> p

--DiskEntryPathNameSuf: dopart--
do INNER; &text[]->s[]; private.decomposepath; private.suf -> s

--DiskEntryPathNameExt: dopart--
do INNER;
   &text[]->e[]; 
   private.decomposepath; 
   private.suf.t[2:private.suf.length] -> e

--DiskEntryPathNameGet: dopart--
do INNER; &text[]->n[]; private.decomposepath; private.name -> n

--DiskEntryPathSet: dopart--
do INNER;
   (if p[]=NONE then ''->p[] if);
   p -> private.path;
   p[] -> &JavaFile[] -> private.jfile[];
   true -> private.pathchanged;

--DiskEntryPathGet: dopart--
do INNER; private.path.copy -> p[]

--DiskEntryExists: dopart--
do private.jfile.exists -> value
   
--DiskEntryTouch: dopart--
do (if private.jfile.exists then
       (* FIXME: constructor overloading not possible: External DateNow wraps a constructor *)
       (DateNow).getTime -> private.jfile.setLastModified;
    else
       private.jfile.createNewFile;
   if);
   
--DiskEntrySize: dopart--
do (* FIXME: static methods does not support int64:
    * private.jfile.length -> long2int -> value
    *)
   private.jfile.length -> BetaHelper.long2int -> value

--DiskEntrySetModTime:dopart--
do (* FIXME: static methods does not support int64: 
    * time -> int2long -> private.jfile.setLastModified
    *)
   (* FIXME: missing * for int64: 
    * (time -> BetaHelper.int2Long)*(1000->BetaHelper.int2Long) -> private.jfile.setLastModified;
    *)
   (time -> BetaHelper.int2long) -> private.jfile.setLastModified;
   
--DiskEntryGetModTime:dopart--
do (* FIXME: static methods does not support int64:
    * private.jfile.lastModified -> long2int -> time
    *)
   (* FIXME: missing * for int64: 
    * private.jfile.lastModified/(1000->BetaHelper.int2long) -> BetaHelper.long2int -> time
    *)
   private.jfile.lastModified -> BetaHelper.long2int -> time
   
--DiskEntryRename: dopart--
do 'DiskEntryRename' -> NYI;

--DiskEntryReadable: dopart--
do private.jfile.canRead -> value

--DiskEntryWriteable: descriptor--
(# 
do private.jfile.canWrite -> value
#)

--DiskEntryIsDir: dopart--
do private.jfile.isDirectory -> value
   
--DiskEntryIsFile: dopart--
do private.jfile.isFile -> value

--FilePrivate:descriptor--
(# fis: ^FileInputStream;
   fos: ^FileOutputStream;
   pis: ^PushbackInputStream;
   ps: ^PrintStream;
   fc: ^FileChannel;
   i: @integer;
#)

--FileOtherException: dopart--
do 'Error in system call: ' -> msg.puttext;
   (*getErrno -> errorstring -> msg.putline;*) 'FileOtherException' -> NYI;
   INNER

--FileTouch: dopart--
do 'FileTouch' -> NYI;

--FileLength: dopart--
do entry.private.jfile.length -> BetaHelper.long2int -> value

--FileDoOpen:descriptor--
(#
do 'FileDoOpen' -> NYI;
#)

--FileOpenRead:dopart--
do entry.private.jfile[] -> &FileInputStream[] -> private.fis[];
   private.fis[] -> &PushbackInputStream[] -> private.pis[];
   
--FileOpenWrite:dopart--
do entry.private.jfile[] -> &FileOutputStream[] -> private.fos[];
   private.fos[] -> &PrintStream[] -> private.ps[];
   
--FileOpenReadWrite:dopart--
do 'FileOpenReadWrite' -> NYI;
   
--FileOpenAppend:dopart--
do 'FileOpenAppend' -> NYI;
   
--FileOpenReadAppend:dopart--
do 'FileOpenReadAppend' -> NYI;
   
--FileDelete:dopart--
do 'FileDelete' -> NYI;

--FilePut:dopart--
do ch -> private.ps.write_I; private.ps.flush

--FileGet:dopart--
do private.pis.read -> ch;

--FilePeek:dopart--
do private.pis.read -> private.i -> ch;
   private.i -> private.pis.unread_I;
   
--FilePutText:dopart--
do txt[] -> private.ps.print_String

--FileGetAtom:dopart--
do 'FileGetAtom' -> NYI;

--FileGetLine:dopart--
do (* Cannot use BufferedReader.readline, since we have a 
    * PushbackInputReader in work here: 
    * The buffered reader apparently does not know about 
    * the pushback character? 
    *)
   scan:
     (if (private.pis.read->private.i)=ascii.newline then
         (* eat the newline *)
      else
         (* more to come *)
         (if (txt.pos+1->txt.pos) > txt.T.range then 
             txt.T.range+16->txt.T.extend 
         if);
         private.i->txt.T[txt.pos]; 
         txt.lgth+1->txt.lgth;
         restart scan
     if)
   
--FileGetPos:dopart--
do (if ensure_channel then
       private.fc.position -> BetaHelper.long2int -> value
   if);
   
--FileSetPos:dopart--
do (if ensure_channel then
       p -> BetaHelper.int2long -> private.fc.position_J
   if);
   
--FileEos:dopart--
do private.pis.read -> private.i -> private.pis.unread_I;
   private.i=-1 -> value;
   
--FileGetRep:dopart--
do 'FileGetRep' -> NYI;

--FilePutRep:dopart--
do 'FilePutRep' -> NYI;

--FileFlush:dopart--
do private.ps.flush

--FileClose:dopart--
do (* Close input stream *)
   (if private.pis[]<>NONE then
       private.pis.close;
   if);
   (* Close output stream *)
   (if private.ps[]<>NONE then
       private.ps.close;
   if);
