ORIGIN 'betaenv_macbody';
INCLUDE '~beta/basiclib/v1.6/external';

(* COPYRIGHT Mj¿lner Informatics, 1991-93 All rights reserved.
 *
 * this is a console supporting basic input/output as defined in betaenv screen and keyboard
 *)
 

--- lib : attributes ---
console :
(#

  (* Toolbox interface defined locally *)
Debugger: external (* enter MacBugs *)
  (# do '$A9FF' -> pascalTrap #);
DebugStr: external (* enter MacBugs with a message *)
  (# t: [1]@char;
  enter t
  do '$ABFF' -> pascalTrap;
  #);

longInt : cstruct
(# 
  byteSize ::< (# do 4 -> value #);

loWord : short(# pos::< (# do 2 -> value #)#);
hiWord : short(# pos::< (# do 0 -> value #)#);
enter R[1]
exit R[1]
#);

charRef : cstruct
(#  byteSize ::< (# do 2 -> value #)
enter (# val : @integer enter val do (0,val) -> putShort #)
exit 0 -> getShort
#);

shortRef : cstruct
(#  byteSize ::< (# do 2 -> value #)
enter (# val : @integer enter val do (0,val) -> putShort #)
exit 0 -> getShort
#);

byteRef : cstruct
(# byteSize ::< (# do 1 -> value #)
enter (# val : @integer enter val do (0,val) -> putByte #)
exit 0 -> getByte
#);

toResType :
	(# t : @text; intVal : @integer
	enter t
	do (if t.length //4 then
		   t.scanAll(# do intVal*256+ch -> intVal #);
		else 
		   (FAILURE,'Parameter to toResType must be of length 4') -> stop
       if)
	exit intVal
	#);

FromResType:
		(#
			value: @Integer;
			const3: (# exit 16777216 #);
			const2: (# exit 65536 #);
			const1: (# exit 256 #);
			result: [4] @Char;
		enter value
		do
			value div const3 -> result[1];
			value mod const3 -> value;				
			value div const2 -> result[2];
			value mod const2 -> value;				
			value div const1 -> result[3];
			value mod const1 -> result[4];
		exit result
		#);		

macRect : cstruct
(# byteSize ::< (# do 8 -> value #);

		getRect:
			(#
					Top,Left,Bottom,Right: @Integer;
			do
			  @@R[1] -> TOS'%adrGetSignedShort[0]' -> Top;
					@@R[1] + 2 -> TOS'%adrGetSignedShort[0]' -> Left;
					@@R[1] + 4 -> TOS'%adrGetSignedShort[0]' -> Bottom;
					@@R[1] + 6 -> TOS'%adrGetSignedShort[0]' -> Right;
			exit ((Left,Top),(Right,Bottom))
			#);
		
		setRect:
			(#
					Top,Left,Bottom,Right: @Integer;
			enter ((Left,Top),(Right,Bottom))
			do
			  (R,0,Top) -> TOS'%inxPutShort';
					(R,2,Left) -> TOS'%inxPutShort';
					(R,4,Bottom) -> TOS'%inxPutShort';
					(R,6,Right) -> TOS'%inxPutShort';
			#);
  
#);

pascalString : cstruct
 (#
   byteSize ::< (# do 256 -> value; INNER #);
   length : (# exit 0 -> getByte #);
 
   setText :
    (# t : [1]@ char
    enter t
    do 
    (0,t.range) -> putByte;
    (for i:t.range repeat (i,t[i]) -> putByte for);
    #);
 
   getText :
    (# t : [length] @ char;
    do (for i:length repeat i -> getByte -> t[i] for)
    exit t
    #);
 enter setText
 exit getText
 #);

NIL : (# exit 0 #);

macPoint : cstruct
 (#
   byteSize ::< (# do 4 -> value #);
			
			getPoint:
			 (#
				  h,v: @Integer;
				do
				  @@R[1] + 2 -> TOS'%adrGetSignedShort[0]' -> h;
						@@R[1] -> TOS'%adrGetSignedShort[0]' -> v;
				exit (h,v)
				#);
			
			setPoint:
			 (#
				  h,v: @Integer;
				enter (h,v)
				do
				  (R,2,h) -> TOS'%inxPutShort';
						(R,0,v) -> TOS'%inxPutShort';
				#);
				
 enter r[1]
 exit r[1]
 #);
	
MoveHHi: External (# h: @Integer enter h do callpascal #); 

RecordPeek: 
  (* super-pattern for describing record-structures 
		 * allocated by the toolbox
   *)
 (# ptr : @integer;
 
   value: (# value: @integer do INNER exit value #);
   
   GetByte: 
   (# inx: @integer 
   enter inx 
   exit ptr + inx -> TOS'%adrGetByte' 
   #);
   
   PutByte:
   (# val,inx: @integer 
   enter(inx,val) 
   do (ptr+inx,val) -> TOS'%putByte[0]'
   #);
   
   GetShort: 
   (# inx: @integer
   enter inx
   exit ptr + inx -> TOS'%adrGetShort'
   #);
   
   GetSignedShort: 
   (# inx: @integer
   enter inx
   exit ptr + inx -> TOS'%adrGetSignedShort'
   #);
   
   PutShort:
   (# val,inx: @integer
   enter(inx,val)
   do (ptr+inx,val) -> TOS'%putShort[0]'
   #);
   
   GetLong:
   (# inx: @integer
   enter inx
   exit ptr + inx -> TOS'%adrGetLong'
   #);
   
   PutLong: 
   (# val,inx: @integer
   enter(inx,val)
   do (* as this is not supported by the TOS'%'-calls, we have
   to do it in another way *)
   (ptr+inx+2,val) -> TOS'%putShort[0]';
   (ptr+inx,val -> TOS'%shiftRight[16]') -> TOS'%putShort[0]'
   #);
			
			GetRect:
			 (#
				  inx,top,left,bottom,right: @Integer;
				enter inx
				do
						inx -> getSignedShort -> top;
						inx + 2 -> getSignedShort -> left;
						inx + 4 -> getSignedShort -> bottom;
						inx + 6 -> getSignedShort -> right;
				exit ((left,top),(right,bottom))
				#);
			
			setRect:
			 (#
				  inx,top,left,bottom,right: @Integer;
				enter (inx,((left,top),(right,bottom)))
				do ptr + inx -> inx;
				  (inx,top) -> TOS'%putShort[0]';
						(inx+2,left) -> TOS'%putShort[0]';
						(inx+4,bottom) -> TOS'%putShort[0]';
						(inx+6,right) -> TOS'%putShort[0]';
				#);
   
   Byte: (* for declaring fields *)
   (# pos:< value; val: @integer
   enter (# enter val do (pos,val)->putByte #)
   exit pos->getByte
   #);
   
   Short:
   (# pos:< value; val: @integer
   enter (# enter val do (pos,val)->putShort #)
   exit pos->getShort
   #);
   
   SignedShort:
   (# pos:< value; val: @integer
   enter (# enter val do (pos,val)->putShort #)
   exit pos->getSignedShort
   #);
   
   Long:
   (# pos:< value; val: @integer
   enter (# enter val do (pos,val)->putLong #)
   exit pos->getLong
   #);
   
   DoubleLong :
   (# pos:< value; val1,val2: @integer
   enter (# enter (val1,val2) do (pos,val1)->putLong; (pos+4,val2) -> putLong #)
   exit (pos->getLong,pos+4->getLong)
   #);
   
   Rect : doubleLong
    (#
      val: @Integer;
      Top: 
       (# 
       enter (# enter val do (pos,val) -> PutShort;  #)
       exit pos -> getSignedShort
       #);
      Left: 
       (# 
       enter (# enter val do (pos+2,val) -> PutShort; #)
       exit (pos+2) -> getSignedShort
       #);
      Bottom: 
       (# 
       enter (# enter val do (pos+4,val) -> PutShort; #)
       exit (pos+4) -> getSignedShort
       #);
      Right: 
       (# 
       enter (# enter val do (pos+6,val) -> PutShort; #)
       exit (pos+6) -> getSignedShort
       #);
      
      TopLeft:
       (#
       enter (# enter val do (pos,val) -> PutLong; #)
       exit pos -> GetLong
       #);
      BottomRight:
       (#
       enter (# enter val do (pos+4,val) -> PutLong; #)
       exit (pos+4) -> GetLong
       #);
    #);
   
   pstring:
    (#
				  pos:< IntegerObject;
						nLength: (# exit pos -> GetByte #);
						str: @Text;
    do
					 	(# t: [nLength] @char;
							do
							  (for i: nLength repeat (i + pos) -> getByte -> t[i] for);
							  t -> str;
							#);
				exit str
    #);
   
   ReadOnlyByte: (* for declaring fields *)
   (# pos:< value
   exit pos->getByte
   #);
   
   ReadOnlyShort:
   (# pos:< value
   exit pos->getShort
   #);
   
   ReadOnlySignedShort:
   (# pos:< value; val: @integer
   exit pos->getSignedShort
   #);
   
   ReadOnlyLong:
   (# pos:< value
   exit pos->getLong
   #);
   
   readOnlyDoubleLong :
   (# pos:< value; val1,val2: @integer
   exit (pos->getLong,pos+4->getLong)
   #);
   
   readOnlyRect :readOnlyDoubleLong(##);
			   
   initFromHandle :
   (# hndl : @Integer
   enter hndl
   do
				 hndl -> MoveHHi;
					hndl -> TOS'%adrGetLong' -> ptr
   #);
 enter ptr
 exit ptr
 #);

		
pToC : 
 (* converts a char-repetition, where the length is the first
 byte to a repetition of that length *)
 (# p : [1] @char
 enter p
 exit
  (# c : [p[1]]@char
  do
    (for i:p[1] repeat p[i+1] -> c[i] for)
  exit c 
  #)
 #);

CToP :(*reverse of PtoC *)
(#
  c : [1] @char
enter c
exit
 (#
 p : [c.range+1]@char
 do
   (for i:c.range repeat
     c[i] -> p[i+1]
   for);
   c.range -> p[1]
 exit p 
 #)
#);


getqd : external(# theqd : @integer exit theqd #); 
(* returns startaddress of global variables *)

GlobVars :
 (# qd : @integer; (* startAddress of global variables *)
   thePortAddress : @integer; (* last address of global variables = address of thePort *)
   
   thePort : (# tp : @integer exit thePortAddress -> TOS'%adrGetLONG' -> tp #);
   
   whiteAddress : (# exit thePortAddress - 8 #); (* offsets found in MAC revealed, Volume 1, p541 *)
   BlackAddress : (# exit thePortAddress - 16 #);
   GrayAddress : (# exit thePortAddress - 24 #);
   ltGrayAddress : (# exit thePortAddress - 32 #);
   dkGrayAddress : (# exit thePortAddress - 40 #);
   ArrowAddress : (# exit thePortAddress - 108 #);
   ScreenBitsAddress : (# exit thePortAddress - 122 #);
   screenBitsBoundsBR :
   (# bottom,right : @integer
   do thePortAddress - 122 + 10 -> TOS'%adrGetShort' -> bottom;
   thePortAddress - 122 + 12 -> TOS'%adrGetShort' -> right
   exit (right,bottom)
   #);
   
   RandSeedAddress : (# exit thePortAddress - 126 #);
   
   init: 
   (# 
   do
					getqd -> qd;
   		qd + 202 -> thePortAddress;
   		(* initgraf now done in betaenvbody *)
   #);
 
 #);

initToolbox :
 (# g :^ GlobVars;
 enter g[]
 do g.init;
 INNER
 #);


currentEntVersion : (# exit 2 #);


grafPortPtr : (* offsets found in MAC REVEALED, VOL I, p162 *) recordPeek
(# device : readOnlyShort(# pos ::< (# do 0 -> value #)#);
	 baseAddr: long (# pos::< (# Do 2 -> value #)#);
	 rowBytes: short (# pos::< (# Do 6 -> value #)#);
	 bounds: rect (# pos::< (# Do 8 -> value #)#);
	 
	 portBitsAddr : readOnlyLong(# pos ::< (# do 2 -> value #)#);
	 
	 portBitsBoundsTL : (# exit (8 -> getShort,10 -> getShort)#);

	 PortRect : Rect (# pos ::< (# do 16 -> value #)#);

	 PortRectTL :(# exit (# exit (16 -> getShort,18 -> getShort) #)#);
	 
	 visRgn : readOnlyLong(# pos ::< (# do 24 -> value #)#);
	 clipRgn : readOnlyLong(# pos ::< (# do 28 -> value #)#);
	 bkPatAdr : readOnlyLong(# pos ::< (# do 32 -> value #)#);
	 fillPatAdr : readOnlyLong(# pos ::< (# do 40 -> value #)#);
	 
	 pnLoc : readOnlyLong(# pos ::< (# do 48 -> value #)#);
	 pnSize : readOnlyLong(# pos ::< (# do 52 -> value #)#);
	 pnMode : readOnlyShort(# pos ::< (# do 56 -> value #)#);
	 pnPatAdr : readOnlyLong(# pos ::< (# do 58 -> value #)#);
	 pnVis : readOnlyShort(# pos ::< (# do 66 -> value #)#);
	 
	 txFont :readOnlyShort(# pos ::< (# do 68 -> value #)#);
	 txFace :readOnlyShort(# pos ::< (# do 70 -> value #)#);
	 txMode :readOnlyShort(# pos ::< (# do 72 -> value #)#);
	 txSize :readOnlyShort(# pos ::< (# do 74 -> value #)#);
	 spExtra : readOnlyLong(# pos ::< (# do 76 -> value #)#);
	 fgColor : readOnlyLong(# pos ::< (# do 80 -> value #)#);
	 bkColor : readOnlyLong(# pos ::< (# do 84 -> value #)#);
	 colrBit : readOnlyShort(# pos ::< (# do 88 -> value #)#);
	 patStretch: readOnlyShort(# pos ::< (# do 90 -> value #)#);
	 
	 picSave: Long(# pos ::< (# do 92 -> value #)#);
	 rgnSave: Long(# pos ::< (# do 96 -> value #)#);
	 polySave: Long(# pos ::< (# do 100 -> value #)#);
#);


Initgraf : external
(# thePort : @integer
enter thePort
do '$A86E' -> pascalTrap
#);
OpenPort : external(# thePort : @integer enter thePort do '$A86F' -> pascalTrap #);
InitPort : external(# thePort : @integer enter thePort do '$A86D' -> pascalTrap #);
ClosePort : external(# thePort : @integer enter thePort do '$A87D' -> pascalTrap #);
SetPort : external(# thePort : @integer enter thePort do '$A873' -> pascalTrap #);
GetPort : external(# thePort : ^longInt enter thePort[] do '$A874' -> pascalTrap #);
SetPortBits :external(# portBits : @Integer enter portBits do '$A875' -> pascalTrap #);
PortSize :external(# width,height : @shortInt enter (width,height) do '$A876' -> pascalTrap #);
SetOrigin : external(# dh,dv : @shortInt enter (dh,dv) do '$A878' -> pascalTrap #);
ClipRect : external(# r : ^macRect enter r[] do '$A87B' -> pascalTrap #);
InitCursor : external(# do '$A850' -> pascalTrap #);
TextFont : external(# font : @shortInt enter font do '$A887' -> pascalTrap #);
TextFace : external(# face : @shortInt enter face do '$A888' -> pascalTrap #);
TextMode : external(# mode : @shortInt enter mode do '$A889' -> pascalTrap #);
TextSize : external(# size : @shortInt enter size do '$A88A' -> pascalTrap #);
DrawChar : external(# ch : @char enter ch do '$A883' -> pascalTrap #);
DrawString : external(# s : [1] @char enter s do '$A884' -> pascalTrap #);
DrawText : external(# ptr: @integer; firstByte,byteCount : @shortInt enter (ptr,firstByte,byteCount) do '$A885' -> pascalTrap #);


SetRect : external(# rect : ^macRect; l,t,r,b : @shortInt enter (rect[],l,t,r,b) do '$A8A7' -> pascalTrap #);
OffsetRect : external(# r : ^macRect; dh,dv : @shortInt enter (r[],dh,dv) do '$A8A8' -> pascalTrap #);
InsetRect : external(# r : ^macRect; dh,dv : @shortInt enter (r[],dh,dv) do '$A8A9' -> pascalTrap #);




LocalToGlobal : external(# p : ^macPoint enter p[] do '$A870' -> pascalTrap #);
GlobalToLocal : external(# p : ^macPoint enter p[] do '$A871' -> pascalTrap #);

windowPtr : grafPortPtr (* OFFSETS found in MACINTOSH Revealed, Volume 2, page 112 *)
(#
  windowKind : readOnlySignedShort(# pos ::< (# do 108 -> value #)#);
  visible: readOnlyByte(# pos ::< (# do 110 -> value #)#);
  hilited : readOnlyByte(# pos ::< (# do 111 -> value #)#);
  goAwayFlag : readOnlyByte(# pos ::< (# do 112 -> value #)#);
  spareFlag : readOnlyByte(# pos ::< (# do 113 -> value #)#);
  strucRgn : readOnlyLong(# pos ::< (# do 114 -> value #)#);
  contRgn : readOnlyLong(# pos ::< (# do 118 -> value #)#);
  updateRgn : readOnlyLong(# pos ::< (# do 122 -> value #)#);
  windowDefProc : readOnlyLong(# pos ::< (# do 126 -> value #)#);
  dataHandle : long(# pos ::< (# do 130 -> value #)#);
  titleHandle : readOnlyLong(# pos ::< (# do 134 -> value #)#);
  titleWidth : readOnlyShort(# pos ::< (# do 138 -> value #)#);
  controlList : long (# pos ::< (# do 140 -> value #)#);
  nextWindow : readOnlyLong(# pos ::< (# do 144 -> value #)#);
  windowPic : long (# pos ::< (# do 148 -> value #)#);
  refCon : readOnlyLong(# pos ::< (# do 152 -> value #)#);
#);

GetNewWindow : external
(# windowId : @shortInt;
   wStorage : @integer;
   behind : @integer;
   result : @integer
enter (windowId,wStorage,behind)
do '$A9BD' -> pascalTrap
exit result
#);

CloseWindow : external
(# theWindow : @integer
enter theWindow
do '$A92D' -> pascalTrap
#);

DisposeWindow : external
(# theWindow : @integer
enter theWindow
do '$A914' -> pascalTrap
#);

SetWTitle : external
(# theWindow : @integer; theTitle : [1] @char
enter (theWindow,theTitle)
do '$A91A' -> pascalTrap
#);

SelectWindow : external(# theWindow : @integer enter theWindow do '$A91F' -> pascalTrap #);
HideWindow : external(# theWindow : @integer enter theWindow do '$A916' -> pascalTrap #);
ShowWindow : external(# theWindow : @integer enter theWindow do '$A915' -> pascalTrap #);
DrawGrowIcon : external(# theWindow : @integer enter theWindow do '$A904' -> pascalTrap #);
BringToFront : external(# theWindow : @integer enter theWindow do '$A920' -> pascalTrap #);
FrontWindow : external
(# theWindow : @integer do '$A924' -> pascalTrap exit theWindow #);
FindControl : external
(# thePt : @integer;
   theWindow : @integer;
   theControl : ^longInt;
   result : @shortInt
enter (thePt,theWindow,theControl[])
do '$A96C' -> pascalTrap
exit result
#);

HiliteMenu : external
(# menuId : @shortInt
enter menuId
do '$A938' -> pascalTrap
#);
EraseRect : external(# r : ^macRect enter r[] do '$A8A3' -> pascalTrap #);

SizeWindow : external
(# theWindow : @integer;
   w,h : @shortInt;
   fUpdate : @boolean
enter (theWindow,w,h,fUpdate)
do '$A91D' -> pascalTrap 
#);

ZoomWindow : external
(# theWindow : @integer;
   partCode : @shortInt;
   front : @boolean
enter (theWindow,partCode,front)
do '$A83A' -> pascalTrap 
#);

InvalRect : external
(# badRect : ^macRect
enter badRect[]
do '$A928' -> pascalTrap
#);

InvalRgn : external
(# badRgn : @integer
enter badRgn
do '$A927' -> pascalTrap
#);


BeginUpdate : external(# theWindow : @integer enter theWindow do '$A922' -> pascalTrap #);

EndUpdate : external(# theWindow : @integer enter theWindow do '$A923' -> pascalTrap #);

GrowWindow : external
(# theWindow : @integer;
   startPt : @integer;
   bBox : ^ macRect;
   result : @integer
enter (theWindow,startPt,bBox[])
do '$A92B' -> pascalTrap 
exit result
#);

FindWindow : external
(# thePoint : @integer;
   whichWindow : ^longInt;
   result : @shortInt
enter (thePoint,whichWindow[])
do '$A92C' -> pascalTrap
exit result
#);


TrackGoAway : external
(# theWindow : @integer;
   startPt : @integer;
   result : @boolean
enter (theWindow,startPt)
do '$A91E' -> pascalTrap
exit result
#);


TrackBox : external
(# theWindow : @integer;
   thePt : @integer;
   partCode : @shortInt;
   result :@ boolean
enter (theWindow,thePt,partCode)
do '$A83B' -> pascalTrap
exit result
#);

DragWindow : external
(# theWindow : @integer;
   startPt : @integer;
   result : @boolean;
   rect : ^macRect
enter (theWindow,startPt,rect[])
do '$A925' -> pascalTrap
#);

eventRecord : cstruct
(#
  byteSize ::< (# do 16 -> value #);
  
  what : short(# pos::< (# do 0 -> value #)#);
  message : long(# pos::< (# do 2 -> value #)#);
  keyCode : byte(# pos ::< (# do 4 -> value #)#);
  charCode : byte(# pos ::< (# do 5 -> value #)#);
  when : long(# pos::< (# do 6 -> value #)#);
  where : long(# pos::< (# do 10 -> value #)#);
  modifiers : short(# pos::< (# do 14 -> value #)#);
  
  app4Selector : byte(# pos::< (# do 2 -> value #)#);
  childDiedStatus : byte(# pos::< (# do 3 -> value #)#);
  resume : (# b : @boolean exit message -> TOS'%GetBits[31,1]' -> b #);
  scrapDataHasChanged : (# b : @boolean exit message -> TOS'%GetBits[30,1]' -> b #);
  
  activeFlag : (# b : @boolean exit modifiers -> TOS'%GetBits[31,1]' -> b #);
  btnState : (# b : @boolean exit modifiers -> TOS'%GetBits[24,1]' -> b #);
  cmdKey : (# b : @boolean exit modifiers -> TOS'%GetBits[23,1]' -> b #);
  shiftKey : (# b : @boolean exit modifiers -> TOS'%GetBits[22,1]' -> b #);
  alphaLock : (# b : @boolean exit modifiers -> TOS'%GetBits[21,1]' -> b #);
  optionKey : (# b : @boolean exit modifiers -> TOS'%GetBits[20,1]' -> b #);
  controlKey : (# b : @boolean exit modifiers -> TOS'%GetBits[19,1]' -> b #);
#);

WaitNextEvent : external
(# eventMask : @shortInt;
   theEvent : ^eventRecord;
   sleep,rgn : @integer;
   result : @shortInt
enter (eventMask,theEvent[],sleep,rgn)
do '$A860' -> pascalTrap
exit result
#);

GetMouse : external(# mouseLoc : ^macPoint enter mouseLoc[] do '$A972' -> pascalTrap #);
TickCount : external(# value : @integer do '$A975' -> pascalTrap exit value #);
GetDblTime : external(# value : @integer do '{$2EB8,$02F0}' -> pascalTrap exit value #);

(* OS event *)

FlushEvents: external
(#
	whichMask,stopMask: @shortInt;
Enter (whichMask,stopMask)
Do '{$201F,$A032}' -> pascalTrap
#);

GetEvQHdr: external
(#
	QHdrPtr: @integer;
Do 'GETEVQHDR' -> callPascal
Exit QHdrPtr
#);

InitMenus : external(# do '$A930' -> pascalTrap #);

GetMenu : external
(# resourceId : @shortInt;
   menuHandle : @integer
enter resourceId
do '$A9BF' -> pascalTrap
exit menuHandle
#);

AppendResMenu : external
(# menuHandle : @integer;
   theType : @integer
enter (menuHandle,theType)
do '$A94D' -> pascalTrap
#);

InsertMenu : external
(# menuHandle : @integer;
   beforeId : @shortInt
enter (menuHandle,beforeId)
do '$A935' -> pascalTrap
#);

DrawMenuBar : external(# do '$A937' -> pascalTrap #);

MenuSelect : external
(# startPt : @integer;
   result : @integer
enter startPt
do '$A93D' -> pascalTrap
exit result
#);

MenuKey : external
(# ch : @shortInt; result : @integer
enter ch
do '$A93E' -> pascalTrap
exit result
#);

GetMenuItemText : external
(#  theMenu : @integer; item : @shortInt; ItemString : ^pascalString
enter (theMenu,item,itemString[])
do '$A946'-> pascalTrap
#);

MenuChoice : external(# result : @integer do '$AA66' -> pascalTrap exit result #);

 BitAnd: external
 (# value1,value2,result: @integer
 enter (value1,value2)
 do '$A858' -> pascalTrap 
 exit result
 #);

 BitOr: external
 (# value1,value2,result: @integer
 enter (value1,value2)
 do '$A85B' -> pascalTrap 
 exit result
 #);

 BitShift: external
 (#  value : @integer; count: @shortInt; result : @integer
 enter (value,count)
 do '$A85C' -> pascalTrap
 exit result
 #);

EvQElPtr: RecordPeek
(# qLink: Long (# pos ::< (# do 0 -> value #)#);
   qType: Short(# pos ::< (# do 4 -> value #)#);
   evtQWhat: Short(# pos ::< (# do 6 -> value #)#);
   evtQMessage: Long (# pos ::< (# do 8 -> value #)#); 
   evtQWhen: Long (# pos ::< (# do 12 -> value #)#);
   evtQWhere: Long (# pos ::< (# do 16 -> value #)#);
   evtQModifiers: short (# pos ::< (# do 20 -> value #)#);
#);

QHdrPtr: RecordPeek
(# qFlags: Short (# pos ::< (# do 0 -> value #)#);
   qHead: Long (# pos ::< (# do 2 -> value #)#);
   qTail: Long (# pos ::< (# do 6 -> value #)#);
#);


(* in script *)

GetEnvirons: external
(# verb: @ShortInt;
   result: @Integer;
enter verb
do '{$2F3C,$8402,$0008,$A8B5}' -> PascalTrap;
exit result
#);

GetScript:external
(# script,verb: @ShortInt;
   result: @Integer;
enter (script,verb)
do '{$2F3C,$8404,$000C,$A8B5}' -> PascalTrap
exit result
#);
GetScriptManagerVariable:External
(# selector: @ShortInt;
   result: @Integer;
enter selector
do '{$2F3C,$8402,$0008,$A8B5}' -> PascalTrap
exit result
#);
KeyTranslate: external
(#
	transData,result: @integer;
	keycode: @shortInt;
	state: ^longInt;
Enter (transData,keycode,state[])
Do '$A9C3' -> pascalTrap;
Exit result
#);
TEPtr : (* offsets found in MAC REVEALED, VOL 2, p243 *) recordPeek
(# 
	 destRect : Rect (# pos ::< (# do 0 -> value #)#);
	 viewRect : Rect (# pos ::< (# do 8 -> value #)#);

		 lineHeight : short(# pos ::< (# do 24 -> value #)#);
		 fontAscent : short(# pos ::< (# do 26 -> value #)#);
		 selStart : short(# pos ::< (# do 32 -> value #)#);
		 selEnd : short (# pos ::< (# do 34 -> value #)#);
		 wordBreak : long(# pos ::< (# do 38 -> value #)#);
		 clikLoop : long(# pos ::< (# do 42 -> value #)#);
		 just : Short(# pos ::< (# do 58 -> value #)#);
		 teLength : readOnlyShort(# pos ::< (# do 60 -> value #)#);
		 hText : readOnlyShort(# pos ::< (# do 62 -> value #)#);
		 crOnly : short(# pos ::< (# do 72 -> value #)#);
		 txFont : short(# pos ::< (# do 74 -> value #)#);
		 txFace : short(# pos ::< (# do 76 -> value #)#);
		 txMode : short(# pos ::< (# do 78 -> value #)#);
		 txSize : short(# pos ::< (# do 80 -> value #)#);
		 inPort : long(# pos ::< (# do 82 -> value #)#);
		 highHook : long(# pos ::< (# do 86 -> value #)#);
		 caretHook : long(# pos ::< (# do 90 -> value #)#);
		 nLines : readOnlyShort(# pos ::< (# do 94 -> value #)#);
	 lineStart :(# lineNo : @integer enter lineNo exit 96+lineNo*2 -> getShort #);
#);

TEInit : external(# do '$A9CC' -> pascalTrap #);

TENew : external
(# destRect,viewRect : ^macRect; theHandle :@ integer
enter (destRect[],viewRect[])
do '$A9D2' -> pascalTrap
exit theHandle
#);

TEDispose : external
(# theHandle :@ integer
enter theHandle
do '$A9CD' -> pascalTrap
#);

TESetText : external
(# text,length,hTe : @integer
enter (text,length,hTe)
do '$A9CF' -> pascaltrap
#);

TEGetText : external
(# thetext,hTe : @integer
enter hTe
do '$A9CB' -> pascaltrap
exit theText
#);

TEIdle : external
(# hTe : @integer
enter hTe
do '$A9DA' -> pascaltrap
#);

TESetSelect : external
(# selStart,selEnd,hTe : @integer
enter (selStart,selEnd,hTe)
do '$A9D1' -> pascaltrap
#);

TEActivate : external
(# hTe : @integer
enter hTe
do '$A9D8' -> pascaltrap
#);

TEDeactivate : external
(# hTe : @integer
enter hTe
do '$A9D9' -> pascaltrap
#);

TEKey : external
(# key : @shortInt; hTe : @integer
enter (key,hTe)
do '$A9DC' -> pascaltrap
#);

TECut : external
(# hTe : @integer
enter hTe
do '$A9D6' -> pascaltrap
#);

TECopy : external
(# hTe : @integer
enter hTe
do '$A9D5' -> pascaltrap
#);

TEPaste : external
(# hTe : @integer
enter hTe
do '$A9DB' -> pascaltrap
#);

TEDelete : external
(# hTe : @integer
enter hTe
do '$A9D7' -> pascaltrap
#);

TEInsert : external
(# text,length,hTe : @integer
enter (text,length,hTe)
do '$A9DE' -> pascaltrap
#);

TEUpdate : external
(# hTe : @integer; rUpdate : ^macRect
enter (rUpdate[],hTe)
do '$A9D3' -> pascaltrap
#);


TESelView : external
(# hTe : @integer
enter hTe
do '$A811' -> pascalTrap
#);

TEAutoView : external
(# fAuto : @boolean;
   hTe : @integer
enter (fAuto,hTe)
do '$A813' -> pascalTrap
#);

TEClick : external
(# pt : @integer;
   fExtend : @boolean;
   hte : @integer
enter (pt,fExtend,hTe)
do '$A9D4' -> pascalTrap
#);

TEGetScrapLength : external
(# l : @integer
do callpascal
exit l
#);

TEFromScrap : external(# res : @shortInt do callpascal exit res #);
TEToScrap : external(# res : @shortInt do callpascal exit res #);

NewHandle: External
	(# byteCount,theHandle: @Integer;
	enter byteCount 
	do CallPascal; 
	exit theHandle 
	#);
GetHandleSize: External 
	(# h,Size: @Integer; 
	enter h 
	do CallPascal; 
	exit size 
	#);
HLock: External (# h: @Integer; enter h do CallPascal; #);
HUnlock: External (# h: @Integer; enter h do CallPascal; #);

DisposeHandle: External 
  (# h: @Integer; 
  enter h 
  do '$A023' -> PascalTrap 
  #);

NewPtr: External
	(#	byteCount,thePtr: @Integer;
	enter byteCount
	do CallPascal;
	exit thePtr
	#);
DisposePtr: External 
  (# ptr: @Integer; 
  enter ptr 
  do '$A01F' -> PascalTrap;
  #);

InitResources : external(# do '$A995' -> pascalTrap #);
GetResource :external
(# theType : @integer;
   index : @shortInt;
   result : @integer;
enter (theType,index)
do '$A9A0' -> pascalTrap
exit result
#);
ReleaseResource :external(# handle:@integer enter handle do '$A9A3' -> pascalTrap #);

InitDialogs : external (# resumeProcPtr : @integer enter resumeProcPtr do '$A97B' -> pascalTrap #);
 
Alert : external
(# alertId : @shortInt;
   modalFilterProc : @integer;
   theResult : @shortInt
enter (alertId,modalFilterProc)
do '$A985' -> pascalTrap
exit theResult
#);

OpenDeskAcc : external
(# theAcc : [1] @char;
   result : @shortInt
enter theAcc
do '$A9B6' -> pascalTrap
exit result
#);

SystemEdit : external
(# editCmd : @shortInt;
   result : @shortInt
enter editCmd
do '$A9C2' -> pascalTrap
exit result
#);

SystemClick : external
(# theEvent : ^eventRecord;
   theWindow : @integer
enter (theEvent[],theWindow)
do '$A9B3' -> pascalTrap
#);


ZeroScrap : external
(# result : @integer
do '$A9FC' ->pascalTrap
exit result
#);
 
 (* RESOURCE IDs *)
  WindowID: (# exit 7128 #);
  AppleID:  (# exit 7128 #);
  FileID:   (# exit 7129 #);
  EditID:   (# exit 7130 #);
  
  CloseItem: (# exit 4 #);
  QuitItem:  (# exit 10 #);
  
  (* CONSTANTS *)
  screenWidth: (# b,r: @Integer do GlobVar.screenBitsBoundsBR -> (r,b) exit r #);
  screenHeight: (# b,r: @Integer do GlobVar.screenBitsBoundsBR -> (r,b) exit b #);
  titleBarHeight: (# exit 18 #);
  windowMargin: (# exit 10 #);
  ScreenMargin: (# exit 4 #);
  TextMargin: (# exit 4 #);
  ScrollbarWidth: (# exit 16 #);
  ScrollbarAdjust: (# exit 15 #);
  
  ConsoleWindow: @
  (# wptr: @WindowPtr;
	 theTE: @integer;
	 
	 CheckLenOfTE:@
	   (# tptr: @tePtr;
	   do theTE -> tptr.initFromHandle;
	      (if tptr.telength>30000 //true then
		      (0,10000,theTE) -> TESetSelect;
			  theTE -> TEDelete;
			  (40000,40000,theTE) -> TESetSelect;
		  if);
	   #);
	 
	 init:
	 (# pr,viewrect: @macRect;
	    tPtr: @tePtr;
		x,y,r,b,ignore: @Integer;
	 do globvar[] -> initToolbox; (* here all the INIT-routines are called *)
	    false -> terminate; 
	    true -> inForeGround; 
		((0,0),globvar.screenBitsBoundsBR) -> dragRect.setRect; 
		((40,40),globvar.screenBitsBoundsBR) -> sizeRect.setRect;
	    (WindowID,0,-1) -> GetNewWindow -> wptr;
	    (if wptr//0 then 
			(* serious error, no resource or no more memory *)
			(# BetaExit : External(# status : @integer enter status do CallC #);
			do 2->BetaExit;
			#);
		if);
		wptr -> ShowWindow;
		wptr -> setport;
		wptr -> DrawGrowIcon;
		16 -> wptr.getRect -> pr.setRect;
		pr.getRect -> ((x,y),(r,b));
		((0,0),(r-(ScrollbarWidth-1),b-(ScrollbarWidth-1))) -> viewrect.setRect;
        (viewrect[],viewrect[]) -> TENew -> theTE;
	    theTE -> tPtr.initFromHandle;
		4 -> tPtr.txFont; (* 4 = monaco *)
		9 -> tPtr.txSize;
        theTE -> TEActivate;
	    (true,theTE) -> TEAutoView;
		0 -> charbuf.setpos;
		startCmdPeriod;
		
		TEFromScrap -> ignore;
	 #);
	 
	 update:
	 (# tPtr: @tePtr;
		r : @macRect;
	 do theTE -> tPtr.initFromHandle;
	 
		8 -> tPtr.getRect -> r.setRect;
		(r[],theTE) -> TEUpdate;
		wptr -> DrawGrowIcon;
	 #);
	 
	 activate: (# do theTE -> TEActivate #);
	 
	 deactivate: (# do theTE -> TEDeactivate #);
	 
	 lastCh: @char;
	 charbuf: @Text;
	 
	 keyDown:
	 (# ch: @Char;
	 enter ch
	 do (ch,theTE) -> TEKey;
	    (if ch
		 //ascii.del//ascii.bs then 
		   (if charbuf.empty//false then
		       (charbuf.pos,charbuf.pos) -> charbuf.delete;
		   if);
		 //28//29//30//31 then (* ignore arrow keys *)
		 else
		    ch -> lastCh -> charbuf.put;
		if);
	 #);
	 
	 PutCh:
	 (# ch: @Char;
	 enter ch
	 do (ch,theTE) -> TEKey;
	    CheckLenOfTE;
	 #);
	 
	 readline:
	 (#
	 do charbuf.clear;
	    0 -> lastCh;
	 	loop: (* get events until newline or carriage return is typed *)
		   (if terminate//false then 
		   	   eventreader.readOne;
			   (if lastCh//ascii.newline then else restart loop if)
		   if);
        charbuf.reset;
     #);
	 
	 inContent:
	 (# p: ^macPoint;
	    double: @Boolean;
		shift: @Boolean
	 enter (p[],double,shift)
	 do
	    (p,shift,theTE) -> TEClick;
	 #);
	 
	 inControl: (# (* scrollbars not yet implemented *) #);
	 
	 inGrow: 
	   (# portRect: ^macRect;
	      textRec: @TEPtr; a,b,c,d: @Integer;
	   enter portRect[]
	   do theTE -> HLock;
          theTE -> textRec.initFromHandle;
          portRect.getRect -> ((a,b),(c,d)); (* prevent inline enter code *)
          (8,((a,b),(c-(ScrollbarWidth-1),d-(ScrollbarWidth-1)))) -> textRec.setRect;
		  theTE -> HUnlock;
	      theTE -> TESelView; (* scroll selection into view *)
	   #);
	 inGoAway: (# do true -> terminate #);
	   
	 insert:
	 (# t: @Text;
	    myString : cstruct (* a real text string with chars in consecutive bytes *)
	      (# byteSize ::< (# do t.length -> value #);	
		     setText :
		       (# t : [1]@ char
		       enter t
		       do (for i:t.range repeat (i-1,t[i]) -> putByte for);
		       #);
	      #);
	    TEInsert : external
		  (# text:^mystring;
		     length,hTe : @integer
		  enter (text[],length,hTe)
		  do '$A9DE' -> pascaltrap
		  #);
	 enter t
	 do (# p: @mystring;
	    do t -> p.settext;
	       (p[],t.length,theTE) -> TEInsert;
		#);
     #);
	 	 
	 show:
	 (# 
	 do (if isRunning//true then
			wptr -> BringToFront;
		else
	        init;
			Menus.init;
			true -> isRunning;
		if);
	 #);
	 
(* COMMAND PERIOD CHECK *)
	 foundCmdPeriod: @Boolean;
	 KCHRPtr: @RecordPeek;
	 hKCHR: @integer;

	 startCmdPeriod:
	 (# smKCHRCache:  (# exit 38 #);
	    smKeyScript:  (# exit 22 #);
		smScriptKeys: (# exit 32 #);
		keyCId: @Integer;
	 do smKCHRCache -> GetScriptManagerVariable -> KCHRPtr;
	 
		0 -> hKCHR;  (* set to NIL before starting *)
		(if KCHRPtr //0 then   (* we didn't get the ptr from GetEnvirons *)
			(*(smKeyScript -> GetScriptManagerVariable, smScriptKeys) -> GetScript -> keyCId;*)
           (*  read the appropriate KCHR resource *)
			('KCHR' -> toResType, smKeyScript -> GetScriptManagerVariable) -> GetResource -> hKCHR;
			hKCHR -> HLock;
			hKCHR -> KCHRPtr.initFromHandle;
		if);
    #);
	 
    CheckCmdPeriod:
	(# eqPtr: @EvQElPtr;
	   qHeadPtr: @QHdrPtr;
	   found: @Boolean;
	   GetEvQHdr: (# exit 330 #);
	do (* shortcut if cmd period has been found *)
		(if foundCmdPeriod //true then
			true -> found;
		 else
            (* run through event queue and see if there is any cmd-period events *)
		    GetEvQHdr -> qHeadPtr;       (* --> header of event queue *)
		    qHeadPtr.qHead -> eqPtr;     (* --> first event in queue *)
		    loop:
		    (# do
				  (if found or (eqptr=0) //true then leave loop if);
				  (if eqPtr -> TestCmdPeriod //true then 
				      0 -> eqPtr.evtQWhat;  (* 'remove' cmd-period event *)
				      true -> found;
				  if);
				  (if eqPtr// qHeadPtr.qTail then leave loop if);
				  eqPtr.qLink -> eqPtr;
				  restart loop;
		    #);
		    found -> foundCmdPeriod;
		if);
	exit found
	#);
	
	TestCmdPeriod:
	(# theEvent: @EvQElPtr;
	   result: @Boolean;
	   cmdKey: (# exit 256 #);
	   kMaskModifier: (# exit 65024 #);       (* need to strip command key from Modifiers*)
	   kMaskVirtualKey: (# exit 65280 #); (*get virtual key from event message*)
	   kMaskASCII1: (# exit 16711680 #);
	   kMaskASCII2: (# exit 255 #);     (*get key from KeyTrans return*)
	   kKeyUpMask: (# exit 128 #);
	   kPeriod: (# exit '.' #);
	   keyCode: @Integer;
	   virtualKey, keyInfo, lowChar, highChar, keyCId: @Integer;
	   state: @longInt;
	enter theEvent
	do
 		(if theEvent.evtQWhat
		 //3 (* keyDown *)
		 //5 (* autoKey *) then 
     		(*< see if the command key is down.  If it is, get the ASCII >*)
			(if ((theEvent.evtQmodifiers, cmdKey) -> BitAnd) <> 0 //true then 
				((theEvent.evtQmessage, kMaskVirtualKey) -> BitAnd) div 256 -> virtualKey;
          		(* strip the virtual key by ANDing the modifiers with our mask*)
				(theEvent.evtQmodifiers, kMaskModifier) -> BitAnd -> keyCode;
				(keyCode, kKeyUpMask) -> BitOr -> keyCode;
          		(* let KeyTrans think it was a keyup event , this will keep *)
          		(* special dead key processing from occurring *)
          		(* Finally OR in the virtualKey *)
				(keyCode, virtualKey) -> BitOr -> keyCode;
				(if KCHRPtr <> 0 //true then
					 (KCHRPtr, keyCode, state[]) -> KeyTranslate -> keyInfo;
				 else
            		(* if we can't get the KCHR for some reason we set keyInfo *)
            		(* to the message field . This ensures that we still get the Cancel*)
            		(* operation on systems where '.' isn 't shifted.*)
					theEvent.evtQmessage -> keyInfo;
		        if);
				(keyInfo, kMaskASCII2) -> BitAnd -> LowChar;
				((keyInfo, kMaskASCII1) -> BitAnd, -16) -> BitShift -> HighChar;
				(LowChar = kPeriod) or (HighChar = kPeriod) -> result;
			if);
		if);
	 exit result
	 #);
	 
	EndCmdPeriodCheck:
	(#
	do (if hKCHR <> nil //true then
		   hKCHR -> HUnLock;
		   hKCHR -> ReleaseResource;
	   if);
	   false -> foundCmdPeriod;
	#);
  #);
  
  Menus: @
  (# appleMenu,fileMenu,EditMenu,resType: @integer;
	Text2ResType:
		(#
			const3: (# exit 16777216 #);
			const2: (# exit 65536 #);
			const1: (# exit 256 #);
			newtxt: [4] @Char;
			result: @Integer;
		enter newtxt
		do
			newtxt[1] * const3 -> result;
			(newtxt[2] * const2) + result -> result;
			(newtxt[3] * const1) + result -> result;
			newtxt[4] + result -> result;
		exit result
		#);
     init:
	 (#
	 do appleID -> GetMenu -> appleMenu;
        fileID  -> GetMenu -> fileMenu;
        editID  -> GetMenu -> editMenu;
		'DRVR' -> Text2ResType -> resType;
  		(appleMenu,resType) -> AppendResMenu;
		(appleMenu,0) -> InsertMenu;
        (fileMenu, 0) -> InsertMenu;
        (editMenu, 0) -> InsertMenu;
        DrawMenuBar;
	 #);
	 
	 ProcessMenu:
	 (# menu,item: @Integer;
	    name: @PascalString;
	 enter (menu,item)
	 do
	    (if menu
		 // appleID then
            (if item < 3 //true then
                (# res: @integer; alertId: (# exit 7128 #)
		           do (alertId, NIL) -> Alert -> res;
				#);
             else 
                (appleMenu,item,name[]) -> GetMenuItemText;
		        name.gettext -> openDeskAcc;
			if);
		 // fileID then
		    (if item
			 // quitItem//closeitem then true -> terminate;
			if);
		 // editID then
		 	(if item
			 //3 then ConsoleWindow.theTE -> TECut;
			 //4 then ConsoleWindow.theTE -> TECopy;
			 //5 then ConsoleWindow.theTE -> TEPaste;	
  if)if)#)#);
eventReader: @
  (# 
     lastClickEventTime: @integer;
	 lastClickEventPlace: @macPoint;
     rgn : @integer;
     result : @integer;
     e : @eventRecord;
	 menuSelected: @
	  (# command : @longInt; 
	     menu,item : @integer 
	  enter command
	  do (if command.hiWord 
		 //0 then (* the user did not select a menu *)
		 else command.hiWord -> menu;
		      command.loWord -> item;
			  (menu,item) -> Menus.ProcessMenu;
  			  0 -> hiliteMenu (* deselect the menubar *)

		if);
	  #);
	mouseDown: @
	(# message : @integer;
       win : @longInt;
	   whichPart : @integer;
	   thePoint : @macPoint;
	   theControl : @longInt;
	   thePart : @integer;
	   
	   inSysWindow: (# do (e[],win) -> systemClick; INNER #);
	   inDrag: (# do (win,e.where,dragRect[]) -> dragWindow; INNER #);
	   inControl:
	     (# 
		 do (* use thePart and theControl *) 
		    (* (theControl,thePart,thePoint) -> consoleWindow.inControl *)
		 #);
	   inZoom:
	     (# zoomingIn :@ boolean;
		    portRect: @macRect
		 enter zoomingIn 
		 do (if ((win,thePoint,whichPart) -> trackBox)
		    //true then 
			  (win,whichPart,false) -> zoomWindow;
			  16 -> consoleWindow.wPtr.getRect -> portRect.setRect;
		      portRect[] -> eraseRect;
			if);
		 #);
	   inContent: 
		 (# 
		 do (if win
			//frontWindow then 
			  e.where -> thePoint;
			  thePoint[] -> globalToLocal;
			  (thePoint,win,theControl[]) -> findControl -> thePart;
			  (if theControl
			  //NIL then 
			    (# p: @macPoint; dbltime: @integer;
				   isDouble: @Boolean;
				 do 
					e.where -> p;
					getDblTime -> dblTime;
					(if ((e.when - lastClickEventTime)<=dblTime)
					//true then
					  (# h1,v1,h2,v2 : @integer
					  do p.getpoint -> (v1,h1);
					     lastClickEventPlace.getpoint -> (v2,h2);
						 h1 - h2 -> h1;
						 v1 - v2 -> v1;
						 (h1*h1+v1*v1<10) -> isDouble
					  #);
					if);
					e.where -> lastClickEventPlace;
					e.when -> lastClickEventTime;
					p[] -> globalToLocal;
					(p[],isDouble,e.shiftKey) -> consoleWindow.inContent;
				 #);
			  else inControl
			  if);
			else win -> selectWindow
			if)
		 #);
	   inGoAway:
		 (#
		 do (if ((win,e.where) -> trackGoAway)
			//true then consoleWindow.inGoAway 
			if);
		 #);
	   inGrow:
		 (# newSize : @macPoint;
			portRect : @macRect;
			theWin : @grafPortPtr;
			newWidth,newHeight : @integer;
		 do (win,e.where,sizeRect[]) -> growWindow -> newSize;
			(if newSize
			//0 then
			else
			  win -> theWin;
			  16 -> theWin.getRect -> portRect.setRect;
			  portRect[] -> eraseRect;
			  
			  newSize.getPoint -> (newWidth,newHeight);
			  (win,newWidth,newHeight,true) -> sizeWindow;
			  
			  16 -> theWin.getRect -> portRect.setRect;
			  portRect[] -> invalRect;
			  portRect[] -> consoleWindow.inGrow
			if)
		 #);
	    enter message 
		do (e.where,win[]) -> findWindow -> whichPart;
		   (if whichPart
		    //1 (* inMenuBar *) then e.where -> menuSelect -> menuSelected;
		    //2 (* inSysWindow *) then inSysWindow;
		    //3 (* inContent *) then inContent;
		    //4 (* inDrag *) then inDrag;
		    //5 (* inGrow *) then inGrow;
		    //6 (* inGoAway *) then inGoAway;
		   
		    //7 (* inZoomIn *)//8 (* inZoomOut *) then (whichPart=7) -> inZoom;
		    //0 (* inDesk *) then (* not taken care of ane more. Obsolete *)
		    else (* impossible *)
		   if);
	  #);
	mouseUp: @
	  (# message : @integer;
	     thePoint : @macPoint;
	  enter message 
	  do e.where -> thePoint;
		 thePoint[] -> globalToLocal;
		 INNER
	  #);
    keyDown: @
	   (# (* if commandKey down do a process call menuSelected instead *)
	      ch : @char 
	   enter ch 
	   do (if e.cmdKey then 
	   			(if ch = '.' then
					(failure,'Program execution aborted by user') -> Stop;
				else
	   				ch -> menuKey -> menuSelected;
				if);
		   else 
		      (if NOT ignoreKeystrokes then ch -> consoleWindow.keyDown if);
	      if)
	   #);
	keyUp: @(# ch : @char enter ch do INNER #);
	autoKey: @
	  (# ch : @char
	  enter ch 
	  do (if ignoreKeystrokes//false then ch -> consoleWindow.keyDown if);
	  #);
	updateEvt: @
	  (# window: @integer
	  enter window
	  do window -> beginUpdate;
         consolewindow.update;
	     window -> endUpdate;
	  #);
	diskEvt: (# do INNER #);
	activateEvt: 
	  (# 
	  do (if e.activeFlag//true then consoleWindow.activate else deActivateEvt if)
	  #);
	deActivateEvt: (# do consoleWindow.deactivate #);
	networkEvt: (# do INNER #);
	driverEvt: (# do INNER #);
	app1evt: (# do INNER #);
	app2evt: (# do INNER #);
	app3evt: (# do INNER #);
	app4Evt: (# do INNER #);
	suspendApplication: 
	(# ignore: @Integer;
	do false -> inForeGround;
	   consoleWindow.deactivate;
	   ZeroScrap -> ignore; TEToScrap -> ignore;
	#);
	childDied: (# pid,status : @integer enter (pid,status) do INNER #);
    resumeApplication:
      (# ignore: @Integer; doClipBoardConversion: @boolean
	  enter doClipBoardConversion 
	  do true -> inForeGround; 
	     consoleWindow.activate; 
		 InitCursor;
		 TEFromScrap -> ignore;
	  #);
	  
	mouseMoved: (# do INNER #);
	otherEvent: (# what : @integer enter what do INNER #);
			
	readOne: @
	(# sleep: @integer;
	enter sleep
	do
       (-1,e[],sleep, 0) -> waitNextEvent -> result;
		 (if result
		   //0 then (* null event *)
		       consoleWindow.theTE -> TEIdle;
		   else
			 (if e.what
			 //1 then e.message -> MouseDown
			 //2 then e.message -> MouseUp
			 //3 then e.charCode -> KeyDown
			 //4 then e.charCode -> keyUp
			 //5 then e.charCode -> autoKey
			 //6 then e.message -> UpdateEvt
			 //7 then diskEvt
			 //8 then activateEvt
			 //10 then networkEvt
			 //11 then driverEvt
			 //12 then app1evt
			 //13 then app2evt
			 //14 then app3evt
			 //15 then (* this can be one the multi-finder events having special meaning *)
				 (if e.app4Selector 
				  //1 then
				    (if e.resume//true then
				       e.scrapDataHasChanged -> resumeApplication
				     else 
				       suspendApplication
				    if)
				  //250 (* $FA *) then MouseMoved 
				  //253 (* $FD *) then (e.where,e.childDiedStatus) -> childDied
				  else app4evt
				 if)
			 else e.message -> otherEvent 
	if)if)#)#);
	
	terminate : @boolean;
	ignoreKeystrokes: @boolean;
    inForeGround : @boolean;
    dragRect,sizeRect: @macRect;
	stopIsCalled: @Boolean;
    globvar: @globvars; (* 'globvar' is a beta-interface to the quick-draw globals *)
	isRunning: @Boolean;
	
	init:
	  (# s: ^ScreenStream;
	     k: ^KeyboardStream;
	  do &ScreenStream[] -> s[] -> screen[]; 
		 &normalKeyboardStream[] -> k[] -> keyboard[];
		 THIS(Console)[] -> s.c[]; (* make the THIS(Console) avaliable in screen and keyboard *)
		 THIS(Console)[] -> k.c[];
	  #);
		  
     doterminate: 
	 (# ignore: @Integer;
	 do (if isRunning//true then
	        consoleWindow.theTE -> TEDeactivate;
			true -> ignoreKeystrokes;
			ConsoleWindow.EndCmdPeriodCheck;
			ascii.newline -> ConsoleWindow.putch;
			ascii.newline -> ConsoleWindow.putch;
			'Close the window or select Quit in File menu to stop execution' -> ConsoleWindow.insert;
			(* wait for user accept to remove window *)
			loop : (if terminate//false then eventreader.readOne; restart loop if);
		    (if TEGetScrapLength>0//true then
			    ZeroScrap -> ignore;  
				TEToScrap -> ignore;
			if);
	 if)#);
  do init;
	 INNER;
  #);
  
ScreenStream : stream 
	(# 
	
	 c: ^console;
	 put::< 
	  (#
	  do c.ConsoleWindow.show; 
		 ch -> c.ConsoleWindow.PutCh; 
		 (if c.stopIsCalled//false then
			  (if c.ConsoleWindow.CheckCmdPeriod //true then 
					true -> c.stopIsCalled;
				  (failure,'Program execution aborted by user') -> Stop
		 if)if);
	  #);
	 putText::<
	  (#
		do c.ConsoleWindow.show;
		  txt -> c.ConsoleWindow.insert; 
		 (if c.stopIsCalled//false then
			  (if c.ConsoleWindow.CheckCmdPeriod //true then 
					true -> c.stopIsCalled;
				  (failure,'Program execution aborted by user') -> Stop
		 if)if);
		 (*true -> doneInInner*)
	  #);
	 doTerminate: (# do c.doTerminate #);
	#);
	
normalKeyboardStream: KeyboardStream
	(# blocked: @boolean;
		block::
			(# doCheck: @check;
			do (if blocked then
					exception
						(#
						do	'Trying to read from the  keyboard while it is already waiting for input'
								-> msg.putLine;
						#);
				else
					true -> blocked;
					loop:	(if blocked then
								2 -> doCheck;
								restart loop;
							if);
				if);
			#);
		continue::
			(#
			do false -> blocked;
			#);
	#);
KeyboardStream : stream 
	(# c: ^console;
		block:<
		    (*
			 * Must block until continue is called.
			 * This virtual is bound in "basicsystemenv_mac.bet" 
			 * to use a semaphor so the keyboard.get will
			 * not block the scheduler in systemenv.
			 *)
			(#
			do INNER;
			#);
		continue:<
		    (*
			 * Must cause block to terminate
			 *)
			(#
			do INNER;
			#);
		check:
			(*
			 * Sleep is measured in ticks; 1 tick = 1/60 sec.
			 *)
			(# sleep: @integer;
			enter sleep
			do 0 -> c.ConsoleWindow.lastCH;
				sleep -> c.eventReader.readOne;
				(if (c.ConsoleWindow.lastCH = 13) OR (c.ConsoleWindow.lastCH = 3) then
					c.ConsoleWindow.charbuf.reset;
					continue;
				if);
			#);
	
		get::< 
			(#
			do c.ConsoleWindow.show;
				(* (if c.ConsoleWindow.charbuf.eos = false then
					(if c.ConsoleWindow.charbuf.peek = ascii.newline then
						c.ConsoleWindow.charbuf.clear;
					if)
				if);
				*)
				(if c.ConsoleWindow.charbuf.eos then
					(* no chars in buffer, get a new line *)
					c.ConsoleWindow.charbuf.clear;
					block; (* Michael Lassen:
					 		* Block blocks until there is a line
					        * of chars in the consolewindow.
							* The c.consolewindow.readline call is
							* obsolete. See comment for Block.
							*)
					(* c.consolewindow.readline; *) (*  read chars on input until nl *)
				if);
				c.ConsoleWindow.charbuf.get -> ch;
				(if ch = 3 then
					13 -> ch;
				if);
			#);
		peek::< 
			(#
			do c.ConsoleWindow.show;
				(* (if c.ConsoleWindow.charbuf.eos = false then
					(if c.ConsoleWindow.charbuf.peek = ascii.newline then
						c.ConsoleWindow.charbuf.clear;
					if)
				if);
				*)
				(if c.ConsoleWindow.charbuf.eos then
					(* no chars in buffer, get a new line *)
					c.ConsoleWindow.charbuf.clear;
					block; (* Michael Lassen was here:
							  * Block blocks until there is a line
							  * of chars in the consolewindow.
							  * The c.consolewindow.readline call is
							  * obsolete. See comment for Block
							  *)
					(* c.consolewindow.readline; *)(* read chars on input until nl *)
				if);
				c.ConsoleWindow.charbuf.peek -> ch; (* peek next char *)
				(if ch = 3 then 13 -> ch if);
			#);
		getline::< 
			(#
			do c.ConsoleWindow.show;
				(* read a new line from keyboard *)
				c.ConsoleWindow.charbuf.clear;
				block;	(* Michael Lassen was here:
						 * Block blocks until there is a line
						 * of chars in the consolewindow.
						 * The c.consolewindow.readline call is
						 * obsolete. See comment for Block
						*)
				(* c.consolewindow.readline; *) (* read chars on input until nl *)
				c.ConsoleWindow.charbuf -> txt;
				(if txt.length > 0 then
				   (if (txt.T[txt.length])//13//3 then
				      txt.lgth - 1 -> txt.lgth;
				   if);
				if);
				c.ConsoleWindow.charbuf.clear;
				(*true -> doneInInner;*)
			#);
		eos::< 
			(#
			do FALSE -> value; (* Never end of stream! *)
			   (*
				*(if c.ConsoleWindow.charbuf.eos = false  then
				*	(if c.ConsoleWindow.charbuf.peek = ascii.newline then
				*		c.ConsoleWindow.charbuf.clear;
				*		true->value;
				*	if)
				*if);
			    *)
			#);
	#);

---- StartConsole: descriptor ----
  (# do &console #)
  
---- DoTerminateConsole: descriptor ----
  (# s: ^ScreenStream;
     getStandAlone : external(# isRunningAlone : @integer do callC exit isRunningAlone #);
  do (if getStandAlone//1 then 
		 (if screen##=ScreenStream## then (* is the screen a console ScreenStream *)
		     screen[] -> s[];
		     s.doterminate;
	 if)if);
  #)
