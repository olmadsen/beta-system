ORIGIN 'betaenvbody';
INCLUDE '~beta/win32lib/ntinterface';
BUILD default '$$/basicio.obj' 'external/basicio.c'
              'betacc $0 $1';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1984-96
 *       All rights reserved.
 *
 *)
-- betaenvbodyMDInitAscii: descriptor -- 
(#
do
   (* Initialize private.NonWhiteSpace. Offsett by one to allow test for
    * isNonWhiteSpace(0)
    *)
   (* From '!'(33) to '~'(126) is NonWhiteSpace *)
   (for ch: (126-33+1) repeat true->private.NonWhiteSpace[ch+33] for);
   (* From <inverted exclamation>(161) to <y umlaut>(255) is NonWhiteSpace 
    * (iso8859, Latin-1)
    *)
   (for ch: (255-161+1) repeat true->private.NonWhiteSpace[ch+161] for);

#)
--betaenvInitEnv: descriptor--
(# UnixScreen: Stream (* A standard UNIX screen *)
     (# EOFvalue: external(# eof: @integer exit eof #);
        Eos::< (#do true->value #); (* Changed from false 19/10-92 by datpete *)
	OtherError::< (# do 'Screen error'->msg.puttext #);(****????*)
        Get::< (# do 'Warning: attempt to Get from the Screen' -> screen.putline; #);
	Put::< 
          (# PutToScreen: External(# ch: @char enter ch do CallC #);
	  do ch->PutToScreen;
	  #);
	PutText::< 
          (# PutTextToScreen: External(# str: @integer enter str #);
	  do (if Txt.lgth > 0 then
                 (if Txt.lgth < Txt.T.range then 0 -> Txt.T[Txt.lgth+1] if);
                 @@Txt.T[1]->PutTextToScreen;
             if)
          #);
      #);
   UnixKeyBoard: Stream (* A standard Unix keyboard *)
     (# Eos::<
       	  (# KeyboardEOS: External(# yes: @boolean do CallC exit yes #);
	  do KeyboardEOS->value
	  #);
	OtherError::< (#do 'Keyboard error'->msg.puttext #); (****????*)
        Put::< (# do 'Warning: attempt to Put to the Keyboard' -> screen.putline; #);
	Get::<
          (# GetFromKeyboard: External(# ch: @char do CallC exit ch #)
	  do GetFromKeyboard->ch
	  #);
        GetAtom::<
          (# KeyboardPeek: External(# ch: @char do CallC exit ch #);
	     GetFromKeyboard: External(# ch: @char do CallC exit ch #);
          do skipBlanks:
               (if KeyboardPeek->ascii.isWhiteSpace then
                   GetFromKeyboard; restart skipBlanks 
               if);
             scan:
               (if not (KeyboardPeek->ascii.isWhiteSpace) then
                   (if (txt.pos+1->txt.pos) > txt.T.range then txt.T.range+16->txt.T.extend if);
                   GetFromKeyboard->txt.T[txt.pos]; txt.lgth+1->txt.lgth;
                   restart scan
               if)
	  #);
        GetLine::<
          (# KeyboardPeek: External(# ch: @char do CallC exit ch #);
	     GetFromKeyboard: External(# ch: @char do CallC exit ch #);
          do scan:
               (if KeyboardPeek<>ascii.newline then
                   (if (txt.pos+1->txt.pos) > txt.T.range then txt.T.range+16->txt.T.extend if);
                   GetFromKeyboard->txt.T[txt.pos]; txt.lgth+1->txt.lgth;
                   restart scan
                else getFromKeyboard
               if)
          #);	Peek::<
	  (# KeyboardPeek: External(# ch: @char do CallC exit ch #)
	  do KeyboardPeek->ch
	  #);
     #);
do 
(*    getEOFvalue->EOFvalue;*)
    ascii.init;
    ascii.nl-> ascii.newline;
    &UnixScreen[]->screen[]; 
    &UnixKeyBoard[]->keyboard[];
#)
-- betaenvTerminateEnv: descriptor --
(##)
-- betaenvbodyTerminateConsole: descriptor --
(##)
--- lib: attributes ---
ArgumentHandler:
  (# noOfArgs: @Integer;
     ArgStrings: [0]^Text;
     AddArg:
       (# T: ^Text;
       enter T[]
       do noOfArgs+1 -> noOfArgs;
          (if noOfArgs > ArgStrings.range then
              noOfArgs -> ArgStrings.extend;
          if);
          T.Copy -> ArgStrings[noOfArgs][];
       #);
     
     init:
       (# T: @Text; Path: ^Text;
          idx: @Integer;
          count: @Integer;
          ch: @Char;
       do (for i: Argc repeat
               i -> Argv -> T;
               T -> OpenNTFindFiles -> count;
               (if count < 1 then
                   T[] -> AddArg;
                else
                   0 -> idx;
                   (for i: T.length repeat 
                        i -> T.inxGet -> ch;
                        (if (ch = '\\') or (ch = '/') then
                            i -> idx 
                        if)
                   for);
                   (if idx > 0 then
                       (1, idx) -> T.sub -> Path[]
                   if);                       
                   (for j: count repeat
                        GetNTFindFiles -> T;
                        (if idx > 0 then Path[] -> T.prepend if);
                        T[] -> AddArg
                   for)
               if);
               CloseNTFindFiles
          for)
       #);
     
     getArg:
       (# argNo: @Integer; theArg: ^Text;
       enter argNo
       do (if ((1<=argNo) and (argNo<=noOfArgs)) then
              ArgStrings[argNo].copy -> theArg[]
          if)
       exit theArg[]
       #);
  #)  
--- betaenvNoOfArguments: dopart ---
do (# ah: ^ArgumentHandler;
   do ObjectPool.get
      (# type::ArgumentHandler; exact::trueObject;
         init::(# do obj.init #);
      #) -> ah[];
      ah.noOfArgs->value
   #);
--- betaenvArguments: dopart ---
do (# ah: ^ArgumentHandler;
   do ObjectPool.get
      (# type::ArgumentHandler; exact::trueObject;
         init::(# do obj.init #);
      #) -> ah[];
      argNo -> ah.getArg -> theArg[];
   #);
   
