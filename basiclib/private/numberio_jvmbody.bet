ORIGIN 'numberioBody';
INCLUDE 'betaenv_jvmbody';
(*
 * COPYRIGHT
 *       Copyright (C) Mjolner Informatics, 1992-2003
 *       All rights reserved.
 *)   
--- numberioPutHex: descriptor ---
(# d, j: @integer;
   achar:@char;
   ch,padding:@char;
   putC: @put;
   significant:@boolean;
   myput:@
     (# ch:@char;
     enter ch
     do (if ch='0' then
            (if significant then
                ch->putC
             else
                padding->putC
            if)
         else
            true->significant;
            ch->putC
        if);
     #);
do false->significant;
   (if zeroPadding then
       '0'->padding
    else
       ' '->padding
   if);
   (if x=0 then
       (for i:width-1 repeat padding->putC; for);
       '0'->putC;
    else
       (if uppercase then
           'A'->achar;
        else
           'a'->achar;
       if);
       (for byte: 4 repeat
            (byte-1)->j; j->x.%getByte->d;
            d div 16->j; (if j<=9 then '0'+j->myput else achar+j-10->myput if);
            d mod 16->j; (if j<=9 then '0'+j->myput else achar+j-10->myput if);
       for);
   if);
#)

--- numberioPutByteHex: descriptor ---
(# d, j: @integer;
   putC: @put
do (byte-1)->j; j->x.%getByte->d;
   d div 16->j; (if j<=9 then '0'+j->putC else 'A'+j-10->putC if);
   d mod 16->j; (if j<=9 then '0'+j->putC else 'A'+j-10->putC if)
#)

--- numberioPutOctal: descriptor ---
(# j:@integer;
   first:@boolean;
   ch,padding:@char;
   putC:@put
do false->first;
   (if zeroPadding then
       '0'->padding
    else
       ' '->padding
   if);
   (if width>11 then
       (for i:width-11 repeat
            padding->putC;
       for);
       11->width;
   if);
   ((0,2)->x.%getbits)+'0'->ch;
   (if ch>'0' then
       true->first;
       ch->putC;
    else
       (if width=11 then
           padding->putC;
       if);
   if);
   
   (for i:10 repeat
        ((3*i-1,3)->x.%getbits)+'0'->ch;
        (if first then 
            ch->putC;
         else
            (if ch>'0' then
                ch->putC;
                true->first;
             else
                (if i>10-width then
                    padding->putC;
                if);
            if);
        if);
   for);
#)


--- numberioPutBinary: descriptor ---
(# putC: @put;
   first:@boolean;
   ch,padding:@char;
do false->first;
   (if zeroPadding then
       '0'->padding
    else
       ' '->padding
   if);
   (for i:32 repeat
        '0'+(((i-1),1)->x.%getBits)->ch;
        (if first then
            ch->putC;
         else
            (if ch='1' then
                ch->putC;
                true->first;
             else
                (if i>32-width then
                    padding->putC;
                if);
            if);
        if);
   for)
#)
--- numberioPutByteBinary: descriptor ---
(# j: @integer;
   putC: @put
do (byte-1)*8->j;
   (for i:8 repeat
        '0'+(((j+i-1),1)->x.%getBits)->putC
   for)
#)

--- numberIoPutRealBody: descriptor ---
(# 
do 'numberIoPutRealBody' -> NYI
#)

-- NumberioReadnumberToReal: dopart --
do 'NumberioReadnumberToReal' -> NYI
