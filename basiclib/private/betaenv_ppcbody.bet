ORIGIN 'betaenvbody';
OBJFILE default '$/betaenv_ppcbody.c.o';
OBJFILE default '$/betaenv_ppcconsole.o';
RESOURCE default 'external/betaenv_ppcbody.rsrc';
-- betaenvbodyMDInitAscii: Descriptor --
(* initialize upCase and lowCase *)
  (# UClc: @
       (# UC,lc: @integer 
       enter (UC,lc) 
       do UC->private.UPCASE[lc]; 
          lc->private.lowCase[UC]; 
       #)
  do
     (128,138)->UClc;
     (* swedish ae *)
     (129,140)->UClc;
     (* danish aa *)
     (130,141)->UClc;
     (* french c *)
     (131,142)->UClc;
     (* french e *)
     (132,150)->UClc;
     (* strange n *)
     (133,154)->UClc;
     (* swedish o *)
     (134,159)->UClc;
     (* german U *)
     (174,190)->UClc;
     (* danish ae *)
     (175,191)->UClc;
     (* danish oe *)
     (202,32)->UClc;
     (* nonbreaking space *)
     (203,136)->UClc;
     (* funny french a *)
     (204,139)->UClc;
     (* funny french a *)
     (205,155)->UClc;
     (* funny french o *)
     (206,207)->UClc;
     (* french ae *)
     (* Initialize private.NonWhiteSpace. Offsett by one to allow test for
      * isNonWhiteSpace(0)
      *)
     (* From '!'(33) to '~'(126) is NonWhiteSpace *)
     (for ch: (126-33+1) repeat true->private.NonWhiteSpace[ch+33] for);
     (* From <inverted exclamation>(161) to <y umlaut>(255) is NonWhiteSpace 
      * in Macintosh ASCII table
      *)
     (for ch: (255-161+1) repeat true->private.NonWhiteSpace[ch+161] for);
     
  #)  

-- betaenvinitEnv: Descriptor --
(# MPWScreen: Stream 
     (# Eos::< (# do False->value #);
        OtherError::< (# do 'OtherError in Screen '->msg.puttext #);
        Put::<
          (# PutToScreen: External (# ch: @integer enter ch do CallC #); 
          do ch->PutToScreen; 
          #);
        Get::
          (# 
          do 'Warning: attempt to Get from the Screen' -> screen.putline; 
          #);
        PutText::< (* For efficiency reasons. *)
          (# PutTextToScreen: External (# t: @integer enter t #); 
          do
             (if Txt.lgth > 0 then
                 (if Txt.lgth < Txt.T.range then 0->Txt.T[Txt.lgth+1] if);
                 @@ Txt.T[1]->PutTextToScreen;
             if)
          #);
        
     #);
   MPWKeyBoard: Stream
     (# Eos::<
          (# KeyboardEOS: External (# yes: @boolean do CallC exit yes #); 
          do KeyboardEOS->value; 
          #);
        OtherError:: (# do 'Keyboard Error'->msg.puttext #);
        Put::
          (# 
          do 'Warning: attempt to Put to the Keyboard' -> screen.putline;
          #);
        Get::
          (# GetFromKeyboard: External (# ch: @char;  do CallC exit ch #); 
          do GetFromKeyboard->ch; 
          #);
        Peek::
          (# KeyboardPeek: External (# ch: @char do CallC exit ch #)
          do KeyboardPeek->ch
          #);
        
     #);
   getStandAlone: external (# isRunningAlone: @integer do callC exit isRunningAlone #);
   
do
   ascii.init;
   ascii.cr->ascii.newLine;
   (if getStandAlone=1 then 
       &PPCScreen[]->screen[]; &PPCKeyBoard[]->keyboard[]; 
    else
       (* a MPW tool *)
       &MPWScreen[]->screen[]; &MPWKeyBoard[]->keyboard[]; 
   if)
#)  

-- betaenvTerminateEnv: Descriptor --
(# do TerminateConsole #)  

-- betaenvBodyTerminateConsole: Descriptor --
(# do TerminateConsole #)  

-- LIB: Attributes --
PPCScreen: Stream 
  (# Eos:: (# do False->value #);
     OtherError:: (# do 'OtherError in Screen '->msg.puttext #);
     Put::
       (# PPC_PutCh: External (# ch: @integer enter ch do CallC #); 
       do ch->PPC_PutCh; 
       #);
     Get::
       (# 
       do 'Warning: attempt to Get from the Screen' -> screen.putline; 
       #);
     PutText:: (* For efficiency reasons. *)
       (# PPC_PutLine: External (# t: @integer enter t #); 
       do
          (if Txt.lgth > 0
           // true then
              (if Txt.lgth < Txt.T.range then 0->Txt.T[Txt.lgth+1] if);
              @@ Txt.T[1]->PPC_PutLine;
          if)
       #);
     
  #);
PPCKeyBoard: Stream 
  (# Eos::
       (# KeyboardEOS: External (# yes: @boolean do CallC exit yes #); 
       do KeyboardEOS->value; 
       #);
     OtherError:: (# do 'Keyboard Error'->msg.puttext #);
     Put::
       (# 
       do 'Warning: attempt to Put to the Keyboard' -> screen.putline;
       #);
     Get::
       (# GetFromKeyboard: External (# ch: @char;  do CallC exit ch #); 
       do GetFromKeyboard->ch; 
       #);
     Peek::
       (# KeyboardPeek: External (# ch: @char do CallC exit ch #) do KeyboardPeek->ch #);
     
  #);
TerminateConsole:
  (# PPC_WaitForQuit: external (# do callC #);
     getStandAlone: external 
       (# isRunningAlone: @integer do callC exit isRunningAlone #);
     
  do
     (if getStandAlone=1 then
         (if screen##=PPCScreen## (* is the screen a C PPCScreen *) 
             then PPC_WaitForQuit; 
         if)
     if);
     
  #)  

