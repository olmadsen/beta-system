ORIGIN '../timedate.bet';
INCLUDE '~beta/basiclib/v1.6/formatio';
INCLUDE '~beta/sysutils/v1.6/time';
INCLUDE '~beta/basiclib/v1.6/external';
INCLUDE '~beta/basiclib/v1.6/math';
INCLUDE '~beta/basiclib/v1.6/numberio';

--- timePrivate:descriptor ---
(# year, month(*[0-11]*), day(*[0-...]*), hour, minute, sec, weekday: @integer;
   jdd, jdf:  @real; jd: (# exit jdd+jdf #);
#)

--- timeExitTime:dopart ---
do private.year->year;
   private.month+1(*to adjust to [1-12]*)->month;
   private.day+1(*to adjust to [1-...]*)->day;
   private.hour->hour;
   private.minute->minute;
   private.sec->sec;
   
   
--- timeEnterTime:dopart ---
do year->private.year;
   month-1(*to adjust to [0-11]*)->adjustMonth;
   day-1(*to adjust to [0-...]*)->private.day;
   hour->private.hour;
   minute->private.minute;
   sec->private.sec;
   GregCal2JD; JD2GregCal;
   
--- timeTimeNow:dopart ---
do systemTime -> t.clockChanged;
   
--- timeTimeMin:dopart ---
do 0.0 -> t.private.jdd -> t.private.jdf; t.JD2GregCal;
   
--- timeTimeMax:dopart ---
do (9000000,12,31,23,59,59)->t;
   
--- timeDifference: dopart ---
do (# tMin, tMax: ^time
   do
      (if t1.private.jd<t2.private.jd then
          t1[]->tMin[]; t2[]->tMax[]
       else
          t2[]->tMin[]; t1[]->tMax[]
      if);    
      
      (tMax.private.jd-tMin.private.jd) -> wfloor -> d.days;
      
      tMax.sec-tMin.sec->d.seconds;
      tMax.minute-tMin.minute->d.minutes;
      tMax.hour-tMin.hour->d.hours;
      (if d.seconds<0 then d.minutes-1->d.minutes; 60+d.seconds->d.seconds if);
      (if d.minutes<0 then d.hours-1->d.hours; 60+d.minutes->d.minutes if);
      (if d.hours<0 then d.days-1->d.days; 24+d.hours->d.hours if);
   #)
   
--- timePutTime:dopart ---
do '%s %s %02.d %04.d %02.d:%02.d:%02.d'->putFormat
   (# m: ^text
   do (if t.private.weekday
       // 0 then 'Sun'->s;
       // 1 then 'Mon'->s;
       // 2 then 'Tue'->s;
       // 3 then 'Wed'->s;
       // 4 then 'Thu'->s;
       // 5 then 'Fri'->s;
       // 6 then 'Sat'->s;
       else '['->m[];t.private.weekday->m.putint;']'->m.put; m[]->s
      if);
      (if t.private.month
       // 0 then 'Jan'->s
       // 1 then 'Feb'->s
       // 2 then 'Mar'->s
       // 3 then 'Apr'->s
       // 4 then 'May'->s
       // 5 then 'Jun'->s
       // 6 then 'Jul'->s
       // 7 then 'Aug'->s
       // 8 then 'Sep'->s
       // 9 then 'Oct'->s
       // 10 then 'Nov'->s
       // 11 then 'Dec'->s
       else
          '['->m[];
          t.private.month+1(*to adjust to [1-12]*)->m.putint;
          ']'->m.put; m[]->s
      if);
      t.private.day+1(*to adjust to [1-...]*)->d;
      t.private.year->d;
      t.private.hour->d; t.private.minute->d; t.private.sec->d;
   #);
   
-- timeGetTime:dopart ---
do '%s%s%d%d%d:%d:%d'->getFormat
   (# year, month, day, hour, minute, sec: @integer;
      mt: ^text;
   do s->mt[];
      s->mt[];
      (if true
       // 'Jan'->mt.equal then 1->month
       // 'Feb'->mt.equal then 2->month
       // 'Mar'->mt.equal then 3->month
       // 'Apr'->mt.equal then 4->month
       // 'May'->mt.equal then 5->month
       // 'Jun'->mt.equal then 6->month
       // 'Jul'->mt.equal then 7->month
       // 'Aug'->mt.equal then 8->month
       // 'Sep'->mt.equal then 9->month
       // 'Oct'->mt.equal then 10->month
       // 'Nov'->mt.equal then 11->month
       // 'Dec'->mt.equal then 12->month
       else (if (1->mt.inxget)='[' then
                mt.reset;
                '\\[%d\\]'->mt.getFormat
                (# do d->month #)
            if)
      if);
      d->day;
      d->year;
      d->hour; d->minute; d->sec;
      (year, month, day, hour, minute, sec)->t
   #)
   
--- timePutDate:dopart ---
do '%s %s %02.d %04.d'->putFormat
   (# m: ^text
   do (if t.private.weekday
       // 0 then 'Sun'->s;
       // 1 then 'Mon'->s;
       // 2 then 'Tue'->s;
       // 3 then 'Wed'->s;
       // 4 then 'Thu'->s;
       // 5 then 'Fri'->s;
       // 6 then 'Sat'->s;
       else '['->m[];t.private.weekday->m.putint;']'->m.put; m[]->s
      if);
      (if t.private.month
       // 0 then 'Jan'->s
       // 1 then 'Feb'->s
       // 2 then 'Mar'->s
       // 3 then 'Apr'->s
       // 4 then 'May'->s
       // 5 then 'Jun'->s
       // 6 then 'Jul'->s
       // 7 then 'Aug'->s
       // 8 then 'Sep'->s
       // 9 then 'Oct'->s
       // 10 then 'Nov'->s
       // 11 then 'Dec'->s
       else
          '['->m[];
          t.private.month+1(*to adjust to [1-12]*)->m.putint;
          ']'->m.put; m[]->s
      if);
      t.private.day+1(*to adjust to [1-...]*)->d;
      t.private.year->d;
   #);
   
-- timeGetDate:dopart ---
do '%s%s%d%d'->getFormat
   (# year, month, day: @integer;
      mt: ^text;
   do s->mt[];
      s->mt[];
      (if true
       // 'Jan'->mt.equal then 1->month
       // 'Feb'->mt.equal then 2->month
       // 'Mar'->mt.equal then 3->month
       // 'Apr'->mt.equal then 4->month
       // 'May'->mt.equal then 5->month
       // 'Jun'->mt.equal then 6->month
       // 'Jul'->mt.equal then 7->month
       // 'Aug'->mt.equal then 8->month
       // 'Sep'->mt.equal then 9->month
       // 'Oct'->mt.equal then 10->month
       // 'Nov'->mt.equal then 11->month
       // 'Dec'->mt.equal then 12->month
       else (if (1->mt.inxget)='[' then
                mt.reset;
                '\\[%d\\]'->mt.getFormat
                (# do d->month #)
            if)
      if);
      d->day;
      d->year;
      (year, month, day, 00, 00, 00)->t
   #)

--- timePutClock:dopart ---
do '%02.d:%02.d:%02.d'->putFormat
   (# do t.private.hour->d; t.private.minute->d; t.private.sec->d #);
   
-- timeGetClock:dopart ---
do '%d:%d:%d'->getFormat
   (# do (0, 1, 1, d, d, d)->t #)

   
--- timePutPeriod: dopart ---
do '%02.d#%02.d:%02.d:%02.d'->putFormat
   (# do p.days->d; p.hours->d; p.minutes->d; p.seconds->d #)
   
--- timeGetPeriod: dopart ---
do '%d#%d:%d:%d'->getFormat
   (# do d->p.days; d->p.hours; d->p.minutes; d->p.seconds #)
   
--- timeEnterYear:dopart ---
do value->private.year;
   GregCal2JD;JD2GregCal;
   
--- timeExitYear:dopart ---
do private.year->value
   
--- timeEnterMonth:dopart ---
do value-1(*to adjust to [0-11]*)->adjustMonth;
   GregCal2JD;JD2GregCal;
   
--- timeExitmonth:dopart ---
do private.month+1(*to adjust to [1-12]*)->value
   
--- timeEnterDay:dopart ---
do value-1(*to adjust to [0-...]*) -> private.day;
   GregCal2JD;JD2GregCal;

--- timeExitDay:dopart ---
do private.day+1(*to adjust to [1-...]*)->value
   
--- timeEnterHour:dopart ---
do value -> private.hour;
   GregCal2JD;JD2GregCal;
   
--- timeExitHour:dopart ---
do private.hour->value
   
--- timeEnterMinute:dopart ---
do value -> private.minute;
   GregCal2JD;JD2GregCal;
   
--- timeExitMinute:dopart ---
do private.minute->value
   
--- timeEnterSec:dopart ---
do value -> private.sec;
   GregCal2JD;JD2GregCal;
   
--- timeExitSec:dopart ---
do private.sec->value
   
--- timeExitWeekday: dopart ---
do private.weekday+1(*to adjust to [1-7]*)->value

--- timeSameYear:dopart ---
do (other.private.year=private.year)->value;
   
--- timeSameMonth:dopart ---
do (other->SameYear) and
   (other.private.month=private.month)->value;
   
--- timeSameDay:dopart ---
do (other->SameMonth) and
   (other.private.day=private.day)->value;
   
--- timeSameHour:dopart ---
do (other->SameDay) and
   (other.private.hour=private.hour)->value;
   
--- timeSameMinute:dopart ---
do (other->SameHour) and
   (other.private.minute=private.minute)->value;
   
--- timeSameSec:dopart ---
do (other->SameMinute) and
   (other.private.sec=private.sec)->value;
   
--- timeBefore:dopart ---
do not ((other->equal) or (other->after)) -> value
   
--- timeAfter:dopart ---
do
   (if true
    // (other.private.year<private.year) then
       true->value
    // (other.private.year=private.year) then
       (if true
        // (other.private.month<private.month) then
           true->value
        // (other.private.month=private.month) then
           (if true
            // (other.private.day<private.day) then
               true->value
            // (other.private.day=private.day) then
               (if true
                // (other.private.hour<private.hour) then
                   true->value
                // (other.private.hour=private.hour) then
                   (if true
                    // (other.private.minute<private.minute) then
                       true->value
                    // (other.private.minute=private.minute) then
                       (if true
                        // (other.private.sec<private.sec) then
                           true->value
                        // (other.private.sec=private.sec) then
                           false->value   
                        else
                           false->value
                       if)
                    else
                       false->value
                   if)
                else
                   false->value
               if)
            else
               false->value
           if)
        else
           false->value
       if)
    else
       false->value
   if)
   
--- timeBetween:dopart ---
do (((d1->after) and (d2->before)) or (d1->equal) or (d2->equal))
     ->value;
   
--- timeAdd: dopart ---
do (# tf, td: @real;
   do       
      private.day+p.days->private.day;
      private.hour+p.hours->private.hour;
      private.minute+p.minutes->private.minute;
      private.sec+p.seconds->private.sec;
      
      GregCal2JD;JD2GregCal;
   #)
   
--- timeSub: dopart ---
do (# tf, td: @real;
   do
      private.day-p.days->private.day;
      private.hour-p.hours->private.hour;
      private.minute-p.minutes->private.minute;
      private.sec-p.seconds->private.sec;
      
      GregCal2JD;JD2GregCal;
   #)
   
--- timeLib:attributes ---

adjustMonth:
  (# value,yp,mp: @integer;
  enter value
  do (if value >= 0 then
         value / 12 -> yp;
         value mod 12 -> mp;
      else
         - value -> value;
         - (( (value-1) / 12) + 1) -> yp;
         (if value mod 12 <> 0 then
             (12 - (value mod 12)) -> mp;
         if);
     if);
     yp + private.year -> private.year;
     mp -> private.month;
  #);

adjustClock:
  (#
  do (if private.sec<0 then
         private.minute-1->private.minute; 60+private.sec->private.sec
     if);
     (if private.minute<0 then
         private.hour-1->private.hour; 60+private.minute->private.minute
     if);
     (if private.hour<0 then
         private.day-1->private.day;24+private.hour->private.hour
     if);
     private.minute + (private.sec div 60)
       -> private.minute; private.sec mod 60 -> private.sec;
     private.hour + (private.minute div 60)
       -> private.hour; private.minute mod 60 -> private.minute;
     private.day + (private.hour div 24)
       -> private.day; private.hour mod 24 -> private.hour;
  #);

(* ================================================================ *)
(* ====                                                        ==== *)
(* ====      Julian Day Calculation                            ==== *)
(* ====                                                        ==== *)
(* ====      Converted from Pascal-library "HostLib"           ==== *)
(* ====      from H.B. Christensen's thesis project            ==== *)
(* ====      in astrophysics.                                  ==== *)
(* ====                                                        ==== *)
(* ====      Originally BASIC programs appearing in            ==== *)
(* ====      "Sky and Telescope", May 1984                     ==== *)
(* ====                                                        ==== *)
(* ================================================================ *)

JD2GregCal:
  (# f,a1,a,b,c,d,e,m,y: @Real;
  do private.jdf -> f;
     private.jdd -> d;
     
     f + 0.5 -> f;
     (if f >= 1.0 then f-1 -> f; d+1 -> d; if);
     
     ( (d/36524.25) - 51.12264 ) -> wfloor -> a1;
     d + 1 + a1 - ((a1/4)->wfloor) -> a;
     a + 1524 -> b;
     ( (b/365.25) - 0.3343 ) -> wfloor -> c;
     365.25 * c -> wfloor -> d;
     ((b-d)/30.61) -> wfloor -> e;
     b - d - ((30.61*e)->wfloor) + f -> d;
     e - 1 -> m;
     c - 4716.0 -> y;
     (if e > 13.5 then m - 12 -> m if);
     (if m < 2.5 then y + 1 -> y if);
     y -> private.year;
     m-1(*to adjust to [0-11]*) -> private.month;
     d-1(*to adjust to [0-..]*) -> private.day;
     
     (* Weekday is rather simple, but remember that julian day
      begins at noon! *)
     private.jd + 1.5 -> private.weekday;         (* cast to integer *)
     private.weekday mod 7 -> private.weekday;
  #);

GregCal2JD:
  (* One or more of YEAR, MONTH, DAY, etc changed... update julian day *)
  (# d,d1,f,j,j1,m,s,a: @Real;
     pd: @Integer;
  do adjustClock;
     private.day+1(*to adjust to [1-...]*) -> d;
     private.month+1(* to adjust to [1-12]*) -> m;
     d -> wfloor -> d1; d - d1 - 0.5 -> f;
     - ( ( 7 * ((((m+9)/12) -> wfloor)+private.year) / 4 ) -> wfloor ) -> j;
     (if true
      // (m-9) > 0 then 1 -> s;
      // (m-9) < 0 then -1 -> s;
      else 0 -> s;
     if);
     (m-9) -> fabs -> a;
     (private.year + s * ((a/7) -> wfloor)) -> wfloor -> j1;
     - ( ( (((j1/100) -> wfloor) + 1)*3/4 ) -> wfloor )-> j1;
     j + ((275*M/9) -> wfloor)+ d1 + j1 -> j;
     j + 1721027+2+367.0*private.year -> j;
     (if f < 0 then f + 1 -> f; j - 1 -> j; if);
     j -> private.jdd;
     f -> private.jdf;
     
     (* Weekday is rather simple *)
     private.jd + 1.5 -> pd;
     pd mod 7 -> private.weekday;
  #);

(* value of CLOCK changed, update YEAR, MONTH, DAY, etc. accordingly  *)
clockChanged:
  (# struct_tm: externalrecord
       (# tm_sec:    long(# pos:: (# do 0->value #) #);
          tm_min:    long(# pos:: (# do 4->value #) #);
          tm_hour:   long(# pos:: (# do 8->value #) #);
          tm_mday:   long(# pos:: (# do 12->value #) #);
          tm_mon:    long(# pos:: (# do 16->value #) #);
          tm_year:   long(# pos:: (# do 20->value #) #);
          tm_wday:   long(# pos:: (# do 24->value #) #);
          tm_yday:   long(# pos:: (# do 28->value #) #);
          tm_isdst:  long(# pos:: (# do 32->value #) #);
       enter ptr
       exit ptr
       #);
     
     t: @struct_tm;
     clock: @time_t;
     
     localtime: external
       (# time_t_ptr: ^time_t;
          tm_ptr: @integer;
          
       enter (time_t_ptr[])
       do callC
       exit tm_ptr
       #);
     
  enter clock.value
  do clock[]->localtime->t;
     
     t.tm_sec->private.sec;
     t.tm_min->private.minute;
     t.tm_hour->private.hour;
     t.tm_mday-1(*to adjust to [0-..]*)->private.day;
     t.tm_mon->private.month;
     (t.tm_year + 1900)->private.year;
     GregCal2JD;
  #);


time_t: cStruct
  (# byteSize:: (# do 4->value #);
     value: long(# pos:: (# do 0->value #) #)
  #);



--- lib: attributes ---

wfloor: (# i,o: @real enter i do i->floor->o exit o #);

frac: (# i,o: @Real; enter i do i-(i->wfloor)->o exit o #);
