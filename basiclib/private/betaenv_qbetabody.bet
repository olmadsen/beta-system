ORIGIN 'betaenvbody';
INCLUDE '~beta/sysutils/envstring';
(* This file is an experiment in creating a compiler for Beta 
 * using the VM for qbeta in MiniSystem/VM and other files in MiniSystem
 * At we use the machine_type 'qbeta' for this purpose
 *)
--LIB: attributes--

NYI:
  (# feature: ^text
  enter feature[]
  do (if not betaenvPrivate.no_nyi then
         '[Not yet implemented for .NET: ' -> puttext; 
         feature[] -> puttext; ']'->putline;
     if)
  #);


--betaenv_machine_type: dopart--
do 'qbeta' -> T;

--- betaenvStop: dopart ---
do newLine; 
   (if T[] <> NONE then T[]->putText; newline if);
   (if termCode
    // normal  then 

    // failure then 

    // failureTrace then 

    // dumpStack then

    else
       'Stop: Unknown termCode: '->screen.puttext; termCode->screen.putint; screen.newline;
   if)
   
--- betaenv_state:doPart ---
do 'betaenv:state' -> NYI
 
--- betaenvInfReal: dopart ---
do 'betaenv:infReal' -> NYI
   
--- betaenvDoGC: dopart ---
do 'betaenv:doGC' -> NYI
   
--betaenvbodyMDInitAscii: descriptor-- 
(#
do
   (* Initialize private.NonWhiteSpace. Offset by one to allow test for
    * isNonWhiteSpace(0)
    *)
   (* From '!'(33) to '~'(126) is NonWhiteSpace *)
   (for ch: (126-33+1) repeat true->private.NonWhiteSpace[ch+33] for);
   (* From <inverted exclamation>(161) to <y umlaut>(255) is NonWhiteSpace 
    * (iso8859, Latin-1)
    *)
   (for ch: (255-161+1) repeat true->private.NonWhiteSpace[ch+161] for);

#)
--betaenvInitEnv: descriptor--
(# beta_suppress_nyi: ^text;
do ascii.init;
   ascii.nl-> ascii.newline;
   (*&ClrConsole[]->screen[]; 
   (&ClrKeyboard[]).init->keyboard[];
   &rawargumenthandler[] -> argumenthandler[];
   Coroutine.ParseBETART;
   Coroutine.get_noNYI -> betaenvPrivate.no_nyi;*)
#)

--- betaenvNoOfArguments: dopart ---
do (*'betaenvNoOfArguments: dopart'->putline;*)
   (*ArgVector.range -> value*)
   
--- betaenvArguments: dopart ---
do (if ((1<=argNo) and (argNo<=ArgVector.range)) then
       ArgVector[argNo].copy->theArg[]
   if)
   
--- betaenvExpandArgumentsprivate: descriptor ---
(##)

--- betaenvExpandNoOfArguments: dopart ---
do 
   
--- betaenvExpandArguments: dopart ---
do  

--- betaenvPrivate: descriptor ---
(# no_nyi: @boolean; #)

--- exceptionMain: dopart ---
do INNER exception;
   (if not continue and not propagate then       
       (if true (*UseOldExceptions*) then
           failureTrace->termCode;
           '*** Exception processing\n'->msg.prepend;
           (termCode, msg[])->stop;
        else
           (* throw this static exception object
            * as a dynamic exception
            *
           (if this(exception)##=unknown## then
               (failureTrace,msg[])->stop
            else
               this(exception)[]->throw;
            if)
            *)
       if);
   if);
   
--- exceptTryHandlerWhenContinue: dopart ---
do 'betaenv:exceptTryHandlerWhenContinue'  -> NYI
--- exceptTryHandlerWhenRetry: dopart ---
do 'betaenv:exceptTryHandlerWhenRetry'  -> NYI
--- exceptTryHandlerWhenPropagate: dopart ---
do 'betaenv:exceptTryHandlerWhenPropagate'  -> NYI
--- exceptTryHandlerWhenAbort: dopart ---
do 'betaenv:exceptTryHandlerWhenAbort'  -> NYI
--- exceptTryHandlerWhen: descriptor ---
(#
do 'betaenv:exceptTryHandlerWhen'  -> NYI
#)
--- exceptTryHandlerPrivate: descriptor ---
(#
do 'betaenv:exceptTryHandlerPrivate'  -> NYI 
#)

--- exceptTryPrivate: descriptor ---
(#
do 'betaenv:exceptTryPrivate'  -> NYI 
#)

--- exceptTryHandle: descriptor ---
(#
do 'betaenv:exceptTryHandle'  -> NYI 
#)

--- exceptTry: dopart ---
do 'betaenv:exceptTry'  -> NYI 
   
--- exceptThrowPrivate: descriptor ---
(#
do 'betaenv:exceptThrowPrivate'  -> NYI 
#)

--- exceptThrow: dopart ---
do 'betaenv:exceptThrow'  -> NYI 

--betaenvDoPart: dopart--
do init;
   &|program[]->theProgram[];
   theProgram;
   (if theScheduler[]<>NONE then theScheduler if);
   
