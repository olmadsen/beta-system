ORIGIN  'filebody';
INCLUDE '~beta/dotnetlib/beta_helpers';
INCLUDE 'betaenv_clrbody';
INCLUDE '~beta/dotnetlib/System/IO/File';
INCLUDE '~beta/dotnetlib/System/IO/Directory';
INCLUDE '~beta/dotnetlib/System/IO/FileInfo';
INCLUDE '~beta/dotnetlib/System/IO/FileSystemInfo';
INCLUDE '~beta/dotnetlib/System/IO/DirectoryInfo';
INCLUDE '~beta/dotnetlib/System/IO/FileAttributes';
INCLUDE '~beta/dotnetlib/System/DateTime';
INCLUDE '~beta/dotnetlib/System/Convert';
INCLUDE '~beta/dotnetlib/System/IO/SeekOrigin';
INCLUDE '~beta/dotnetlib/System/IO/FileMode';
INCLUDE '~beta/dotnetlib/System/IO/StreamReader';
INCLUDE '~beta/dotnetlib/System/IO/StreamWriter';
INCLUDE '~beta/dotnetlib/System/IO/BinaryReader';
INCLUDE '~beta/dotnetlib/System/IO/BinaryWriter';
INCLUDE '~beta/dotnetlib/System/IO/FileStream';
INCLUDE '~beta/dotnetlib/System/IO/Stream';

(* This fragment group is the .NET dependent implementation of files *)



(*************** DiskEntry: ******************)


--DiskEntryException: dopart-- 
do 'Disk entry exception for \''->msg.puttext;
   path -> msg.puttext;
   '\''->msg.putline;
   'Error in system call: ' -> msg.puttext;
   (*getErrno -> errorstring -> msg.putline;*)
   INNER;

--DiskEntryPrivate: descriptor--
(# path: @text;
   pathchanged: @boolean;
   head, name, main, suf: ^text;
   info: ^FileSystemInfo;
   finfo: ^FileInfo;
   dinfo: ^DirectoryInfo;
   checkInfo: booleanvalue
     (# 
     do (if true 
         // (path[]->DotnetDirectory.Exists) then
            (if dinfo[]=NONE then path[] -> &DirectoryInfo[] -> dinfo[] -> info[] if);
            true -> value;
         // (path[]->DotnetFile.Exists) then
            (if finfo[]=NONE then path[] -> &FileInfo[] -> finfo[] -> info[] if);
            true -> value;
         else 
            NONE -> info[];
            NONE -> dinfo[];
            NONE -> finfo[];
            false -> value;
        if);
     #);
   hasAttribute: booleanValue
     (# att: @int32;
     enter att
     do (if checkInfo then
            (if false then
                'file_clrbody: diskEntry.hasAttribute'  -> NYI;
                (* FIXME: HACK: bit-and of "reference" and integer!
                 * Works almost (by coincidence) if a pop instruction is deleted in the IL (:-)
                 *)
                (*((info.get_Attributes->asFileAttributes) %Band att = att) -> value; *)
            if);
            (info[], att) -> BetaHelpers.diskentryHasAttribute -> value;
        if);
     #);
   decomposepath: 
     (# i: @integer;
     do (if pathchanged then
	    (* decompose path. FIXME: Could use System.IO.Path *)
	    0->i;
            (* Assume \ is separator *)
            '\\' -> path.findAll(# do inx -> i #);
            (* No \ found, check for / instead *)
            (if i=0 then '/' -> path.findAll(# do inx -> i #); if);
	    &text[]->head[];
            (if i=0 then 
                path.copy -> name[];
	     else
		path.t[1:i-1] -> head;
                &text[] -> name[];
		path.t[i+1:path.length] -> name;
	    if);
	    (* decompose name *)
            0->i;
	    '.' -> name.findAll(# do inx -> i #);
            &text[] -> suf[];
	    (if i=0 then 
                name.copy -> main[];
	     else
                &text[] -> main[];
		name.t[1:i-1] -> main;
		name.t[i:name.length] -> suf;
	    if);
	    false -> pathchanged
	if);
     #);
#)

--DiskEntryPathHead: dopart--
do INNER; &text[]->h[]; private.decomposepath; private.head -> h 

--DiskEntryPathNamePref: dopart--
do INNER; &text[] -> p[]; private.decomposepath; private.main -> p

--DiskEntryPathNameSuf: dopart--
do INNER; &text[]->s[]; private.decomposepath; private.suf -> s

--DiskEntryPathNameExt: dopart--
do INNER;
   &text[]->e[]; 
   private.decomposepath; 
   private.suf.t[2:private.suf.length] -> e

--DiskEntryPathNameGet: dopart--
do INNER; &text[]->n[]; private.decomposepath; private.name -> n

--DiskEntryPathSet: dopart--
do INNER;
   (if p[]=NONE then &text[]->p[] if);
   p -> private.path;
   private.checkInfo;
   true -> private.pathchanged;

--DiskEntryPathGet: dopart--
do INNER; private.path.copy -> p[]

--DiskEntryExists: dopart--
do (private.path[]->DotnetFile.Exists) or 
   (private.path[]->DotnetDirectory.Exists) 
     -> value

--DiskEntryTouch: dopart--
do INNER; (* Allow File/Directory to create itself *)
   (if true
    // private.dinfo[]<>NONE then
       DateTime.get_Now -> private.dinfo.set_LastWriteTime;
    // private.finfo[]<>NONE then
       DateTime.get_Now -> private.finfo.set_LastWriteTime;
    else
       (* Create file *)
       private.path[] -> &FileInfo[] -> private.finfo[];
       private.finfo.Create;
   if);
   
--DiskEntrySize: dopart--
do (if true
    // private.dinfo[]<>NONE then
       0 -> value;
    // private.finfo[]<>NONE then 
       private.finfo.get_Length -> value
    else 
       error;
   if)
   
--DiskEntryGetModTime:dopart--
do (if true
    // private.dinfo[]<>NONE then
       (private.dinfo.get_LastWriteTime->asDateTime).ToFileTime -> BetaHelpers.fileTimeToModtime -> time
    // private.finfo[]<>NONE then
       (private.finfo.get_LastWriteTime->asDateTime).ToFileTime -> BetaHelpers.fileTimeToModtime -> time
    else 
       error;
   if);

--DiskEntrySetModTime:dopart--
do (if true
    // private.dinfo[]<>NONE then
       (time -> BetaHelpers.modtimeToFileTime) -> DateTime.FromFileTime -> private.dinfo.set_LastWriteTime;
    // private.finfo[]<>NONE then
       (time -> BetaHelpers.modtimeToFileTime) -> DateTime.FromFileTime -> private.finfo.set_LastWriteTime;
    else 
       error;
   if);

--DiskEntryRename: dopart--
do (if true
    // private.dinfo[]<>NONE then
       newpath[] -> private.dinfo.MoveTo;
    // private.finfo[]<>NONE then
       newpath[] -> private.finfo.MoveTo;
    else
       error
   if);

--DiskEntryReadable: dopart--
do true->value; (* FIXME: Really always readable? *)

--DiskEntryWriteable: descriptor--
(# 
do not (FileAttributes.ReadOnly->private.hasAttribute) -> value
#)

--DiskEntryIsDir: dopart--
do (FileAttributes.DotnetDirectory->private.hasAttribute) -> value
   
--DiskEntryIsFile: dopart--
do not (FileAttributes.DotnetDirectory->private.hasAttribute) -> value (* FIXME: check *)
   
   
   
   
(*************** File: ******************)
   
--FilePrivate:descriptor--
(# 
   fs: ^FileStream;   (* Actual filestream underneath readers/writers below *)
   sr: ^StreamReader; (* Used to read text *)
   sw: ^StreamWriter; (* Used to write text *)
   br: ^BinaryReader; (* Used to read values by binfile and filerep *)
   bw: ^BinaryWriter; (* Used to write values by binfile and filerep *)
   i: @integer;
   s: ^DotnetStream; (* temporary variable used by getpos/setpos *)
#)

--FileOtherException: dopart--
do 'Error in system call: ' -> msg.puttext;
   (*getErrno -> errorstring -> msg.putline;*)
   INNER

--FileTouch: dopart--
do entry.touch;

--FileLength: dopart--
do entry.size -> value

--FileDoOpen:descriptor--
(# 
do (* Not needed on .Net *)
#)

--FileOpenRead:dopart--
do (if private.sr[]<>NONE then private.sr.Close if);
   (if private.br[]<>NONE then private.br.Close if);
   entry.private.finfo.OpenRead -> private.fs[];
   (if binary then
       private.fs[] -> BinaryReader._init_Stream -> private.br[];
    else
       private.fs[] -> StreamReader._init_Stream -> private.sr[];
   if);

--FileOpenWrite:dopart--
do (if entry.private.finfo[]<>NONE then
       (* Delete existing file *)
       entry.private.finfo.Delete;
    else
       (* Set up finfo for new file *)
       entry.private.path[] -> &FileInfo[] -> entry.private.finfo[] -> entry.private.info[];
   if);
   entry.private.finfo.OpenWrite -> private.fs[];
   (if binary then
       private.fs[] -> BinaryWriter._init_Stream -> private.bw[];
    else
       private.fs[] -> StreamWriter._init_Stream -> private.sw[];
   if);
   
--FileOpenReadWrite:dopart--
do 'file_clrbody: FileOpenReadWrite'  -> NYI;
   
--FileOpenAppend:dopart--
do (if entry.private.finfo[]=NONE then
       (* Set up finfo for new file and create it *)
       entry.private.path[] -> &FileInfo[] -> entry.private.finfo[] -> entry.private.info[];
       entry.private.finfo.CreateText -> private.sw[];
       private.sw.Close;
   if);
   (if binary then
       (if false then
           (* Code gen error due to untyped enumerations in BETA (SeekOrigin) *)
           entry.private.finfo.OpenWrite -> private.fs[];
           private.fs[] -> BinaryWriter._init_Stream -> private.bw[];
           (0, SeekOrigin.End) -> private.bw.Seek;
        else
           'file_clrbody: FileOpenAppend for binary file' -> NYI;
       if);
    else
       entry.private.finfo.AppendText -> private.sw[];
   if);
   
--FileOpenReadAppend:dopart--
do 'file_clrbody: FileOpenReadAppend'  -> NYI;
   
--FileDelete:dopart--
do (if entry.private.checkinfo then
       entry.private.info.Delete;
    else
       (*error;*)
   if);

--FilePut:dopart--
do (if binary then
       (if false then
           (* int8u not implemented *)
           ch -> private.bw.Write_int8u (*Write_char*);
        else
           (private.bw[], ch) -> BetaHelpers.WriteInt8u;           
       if);
    else
       ch -> private.sw.Write_char;
   if);

--FileGet:dopart--
do (if binary then
       (if false then
           (* int8u not implemented *)
           private.br.ReadByte (*read*) -> ch;
        else
           private.br[]-> BetaHelpers.ReadInt8u -> ch;
       if);
    else
       private.sr.Read -> ch;
   if);
   (if false then
       'FileGet: ch='->screen.puttext; ch->screen.putint; 
       ' '-> screen.put;
       entry.private.path[]->screen.putline;
   if)

--FilePeek:dopart--
do (if binary then
       'file_clrbody.bet: FilePeek for binary file' -> NYI;
    else
       private.sr.Peek -> ch;
   if);
   
--FilePutText:dopart--
do (if binary then
       txt[] -> private.bw.Write_String;
    else
       txt[] -> private.sw.Write_String;
   if);

--FileGetAtom:dopart--
do (if binary then
       'file_clrbody.bet: FileGetAtom for binary file' -> NYI;
    else
       private.sr.Read -> private.i;
       skipBlanks:
         (if private.i<> -1 then
             (if private.i->ascii.isWhiteSpace then
                 private.sr.Read -> private.i;
                 restart skipBlanks;
              else
                 scan:
                   (* atom not yet complete *)
                   (if txt.pos+1 > txt.T.range then
                       txt.T.range+16->txt.T.extend;
                       restart scan;
                    else
                       txt.pos+1->txt.pos;
                       private.i ->txt.T[txt.pos]; 
                       txt.lgth+1->txt.lgth;
                       (if private.i = -1 then
                           (* End of file - stop here *)
                        else
                           (if private.sr.Peek -> ascii.isWhiteSpace then
                               (* end of atom - stop *)
                            else
                               private.sr.Read -> private.i;
                               restart scan;
                           if)
                       if)
                   if);
             if);
          else 
             (* EOF while skipping blanks *)
         if)
   if)
   
--FileGetLine:dopart--
do (if binary then
       'file_clrbody.bet: FileGetLine for binary file' -> NYI;
    else
       private.sr.ReadLine -> txt[]
   if);
   
--FileGetPos:dopart--
do (if true then
       private.fs.get_Position -> value;
    else
       (if binary then
           'file_clrbody.bet: FileGetPos for binary file' -> NYI;
        else
           (if private.sr[]<>NONE then
               (private.sr.get_BaseStream->private.s[]).get_Position -> value
            else
               (if private.sw[]<>NONE then
                   (private.sw.get_BaseStream->private.s[]).get_Position -> value
               if);
           if)
       if);
   if);
   
--FileSetPos:dopart--
do (if mode<>FromBeginning then
       'file_clrbody.bet: FileSetPos not relative to beginning' -> NYI;
   if);
   (if true then
       p -> private.fs.set_Position;
    else
       (if binary then
           'file_clrbody.bet: FileGetPos for binary file' -> NYI;
        else
           (if private.sr[]<>NONE then
               newpos -> (private.sr.get_BaseStream->private.s[]).set_Position;
            else
               (if private.sw[]<>NONE then
                   newpos -> (private.sw.get_BaseStream->private.s[]).set_Position;
               if);
           if)
       if);
   if);
   
--FileEos:dopart--
do (if false then
       (private.fs.get_Position->BetaHelpers.long2int) 
       = (private.fs.get_Length->BetaHelpers.long2int)
         -> value;
    else
       (if binary then
           'file_clrbody.bet: FileEos for binary file' -> NYI;
        else
           private.sr.Peek = -1 -> value;
       if);
   if);

--FileFlush:dopart--
do (if binary then
       private.bw.Flush;
    else
       private.sw.Flush;
   if);

--FileClose:dopart--
do (if binary then
       (if private.br[]<>NONE then
           private.br.Close;
           NONE -> private.br[];
       if);
       (if private.bw[]<>NONE then
           private.bw.Close;
           NONE -> private.bw[];
       if);
    else
       (if private.sr[]<>NONE then
           private.sr.Close;
           NONE -> private.sr[];
       if);
       (if private.sw[]<>NONE then
           private.sw.Close;
           NONE -> private.sw[];
       if);
   if);
   (if private.fs[]<>NONE then
       private.fs.close;
   if);


