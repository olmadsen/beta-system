ORIGIN  'filebody';
INCLUDE '~beta/dotnetlib/beta_helpers';
INCLUDE 'betaenv_clrbody';
INCLUDE '~beta/dotnetlib/System/IO/FileInfo';
INCLUDE '~beta/dotnetlib/System/IO/FileAttributes';
INCLUDE '~beta/dotnetlib/System/DateTime';
INCLUDE '~beta/dotnetlib/System/Convert';

(*
 * COPYRIGHT
 *       Copyright Mjolner Informatics, 1986-2003
 *       All rights reserved.
 *)


(* This fragment group is the .NET dependent implementation of files *)

--DiskEntryException: dopart-- 
do 'Disk entry exception for \''->msg.puttext;
   path -> msg.puttext;
   '\''->msg.putline;
   'Error in system call: ' -> msg.puttext;
   (*getErrno -> errorstring -> msg.putline;*)
   INNER;

--DiskEntryPrivate: descriptor--
(# path: @text;
   pathchanged: @boolean;
   head, name, main, suf: ^text;
   info: ^FileInfo;
   decomposepath: 
     (# i: @integer;
     do (if pathchanged then
	    (* decompose path *)
	    0->i;
            (* Assume \ is separator *)
            '\\' -> path.findAll(# do inx -> i #);
            (* No \ found, check for / instead *)
            (if i=0 then '/' -> path.findAll(# do inx -> i #); if);
	    &text[]->head[];
            (if i=0 then 
                path.copy -> name[];
	     else
		path.t[1:i-1] -> head;
                &text[] -> name[];
		path.t[i+1:path.length] -> name;
	    if);
	    (* decompose name *)
            0->i;
	    '.' -> name.findAll(# do inx -> i #);
            &text[] -> suf[];
	    (if i=0 then 
                name.copy -> main[];
	     else
                &text[] -> main[];
		name.t[1:i-1] -> main;
		name.t[i:name.length] -> suf;
	    if);
	    false -> pathchanged
	if);
     #);
#)

--DiskEntryPathHead: dopart--
do INNER; &text[]->h[]; private.decomposepath; private.head -> h 

--DiskEntryPathNamePref: dopart--
do INNER; &text[] -> p[]; private.decomposepath; private.main -> p

--DiskEntryPathNameSuf: dopart--
do INNER; &text[]->s[]; private.decomposepath; private.suf -> s

--DiskEntryPathNameExt: dopart--
do INNER;
   &text[]->e[]; 
   private.decomposepath; 
   private.suf.t[2:private.suf.length] -> e

--DiskEntryPathNameGet: dopart--
do INNER; &text[]->n[]; private.decomposepath; private.name -> n

--DiskEntryPathSet: dopart--
do INNER;
   (if p[]=NONE then &text[]->p[] if);
   p -> private.path;
   private.path[] -> &FileInfo[] -> private.info[];
   true -> private.pathchanged;

--DiskEntryPathGet: dopart--
do INNER; private.path.copy -> p[]

--DiskEntryExists: dopart--
do private.info.get_Exists -> value

--DiskEntryTouch: dopart--
do (if private.info.get_Exists then
       DateTime.get_Now -> private.info.set_LastWriteTime;
    else
       private.info.Create;
   if);
   
--DiskEntrySize: dopart--
do private.info.get_Length -> value
   
--DiskEntryGetModTime:dopart--
do (* FIXME: missing * for int64: *)
   (*(private.info.get_LastWriteTime->asDateTime).ToFileTime -> BetaHelpers.long2intDiv1000 -> time*) 
   (if false then
       (# dt: ^DateTime;
          ft: @int64;
       do 'get_LastWriteTime' -> Console.Writeline_String;
          private.info.get_LastWriteTime->dt[];
          'dt set' -> Console.Writeline_String;
          (# dummy:@char do dt.ToFileTime -> ft; #);
          'ft set' -> Console.Writeline_String;
          ft -> BetaHelpers.long2intDiv1000 -> time;
          'time set' -> Console.Writeline_String;
       #)
   if)

--DiskEntrySetModTime:dopart--
do (* FIXME: missing * for int64 *)
   (time -> BetaHelpers.int2longMul1000) -> DateTime.FromFileTime -> private.info.set_LastWriteTime;   

--DiskEntryRename: dopart--
do (if private.info.get_Exists then
       error
    else
       newpath[] -> private.info.MoveTo;
   if);

--DiskEntryReadable: dopart--
do true->value; (* FIXME: Really? *)

--DiskEntryWriteable: descriptor--
(# 
do ((private.info.get_Attributes->asFileAttributes).value__ %Band FileAttributes.ReadOnly) = 0 
     -> value
#)

--DiskEntryIsDir: dopart--
do ((private.info.get_Attributes->asFileAttributes).value__ %Band FileAttributes.Directory) = FileAttributes.Directory
     -> value
   
--DiskEntryIsFile: dopart--
do ((private.info.get_Attributes->asFileAttributes).value__ %Band FileAttributes.Normal) = FileAttributes.Normal
     -> value
   
--FilePrivate:descriptor--
(# 
#)

--FileOtherException: dopart--
do 'Error in system call: ' -> msg.puttext;
   (*getErrno -> errorstring -> msg.putline;*)
   INNER

--FileTouch: dopart--
do 

--FileLength: dopart--
do entry.size -> value

--FileDoOpen:descriptor--
(# 
#)

--FileOpenRead:dopart--
do 

--FileOpenWrite:dopart--
do 
   
--FileOpenReadWrite:dopart--
do 
   
--FileOpenAppend:dopart--
do 
   
--FileOpenReadAppend:dopart--
do 
   
--FileDelete:dopart--
do 

--FilePut:dopart--
do 

--FileGet:dopart--
do 

--FilePeek:dopart--
do 
   
--FilePutText:dopart--
do 

--FileGetAtom:dopart--
do 

--FileGetLine:dopart--
do 
   
--FileGetPos:dopart--
do 
   
--FileSetPos:dopart--
do 
   
--FileEos:dopart--
do 

--FileFlush:dopart--
do 

--FileClose:dopart--
do 


