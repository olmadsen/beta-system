ORIGIN '../pcre';
MDBODY jvm     'pcre_jvmbody'
       clr     'pcre_clrbody'
       default 'pcre_stdbody';


---- PcrePrivate: descriptor ----
(#
   (* Private internal state *)
   compiled_regexp: @Integer;
   extra: @Integer;
   oVector: [1] @Integer;
   errtext, erroffset: @integer;
#)

-- PcreLib: attributes --
do_compile:
  (# exp: ^text;
     options: @integer;
  enter (exp[], options)
  <<SLOT PcreCompile:dopart>>
  #);
do_locale_compile:
  (# exp: ^text;
     options: @integer;
  enter (exp[], options)
  <<SLOT PcreLocaleCompile:dopart>>
  #);
do_study:
  (# options: @integer;
  enter (options)
  <<SLOT PcreStudy:dopart>>
  #);
do_full_info:
  (# 
  <<SLOT PcreFullInfo:dopart>>
  #);
do_exec:
  (# subject: ^text;
     position, options, status: @integer
  enter (subject[], position, options)
  <<SLOT PcreExec:dopart>>
  exit status
  #);
report_error:
  (# regexp: ^text
  enter regexp[]
  <<SLOT PcreError: dopart>>
  #);

--- PcreInit: dopart ----
do (if options %Band pcre_C_LOCALE <> 0 then
       (exp[], options %Band pcre_NONBETAOPTIONS) -> do_compile 
    else
       (exp[], options %Band pcre_NONBETAOPTIONS) -> do_locale_compile 
   if);
   (if private.compiled_regexp = 0 then
       exp[]->report_error;
    else
       (if options %Band pcre_DO_STUDY <> 0 then
           options %Band pcre_NONBETAOPTIONS -> do_study;
           (if private.errtext <> 0 then
               exp[]->report_error;
           if);
       if);
       do_full_info;
       ((subpatterns + 1) * 3) -> private.oVector.new;
   if);

---- PcreMatchPos: dopart ----
do private.oVector[1] + 1 -> start;
   private.oVector[2] -> end;

---- PcrePreMatchText: dopart ----
do (1, private.oVector[1]) -> subject.sub -> result[];

---- PcrePostMatchText: dopart ----
do (private.oVector[2] + 1, subject.lgth) -> subject.sub -> result[];

---- PcreSubMatchPos: dopart ----
do (if index <= subPatterns then
       private.oVector[index * 2 + 1] + 1 -> start;
       private.oVector[index * 2 + 2] -> end;
   if);

---- PcreSubMatchText: dopart ----
do index -> subMatchPos -> (start, end);
   (if start = 0 then
       (if opt %Band pcre_RETURN_NONE then
           NONE -> result[];
        else
           '' -> result[];
       if);
    else
       (start, end) -> subject.sub -> result[];
   if);

   
   
---- PcreMatchAllPrivate: descriptor ----
(#
   (* Private internal state *)
   endOfPreviousMatch: @Integer;
   splitPositions: [20] @Integer;
#)


---- PcreMatchAllPre: dopart ----
do 0 -> privatema.endOfPreviousMatch;
   0 -> matches;
   privatema.splitPositions.range -> privatema.splitPositions.new;
   INNER;

---- PcreMatchAllSplitPos: dopart ----
do privatema.endOfPreviousMatch + 1 -> start;
   private.oVector[1] -> end;

---- PcreMatchAllSplit: dopart ----
do matches + 1 -> thismatch;
   (if thismatch * 2 > privatema.splitPositions.range then
       privatema.splitPositions.range + 2 -> privatema.splitPositions.extend;
   if);
   splitPos ->
   (privatema.splitPositions[thismatch * 2 - 1], privatema.splitPositions[thismatch * 2]);
   INNER;

---- PcreMatchAllNoMatch: dopart ----
   (* Fix up private.oVector so you can call splitText and splitPos one
    * last time.
    *)
do subject.lgth -> private.oVector[1];
   subject.lgth -> private.oVector[2];
   split;
   post;
   INNER;

---- PcreMatchAllSpn: dopart ----
do (if num > matches + 1 then
       (if not (opt %Band pcre_RETURN_NONE) then
           '' -> result[];
       if);
    else
       (privatema.splitPositions[num * 2 - 1], privatema.splitPositions[num * 2]) ->
       subject.sub ->  result[];
   if);
   INNER;


---- PcreMatchAllRestn: dopart ----
do (if num > matches + 1 then
       (if not (opt %Band pcre_RETURN_NONE) then
           '' -> result[];
       if);
    else
       (privatema.splitPositions[num * 2 - 1], subject.lgth) ->
       subject.sub ->  result[];
   if);
   INNER;

   
---- PcreMatch: dopart ----
do options -> opt;
   0 -> subMatchCounter;
   pre;
   private.oVector.range -> private.oVector.new;
   (if subject.T.range = 0 then 1 -> subject.T.extend; 0 -> subject.T[1] if);
   position - 1 -> psn;
   (subject[], psn, opt %Band pcre_NONBETAOPTIONS) -> do_exec -> result;
   (result <> pcre_ERROR_NOMATCH) -> matched;
   (if matched then
       INNER;
    else
       noMatch;
   if);
   
---- PcreMatchAll: dopart ----
do split;
   matches + 1 -> matches;
   INNER matchAll;
   loop:
     (#
     do private.oVector[2] -> privatema.endOfPreviousMatch;
        (if private.oVector[2] >= subject.lgth then
	    leave loop;  (* Got to end of string *)
	if);
        (subject[], private.oVector[2], opt %Band pcre_NONBETAOPTIONS) -> do_exec -> result;
        (result <> pcre_ERROR_NOMATCH) -> matched;
        (if matched then
	    split;
	    matches + 1 -> matches;
	    INNER matchAll;
	 else
	    (* Fix up private.oVector so you can call splitText and splitPos one
	     * last time.
	     *)
	    subject.lgth -> private.oVector[1];
	    subject.lgth -> private.oVector[2];
	    split;
	    post;
	    true -> matched; (* At least one match occurred *)
	    leave loop;
        if);
        restart loop;
     #);
   
---- PcreReplace: dopart ----
do (1, private.oVector[1]) -> subject.sub -> new[];
   replacement[] -> rep -> new.append;
   (private.oVector[2] + 1, subject.lgth) -> subject.sub -> new.append;
   INNER;
   
--PcreCompilationError:dopart--
do 'PCRE: Error compiling regular expression "' -> msg.append;
   regexp[] -> msg.append;
   '":\n      ' -> msg.append;
   errorText[] -> msg.append;
   msg.newline;
   INNER;
