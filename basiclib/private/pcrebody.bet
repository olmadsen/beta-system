ORIGIN '../pcre';
MDBODY jvm     'pcre_jvmbody'
       clr     'pcre_clrbody'
       default 'pcre_stdbody';


---- PcrePrivate: descriptor ----
(#
   (* Private internal state *)
   compiled_regexp: @Integer;
   extra: @Integer;
   oVector: [1] @Integer;
#)

---- PcreMatchPos: dopart ----
do private.oVector[1] + 1 -> start;
   private.oVector[2] -> end;

---- PcrePreMatchText: dopart ----
do (1, private.oVector[1]) -> subject.sub -> result[];

---- PcrePostMatchText: dopart ----
do (private.oVector[2] + 1, subject.lgth) -> subject.sub -> result[];

---- PcreSubMatchPos: dopart ----
do (if index <= subPatterns then
       private.oVector[index * 2 + 1] + 1 -> start;
       private.oVector[index * 2 + 2] -> end;
   if);

---- PcreSubMatchText: dopart ----
do index -> subMatchPos -> (start, end);
   (if start = 0 then
       (if opt %Band pcre_RETURN_NONE then
           NONE -> result[];
        else
           '' -> result[];
       if);
    else
       (start, end) -> subject.sub -> result[];
   if);

   
   
---- PcreMatchAllPrivate: descriptor ----
(#
   (* Private internal state *)
   endOfPreviousMatch: @Integer;
   splitPositions: [20] @Integer;
#)


---- PcreMatchAllPre: dopart ----
do 0 -> privatema.endOfPreviousMatch;
   0 -> matches;
   privatema.splitPositions.range -> privatema.splitPositions.new;
   INNER;

---- PcreMatchAllSplitPos: dopart ----
do privatema.endOfPreviousMatch + 1 -> start;
   private.oVector[1] -> end;

---- PcreMatchAllSplit: dopart ----
do matches + 1 -> thismatch;
   (if thismatch * 2 > privatema.splitPositions.range then
       privatema.splitPositions.range + 2 -> privatema.splitPositions.extend;
   if);
   splitPos ->
   (privatema.splitPositions[thismatch * 2 - 1], privatema.splitPositions[thismatch * 2]);
   INNER;

---- PcreMatchAllNoMatch: dopart ----
   (* Fix up private.oVector so you can call splitText and splitPos one
    * last time.
    *)
do subject.lgth -> private.oVector[1];
   subject.lgth -> private.oVector[2];
   split;
   post;
   INNER;

---- PcreMatchAllSpn: dopart ----
do (if num > matches + 1 then
       (if not (opt %Band pcre_RETURN_NONE) then
           '' -> result[];
       if);
    else
       (privatema.splitPositions[num * 2 - 1], privatema.splitPositions[num * 2]) ->
       subject.sub ->  result[];
   if);
   INNER;


---- PcreMatchAllRestn: dopart ----
do (if num > matches + 1 then
       (if not (opt %Band pcre_RETURN_NONE) then
           '' -> result[];
       if);
    else
       (privatema.splitPositions[num * 2 - 1], subject.lgth) ->
       subject.sub ->  result[];
   if);
   INNER;


---- PcreReplace: dopart ----
do (1, private.oVector[1]) -> subject.sub -> new[];
   replacement[] -> rep -> new.append;
   (private.oVector[2] + 1, subject.lgth) -> subject.sub -> new.append;
   INNER;
