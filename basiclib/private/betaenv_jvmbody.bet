ORIGIN 'betaenvbody';
INCLUDE '~beta/javalib/java/lang/String';
INCLUDE '~beta/javalib/java/lang/Thread';
INCLUDE '~beta/javalib/java/io/PrintStream';
INCLUDE '~beta/javalib/java/io/Reader';
INCLUDE '~beta/javalib/java/io/InputStreamReader';
INCLUDE '~beta/javalib/java/io/BufferedReader';
INCLUDE '~beta/javalib/java/io/PushbackInputStream';
INCLUDE '~beta/javalib/betahelpers';

--LIB: attributes--

NYI:
  (# feature: ^text
  enter feature[]
  do (if true then
         'Not yet implemented for JVM: ' -> puttext; feature[] -> putline;
     if)
  #);

SetArgValues: (*proc - not recognized as special prefix here! *)
  (# program_name: ^String;
     args: [0]^String;
     trace: (# exit false #);
     out: ^PrintStream
       (* Cannot use putline in here as betaenv is not yet initialized *);
  enter (program_name[],args)
  do (if trace then
         BetaHelpers.get_System_out -> out[];
         'Trace(betaenv_jvmbody): SetArgValues called: ' -> out.print_String;
         'No of arguments: ' -> out.print_String;
         args.range -> out.print_I;
         '\n' -> out.print_I;
     if);
     args.range+1 -> ArgVector.new (* +1 to add program name *);
     program_name[] -> ArgVector[1][] (* Automatic conversion String->Text *);
     (for i:args.range repeat
          (if trace then
              'Trace(betaenv_jvmbody): SetArgValues: ' -> out.print_String;
              args[i][] -> out.print_String;
              '\n' -> out.print_I;
          if);
          args[i][] -> ArgVector[i+1][]; (* Automatic conversion String->Text *)
     for)
  #);

JavaConsole: Stream
  (# out: ^PrintStream;
     init:
       (#
       do BetaHelpers.get_System_out -> out[];
       exit THIS(JavaConsole)[]
       #);
     Eos::< 
       (# do true->value #); 
     OtherError::< 
       (# do 'Screen error'->msg.puttext #);
     Get::< 
       (# do 'Warning: attempt to Get from the Screen' -> screen.putline; #);
     Put::< 
       (# do ch -> out.write_I; out.flush #);
     PutText::< 
       (# do txt[] -> out.print_String #);
  #);
JavaKeyBoard: Stream
  (# pb: ^PushbackInputStream;
     in: ^InputStream;
     reader: ^BufferedReader;
     inputreader: ^InputStreamReader;
     i: @integer;
     init:
       (# 
       do (* Create a PushbackInputStream using constructor with InputStream argument *)
          BetaHelpers.get_System_in -> in[];
          in[] -> PushbackInputStream._init_InputStream -> pb[];
          in[] -> InputStreamReader._init_InputStream -> inputreader[];
          inputreader[] -> BufferedReader._init_Reader -> reader[];
       exit THIS(JavaKeyBoard)[]
       #);
     Eos::<
       (# i: @integer;
       do (if pb.available>0 then
              pb.read -> i -> pb.unread_I;
              i=ascii.eot -> value
           else
              false -> value;
          if);
       #);
     OtherError::< 
       (# do 'Keyboard error'->msg.puttext #);
     Put::< 
       (# do 'Warning: attempt to Put to the Keyboard' -> screen.putline; #);
     Get::<
       (# 
       do pb.read->ch;
       #);
     GetAtom::<
       (# 
       do (* Could probably use a StreamTokenizer *)
          pb.read -> i;
          skipBlanks:
            (if i<> -1 then
                (if i->ascii.isWhiteSpace then
                    pb.read -> i;
                    restart skipBlanks;
                 else
                    scan:
                      (* atom not yet complete *)
                      (if txt.pos+1 > txt.T.range then
                          txt.T.range+16->txt.T.extend;
                          restart scan;
                       else
                          txt.pos+1->txt.pos;
                          i ->txt.T[txt.pos]; 
                          txt.lgth+1->txt.lgth;
                          (if i = -1 then
                              (* End of file - stop here *)
                           else
                              (if pb.read -> i ->ascii.isWhiteSpace then
                                  (* end of atom - unread the whitespace and stop *)
                                  i -> pb.unread_I;
                               else
                                  restart scan;
                              if)
                          if)
                      if);
                if);
             else 
                (* EOF while skipping blanks *)
            if)
       #);
     GetLine::<
       (# 
       do reader.readLine -> txt[];
       #);
     Peek::<
       (# i: @integer;
       do pb.read -> i -> ch;
          i -> pb.unread_I;
       #);
  #);

_exit: External   
  (# status: @int32
  enter status
  do 'static java/lang/System/exit(I)V' -> callC 
  #);

--betaenv_machine_type: dopart--
do 'jvm' -> T;

--- betaenvStop: dopart ---
do newLine; 
   (if T[] <> NONE then T[]->putText; newline if);
   (if termCode
    // normal  then 
       0 -> _exit;
    // failure then 
       1 -> _exit;
    // failureTrace then 
       (* {* FIXME: java.lang.IncompatibleClassChangeError due to code generation error: *}
        * (Thread.currentThread).dumpStack;
        *)
       (* {* FIXME: java.lang.VerifyError: Inconsistent stack height 1 != 0: *}
        * Thread.currentThread -> betaenvprivate.t[];
        * betaenvprivate.t.dumpStack;
        *);
       (# (* FIXME: anonymous pattern yields extra frame on stack *)
          t: ^Thread;
       do Thread.currentThread -> t[];
          t.dumpStack;
       #);
       1 -> _exit;
    // dumpStack then
       (* {* FIXME: java.lang.IncompatibleClassChangeError due to code generation error: *}
        * (Thread.currentThread).dumpStack;
        *)
       (* {* FIXME: java.lang.VerifyError: Inconsistent stack height 1 != 0: *}
        * Thread.currentThread -> {*betaenv*}private.t[];
        * betaenvprivate.t.dumpStack;
        *)
       (# (* FIXME: anonymous pattern yields extra frame on stack *)
          t: ^Thread;
       do Thread.currentThread -> t[];
          t.dumpStack;
       #);
    else
       'Stop: Unknown termCode: '->screen.puttext; termCode->screen.putint; screen.newline;
   if)
   
--- betaenv_state:doPart ---
do 'betaenv:state'  -> NYI
 
--- betaenvInfReal: dopart ---
do 'betaenv:InfReal'  -> NYI
   
--- betaenvDoGC: dopart ---
do 'betaenv:DoGC'  -> NYI
   
--betaenvbodyMDInitAscii: descriptor-- 
(#
do
   (* Initialize private.NonWhiteSpace. Offset by one to allow test for
    * isNonWhiteSpace(0)
    *)
   (* From '!'(33) to '~'(126) is NonWhiteSpace *)
   (for ch: (126-33+1) repeat true->private.NonWhiteSpace[ch+33] for);
   (* From <inverted exclamation>(161) to <y umlaut>(255) is NonWhiteSpace 
    * (iso8859, Latin-1)
    *)
   (for ch: (255-161+1) repeat true->private.NonWhiteSpace[ch+161] for);

#)
--betaenvInitEnv: descriptor--
(# 
do ascii.init;
   ascii.nl-> ascii.newline;
   (&JavaConsole[]).init->screen[]; 
   (&JavaKeyboard[]).init->keyboard[];
   &rawargumenthandler[] -> argumenthandler[];
#)

--- betaenvNoOfArguments: dopart ---
do ArgVector.range -> value
   
--- betaenvArguments: dopart ---
do (if ((1<=argNo) and (argNo<=ArgVector.range)) then
       ArgVector[argNo].copy->theArg[]
   if)
   
--- betaenvExpandArgumentsprivate: descriptor ---
(##)

--- betaenvExpandNoOfArguments: dopart ---
do 
   
--- betaenvExpandArguments: dopart ---
do  

--- betaenvPrivate: descriptor ---
(# t: ^thread #)

--- exceptionMain: dopart ---
do INNER exception;
   (if not continue and not propagate then       
       (if true (*UseOldExceptions*) then
           failureTrace->termCode;
           '*** Exception processing\n'->msg.prepend;
           (termCode, msg[])->stop;
        else
           (* throw this static exception object
            * as a dynamic exception
            *
           (if this(exception)##=unknown## then
               (failureTrace,msg[])->stop
            else
               this(exception)[]->throw;
            if)
            *)
       if);
   if);
   
--- exceptTryHandlerWhenContinue: dopart ---
do 'betaenv:exceptTryHandlerWhenContinue'  -> NYI
--- exceptTryHandlerWhenRetry: dopart ---
do 'betaenv:exceptTryHandlerWhenRetry'  -> NYI
--- exceptTryHandlerWhenPropagate: dopart ---
do 'betaenv:exceptTryHandlerWhenPropagate'  -> NYI
--- exceptTryHandlerWhenAbort: dopart ---
do 'betaenv:exceptTryHandlerWhenAbort'  -> NYI
--- exceptTryHandlerWhen: descriptor ---
(#
do 'betaenv:exceptTryHandlerWhen'  -> NYI 
#)
--- exceptTryHandlerPrivate: descriptor ---
(#
do 'betaenv:exceptTryHandlerPrivate'  -> NYI 
#)

--- exceptTryPrivate: descriptor ---
(#
do 'betaenv:exceptTryPrivate'  -> NYI 
#)

--- exceptTryHandle: descriptor ---
(#
do 'betaenv:exceptTryHandle'  -> NYI 
#)

--- exceptTry: dopart ---
do 'betaenv:exceptTry'  -> NYI 
   
--- exceptThrowPrivate: descriptor ---
(#
do 'betaenv:exceptThrowPrivate'  -> NYI 
#)

--- exceptThrow: dopart ---
do 'betaenv:exceptThrow'  -> NYI 
   
--betaenvDoPart: dopart--
do init;
   &|program[]->theProgram[];
   theProgram; 
   (if theScheduler[]<>NONE then theScheduler if);
