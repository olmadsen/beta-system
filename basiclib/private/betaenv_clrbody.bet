ORIGIN 'betaenvbody';
INCLUDE '~beta/dotnetlib/System/String';
INCLUDE '~beta/dotnetlib/System/Environment';
INCLUDE '~beta/dotnetlib/System/Threading/Thread';
INCLUDE '~beta/dotnetlib/System/Console';
INCLUDE '~beta/dotnetlib/System/IO/TextReader';
INCLUDE '../textUtils';

BUILD   clr
        'clr/Coroutine.dll' 
        'external/Coroutine.cs' 
        'csc -nologo -debug:full -t:library -out:clr/Coroutine.dll -r:../clr/betaenv.dll $1';

--LIB: attributes--

SetArgValues:
  (# program_name: ^String;
     args: [0]^String;
  enter (program_name[],args)
  do args.range+1 -> ArgVector.new (* +1 to add program name *);
     program_name[] -> ArgVector[1][] (* Automatic conversion String->Text *);
     (for i:args.range repeat
          args[i][] -> ArgVector[i+1][]; (* Automatic conversion String->Text *)
     for)
  #);

NYI:
  (# feature: ^text
  enter feature[]
  do (if true then
         '[Not yet implemented for .NET: ' -> puttext; feature[] -> puttext; ']'->putline;
     if)
  #);

ClrConsole: Stream
  (# Eos::< 
       (# do true->value #); 
     OtherError::< 
       (# do 'Screen error'->msg.puttext #);
     Get::< 
       (# do 'Warning: attempt to Get from the Screen' -> screen.putline; #);
     Put::< 
       (#
       do (* NOTICE: BETA char 8 bit, IL char 16 bit *)
          ch -> Console.Write_Char; 
       #);
     PutText::< 
       (# 
       do (if false then
              (* FIXME: garbled output! 8 vs. 16 bit problem? *)
              (* NOTICE: BETA char 8 bit, IL char 16 bit *)
              txt[] -> Console.Write_String;
           else
              (for i: txt.lgth repeat
                   txt.T[i] -> put
              for)
          if)
       #);
  #);
ClrKeyBoard: Stream
  (* The .NET Framework (v1.1) does not offer a blocking peek, 
   * which is needed for correct semantics of the BETA keyboard.
   * Nor does the framework offer something equivalent for the 
   * Java PushBackInputStream.
   * The framework does, however, offer a blocking read, which we then 
   * used to implement a PushBack input stream.
   *)
  (# in: ^TextReader;
     buffer: [1]@char;
     has_peek: @boolean;
     readBlock: charValue
       (# nread: @int32;
          readSucceeeded:<object;
          readFailed:<object;
       do (if has_peek then
              buffer[1]->value;
              false->has_peek;
           else
              (buffer[], 0, 1) -> in.ReadBlock -> nread;
              (if nread=1 then
                  (* NOTICE: BETA char 8 bit, IL char 16 bit *)
                  buffer[1] %Band 0xff ->value;
                  readSucceeeded;
               else
                  ascii.eot->value;
                  readFailed;
              if);
          if);
          (*'readBlock: ch='->screen.puttext; value->screen.putint; screen.newline;*)
       #);
     peekBlock: readBlock
       (# readSucceeeded:<(# do true->has_peek #);
          readFailed:<(# do false->has_peek #);
       #);
     init:
       (# 
       do Console.get_In->in[]
       exit THIS(ClrKeyboard)[]
       #);
     Eos::<
       (# 
       do (peekBlock = ascii.eot) -> value;
       #);
     OtherError::< 
       (# do 'Keyboard error'->msg.puttext #);
     Put::< 
       (# do 'Warning: attempt to Put to the Keyboard' -> screen.putline; #);
     Get::<
       (# 
       do readBlock -> ch;
       #);
     GetAtom::<
       (# 
       do 'betaenv:ClrKeyboard.GetAtom' -> NYI
       #);
     GetLine::<
       (# ch: @char;
          cr_met: @boolean;
       do &text[]->txt[];
          (if true then
              (if has_peek then
                  readBlock->txt.put;
              if);
              Console.ReadLine -> txt.append;
           else
              false -> cr_met;
              read:
                (if readBlock->ch
                 // ascii.cr then 
                    true -> cr_met; 
                    restart read;
                 // ascii.nl then 
                    (if cr_met then
                        (* Found cariagereturn-newline, so we are at end of line *)
                        leave read;
                     else
                        (* embedded nl? *)
                        restart read;
                    if)
                 else
                    ch->txt.put;
                    false -> cr_met;
                    restart read;
                if);
          if);
       #);
     Peek::<
       (# 
       do peekBlock->ch;
       #);
  #);

--betaenv_machine_type: dopart--
do 'clr' -> T;

--- betaenvStop: dopart ---
do newLine; 
   (if T[] <> NONE then T[]->putText; newline if);
   (if termCode
    // normal  then 
       0 -> Environment.DotnetExit;
    // failure then 
       1 -> Environment.DotnetExit;
    // failureTrace then 
       Environment.get_StackTrace -> Console.WriteLine_String;
       1 -> Environment.DotnetExit;
    // dumpStack then
       Environment.get_StackTrace -> Console.WriteLine_String;
    else
       'Stop: Unknown termCode: '->screen.puttext; termCode->screen.putint; screen.newline;
   if)
   
--- betaenv_state:doPart ---
do 'betaenv:state' -> NYI
 
--- betaenvInfReal: dopart ---
do 'betaenv:infReal' -> NYI
   
--- betaenvDoGC: dopart ---
do 'betaenv:doGC' -> NYI
   
--betaenvbodyMDInitAscii: descriptor-- 
(#
do
   (* Initialize private.NonWhiteSpace. Offset by one to allow test for
    * isNonWhiteSpace(0)
    *)
   (* From '!'(33) to '~'(126) is NonWhiteSpace *)
   (for ch: (126-33+1) repeat true->private.NonWhiteSpace[ch+33] for);
   (* From <inverted exclamation>(161) to <y umlaut>(255) is NonWhiteSpace 
    * (iso8859, Latin-1)
    *)
   (for ch: (255-161+1) repeat true->private.NonWhiteSpace[ch+161] for);

#)
--betaenvInitEnv: descriptor--
(# 
do ascii.init;
   ascii.nl-> ascii.newline;
   &ClrConsole[]->screen[]; 
   (&ClrKeyboard[]).init->keyboard[];
   &rawArgumentHandler[]->argumentHandler[];
#)

--- betaenvNoOfArguments: dopart ---
do ArgVector.range -> value
   
--- betaenvArguments: dopart ---
do (if ((1<=argNo) and (argNo<=ArgVector.range)) then
       ArgVector[argNo].copy->theArg[]
   if)
   
--- betaenvExpandArgumentsprivate: descriptor ---
(##)

--- betaenvExpandNoOfArguments: dopart ---
do 
   
--- betaenvExpandArguments: dopart ---
do  

--- betaenvPrivate: descriptor ---
(##)

--- exceptionMain: dopart ---
do INNER exception;
   (if not continue and not propagate then       
       (if true (*UseOldExceptions*) then
           failureTrace->termCode;
           '*** Exception processing\n'->msg.prepend;
           (termCode, msg[])->stop;
        else
           (* throw this static exception object
            * as a dynamic exception
            *
           (if this(exception)##=unknown## then
               (failureTrace,msg[])->stop
            else
               this(exception)[]->throw;
            if)
            *)
       if);
   if);
   
--- exceptTryHandlerWhenContinue: dopart ---
do 'betaenv:exceptTryHandlerWhenContinue'  -> NYI
--- exceptTryHandlerWhenRetry: dopart ---
do 'betaenv:exceptTryHandlerWhenRetry'  -> NYI
--- exceptTryHandlerWhenPropagate: dopart ---
do 'betaenv:exceptTryHandlerWhenPropagate'  -> NYI
--- exceptTryHandlerWhenAbort: dopart ---
do 'betaenv:exceptTryHandlerWhenAbort'  -> NYI
--- exceptTryHandlerWhen: descriptor ---
(#
do 'betaenv:exceptTryHandlerWhen'  -> NYI 
#)
--- exceptTryHandlerPrivate: descriptor ---
(#
do 'betaenv:exceptTryHandlerPrivate'  -> NYI 
#)

--- exceptTryPrivate: descriptor ---
(#
do 'betaenv:exceptTryPrivate'  -> NYI 
#)

--- exceptTryHandle: descriptor ---
(#
do 'betaenv:exceptTryHandle'  -> NYI 
#)

--- exceptTry: dopart ---
do 'betaenv:exceptTry'  -> NYI 
   
--- exceptThrowPrivate: descriptor ---
(#
do 'betaenv:exceptThrowPrivate'  -> NYI 
#)

--- exceptThrow: dopart ---
do 'betaenv:exceptThrow'  -> NYI 

--betaenvDoPart: dopart--
do init;
   &|program[]->theProgram[];
   theProgram;
   (if theScheduler[]<>NONE then theScheduler if);
   
