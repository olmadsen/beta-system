ORIGIN '~beta/basiclib/v1.5/betaenv';
INCLUDE '~beta/basiclib/v1.5/numberio'
        '~beta/basiclib/v1.5/math'
        '~beta/containers/v1.5/list';
-- lib: Attributes --
treePPNode:
  (#
     element:< object;
     elm: ^element;
     sons: @list
       (#
          element::< treePPNode;
          width:<
            (# w: @real
            do
               scan
                 (# 
                 do
                    (if (current[] = (head).elm[]) or
                    (current[] = (last).elm[]) then
                        current.width div 2+w->w
                     else
                        current.width+w->w
                    if)
                 #)
            exit w
            #)
       #);
     appendSon:<
       (# son: ^treePPNode enter son[] do son[]->sons.append; INNER #);
     width:< (# w: @real do INNER width exit w #);
     print:< Object
  enter elm[]
  exit elm[]
  #);
link:
  (#
     next: ^link;
     pnode: ^treePPNode;
     pos: @real;
     print:<
       (# 
       do
          (if pnode[] <> none then
              pnode.print;
              ' '->puttext;
              pos->screen.putreal;
              newline;
              (if next[] <> none then next.print if)
          if)
       #)
  #);
treePPhead:
  (#
     next: ^treePPhead;
     first: ^link;
     print:<
       (# 
       do
          'Head: '->putline;
          (if first[] <> none then
              first.print; newline
           else
              'first i NONE'->putline
          if);
          (if next[] <> none then next.print if)
       #)
  #);
treePPposition:
  (#
     n: ^treePPNode;
     h: ^treePPhead;
     pos,minDist,resPos,leftPos,rightPos,i,sonSize,dummy: @real;
     l: ^link
  enter (n[],h[],pos,minDist)
  do
     (if n[] = none then
         pos->resPos
      else
         &link[]->l[];
         n[]->l.pnode[];
         n.sons.size->sonSize;
         (if h[] = none then
             &treePPhead[]->h[]
          else
             h.first[]->l.next[];
             (if h.first.pos+h.first.pnode.width div 2+minDist+n.width div 2 >
             pos then
                 h.first.pos+h.first.pnode.width div 2+minDist+n.width div 2
                   ->pos
             if)
         if);
         l[]->h.first[];
         (if n.sons.empty then
             pos->resPos
          else
             0->i;
             n.sons.scan
               (# 
               do
                  (if true
                   // i = 0 then
                      (if n.sons.size = 1 then
                          (current[],h.next[],pos,minDist)->treePPposition
                            ->(leftPos,h.next[])
                       else
                          (current[],h.next[],pos-
                           (n.sons.width div 2+(sonSize-1) div 2*minDist),
                           minDist)->treePPposition->(leftPos,h.next[])
                      if)
                   // i = sonSize-1 then
                      (current[],h.next[],pos+n.sons.width div 2+(sonSize-1) div
                       2*minDist,minDist)->treePPposition->(rightPos,h.next[])
                   else
                      (current[],h.next[],pos-
                       (n.sons.width div 2+(sonSize-1) div 2*minDist),minDist)
                        ->treePPposition->(dummy,h.next[])
                  if);
                  i+1->i
               #);
             (if n.sons.size = 1 then
                 leftPos->pos
              else
                 (leftPos+rightPos) div 2->pos
             if)
         if);
         pos->l.pos;
         pos->resPos
     if)
  exit (resPos,h[])
  #)  

