ORIGIN 'diagramattributes';
(* switch
 * 1  = general debugging
 * 21 = IndexIDList
 * 22 = RemakePP
 * 23 = DiagramList
 *)
(* DIAGRAM *)
INCLUDE '~beta/sysutils/v1.4/objinterface';
-- TitleInteractiveNew: DescriptorForm --
(# do (w,h)->Size #)  

-- TitleOnInit: DescriptorForm --
(#
do
   UDPrivate.UDDiagram
     ->UserDataInit
     (*toby 1-11-94:
      User data initializations*) ;
   UDtheParentNode.Init;
   UDtheFragmentNode.Init;
   thePrefixConn.Init;
   gppProp.fontSize->theText.size;
   bold->titleNode.theText.style;
   (* titleText -> theText.set; resposibility of sub patterns *)
   INNER OnInit;
#)  

-- TitleOnSelect: DescriptorForm --
(#
do
(*(PatternDiagrams.oldSelection[],THIS(title)[]) -> changedFocus;
 THIS(title)[] -> PatternDiagrams.oldSelection[];*)
#)
(* LISTDIAGRAM *)  

-- TitleTextModeOn: DescriptorForm --
(# do 'Text mode on in TitleNode'->putLine; theText.get->theTextBefore; #)  

-- TitleTextModeOff: DescriptorForm --
(# t: @text; theNode: ^patternDiagramNode; anExp: ^expanded;
do
   'Text mode off in titleNode '->putLine;
   theText.get->t;
   t[]->putLine;
   (if not (theTextBefore[]->t.equal) then
       'b '->putLine;
       (thisDiagram).theParentNode->theNode[];
       (if theNode[]
        // none then 'theDeclaration is none!! '->putLine
        else
           '1 '->putLine;
           theNode[]->currentObject;
           ((thisDiagram).theParentNode).getAstNode->anExp[];
           '2 '->putLine;
           (theNode[],(anExp.getSon1).index,t[])->declarationTextChanged;
           '3'->putLine;
       if)
    else
       'no changes'->putLine; false->ongoingTextediting
   if);
#)  

-- LocalNodesAbstractAll: DescriptorForm --
(# dummy: ^DiagramNode;
do
   (if current.struc <= DiagramNode##
    // true then
       current[]->dummy[];
       (if dummy.currentDecomposDiagram <> none
        // true then (dummy.currentDecomposDiagram).titleNode.abstract
       if)
   if);
#)  

-- InsertDiagramNode: DescriptorForm --
(#
   previousNode: ^PatternDiagramNode;
   i: @Integer;
   x,y,w,h: @Integer;
   startPos: @point;
   IsDynamic:
     (#
        yes: @Boolean;
        anAST: ^AST;
        decl: ^betaGram.SimpleDecl;
        theSpec: ^betaGram.ReferenceSpecification;
     enter anAST[]
     do
        (if anAST## <= betagram.SimpleDecl## then
            anAST[]->decl[];
            decl.GetReferenceSpecification->anAST[];
            (if anAST## <= betagram.ReferenceSpecification## then
                anAST[]->theSpec[];
                (if theSpec.symbol
                 // betaGram.dynamicItem // betaGram.dynamicComponent then
                    true->yes;
                if)
             else
                'Freja-- OOBS: anAST## <= betagram.ReferenceSpecification## failed'
                  ->screen.putline;
            if)
         else
            'Freja-- OOBS: anAST## <= betagram.SimpleDecl## failed'
              ->screen.putline;
        if);
     exit yes
     #);
   displayNode:
     (#
     do
        previousNode.geometry->(x,y,w,h);
        x-(w div 2)->x;
        x+gppProp.width->x;
        gppProp.width*2->w;
        previousNode[]->PatternDiagrams.addAfterNode[];
        (x-(w div 2),y-(h div 2)+gppProp.height)->startPos;
        (if anAst.kind
         // kinds.interior then
            (if anAst.symbol
             // betaGram.SimpleDecl then
                (if anAst[]->IsDynamic
                 // true then
                    (if gppProp.CompositionWith
                     // gppProp.CompositionAll // gppProp.CompositionReference
                     then
                        (if switch[23]
                         // true then
                            'dynamic CompositionWith, CompositionAll or CompositionReference'
                              ->putLine;
                        if);
                        (anAst[],startpos)->DisplayAST->startpos;
                    if);
                 else
                    (if gppProp.CompositionWith
                     // gppProp.CompositionAll // gppProp.CompositionPartWhole
                     then
                        (if switch[23]
                         // true then
                            'static  CompositionWith, CompositionAll or CompositionReference'
                              ->putLine;
                            'startpos before: '->putText;
                            startpos.x->putInt;
                            ' '->put;
                            startpos.y->putInt;
                            newline
                        if);
                        (anAst[],startpos)->DisplayAST->startpos;
                        (if switch[23]
                         // true then
                            'startpos after: '->putText;
                            startpos.x->putInt;
                            ' '->put;
                            startpos.y->putInt;
                            newline
                        if);
                    if)
                if);
             // betaGram.PatternDecl // betaGram.VirtualDecl
             // betaGram.BindingDecl
             // betaGram.RepetitionDecl (*// betaGram.VariablePatternDecl*)
             then
                (if gppProp.CompositionWith
                 // gppProp.CompositionAll // gppProp.CompositionBlock then
                    (if switch[23]
                     // true then
                        'InsertDiagramNode: PatternDecl, VirtualDecl, BindingDecl, RepetitionDecl'
                          ->putLine;
                        'startpos before: '->putText;
                        startpos.x->putInt;
                        ' '->put;
                        startpos.y->putInt;
                        newline
                    if);
                    (anAst[],startpos)->DisplayAST->startpos;
                    (if switch[23]
                     // true then
                        'startpos after: '->putText;
                        startpos.x->putInt;
                        ' '->put;
                        startpos.y->putInt;
                        newline
                    if);
                if)
            if)
         // kinds.unexpanded then
            (if switch[23]
             // true then
                'InsertDiagramNode: unexpanded'->putLine;
                'startpos before: '->putText;
                startpos.x->putInt;
                ' '->put;
                startpos.y->putInt;
            if);
            (anAst[],startpos)->DisplayAST->startpos;
            (if switch[23]
             // true then
                ' startpos after: '->putText;
                startpos.x->putInt;
                ' '->put;
                startpos.y->putInt;
                newline
            if);
        if)
     #);
   aText: @Text;
do
   (if switch[23]
    // true then
       'Gpp ------- InsertDiagramNode: '->putText;
       pos->putInt;
       ' '->put;
       anAst.Index->putInt;
       newLine;
       anAST.dump;
       newLine;
   if);
   1->i;
   true->remakingDiagram;
   (if pos = 0 then titleNode[]->previousNode[]; displayNode if);
   localnodes.scan
     (# aText: @Text;
     do
        (if switch[23] then
            'InsertDiagramNode: examening no '->puttext;
            i->putint;
            ' element in localnodes - '->puttext;
            current.thetext.get->aText;
            aText[]->putline
        if);
        (if i
         // pos then current[]->previousNode[]; displayNode
         else
            (if (* what about this? (current[]<>aNode[]) and *) (i > pos)
             // true then
                (if switch[23]
                 // true then
                    'InsertDiagramNode: move down '->puttext;
                    current.theText.get->aText;
                    aText[]->putline;
                if);
                (* move the rest *)
                current.center->(x,y);
                (x,y+gppProp.height)->current.center;
            if)
        if);
        i+1->i;
     #);
   (if PatternDiagrams.newNode[]
    // none then 'OOBS: newNode is NONE'->screen.putline;
    else
       (if pos <> 0 then
           (PatternDiagrams.newNode[],
            PatternDiagrams.addAfterNode[]->localNodes.at)
             ->localNodes.insertAfter
        else
           (if switch[23] then
               'InsertDiagramNode - prepending in localNodes: '->puttext;
               PatternDiagrams.newNode.theText.get->aText;
               aText[]->putline
           if);
           PatternDiagrams.newNode[]
             ->
               localNodes.prepend
               (*The new node is the topmost localNode when pos=0*)
       if);
   if);
   none ->PatternDiagrams.addAfterNode[];
   false->remakingDiagram;
#)  

-- DeleteDiagramNode: DescriptorForm --
(#
   x,y,w,h: @Integer;
   tx,ty: @Integer;
   deleted: @boolean;
   abs: ^AbstractNode;
   p: [8] @Integer;
   leftAtTitle: @boolean;
   t: @Text;
do
   (if switch[23]
    // true then 'Gpp ------- DeleteDiagramNode'->putLine;
   if);
   scanner: localnodes.scan
     (# aText: ^Text;
     do
        (if switch[23] then
            'DeleteDiagramNode - current in scanner: '->puttext
        if);
        current.theText.get->t;
        t[]->putline;
        (if current[]
         // d[] then
            d.geometry->(x,y,w,h);
            (if deleteNode
             // true then
                d.delete;
                (* ESS: was outside the if:
                 *)
                true->deleted;
            if);
            (if switch[23]
             // true then
                (if deleteNode
                 // true then
                    'DeleteDiagramNode: element found and deleted'
                      ->screen.putline;
                 else
                    'DeleteDiagramNode: element found but not deleted'
                      ->screen.putline;
                if)
            if);
            titlenode.center->(tx,ty);
            current[]->abs[];
            (if x < tx
             // true then
                (abs.theTreeConn[] <> none )->leftAtTitle; leave scanner
            if);
         else
            (if deleted
             // true then (* move the rest *)
                current.center->(x,y);
                current[]->abs[];
                (if abs.theTreeConn[]
                 // none then (x,y-gppProp.height)->abs.center;
                 else
                    (x-w,y)->abs.center;
                    x-w->p[5];
                    (* set two points on the connector *)
                    y-(gppProp.DownOnPage)->p[6];
                    (* a bit up *)
                    y-(gppProp.DownOnPage)->p[4];
                    (* a bit up *)
                    titleNode.center->(x,y);
                    x->p[3];
                    p->abs.theTreeConn.Points;
                if);
                (if switch[23]
                 // true then
                    'DeleteDiagramNode - element moved: '->puttext;
                    current.theText.get->t;
                    t[]->putline;
                if);
            if)
        if)
     #);
   (if switch[23] then 'DeleteDiagramNode end of scanner'->putline if);
   (if leftAtTitle
    // true then
       scanner: localNodes.scan
         (#
         do
            (if current[]
             // d[] then leave scanner;
             else
                current.center->(x,y);
                current[]->abs[];
                (x+w,y)->abs.center;
                x+w->p[5];
                (* set two points on the connector *)
                y-(gppProp.DownOnPage)->p[6];
                (* a bit up *)
                y-(gppProp.DownOnPage)->p[4];
                (* a bit up *)
                titleNode.center->(x,y);
                x->p[3];
                p->abs.theTreeConn.Points;
            if);
            (if switch[23]
             // true then
                'DeleteDiagramNode - element moved (leftAtTitle=true): '
                  ->puttext;
                current.theText.get->t;
                t[]->putline;
            if);
         #)
   if);
   d[]->localnodes.at->localnodes.delete;
#)  

-- ReplaceDiagramNode: DescriptorForm --
(#
   x,y,w,h: @Integer;
   startPos: @point;
   insertAfterPos,insertBeforePos,thePos: ^localnodes.theCellType;
   IsDynamic:
     (#
        yes: @Boolean;
        anAST: ^AST;
        decl: ^betaGram.SimpleDecl;
        theSpec: ^betaGram.ReferenceSpecification;
     enter anAST[]
     do
        (if anAST## <= betagram.SimpleDecl## then
            anAST[]->decl[];
            decl.GetReferenceSpecification->anAST[];
            (if anAST## <= betagram.ReferenceSpecification## then
                anAST[]->theSpec[];
                (if theSpec.symbol
                 // betaGram.dynamicItem // betaGram.dynamicComponent then
                    true->yes;
                if)
             else
                'Freja-- OOBS: anAST## <= betagram.ReferenceSpecification## failed'
                  ->screen.putline;
            if)
         else
            'Freja-- OOBS: anAST## <= betagram.SimpleDecl## failed'
              ->screen.putline;
        if);
     exit yes
     #);
   aText: @Text;
do
   (if switch[23]
    // true then
       'Gpp ------- ReplaceDiagramNode: '->putText;
       newAST.Index->putInt;
       newLine;
       newAST.dump;
       newLine;
   if);
   true->remakingDiagram;
   scanner: localnodes.scan
     (#
     do
        (if switch[23] then
            'ReplaceDiagramNode - examining: '->puttext;
            current.theText.get->aText;
            aText[]->putline
        if);
        (if current[]
         // d[] then
            '1: '->putline;
            (if switch[23] then
                'ReplaceDiagramNode - addAfterNode: '->puttext;
                current.theText.get->aText;
                aText[]->putline
            if);
            current[]->PatternDiagrams.addAfterNode[];
            PatternDiagrams.addAfterNode[]->localNodes.at->thePos[];
            '2: '->putline;
            (if thePos.pred[] <> none then
                thePos.pred[]->insertAfterPos[]
             else
                (if thePos.succ[] <> none then
                    thePos.succ[]->insertBeforePos[]
                if)
            if);
            '3: '->putline;
            d.geometry->(x,y,w,h);
            d.delete;
            (* No, the node is already deleted /ESS 
             * d[]->localnodes.at->localnodes.delete;
             (Because deleteDiagramNode is called from callback onRemove,
             which is called on d.delete /TOBY)*)
            (x-(w div 2),y-(h div 2))->startPos;
            (* insert new *)
            (if newAst.kind
             // kinds.interior then
                (if newAST.symbol
                 // betaGram.SimpleDecl then
                    (if newAST[]->IsDynamic
                     // true then
                        (if gppProp.CompositionWith
                         // gppProp.CompositionAll
                         // gppProp.CompositionReference then
                            (if switch[23]
                             // true then
                                'dynamic CompositionWith, CompositionAll or CompositionReference'
                                  ->putLine;
                            if);
                            (newAST[],startpos)->DisplayAST->startpos;
                        if);
                     else
                        (if gppProp.CompositionWith
                         // gppProp.CompositionAll
                         // gppProp.CompositionPartWhole then
                            (if switch[23]
                             // true then
                                'static  CompositionWith, CompositionAll or CompositionReference'
                                  ->putLine;
                                'startpos before: '->putText;
                                startpos.x->putInt;
                                ' '->put;
                                startpos.y->putInt;
                                newline
                            if);
                            (newAST[],startpos)->DisplayAST->startpos;
                            (if switch[23]
                             // true then
                                'startpos after: '->putText;
                                startpos.x->putInt;
                                ' '->put;
                                startpos.y->putInt;
                                newline
                            if);
                        if)
                    if);
                 // betaGram.PatternDecl // betaGram.VirtualDecl
                 // betaGram.BindingDecl
                 //
                 betaGram.RepetitionDecl (*// betaGram.VariablePatternDecl*)
                 then
                    (if gppProp.CompositionWith
                     // gppProp.CompositionAll // gppProp.CompositionBlock then
                        (if switch[23]
                         // true then
                            'InsertDiagramNode: PatternDecl, VirtualDecl, BindingDecl, RepetitionDecl'
                              ->putLine;
                            'startpos before: '->putText;
                            startpos.x->putInt;
                            ' '->put;
                            startpos.y->putInt;
                            newline
                        if);
                        (newAST[],startpos)->DisplayAST->startpos;
                        (if switch[23]
                         // true then
                            'startpos after: '->putText;
                            startpos.x->putInt;
                            ' '->put;
                            startpos.y->putInt;
                            newline
                        if);
                    if)
                if)
             // kinds.unexpanded then
                (if switch[23]
                 // true then 'InsertDiagramNode: unexpanded'->putLine;
                if);
                (newAST[],startpos)->DisplayAST->startpos;
            if);
            leave scanner;
        if)
     #);
   (if PatternDiagrams.newNode[]
    // none then 'OOBS: newNode is NONE'->screen.putline;
    else
       (if insertAfterPos[] <> none then
           (PatternDiagrams.newNode[],insertAfterPos[])->localNodes.insertAfter
        else
           (if insertBeforePos[] <> none then
               (PatternDiagrams.newNode[],insertBeforePos[])
                 ->localNodes.insertBefore
            else
               PatternDiagrams.newNode[]->localNodes.append
           if)
       if);
   if);
   none ->PatternDiagrams.addAfterNode[];
   false->remakingDiagram;
#)  

-- UpdateDiagramNode: DescriptorForm --
(#
   theNode: ^DiagramNode;
   testNode: ^IdObject;
   aDeclaration: ^betaGram.AttributeDecl;
   anAST,keepOldAST,keepNewAST: ^ast;
   anExp: ^expanded;
   theNames: ^betaGram.Names;
   updateName:
     (#
        theNewNameDcl,theOldNameDcl: ^betaGram.NameDcl;
        oldText,newText: ^text;
        doUpdate: @Boolean;
        aPatternDiagram: ^PatternDiagram
     do
        (if theNode.currentDecomposDiagram <> none
        (*Update name in titlenode of detailed*) then
            anAST[]->theNewNameDcl[];
            theNewNameDcl.getText->newText[];
            newText[]->putline;
            (if oldAST.symbol = betaGram.NameDcl then
                oldAST[]->theOldNameDcl[];
                theOldNameDcl.getText->oldText[];
                oldText[]->putline;
                (if oldText[]->newText.equal then
                    (if switch[23] then
                        'UpdateDiagramNode: old name is equal to new name!'
                          ->putline
                    if)
                 else
                    true->doUpdate
                if)
             else
                true->doUpdate
            if);
            (if doUpdate then
                theNode.currentDecomposDiagram->aPatternDiagram[];
                newText->aPatternDiagram.titleText
                  ->aPatternDiagram.titleNode.theText.set;
                (theNode.currentDecomposDiagram).titleText[]->putline
             else
                (if switch[23] then
                    'UpdateDiagramNode: doUpdate is false'->putline
                if)
            if)
         else
            (if switch[23] then
                'UpdateDiagramNode: currentDecomposDiagram is none'->putline
            if)
        if)
     #);
do
   (if switch[23]
    // true then
       'Gpp ------- UpdateDiagramNode: '->putText;
       oldAST.Index->putInt;
       newLine;
       (* oldAST.dump;
        newline; *)
   if);
   oldAST[]->keepOldAST[];
   newAST[]->keepNewAST[];
   search:
   (if oldAST[]
    // none then
       'Gpp ------- UpdateDiagramNode: node not found: '->putText;
       oldAST.Index->putInt;
       newLine;
    else
   (*oldAST.index->IndexIDList.IndextoObject -> theNode[];*)
       (oldAST.index,newAST.index)->IndexIDList.update->testNode[];
       (*theNode[];*)
       (if testNode[]
        // none then
        else
           (if true
            // testNode.struc <= PatternDiagramNode## then
               testNode[]->theNode[]
            else
               'It is not a PatternDiagramNode!!'->putLine;
           if);
       if);
       testRedisplay:
       (if theNode[]
        // none then
           (if switch[23] then
               'Calling redisplay - internal part of declaration was expanded'
                 ->putline
           if);
           getDecl:
           (if (keepNewAST## <= betaGram.attributeDecl##) or
           (keepNewAST[]->keepNewAST.frag.root.equal) then
            else
               keepNewAST.father->keepNewAST[]; restart getDecl
           if);
           (if keepNewAST## <= betaGram.attributeDecl## then
               keepNewAST[]->anExp[];
               anExp.getSon1->theNames[];
               theNames.newScan
                 (# do current[]->anAST[] #);
               keepNewAST.index->IndexIDList.indexToObject->theNode[];
               (if theNode[] <> none then
                   updateName; (keepNewAST[],anAST[])->theNode.Redisplay
                else
                   (if switch[23] then
                       'Surrounding declaration not present in IndexIDList??'
                         ->putline
                   if)
               if)
            else
               (if switch[23] then
                   'No part of a declatation was changed - no redisplay is done'
                     ->putline
               if)
           if);
           ;
           (*toby: Internal part of decl. expanded. Did not change index on ancestors!(?)
            
            oldAST.father->oldAST[];
            newAST.father->newAST[];
            restart search; *)
        else
           (if keepNewAST.symbol
            // betaGram.nameDcl then
               (if switch[23]
                // true then '  it is a nameDcl'->putLine;
               if);
               keepNewAST.father->anAST[];
               anAST.father->aDeclaration[];
               keepNewAST[]->anAST[];
               updateName;
            else
               (if (keepNewAST.struc <= betaGram.attributeDecl##)
                // true then
                   (if switch[23]
                    // true then
                       '  it is a declaration: '->putText;
                       keepNewAST.symbol->putInt;
                       newLine;
                   if);
                   keepNewAST[]->aDeclaration[];
                   (* get the nameDcl *)
                   aDeclaration.getson1->anExp[];
                   anExp.getson1->anAST[];
                else
                   (if switch[23]
                    // true then
                       'not namedcl or attributeDecl: '->putText;
                       newAST.symbol->putInt;
                       newLine;
                   if);
                   leave testRedisplay;
               if);
           if);
           (if switch[23]
            // true then
               keepNewAST.dump;
               newline;
               (if aDeclaration[]
                // none then
                else
                   aDeclaration.dump; newline;
               if);
           if);
           updateName;
           (aDeclaration[],anAST[])->theNode.redisplay;
       if);
   if)
#)  

-- ListDiagramOnInit: DescriptorForm --
(#
do
   UDPrivate.UDListDiagram->UserDataInit;
   UDdetailPage.Init;
   UDNoOfRefConnectors.Init;
   (if not initialisingSaved then
       THIS(ListDiagram)[]->theDiagram; geometry->(x,y,w,h)
   if);
#)  

-- ListDiagramOnRemove: DescriptorForm --
(# theParent: ^PatternDiagramNode
do (* tell the parent node that it is no longer detailed *)
   (if theParentNode <> none
    // true then
       theParentNode->theParent[]; theParent.abstractedFromDiagramBelow;
   if);
#)  

-- ListDiagramOnDoubleClick: DescriptorForm --
(#
do
   localNodes.abstractAll;
   False->proceed;
   (*don't let design/OA proceed in normal way*)
#)  

-- ListDiagramAbstract: DescriptorForm --
(# connectorList: ^ObjectList; ok,areUserConns: @Boolean; prompt: @Text
do
   (if switch[1] // true then 'title abstract all my nodes'->putline if);
   GetConnectors->connectorList[];
   (if connectorList[] <> none then
       connectorList.scan
         (#
         do
            (if current## <= CommonConnector## then
             else
                true->areUserConns;
                'Warning: There are user defined relations connected to the diagram.'
                  ->prompt.puttext;
                ' These will not show up again before the program has been checked!'
                  ->prompt.puttext;
                prompt->DSUIGetUserYesOrNo->ok
            if)
         #)
    else
       true->ok
   if);
   (if ok or (not areUserConns) then localNodes.abstractAll; Delete if);
#)  

-- ListDiagramDetail: DescriptorForm --
(# lastNode: ^AbstractNode;
do
   (if switch[1]
    // true then 'title detail all attribute decls...'->putline;
   if);
   false->doScrollIntoView;
   localNodes.scan
     (# do current.detail; current[]->lastNode[] #);
   true->doScrollIntoView;
   (if lastNode.currentDecomposDiagram <> none then
       (lastNode.currentDecomPosdiagram).titleNode[]
         ->THIS(OADPage).scrollIntoView;
    else
       'lastNode.currentDecomposDiagram is NONE'->screen.putline;
   if);
#)  

-- listDiagramUpdateAstFromDisk: DescriptorForm --
(# fn: ^FragmentNode;
do
   (if switch[1] // true then 'listDiagramUpdateAstFromDisk'->putLine; if);
   (if (theObject.theDiagram).theFragmentNode <> none
    // true then (theObject.theDiagram).theFragmentNode->fn[];
    else
       (if theObject.struc <= FragmentNode##
        // true then
           'Freja[[listDiagramUpdateAst:: we got a FragmentNode to update]'
             ->screen.putline;
           theObject[]->fn[];
        else
           (theObject[],screen[])->PrintObject;
       if);
   if);
   (if fn[] <> none
    // true then (oldff[],theObject[])->fn.ReReadAST->newFF[];
    else
       'Freja[[ERROR: listDiagramUpdateAstFromDisk no fragmentnode!!]]'
         ->screen.putline;
   if);
   (if switch[1]
    // true then 'end listDiagramUpdateAstFromDisk'->putLine;
   if);
#)
(* OADDIAGRAMS *)  

-- OADDiagramNew: DescriptorForm --
(# theDummyDesc: ^betaGram.ObjectDescriptor
do
(* save THIS(OADDiagram) with the ASTindex of the  
 * descriptor it is generated from so it can be located later
 *)
   (if theDescriptor <> none
    // true then
       theDescriptor->theDummyDesc[];
       (theDummyDesc.index,THIS(OADDiagram)[])
         ->PatternDiagrams.theList.insertPD;
   if);
#)  

-- OADDisplayDeclarations: DescriptorForm --
(#
   x,y,w,h: @Integer;
   HasAttributesDefined:
     (#
        yes: @Boolean;
        decl: ^betaGram.SimpleDecl;
        theSpec: ^betaGram.ReferenceSpecification;
        theObjectSpec: ^AST;
        os: ^betaGram.ObjectSpecification;
     enter decl[]
     do
        decl.GetReferenceSpecification->theSpec[];
        theSpec.getson1->theObjectSpec[];
        (if theObjectSpec.kind
         // kinds.interior then
            (if theObjectSpec.symbol
             // betaGram.ObjectDescriptor then
             (* it was an ObjectSpecification *)
                theObjectSpec[]->os[];
                (if theObjectSpec.frag.father->ischecked
                 // true then (os.findDescriptor->CountAttributes) > 0->yes
                if)
            if)
        if)
     exit yes
     #);
   IsDynamic:
     (#
        yes: @Boolean;
        anAST: ^AST;
        decl: ^betaGram.SimpleDecl;
        theSpec: ^betaGram.ReferenceSpecification;
     enter anAST[]
     do
        (if anAST## <= betagram.SimpleDecl## then
            anAST[]->decl[];
            decl.GetReferenceSpecification->anAST[];
            (if anAST## <= betagram.ReferenceSpecification## then
                anAST[]->theSpec[];
                (if theSpec.symbol
                 // betaGram.dynamicItem // betaGram.dynamicComponent then
                    true->yes;
                if)
             else
                'Freja-- OOBS: anAST## <= betagram.ReferenceSpecification## failed'
                  ->screen.putline;
            if)
         else
            'Freja-- OOBS: anAST## <= betagram.SimpleDecl## failed'
              ->screen.putline;
        if);
     exit yes
     #);
do
   (if theAttributes[]
    // none then (* it is a non-terminal: display it as such *)
       'DisplayDeclarations: ATTRIBUTES IS NONE'->putline;
    else
       (if gppProp.CompositionDType > gppProp.CompositionNested
        // true then
        (* first display simple declarations like references (static and dynamic)
         * then display pattern and virtual declarations;
         *)
           titleNode.geometry->(x,y,w,h);
           x->startpos.x;
           (* same center *)
           startpos.y+(2*gppProp.DownOnPage)->startpos.y;
       if);
       theAttributes.scan
         (#
         do
            (if current.kind
             // kinds.interior then
                (if current.symbol
                 // betaGram.SimpleDecl then
                    (if current[]->IsDynamic
                     // true then
                        (if gppProp.CompositionWith
                         // gppProp.CompositionAll
                         // gppProp.CompositionReference then
                            (current[],startpos)->DisplayAST->startpos;
                        if);
                     else
                        (if gppProp.CompositionWith
                         // gppProp.CompositionAll
                         // gppProp.CompositionPartWhole then
                            (current[],startpos)->DisplayAST->startpos;
                        if)
                    if);
                 // betaGram.PatternDecl // betaGram.VirtualDecl
                 // betaGram.BindingDecl
                 //
                 betaGram.RepetitionDecl (*// betaGram.VariablePatternDecl *)
                 then
                    (if gppProp.CompositionWith
                     // gppProp.CompositionAll // gppProp.CompositionBlock then
                        (current[],startpos)->DisplayAST->startpos;
                    if)
                if)
             // kinds.unExpanded then
                (current[],startpos)->DisplayAST->startpos;
             else
            if)
         #)
   if)
#)  

-- OADDiagramOnRemove: DescriptorForm --
(# theDummyDesc: ^betaGram.ObjectDescriptor
do (* remove the diagram from the list of patterndiagrams on the page *)
   (if theDescriptor <> none
    // true then
       theDescriptor->theDummyDesc[];
       theDummyDesc.index->PatternDiagrams.theList.deletePD;
       (*if this is the last diagram on the page close the page *)
       (if PatternDiagrams.theList.size // 0 then close if);
   if);
#)  

-- OADDisplay: DescriptorForm --
(#
   p: ^localNodes.theCellType;
   e: ^LocalNodes.element;
   det: ^AbstractNode;
   x,y,w,h: @Integer;
   theDummyDesc: ^betaGram.ObjectDescriptor
do
   (if theDescriptor
    // none then
       (if switch[1] // true then 'theDescriptor is NONE '->puttext if);
   if);
   CalculateNextCenter->theCenter;
   (if theDescriptor <> none
    // true then
       theDescriptor->theDummyDesc[]; theDummyDesc.index->titleNode.astIndex;
   if);
   INNER Display;
   (if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
       (if PatternDiagrams.Detailer[] <> none
        // true then
           PatternDiagrams.Detailer[]->det[];
           (if det.theTreeConn[]
            // none then
            (* the Detailer is part of a blockDiagram and not a tree *)
               (theCenter.x,theCenter.y,gppProp.titlewidth,gppProp.height*2,
                titleNode.defaultShape)->titleNode.new;
            else
           (* the new diagram is connected to an existing tree diagram *)
               PatternDiagrams.Detailer.geometry->(x,y,w,h);
               (x,y,w,h,titleNode.defaultShape)->titleNode.new;
               PatternDiagrams.Detailer[]->titleNode.CreateRegion;
               true->PatternDiagrams.Detailer.moveable;
               false->titleNode.selectable;
               false->titleNode.borderVisible;
               titleNode.theText.clear;
               PatternDiagrams.Detailer[]->CurrentObject;
           if);
        else
           (theCenter.x,theCenter.y,gppProp.titlewidth,gppProp.height*2,
            titleNode.defaultShape)->titleNode.new;
       if);
    else
       (theCenter.x,theCenter.y,gppProp.titlewidth*2,gppProp.height,
        titleNode.defaultShape)->titleNode.new;
   if);
   (* now we can make the diagram: titleNode.new, calls onInit as callback
    * which then calls DisplayDeclarations to display the contaning decls.
    *)
   (* Now we make final adjustment (we must know the number of subnodes
    * before we can do this).
    *	
    * If we make trees then we must adjust the localNodes so they
    * are centered
    *)
   (if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
       (if localNodes.empty
        // true then (theCenter,titleNode.Center)->UpdateNextFree;
        else
             (#
                pos1,pos2: @Point;
                x,y,w,h,dist: @Integer;
                no: @Integer;
                lastSimple, (* last node in simple pattern diagram *) firstTree,
                (* first node in tree pattern diagram *) lastTree:
                (* last node in tree pattern diagram *) ^PatternDiagramNode;
             do
                (if localNodes.empty
                 // false then (* update for the next diagram *)
                    localNodes.last->p[]; p.elm[]->e[]; e.Center->pos1;
                 else
                    titleNode.Center->pos1;
                if);
                pos1.x+gppProp.DownOnPage->pos1.x;
                (theCenter,pos1)->UpdateNextFree;
                titleNode[]->lastSimple[];
                localNodes.scan (* count the nodes in tree position *)
                  (# d: ^DiagramNode;
                  do
                     (if current.struc <= DiagramNode##
                      // true then
                         current[]->d[];
                         (if d.theTreeConn[]
                          // none then
                             current[]->lastSimple[]; (* in simple diagram *)
                          else
                             (if firstTree[]
                              // none then current[]->firstTree[]
                             if);
                             current[]->lastTree[];
                             (* in tree diagram *)
                             no+1->no;
                         if)
                     if)
                  #);
                (if true (* calculate adjustment *)
                 // (no > 1) then (* adjust them *)
                    firstTree.Center->pos1;
                    lastTree.Center->pos2;
                    (pos2.x-pos1.x) div 2->dist;
                    lastSimple.Center->pos2;
                    dist-(pos2.x-pos1.x)->dist;
                    (* adjust for fittotext *)
                 // (no = 1) then (* center the one *)
                    lastSimple.center->pos1;
                    localNodes.last->p[];
                    p.elm[]->e[];
                    e.Center->pos2;
                    pos2.x-pos1.x->dist;
                 else
                (* no subnodes in tree *)
                if);
                localNodes.scan (* adjust the subnodes *)
                  (# d: ^DiagramNode;
                  do
                     (if current.struc <= DiagramNode##
                      // true then
                         current[]->d[];
                         (if d.theTreeConn[]
                          // none then (* in simple pattern diagram *)
                             (0,0)->current.ConcludeDisplay;
                          else
                         (* in tree *)
                             (dist,0)->current.ConcludeDisplay;
                         if)
                     if)
                  #)
             #)
       if);
    else
   (* just make a simple patterndiagram of all the nodes
    * update NextFreeLine to the y coordinate of the last node in
    * plus offset *)
       (if localNodes.empty
        // true then (theCenter,titleNode.Center)->UpdateNextFree;
        else
           localNodes.scan
             (# do (0,0)->current.ConcludeDisplay #);
           localNodes.Last->p[];
           p.elm[]->e[];
           (theCenter,e.Center)->UpdateNextFree
       if)
   if)
#)
(* FRAGMENTDIAGRAMS *)  

-- FragmentDiagramNew: DescriptorForm --
(#
   w,h: @Integer;
   groupTitle: ^PatternDiagramNode;
   e: ^LocalNodes.element;
   p: ^Localnodes.theCellType;
   theDummyGroup: ^FragmentGroup
do
   theGroup->theDummyGroup[];
   theDummyGroup.name->ExpandToFullPath->fullname;
   INNER New;
   PatternDiagrams.theList.scanPropertyDiagrams
     (# (* go find the property diagram of theGroup *)
     do
        (if thisDiagram.theGroup
         // theGroup then
            (if thisDiagram.localNodes.empty
             // false then
                thisDiagram.localnodes.last->p[];
                p.elm[]->e[];
                e.geometry->(x,y,w,h);
             else
                thisDiagram.titleNode.geometry->(x,y,w,h);
            if);
            thisDiagram.titleNode[]->groupTitle[];
        if);
     #);
   y+gppProp.DownOnPage->y;
   (* CalculateNextCenter -> (x,y); *)
   x-(w div 2)+(gppProp.titlewidth div 2)->x;
   (x,y,gppProp.titlewidth,gppProp.height,titleNode.defaultShape)
     ->titleNode.new;
   groupTitle[]->titleNode.CreateRegion;
   (0,THIS(FragmentDiagram)[])->PatternDiagrams.theList.insertPD;
#)  

-- FragmentDiagramTitleInit: DescriptorForm --
(# theDummyGroup: ^FragmentGroup
do (* show fragments starting at low-left of the titleNode *)
   UDPrivate.UDFragmentDiagram->UserDataInit;
   UDfullname.Init;
   UDtheGroup.Init;
   gppProp.fontSize->theText.size;
   LeftJustification->theText.Just;
   false->BorderVisible;
   (if not initialisingSaved then
       (x-(w+1) div 2,y-((h+1) div 2))->(x,y);
       theGroup->theDummyGroup[];
       theDummyGroup.fragmentList.scan
         (#
            f: ^FragmentForm;
            theForm: ^betaGram.BetaForm;
            theNode: ^FragmentNode;
         do
            (if current.type
             // linkType then (* ignore *)
             // groupType then
                'Groups in groups not suported'->putline;
             // formType then
                current.f[]->f[];
                f.root[]->theForm[];
                (if theForm.symbol
                 // betaGram.DescriptorForm then
                    &DescriptorNode[]->theNode[];
                 // betaGram.AttributesForm then
                    &AttributesNode[]->theNode[];
                 else
                    'Other type'->putline;
                if);
                gppProp.height+y->y;
                ((x,y),current.f[])->theNode.display;
                (0,0)->theNode.ConcludeDisplay;
                THIS(FragmentDiagram)[]->theNode.theDiagram;
            if);
         #);
       'Fragments'->titleText;
       titletext->theText.set;
       ((x,y),(x,y))->UpdateNextFree;
       scanner: PatternDiagrams.theList.scanPropertyDiagrams
         (#
            x1,y1,w1,h1: @Integer;
            (* go find the property diagram of theGroup *)
         do
            (if thisDiagram.theGroup
             // theGroup then
             (* update the surroundBox of the property diagram *)
                thisDiagram.surroundBox.geometry->(x1,y1,w1,h1);
                (x+gppProp.width,y1+(h1 div 2)+((y-y1+(h1 div 2)) div 2)+1,
                 gppProp.width*2+20, (* width *) y-y1+gppProp.height)
                (* height *) ->thisDiagram.surroundBox.geometry;
                leave scanner;
            if);
         #)
   if);
#)  

