ORIGIN 'diagramattributes';
(* switch
 * 1  = general debugging
 * 21 = IndexIDList
 * 22 = RemakePP
 * 23 = DiagramList
 *)
(* DIAGRAM *)
INCLUDE '~beta/sysutils/v1.4/objinterface';
-- TitleInteractiveNew: Descriptor --
(#  do (w,h)->Size #)  

-- TitleOnInit: Descriptor --
(# 
do
   UDPrivate.UDDiagram
     ->UserDataInit
     (*toby 1-11-94:
      User data initializations*) ;
   UDtheParentNode.Init;
   UDtheFragmentNode.Init;
   thePrefixConn.Init;
   gppProp.fontSize->theText.size;
   bold->titleNode.theText.style;
   (* titleText -> theText.set; resposibility of sub patterns *)
   INNER OnInit;
   
#)  

-- TitleOnSelect: Descriptor --
(# 
do
   (PatternDiagrams.oldSelection[],THIS(title)[])->changedFocus;
   THIS(title)[]->PatternDiagrams.oldSelection[];
   
#)
(* LISTDIAGRAM *)  

-- TitleTextModeOn: Descriptor --
(# 
do
   (if switch[1] then 'Text mode on in TitleNode'->putLine;  if);
   theText.get->theTextBefore;
   true->onGoingTextEditing;
   true->onGoingTitleEditing;
   
#)  

-- TitleTextModeOff: Descriptor --
(# t: @text; theNode: ^patternDiagramNode; anExp: ^expanded; 
do
   (if switch[1] then 'Text mode off in titleNode '->putLine;  if);
   theText.get->t;
   (if switch[1] then t[]->putLine;  if);
   (if not (theTextBefore[]->t.equal) then
       (thisDiagram).theParentNode->theNode[];
       (if theNode[]
        // none then 'theDeclaration is none!! '->putLine
        else
           theNode[]->currentObject;
           ((thisDiagram).theParentNode).getAstNode->anExp[];
           (theNode[],(anExp.getSon1).index,t[])->declarationTextChanged;
           
       if)
    else
       false->ongoingTextediting; false->onGoingTitleEditing
   if);
   
#)  

-- TitleSifEditorInstance: Descriptor --
(# fn: ^PatternDiagramNode; 
do
   (if theFragmentNode <> none
    // true then
       (if no
        // 0 then theFragmentNode->fn[]; fn.SifEditorInstanceNo->no; 
        else
           theFragmentNode->fn[]; no->fn.SifEditorInstanceNo; 
       if);
       
    else
       'titleNode: SifEditorInstanceNo: no FragmentNode'->screen.putline
   if)
#)  

-- LocalNodesAbstractAll: Descriptor --
(# dummy: ^DiagramNode; theDiagram: ^Diagram; 
do
   (if current.struc <= DiagramNode##
    // true then
       current[]->dummy[];
       (if dummy.currentDecomposDiagram <> none
        // true then
           dummy.currentDecomposDiagram->theDiagram[];
           theDiagram.titleNode.abstract
       if)
   if);
   
#)  

-- LocalNodesAdjustSizes: Descriptor --
(# tx,ty,tw,th,tleft,x,y,w,h: @integer
do
   TitleNode.geometry->(tx,ty,tw,th);
   tx-(tw div 2)->tleft;
   LocalNodes.scan
     (# 
     do
        current.geometry->(x,y,w,h);
        (tleft+(MaxWidth div 2),y,MaxWidth,GppProp.Height)->current.geometry
     #)
#)  

-- InsertDiagramNode: Descriptor --
(#
   previousNode: ^PatternDiagramNode;
   i: @Integer;
   x,y,w,h: @Integer;
   startPos: @point;
   IsDynamic:
     (#
        yes: @Boolean;
        anAST: ^AST;
        decl: ^betaGram.SimpleDecl;
        theSpec: ^betaGram.ReferenceSpecification;
        
     enter anAST[]
     do
        (if anAST## <= betagram.SimpleDecl## then
            anAST[]->decl[];
            decl.GetReferenceSpecification->anAST[];
            (if anAST## <= betagram.ReferenceSpecification## then
                anAST[]->theSpec[];
                (if theSpec.symbol
                 // betaGram.dynamicItem // betaGram.dynamicComponent then
                    true->yes; 
                if)
             else
                (if switch[23] then
                    'Freja-- OOBS: anAST## <= betagram.ReferenceSpecification## failed'
                      ->screen.putline
                if);
                
            if)
         else
            'Freja-- OOBS: anAST## <= betagram.SimpleDecl## failed'
              ->screen.putline;
            
        if);
        
     exit yes
     #);
   displayNode:
     (# 
     do
        previousNode.geometry->(x,y,w,h);
        x-(w div 2)->x;
        x+gppProp.width->x;
        gppProp.width*2->w;
        previousNode[]->PatternDiagrams.addAfterNode[];
        (x-(w div 2),y-(h div 2)+gppProp.height)->startPos;
        (if anAst.kind
         // kinds.interior then
            (if anAst.symbol
             // betaGram.SimpleDecl then
                (if anAst[]->IsDynamic
                 // true then
                    (if gppProp.CompositionWith
                     // gppProp.CompositionAll // gppProp.CompositionReference
                     then
                        (if switch[23]
                         // true then
                            'dynamic CompositionWith, CompositionAll or CompositionReference'
                              ->putLine;
                            
                        if);
                        (anAst[],startpos)->DisplayAST->startpos;
                        
                    if);
                    
                 else
                    (if gppProp.CompositionWith
                     // gppProp.CompositionAll // gppProp.CompositionPartWhole
                     then
                        (if switch[23]
                         // true then
                            'static  CompositionWith, CompositionAll or CompositionReference'
                              ->putLine;
                            'startpos before: '->putText;
                            startpos.x->putInt;
                            ' '->put;
                            startpos.y->putInt;
                            newline
                        if);
                        (anAst[],startpos)->DisplayAST->startpos;
                        (if switch[23]
                         // true then
                            'startpos after: '->putText;
                            startpos.x->putInt;
                            ' '->put;
                            startpos.y->putInt;
                            newline
                        if);
                        
                    if)
                if);
                
             // betaGram.PatternDecl // betaGram.VirtualDecl
             // betaGram.BindingDecl // betaGram.FinalDecl
             // betaGram.RepetitionDecl (*// betaGram.VariablePatternDecl*)
             then
                (if gppProp.CompositionWith
                 // gppProp.CompositionAll // gppProp.CompositionBlock then
                    (if switch[23]
                     // true then
                        'InsertDiagramNode: PatternDecl, VirtualDecl, BindingDecl, FinalDecl, RepetitionDecl'
                          ->putLine;
                        'startpos before: '->putText;
                        startpos.x->putInt;
                        ' '->put;
                        startpos.y->putInt;
                        newline
                    if);
                    (anAst[],startpos)->DisplayAST->startpos;
                    (if switch[23]
                     // true then
                        'startpos after: '->putText;
                        startpos.x->putInt;
                        ' '->put;
                        startpos.y->putInt;
                        newline
                    if);
                    
                if)
            if)
         // kinds.unexpanded then
            (if switch[23]
             // true then
                'InsertDiagramNode: unexpanded'->putLine;
                'startpos before: '->putText;
                startpos.x->putInt;
                ' '->put;
                startpos.y->putInt;
                
            if);
            (anAst[],startpos)->DisplayAST->startpos;
            (if switch[23]
             // true then
                ' startpos after: '->putText;
                startpos.x->putInt;
                ' '->put;
                startpos.y->putInt;
                newline
            if);
            
        if)
     #);
   aText: @Text;
   connectorList,inheritanceEnds: ^ObjectList;
   con: ^Connector;
   prefixCon: ^theListDiagram.prefixConnector;
   node1,node2: ^PatternDiagramNode;
   n1,n2: ^DesignObject;
   theTitleNode: ^theListDiagram.title;
   theListdiagram: ^ListDiagram;
   
do
   (if switch[23]
    // true then
       'Gpp ------- InsertDiagramNode: '->putText;
       pos->putInt;
       ' '->put;
       anAst.Index->putInt;
       newLine;
       anAST.dump;
       newLine;
       
   if);
   1->i;
   true->remakingDiagram;
   (if pos = 0 then
       titleNode[]->previousNode[];
       &ObjectList[]->inheritanceEnds[];
       previousNode.getconnectors->connectorList[];
       (if connectorList[] <> none then
           connectorList.scan
             (# 
             do
                (if (current## <= PrefixConnector##) and
                (current[] <> titleNode.thePrefixConn) then
                    current[]->con[];
                    true->con.getEnds->(node1[],node2[]);
                    (if node1[] <> previousNode[] then
                        (if switch[23] then
                            'Inserting in inheritanceEnds: '->puttext;
                            node1.id->putint;
                            newline
                        if);
                        node1[]->inheritanceEnds.insert
                     else
                        (if switch[23] then
                            'Inserting in inheritanceEnds: '->puttext;
                            node2.id->putint;
                            newline
                        if);
                        node2[]->inheritanceEnds.insert
                    if);
                    con.delete
                if)
             #)
       if);
       displayNode
   if);
   localnodes.scan
     (# aText: @Text; 
     do
        (if switch[23] then
            'InsertDiagramNode: examening no '->puttext;
            i->putint;
            ' element in localnodes - '->puttext;
            current.thetext.get->aText;
            aText[]->putline
        if);
        (if i
         // pos then
            current[]->previousNode[];
            &ObjectList[]->inheritanceEnds[];
            (if previousNode[] = (LocalNodes.last).elm[] then
                (if switch[23] then
                    'Inserting as last element in localnodes'->putline
                if);
                previousNode.getconnectors->connectorList[];
                (if connectorList[] <> none then
                    connectorList.scan
                      (# 
                      do
                         current[]->con[];
                         true->con.getEnds->(n1[],n2[]);
                         (if (n1## <= patternDiagramNode##) and
                         (n2## <= patternDiagramNode##) then
                             n1[]->node1[];
                             n2[]->node2[];
                             (if node1[] <> previousNode[] then
                                 node1.theDiagram->theListDiagram[];
                                 (if current## <=
                                 theListDiagram.PrefixConnector## then
                                     (if switch[23] then
                                         'Inserting in inheritanceEnds: '
                                           ->puttext;
                                         node1.id->putint;
                                         newline
                                     if);
                                     node1[]->inheritanceEnds.insert;
                                     con.delete
                                  else
                                     (if switch[23] then
                                         'It is not a prefixConnector'->putline
                                     if)
                                 if)
                              else
                                 node2.theDiagram->theListDiagram[];
                                 (if current## <=
                                 theListDiagram.PrefixConnector## then
                                     (if switch[23] then
                                         'Inserting in inheritanceEnds: '
                                           ->puttext;
                                         node2.id->putint;
                                         newline
                                     if);
                                     node2[]->inheritanceEnds.insert;
                                     con.delete
                                  else
                                     (if switch[23] then
                                         'It is not a prefixConnector'->putline
                                     if)
                                 if)
                             if)
                         if)
                      #)
                if)
            if);
            displayNode
         else
            (if (* what about this? (current[]<>aNode[]) and *) (i > pos)
             // true then
                (if switch[23]
                 // true then
                    'InsertDiagramNode: move down '->puttext;
                    current.theText.get->aText;
                    aText[]->putline;
                    
                if);
                current.center->(x,y);
                (x,y+gppProp.height)->current.center;
                
            if)
        if);
        i+1->i;
        
     #);
   (if PatternDiagrams.newNode[]
    // none then 'OOBS: newNode is NONE'->screen.putline; 
    else
       inheritanceEnds.scan
         (# 
         do
            current[]->node1[];
            node1.theDiagram->theListDiagram[];
            &theListDiagram.PrefixConnector[]->prefixCon[];
            (if switch[23] then
                'Creating PrefixConnector between: '->puttext;
                current.id->putint;
                ' and '->puttext;
                PatternDiagrams.newNode.id->putint;
                newline
            if);
            (current[],PatternDiagrams.newNode[])->prefixCon.prefixNew;
            current[]->theTitleNode[];
            prefixCon[]->theTitleNode.thePrefixConn
         #);
       (if pos <> 0 then
           (PatternDiagrams.newNode[],
            PatternDiagrams.addAfterNode[]->localNodes.at)
             ->localNodes.insertAfter
        else
           (if switch[23] then
               'InsertDiagramNode - prepending in localNodes: '->puttext;
               PatternDiagrams.newNode.theText.get->aText;
               aText[]->putline
           if);
           PatternDiagrams.newNode[]
             ->
               localNodes.prepend
               (*The new node is the topmost localNode when pos=0*)
       if);
       
   if);
   none ->PatternDiagrams.addAfterNode[];
   false->remakingDiagram;
   localNodes.adjustSizes;
   
#)  

-- DeleteDiagramNode: Descriptor --
(#
   x,y,w,h: @Integer;
   tx,ty: @Integer;
   deleted: @boolean;
   abs: ^AbstractNode;
   p: [8] @Integer;
   leftAtTitle: @boolean;
   t: @Text;
   inheritanceEnds,connectorList: ^ObjectList;
   con: ^connector;
   prefixCon: ^theListDiagram.prefixConnector;
   node1,node2: ^PatternDiagramNode;
   n1,n2: ^DesignObject;
   theTitleNode: ^theListDiagram.title;
   dListDiagram,theListDiagram: ^ListDiagram;
   dAbstractNode: ^dListDiagram.AbstractNode;
   
do
   (if switch[23]
    // true then 'Gpp ------- DeleteDiagramNode'->putLine; 
   if);
   (*If called because of some ast replacing event (e.g. astReplaced,
    listElementDeleted,...) - i.e. not because an abstract was invoked.*)
   (if deletenode then
       d.theDiagram->dListDiagram[];
       (if d## <= dListDiagram.AbstractNode## then
           d[]->dAbstractNode[];
           (if dAbstractNode.CurrentDecomposDiagram <> none then
               dAbstractNode.CurrentDecomposDiagram->dListDiagram[];
               dListDiagram.titleNode.abstract
           if)
       if)
   if);
   scanner: localnodes.scan
     (# aText: ^Text; 
     do
        (if switch[23] then
            'DeleteDiagramNode - current in scanner: '->puttext;
            current.theText.get->t;
            t[]->putline;
            
        if);
        (if current[]
         // d[] then
            &ObjectList[]->inheritanceEnds[];
            (if d[] = (LocalNodes.last).elm[] then
                (if switch[23] then
                    'Deleting last element in localnodes'->putline
                if);
                d.getconnectors->connectorList[];
                (if connectorList[] <> none then
                    connectorList.scan
                      (# 
                      do
                         current[]->con[];
                         true->con.getEnds->(n1[],n2[]);
                         (if (n1[] <> none ) and (n2[] <> none ) then
                             (if (n1## <= patternDiagramNode##) and
                             (n2## <= patternDiagramNode##) then
                                 n1[]->node1[];
                                 n2[]->node2[];
                                 (if node1[] <> d[] then
                                     node1.theDiagram->theListDiagram[];
                                     (if current## <=
                                     theListDiagram.PrefixConnector## then
                                         (if switch[23] then
                                             'Inserting in inheritanceEnds: '
                                               ->puttext;
                                             node1.id->putint;
                                             newline
                                         if);
                                         node1[]->inheritanceEnds.insert;
                                         con.delete
                                      else
                                         (if switch[23] then
                                             'It is not a prefixConnector'
                                               ->putline
                                         if)
                                     if)
                                  else
                                     node2.theDiagram->theListDiagram[];
                                     (if current## <=
                                     theListDiagram.PrefixConnector## then
                                         (if switch[23] then
                                             'Inserting in inheritanceEnds: '
                                               ->puttext;
                                             node2.id->putint;
                                             newline
                                         if);
                                         node2[]->inheritanceEnds.insert;
                                         con.delete
                                      else
                                         (if switch[23] then
                                             'It is not a prefixConnector'
                                               ->putline
                                         if)
                                     if)
                                 if)
                             if)
                         if)
                      #)
                if)
            if);
            d.geometry->(x,y,w,h);
            (if deleteNode
             // true then
                d.delete;
                (* ESS: was outside the if:
                 *)
                true->deleted;
                
            if);
            (if switch[23]
             // true then
                (if deleteNode
                 // true then
                    'DeleteDiagramNode: element found and deleted'
                      ->screen.putline;
                    
                 else
                    'DeleteDiagramNode: element found but not deleted'
                      ->screen.putline;
                    
                if)
            if);
            titlenode.center->(tx,ty);
            current[]->abs[];
            (if x < tx
             // true then
                (abs.theTreeConn[] <> none )->leftAtTitle; leave scanner
            if);
            
         else
            (if deleted
             // true then (* move the rest *)
                current.center->(x,y);
                current[]->abs[];
                (if abs.theTreeConn[]
                 // none then (x,y-gppProp.height)->abs.center; 
                 else
                    (x-w,y)->abs.center;
                    x-w->p[5];
                    y-(gppProp.DownOnPage)->p[6];
                    y-(gppProp.DownOnPage)->p[4];
                    titleNode.center->(x,y);
                    x->p[3];
                    p->abs.theTreeConn.Points;
                    
                if);
                (if switch[23]
                 // true then
                    'DeleteDiagramNode - element moved: '->puttext;
                    current.theText.get->t;
                    t[]->putline;
                    
                if);
                
            if)
        if)
     #);
   (if switch[23] then 'DeleteDiagramNode end of scanner'->putline if);
   (if leftAtTitle
    // true then
       scanner: localNodes.scan
         (# 
         do
            (if current[]
             // d[] then leave scanner; 
             else
                current.center->(x,y);
                current[]->abs[];
                (x+w,y)->abs.center;
                x+w->p[5];
                y-(gppProp.DownOnPage)->p[6];
                y-(gppProp.DownOnPage)->p[4];
                titleNode.center->(x,y);
                x->p[3];
                p->abs.theTreeConn.Points;
                
            if);
            (if switch[23]
             // true then
                'DeleteDiagramNode - element moved (leftAtTitle=true): '
                  ->puttext;
                current.theText.get->t;
                t[]->putline;
                
            if);
            
         #)
   if);
   d[]->localnodes.at->localnodes.delete;
   (if LocalNodes.empty then
       inheritanceEnds.scan
         (# 
         do
            current[]->node1[];
            node1.theDiagram->theListDiagram[];
            &theListDiagram.PrefixConnector[]->prefixCon[];
            (current[],titleNode[])->prefixCon.prefixNew;
            current[]->theTitleNode[];
            prefixCon[]->theTitleNode.thePrefixConn
         #)
    else
       inheritanceEnds.scan
         (# 
         do
            current[]->node1[];
            node1.theDiagram->theListDiagram[];
            &theListDiagram.PrefixConnector[]->prefixCon[];
            (current[],(localNodes.last).elm[])->prefixCon.prefixNew;
            current[]->theTitleNode[];
            prefixCon[]->theTitleNode.thePrefixConn
         #)
   if);
   0->MaxWidth;
   0->MaxHeight;
   localNodes.scan
     (#  do current.FitToText; current.size->updateMaxWH #);
   localNodes.adjustSizes;
   
#)  

-- ReplaceDiagramNode: Descriptor --
(#
   x,y,w,h: @Integer;
   startPos: @point;
   insertAfterPos,insertBeforePos,thePos: ^localnodes.theCellType;
   IsDynamic:
     (#
        yes: @Boolean;
        anAST: ^AST;
        decl: ^betaGram.SimpleDecl;
        theSpec: ^betaGram.ReferenceSpecification;
        
     enter anAST[]
     do
        (if anAST## <= betagram.SimpleDecl## then
            anAST[]->decl[];
            decl.GetReferenceSpecification->anAST[];
            (if anAST## <= betagram.ReferenceSpecification## then
                anAST[]->theSpec[];
                (if theSpec.symbol
                 // betaGram.dynamicItem // betaGram.dynamicComponent then
                    true->yes; 
                if)
             else
                (if switch[23] then
                    'Freja-- OOBS: anAST## <= betagram.ReferenceSpecification## failed'
                      ->screen.putline
                if);
                
            if)
         else
            'Freja-- OOBS: anAST## <= betagram.SimpleDecl## failed'
              ->screen.putline;
            
        if);
        
     exit yes
     #);
   aText: @Text;
   connectorList,inheritanceEnds: ^ObjectList;
   con: ^Connector;
   prefixCon: ^theListDiagram.prefixConnector;
   node1,node2: ^PatternDiagramNode;
   n1,n2: ^DesignObject;
   theTitleNode: ^theListDiagram.title;
   dListDiagram,theListDiagram: ^ListDiagram;
   dAbstractNode: ^dListDiagram.AbstractNode;
   
do
   (if switch[23]
    // true then
       'Gpp ------- ReplaceDiagramNode: '->putText;
       newAST.Index->putInt;
       newLine;
       newAST.dump;
       newLine;
       
   if);
   d.theDiagram->dListDiagram[];
   (if d## <= dListDiagram.AbstractNode## then
       d[]->dAbstractNode[];
       (if dAbstractNode.CurrentDecomposDiagram <> none then
           dAbstractNode.CurrentDecomposDiagram->dListDiagram[];
           dListDiagram.titleNode.abstract
       if)
   if);
   true->remakingDiagram;
   scanner: localnodes.scan
     (# 
     do
        (if switch[23] then
            'ReplaceDiagramNode - examining: '->puttext;
            current.theText.get->aText;
            aText[]->putline
        if);
        (if current[]
         // d[] then
            (if switch[23] then
                'ReplaceDiagramNode - addAfterNode: '->puttext;
                current.theText.get->aText;
                aText[]->putline
            if);
            current[]->PatternDiagrams.addAfterNode[];
            PatternDiagrams.addAfterNode[]->localNodes.at->thePos[];
            (if thePos.pred[] <> none then
                thePos.pred[]->insertAfterPos[]
             else
                (if thePos.succ[] <> none then
                    thePos.succ[]->insertBeforePos[]
                if)
            if);
            &ObjectList[]->inheritanceEnds[];
            (if d[] = (LocalNodes.last).elm[] then
                (if switch[23] then
                    'Replacing last element in localnodes'->putline
                if);
                d.getconnectors->connectorList[];
                (if connectorList[] <> none then
                    connectorList.scan
                      (# 
                      do
                         current[]->con[];
                         true->con.getEnds->(n1[],n2[]);
                         (if (n1## <= patternDiagramNode##) and
                         (n2## <= patternDiagramNode##) then
                             n1[]->node1[];
                             n2[]->node2[];
                             (if node1[] <> d[] then
                                 node1.theDiagram->theListDiagram[];
                                 (if current## <=
                                 theListDiagram.PrefixConnector## then
                                     (if switch[23] then
                                         'Inserting in inheritanceEnds: '
                                           ->puttext;
                                         node1.id->putint;
                                         newline
                                     if);
                                     node1[]->inheritanceEnds.insert;
                                     con.delete
                                  else
                                     (if switch[23] then
                                         'It is not a prefixConnector'->putline
                                     if)
                                 if)
                              else
                                 node2.theDiagram->theListDiagram[];
                                 (if current## <=
                                 theListDiagram.PrefixConnector## then
                                     (if switch[23] then
                                         'Inserting in inheritanceEnds: '
                                           ->puttext;
                                         node2.id->putint;
                                         newline
                                     if);
                                     node2[]->inheritanceEnds.insert;
                                     con.delete
                                  else
                                     (if switch[23] then
                                         'It is not a prefixConnector'->putline
                                     if)
                                 if)
                             if)
                         if)
                      #)
                if)
            if);
            d.geometry->(x,y,w,h);
            d.delete;
            (* No, the node is already deleted /ESS 
             * d[]->localnodes.at->localnodes.delete;
             (Because deleteDiagramNode is called from callback onRemove,
             which is called on d.delete /TOBY)*)
            (x-(w div 2),y-(h div 2))->startPos;
            (* insert new *)
            (if newAst.kind
             // kinds.interior then
                (if newAST.symbol
                 // betaGram.SimpleDecl then
                    (if newAST[]->IsDynamic
                     // true then
                        (if gppProp.CompositionWith
                         // gppProp.CompositionAll
                         // gppProp.CompositionReference then
                            (if switch[23]
                             // true then
                                'dynamic CompositionWith, CompositionAll or CompositionReference'
                                  ->putLine;
                                
                            if);
                            (newAST[],startpos)->DisplayAST->startpos;
                            
                        if);
                        
                     else
                        (if gppProp.CompositionWith
                         // gppProp.CompositionAll
                         // gppProp.CompositionPartWhole then
                            (if switch[23]
                             // true then
                                'static  CompositionWith, CompositionAll or CompositionReference'
                                  ->putLine;
                                'startpos before: '->putText;
                                startpos.x->putInt;
                                ' '->put;
                                startpos.y->putInt;
                                newline
                            if);
                            (newAST[],startpos)->DisplayAST->startpos;
                            (if switch[23]
                             // true then
                                'startpos after: '->putText;
                                startpos.x->putInt;
                                ' '->put;
                                startpos.y->putInt;
                                newline
                            if);
                            
                        if)
                    if);
                    
                 // betaGram.PatternDecl // betaGram.VirtualDecl
                 // betaGram.BindingDecl // betaGram.FinalDecl
                 //
                 betaGram.RepetitionDecl (*// betaGram.VariablePatternDecl*)
                 then
                    (if gppProp.CompositionWith
                     // gppProp.CompositionAll // gppProp.CompositionBlock then
                        (if switch[23]
                         // true then
                            'InsertDiagramNode: PatternDecl, VirtualDecl, BindingDecl, FinalDecl, RepetitionDecl'
                              ->putLine;
                            'startpos before: '->putText;
                            startpos.x->putInt;
                            ' '->put;
                            startpos.y->putInt;
                            newline
                        if);
                        (newAST[],startpos)->DisplayAST->startpos;
                        (if switch[23]
                         // true then
                            'startpos after: '->putText;
                            startpos.x->putInt;
                            ' '->put;
                            startpos.y->putInt;
                            newline
                        if);
                        
                    if)
                if)
             // kinds.unexpanded then
                (if switch[23]
                 // true then 'InsertDiagramNode: unexpanded'->putLine; 
                if);
                (newAST[],startpos)->DisplayAST->startpos;
                
            if);
            leave scanner;
            
        if)
     #);
   (if PatternDiagrams.newNode[]
    // none then 'OOBS: newNode is NONE'->screen.putline; 
    else
       inheritanceEnds.scan
         (# 
         do
            current[]->node1[];
            node1.theDiagram->theListDiagram[];
            &theListDiagram.PrefixConnector[]->prefixCon[];
            (if switch[23] then
                'Creating PrefixConnector between: '->puttext;
                current.id->putint;
                ' and '->puttext;
                PatternDiagrams.newNode.id->putint;
                newline
            if);
            (current[],PatternDiagrams.newNode[])->prefixCon.prefixNew;
            current[]->theTitleNode[];
            prefixCon[]->theTitleNode.thePrefixConn
         #);
       (if insertAfterPos[] <> none then
           (PatternDiagrams.newNode[],insertAfterPos[])->localNodes.insertAfter
        else
           (if insertBeforePos[] <> none then
               (PatternDiagrams.newNode[],insertBeforePos[])
                 ->localNodes.insertBefore
            else
               PatternDiagrams.newNode[]->localNodes.append
           if)
       if);
       
   if);
   none ->PatternDiagrams.addAfterNode[];
   false->remakingDiagram;
   localNodes.adjustSizes;
   
#)  

-- UpdateDiagramNode: Descriptor --
(#
   theNode,theNode2: ^DiagramNode;
   testNode: ^IdObject;
   aDeclaration: ^betaGram.AttributeDecl;
   anAST,keepOldAST,keepNewAST: ^ast;
   anExp: ^expanded;
   theNames: ^betaGram.Names;
   theDecomposDiagram: ^Diagram;
   updateName:
     (#
        theNewNameDcl,theOldNameDcl: ^betaGram.NameDcl;
        theNewNameDecl,theOldNameDecl: ^NameDecl;
        oldText,newText: ^text;
        doUpdate: @Boolean;
        aPatternDiagram: ^PatternDiagram;
        theNewAST,theOldAST: ^AST
     do
        (if theNode.currentDecomposDiagram <> none
        (*Update name in titlenode of detailed*) then
            anAST[]->theNewNameDcl[];
            theNewNameDcl.getSon1->theNewAST[];
            (if theNewAST.kind = kinds.unexpanded then
                '<<NameDecl>>'->newText[]
             else
                theNewAST[]->theNewNameDecl[]; theNewNameDecl.getText->newText[]
            if);
            (if oldAST.symbol = betaGram.NameDcl then
                oldAST[]->theOldNameDcl[];
                theOldNameDcl.getSon1->theOldAST[];
                (if theOldAST.kind = kinds.unexpanded then
                    '<<NameDecl>>'->oldText[]
                 else
                    theOldAST[]->theOldNameDecl[];
                    theOldNameDecl.getText->oldText[]
                if);
                (if oldText[]->newText.equal then
                    (if switch[23] then
                        'UpdateDiagramNode: old name is equal to new name!'
                          ->putline
                    if)
                 else
                    true->doUpdate
                if)
             else
                true->doUpdate
            if);
            (if doUpdate then
                theNode.currentDecomposDiagram->aPatternDiagram[];
                newText->aPatternDiagram.titleText
                  ->aPatternDiagram.titleNode.theText.set;
                (if switch[23] then
                    'UpdateDiagramNode: name updated in detailed is '->puttext;
                    (theNode.currentDecomposDiagram).titleText[]->putline
                if)
             else
                (if switch[23] then
                    'UpdateDiagramNode: doUpdate is false'->putline
                if)
            if)
         else
            (if switch[23] then
                'UpdateDiagramNode: currentDecomposDiagram is none'->putline
            if)
        if)
     #);
   
do
   (if switch[23]
    // true then
       'Gpp ------- UpdateDiagramNode: '->putText;
       oldAST.Index->putInt;
       newLine;
       
   if);
   oldAST[]->keepOldAST[];
   newAST[]->keepNewAST[];
   search:
   (if oldAST[]
    // none then
       'Gpp ------- UpdateDiagramNode: node not found: '->putText;
       oldAST.Index->putInt;
       newLine;
       
    else
   (*(oldAST.index,newAST.index)->IndexIDList.update->testNode[];*)
       (oldAST[],newAST[])->ASTtoNodeListUpdate->theNode[];
       (*(if testNode[]
        // none then
        else
        (if true
        // testNode.struc <= PatternDiagramNode## then
        testNode[]->theNode[]
        else
        'It is not a PatternDiagramNode!!'->putLine;
        if);
        if);
        * *)
       testRedisplay:
       (if theNode[]
        // none then
           (if switch[23] then
               'Calling redisplay - internal part of declaration was expanded'
                 ->putline
           if);
           getDecl:
           (if (keepNewAST## <= betaGram.attributeDecl##) or
           (keepNewAST[]->keepNewAST.frag.root.equal) then
               
            else
               keepNewAST.father->keepNewAST[]; restart getDecl
           if);
           (if keepNewAST## <= betaGram.attributeDecl## then
               keepNewAST[]->anExp[];
               anExp.getSon1->theNames[];
               theNames.newScan
                 (#  do current[]->anAST[] #);
               keepNewAST[]->ASTtoNode->theNode[];
               (if theNode[] <> none then
                   updateName; (keepNewAST[],anAST[])->theNode.Redisplay
                else
                   (if switch[23] then
                       'Surrounding declaration not present in IndexIDList??'
                         ->putline
                   if)
               if)
            else
               (if switch[23] then
                   'No part of a declatation was changed - no redisplay is done'
                     ->putline
               if)
           if);
           ;
           
        else
           (if keepNewAST.symbol
            // betaGram.nameDcl then
               (if switch[23]
                // true then '  it is a nameDcl'->putLine; 
               if);
               keepNewAST.father->anAST[];
               anAST.father->aDeclaration[];
               keepNewAST[]->anAST[];
               
            else
               (if (keepNewAST.struc <= betaGram.attributeDecl##)
                // true then
                   (if switch[23]
                    // true then
                       '  it is a declaration: '->putText;
                       keepNewAST.symbol->putInt;
                       newLine;
                       
                   if);
                   (if theNode.CurrentDecomposDiagram <> none then
                       theNode.CurrentDecomposDiagram->theDecomposDiagram[];
                       theDecomposDiagram.titleNode.abstract
                   if);
                   keepNewAST[]->aDeclaration[];
                   aDeclaration.getson1->anExp[];
                   anExp.getson1->anAST[];
                   
                else
                   (if switch[23]
                    // true then
                       'not namedcl or attributeDecl: '->putText;
                       newAST.symbol->putInt;
                       newLine;
                       
                   if);
                   leave testRedisplay;
                   
               if);
               
           if);
           (if switch[23]
            // true then
            (* keepNewAST.dump;
             newline;
             (if aDeclaration[]
             // none then
             else
             aDeclaration.dump; newline;
             if); *)
               
           if);
           updateName;
           (aDeclaration[],anAST[])->theNode.redisplay;
           
       if);
       
   if);
   localNodes.adjustSizes
#)  

-- ListDiagramOnInit: Descriptor --
(# 
do
   UDPrivate.UDListDiagram->UserDataInit;
   UDdetailPage.Init;
   UDNoOfRefConnectors.Init;
   UDMaxHeight.init;
   UDMaxWidth.init;
   (if not initialisingSaved then
       THIS(ListDiagram)[]->theDiagram; geometry->(x,y,w,h)
   if);
   
#)  

-- ListDiagramOnRemove: Descriptor --
(# theParent: ^PatternDiagramNode
do (* tell the parent node that it is no longer detailed *)
   (if theParentNode <> none
    // true then
       theParentNode->theParent[]; theParent.abstractedFromDiagramBelow; 
   if);
   
#)  

-- ListDiagramOnDoubleClick: Descriptor --
(# 
do
   localNodes.abstractAll;
   False->proceed;
   (*don't let design/OA proceed in normal way*)
   
#)  

-- ListDiagramAbstract: Descriptor --
(# connectorList: ^ObjectList; ok,areUserConns: @Boolean; prompt: @Text
do
   (if switch[1] // true then 'title abstract all my nodes'->putline if);
   localNodes.abstractAll;
   Delete;
   
#)  

-- ListDiagramDetail: Descriptor --
(# lnode: ^PatternDiagramNode; lastNode: ^AbstractNode; 
do
   (if switch[1]
    // true then 'title detail all attribute decls...'->putline; 
   if);
   false->doScrollIntoView;
   localNodes.scan
     (#  do current.detail; current[]->lnode[] #);
   true->doScrollIntoView;
   (if lnode[] <> none then
       (if (*could be a SlotNode*) lnode## <= AbstractNode## then
           lnode[]->lastNode[];
           (if lastNode.currentDecomposDiagram <> none then
               (lastNode.currentDecomPosdiagram).titleNode[]
                 ->THIS(OADPage).scrollIntoView;
               
            else
               'lastNode.currentDecomposDiagram is NONE'->screen.putline; 
           if)
       if)
   if);
   
#)  

-- listDiagramUpdateAstFromDisk: Descriptor --
(# fn: ^FragmentNode; 
do
   (if switch[1] // true then 'listDiagramUpdateAstFromDisk'->putLine;  if);
   (if (theObject.theDiagram).theFragmentNode <> none
    // true then (theObject.theDiagram).theFragmentNode->fn[]; 
    else
       (if theObject.struc <= FragmentNode##
        // true then
           'Freja[[listDiagramUpdateAst:: we got a FragmentNode to update]'
             ->screen.putline;
           theObject[]->fn[];
           
        else
           (theObject[],screen[])->PrintObject; 
       if);
       
   if);
   (if fn[] <> none
    // true then (oldff[],theObject[])->fn.ReReadAST->newFF[]; 
    else
       'Freja[[ERROR: listDiagramUpdateAstFromDisk no fragmentnode!!]]'
         ->screen.putline;
       
   if);
   (if switch[1]
    // true then 'end listDiagramUpdateAstFromDisk'->putLine; 
   if);
   
#)
(* OADDIAGRAMS *)  

-- updateMaxWH: Descriptor --
(# 
do
   (w,MaxWidth)->max->MaxWidth;
   (h,MaxHeight)->max->MaxHeight;
   (GppProp.width,MaxWidth)->max->MaxWidth;
   (GppProp.height,MaxHeight)->max->MaxHeight
#)  

-- OADDiagramNew: Descriptor --
(# theDummyDesc: ^betaGram.ObjectDescriptor
do
(* save THIS(OADDiagram) with the ASTindex of the  
 * descriptor it is generated from so it can be located later
 *)
   (if theDescriptor <> none
    // true then
       theDescriptor->theDummyDesc[];
       (theDummyDesc.index,THIS(OADDiagram)[])
         ->PatternDiagrams.theList.insertPD;
       
   if);
   
#)  

-- OADDisplayDeclarations: Descriptor --
(#
   x,y,w,h: @Integer;
   HasAttributesDefined:
     (#
        yes: @Boolean;
        decl: ^betaGram.SimpleDecl;
        theSpec: ^betaGram.ReferenceSpecification;
        theObjectSpec: ^AST;
        os: ^betaGram.ObjectSpecification;
        
     enter decl[]
     do
        decl.GetReferenceSpecification->theSpec[];
        theSpec.getson1->theObjectSpec[];
        (if theObjectSpec.kind
         // kinds.interior then
            (if theObjectSpec.symbol
             // betaGram.ObjectDescriptor then
             (* it was an ObjectSpecification *)
                theObjectSpec[]->os[];
                (if theObjectSpec.frag.father->ischecked
                 // true then (os.findDescriptor->CountAttributes) > 0->yes
                if)
            if)
        if)
     exit yes
     #);
   IsDynamic:
     (#
        yes: @Boolean;
        anAST: ^AST;
        decl: ^betaGram.SimpleDecl;
        theSpec: ^betaGram.ReferenceSpecification;
        
     enter anAST[]
     do
        (if anAST## <= betagram.SimpleDecl## then
            anAST[]->decl[];
            decl.GetReferenceSpecification->anAST[];
            (if anAST## <= betagram.ReferenceSpecification## then
                anAST[]->theSpec[];
                (if theSpec.symbol
                 // betaGram.dynamicItem // betaGram.dynamicComponent then
                    true->yes; 
                if)
             else
                (if switch[23] then
                    'Freja-- OOBS: anAST## <= betagram.ReferenceSpecification## failed'
                      ->screen.putline
                if);
                
            if)
         else
            'Freja-- OOBS: anAST## <= betagram.SimpleDecl## failed'
              ->screen.putline;
            
        if);
        
     exit yes
     #);
   
do
   (if theAttributes[]
    // none then (* it is a non-terminal: display it as such *)
       'DisplayDeclarations: ATTRIBUTES IS NONE'->putline; 
    else
       (if gppProp.CompositionDType > gppProp.CompositionNested
        // true then
        (* first display simple declarations like references (static and dynamic)
         * then display pattern and virtual declarations;
         *)
           titleNode.geometry->(x,y,w,h);
           x->startpos.x;
           startpos.y+(2*gppProp.DownOnPage)->startpos.y;
           
       if);
       theAttributes.scan
         (# 
         do
            (if current.kind
             // kinds.interior then
                (if current.symbol
                 // betaGram.SimpleDecl then
                    (if current[]->IsDynamic
                     // true then
                        (if gppProp.CompositionWith
                         // gppProp.CompositionAll
                         // gppProp.CompositionReference then
                            (current[],startpos)->DisplayAST->startpos; 
                        if);
                        
                     else
                        (if gppProp.CompositionWith
                         // gppProp.CompositionAll
                         // gppProp.CompositionPartWhole then
                            (current[],startpos)->DisplayAST->startpos; 
                        if)
                    if);
                    
                 // betaGram.PatternDecl // betaGram.VirtualDecl
                 // betaGram.BindingDecl // betaGram.FinalDecl
                 //
                 betaGram.RepetitionDecl (*// betaGram.VariablePatternDecl *)
                 then
                    (if gppProp.CompositionWith
                     // gppProp.CompositionAll // gppProp.CompositionBlock then
                        (current[],startpos)->DisplayAST->startpos; 
                    if)
                if)
             // kinds.unExpanded then
                (current[],startpos)->DisplayAST->startpos; 
             else
                
            if)
         #);
       LocalNodes.adjustSizes
   if)
#)  

-- OADDiagramOnRemove: Descriptor --
(# theDummyDesc: ^betaGram.ObjectDescriptor
do (* remove the diagram from the list of patterndiagrams on the page *)
   (if theDescriptor <> none
    // true then
       theDescriptor->theDummyDesc[];
       theDummyDesc.index->PatternDiagrams.theList.deletePD;
       (*if this is the last diagram on the page close the page *)
       (if PatternDiagrams.theList.size // 0 then close if);
       
   if);
   
#)  

-- OADDisplay: Descriptor --
(#
   p: ^localNodes.theCellType;
   e: ^LocalNodes.element;
   det: ^AbstractNode;
   x,y,w,h: @Integer;
   theDummyDesc: ^betaGram.ObjectDescriptor
do
   (if theDescriptor
    // none then
       (if switch[1] // true then 'theDescriptor is NONE '->puttext if); 
   if);
   CalculateNextCenter->theCenter;
   (if theDescriptor <> none
    // true then
       theDescriptor->theDummyDesc[];
       theDummyDesc.index->titleNode.astIndex;
       (if switch[1] then
           'OADDisplay: '->putText;
           titleNode.astIndex->putInt;
           '->astIndex'->putLine
       if);
       
   if);
   INNER Display;
   (if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
       (if PatternDiagrams.Detailer[] <> none
        // true then
           PatternDiagrams.Detailer[]->det[];
           (if det.theTreeConn[]
            // none then
            (* the Detailer is part of a blockDiagram and not a tree *)
               (theCenter.x,theCenter.y,gppProp.titlewidth,gppProp.height*2,
                titleNode.defaultShape)->titleNode.new;
               
            else
           (* the new diagram is connected to an existing tree diagram *)
               PatternDiagrams.Detailer.geometry->(x,y,w,h);
               (x,y,w,h,titleNode.defaultShape)->titleNode.new;
               PatternDiagrams.Detailer[]->titleNode.CreateRegion;
               true->PatternDiagrams.Detailer.moveable;
               false->titleNode.selectable;
               false->titleNode.borderVisible;
               titleNode.theText.clear;
               PatternDiagrams.Detailer[]->CurrentObject;
               
           if);
           
        else
           (theCenter.x,theCenter.y,gppProp.titlewidth,gppProp.height*2,
            titleNode.defaultShape)->titleNode.new;
           
       if);
       
    else
       (theCenter.x,theCenter.y,gppProp.titlewidth*2,gppProp.height,
        titleNode.defaultShape)->titleNode.new;
       
   if);
   (* now we can make the diagram: titleNode.new, calls onInit as callback
    * which then calls DisplayDeclarations to display the contaning decls.
    *)
   (* Now we make final adjustment (we must know the number of subnodes
    * before we can do this).
    *	
    * If we make trees then we must adjust the localNodes so they
    * are centered
    *)
   (if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
       (if localNodes.empty
        // true then (theCenter,titleNode.Center)->UpdateNextFree; 
        else
             (#
                pos1,pos2: @Point;
                x,y,w,h,dist: @Integer;
                no: @Integer;
                lastSimple, (* last node in simple pattern diagram *) firstTree,
                (* first node in tree pattern diagram *) lastTree:
                (* last node in tree pattern diagram *) ^PatternDiagramNode;
                
             do
                (if localNodes.empty
                 // false then (* update for the next diagram *)
                    localNodes.last->p[]; p.elm[]->e[]; e.Center->pos1; 
                 else
                    titleNode.Center->pos1; 
                if);
                pos1.x+gppProp.DownOnPage->pos1.x;
                (theCenter,pos1)->UpdateNextFree;
                titleNode[]->lastSimple[];
                localNodes.scan (* count the nodes in tree position *)
                  (# d: ^DiagramNode; 
                  do
                     (if current.struc <= DiagramNode##
                      // true then
                         current[]->d[];
                         (if d.theTreeConn[]
                          // none then
                             current[]->lastSimple[]; (* in simple diagram *) 
                          else
                             (if firstTree[]
                              // none then current[]->firstTree[]
                             if);
                             current[]->lastTree[];
                             no+1->no;
                             
                         if)
                     if)
                  #);
                (if true (* calculate adjustment *)
                 // (no > 1) then (* adjust them *)
                    firstTree.Center->pos1;
                    lastTree.Center->pos2;
                    (pos2.x-pos1.x) div 2->dist;
                    lastSimple.Center->pos2;
                    dist-(pos2.x-pos1.x)->dist;
                    
                 // (no = 1) then (* center the one *)
                    lastSimple.center->pos1;
                    localNodes.last->p[];
                    p.elm[]->e[];
                    e.Center->pos2;
                    pos2.x-pos1.x->dist;
                    
                 else
                (* no subnodes in tree *)
                    
                if);
                localNodes.scan (* adjust the subnodes *)
                  (# d: ^DiagramNode; 
                  do
                     (if current.struc <= DiagramNode##
                      // true then
                         current[]->d[];
                         (if d.theTreeConn[]
                          // none then (* in simple pattern diagram *)
                             (0,0)->current.ConcludeDisplay; 
                          else
                         (* in tree *)
                             (dist,0)->current.ConcludeDisplay; 
                         if)
                     if)
                  #)
             #)
       if);
       
    else
   (* just make a simple patterndiagram of all the nodes
    * update NextFreeLine to the y coordinate of the last node in
    * plus offset *)
       (if localNodes.empty
        // true then (theCenter,titleNode.Center)->UpdateNextFree; 
        else
           localNodes.scan
             (#  do (0,0)->current.ConcludeDisplay #);
           localNodes.Last->p[];
           p.elm[]->e[];
           (theCenter,e.Center)->UpdateNextFree
       if)
   if)
#)
(* FRAGMENTDIAGRAMS *)  

-- FragmentDiagramNew: Descriptor --
(#
   w,h: @Integer;
   groupTitle: ^PatternDiagramNode;
   e: ^LocalNodes.element;
   p: ^Localnodes.theCellType;
   theDummyGroup: ^FragmentGroup
do
   theGroup->theDummyGroup[];
   theDummyGroup.name->ExpandToFullPath->fullname;
   INNER New;
   PatternDiagrams.theList.scanPropertyDiagrams
     (# (* go find the property diagram of theGroup *) 
     do
        (if thisDiagram.theGroup
         // theGroup then
            (if thisDiagram.localNodes.empty
             // false then
                thisDiagram.localnodes.last->p[];
                p.elm[]->e[];
                e.geometry->(x,y,w,h);
                
             else
                thisDiagram.titleNode.geometry->(x,y,w,h); 
            if);
            thisDiagram.titleNode[]->groupTitle[];
            
        if);
        
     #);
   y+gppProp.DownOnPage->y;
   (* CalculateNextCenter -> (x,y); *)
   x-(w div 2)+(gppProp.titlewidth div 2)->x;
   (x,y,gppProp.titlewidth,gppProp.height,titleNode.defaultShape)
     ->titleNode.new;
   groupTitle[]->titleNode.CreateRegion;
   (0,THIS(FragmentDiagram)[])->PatternDiagrams.theList.insertPD;
   
#)  

-- FragmentDiagramTitleInit: Descriptor --
(# theDummyGroup: ^FragmentGroup
do (* show fragments starting at low-left of the titleNode *)
   UDPrivate.UDFragmentDiagram->UserDataInit;
   UDfullname.Init;
   UDtheGroup.Init;
   gppProp.fontSize->theText.size;
   LeftJustification->theText.Just;
   false->BorderVisible;
   (if not initialisingSaved then
       (x-(w+1) div 2,y-((h+1) div 2))->(x,y);
       theGroup->theDummyGroup[];
       theDummyGroup.fragmentList.scan
         (#
            f: ^FragmentForm;
            theForm: ^betaGram.BetaForm;
            theNode: ^FragmentNode;
            
         do
            (if current.type
             // linkType then (* ignore *)
                
             // groupType then
                'Groups in groups not suported'->putline; 
             // formType then
                current.f[]->f[];
                f.root[]->theForm[];
                (if theForm.symbol
                 // betaGram.DescriptorForm then
                    &DescriptorNode[]->theNode[]; 
                 // betaGram.AttributesForm then
                    &AttributesNode[]->theNode[]; 
                 else
                    'Other type'->putline; 
                if);
                gppProp.height+y->y;
                THIS(FragmentDiagram)[]->theNode.theDiagram;
                ((x,y),current.f[])->theNode.display;
                (0,0)->theNode.ConcludeDisplay;
                
            if);
            
         #);
       'Fragments'->titleText;
       titletext->theText.set;
       ((x,y),(x,y))->UpdateNextFree;
       scanner: PatternDiagrams.theList.scanPropertyDiagrams
         (#
            x1,y1,w1,h1: @Integer;
            (* go find the property diagram of theGroup *)
            
         do
            (if thisDiagram.theGroup
             // theGroup then
             (* update the surroundBox of the property diagram *)
                thisDiagram.surroundBox.geometry->(x1,y1,w1,h1);
                (x+gppProp.width,y1+(h1 div 2)+((y-y1+(h1 div 2)) div 2)+1,
                 gppProp.width*2+20, (* width *) y-y1+gppProp.height)
                (* height *) ->thisDiagram.surroundBox.geometry;
                leave scanner;
                
            if);
            
         #)
   if);
   
#)  

