ORIGIN 'diagramattributes';
INCLUDE '~beta/sysutils/v1.6/objinterface'
        'gppinterfacebody';
(* DIAGRAM *)
-- TitleInteractiveNew: Descriptor --
(#  do (w,h)->Size #)  

-- TitleOnInit: Descriptor --
(# 
do
   UDPrivate.UDDiagram
     ->UserDataInit
     (*toby 1-11-94:
      User data initializations*) ;
   UDtheParentNode.Init;
   UDtheFragmentNode.Init;
   thePrefixConn.Init;
   false->sizeable;
   font.Geneva->theText.font;
   textJust.Centered->theText.just;
   gppProp.fontSize->theText.size;
   textStyle.bold->theText.style;
   INNER OnInit;
   (* titleText -> theText.set; resposibility of sub patterns *)
   
#)  

-- TitleOnSelect: Descriptor --
(# 
do
   (PatternDiagrams.oldSelection[],THIS(title)[])->changedFocus;
   THIS(title)[]->PatternDiagrams.oldSelection[];
   enableEditName;
   INNER onSelect;
   
#)
(* LISTDIAGRAM *)  

-- TitleTextModeOn: Descriptor --
(# 
do
   (if switch[80] then 'Text mode on in TitleNode'->putLine;  if);
   theText.get->theTextBefore;
   true->onGoingTextEditing;
   true->onGoingTitleEditing;
   THIS(title).geometry->(oldX,oldY,oldWidth,oldHeight);
   getRegionList->theRegionList[];
   (if theRegionList[] <> none then
       theRegionList.scan
         (# anObj: ^DesignObject
         do current[]->anObj[]; anObj.unmakeRegion
         #);
       
   if);
   (3*GppProp.titleWidth div 2,3*GppProp.height)->THIS(title).size;
   
#)  

-- TitleTextModeOff: Descriptor --
(# t: @text; theNode: ^patternDiagramNode; anExp: ^mps.expanded; 
do
   (if switch[80] then 'Text mode off in titleNode '->putLine;  if);
   theText.get->t;
   (if switch[80] then t[]->putLine;  if);
   (if not (theTextBefore[]->t.equal) then
       (thisDiagram).theParentNode->theNode[];
       (if theNode[]
        // none then 'theDeclaration is none!! '->putLine
        else
       (* theNode[]->currentObject;*)
           ((thisDiagram).theParentNode).getAstNode->anExp[];
           (theNode[],anExp.getSon1,t[])->declarationTextChanged;
           (if parseErrorOccurred then false->OKToExit else true->changed if);
           
       if)
    else
       false->ongoingTextediting;
       false->onGoingTitleEditing;
       false->parseErrorOccurred
   if);
   
#)  

-- TitleTextOnTextModeOff: DoPart --
do
     (# w,h,newX: @integer
     do
        (if changed then
            FitToText;
            THIS(title).size->(w,h);
            oldX-oldWidth div 2+((w,gppProp.titleWidth)->max) div 2->newX;
            (newX,oldY,(w,gppProp.titleWidth)->max,(h,gppProp.height)->max)
              ->THIS(title).geometry
         else
            (oldX,oldY,oldWidth,oldHeight)->THIS(title).geometry
        if);
        (if theRegionList[] <> none then
            theRegionList.scan
              (# anObj: ^DesignObject
              do current[]->anObj[]; THIS(title)[]->anObj.createRegion
              #)
        if)
     #)  

-- TitleTextOnTextModeOn: DoPart --
do (*  theText.getLength->length;
    (0,length)->theText.SetSelection; *)
(*   (#
 t: @Text;
 TWMetaTextFromWidget: external
 (# object: @integer do 'TW_MetaTextFromWidget'->callC #);
 TextHighlight: external
 (# text: @integer enter text do 'Text_Highlight'->callC #))
 do theText.get->t; @@ t.T[1]->TextHighlight
 #)*)   

-- TitleTheSifEditor: DoPart --
do
   (if theFragmentNode <> none then
       (if se[] = none then
           theFragmentNode->fn[]; fn.theSifEditor->se[]; 
        else
           theFragmentNode->fn[]; se[]->fn.theSifEditor; 
       if);
       
    else
       (if switch[40] then
           'titleNode: theSifEditor: no FragmentNode'->screen.putline
       if)
   if)  

-- diagramTitleDump: DoPart --
do
   '********theParentNode********'->putline;
   (if theParentNode <> none then
       (theParentNode).ID->putint; newline
    else
       'is NONE!'->putline
   if);
   '********theFragmentNode********'->putline;
   (if theFragmentNode <> none then
       (theFragmentNode).id->putint; newline
    else
       'is NONE!'->putline
   if);
   '********thePrefixConn********'->putline;
   (if thePrefixConn <> none then
       (thePrefixConn).id->putint; newline
    else
       'is NONE!'->putline
   if);
   INNER dump  

-- LocalNodesAbstractAll: Descriptor --
(# dummy: ^DiagramNode; theDiagram: ^Diagram; 
do
   (if current## <= DiagramNode##
    // true then
       current[]->dummy[];
       (if dummy.currentDecomposDiagram <> none
        // true then
           dummy.currentDecomposDiagram->theDiagram[];
           theDiagram.titleNode.abstract
       if)
   if);
   (*localnodes *must* be explicitely deleted before
    their titles.
    If not their theDiagram ref. cannot be read
    in deleteDiagramNode.*)
   current.delete;
   
#)  

-- LocalNodesAdjustSizes: Descriptor --
(#
   tx,ty,tw,th,tleft,x,y,w,h: @integer;
   regions: ^ObjectList;
   regionsWithSize: @list
     (#
        element:: 
          (#
             region: ^DesignObject;
             w,h: @integer;
             size: (#  enter (w,h) exit (w,h) #)
          #);
        insert:
          (# anObj: ^DesignObject; elm: ^element
          enter anObj[]
          do
             &element[]->elm[];
             anObj[]->elm.region[];
             anObj.size->elm.size;
             elm[]->append
          #);
        restoreRegionSizes: scan (#  do current.size->current.region.size #)
     #)
do
   TitleNode.geometry->(tx,ty,tw,th);
   tx-(tw div 2)->tleft;
   titleNode.getRegionList->regions[];
   (if regions[] <> none then
       regions.scan
         (# theObject: ^DesignObject
         do
            (if not (current## <= PatternDiagramNode##) then
                current[]->regionsWithSize.insert
             else
                current[]->theObject[]; theObject.unMakeRegion
            if)
         #)
   if);
   (tleft+(MaxWidth div 2),ty,MaxWidth,GppProp.Height)->titleNode.geometry;
   (if regions[] <> none then
       regions.scan
         (# theObject: ^DesignObject
         do
            (if current## <= PatternDiagramNode## then
                current[]->theObject[]; titleNode[]->theObject.createRegion
            if)
         #);
       (if not regionsWithSize.empty then
           regionsWithSize.restoreRegionSizes; regionsWithSize.clear
       if)
   if);
   LocalNodes.scan
     (# currentLocalNode: ^PatternDiagramNode
     do
        current.geometry->(x,y,w,h);
        current.getRegionList->regions[];
        (if regions[] <> none then
            regions.scan (#  do current[]->regionsWithSize.insert #)
        if);
        (tleft+(MaxWidth div 2),y,MaxWidth,GppProp.Height)->current.geometry;
        (if not regionsWithSize.empty then
            regionsWithSize.restoreRegionSizes; regionsWithSize.clear
        if)
     #);
   (if theSurroundBox <> none then
       TitleNode.geometry->(tx,ty,tw,th);
       (if localNodes.empty or (not gppProp.showAttributes) then
           (tx,ty,tw,th)->(theSurroundBox).geometry
        else
           (tx,ty-gppProp.height div 2+((localNodes.size+1)*gppProp.height) div
            2,tw,(localNodes.size+1)*gppProp.height)->(theSurroundBox).geometry
       if)
   if)
#)  

-- localNodesDump: DoPart --
do
   'LocalNodes:'->putline;
   scan
     (# t: @text
     do current.id->putint; ': '->puttext; current.theText.get->t; t[]->putline
     #);
   'End LocalNodes'->putline  

-- InsertDiagramNode: Descriptor --
(#
   previousNode: ^PatternDiagramNode;
   i: @Integer;
   x,y,w,h: @Integer;
   startPos: @point;
   displayNode:
     (# 
     do
        previousNode.geometry->(x,y,w,h);
        x-(w div 2)->x;
        x+gppProp.width->x;
        gppProp.width*2->w;
        previousNode[]->PatternDiagrams.addAfterNode[];
        (x-(w div 2),y-(h div 2)+gppProp.height)->startPos;
        (anAst[],startpos)->DisplayAST->startpos
     #);
   aText: @Text;
   connectorList (* ,inheritanceEnds *) : ^ObjectList;
   con: ^Connector;
   node1,node2: ^PatternDiagramNode;
   n1,n2,p1,p2: ^DesignObject;
   theTitleNode: ^theListDiagram.title;
   theListdiagram: ^ListDiagram;
   object1,object2: ^designObject;
   
do
   (if switch[60]
    // true then
       'Gpp ------- InsertDiagramNode: '->putText;
       pos->putInt;
       ' '->put;
       anAst.Index->putInt;
       newLine;
       anAST.dump;
       newLine;
       
   if);
   1->i;
   true->remakingDiagram;
   (if pos = 0 then titleNode[]->previousNode[]; displayNode if);
   localnodes.scan
     (# aText: @Text; 
     do
        (if switch[60] then
            'InsertDiagramNode: examening no '->puttext;
            i->putint;
            ' element in localnodes - '->puttext;
            current.thetext.get->aText;
            aText[]->putline
        if);
        (if i
         // pos then current[]->previousNode[]; displayNode
         else
            (if (* what about this? (current[]<>aNode[]) and *) (i > pos)
             // true then
                (if switch[60]
                 // true then
                    'InsertDiagramNode: move down '->puttext;
                    current.theText.get->aText;
                    aText[]->putline;
                    
                if);
                current.center->(x,y);
                (x,y+gppProp.height)->current.center;
                
            if)
        if);
        i+1->i;
        
     #);
   (if PatternDiagrams.newNode[] = none then
       'OOBS: newNode is NONE'->screen.putline; 
    else
       (if pos <> 0 then
           (PatternDiagrams.newNode[],
            PatternDiagrams.addAfterNode[]->localNodes.at)
             ->localNodes.insertAfter
        else
           (if switch[60] then
               'InsertDiagramNode - prepending in localNodes: '->puttext;
               PatternDiagrams.newNode.theText.get->aText;
               aText[]->putline
           if);
           PatternDiagrams.newNode[]
             ->
               localNodes.prepend
               (*The new node is the topmost localNode when pos=0*)
       if);
       
   if);
   none ->PatternDiagrams.addAfterNode[];
   false->remakingDiagram;
   localNodes.adjustSizes;
   
#)  

-- DeleteDiagramNode: Descriptor --
(#
   x,y,w,h: @Integer;
   tx,ty: @Integer;
   deleted: @boolean;
   p: [8] @Integer;
   leftAtTitle: @boolean;
   t: @Text;
   (*  inheritanceEnds, *)
   connectorList: ^ObjectList;
   con: ^connector;
   node1,node2: ^PatternDiagramNode;
   abs: ^AbstractNode;
   n1,n2,p1,p2: ^DesignObject;
   theTitleNode: ^theListDiagram.title;
   dListDiagram,theListDiagram: ^ListDiagram;
   dDiagramNode: ^dListDiagram.DiagramNode;
   dNonTerminalNode: ^dListDiagram.NonTerminalNode;
   object1,object2: ^designObject
do
   (if switch[60]
    // true then 'Gpp ------- DeleteDiagramNode'->putLine; 
   if);
   d.theDiagram->dListDiagram[];
   (if d## <= dListDiagram.DiagramNode## then
       d[]->dDiagramNode[];
       dDiagramNode.theDeclaration->RemoveListElement;
       (if deletenode then
           (if dDiagramNode.CurrentDecomposDiagram <> none then
               dDiagramNode.CurrentDecomposDiagram->dListDiagram[];
               dListDiagram.titleNode.abstract
           if)
       if);
       
    else
       (if d## <= dListDiagram.NonTerminalNode## then
           d[]->dNonTerminalNode[]; dNonTerminalNode.unExp->RemoveListElement
       if)
   if);
   scanner: localnodes.scan
     (# aText: ^Text; 
     do
        (if switch[60] then
            'DeleteDiagramNode - current in scanner: '->puttext;
            current.theText.get->t;
            t[]->putline;
            
        if);
        (if current[]
         // d[] then
            d.geometry->(x,y,w,h);
            (if deleteNode
             // true then
                d.delete;
                (* ESS: was outside the if:
                 *)
                true->deleted;
                
            if);
            (if switch[60]
             // true then
                (if deleteNode
                 // true then
                    'DeleteDiagramNode: element found and deleted'
                      ->screen.putline;
                    
                 else
                    'DeleteDiagramNode: element found but not deleted'
                      ->screen.putline;
                    
                if)
            if);
            titlenode.center->(tx,ty);
            current[]->abs[]
         else
            (if deleted
             // true then (* move the rest *)
                current.center->(x,y);
                current[]->abs[];
                (x,y-gppProp.height)->abs.center;
                (if switch[60]
                 // true then
                    'DeleteDiagramNode - element moved: '->puttext;
                    current.theText.get->t;
                    t[]->putline;
                    
                if);
                
            if)
        if)
     #);
   (if switch[60] then 'DeleteDiagramNode end of scanner'->putline if);
   d[]->localnodes.at->localnodes.delete;
   0->MaxWidth;
   0->MaxHeight;
   titleNode[]->updateMaxWH;
   localNodes.scan
     (#  do current[]->updateMaxWH #);
   localNodes.adjustSizes;
   
#)  

-- ReplaceDiagramNode: Descriptor --
(#
   x,y,w,h: @Integer;
   startPos: @point;
   insertAfterPos,insertBeforePos,thePos: ^localnodes.theCellType;
   IsDynamic:
     (#
        yes: @Boolean;
        anAST: ^MPS.AST;
        decl: ^betaGram.SimpleDecl;
        theSpec: ^betaGram.ReferenceSpecification;
        
     enter anAST[]
     do
        (if anAST## <= betagram.SimpleDecl## then
            anAST[]->decl[];
            decl.GetReferenceSpecification->anAST[];
            (if anAST## <= betagram.ReferenceSpecification## then
                anAST[]->theSpec[];
                (if theSpec.symbol
                 // betaGram.dynamicItem // betaGram.dynamicComponent then
                    true->yes; 
                if)
             else
                (if switch[60] then
                    'Freja-- OOBS: anAST## <= betagram.ReferenceSpecification## failed'
                      ->screen.putline
                if);
                
            if)
         else
            'Freja-- OOBS: anAST## <= betagram.SimpleDecl## failed'
              ->screen.putline;
            
        if);
        
     exit yes
     #);
   aText: @Text;
   connectorList (* ,inheritanceEnds *) : ^ObjectList;
   con: ^Connector;
   node1,node2: ^PatternDiagramNode;
   n1,n2,p1,p2: ^DesignObject;
   theTitleNode: ^theListDiagram.title;
   dListDiagram,theListDiagram: ^ListDiagram;
   dAbstractNode: ^dListDiagram.AbstractNode;
   theSimpleNode: ^SimpleNode;
   object1,object2: ^designObject;
   
do
   (if switch[60]
    // true then
       'Gpp ------- ReplaceDiagramNode: '->putText;
       newAST.Index->putInt;
       newLine;
       newAST.dump;
       newLine;
       
   if);
   d.theDiagram->dListDiagram[];
   (if d## <= dListDiagram.AbstractNode## then
       d[]->dAbstractNode[];
       (if dAbstractNode.CurrentDecomposDiagram <> none then
           dAbstractNode.CurrentDecomposDiagram->dListDiagram[];
           dListDiagram.titleNode.abstract
       if)
   if);
   true->remakingDiagram;
   scanner: localnodes.scan
     (# 
     do
        (if switch[60] then
            'ReplaceDiagramNode - examining: '->puttext;
            current.theText.get->aText;
            aText[]->putline
        if);
        (if current[]
         // d[] then
            (if switch[60] then
                'ReplaceDiagramNode - addAfterNode: '->puttext;
                current.theText.get->aText;
                aText[]->putline
            if);
            current[]->PatternDiagrams.addAfterNode[];
            PatternDiagrams.addAfterNode[]->localNodes.at->thePos[];
            (if thePos.pred[] <> none then
                thePos.pred[]->insertAfterPos[]
             else
                (if thePos.succ[] <> none then
                    thePos.succ[]->insertBeforePos[]
                if)
            if);
            d.geometry->(x,y,w,h);
            (if ongoingTextediting then
                (dAbstractNode.theText.oldWidth,dAbstractNode.theText.oldHeight)
                  ->(w,h)
            if);
            (x-(w div 2),y-(h div 2))->startPos;
            (newAST[],startpos)->DisplayAST->startpos;
            (if patternDiagrams.newNode[] = none then
                'OOBS: newNode is NONE'->screen.putline
             else
                
            if);
            d.delete;
            (if newAst.kind
             // mps.kinds.interior then
                (if newAST.symbol
                 // betaGram.SimpleDecl then
                    (if newAST[]->IsDynamic // true then  if); 
                if)
            if);
            leave scanner;
            
        if)
     #);
   (if PatternDiagrams.newNode[]
    // none then 'OOBS: newNode is NONE'->screen.putline; 
    else
       (if insertAfterPos[] <> none then
           (PatternDiagrams.newNode[],insertAfterPos[])->localNodes.insertAfter
        else
           (if insertBeforePos[] <> none then
               (PatternDiagrams.newNode[],insertBeforePos[])
                 ->localNodes.insertBefore
            else
               PatternDiagrams.newNode[]->localNodes.append
           if)
       if);
       
   if);
   none ->PatternDiagrams.addAfterNode[];
   false->remakingDiagram;
   0->MaxWidth;
   0->MaxHeight;
   titleNode[]->updateMaxWH;
   localNodes.scan
     (#  do current[]->updateMaxWH #);
   localNodes.adjustSizes;
   
#)  

-- UpdateDiagramNode: Descriptor --
(#
   thePatternDiagramNode: ^PatternDiagramNode;
   theFragmentNode: ^FragmentNode;
   theNode,theNode2: ^DiagramNode;
   theAbstractNode: ^AbstractNode;
   theNonTerminalNode: ^NonTerminalNode;
   testNode: ^IdObject;
   aDeclaration: ^betaGram.AttributeDecl;
   anAST,keepOldAST,keepNewAST: ^mps.ast;
   anExp: ^mps.expanded;
   theNames: ^betaGram.Names;
   theDecomposDiagram: ^Diagram;
   theSimpleNode: ^SimpleNode;
   syncatNo: @integer;
   updateName:
     (#
        theNewNameDcl,theOldNameDcl: ^betaGram.NameDcl;
        theNewNameDecl,theOldNameDecl: ^mps.namedecl;
        oldText,newText: ^text;
        doUpdate: @Boolean;
        aPatternDiagram: ^PatternDiagram;
        theNewAST,theOldAST: ^MPS.AST;
        oldX,oldY,oldWidth,oldHeight,x,y,w,h,newX: @integer;
        theRegionList: ^ObjectList
     do
        (if theNode.currentDecomposDiagram <> none
        (*Update name in titlenode of detailed*) then
            anAST[]->theNewNameDcl[];
            theNewNameDcl.getSon1->theNewAST[];
            (if theNewAST.kind = mps.kinds.unexpanded then
                '<<NameDecl>>'->newText[]
             else
                theNewAST[]->theNewNameDecl[]; theNewNameDecl.getText->newText[]
            if);
            (if oldAST.symbol = betaGram.NameDcl then
                oldAST[]->theOldNameDcl[];
                theOldNameDcl.getSon1->theOldAST[];
                (if theOldAST.kind = mps.kinds.unexpanded then
                    '<<NameDecl>>'->oldText[]
                 else
                    theOldAST[]->theOldNameDecl[];
                    theOldNameDecl.getText->oldText[]
                if);
                (if oldText[]->newText.equal then
                    (if switch[60] then
                        'UpdateDiagramNode: old name is equal to new name!'
                          ->putline
                    if)
                 else
                    true->doUpdate
                if)
             else
                true->doUpdate
            if);
            (if doUpdate then
                theNode.currentDecomposDiagram->aPatternDiagram[];
                newText->aPatternDiagram.titleText
                  ->aPatternDiagram.titleNode.theText.set;
                aPatternDiagram.titleNode[]->aPatternDiagram.updateMaxWH;
                aPatternDiagram.localNodes.adjustsizes;
                (if switch[60] then
                    'UpdateDiagramNode: name updated in detailed is '->puttext;
                    (theNode.currentDecomposDiagram).titleText[]->putline
                if)
             else
                (if switch[60] then
                    'UpdateDiagramNode: doUpdate is false'->putline
                if)
            if)
         else
            (if switch[60] then
                'UpdateDiagramNode: currentDecomposDiagram is none'->putline
            if)
        if)
     #);
   
do
   (if switch[60]
    // true then
       'Gpp ------- UpdateDiagramNode: '->putText;
       oldAST.Index->putInt;
       newLine;
       
   if);
   oldAST[]->keepOldAST[];
   newAST[]->keepNewAST[];
   search:
   (if oldAST[]
    // none then
       'Gpp ------- UpdateDiagramNode: node not found: '->stderr.putText;
       oldAST.Index->stderr.putInt;
       stderr.newLine;
       
    else
   (*(oldAST.index,newAST.index)->IndexIDList.update->testNode[];*)
       (oldAST[],newAST[])->ASTtoNodeListUpdate->thePatternDiagramNode[];
       (if thePatternDiagramNode[] <> none then
           (if thePatternDiagramNode## <= NonTerminalNode## then
               thePatternDiagramNode[]->theNonTerminalNode[];
               newAST[]->theNonTerminalNode.redisplay
            else
               (if thePatternDiagramNode## <= FragmentNode## then
                   thePatternDiagramNode[]->theFragmentNode[];
                   newAST.frag[]->theFragmentNode.redisplay
                else
                   (if thePatternDiagramNode## <= DiagramNode## then
                       thePatternDiagramNode[]->theNode[]
                   if)
               if)
           if)
        else
           thePatternDiagramNode[]->theNode[]
       if);
       (if theNonTerminalNode[] = none then
           testRedisplay:
           (if theNode[]
            // none then
               (if switch[60] then
                   'Calling redisplay - internal part of declaration was expanded'
                     ->putline
               if);
               getDecl:
               (if (keepNewAST## <= betaGram.attributeDecl##) or
               (keepNewAST[]->keepNewAST.frag.root.equal) then
                   
                else
                   keepNewAST.father->keepNewAST[]; restart getDecl
               if);
               (if keepNewAST## <= betaGram.attributeDecl## then
                   keepNewAST[]->anExp[];
                   anExp.getSon1->theNames[];
                   theNames.newScan
                     (#  do current[]->anAST[] #);
                   keepNewAST[]->ASTtoNode->theNode[];
                   (if theNode[] <> none then
                       newAST[]->getSyncatNo->syncatNo;
                       (if (syncatNo = gram.NameDcl) or
                       (syncatNo = gram.prefix) or (syncatNo = gram.prefixOpt)
                       or (newAST.kind = mps.kinds.NameAppl) or
                       (newAST.kind = mps.kinds.NameDecl) then
                           
                        else
                           (if theNode.CurrentDecomposDiagram <> none then
                               theNode.CurrentDecomposDiagram
                                 ->theDecomposDiagram[];
                               theDecomposDiagram.titleNode.abstract
                           if)
                       if);
                       updateName;
                       (keepNewAST[],anAST[])->theNode.Redisplay
                    else
                       (if switch[60] then
                           'Surrounding declaration not present in IndexIDList??'
                             ->putline
                       if)
                   if)
                else
                   (if switch[60] then
                       'No part of a declaration was changed - no redisplay is done'
                         ->putline
                   if);
                   (if (oldAST.kind = mps.kinds.optional) and
                   (newAST.kind = mps.kinds.unexpanded) then
                       (if switch[60] then
                           'Show optionals was performed on outermost descriptor'
                             ->putline
                       if)
                    else
                       keepNewAST[]->ASTtoNode->theAbstractNode[];
                       (if theAbstractNode[] <> none then
                           theAbstractNode.abstract
                        else
                           'Could not find fragmentNode in IndexIDList!?'
                             ->stdErr.putline
                       if)
                   if)
               if);
               ;
               
            else
               (if keepNewAST.symbol
                // betaGram.nameDcl then
                   (if switch[60]
                    // true then '  it is a nameDcl'->putLine; 
                   if);
                   keepNewAST.father->anAST[];
                   anAST.father->aDeclaration[];
                   keepNewAST[]->anAST[];
                   
                else
                   (if (keepNewAST## <= betaGram.attributeDecl##)
                    // true then
                       (if switch[60]
                        // true then
                           '  it is a declaration: '->putText;
                           keepNewAST.symbol->putInt;
                           newLine;
                           
                       if);
                       (if theNode.CurrentDecomposDiagram <> none then
                           theNode.CurrentDecomposDiagram->theDecomposDiagram[];
                           theDecomposDiagram.titleNode.abstract
                       if);
                       keepNewAST[]->aDeclaration[];
                       aDeclaration.getson1->anExp[];
                       anExp.getson1->anAST[];
                       
                    else
                       (if switch[60]
                        // true then
                           'not namedcl or attributeDecl: '->putText;
                           newAST.symbol->putInt;
                           newLine;
                           
                       if);
                       leave testRedisplay;
                       
                   if);
                   
               if);
               (if switch[60]
                // true then
                (* keepNewAST.dump;
                 newline;
                 (if aDeclaration[]
                 // none then
                 else
                 aDeclaration.dump; newline;
                 if); *)
                   
               if);
               updateName;
               (aDeclaration[],anAST[])->theNode.redisplay;
               
           if)
       if);
       (*(if testNode[]
        // none then
        else
        (if true
        // testNode## <= PatternDiagramNode## then
        testNode[]->theNode[]
        else
        'It is not a PatternDiagramNode!!'->putLine;
        if);
        if);
        * *)
       
   if);
   localNodes.adjustSizes
#)  

-- ListDiagramOnInit: Descriptor --
(# 
do
   UDPrivate.UDListDiagram->UserDataInit;
   UDtheSurroundBox.init;
   UDdetailPage.Init;
   UDNoOfRefConnectors.Init;
   UDMaxHeight.init;
   UDMaxWidth.init;
   (if not initialisingSaved then
       THIS(ListDiagram)[]->theDiagram; geometry->(x,y,w,h); 
   if);
   
#)  

-- ListDiagramOnRemove: Descriptor --
(#
   theParent: ^PatternDiagramNode;
   theNode: ^PatternDiagramNode;
   theListDiagram: ^ListDiagram;
   theFragNode: ^theListDiagram.FragmentNode;
   connectors,regions: ^objectList
do (* tell the parent node that it is no longer detailed *)
   (if switch[30] then
       'title: onRemove callback on '->puttext; ID->putint; newline
   if);
   (if theParentNode <> none
    // true then
       theParentNode->theParent[]; theParent.abstractedFromDiagramBelow
    else
       (if theFragmentNode <> none then
           theFragmentNode->theNode[];
           theNode.theDiagram->theListDiagram[];
           theNode[]->theFragNode[];
           none ->theFragNode.currentDecomposDiagram
       if)
   if);
   getConnectors->connectors[];
   (if connectors[] <> none then
       connectors.scan
         (#
            theConn: ^deletableConnector;
            theListDiagram: ^ListDiagram;
            thePatternDeclDiagram: ^PatternDeclDiagram;
            theSimpleNode: ^theListDiagram.SimpleNode;
            theDiagramNode: ^theListDiagram.DiagramNode;
            thePatternNode: ^theListDiagram.PatternNode;
            theObject: ^DesignObject;
            theNode: ^PatternDiagramNode
         do
            (if current## <= deletableConnector## then
                current[]->theConn[];
                THIS(title)[]->theConn.getOtherEnd->theObject[];
                (if theObject[] = none then
                    theSurroundBox->theConn.getOtherEnd->theObject[]
                if);
                (if theObject[] <> none then
                    theObject[]->BoxToNode->theObject[];
                    (if theObject## <= PatternDiagramNode## then
                        theObject[]->theNode[];
                        theNode.theDiagram->theListDiagram[];
                        (if current## <= PrefixConnector## then
                            (if current[] =
                            theListDiagram.titleNode.thePrefixConn then
                                theListDiagram[]->thePatternDeclDiagram[];
                                none ->thePatternDeclDiagram.thePrefix;
                                none ->theListDiagram.titleNode.thePrefixConn;
                                theListDiagram.titleNode.unmakeRegion;
                                theListDiagram.theParentNode->theNode[];
                                theNode.theDiagram->theListDiagram[];
                                theNode[]->theDiagramNode[];
                                none ->theDiagramNode.thePrefix
                            if)
                        if)
                    if)
                if)
            if)
         #)
   if);
   getRegionList->regions[];
   (if regions[] <> none then
       regions.scan
         (# theNode: ^UserDataNode
         do
            (if (not (current## <= PatternDiagramNode##)) and
            (current## <= UserDataNode##) then
                current[]->theNode[];
                theNode.getConnectors->connectors[];
                (if connectors[] <> none then
                    connectors.scan
                      (#
                         theAggregationConnector: ^AggregationConnector;
                         theListDiagram: ^ListDiagram;
                         theSimpleNode: ^theListDiagram.SimpleAttributeDecl;
                         left,right: ^theAggregationConnector.Role
                      do
                         (if current## <= AggregationConnector## then
                             current[]->theAggregationConnector[];
                             (if theNode## <= theAggregationConnector.Role##
                              then
                                 (
                                 (theAggregationConnector.leftRole->theAggregationConnector.lr[]).
                                 thePatternDiagramNode).theDiagram
                                   ->theListDiagram[];
                                 (theAggregationConnector.leftRole->theAggregationConnector.lr[]).
                                 thePatternDiagramNode->theSimpleNode[];
                                 none ->theSimpleNode.theAggregationConnector;
                                 theAggregationConnector.leftRole->theAggregationConnector.lr[]->left[];
                                 theAggregationConnector.rightRole->right[];
                                 left.delete;
                                 right.delete
                              else
                                 'AggregationConnector '->stdErr.puttext;
                                 theAggregationConnector.id->stdErr.putint;
                                 ' with non-role end '->stdErr.puttext;
                                 theNode.id->stdErr.putint;
                                 stderr.newline
                             if)
                         if)
                      #)
                if)
            if)
         #)
   if);
   
#)  

-- ListDiagramOnDoubleClick: Descriptor --
(# 
do (*  localNodes.abstractAll;
    False->proceed; *) (*don't let design/OA proceed in normal way*) 
#)  

-- ListDiagramAbstract: Descriptor --
(#
   connectorList: ^ObjectList;
   theNode: ^PatternDiagramNode;
   theListDiagram: ^ListDiagram
do
   (if switch[70] // true then 'title abstract all my nodes'->putline if);
   localNodes.abstractAll;
   (if theParentNode <> none then
       theParentNode->theNode[];
       theNode.theDiagram->theListDiagram[];
       (if theNode## <= theListDiagram.PatternNode## then
           getConnectors->connectorList[];
           (if connectorList[] <> none then
               connectorList.scan
                 (# theConn: ^AggregationConnector; x,y,w,h: @integer
                 do
                    (if current## <= AggregationConnector## then
                        current[]->theConn[];
                        (if not gppProp.showAttributes then
                            false->theConn.visible
                        if);
                        (theConn.rightRole->theConn.rr[]).unmakeRegion;
                        (theParentNode).geometry->(x,y,w,h);
                        (x-w div 2,y)->(theConn.rightRole->theConn.rr[]).center;
                        theParentNode
                          ->(theConn.rightRole->theConn.rr[]).thePatternDiagramNode;
                        theParentNode->(theConn.rightRole->theConn.rr[]).createRegion
                    if)
                 #)
           if)
       if)
   if);
   Delete;
   
#)  

-- ListDiagramAbstractRecursively: DoPart --
do localNodes.scan (#  do current.abstract #); INNER abstractRecursively  

-- ListDiagramDetail: Descriptor --
(# lnode: ^PatternDiagramNode; lastNode: ^AbstractNode; 
do
   (if switch[60]
    // true then 'title detail all attribute decls...'->putline; 
   if);
   false->doScrollIntoView;
   localNodes.scan
     (#  do current.detail; current[]->lnode[] #);
   true->doScrollIntoView;
   (if lnode[] <> none then
       (if (*could be a SlotNode*) lnode## <= AbstractNode## then
           lnode[]->lastNode[];
           (if lastNode.currentDecomposDiagram <> none then
               (lastNode.currentDecomPosdiagram).titleNode[]
                 ->THIS(OADPage).scrollIntoView;
               
            else
               'lastNode.currentDecomposDiagram is NONE'->screen.putline; 
           if)
       if)
   if);
   
#)  

-- ListDiagramDetailRecursively: DoPart --
do
   false->doScrollIntoView;
   localNodes.scan
     (# theAbstractNode: ^AbstractNode
     do
        current.detail;
        (if current## <= AbstractNode## then
            current[]->theAbstractNode[];
            (if theAbstractNode.currentDecomposDiagram <> none then
                (theAbstractNode.currentDecomposDiagram).titleNode.
                  detailRecursively
            if)
        if)
     #);
   true->doScrollIntoView;
   INNER detailRecursively;
     

-- ListDiagramOverview: DoPart --
do
     (# theListDiagram: ^ListDiagram
     do
        (if theParentNode <> none then
            (theParentNode).theDiagram->theListDiagram[];
            theListDiagram.localNodes.scan
              (# 
              do (if current[] <> theParentNode then current.abstract if)
              #)
        if)
     #);
   INNER overview  

-- updateMaxWH: Descriptor --
(# w,h,origX,origY,origW,origH: @integer
do
   thePatternDiagramNode.geometry->(origX,origY,origW,origH);
   false->thePatternDiagramNode.theText.wrap;
   thePatternDiagramNode.FitToText;
   thePatternDiagramNode.size->(w,h);
   (w,MaxWidth)->max->MaxWidth;
   (h,MaxHeight)->max->MaxHeight;
   (GppProp.width,MaxWidth)->max->MaxWidth;
   (GppProp.height,MaxHeight)->max->MaxHeight;
   (origX,origY,origW,origH)->thePatternDiagramNode.geometry;
   true->thePatternDiagramNode.theText.wrap;
   (if thePatternDiagramNode[] = titleNode[] then
       textJust.Centered->thePatternDiagramNode.theText.just
   if)
#)  

-- OADDiagramNew: Descriptor --
(# theDummyDesc: ^betaGram.ObjectDescriptor
do
(* save THIS(OADDiagram) with the ASTindex of the  
 * descriptor it is generated from so it can be located later
 *)
   (if theDescriptor <> none
    // true then
       theDescriptor->theDummyDesc[];
       (theDummyDesc.index,theDummyDesc.frag.fullname,THIS(OADDiagram)[])
         ->PatternDiagrams.theList.insertPD;
       (* titleNode.ConcludeDisplay; *)
       
   if);
   titleNode.concludeDisplay;
   
#)  

-- OADDisplayDeclarations: Descriptor --
(# x,y,w,h: @Integer; 
do
   (if theAttributes[]
    // none then (* it is a non-terminal: display it as such *)
       'DisplayDeclarations: ATTRIBUTES IS NONE'->putline; 
    else
   (* (if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
    [* first display simple declarations like references (static and dynamic)
    * then display pattern and virtual declarations;
    *]
    titleNode.geometry->(x,y,w,h);
    x->startpos.x;
    startpos.y+(2*gppProp.DownOnPage)->startpos.y;
    
    if); *)
       theAttributes.scan
         (# 
         do
            (if not (current.kind = mps.kinds.optional) then
                (current[],startpos)->DisplayAST->startpos
            if)
         #);
       LocalNodes.adjustSizes
   if)
#)  

-- OADDiagramOnRemove: Descriptor --
(# theDummyDesc: ^betaGram.ObjectDescriptor
do (* remove the diagram from the list of patterndiagrams on the page *)
   (if theDescriptor <> none
    // true then
       theDescriptor->theDummyDesc[];
       (*if this is the last diagram on the page close the page *)
       (theDummyDesc.index,theDummyDesc.frag.fullname)
         ->PatternDiagrams.theList.deletePD;
       (if PatternDiagrams.theList.size
        // 0 then
           theFragmentNode
             ->theGroupPage.currentObject (#  do true->autoPan #);
           true->theGroupPage.visible;
           close
       if);
       
   if);
   
#)  

-- OADDisplay: Descriptor --
(#
   p: ^localNodes.theCellType;
   e: ^LocalNodes.element;
   det: ^AbstractNode;
   x,y,w,h,tx,ty,tw,th: @Integer;
   theDummyDesc: ^betaGram.ObjectDescriptor;
   theBox: ^SurroundBox
do
   (if theDescriptor
    // none then
       (if switch[60] // true then 'theDescriptor is NONE '->puttext if); 
   if);
   CalculateNextCenter->theCenter;
   (if theDescriptor <> none
    // true then
       theDescriptor->theDummyDesc[];
       theDummyDesc.index->titleNode.astIndex;
       (if switch[60] then
           'OADDisplay: '->putText;
           titleNode.astIndex->putInt;
           '->astIndex'->putLine
       if);
       
   if);
   INNER Display;
   &SurroundBox[]->theBox[];
   (if gppProp.DiagramPositioning
    // gppProp.AllManual then
       cursor.Picture->cursor.set;
       THIS(OADDiagram)[]->patternDiagrams.interactiveNewDiagram[]
    // gppProp.AllAuto then
       (if switch[70] then
           '******** diagrambody-OADDisplay 4 calling new with ********'
             ->putline;
           'x: '->putText;
           theCenter.x->putint;
           newLine;
           'y: '->putText;
           theCenter.y->putint;
           newLine;
           'w: '->putText;
           gppProp.titlewidth->putint;
           newLine;
           'h: '->putText;
           gppProp.height*2->putint;
           newLine;
           
       if);
       (theCenter.x,theCenter.y,gppProp.titlewidth*2,gppProp.height,
        shape.Rectangle)->theBox.new;
       theBox[]->theSurroundBox;
       (theCenter.x,theCenter.y,gppProp.titlewidth*2,gppProp.height,
        titleNode.defaultShape)->titleNode.new
    else
       'OADDisplay: No DiagramPositioning mode?!'->putline
   if);
   titleNode.geometry->(tx,ty,tw,th);
   (if localNodes.empty or (not gppProp.showAttributes) then
       (tx,ty,tw,th)->theBox.geometry
    else
       (tx,ty-gppProp.height div 2+((localNodes.size+1)*gppProp.height) div 2,
        tw,(localNodes.size+1)*gppProp.height)->theBox.geometry
   if);
   titleNode[]->theBox.CreateRegion;
   (*(if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
    (if localNodes.empty
    // true then (theCenter,titleNode.Center)->UpdateNextFree; 
    else
    (#
    pos1,pos2: @Point;
    x,y,w,h,dist: @Integer;
    no: @Integer;
    lastSimple, [* last node in simple pattern diagram *] firstTree,
    [* first node in tree pattern diagram *] lastTree: [* last node in tree pattern diagram *] ^PatternDiagramNode;
    
    do
    (if localNodes.empty
    // false then [* update for the next diagram *]
    localNodes.last->p[]; p.elm[]->e[]; e.Center->pos1; 
    else
    titleNode.Center->pos1; 
    if);
    pos1.x+gppProp.DownOnPage->pos1.x;
    (theCenter,pos1)->UpdateNextFree;
    titleNode[]->lastSimple[];
    localNodes.scan [* count the nodes in tree position *]
    (# d: ^DiagramNode; 
    do
    (if current## <= DiagramNode##
    // true then
    current[]->d[];
    (if d.theTreeConn[]
    // none then current[]->lastSimple[]; [* in simple diagram *]
    else
    (if firstTree[]
    // none then current[]->firstTree[]
    if);
    current[]->lastTree[];
    no+1->no;
    
    if)
    if)
    #);
    (if true [* calculate adjustment *]
    // (no > 1) then [* adjust them *]
    firstTree.Center->pos1;
    lastTree.Center->pos2;
    (pos2.x-pos1.x) div 2->dist;
    lastSimple.Center->pos2;
    dist-(pos2.x-pos1.x)->dist;
    
    // (no = 1) then [* center the one *]
    lastSimple.center->pos1;
    localNodes.last->p[];
    p.elm[]->e[];
    e.Center->pos2;
    pos2.x-pos1.x->dist;
    
    else
    [* no subnodes in tree *]
    
    if);
    localNodes.scan [* adjust the subnodes *]
    (# d: ^DiagramNode; 
    do
    (if current## <= DiagramNode##
    // true then
    current[]->d[];
    (if d.theTreeConn[]
    // none then [* in simple pattern diagram *] (0,0)
    ->
    current.
    ConcludeDisplay;
    
    else
    [* in tree *]
    (dist,0)->current.ConcludeDisplay; 
    if)
    if)
    #)
    #)
    if);
    
    else
    [* just make a simple patterndiagram of all the nodes
    * update NextFreeLine to the y coordinate of the last node in
    * plus offset *]
    (if localNodes.empty
    // true then (theCenter,titleNode.Center)->UpdateNextFree; 
    else
    localNodes.scan
    (#  do (0,0)->current.ConcludeDisplay #);
    localNodes.Last->p[];
    p.elm[]->e[];
    (theCenter,e.Center)->UpdateNextFree
    if)
    if);*)
   (*(if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
    (if PatternDiagrams.Detailer[] <> none
    // true then
    PatternDiagrams.Detailer[]->det[];
    (if det.theTreeConn[]
    // none then
    [* the Detailer is part of a blockDiagram and not a tree *]
    (if switch[18] then
    '******** diagrambody-OADDisplay 1 calling new with ********'
    ->putline;
    'x: '->putText;
    theCenter.x->putint;
    newLine;
    'y: '->putText;
    theCenter.y->putint;
    newLine;
    'w: '->putText;
    gppProp.titlewidth->putint;
    newLine;
    'h: '->putText;
    gppProp.height*2->putint;
    newLine;
    
    if);
    (theCenter.x,theCenter.y,gppProp.titlewidth,gppProp.height*2,
    titleNode.defaultShape)->titleNode.new;
    
    else
    [* the new diagram is connected to an existing tree diagram *]
    PatternDiagrams.Detailer.geometry->(x,y,w,h);
    (if switch[18] then
    '******** diagrambody-OADDisplay 2 calling new with ********'
    ->putline;
    'x: '->putText;
    x->putint;
    newLine;
    'y: '->putText;
    y->putint;
    newLine;
    'w: '->putText;
    w->putint;
    newLine;
    'h: '->putText;
    h->putint;
    newLine;
    
    if);
    (x,y,w,h,titleNode.defaultShape)->titleNode.new;
    PatternDiagrams.Detailer[]->titleNode.CreateRegion;
    true->PatternDiagrams.Detailer.moveable;
    false->titleNode.selectable;
    false->titleNode.borderVisible;
    titleNode.theText.clear;
    PatternDiagrams.Detailer[]->CurrentObject;
    
    if);
    
    else
    (if switch[18] then
    '******** diagrambody-OADDisplay 3 calling new with ********'
    ->putline;
    'x: '->putText;
    theCenter.x->putint;
    newLine;
    'y: '->putText;
    theCenter.y->putint;
    newLine;
    'w: '->putText;
    gppProp.titlewidth->putint;
    newLine;
    'h: '->putText;
    gppProp.height*2->putint;
    newLine;
    
    if);
    (theCenter.x,theCenter.y,gppProp.titlewidth,gppProp.height*2,
    titleNode.defaultShape)->titleNode.new;
    
    if);
    
    else
    (if switch[18] then
    '******** diagrambody-OADDisplay 4 calling new with ********'->putline;
    'x: '->putText;
    theCenter.x->putint;
    newLine;
    'y: '->putText;
    theCenter.y->putint;
    newLine;
    'w: '->putText;
    gppProp.titlewidth->putint;
    newLine;
    'h: '->putText;
    gppProp.height*2->putint;
    newLine;
    
    if);
    (theCenter.x,theCenter.y,gppProp.titlewidth*2,gppProp.height,
    titleNode.defaultShape)->titleNode.new;
    
    if); *)
   (* now we can make the diagram: titleNode.new, calls onInit as callback
    * which then calls DisplayDeclarations to display the contaning decls.
    *)
   (* Now we make final adjustment (we must know the number of subnodes
    * before we can do this).
    * 
    * If we make trees then we must adjust the localNodes so they
    * are centered
    *)
   (* (if localNodes.empty
    // true then (theCenter,titleNode.Center)->UpdateNextFree; 
    else
    localNodes.scan
    (#  do (0,0)->current.ConcludeDisplay #);
    localNodes.Last->p[];
    p.elm[]->e[];
    (theCenter,e.Center)->UpdateNextFree
    if)*)
   
#)
(* FRAGMENTDIAGRAMS *)  

-- PatternAttDiagramDisplay: Descriptor --
(#  do (if theAST <> none then (theAST).index->titleNode.astIndex if) #)  

-- FragmentDiagramNew: Descriptor --
(#
   w,h: @Integer;
   groupTitle: ^PatternDiagramNode;
   e: ^LocalNodes.element;
   p: ^Localnodes.theCellType;
   theDummyGroup: ^mps.fragmentgroup
do
   theGroup->theDummyGroup[];
   theDummyGroup.name->mps.ExpandToFullPath->fullname;
   INNER New;
   PatternDiagrams.theList.scanPropertyDiagrams
     (# 
     do
        (if thisDiagram.theGroup
         // theGroup then
            (if thisDiagram.localNodes.empty
             // false then
                thisDiagram.localnodes.last->p[];
                p.elm[]->e[];
                e.geometry->(x,y,w,h);
                
             else
                thisDiagram.titleNode.geometry->(x,y,w,h); 
            if);
            thisDiagram.titleNode[]->groupTitle[];
            
        if);
        
     #);
   y+gppProp.DownOnPage->y;
   (* CalculateNextCenter -> (x,y); *)
   x-(w div 2)+(gppProp.titlewidth div 2)->x;
   (if switch[70] then
       '******** diagrambody-FragmentDiagramNew: calling new with ********'
         ->putline;
       'x: '->putText;
       x->putint;
       newLine;
       'y: '->putText;
       y->putint;
       newLine;
       'w: '->putText;
       gppProp.titlewidth->putint;
       newLine;
       'h: '->putText;
       gppProp.height->putint;
       newLine;
       
   if);
   (x,y,gppProp.titlewidth,gppProp.height,titleNode.defaultShape)
     ->titleNode.new;
   groupTitle[]->titleNode.CreateRegion;
   (0,none ,THIS(FragmentDiagram)[])->PatternDiagrams.theList.insertPD;
   
#)  

-- FragmentDiagramTitleInit: Descriptor --
(# theDummyGroup: ^mps.fragmentgroup
do (* show fragments starting at low-left of the titleNode *)
   UDPrivate.UDFragmentDiagram->UserDataInit;
   UDfullname.Init;
   UDtheGroup.Init;
   gppProp.fontSize->theText.size;
   textJust.leftJustification->theText.just;
   false->BorderVisible;
   (if not initialisingSaved then
       (x-(w+1) div 2,y-((h+1) div 2))->(x,y);
       theGroup->theDummyGroup[];
       (if theDummyGroup[] <> none then
           theDummyGroup.fragmentList.scan
             (#
                f: ^mps.fragmentform;
                theRoot: ^MPS.AST;
                theNode: ^FragmentNode;
                
             do
                (if current.type
                 // mps.linkType then (* ignore *)
                    
                 // mps.groupType then
                    'Groups in groups not suported'->putline; 
                 // mps.formType then
                    current.f[]->f[];
                    f.root[]->theRoot[];
                    (if theRoot.symbol
                     // betaGram.DescriptorForm then
                        &DescriptorNode[]->theNode[]; 
                     // betaGram.AttributesForm then
                        &AttributesNode[]->theNode[]; 
                     // betaGram.DoPart then
                        &DoPartNode[]->theNode[]
                     else
                        'Other type'->stdErr.putline; 
                    if);
                    gppProp.height+y->y;
                    (if theNode[] <> none then
                        THIS(FragmentDiagram)[]->theNode.theDiagram;
                        ((x,y),current.f[])->theNode.display;
                        (0,0)->theNode.ConcludeDisplay
                    if);
                    
                if);
                
             #)
        else
           'FragmentDiagramTitleInit: theGroup is none!'->stdErr.putline
       if);
       'Fragments'->titleText;
       titletext->theText.set;
       ((x,y),(x,y))->UpdateNextFree;
       scanner: PatternDiagrams.theList.scanPropertyDiagrams
         (#
            x1,y1,w1,h1: @Integer;
            (* go find the property diagram of theGroup *)
            
         do
            (if thisDiagram.theGroup
             // theGroup then
                (thisDiagram.theSurroundBox).geometry->(x1,y1,w1,h1);
                (x+gppProp.width,y1+(h1 div 2)+((y-y1+(h1 div 2)) div 2)+1,
                 gppProp.width*2+20, (* width *) y-y1+gppProp.height)
                (* height *) ->(thisDiagram.theSurroundBox).geometry;
                leave scanner;
                
            if);
            
         #);
       0->MaxWidth;
       0->MaxHeight;
       titleNode[]->updateMaxWH;
       localNodes.scan
         (#  do current[]->updateMaxWH #);
       localNodes.adjustSizes
   if);
   
#)  

-- InsertFragmentNode: DoPart --
do
     (#
        previousNode: ^PatternDiagramNode;
        i: @Integer;
        x,y,w,h: @Integer;
        startPos: @point;
        displayNode:
          (#
             theRoot: ^MPS.AST;
             theNode: ^FragmentNode;
             dummy: ^mps.fragmentform;
             dummy2: ^mps.fragmentGroup
          do
             previousNode.geometry->(x,y,w,h);
             (x-(w+1) div 2,y-((h+1) div 2))->(x,y);
             previousNode[]->PatternDiagrams.addAfterNode[];
             (if ff.type
              // mps.linkType then (* ignore *)
                 
              // mps.groupType then
                 'Groups in groups not suported'->putline; 
              // mps.formType then
                 ff.root[]->theRoot[];
                 (if theRoot.symbol
                  // betaGram.DescriptorForm then
                     &DescriptorNode[]->theNode[]; 
                  // betaGram.AttributesForm then
                     &AttributesNode[]->theNode[]; 
                  // betaGram.DoPart then
                     &DoPartNode[]->theNode[]
                  else
                     'Other type'->putline; 
                 if);
                 gppProp.height+y->y;
                 THIS(FragmentDiagram)[]->theNode.theDiagram;
                 ((x,y),ff[])->theNode.display;
                 (0,0)->theNode.ConcludeDisplay;
                 theNode.theFragment->dummy[];
                 scanner: PatternDiagrams.theList.scanPropertyDiagrams
                   (#
                      x1,y1,w1,h1: @Integer;
                      (* go find the property diagram of theGroup *)
                      
                   do
                   (*'thisDiagram.theGroup: '->puttext;
                    (thisDiagram.theGroup).fullname->putline;
                    'ff.father: '->puttext;
                    (ff.father).fullname->putline;*)
                      thisDiagram.theGroup->dummy2[];
                      (if thisDiagram.theGroup = ff.father then
                      (* update the surroundBox of the property diagram *)
                          (thisDiagram.theSurroundBox).geometry->(x1,y1,w1,h1);
                          (x1,y1+(gppProp.height div 2),w1, (* width *) h1+
                           gppProp.height) (* height *)
                            ->(thisDiagram.theSurroundBox).geometry;
                          leave scanner;
                          
                      if);
                      
                   #);
                 
             if)
          #);
        aText: @Text;
        connectorList,inheritanceEnds: ^ObjectList;
        theTitleNode: ^theListDiagram.title;
        theListdiagram: ^ListDiagram;
        
     do
        (if switch[60]
         // true then
            'Gpp ------- InsertFragmentNode: '->putText;
            pos->putInt;
            ' '->put;
            ff.fullname->putline;
            
        if);
        1->i;
        (if pos = 0 then titleNode[]->previousNode[]; displayNode if);
        localnodes.scan
          (# aText: @Text; 
          do
             (if switch[60] then
                 'InsertDiagramNode: examening no '->puttext;
                 i->putint;
                 ' element in localnodes - '->puttext;
                 current.thetext.get->aText;
                 aText[]->putline
             if);
             (if i
              // pos then current[]->previousNode[]; displayNode
              else
                 (if (* what about this? (current[]<>aNode[]) and *) (i > pos)
                  // true then
                     (if switch[60]
                      // true then
                         'InsertDiagramNode: move down '->puttext;
                         current.theText.get->aText;
                         aText[]->putline;
                         
                     if);
                     current.center->(x,y);
                     (x,y+gppProp.height)->current.center;
                     
                 if)
             if);
             i+1->i;
             
          #);
        (if PatternDiagrams.newNode[]
         // none then 'OOBS: newNode is NONE'->screen.putline; 
         else
            (if pos <> 0 then
                (PatternDiagrams.newNode[],
                 PatternDiagrams.addAfterNode[]->localNodes.at)
                  ->localNodes.insertAfter
             else
                (if switch[60] then
                    'InsertDiagramNode - prepending in localNodes: '->puttext;
                    PatternDiagrams.newNode.theText.get->aText;
                    aText[]->putline
                if);
                PatternDiagrams.newNode[]
                  ->
                    localNodes.prepend
                    (*The new node is the topmost localNode when pos=0*)
            if);
            
        if);
        none ->PatternDiagrams.addAfterNode[];
        localNodes.adjustSizes;
        
     #)  

-- deleteFragmentNode: DoPart --
do
     (#
        dListDiagram: ^ListDiagram;
        dFragmentNode: ^dListDiagram.FragmentNode;
        x,y,w,h: @Integer;
        dx,dy: @Integer;
        t: @text;
        theGroup: ^mps.fragmentGroup
     do
        d.theDiagram->dListDiagram[];
        d[]->dFragmentNode[];
        (dFragmentNode.theFragment).father->theGroup[];
        dFragmentNode.theRoot->RemoveListElement;
        (if dFragmentNode.currentDecomposDiagram <> none then
            (dFragmentNode.currentDecomposDiagram).titleNode.abstract; 
        if);
        d.geometry->(dx,dy,w,h);
        scanner: localnodes.scan
          (# aText: ^Text; 
          do
             (if switch[60] then
                 'DeleteDiagramNode - current in scanner: '->puttext;
                 current.theText.get->t;
                 t[]->putline;
                 
             if);
             (if current[] = d[] then
                 d.delete
              else
                 current.center->(x,y);
                 (if y > dy then
                     (x,y-gppProp.height)->current.center;
                     (if switch[60]
                      // true then
                         'DeleteDiagramNode - element moved: '->puttext;
                         current.theText.get->t;
                         t[]->putline;
                         
                     if)
                 if)
             if)
          #);
        scanner: PatternDiagrams.theList.scanPropertyDiagrams
          (#
             x1,y1,w1,h1: @Integer;
             (* go find the property diagram of theGroup *)
             
          do
          (*'thisDiagram.theGroup: '->puttext;
           (thisDiagram.theGroup).fullname->putline;
           'ff.father: '->puttext;
           (ff.father).fullname->putline;*)
             (if thisDiagram.theGroup = theGroup[] then
             (* update the surroundBox of the property diagram *)
                 (thisDiagram.theSurroundBox).geometry->(x1,y1,w1,h1);
                 (x1,y1-(gppProp.height div 2),w1, (* width *) h1-
                  gppProp.height) (* height *)
                   ->(thisDiagram.theSurroundBox).geometry;
                 leave scanner;
                 
             if);
             
          #);
        (if switch[60] then 'DeleteDiagramNode end of scanner'->putline if);
        d[]->localnodes.at->localnodes.delete;
        0->MaxWidth;
        0->MaxHeight;
        titleNode[]->updateMaxWH;
        localNodes.scan
          (#  do current[]->updateMaxWH #);
        localNodes.adjustSizes;
        
     #)  

