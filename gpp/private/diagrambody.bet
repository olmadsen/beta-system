ORIGIN 'diagramattributes';
INCLUDE '~beta/sysutils/v1.4.2/objinterface'
        'gppinterfacebody';
(* switch
 * 1  = general debugging
 * 21 = IndexIDList
 * 22 = RemakePP
 * 23 = DiagramList
 *)
(* DIAGRAM *)
-- TitleInteractiveNew: Descriptor --
(#  do (w,h)->Size #)  

-- TitleOnInit: Descriptor --
(# 
do
   UDPrivate.UDDiagram->UserDataInit (*toby 1-11-94:
                                      User data initializations*) ;
   UDtheParentNode.Init;
   UDtheFragmentNode.Init;
   thePrefixConn.Init;
   theSimplePrefixConn.init;
   gppProp.fontSize->theText.size;
   bold->titleNode.theText.style;
   false->sizeable;
   INNER OnInit;
   (* titleText -> theText.set; resposibility of sub patterns *)
   
#)  

-- TitleOnSelect: Descriptor --
(# 
do
   (PatternDiagrams.oldSelection[],THIS(title)[])->changedFocus;
   THIS(title)[]->PatternDiagrams.oldSelection[];
   enableEditName;
   INNER onSelect;
   
#)
(* LISTDIAGRAM *)  

-- TitleTextModeOn: Descriptor --
(# 
do
   (if switch[1] then 'Text mode on in TitleNode'->putLine;  if);
   theText.get->theTextBefore;
   true->onGoingTextEditing;
   true->onGoingTitleEditing;
   THIS(title).geometry->(oldX,oldY,oldWidth,oldHeight);
   getRegionList->theRegionList[];
   (if theRegionList[] <> none then
       theRegionList.scan
         (# anObj: ^DesignObject do current[]->anObj[]; anObj.unmakeRegion #);
       
   if);
   (3*GppProp.titleWidth div 2,3*GppProp.height)->THIS(title).size;
   
#)  

-- TitleTextModeOff: Descriptor --
(# t: @text; theNode: ^patternDiagramNode; anExp: ^mps.expanded; 
do
   (if switch[1] then 'Text mode off in titleNode '->putLine;  if);
   theText.get->t;
   (if switch[1] then t[]->putLine;  if);
   (if not (theTextBefore[]->t.equal) then
       (thisDiagram).theParentNode->theNode[];
       (if theNode[]
        // none then 'theDeclaration is none!! '->putLine
        else
       (* theNode[]->currentObject;*)
           ((thisDiagram).theParentNode).getAstNode->anExp[];
           (theNode[],anExp.getSon1,t[])->declarationTextChanged;
           (if parseErrorOccurred then false->OKToExit else true->changed if);
           
       if)
    else
       false->ongoingTextediting; false->onGoingTitleEditing; false->parseErrorOccurred
   if);
   
#)  

-- TitleTextOnTextModeOff: DoPart --
do
     (# w,h,newX: @integer
     do
        (if changed then
            FitToText;
            THIS(title).size->(w,h);
            oldX-oldWidth div 2+((w,gppProp.titleWidth)->max) div 2->newX;
            (newX,oldY,(w,gppProp.titleWidth)->max,(h,gppProp.height)->max)->THIS(title).geometry
         else
            (oldX,oldY,oldWidth,oldHeight)->THIS(title).geometry
        if);
        (if theRegionList[] <> none then
            theRegionList.scan
              (# anObj: ^DesignObject
              do current[]->anObj[]; THIS(title)[]->anObj.createRegion
              #)
        if)
     #)  

-- TitleTextOnTextModeOn: DoPart --
do (*  theText.getLength->length;
    (0,length)->theText.SetSelection; *)
(*   (#
 t: @Text;
 TWMetaTextFromWidget: external
 (# object: @integer do 'TW_MetaTextFromWidget'->callC #);
 TextHighlight: external
 (# text: @integer enter text do 'Text_Highlight'->callC #))
 do theText.get->t; @@ t.T[1]->TextHighlight
 #)*)   

-- TitleTheSifEditor: DoPart --
do
   (if theFragmentNode <> none then
       (if se[] = none then
           theFragmentNode->fn[]; fn.theSifEditor->se[]; 
        else
           theFragmentNode->fn[]; se[]->fn.theSifEditor; 
       if);
       
    else
       'titleNode: theSifEditor: no FragmentNode'->screen.putline
   if)  

-- LocalNodesAbstractAll: Descriptor --
(# dummy: ^DiagramNode; theDiagram: ^Diagram; 
do
   (if current.struc <= DiagramNode##
    // true then
       current[]->dummy[];
       (if dummy.currentDecomposDiagram <> none
        // true then dummy.currentDecomposDiagram->theDiagram[]; theDiagram.titleNode.abstract
       if)
   if);
   (*localnodes *must* be explicitely deleted before
    their titles.
    If not their theDiagram ref. cannot be read
    in deleteDiagramNode.*)
   current.delete;
   
#)  

-- LocalNodesAdjustSizes: Descriptor --
(# tx,ty,tw,th,tleft,x,y,w,h: @integer
do
   TitleNode.geometry->(tx,ty,tw,th);
   tx-(tw div 2)->tleft;
   LocalNodes.scan
     (# 
     do
        current.geometry->(x,y,w,h);
        (tleft+(MaxWidth div 2),y,MaxWidth,GppProp.Height)->current.geometry
     #)
#)  

-- localNodesDump: DoPart --
do
   'LocalNodes:'->putline;
   scan
     (# t: @text do current.id->putint; ': '->puttext; current.theText.get->t; t[]->putline #);
   'End LocalNodes'->putline  

-- InsertDiagramNode: Descriptor --
(#
   previousNode: ^PatternDiagramNode;
   i: @Integer;
   x,y,w,h: @Integer;
   startPos: @point;
   displayNode:
     (# 
     do
        previousNode.geometry->(x,y,w,h);
        x-(w div 2)->x;
        x+gppProp.width->x;
        gppProp.width*2->w;
        previousNode[]->PatternDiagrams.addAfterNode[];
        (x-(w div 2),y-(h div 2)+gppProp.height)->startPos;
        (anAst[],startpos)->DisplayAST->startpos
     #);
   aText: @Text;
   connectorList,inheritanceEnds: ^ObjectList;
   con: ^Connector;
   prefixCon: ^theListDiagram.prefixConnector;
   node1,node2: ^PatternDiagramNode;
   n1,n2: ^DesignObject;
   theTitleNode: ^theListDiagram.title;
   theListdiagram: ^ListDiagram;
   nd1,nd2: @integerRef;
   object1,object2: ^designObject;
   wed: ^wedgeNode;
   
do
   (if switch[23]
    // true then
       'Gpp ------- InsertDiagramNode: '->putText;
       pos->putInt;
       ' '->put;
       anAst.Index->putInt;
       newLine;
       anAST.dump;
       newLine;
       
   if);
   1->i;
   true->remakingDiagram;
   (if pos = 0 then
       titleNode[]->previousNode[];
       &ObjectList[]->inheritanceEnds[];
       previousNode.getconnectors->connectorList[];
       (if connectorList[] <> none then
           connectorList.scan
             (# 
             do
                current[]->con[];
                true->con.getEnds->(n1[],n2[]);
                (if (n1## <= patternDiagramNode##) and (n2## <= patternDiagramNode##) then
                    n1[]->node1[];
                    n2[]->node2[];
                    (if (node1[] <> previousNode[]) and (node2[] = previousNode[]) then
                        node1.theDiagram->theListDiagram[];
                        (if current## <= theListDiagram.PrefixConnector## then
                            (if switch[23] then
                                'Inserting in inheritanceEnds: '->puttext; node1.id->putint; newline
                            if);
                            node1[]->inheritanceEnds.insert;
                            con.delete
                         else
                            (if switch[23] then 'It is not a prefixConnector'->putline if)
                        if)
                     else
                        (if (node2[] <> previousNode[]) and (node1[] = previousNode[]) then
                            node2.theDiagram->theListDiagram[];
                            (if current## <= theListDiagram.PrefixConnector## then
                                (if switch[23] then
                                    'Inserting in inheritanceEnds: '->puttext;
                                    node2.id->putint;
                                    newline
                                if);
                                node2[]->inheritanceEnds.insert;
                                con.delete
                             else
                                (if switch[23] then 'It is not a prefixConnector'->putline if)
                            if)
                        if)
                    if)
                if)
             #)
       if);
       displayNode
   if);
   localnodes.scan
     (# aText: @Text; 
     do
        (if switch[23] then
            'InsertDiagramNode: examening no '->puttext;
            i->putint;
            ' element in localnodes - '->puttext;
            current.thetext.get->aText;
            aText[]->putline
        if);
        (if i
         // pos then
            current[]->previousNode[];
            &ObjectList[]->inheritanceEnds[];
            (if previousNode[] = (LocalNodes.last).elm[] then
                (if switch[23] then 'Inserting as last element in localnodes'->putline if);
                previousNode.getconnectors->connectorList[];
                (if connectorList[] <> none then
                    connectorList.scan
                      (# 
                      do
                         current[]->con[];
                         true->con.getEnds->(n1[],n2[]);
                         (if (n1## <= patternDiagramNode##) and (n2## <= patternDiagramNode##) then
                             n1[]->node1[];
                             n2[]->node2[];
                             (if node1[] <> previousNode[] then
                                 node1.theDiagram->theListDiagram[];
                                 (if current## <= theListDiagram.PrefixConnector## then
                                     (if switch[23] then
                                         'Inserting in inheritanceEnds: '->puttext;
                                         node1.id->putint;
                                         newline
                                     if);
                                     node1[]->inheritanceEnds.insert;
                                     (if (con.ID,true,nd1[],nd2[])->DSRdAttrGetConnEnds then
                                         nd1->theObjectList.Find->object1[];
                                         (if object1[] <> none then
                                             (if object1## <= wedgeNode## then
                                                 object1[]->wed[]
                                              else
                                                 nd2->theObjectList.Find->object2[];
                                                 (if object2[] <> none then
                                                     (if object2## <= wedgeNode## then
                                                         object2[]->wed[]
                                                     if)
                                                 if)
                                             if)
                                         if)
                                      else
                                         'GetEnds failed connector ID: '->puttext;
                                         con.ID->putint;
                                         newline
                                     if);
                                     con.delete;
                                     (if wed[] <> none then wed.delete if)
                                  else
                                     (if switch[23] then
                                         'It is not a prefixConnector'->putline
                                     if)
                                 if)
                              else
                                 node2.theDiagram->theListDiagram[];
                                 (if current## <= theListDiagram.PrefixConnector## then
                                     (if switch[23] then
                                         'Inserting in inheritanceEnds: '->puttext;
                                         node2.id->putint;
                                         newline
                                     if);
                                     node2[]->inheritanceEnds.insert;
                                     (if (con.ID,true,nd1[],nd2[])->DSRdAttrGetConnEnds then
                                         nd1->theObjectList.Find->object1[];
                                         (if object1[] <> none then
                                             (if object1## <= wedgeNode## then
                                                 object1[]->wed[]
                                              else
                                                 nd2->theObjectList.Find->object2[];
                                                 (if object2[] <> none then
                                                     (if object2## <= wedgeNode## then
                                                         object2[]->wed[]
                                                     if)
                                                 if)
                                             if)
                                         if)
                                      else
                                         'GetEnds failed connector ID: '->puttext;
                                         con.ID->putint;
                                         newline
                                     if);
                                     con.delete;
                                     (if wed[] <> none then wed.delete if)
                                  else
                                     (if switch[23] then
                                         'It is not a prefixConnector'->putline
                                     if)
                                 if)
                             if)
                         if)
                      #)
                if)
            if);
            displayNode
         else
            (if (* what about this? (current[]<>aNode[]) and *) (i > pos)
             // true then
                (if switch[23]
                 // true then
                    'InsertDiagramNode: move down '->puttext;
                    current.theText.get->aText;
                    aText[]->putline;
                    
                if);
                current.center->(x,y);
                (x,y+gppProp.height)->current.center;
                
            if)
        if);
        i+1->i;
        
     #);
   (if PatternDiagrams.newNode[]
    // none then 'OOBS: newNode is NONE'->screen.putline; 
    else
       inheritanceEnds.scan
         (# 
         do
            current[]->node1[];
            node1.theDiagram->theListDiagram[];
            &theListDiagram.PrefixConnector[]->prefixCon[];
            (if switch[23] then
                'Creating PrefixConnector between: '->puttext;
                current.id->putint;
                ' and '->puttext;
                PatternDiagrams.newNode.id->putint;
                newline
            if);
            (current[],PatternDiagrams.newNode[])->prefixCon.prefixNew;
            current[]->theTitleNode[];
            prefixCon[]->theTitleNode.thePrefixConn
         #);
       (if pos <> 0 then
           (PatternDiagrams.newNode[],PatternDiagrams.addAfterNode[]->localNodes.at)
             ->localNodes.insertAfter
        else
           (if switch[23] then
               'InsertDiagramNode - prepending in localNodes: '->puttext;
               PatternDiagrams.newNode.theText.get->aText;
               aText[]->putline
           if);
           PatternDiagrams.newNode[]
             ->localNodes.prepend (*The new node is the topmost localNode when pos=0*)
       if);
       
   if);
   none ->PatternDiagrams.addAfterNode[];
   false->remakingDiagram;
   localNodes.adjustSizes;
   
#)  

-- DeleteDiagramNode: Descriptor --
(#
   x,y,w,h: @Integer;
   tx,ty: @Integer;
   deleted: @boolean;
   abs: ^AbstractNode;
   p: [8] @Integer;
   leftAtTitle: @boolean;
   t: @Text;
   inheritanceEnds,connectorList: ^ObjectList;
   con: ^connector;
   prefixCon: ^theListDiagram.prefixConnector;
   node1,node2: ^PatternDiagramNode;
   n1,n2: ^DesignObject;
   theTitleNode: ^theListDiagram.title;
   dListDiagram,theListDiagram: ^ListDiagram;
   dDiagramNode: ^dListDiagram.DiagramNode;
   dNonTerminalNode: ^dListDiagram.NonTerminalNode;
   nd1,nd2: @integerRef;
   object1,object2: ^designObject;
   wed: ^wedgeNode
do
   (if switch[23] // true then 'Gpp ------- DeleteDiagramNode'->putLine;  if);
   d.theDiagram->dListDiagram[];
   (if d## <= dListDiagram.DiagramNode## then
       d[]->dDiagramNode[];
       dDiagramNode.theDeclaration->RemoveListElement;
       (if deletenode then
           (if dDiagramNode.CurrentDecomposDiagram <> none then
               dDiagramNode.CurrentDecomposDiagram->dListDiagram[]; dListDiagram.titleNode.abstract
           if)
       if);
       
    else
       (if d## <= dListDiagram.NonTerminalNode## then
           d[]->dNonTerminalNode[]; dNonTerminalNode.unExp->RemoveListElement
       if)
   if);
   scanner: localnodes.scan
     (# aText: ^Text; 
     do
        (if switch[23] then
            'DeleteDiagramNode - current in scanner: '->puttext;
            current.theText.get->t;
            t[]->putline;
            
        if);
        (if current[]
         // d[] then
            &ObjectList[]->inheritanceEnds[];
            (if d[] = (LocalNodes.last).elm[] then
                (if switch[23] then 'Deleting last element in localnodes'->putline if);
                d.getconnectors->connectorList[];
                (if connectorList[] <> none then
                    connectorList.scan
                      (# 
                      do
                         current[]->con[];
                         true->con.getEnds->(n1[],n2[]);
                         (if (n1[] <> none ) and (n2[] <> none ) then
                             (if (n1## <= patternDiagramNode##) and (n2## <= patternDiagramNode##)
                              then
                                 n1[]->node1[];
                                 n2[]->node2[];
                                 (if node1[] <> d[] then
                                     node1.theDiagram->theListDiagram[];
                                     (if current## <= theListDiagram.PrefixConnector## then
                                         (if switch[23] then
                                             'Inserting in inheritanceEnds: '->puttext;
                                             node1.id->putint;
                                             newline
                                         if);
                                         node1[]->inheritanceEnds.insert;
                                         (if (con.ID,true,nd1[],nd2[])->DSRdAttrGetConnEnds then
                                             nd1->theObjectList.Find->object1[];
                                             (if object1[] <> none then
                                                 (if object1## <= wedgeNode## then
                                                     object1[]->wed[]
                                                  else
                                                     nd2->theObjectList.Find->object2[];
                                                     (if object2[] <> none then
                                                         (if object2## <= wedgeNode## then
                                                             object2[]->wed[]
                                                         if)
                                                     if)
                                                 if)
                                             if)
                                          else
                                             'GetEnds failed connector ID: '->puttext;
                                             con.ID->putint;
                                             newline
                                         if);
                                         con.delete;
                                         (if wed[] <> none then wed.delete if)
                                      else
                                         (if switch[23] then
                                             'It is not a prefixConnector'->putline
                                         if)
                                     if)
                                  else
                                     node2.theDiagram->theListDiagram[];
                                     (if current## <= theListDiagram.PrefixConnector## then
                                         (if switch[23] then
                                             'Inserting in inheritanceEnds: '->puttext;
                                             node2.id->putint;
                                             newline
                                         if);
                                         node2[]->inheritanceEnds.insert;
                                         (if (con.ID,true,nd1[],nd2[])->DSRdAttrGetConnEnds then
                                             nd1->theObjectList.Find->object1[];
                                             (if object1[] <> none then
                                                 (if object1## <= wedgeNode## then
                                                     object1[]->wed[]
                                                  else
                                                     nd2->theObjectList.Find->object2[];
                                                     (if object2[] <> none then
                                                         (if object2## <= wedgeNode## then
                                                             object2[]->wed[]
                                                         if)
                                                     if)
                                                 if)
                                             if)
                                          else
                                             'GetEnds failed connector ID: '->puttext;
                                             con.ID->putint;
                                             newline
                                         if);
                                         con.delete;
                                         (if wed[] <> none then wed.delete if)
                                      else
                                         (if switch[23] then
                                             'It is not a prefixConnector'->putline
                                         if)
                                     if)
                                 if)
                             if)
                         if)
                      #)
                if)
            if);
            d.geometry->(x,y,w,h);
            (if deleteNode
             // true then
                d.delete; (* ESS: was outside the if:
                           *) true->deleted; 
            if);
            (if switch[23]
             // true then
                (if deleteNode
                 // true then 'DeleteDiagramNode: element found and deleted'->screen.putline; 
                 else
                    'DeleteDiagramNode: element found but not deleted'->screen.putline; 
                if)
            if);
            titlenode.center->(tx,ty);
            current[]->abs[];
            (if x < tx
             // true then (abs.theTreeConn[] <> none )->leftAtTitle; leave scanner
            if);
            
         else
            (if deleted
             // true then (* move the rest *)
                current.center->(x,y);
                current[]->abs[];
                (if abs.theTreeConn[]
                 // none then (x,y-gppProp.height)->abs.center; 
                 else
                    (x-w,y)->abs.center;
                    x-w->p[5];
                    y-(gppProp.DownOnPage)->p[6];
                    y-(gppProp.DownOnPage)->p[4];
                    titleNode.center->(x,y);
                    x->p[3];
                    p->abs.theTreeConn.Points;
                    
                if);
                (if switch[23]
                 // true then
                    'DeleteDiagramNode - element moved: '->puttext;
                    current.theText.get->t;
                    t[]->putline;
                    
                if);
                
            if)
        if)
     #);
   (if switch[23] then 'DeleteDiagramNode end of scanner'->putline if);
   (if leftAtTitle
    // true then
       scanner: localNodes.scan
         (# 
         do
            (if current[]
             // d[] then leave scanner; 
             else
                current.center->(x,y);
                current[]->abs[];
                (x+w,y)->abs.center;
                x+w->p[5];
                y-(gppProp.DownOnPage)->p[6];
                y-(gppProp.DownOnPage)->p[4];
                titleNode.center->(x,y);
                x->p[3];
                p->abs.theTreeConn.Points;
                
            if);
            (if switch[23]
             // true then
                'DeleteDiagramNode - element moved (leftAtTitle=true): '->puttext;
                current.theText.get->t;
                t[]->putline;
                
            if);
            
         #)
   if);
   d[]->localnodes.at->localnodes.delete;
   (if LocalNodes.empty then
       inheritanceEnds.scan
         (# 
         do
            current[]->node1[];
            node1.theDiagram->theListDiagram[];
            &theListDiagram.PrefixConnector[]->prefixCon[];
            (current[],titleNode[])->prefixCon.prefixNew;
            current[]->theTitleNode[];
            prefixCon[]->theTitleNode.thePrefixConn
         #)
    else
       inheritanceEnds.scan
         (# 
         do
            current[]->node1[];
            node1.theDiagram->theListDiagram[];
            &theListDiagram.PrefixConnector[]->prefixCon[];
            (current[],(localNodes.last).elm[])->prefixCon.prefixNew;
            current[]->theTitleNode[];
            prefixCon[]->theTitleNode.thePrefixConn
         #)
   if);
   0->MaxWidth;
   0->MaxHeight;
   localNodes.scan
     (#  do current.FitToText; current.size->updateMaxWH #);
   localNodes.adjustSizes;
   
#)  

-- ReplaceDiagramNode: Descriptor --
(#
   x,y,w,h: @Integer;
   startPos: @point;
   insertAfterPos,insertBeforePos,thePos: ^localnodes.theCellType;
   IsDynamic:
     (#
        yes: @Boolean;
        anAST: ^MPS.AST;
        decl: ^betaGram.SimpleDecl;
        theSpec: ^betaGram.ReferenceSpecification;
        
     enter anAST[]
     do
        (if anAST## <= betagram.SimpleDecl## then
            anAST[]->decl[];
            decl.GetReferenceSpecification->anAST[];
            (if anAST## <= betagram.ReferenceSpecification## then
                anAST[]->theSpec[];
                (if theSpec.symbol
                 // betaGram.dynamicItem // betaGram.dynamicComponent then true->yes; 
                if)
             else
                (if switch[23] then
                    'Freja-- OOBS: anAST## <= betagram.ReferenceSpecification## failed'
                      ->screen.putline
                if);
                
            if)
         else
            'Freja-- OOBS: anAST## <= betagram.SimpleDecl## failed'->screen.putline; 
        if);
        
     exit yes
     #);
   aText: @Text;
   connectorList,inheritanceEnds: ^ObjectList;
   con: ^Connector;
   prefixCon: ^theListDiagram.prefixConnector;
   node1,node2: ^PatternDiagramNode;
   n1,n2: ^DesignObject;
   theTitleNode: ^theListDiagram.title;
   dListDiagram,theListDiagram: ^ListDiagram;
   dAbstractNode: ^dListDiagram.AbstractNode;
   theSimpleNode: ^SimpleNode;
   nd1,nd2: @integerRef;
   object1,object2: ^designObject;
   wed: ^wedgeNode;
   
do
   (if switch[23]
    // true then
       'Gpp ------- ReplaceDiagramNode: '->putText;
       newAST.Index->putInt;
       newLine;
       newAST.dump;
       newLine;
       
   if);
   d.theDiagram->dListDiagram[];
   (if d## <= dListDiagram.AbstractNode## then
       d[]->dAbstractNode[];
       (if dAbstractNode.CurrentDecomposDiagram <> none then
           dAbstractNode.CurrentDecomposDiagram->dListDiagram[]; dListDiagram.titleNode.abstract
       if)
   if);
   true->remakingDiagram;
   scanner: localnodes.scan
     (# 
     do
        (if switch[23] then
            'ReplaceDiagramNode - examining: '->puttext;
            current.theText.get->aText;
            aText[]->putline
        if);
        (if current[]
         // d[] then
            (if switch[23] then
                'ReplaceDiagramNode - addAfterNode: '->puttext;
                current.theText.get->aText;
                aText[]->putline
            if);
            current[]->PatternDiagrams.addAfterNode[];
            PatternDiagrams.addAfterNode[]->localNodes.at->thePos[];
            (if thePos.pred[] <> none then
                thePos.pred[]->insertAfterPos[]
             else
                (if thePos.succ[] <> none then thePos.succ[]->insertBeforePos[] if)
            if);
            &ObjectList[]->inheritanceEnds[];
            (if d[] = (LocalNodes.last).elm[] then
                (if switch[23] then 'Replacing last element in localnodes'->putline if);
                d.getconnectors->connectorList[];
                (if connectorList[] <> none then
                    connectorList.scan
                      (# 
                      do
                         current[]->con[];
                         true->con.getEnds->(n1[],n2[]);
                         (if (n1## <= patternDiagramNode##) and (n2## <= patternDiagramNode##) then
                             n1[]->node1[];
                             n2[]->node2[];
                             (if node1[] <> d[] then
                                 node1.theDiagram->theListDiagram[];
                                 (if current## <= theListDiagram.PrefixConnector## then
                                     (if switch[23] then
                                         'Inserting in inheritanceEnds: '->puttext;
                                         node1.id->putint;
                                         newline
                                     if);
                                     node1[]->inheritanceEnds.insert;
                                     (if (con.ID,true,nd1[],nd2[])->DSRdAttrGetConnEnds then
                                         nd1->theObjectList.Find->object1[];
                                         (if object1[] <> none then
                                             (if object1## <= wedgeNode## then
                                                 object1[]->wed[]
                                              else
                                                 nd2->theObjectList.Find->object2[];
                                                 (if object2[] <> none then
                                                     (if object2## <= wedgeNode## then
                                                         object2[]->wed[]
                                                     if)
                                                 if)
                                             if)
                                         if)
                                      else
                                         'GetEnds failed connector ID: '->puttext;
                                         con.ID->putint;
                                         newline
                                     if);
                                     con.delete;
                                     (if wed[] <> none then wed.delete if)
                                  else
                                     (if switch[23] then
                                         'It is not a prefixConnector'->putline
                                     if)
                                 if)
                              else
                                 node2.theDiagram->theListDiagram[];
                                 (if current## <= theListDiagram.PrefixConnector## then
                                     (if switch[23] then
                                         'Inserting in inheritanceEnds: '->puttext;
                                         node2.id->putint;
                                         newline
                                     if);
                                     node2[]->inheritanceEnds.insert;
                                     (if (con.ID,true,nd1[],nd2[])->DSRdAttrGetConnEnds then
                                         nd1->theObjectList.Find->object1[];
                                         (if object1[] <> none then
                                             (if object1## <= wedgeNode## then
                                                 object1[]->wed[]
                                              else
                                                 nd2->theObjectList.Find->object2[];
                                                 (if object2[] <> none then
                                                     (if object2## <= wedgeNode## then
                                                         object2[]->wed[]
                                                     if)
                                                 if)
                                             if)
                                         if)
                                      else
                                         'GetEnds failed connector ID: '->puttext;
                                         con.ID->putint;
                                         newline
                                     if);
                                     con.delete;
                                     (if wed[] <> none then wed.delete if)
                                  else
                                     (if switch[23] then
                                         'It is not a prefixConnector'->putline
                                     if)
                                 if)
                             if)
                         if)
                      #)
                if)
            if);
            d.geometry->(x,y,w,h);
            (if ongoingTextediting then
                (dAbstractNode.theText.oldWidth,dAbstractNode.theText.oldHeight)->(w,h)
            if);
            d.delete;
            (x-(w div 2),y-(h div 2))->startPos;
            (newAST[],startpos)->DisplayAST->startpos;
            (if newAst.kind
             // mps.kinds.interior then
                (if newAST.symbol
                 // betaGram.SimpleDecl then
                    (if newAST[]->IsDynamic
                     // true then
                        (if (private.dynamicReferenceQual[] <> none ) and
                        (private.dynamicConnector[] <> none ) then
                            (if PatternDiagrams.newNode[]
                             // none then 'OOBS: newNode is NONE'->screen.putline; 
                             else
                                PatternDiagrams.newNode[]->theSimpleNode[];
                                private.dynamicReferenceQual[]->theSimpleNode.theQualification;
                                private.dynamicConnector[]->theSimpleNode.theReferenceConnector;
                                none ->private.dynamicReferenceQual[];
                                none ->private.dynamicConnector[]
                            if)
                        if);
                        
                    if);
                    
                if)
            if);
            leave scanner;
            
        if)
     #);
   (if PatternDiagrams.newNode[]
    // none then 'OOBS: newNode is NONE'->screen.putline; 
    else
       inheritanceEnds.scan
         (# 
         do
            current[]->node1[];
            node1.theDiagram->theListDiagram[];
            &theListDiagram.PrefixConnector[]->prefixCon[];
            (if switch[23] then
                'Creating PrefixConnector between: '->puttext;
                current.id->putint;
                ' and '->puttext;
                PatternDiagrams.newNode.id->putint;
                newline
            if);
            (current[],PatternDiagrams.newNode[])->prefixCon.prefixNew;
            current[]->theTitleNode[];
            prefixCon[]->theTitleNode.thePrefixConn
         #);
       (if insertAfterPos[] <> none then
           (PatternDiagrams.newNode[],insertAfterPos[])->localNodes.insertAfter
        else
           (if insertBeforePos[] <> none then
               (PatternDiagrams.newNode[],insertBeforePos[])->localNodes.insertBefore
            else
               PatternDiagrams.newNode[]->localNodes.append
           if)
       if);
       
   if);
   none ->PatternDiagrams.addAfterNode[];
   false->remakingDiagram;
   localNodes.adjustSizes;
   
#)  

-- UpdateDiagramNode: Descriptor --
(#
   thePatternDiagramNode: ^PatternDiagramNode;
   theNode,theNode2: ^DiagramNode;
   theAbstractNode: ^AbstractNode;
   theNonTerminalNode: ^NonTerminalNode;
   testNode: ^IdObject;
   aDeclaration: ^betaGram.AttributeDecl;
   anAST,keepOldAST,keepNewAST: ^mps.ast;
   anExp: ^mps.expanded;
   theNames: ^betaGram.Names;
   theDecomposDiagram: ^Diagram;
   theSimpleNode: ^SimpleNode;
   syncatNo: @integer;
   updateName:
     (#
        theNewNameDcl,theOldNameDcl: ^betaGram.NameDcl;
        theNewNameDecl,theOldNameDecl: ^mps.namedecl;
        oldText,newText: ^text;
        doUpdate: @Boolean;
        aPatternDiagram: ^PatternDiagram;
        theNewAST,theOldAST: ^MPS.AST;
        oldX,oldY,oldWidth,oldHeight,w,h,newX: @integer;
        theRegionList: ^ObjectList
     do
        (if theNode.currentDecomposDiagram <> none (*Update name in titlenode of detailed*) then
            anAST[]->theNewNameDcl[];
            theNewNameDcl.getSon1->theNewAST[];
            (if theNewAST.kind = mps.kinds.unexpanded then
                '<<NameDecl>>'->newText[]
             else
                theNewAST[]->theNewNameDecl[]; theNewNameDecl.getText->newText[]
            if);
            (if oldAST.symbol = betaGram.NameDcl then
                oldAST[]->theOldNameDcl[];
                theOldNameDcl.getSon1->theOldAST[];
                (if theOldAST.kind = mps.kinds.unexpanded then
                    '<<NameDecl>>'->oldText[]
                 else
                    theOldAST[]->theOldNameDecl[]; theOldNameDecl.getText->oldText[]
                if);
                (if oldText[]->newText.equal then
                    (if switch[23] then
                        'UpdateDiagramNode: old name is equal to new name!'->putline
                    if)
                 else
                    true->doUpdate
                if)
             else
                true->doUpdate
            if);
            (if doUpdate then
                theNode.currentDecomposDiagram->aPatternDiagram[];
                aPatternDiagram.titleNode.geometry->(oldX,oldY,oldWidth,oldHeight);
                aPatternDiagram.titleNode.getRegionList->theRegionList[];
                (if theRegionList[] <> none then
                    theRegionList.scan
                      (# anObj: ^DesignObject do current[]->anObj[]; anObj.unmakeRegion #);
                    
                if);
                newText->aPatternDiagram.titleText->aPatternDiagram.titleNode.theText.set;
                aPatternDiagram.titleNode.FitToText;
                aPatternDiagram.titleNode.size->(w,h);
                oldX-oldWidth div 2+((w,gppProp.titleWidth)->max) div 2->newX;
                (newX,oldY,(w,gppProp.titleWidth)->max,(h,gppProp.height)->max)
                  ->aPatternDiagram.titleNode.geometry;
                (if theRegionList[] <> none then
                    theRegionList.scan
                      (# anObj: ^DesignObject
                      do current[]->anObj[]; aPatternDiagram.titleNode[]->anObj.createRegion
                      #)
                if);
                (if switch[23] then
                    'UpdateDiagramNode: name updated in detailed is '->puttext;
                    (theNode.currentDecomposDiagram).titleText[]->putline
                if)
             else
                (if switch[23] then 'UpdateDiagramNode: doUpdate is false'->putline if)
            if)
         else
            (if switch[23] then 'UpdateDiagramNode: currentDecomposDiagram is none'->putline if)
        if)
     #);
   
do
   (if switch[23]
    // true then 'Gpp ------- UpdateDiagramNode: '->putText; oldAST.Index->putInt; newLine; 
   if);
   oldAST[]->keepOldAST[];
   newAST[]->keepNewAST[];
   search:
   (if oldAST[]
    // none then
       'Gpp ------- UpdateDiagramNode: node not found: '->putText; oldAST.Index->putInt; newLine; 
    else
   (*(oldAST.index,newAST.index)->IndexIDList.update->testNode[];*)
       (oldAST[],newAST[])->ASTtoNodeListUpdate->thePatternDiagramNode[];
       (if thePatternDiagramNode[] <> none then
           (if thePatternDiagramNode## <= NonTerminalNode## then
               thePatternDiagramNode[]->theNonTerminalNode[]; newAST[]->theNonTerminalNode.redisplay
            else
               thePatternDiagramNode[]->theNode[]
           if)
        else
           thePatternDiagramNode[]->theNode[]
       if);
       (if theNonTerminalNode[] = none then
           testRedisplay:
           (if theNode[]
            // none then
               (if switch[23] then
                   'Calling redisplay - internal part of declaration was expanded'->putline
               if);
               getDecl:
               (if (keepNewAST## <= betaGram.attributeDecl##) or
               (keepNewAST[]->keepNewAST.frag.root.equal) then
                   
                else
                   keepNewAST.father->keepNewAST[]; restart getDecl
               if);
               (if keepNewAST## <= betaGram.attributeDecl## then
                   keepNewAST[]->anExp[];
                   anExp.getSon1->theNames[];
                   theNames.newScan
                     (#  do current[]->anAST[] #);
                   keepNewAST[]->ASTtoNode->theNode[];
                   (if theNode[] <> none then
                       newAST[]->getSyncatNo->syncatNo;
                       (if (syncatNo = gram.NameDcl) or (syncatNo = gram.prefix) or
                       (syncatNo = gram.prefixOpt) then
                           
                        else
                           (if theNode.CurrentDecomposDiagram <> none then
                               theNode.CurrentDecomposDiagram->theDecomposDiagram[];
                               theDecomposDiagram.titleNode.abstract
                           if)
                       if);
                       updateName;
                       (keepNewAST[],anAST[])->theNode.Redisplay
                    else
                       (if switch[23] then
                           'Surrounding declaration not present in IndexIDList??'->putline
                       if)
                   if)
                else
                   (if switch[23] then
                       'No part of a declaration was changed - no redisplay is done'->putline
                   if);
                   (if (oldAST.kind = mps.kinds.optional) and (newAST.kind = mps.kinds.unexpanded)
                    then
                       (if switch[23] then
                           'Show optionals was performed on outermost descriptor'->putline
                       if)
                    else
                       keepNewAST[]->ASTtoNode->theAbstractNode[];
                       (if theAbstractNode[] <> none then
                           theAbstractNode.abstract
                        else
                           'Could not find fragmentNode in IndexIDList!?'->putline
                       if)
                   if)
               if);
               ;
               
            else
               (if keepNewAST.symbol
                // betaGram.nameDcl then
                   (if switch[23] // true then '  it is a nameDcl'->putLine;  if);
                   keepNewAST.father->anAST[];
                   anAST.father->aDeclaration[];
                   keepNewAST[]->anAST[];
                   
                else
                   (if (keepNewAST.struc <= betaGram.attributeDecl##)
                    // true then
                       (if switch[23]
                        // true then
                           '  it is a declaration: '->putText; keepNewAST.symbol->putInt; newLine; 
                       if);
                       (if theNode.CurrentDecomposDiagram <> none then
                           theNode.CurrentDecomposDiagram->theDecomposDiagram[];
                           theDecomposDiagram.titleNode.abstract
                       if);
                       keepNewAST[]->aDeclaration[];
                       aDeclaration.getson1->anExp[];
                       anExp.getson1->anAST[];
                       
                    else
                       (if switch[23]
                        // true then
                           'not namedcl or attributeDecl: '->putText;
                           newAST.symbol->putInt;
                           newLine;
                           
                       if);
                       leave testRedisplay;
                       
                   if);
                   
               if);
               (if switch[23]
                // true then
                (* keepNewAST.dump;
                 newline;
                 (if aDeclaration[]
                 // none then
                 else
                 aDeclaration.dump; newline;
                 if); *)
                   
               if);
               updateName;
               (aDeclaration[],anAST[])->theNode.redisplay;
               
           if)
       if);
       (*(if testNode[]
        // none then
        else
        (if true
        // testNode.struc <= PatternDiagramNode## then
        testNode[]->theNode[]
        else
        'It is not a PatternDiagramNode!!'->putLine;
        if);
        if);
        * *)
       
   if);
   localNodes.adjustSizes
#)  

-- ListDiagramOnInit: Descriptor --
(# 
do
   UDPrivate.UDListDiagram->UserDataInit;
   UDdetailPage.Init;
   UDNoOfRefConnectors.Init;
   UDMaxHeight.init;
   UDMaxWidth.init;
   (if not initialisingSaved then
       THIS(ListDiagram)[]->theDiagram;
       geometry->(x,y,w,h);
       (if switch[18] then
           '******** diagrambody-ListDiagramOnInit ********'->putline;
           'x: '->putText;
           x->putint;
           newLine;
           'y: '->putText;
           y->putint;
           newLine;
           'w: '->putText;
           w->putint;
           newLine;
           'h: '->putText;
           h->putint;
           newLine;
           
       if);
       
   if);
   
#)  

-- ListDiagramOnRemove: Descriptor --
(#
   theParent: ^PatternDiagramNode;
   theNode: ^PatternDiagramNode;
   theListDiagram: ^ListDiagram;
   theFragNode: ^theListDiagram.FragmentNode
do (* tell the parent node that it is no longer detailed *)
   (if theParentNode <> none
    // true then theParentNode->theParent[]; theParent.abstractedFromDiagramBelow
    else
       (if theFragmentNode <> none then
           theFragmentNode->theNode[];
           theNode.theDiagram->theListDiagram[];
           theNode[]->theFragNode[];
           none ->theFragNode.currentDecomposDiagram
       if)
   if);
   
#)  

-- ListDiagramOnDoubleClick: Descriptor --
(# 
do (*  localNodes.abstractAll;
    False->proceed; *) (*don't let design/OA proceed in normal way*) 
#)  

-- ListDiagramAbstract: Descriptor --
(#
   connectorList,theRegionList,objectRegionList: ^ObjectList;
   theNode: ^PatternDiagramNode;
   theListDiagram: ^ListDiagram
do
   (if switch[1] // true then 'title abstract all my nodes'->putline if);
   GetRegionList->theRegionList[];
   (if theRegionList[] <> none then
       theRegionList.scan
         (# theObject: ^DesignObject
         do
            current[]->theObject[];
            theObject.GetRegionList->objectRegionList[];
            (if objectRegionList[] <> none then
                objectRegionList.scan
                  (# theWedge: ^WedgeNode
                  do (if current## <= wedgeNode## then current[]->theWedge[]; theWedge.delete if)
                  #);
                theObject.UnMakeRegion
            if)
         #)
   if);
   localNodes.abstractAll;
   (if theParentNode <> none then
       theParentNode->theNode[];
       theNode.theDiagram->theListDiagram[];
       (if theNode## <= theListDiagram.PatternNode## then
           getConnectors->connectorList[];
           (if connectorList[] <> none then
               connectorList.scan
                 (#
                    theConn: ^DeletableConnector;
                    theOtherEnd: ^patternDiagramNode;
                    OtherEnd: ^theListDiagram.SimpleNode;
                    end2: ^DesignObject
                 do
                    (if current## <= DynamicItemConnector## then
                        current[]->theConn[];
                        THIS(title)[]->theConn.getOtherEnd->theOtherEnd[];
                        (if theOtherEnd[] <> none then
                            theOtherEnd.theDiagram->theListDiagram[];
                            theOtherEnd[]->OtherEnd[];
                            none ->OtherEnd.theReferenceConnector;
                            theConn.delete;
                            &DynamicItemConnector[]->theConn[];
                            true->theConn.initialisingSaved;
                            (if OtherEnd.theDiagram <> theNode.theDiagram then
                                (OtherEnd[],theNode[])->theConn.new;
                                (if (not gppProp.references) or (not gppProp.showAttributes) then
                                    false->theConn.BorderVisible; false->theConn.selectable
                                if);
                                theConn[]->OtherEnd.theReferenceConnector
                            if)
                        if)
                     else
                        (if current## <= DynamicComponentConnector## then
                            current[]->theConn[];
                            THIS(title)[]->theConn.getOtherEnd->theOtherEnd[];
                            (*theOtherEnd=none <=> theConn connected to node in region of title
                             (not title itself)*)
                            (if theOtherEnd[] <> none then
                                theOtherEnd.theDiagram->theListDiagram[];
                                theOtherEnd[]->OtherEnd[];
                                none ->OtherEnd.theReferenceConnector;
                                theConn.delete;
                                &DynamicComponentConnector[]->theConn[];
                                true->theConn.initialisingSaved;
                                (if OtherEnd.theDiagram <> theNode.theDiagram then
                                    (OtherEnd[],theNode[])->theConn.new;
                                    (if (not gppProp.references) or (not gppProp.showAttributes)
                                     then
                                        false->theConn.BorderVisible; false->theConn.selectable
                                    if);
                                    theConn[]->OtherEnd.theReferenceConnector
                                if)
                            if)
                         else
                            (if current## <= deletableConnector## then
                                current[]->theConn[];
                                THIS(title)[]->theConn.getOtherEnd->end2[];
                                (if end2[] <> none then
                                    (if end2## <= AssociationNode## then end2.delete if)
                                if)
                            if)
                        if)
                    if)
                 #)
           if)
       if)
   if);
   Delete;
   
#)  

-- ListDiagramDetail: Descriptor --
(# lnode: ^PatternDiagramNode; lastNode: ^AbstractNode; 
do
   (if switch[1] // true then 'title detail all attribute decls...'->putline;  if);
   false->doScrollIntoView;
   localNodes.scan
     (#  do current.detail; current[]->lnode[] #);
   true->doScrollIntoView;
   (if lnode[] <> none then
       (if (*could be a SlotNode*) lnode## <= AbstractNode## then
           lnode[]->lastNode[];
           (if lastNode.currentDecomposDiagram <> none then
               (lastNode.currentDecomPosdiagram).titleNode[]->THIS(OADPage).scrollIntoView; 
            else
               'lastNode.currentDecomposDiagram is NONE'->screen.putline; 
           if)
       if)
   if);
   
#)  

-- updateMaxWH: Descriptor --
(# 
do
   (w,MaxWidth)->max->MaxWidth;
   (h,MaxHeight)->max->MaxHeight;
   (GppProp.width,MaxWidth)->max->MaxWidth;
   (GppProp.height,MaxHeight)->max->MaxHeight
#)  

-- OADDiagramNew: Descriptor --
(# theDummyDesc: ^betaGram.ObjectDescriptor
do
(* save THIS(OADDiagram) with the ASTindex of the  
 * descriptor it is generated from so it can be located later
 *)
   (if theDescriptor <> none
    // true then
       theDescriptor->theDummyDesc[];
       (theDummyDesc.index,THIS(OADDiagram)[])->PatternDiagrams.theList.insertPD;
       
   if);
   
#)  

-- OADDisplayDeclarations: Descriptor --
(# x,y,w,h: @Integer; 
do
   (if theAttributes[]
    // none then (* it is a non-terminal: display it as such *)
       'DisplayDeclarations: ATTRIBUTES IS NONE'->putline; 
    else
   (* (if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
    [* first display simple declarations like references (static and dynamic)
    * then display pattern and virtual declarations;
    *]
    titleNode.geometry->(x,y,w,h);
    x->startpos.x;
    startpos.y+(2*gppProp.DownOnPage)->startpos.y;
    
    if); *)
       theAttributes.scan
         (# 
         do
            (if not (current.kind = mps.kinds.optional) then
                (current[],startpos)->DisplayAST->startpos
            if)
         #);
       LocalNodes.adjustSizes
   if)
#)  

-- OADDiagramOnRemove: Descriptor --
(# theDummyDesc: ^betaGram.ObjectDescriptor
do (* remove the diagram from the list of patterndiagrams on the page *)
   (if theDescriptor <> none
    // true then
       theDescriptor->theDummyDesc[];
       (*if this is the last diagram on the page close the page *)
       theDummyDesc.index->PatternDiagrams.theList.deletePD;
       (if PatternDiagrams.theList.size
        // 0 then
           theFragmentNode->theGroupPage.currentObject (#  do true->autoPan #);
           true->theGroupPage.visible;
           close
       if);
       
   if);
   
#)  

-- OADDisplay: Descriptor --
(#
   p: ^localNodes.theCellType;
   e: ^LocalNodes.element;
   det: ^AbstractNode;
   x,y,w,h: @Integer;
   theDummyDesc: ^betaGram.ObjectDescriptor
do
   (if theDescriptor
    // none then (if switch[1] // true then 'theDescriptor is NONE '->puttext if); 
   if);
   CalculateNextCenter->theCenter;
   (if theDescriptor <> none
    // true then
       theDescriptor->theDummyDesc[];
       theDummyDesc.index->titleNode.astIndex;
       (if switch[1] then
           'OADDisplay: '->putText; titleNode.astIndex->putInt; '->astIndex'->putLine
       if);
       
   if);
   INNER Display;
   (if switch[18] then
       '******** diagrambody-OADDisplay 4 calling new with ********'->putline;
       'x: '->putText;
       theCenter.x->putint;
       newLine;
       'y: '->putText;
       theCenter.y->putint;
       newLine;
       'w: '->putText;
       gppProp.titlewidth->putint;
       newLine;
       'h: '->putText;
       gppProp.height*2->putint;
       newLine;
       
   if);
   (theCenter.x,theCenter.y,gppProp.titlewidth*2,gppProp.height,titleNode.defaultShape)
     ->titleNode.new;
   (*(if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
    (if localNodes.empty
    // true then (theCenter,titleNode.Center)->UpdateNextFree; 
    else
    (#
    pos1,pos2: @Point;
    x,y,w,h,dist: @Integer;
    no: @Integer;
    lastSimple, [* last node in simple pattern diagram *] firstTree,
    [* first node in tree pattern diagram *] lastTree: [* last node in tree pattern diagram *] ^PatternDiagramNode;
    
    do
    (if localNodes.empty
    // false then [* update for the next diagram *]
    localNodes.last->p[]; p.elm[]->e[]; e.Center->pos1; 
    else
    titleNode.Center->pos1; 
    if);
    pos1.x+gppProp.DownOnPage->pos1.x;
    (theCenter,pos1)->UpdateNextFree;
    titleNode[]->lastSimple[];
    localNodes.scan [* count the nodes in tree position *]
    (# d: ^DiagramNode; 
    do
    (if current.struc <= DiagramNode##
    // true then
    current[]->d[];
    (if d.theTreeConn[]
    // none then current[]->lastSimple[]; [* in simple diagram *]
    else
    (if firstTree[]
    // none then current[]->firstTree[]
    if);
    current[]->lastTree[];
    no+1->no;
    
    if)
    if)
    #);
    (if true [* calculate adjustment *]
    // (no > 1) then [* adjust them *]
    firstTree.Center->pos1;
    lastTree.Center->pos2;
    (pos2.x-pos1.x) div 2->dist;
    lastSimple.Center->pos2;
    dist-(pos2.x-pos1.x)->dist;
    
    // (no = 1) then [* center the one *]
    lastSimple.center->pos1;
    localNodes.last->p[];
    p.elm[]->e[];
    e.Center->pos2;
    pos2.x-pos1.x->dist;
    
    else
    [* no subnodes in tree *]
    
    if);
    localNodes.scan [* adjust the subnodes *]
    (# d: ^DiagramNode; 
    do
    (if current.struc <= DiagramNode##
    // true then
    current[]->d[];
    (if d.theTreeConn[]
    // none then [* in simple pattern diagram *] (0,0)
    ->
    current.
    ConcludeDisplay;
    
    else
    [* in tree *]
    (dist,0)->current.ConcludeDisplay; 
    if)
    if)
    #)
    #)
    if);
    
    else
    [* just make a simple patterndiagram of all the nodes
    * update NextFreeLine to the y coordinate of the last node in
    * plus offset *]
    (if localNodes.empty
    // true then (theCenter,titleNode.Center)->UpdateNextFree; 
    else
    localNodes.scan
    (#  do (0,0)->current.ConcludeDisplay #);
    localNodes.Last->p[];
    p.elm[]->e[];
    (theCenter,e.Center)->UpdateNextFree
    if)
    if);*)
   (*(if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
    (if PatternDiagrams.Detailer[] <> none
    // true then
    PatternDiagrams.Detailer[]->det[];
    (if det.theTreeConn[]
    // none then
    [* the Detailer is part of a blockDiagram and not a tree *]
    (if switch[18] then
    '******** diagrambody-OADDisplay 1 calling new with ********'
    ->putline;
    'x: '->putText;
    theCenter.x->putint;
    newLine;
    'y: '->putText;
    theCenter.y->putint;
    newLine;
    'w: '->putText;
    gppProp.titlewidth->putint;
    newLine;
    'h: '->putText;
    gppProp.height*2->putint;
    newLine;
    
    if);
    (theCenter.x,theCenter.y,gppProp.titlewidth,gppProp.height*2,
    titleNode.defaultShape)->titleNode.new;
    
    else
    [* the new diagram is connected to an existing tree diagram *]
    PatternDiagrams.Detailer.geometry->(x,y,w,h);
    (if switch[18] then
    '******** diagrambody-OADDisplay 2 calling new with ********'
    ->putline;
    'x: '->putText;
    x->putint;
    newLine;
    'y: '->putText;
    y->putint;
    newLine;
    'w: '->putText;
    w->putint;
    newLine;
    'h: '->putText;
    h->putint;
    newLine;
    
    if);
    (x,y,w,h,titleNode.defaultShape)->titleNode.new;
    PatternDiagrams.Detailer[]->titleNode.CreateRegion;
    true->PatternDiagrams.Detailer.moveable;
    false->titleNode.selectable;
    false->titleNode.borderVisible;
    titleNode.theText.clear;
    PatternDiagrams.Detailer[]->CurrentObject;
    
    if);
    
    else
    (if switch[18] then
    '******** diagrambody-OADDisplay 3 calling new with ********'
    ->putline;
    'x: '->putText;
    theCenter.x->putint;
    newLine;
    'y: '->putText;
    theCenter.y->putint;
    newLine;
    'w: '->putText;
    gppProp.titlewidth->putint;
    newLine;
    'h: '->putText;
    gppProp.height*2->putint;
    newLine;
    
    if);
    (theCenter.x,theCenter.y,gppProp.titlewidth,gppProp.height*2,
    titleNode.defaultShape)->titleNode.new;
    
    if);
    
    else
    (if switch[18] then
    '******** diagrambody-OADDisplay 4 calling new with ********'->putline;
    'x: '->putText;
    theCenter.x->putint;
    newLine;
    'y: '->putText;
    theCenter.y->putint;
    newLine;
    'w: '->putText;
    gppProp.titlewidth->putint;
    newLine;
    'h: '->putText;
    gppProp.height*2->putint;
    newLine;
    
    if);
    (theCenter.x,theCenter.y,gppProp.titlewidth*2,gppProp.height,
    titleNode.defaultShape)->titleNode.new;
    
    if); *)
   (* now we can make the diagram: titleNode.new, calls onInit as callback
    * which then calls DisplayDeclarations to display the contaning decls.
    *)
   (* Now we make final adjustment (we must know the number of subnodes
    * before we can do this).
    * 
    * If we make trees then we must adjust the localNodes so they
    * are centered
    *)
   (if localNodes.empty
    // true then (theCenter,titleNode.Center)->UpdateNextFree; 
    else
       localNodes.scan
         (#  do (0,0)->current.ConcludeDisplay #);
       localNodes.Last->p[];
       p.elm[]->e[];
       (theCenter,e.Center)->UpdateNextFree
   if)
#)
(* FRAGMENTDIAGRAMS *)  

-- PatternAttDiagramDisplay: Descriptor --
(#  do (if theAST <> none then (theAST).index->titleNode.astIndex if) #)  

-- FragmentDiagramNew: Descriptor --
(#
   w,h: @Integer;
   groupTitle: ^PatternDiagramNode;
   e: ^LocalNodes.element;
   p: ^Localnodes.theCellType;
   theDummyGroup: ^mps.fragmentgroup
do
   theGroup->theDummyGroup[];
   theDummyGroup.name->mps.ExpandToFullPath->fullname;
   INNER New;
   PatternDiagrams.theList.scanPropertyDiagrams
     (# 
     do
        (if thisDiagram.theGroup
         // theGroup then
            (if thisDiagram.localNodes.empty
             // false then thisDiagram.localnodes.last->p[]; p.elm[]->e[]; e.geometry->(x,y,w,h); 
             else
                thisDiagram.titleNode.geometry->(x,y,w,h); 
            if);
            thisDiagram.titleNode[]->groupTitle[];
            
        if);
        
     #);
   y+gppProp.DownOnPage->y;
   (* CalculateNextCenter -> (x,y); *)
   x-(w div 2)+(gppProp.titlewidth div 2)->x;
   (if switch[18] then
       '******** diagrambody-FragmentDiagramNew: calling new with ********'->putline;
       'x: '->putText;
       x->putint;
       newLine;
       'y: '->putText;
       y->putint;
       newLine;
       'w: '->putText;
       gppProp.titlewidth->putint;
       newLine;
       'h: '->putText;
       gppProp.height->putint;
       newLine;
       
   if);
   (x,y,gppProp.titlewidth,gppProp.height,titleNode.defaultShape)->titleNode.new;
   groupTitle[]->titleNode.CreateRegion;
   (0,THIS(FragmentDiagram)[])->PatternDiagrams.theList.insertPD;
   
#)  

-- FragmentDiagramTitleInit: Descriptor --
(# theDummyGroup: ^mps.fragmentgroup
do (* show fragments starting at low-left of the titleNode *)
   UDPrivate.UDFragmentDiagram->UserDataInit;
   UDfullname.Init;
   UDtheGroup.Init;
   gppProp.fontSize->theText.size;
   LeftJustification->theText.Just;
   false->BorderVisible;
   (if not initialisingSaved then
       (x-(w+1) div 2,y-((h+1) div 2))->(x,y);
       theGroup->theDummyGroup[];
       theDummyGroup.fragmentList.scan
         (# f: ^mps.fragmentform; theRoot: ^MPS.AST; theNode: ^FragmentNode; 
         do
            (if current.type
             // mps.linkType then (* ignore *)
                
             // mps.groupType then
                'Groups in groups not suported'->putline; 
             // mps.formType then
                current.f[]->f[];
                f.root[]->theRoot[];
                (if theRoot.symbol
                 // betaGram.DescriptorForm then
                    &DescriptorNode[]->theNode[]; 
                 // betaGram.AttributesForm then
                    &AttributesNode[]->theNode[]; 
                 // betaGram.DoPart then
                    &DoPartNode[]->theNode[]
                 else
                    'Other type'->putline; 
                if);
                gppProp.height+y->y;
                THIS(FragmentDiagram)[]->theNode.theDiagram;
                ((x,y),current.f[])->theNode.display;
                (0,0)->theNode.ConcludeDisplay;
                
            if);
            
         #);
       'Fragments'->titleText;
       titletext->theText.set;
       ((x,y),(x,y))->UpdateNextFree;
       scanner: PatternDiagrams.theList.scanPropertyDiagrams
         (# x1,y1,w1,h1: @Integer; (* go find the property diagram of theGroup *) 
         do
            (if thisDiagram.theGroup
             // theGroup then
                (thisDiagram.theSurroundBox).geometry->(x1,y1,w1,h1);
                (x+gppProp.width,y1+(h1 div 2)+((y-y1+(h1 div 2)) div 2)+1,gppProp.width*2+20,
                 (* width *) y-y1+gppProp.height) (* height *)
                  ->(thisDiagram.theSurroundBox).geometry;
                leave scanner;
                
            if);
            
         #);
       0->MaxWidth;
       0->MaxHeight;
       localNodes.scan
         (#  do current.FitToText; current.size->updateMaxWH #);
       localNodes.adjustSizes
   if);
   
#)  

-- InsertFragmentNode: DoPart --
do
     (#
        previousNode: ^PatternDiagramNode;
        i: @Integer;
        x,y,w,h: @Integer;
        startPos: @point;
        displayNode:
          (#
             theRoot: ^MPS.AST;
             theNode: ^FragmentNode;
             dummy: ^mps.fragmentform;
             dummy2: ^mps.fragmentGroup
          do
             previousNode.geometry->(x,y,w,h);
             (x-(w+1) div 2,y-((h+1) div 2))->(x,y);
             previousNode[]->PatternDiagrams.addAfterNode[];
             (if ff.type
              // mps.linkType then (* ignore *)
                 
              // mps.groupType then
                 'Groups in groups not suported'->putline; 
              // mps.formType then
                 ff.root[]->theRoot[];
                 (if theRoot.symbol
                  // betaGram.DescriptorForm then
                     &DescriptorNode[]->theNode[]; 
                  // betaGram.AttributesForm then
                     &AttributesNode[]->theNode[]; 
                  // betaGram.DoPart then
                     &DoPartNode[]->theNode[]
                  else
                     'Other type'->putline; 
                 if);
                 gppProp.height+y->y;
                 THIS(FragmentDiagram)[]->theNode.theDiagram;
                 ((x,y),ff[])->theNode.display;
                 (0,0)->theNode.ConcludeDisplay;
                 theNode.theFragment->dummy[];
                 scanner: PatternDiagrams.theList.scanPropertyDiagrams
                   (# x1,y1,w1,h1: @Integer; (* go find the property diagram of theGroup *) 
                   do
                   (*'thisDiagram.theGroup: '->puttext;
                    (thisDiagram.theGroup).fullname->putline;
                    'ff.father: '->puttext;
                    (ff.father).fullname->putline;*)
                      thisDiagram.theGroup->dummy2[];
                      (if thisDiagram.theGroup = ff.father then
                      (* update the surroundBox of the property diagram *)
                          (thisDiagram.theSurroundBox).geometry->(x1,y1,w1,h1);
                          (x1,y1+(gppProp.height div 2),w1, (* width *) h1+gppProp.height)
                          (* height *) ->(thisDiagram.theSurroundBox).geometry;
                          leave scanner;
                          
                      if);
                      
                   #);
                 
             if)
          #);
        aText: @Text;
        connectorList,inheritanceEnds: ^ObjectList;
        theTitleNode: ^theListDiagram.title;
        theListdiagram: ^ListDiagram;
        
     do
        (if switch[23]
         // true then
            'Gpp ------- InsertFragmentNode: '->putText;
            pos->putInt;
            ' '->put;
            ff.fullname->putline;
            
        if);
        1->i;
        (if pos = 0 then titleNode[]->previousNode[]; displayNode if);
        localnodes.scan
          (# aText: @Text; 
          do
             (if switch[23] then
                 'InsertDiagramNode: examening no '->puttext;
                 i->putint;
                 ' element in localnodes - '->puttext;
                 current.thetext.get->aText;
                 aText[]->putline
             if);
             (if i
              // pos then current[]->previousNode[]; displayNode
              else
                 (if (* what about this? (current[]<>aNode[]) and *) (i > pos)
                  // true then
                     (if switch[23]
                      // true then
                         'InsertDiagramNode: move down '->puttext;
                         current.theText.get->aText;
                         aText[]->putline;
                         
                     if);
                     current.center->(x,y);
                     (x,y+gppProp.height)->current.center;
                     
                 if)
             if);
             i+1->i;
             
          #);
        (if PatternDiagrams.newNode[]
         // none then 'OOBS: newNode is NONE'->screen.putline; 
         else
            (if pos <> 0 then
                (PatternDiagrams.newNode[],PatternDiagrams.addAfterNode[]->localNodes.at)
                  ->localNodes.insertAfter
             else
                (if switch[23] then
                    'InsertDiagramNode - prepending in localNodes: '->puttext;
                    PatternDiagrams.newNode.theText.get->aText;
                    aText[]->putline
                if);
                PatternDiagrams.newNode[]
                  ->localNodes.prepend (*The new node is the topmost localNode when pos=0*)
            if);
            
        if);
        none ->PatternDiagrams.addAfterNode[];
        localNodes.adjustSizes;
        
     #)  

-- deleteFragmentNode: DoPart --
do
     (#
        dListDiagram: ^ListDiagram;
        dFragmentNode: ^dListDiagram.FragmentNode;
        x,y,w,h: @Integer;
        dx,dy: @Integer;
        t: @text;
        theGroup: ^mps.fragmentGroup
     do
        d.theDiagram->dListDiagram[];
        d[]->dFragmentNode[];
        (dFragmentNode.theFragment).father->theGroup[];
        dFragmentNode.theRoot->RemoveListElement;
        (if dFragmentNode.currentDecomposDiagram <> none then
            (dFragmentNode.currentDecomposDiagram).titleNode.abstract; 
        if);
        d.geometry->(dx,dy,w,h);
        scanner: localnodes.scan
          (# aText: ^Text; 
          do
             (if switch[23] then
                 'DeleteDiagramNode - current in scanner: '->puttext;
                 current.theText.get->t;
                 t[]->putline;
                 
             if);
             (if current[] = d[] then
                 d.delete
              else
                 current.center->(x,y);
                 (if y > dy then
                     (x,y-gppProp.height)->current.center;
                     (if switch[23]
                      // true then
                         'DeleteDiagramNode - element moved: '->puttext;
                         current.theText.get->t;
                         t[]->putline;
                         
                     if)
                 if)
             if)
          #);
        scanner: PatternDiagrams.theList.scanPropertyDiagrams
          (# x1,y1,w1,h1: @Integer; (* go find the property diagram of theGroup *) 
          do
          (*'thisDiagram.theGroup: '->puttext;
           (thisDiagram.theGroup).fullname->putline;
           'ff.father: '->puttext;
           (ff.father).fullname->putline;*)
             (if thisDiagram.theGroup = theGroup[] then
             (* update the surroundBox of the property diagram *)
                 (thisDiagram.theSurroundBox).geometry->(x1,y1,w1,h1);
                 (x1,y1-(gppProp.height div 2),w1, (* width *) h1-gppProp.height) (* height *)
                   ->(thisDiagram.theSurroundBox).geometry;
                 leave scanner;
                 
             if);
             
          #);
        (if switch[23] then 'DeleteDiagramNode end of scanner'->putline if);
        d[]->localnodes.at->localnodes.delete;
        0->MaxWidth;
        0->MaxHeight;
        localNodes.scan
          (#  do current.FitToText; current.size->updateMaxWH #);
        localNodes.adjustSizes;
        
     #)  

