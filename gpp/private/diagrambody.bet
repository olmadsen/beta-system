ORIGIN 'diagramattributes';
INCLUDE '~beta/sysutils/objinterface'
        'gppinterfacebody'
        '~beta/guienv/controls'
        '~beta/guienv/utils/auxcontrols'
        '~beta/guienv/utils/groupbox'
        '~beta/guienv/fields'
        '~beta/guienv/utils/textfieldadds'
        '~beta/guienv/scrolllists'
        '~beta/guienv/utils/tabControl'
        '~beta/guienv/preliminary/tabStops/tabStops';
LIB_ITEM 'gpp';
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
(* DIAGRAM *)
-- diagramPopupEditOnStatus: DoPart --
do
   ((theParentNode <> none ) and (not (theSifEditor).sifisEditingMode) and
    (not (theSifEditor).isReadOnly))->value  

-- diagramPopupEditOnSelect: DoPart --
do (theParentNode).edit  

-- diagramTitlePopupOpen: DoPart --
do
   true->opened;
   editItem.open;
   'Edit...'->editItem.name;
   editItem[]->append;
   INNER open  

-- diagramTitleOnRightMouseDown: DoPart --
do (* MANNAN: check the followin 3 lines *)
   (patterndiagrams.oldSelection[],THIS(title)[])->changedFocus;
   THIS(title)[]->patterndiagrams.oldSelection[];
   enableEditName;
   (if THIS(Diagram)## <= PatternDiagram## then
       (if not thePopup.opened then thePopup.open if);
       (1,mousePos,inWindow[])->thePopup.popup;
       INNER onRightMouseDown
   if)  

-- TitleInteractiveNew: Descriptor --
(#  do (w,h)->Size #)  

-- TitleOnInit: Descriptor --
(# 
do
   UDPrivate.UDDiagram
     ->UserDataInit (*toby 1-11-94:
                     User data initializations*) ;
   UDtheParentNode.Init;
   UDtheFragmentNode.Init;
   thePrefixConn.Init;
   false->sizeable;
   font.Geneva->theText.font;
   textJust.Centered->theText.just;
   gppProp.fontSize->theText.size;
   textStyle.bold->theText.style;
   INNER OnInit;
   (* titleText -> theText.set; resposibility of sub patterns *)
   
#)  

-- TitleOnSelect: Descriptor --
(# 
do
   (patterndiagrams.oldSelection[],THIS(title)[])->changedFocus;
   THIS(title)[]->patterndiagrams.oldSelection[];
   enableEditName;
   INNER onSelect;
   
#)
(* LISTDIAGRAM *)  

-- TitleTheSifEditor: DoPart --
do
   (if theFragmentNode <> none then
       (if se[] = none then
           theFragmentNode->fn[]; fn.theSifEditor->se[]; 
        else
           theFragmentNode->fn[]; se[]->fn.theSifEditor; 
       if);
       
    else
       (if switch[40] then
           'titleNode: theSifEditor: no FragmentNode'->screen.putline
       if)
   if)  

-- diagramTitleDump: DoPart --
do
   'Diagram.titleNode'->nodetype[];
   '********theParentNode********'->putline;
   (if theParentNode <> none then
       (theParentNode).ID->putint; newline
    else
       'is NONE!'->putline
   if);
   '********theFragmentNode********'->putline;
   (if theFragmentNode <> none then
       (theFragmentNode).id->putint; newline
    else
       'is NONE!'->putline
   if);
   '********thePrefixConn********'->putline;
   (if thePrefixConn <> none then
       (thePrefixConn).id->putint; newline
    else
       'is NONE!'->putline
   if);
   INNER dump  

-- LocalNodesAbstractAll: Descriptor --
(# dummy: ^AbstractNode; theDiagram: ^Diagram; 
do
   70
     ->trace
       (# 
       do
          'localNodes.abstractAll deleting %s'
            ->t.putformat
              (# help: @text do current.thetext.get->help; help[]->s #)
       #);
   (if current## <= AbstractNode## then
       current[]->dummy[];
       (if dummy.currentDecomposDiagram <> none then
           dummy.currentDecomposDiagram->theDiagram[];
           theDiagram.titleNode.abstract
       if)
   if);
   (*localnodes *must* be explicitely deleted before
    their titles.
    If not their theDiagram ref. cannot be read
    in deleteDiagramNode.*)
   current.delete;
   
#)  

-- LocalNodesAdjustSizes: Descriptor --
(#
   tx,ty,tw,th,tleft,x,y,w,h: @integer;
   regions: ^ObjectList;
   regionsWithSize: @list
     (#
        element:: 
          (#
             region: ^DesignObject;
             w,h: @integer;
             size: (#  enter (w,h) exit (w,h) #)
          #);
        insert:
          (# anObj: ^DesignObject; elm: ^element
          enter anObj[]
          do
             &element[]->elm[];
             anObj[]->elm.region[];
             anObj.size->elm.size;
             elm[]->append
          #);
        restoreRegionSizes: scan (#  do current.size->current.region.size #)
     #);
   oadd: ^OADDiagram
do
   TitleNode.geometry->(tx,ty,tw,th);
   tx-(tw div 2)->tleft;
   (* titleNode.getRegionList->regions[];
    (if regions[] <> none then
    regions.scan
    (# theObject: ^DesignObject
    do
    (if not (current## <= PatternDiagramNode##) then
    current[]->regionsWithSize.insert
    else
    current[]->theObject[]; theObject.unMakeRegion
    if)
    #)
    if); *)
   (tleft+(MaxWidth div 2),ty,MaxWidth,GppProp.Height)->titleNode.geometry;
   LocalNodes.scan
     (# currentLocalNode: ^PatternDiagramNode
     do
        current.geometry->(x,y,w,h);
        current.getRegionList->regions[];
        (if regions[] <> none then
        (* if region is to the right of localNode
         move it corresponding to resize *)
            regions.scan
              (# dobj: ^designObject; rx,ry: @integer
              do
                 (if current## <= designObject## then
                     current[]->dobj[];
                     dobj.center->(rx,ry);
                     (if rx > x then (rx+(MaxWidth-w),ry)->dobj.center if)
                 if)
              #)
        if);
        (tleft+(MaxWidth div 2),y,MaxWidth,GppProp.Height)->current.geometry
     #);
   (* (if regions[] <> none then
    regions.scan
    (# theObject: ^DesignObject
    do
    (if current## <= PatternDiagramNode## then
    current[]->theObject[]; titleNode[]->theObject.createRegion
    if)
    #);
    (if not regionsWithSize.empty then
    regionsWithSize.restoreRegionSizes; regionsWithSize.clear
    if)
    if); *)
   (if theSurroundBox <> none then
       TitleNode.geometry->(tx,ty,tw,th);
       (if localNodes.empty or (not gppProp.showAttributes) then
           (tx,ty,tw,th)->(theSurroundBox).geometry
        else
           (tx,ty-gppProp.height div 2+((localNodes.size+1)*gppProp.height) div
            2,tw,(localNodes.size+1)*gppProp.height)->(theSurroundBox).geometry
       if)
   if);
   (if localNodeOrder = gppProp.inCompartments then
       (if THIS(Diagram)## <= OADDiagram## then
           THIS(Diagram)[]->oadd[]; oadd.sortAttributesAndOperations
       if)
   if)
#)  

-- localNodesDump: DoPart --
do
   scanFrom
     (# t: @text
     do current.id->putint; ': '->puttext; current.theText.get->t; t[]->putline
     #)  

-- InsertDiagramNode: Descriptor --
(#
   previousNode: ^PatternDiagramNode;
   i: @Integer;
   x,y,w,h: @Integer;
   startPos: @point;
   displayNode:
     (# 
     do
        previousNode.geometry->(x,y,w,h);
        x-(w div 2)->x;
        x+gppProp.width->x;
        gppProp.width*2->w;
        previousNode[]->patterndiagrams.addAfterNode[];
        (x-(w div 2),y-(h div 2)+gppProp.height)->startPos;
        (anAst[],startpos)->DisplayAST->startpos
     #);
   aText: @Text;
   connectorList (* ,inheritanceEnds *) : ^ObjectList;
   con: ^Connector;
   node1,node2: ^PatternDiagramNode;
   n1,n2,p1,p2: ^DesignObject;
   theTitleNode: ^theListDiagram.title;
   theListdiagram: ^ListDiagram;
   object1,object2: ^designObject;
   
do
   (if switch[60]
    // true then
       'Gpp ------- InsertDiagramNode: '->putText;
       pos->putInt;
       ' '->put;
       anAst.Index->putInt;
       newLine;
       anAST.dump;
       newLine;
       
   if);
   1->i;
   true->remakingDiagram;
   (if pos = 0 then titleNode[]->previousNode[]; displayNode if);
   localnodes.scan
     (# aText: @Text; 
     do
        (if switch[60] then
            'InsertDiagramNode: examening no '->puttext;
            i->putint;
            ' element in localnodes - '->puttext;
            current.thetext.get->aText;
            aText[]->putline
        if);
        (if i
         // pos then current[]->previousNode[]; displayNode
         else
            (if (* what about this? (current[]<>aNode[]) and *) (i > pos)
             // true then
                (if switch[60]
                 // true then
                    'InsertDiagramNode: move down '->puttext;
                    current.theText.get->aText;
                    aText[]->putline;
                    
                if);
                current.center->(x,y);
                (x,y+gppProp.height)->current.center;
                
            if)
        if);
        i+1->i;
        
     #);
   (if patterndiagrams.newNode[] = none then
       'OOBS: newNode is NONE'->screen.putline; 
    else
       (if pos <> 0 then
           (patterndiagrams.newNode[],
            patterndiagrams.addAfterNode[]->localNodes.at)
             ->localNodes.insertAfter
        else
           (if switch[60] then
               'InsertDiagramNode - prepending in localNodes: '->puttext;
               patterndiagrams.newNode.theText.get->aText;
               aText[]->putline
           if);
           patterndiagrams.newNode[]
             ->
               localNodes.prepend
               (*The new node is the topmost localNode when pos=0*)
       if);
       
   if);
   none ->patterndiagrams.addAfterNode[];
   false->remakingDiagram;
   localNodes.adjustSizes;
   
#)  

-- DeleteDiagramNode: Descriptor --
(#
   x,y,w,h: @Integer;
   tx,ty: @Integer;
   deleted: @boolean;
   p: [8] @Integer;
   leftAtTitle: @boolean;
   t: @Text;
   (*  inheritanceEnds, *)
   connectorList: ^ObjectList;
   con: ^connector;
   node1,node2: ^PatternDiagramNode;
   abs: ^AbstractNode;
   n1,n2,p1,p2: ^DesignObject;
   theTitleNode: ^theListDiagram.title;
   dListDiagram,theListDiagram: ^ListDiagram;
   dDiagramNode: ^dListDiagram.DiagramNode;
   dNonTerminalNode: ^dListDiagram.NonTerminalNode;
   object1,object2: ^designObject;
   remAttributeType: @integer
do
   60
     ->trace
       (# theNode: ^PatternDiagramNode
       do
          d[]->theNode[];
          'Gpp ------- DeleteDiagramNode: %s'
            ->t.putformat
              (# help: @text do theNode.thetext.get->help; help[]->s #)
       #);
   d.attributeType
     -> (* cannot be read after node is deleted! *) remAttributeType;
   d.theDiagram->dListDiagram[];
   (if d## <= dListDiagram.DiagramNode## then
       d[]->dDiagramNode[];
       (if deletenode then
           (if dDiagramNode.CurrentDecomposDiagram <> none then
               dDiagramNode.CurrentDecomposDiagram->dListDiagram[];
               dListDiagram.titleNode.abstract
           if)
       if);
       
    else
       (if d## <= dListDiagram.NonTerminalNode## then
           d[]->dNonTerminalNode[]
       if)
   if);
   scanner: localnodes.scan
     (# aText: ^Text; 
     do
        60
          ->trace
            (# 
            do
               'DeleteDiagramNode - current in scanner: %s'
                 ->t.putformat
                   (# help: @text
                   do current.theText.get->help; help[]->s
                   #)
            #);
        (if current[] = d[] then
            (if deleteNode then
                d.delete; (* ESS: was outside the if:
                           *) true->deleted; 
            if);
            60
              ->trace
                (# 
                do
                   (if deleteNode then
                       'element found and deleted'->t
                    else
                       'element found but not deleted'->t
                   if)
                #)
         else
            (if deleted then (* move the rest *)
                current.center->(x,y);
                (x,y-gppProp.height)->current.center;
                60
                  ->trace
                    (# 
                    do
                       'element moved: %s'
                         ->t.putformat
                           (# help: @text
                           do current.theText.get->help; help[]->s
                           #)
                    #)
            if)
        if)
     #);
   60->trace (#  do 'DeleteDiagramNode end of scanner'->t #);
   d[]->localnodes.at->localnodes.delete;
   (if remAttributeType
    // gppProp.SimpleAttribute then
       d[]->attributes.at->attributes.delete
    // gppProp.operation then
       d[]->operations.at->operations.delete
    // gppProp.localClass then
       d[]->localClasses.at->localClasses.delete
   if);
   0->MaxWidth;
   0->MaxHeight;
   titleNode[]->updateMaxWH;
   localNodes.scan
     (#  do current[]->updateMaxWH #);
   localNodes.adjustSizes;
   60->trace (#  do 'Gpp ------- DeleteDiagramNode END'->t #);
   
#)  

-- ReplaceDiagramNode: Descriptor --
(#
   x,y,w,h: @Integer;
   startPos: @point;
   insertAfterPos,insertBeforePos,thePos: ^localnodes.theCellType;
   IsDynamic:
     (#
        yes: @Boolean;
        anAST: ^MPS.AST;
        decl: ^betaGram.SimpleDecl;
        theSpec: ^betaGram.ReferenceSpecification;
        
     enter anAST[]
     do
        (if anAST## <= betagram.SimpleDecl## then
            anAST[]->decl[];
            decl.GetReferenceSpecification->anAST[];
            (if anAST## <= betagram.ReferenceSpecification## then
                anAST[]->theSpec[];
                (if theSpec.symbol
                 // betaGram.dynamicItem // betaGram.dynamicComponent then
                    true->yes; 
                if)
             else
                (if switch[60] then
                    'Freja-- OOBS: anAST## <= betagram.ReferenceSpecification## failed'
                      ->screen.putline
                if);
                
            if)
         else
            'Freja-- OOBS: anAST## <= betagram.SimpleDecl## failed'
              ->screen.putline;
            
        if);
        
     exit yes
     #);
   aText: @Text;
   connectorList (* ,inheritanceEnds *) : ^ObjectList;
   con: ^Connector;
   node1,node2: ^PatternDiagramNode;
   n1,n2,p1,p2: ^DesignObject;
   theTitleNode: ^theListDiagram.title;
   dListDiagram,theListDiagram: ^ListDiagram;
   dAbstractNode: ^dListDiagram.AbstractNode;
   theSimpleNode: ^SimpleNode;
   object1,object2: ^designObject;
   
do
   (if switch[60]
    // true then
       'Gpp ------- ReplaceDiagramNode: '->putText;
       newAST.Index->putInt;
       newLine;
       newAST.dump;
       newLine;
       
   if);
   d.theDiagram->dListDiagram[];
   (if d## <= dListDiagram.AbstractNode## then
       d[]->dAbstractNode[];
       (if dAbstractNode.CurrentDecomposDiagram <> none then
           dAbstractNode.CurrentDecomposDiagram->dListDiagram[];
           dListDiagram.titleNode.abstract
       if)
   if);
   true->remakingDiagram;
   scanner: localnodes.scan
     (# 
     do
        (if switch[60] then
            'ReplaceDiagramNode - examining: '->puttext;
            current.theText.get->aText;
            aText[]->putline
        if);
        (if current[]
         // d[] then
            (if switch[60] then
                'ReplaceDiagramNode - addAfterNode: '->puttext;
                current.theText.get->aText;
                aText[]->putline
            if);
            current[]->patterndiagrams.addAfterNode[];
            patterndiagrams.addAfterNode[]->localNodes.at->thePos[];
            (if thePos.pred[] <> none then
                thePos.pred[]->insertAfterPos[]
             else
                (if thePos.succ[] <> none then
                    thePos.succ[]->insertBeforePos[]
                if)
            if);
            d.geometry->(x,y,w,h);
            (x-(w div 2),y-(h div 2))->startPos;
            (newAST[],startpos)->DisplayAST->startpos;
            (if patterndiagrams.newNode[] = none then
                'OOBS: newNode is NONE'->screen.putline
             else
                
            if);
            d.delete;
            (if newAst.kind
             // mps.kinds.interior then
                (if newAST.symbol
                 // betaGram.SimpleDecl then
                    (if newAST[]->IsDynamic // true then  if); 
                if)
            if);
            leave scanner;
            
        if)
     #);
   (if patterndiagrams.newNode[]
    // none then 'OOBS: newNode is NONE'->screen.putline; 
    else
       (if insertAfterPos[] <> none then
           (patterndiagrams.newNode[],insertAfterPos[])->localNodes.insertAfter
        else
           (if insertBeforePos[] <> none then
               (patterndiagrams.newNode[],insertBeforePos[])
                 ->localNodes.insertBefore
            else
               patterndiagrams.newNode[]->localNodes.append
           if)
       if);
       
   if);
   none ->patterndiagrams.addAfterNode[];
   false->remakingDiagram;
   0->MaxWidth;
   0->MaxHeight;
   titleNode[]->updateMaxWH;
   localNodes.scan
     (#  do current[]->updateMaxWH #);
   localNodes.adjustSizes;
   
#)  

-- UpdateDiagramNode: Descriptor --
(#
   thePatternDiagramNode: ^PatternDiagramNode;
   theFragmentNode: ^FragmentNode;
   theNode,theNode2: ^DiagramNode;
   theAbstractNode: ^AbstractNode;
   theNonTerminalNode: ^NonTerminalNode;
   testNode: ^IdObject;
   aDeclaration: ^betaGram.AttributeDecl;
   anAST,keepOldAST,keepNewAST: ^mps.ast;
   anExp: ^mps.expanded;
   theNames: ^betaGram.Names;
   theDecomposDiagram: ^Diagram;
   theSimpleNode: ^SimpleNode;
   syncatNo: @integer;
   updateName:
     (#
        theNewNameDcl,theOldNameDcl: ^betaGram.NameDcl;
        theNewNameDecl,theOldNameDecl: ^mps.namedecl;
        oldText,newText: ^text;
        doUpdate: @Boolean;
        aPatternDiagram: ^PatternDiagram;
        theNewAST,theOldAST: ^MPS.AST;
        oldX,oldY,oldWidth,oldHeight,x,y,w,h,newX: @integer;
        theRegionList: ^ObjectList
     do
        (if theNode.currentDecomposDiagram <> none
        (*Update name in titlenode of detailed*) then
            anAST[]->theNewNameDcl[];
            theNewNameDcl.getSon1->theNewAST[];
            (if theNewAST.kind = mps.kinds.unexpanded then
                '<<NameDecl>>'->newText[]
             else
                theNewAST[]->theNewNameDecl[]; theNewNameDecl.getText->newText[]
            if);
            (if oldAST.symbol = betaGram.NameDcl then
                oldAST[]->theOldNameDcl[];
                theOldNameDcl.getSon1->theOldAST[];
                (if theOldAST.kind = mps.kinds.unexpanded then
                    '<<NameDecl>>'->oldText[]
                 else
                    theOldAST[]->theOldNameDecl[];
                    theOldNameDecl.getText->oldText[]
                if);
                (if oldText[]->newText.equal then
                    (if switch[60] then
                        'UpdateDiagramNode: old name is equal to new name!'
                          ->putline
                    if)
                 else
                    true->doUpdate
                if)
             else
                true->doUpdate
            if);
            (if doUpdate then
                theNode.currentDecomposDiagram->aPatternDiagram[];
                newText->aPatternDiagram.titleText
                  ->aPatternDiagram.titleNode.theText.set;
                aPatternDiagram.titleNode[]->aPatternDiagram.updateMaxWH;
                aPatternDiagram.localNodes.adjustsizes;
                (if switch[60] then
                    'UpdateDiagramNode: name updated in detailed is '->puttext;
                    (theNode.currentDecomposDiagram).titleText[]->putline
                if)
             else
                (if switch[60] then
                    'UpdateDiagramNode: doUpdate is false'->putline
                if)
            if)
         else
            (if switch[60] then
                'UpdateDiagramNode: currentDecomposDiagram is none'->putline
            if)
        if)
     #);
   
do
   60
     ->trace
       (# 
       do
          'Gpp ------- UpdateDiagramNode: %i\n'
            ->t.putformat (#  do oldAST.Index->i #)
       #);
   oldAST[]->keepOldAST[];
   newAST[]->keepNewAST[];
   search:
   (if oldAST[] = none then
       'Gpp ------- UpdateDiagramNode: node not found: %i\n'
         ->stderr.putformat (#  do oldAST.Index->i #)
    else
       (oldAST[],newAST[])->ASTtoNodeListUpdate->thePatternDiagramNode[];
       (if thePatternDiagramNode[] <> none then
           (if thePatternDiagramNode## <= NonTerminalNode## then
               thePatternDiagramNode[]->theNonTerminalNode[];
               newAST[]->theNonTerminalNode.redisplay
            else
               (if thePatternDiagramNode## <= FragmentNode## then
                   thePatternDiagramNode[]->theFragmentNode[];
                   newAST.frag[]->theFragmentNode.redisplay
                else
                   (if thePatternDiagramNode## <= DiagramNode## then
                       thePatternDiagramNode[]->theNode[]
                   if)
               if)
           if)
        else
           thePatternDiagramNode[]->theNode[]
       if);
       (if theNonTerminalNode[] = none then
           testRedisplay:
           (if theNode[] = none then
               60
                 ->trace
                   (# 
                   do
                      'Calling redisplay - internal part of declaration was expanded'
                        ->t
                   #);
               getDecl:
               (if (keepNewAST## <= betaGram.attributeDecl##) or
               (keepNewAST[]->keepNewAST.frag.root.equal) then
                   
                else
                   keepNewAST.father->keepNewAST[]; restart getDecl
               if);
               (if keepNewAST## <= betaGram.attributeDecl## then
                   keepNewAST[]->anExp[];
                   anExp.getSon1->theNames[];
                   theNames.newScan
                     (#  do current[]->anAST[] #);
                   keepNewAST[]->ASTtoNode->theNode[];
                   (if theNode[] <> none then
                       newAST[]->getSyncatNo->syncatNo;
                       (if (syncatNo = gram.NameDcl) or
                       (syncatNo = gram.prefix) or (syncatNo = gram.prefixOpt)
                       or (newAST.kind = mps.kinds.NameAppl) or
                       (newAST.kind = mps.kinds.NameDecl) then
                           
                        else
                           (if theNode.CurrentDecomposDiagram <> none then
                               theNode.CurrentDecomposDiagram
                                 ->theDecomposDiagram[];
                               theDecomposDiagram.titleNode.abstract
                           if)
                       if);
                       updateName;
                       (keepNewAST[],anAST[])->theNode.Redisplay
                    else
                       60
                         ->trace
                           (# 
                           do
                              'Surrounding declaration not present in IndexIDList??'
                                ->t
                           #)
                   if)
                else
                   60
                     ->trace
                       (# 
                       do
                          'No part of a declaration was changed - no redisplay is done'
                            ->t
                       #);
                   (if (oldAST.kind = mps.kinds.optional) and
                   (newAST.kind = mps.kinds.unexpanded) then
                       60
                         ->trace
                           (# 
                           do
                              'Show optionals was performed on outermost descriptor'
                                ->t
                           #)
                    else
                       keepNewAST[]->ASTtoNode->theAbstractNode[];
                       (if theAbstractNode[] <> none then
                           theAbstractNode.abstract
                        else
                           'Could not find fragmentNode in IndexIDList!?'
                             ->stdErr.putline
                       if)
                   if)
               if)
            else
               (if keepNewAST.symbol = betaGram.nameDcl then
                   60->trace (#  do '  it is a nameDcl'->t #);
                   keepNewAST.father->anAST[];
                   anAST.father->aDeclaration[];
                   keepNewAST[]->anAST[]
                else
                   (if (keepNewAST## <= betaGram.attributeDecl##) then
                       60
                         ->trace
                           (# 
                           do
                              '  it is a declaration: %i\n'
                                ->t.putformat (#  do keepNewAST.symbol->i #)
                           #);
                       (if theNode.CurrentDecomposDiagram <> none then
                           theNode.CurrentDecomposDiagram->theDecomposDiagram[];
                           theDecomposDiagram.titleNode.abstract
                       if);
                       keepNewAST[]->aDeclaration[];
                       aDeclaration.getson1->anExp[];
                       anExp.getson1->anAST[]
                    else
                       60
                         ->trace
                           (# 
                           do
                              'not namedcl or attributeDecl: %i\n'
                                ->t.putformat (#  do newAST.symbol->i #)
                           #);
                       leave testRedisplay
                   if)
               if);
               updateName;
               (aDeclaration[],anAST[])->theNode.redisplay
           if)
       if)
   if);
   localNodes.adjustSizes
#)  

-- ListDiagramOnInit: Descriptor --
(# 
do
   UDPrivate.UDListDiagram->UserDataInit;
   UDtheSurroundBox.init;
   UDdetailPage.Init;
   UDNoOfRefConnectors.Init;
   UDMaxHeight.init;
   UDMaxWidth.init;
   UDlocalNodeOrder.init;
   (if not initialisingSaved then
       THIS(ListDiagram)[]->theDiagram; geometry->(x,y,w,h); 
   if);
   
#)  

-- ListDiagramOnRemove: Descriptor --
(#
   theParent: ^PatternDiagramNode;
   theNode: ^PatternDiagramNode;
   theListDiagram: ^ListDiagram;
   theFragNode: ^theListDiagram.FragmentNode;
   connectors,regions: ^objectList
do (* tell the parent node that it is no longer detailed *)
   30
     ->trace
       (# 
       do 'title: onRemove callback on %i'->t.putformat (#  do ID->i #)
       #);
   (if theParentNode <> none then
       theParentNode->theParent[]; theParent.abstractedFromDiagramBelow
    else
       (if theFragmentNode <> none then
           theFragmentNode->theNode[];
           theNode.theDiagram->theListDiagram[];
           theNode[]->theFragNode[];
           none ->theFragNode.currentDecomposDiagram
       if)
   if);
   getConnectors->connectors[];
   (if connectors[] <> none then
       connectors.scan
         (#
            theConn: ^deletableConnector;
            theListDiagram: ^ListDiagram;
            thePatternDeclDiagram: ^PatternDeclDiagram;
            theSimpleNode: ^theListDiagram.SimpleNode;
            theDiagramNode: ^theListDiagram.DiagramNode;
            thePatternNode: ^theListDiagram.PatternNode;
            theObject: ^DesignObject;
            theNode: ^PatternDiagramNode
         do
            (if current## <= deletableConnector## then
                current[]->theConn[];
                THIS(title)[]->theConn.getOtherEnd->theObject[];
                (if theObject[] = none then
                    theSurroundBox->theConn.getOtherEnd->theObject[]
                if);
                (if theObject[] <> none then
                    theObject[]->BoxToNode->theObject[];
                    (if theObject## <= PatternDiagramNode## then
                        theObject[]->theNode[];
                        theNode.theDiagram->theListDiagram[];
                        (if current## <= PrefixConnector## then
                            (if current[] =
                            theListDiagram.titleNode.thePrefixConn then
                                theListDiagram[]->thePatternDeclDiagram[];
                                none ->thePatternDeclDiagram.thePrefix[];
                                none ->theListDiagram.titleNode.thePrefixConn;
                                theListDiagram.titleNode.unmakeRegion;
                                theListDiagram.theParentNode->theNode[];
                                theNode.theDiagram->theListDiagram[];
                                theNode[]->theDiagramNode[];
                                none ->theDiagramNode.thePrefix[]
                            if)
                        if)
                    if)
                if)
            if)
         #)
   if);
   getRegionList->regions[];
   (if regions[] <> none then
       regions.scan
         (# theNode: ^UserDataNode
         do
            (if (not (current## <= PatternDiagramNode##)) and
            (current## <= UserDataNode##) then
                current[]->theNode[];
                theNode.getConnectors->connectors[];
                (if connectors[] <> none then
                    connectors.scan
                      (#
                         theAggregationConnector: ^AggregationConnector;
                         theListDiagram: ^ListDiagram;
                         theSimpleNode: ^theListDiagram.SimpleAttributeDecl;
                         left,right: ^theAggregationConnector.Role
                      do
                         (if current## <= AggregationConnector## then
                             current[]->theAggregationConnector[];
                             (if theNode## <= theAggregationConnector.Role##
                              then
                                 (
                                 (
                                 theAggregationConnector.leftRole
                                   ->theAggregationConnector.lr[]).
                                 thePatternDiagramNode).theDiagram
                                   ->theListDiagram[];
                                 (
                                 theAggregationConnector.leftRole
                                   ->theAggregationConnector.lr[]).
                                 thePatternDiagramNode->theSimpleNode[];
                                 none ->theSimpleNode.theAggregationConnector;
                                 theAggregationConnector.leftRole
                                   ->theAggregationConnector.lr[]->left[];
                                 theAggregationConnector.rightRole->right[];
                                 left.delete;
                                 right.delete
                              else
                                 'AggregationConnector '->stdErr.puttext;
                                 theAggregationConnector.id->stdErr.putint;
                                 ' with non-role end '->stdErr.puttext;
                                 theNode.id->stdErr.putint;
                                 stderr.newline
                             if)
                         if)
                      #)
                if)
            if)
         #)
   if);
   
#)  

-- ListDiagramOnDoubleClick: Descriptor --
(# 
do (*  localNodes.abstractAll;
    False->proceed; *) (*don't let design/OA proceed in normal way*) 
#)  

-- ListDiagramAbstract: Descriptor --
(#
   connectorList: ^ObjectList;
   theNode: ^PatternDiagramNode;
   theListDiagram: ^ListDiagram
do
   70
     ->trace
       (# 
       do 'Abstract on title = %s\n'->t.putformat (#  do titletext[]->s #)
       #);
   localNodes.abstractAll;
   (if theParentNode <> none then
       theParentNode->theNode[];
       theNode.theDiagram->theListDiagram[];
       (if theNode## <= theListDiagram.PatternNode## then
           getConnectors->connectorList[];
           (if connectorList[] <> none then
               connectorList.scan
                 (# theConn: ^AggregationConnector; x,y,w,h: @integer
                 do
                    (if current## <= AggregationConnector## then
                        current[]->theConn[];
                        (if not gppProp.showAttributes then
                            false->theConn.visible
                        if);
                        (theConn.rightRole->theConn.rr[]).unmakeRegion;
                        (theParentNode).geometry->(x,y,w,h);
                        (x-w div 2,y)->(theConn.rightRole->theConn.rr[]).center;
                        theParentNode
                          ->
                            (theConn.rightRole->theConn.rr[]).
                            thePatternDiagramNode;
                        theParentNode
                          ->(theConn.rightRole->theConn.rr[]).createRegion
                    if)
                 #)
           if)
       if)
   if);
   Delete;
   70->trace (#  do 'Abstract on title END'->t #);
   
#)  

-- ListDiagramAbstractRecursively: DoPart --
do localNodes.scan (#  do current.abstract #); INNER abstractRecursively;   

-- ListDiagramDetail: Descriptor --
(# lnode: ^PatternDiagramNode; lastNode: ^AbstractNode; 
do
   (if switch[60]
    // true then 'title detail all attribute decls...'->putline; 
   if);
   false->doScrollIntoView;
   localNodes.scan
     (#  do current.detail; current[]->lnode[] #);
   true->doScrollIntoView;
   (if lnode[] <> none then
       (if (*could be a SlotNode*) lnode## <= AbstractNode## then
           lnode[]->lastNode[];
           (if lastNode.currentDecomposDiagram <> none then
               (lastNode.currentDecomPosdiagram).titleNode[]
                 ->THIS(OADPage).scrollIntoView;
               
            else
               'lastNode.currentDecomposDiagram is NONE'->screen.putline; 
           if)
       if)
   if);
   
#)  

-- ListDiagramDetailRecursively: DoPart --
do
   false->doScrollIntoView;
   localNodes.scan
     (# theAbstractNode: ^AbstractNode
     do
        current.detail;
        (if current## <= AbstractNode## then
            current[]->theAbstractNode[];
            (if theAbstractNode.currentDecomposDiagram <> none then
                (theAbstractNode.currentDecomposDiagram).titleNode.
                  detailRecursively
            if)
        if)
     #);
   true->doScrollIntoView;
   INNER detailRecursively;
     

-- ListDiagramOverview: DoPart --
do
     (# theListDiagram: ^ListDiagram
     do
        (if theParentNode <> none then
            (theParentNode).theDiagram->theListDiagram[];
            theListDiagram.localNodes.scan
              (# 
              do (if current[] <> theParentNode then current.abstract if)
              #)
        if)
     #);
   INNER overview  

-- updateMaxWH: Descriptor --
(# w,h,origX,origY,origW,origH: @integer
do
   thePatternDiagramNode.geometry->(origX,origY,origW,origH);
   false->thePatternDiagramNode.theText.wrap;
   thePatternDiagramNode.FitToText;
   thePatternDiagramNode.size->(w,h);
   (w,MaxWidth)->max->MaxWidth;
   (h,MaxHeight)->max->MaxHeight;
   (GppProp.width,MaxWidth)->max->MaxWidth;
   (GppProp.height,MaxHeight)->max->MaxHeight;
   (origX,origY,origW,origH)->thePatternDiagramNode.geometry;
   true->thePatternDiagramNode.theText.wrap;
   (if thePatternDiagramNode[] = titleNode[] then
       textJust.Centered->thePatternDiagramNode.theText.just
   if)
#)  

-- ListDiagramShowCompartments: DoPart --
do INNER showCompartments  

-- OADDiagramNew: Descriptor --
(# 
do
(* save THIS(OADDiagram) with the ASTindex of the
 * descriptor it is generated from so it can be located later
 *)
   (if theDescriptor[] <> none then
       (theDescriptor.index,theDescriptor.frag.fullname,THIS(OADDiagram)[])
         ->PatternDiagrams.theList.insertPD;
       
   if);
   titleNode.concludeDisplay
#)  

-- OADDisplayDeclarations: Descriptor --
(# x,y,w,h: @Integer; 
do
   (if theAttributes[]
    // none then (* it is a non-terminal: display it as such *)
       'DisplayDeclarations: ATTRIBUTES IS NONE'->putline; 
    else
   (* (if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
    [* first display simple declarations like references (static and dynamic)
    * then display pattern and virtual declarations;
    *]
    titleNode.geometry->(x,y,w,h);
    x->startpos.x;
    startpos.y+(2*gppProp.DownOnPage)->startpos.y;
    
    if); *)
       theAttributes.scan
         (# 
         do
            (if not (current.kind = mps.kinds.optional) then
                (current[],startpos)->DisplayAST->startpos
            if)
         #);
       LocalNodes.adjustSizes
   if)
#)  

-- OADDiagramPopupAttributeOnSelect: DoPart --
do newAttribute  

-- OADDiagramPopupOperationOnSelect: DoPart --
do newOperation  

-- OADDiagramPopupLocalClassOnSelect: DoPart --
do newLocalClass  

-- OADDiagramPopupNewSubMenuOpen: DoPart --
do attributeItem.open;
   'Attribute...'->attributeItem.name;
   ('a',true,true,false)->attributeItem.specialKey;
   attributeItem[]->append;
   operationItem.open;
   ('o',true,true,false)->operationItem.specialKey;
   'Operation...'->operationItem.name;
   operationItem[]->append;
   localClassItem.open;
   ('l',true,true,false)->localClassItem.specialKey;
   'Local Class...'->localClassItem.name;
   localClassItem[]->append  
      
-- OADDiagramPopupNewItemOpen: DoPart --
do newSubMenu.open; newSubMenu[]->subMenu  

-- OADDiagramPopupCutOnStatus: DoPart --
do
   (theParentNode <> none ) and (not (theSifEditor).sifisEditingMode) and
   (not (theSifEditor).isReadOnly)->value  

-- OADDiagramPopupCutOnSelect: DoPart --
do
     (# anAST: ^mps.ast
     do
        theParentNode->currentObject;
        (titleNode[],theParentNode)->changedFocus;
        (theParentNode).getASTNode->anAST[];
        (if anAST[] <> none then
            (anAST[],1)->(theSifEditor).changeFocus;
            true->doOADPaste;
            false->doObjectPaste;
            false->pasteGroupWithOAD;
            enablePaste;
            ((theParentNode).theSifEditor).cut
        if)
     #)  

-- OADDiagramPopupCopyOnStatus: DoPart --
do theParentNode <> none ->value  

-- OADDiagramPopupCopyOnSelect: DoPart --
do
     (# anAST: ^mps.ast
     do
        theParentNode->currentObject;
        (titleNode[],theParentNode)->changedFocus;
        (theParentNode).getASTNode->anAST[];
        (if anAST[] <> none then
            (anAST[],1)->(theSifEditor).changeFocus;
            true->doOADPaste;
            false->doObjectPaste;
            false->pasteGroupWithOAD;
            enablePaste;
            ((theParentNode).theSifEditor).copy
        if)
     #)  

-- OADDiagramPopupPasteOnStatus: DoPart --
do
   (theParentNode <> none ) and (not (theSifEditor).sifisEditingMode) and
   (not (theSifEditor).isReadOnly)->value  

-- OADDiagramPopupPasteOnSelect: DoPart --
do
     (# x,y: @integer; anAST: ^mps.ast; ld: ^listDiagram
     do
        center->(x,y);
        theParentNode->currentObject;
        (titleNode[],theParentNode)->changedFocus;
        (theParentNode).getASTNode->anAST[];
        (if anAST[] <> none then
            (anAST[],1)->(theSifEditor).changeFocus;
            ((theParentNode).theSifEditor).paste;
            (if currentFocus[] <> none then
                currentFocus.detail;
                currentFocus.theDiagram->ld[];
                (if currentFocus[] = ld.titleNode[] then
                    (x,y)->currentFocus.center
                if)
            if)
        if)
     #)  

-- OADDiagramPopupOpenSubEditorOnSelect: DoPart --
do getASTNode->(theSifEditor).openSubeditor  

-- OADDiagramPopupOpen: DoPart --
do
   sep1.open;
   sep1[]->append;
   
   newItem.open;
   'New'->newItem.name;
   newItem[]->append;
   sep2.open;
   sep2[]->append;
   cutItem.open;
   'Cut'->cutItem.name;
   'x'->cutItem.key;
   cutItem[]->append;
   copyItem.open;
   'Copy'->copyItem.name;
   'c'->copyItem.key;
   copyItem[]->append;
   pasteItem.open;
   'Paste'->pasteItem.name;
   'v'->pasteItem.key;
   pasteItem[]->append;
   sep3.open;
   sep3[]->append;
   openSubEditorItem.open;
   'Open Codeeditor'->openSubEditorItem.name;
   openSubEditorItem[]->append;
   INNER open  

-- OADDiagramOnRemove: Descriptor --
(# 
do (* remove the diagram from the list of patterndiagrams on the page *)
   (if theDescriptor[] <> none then
   (*if this is the last diagram on the page close the page *)
       (theDescriptor.index,theDescriptor.frag.fullname)
         ->PatternDiagrams.theList.deletePD;
       (if PatternDiagrams.theList.size = 0 then
           theFragmentNode
             ->theGroupPage.currentObject (#  do true->autoPan #);
           true->theGroupPage.visible;
           close
       if)
    else
       PatternDiagrams.theList.find
         (# predicate::  (#  do THIS(OADDiagram)[] = current.e[]->value #)
         do
            current[]->patternDiagrams.theList.at
              ->patternDiagrams.theList.delete
         #)
   if)
#)  

-- OADDisplay: Descriptor --
(#
   p: ^localNodes.theCellType;
   e: ^LocalNodes.element;
   det: ^AbstractNode;
   x,y,w,h,tx,ty,tw,th: @Integer;
   theBox: ^SurroundBox
do
   (if theDescriptor[] = none then
       60->trace (#  do 'theDescriptor is NONE '->T #); 
   if);
   CalculateNextCenter->theCenter;
   (if theDescriptor[] <> none then
       theDescriptor.index->titleNode.astIndex;
       60
         ->trace
           (# 
           do
              'OADDisplay: %i ->astindex\n'
                ->T.putFormat (#  do titlenode.astIndex->i #)
           #)
   if);
   INNER Display;
   &SurroundBox[]->theBox[];
   (if gppProp.DiagramPositioning
    // gppProp.AllManual then
       cursor.Picture->cursor.set;
       THIS(OADDiagram)[]->patterndiagrams.interactiveNewDiagram[]
    // gppProp.AllAuto then
       (if switch[70] then
           '******** diagrambody-OADDisplay 4 calling new with ********'
             ->putline;
           'x: '->putText;
           theCenter.x->putint;
           newLine;
           'y: '->putText;
           theCenter.y->putint;
           newLine;
           'w: '->putText;
           gppProp.titlewidth->putint;
           newLine;
           'h: '->putText;
           gppProp.height*2->putint;
           newLine;
           
       if);
       (theCenter.x,theCenter.y,gppProp.titlewidth*2,gppProp.height,
        shape.Rectangle)->theBox.new;
       theBox[]->theSurroundBox;
       (theCenter.x,theCenter.y,gppProp.titlewidth*2,gppProp.height,
        titleNode.defaultShape)->titleNode.new
    else
       'OADDisplay: No DiagramPositioning mode?!'->putline
   if);
   titleNode.geometry->(tx,ty,tw,th);
   (if localNodes.empty or (not gppProp.showAttributes) then
       (tx,ty,tw,th)->theBox.geometry
    else
       (tx,ty-gppProp.height div 2+((localNodes.size+1)*gppProp.height) div 2,
        tw,(localNodes.size+1)*gppProp.height)->theBox.geometry
   if);
   titleNode[]->theBox.CreateRegion;
   (if false then yellow3->titleNode.fillType if);
   sortAttributesAndOperations;
   (if switch[60] then
       'OADDisplay: surroundBox.getParent%s\n'
         ->putformat
           (# parent: ^designobject
           do
              theBox.getParent->parent[];
              (if parent[] <> none then '<>none'->s else '=none'->s if)
           #)
   if);
   (*(if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
    (if localNodes.empty
    // true then (theCenter,titleNode.Center)->UpdateNextFree;
    else
    (#
    pos1,pos2: @Point;
    x,y,w,h,dist: @Integer;
    no: @Integer;
    lastSimple, [* last node in simple pattern diagram *] firstTree,
    [* first node in tree pattern diagram *] lastTree: [* last node in tree pattern diagram *] ^PatternDiagramNode;
    
    do
    (if localNodes.empty
    // false then [* update for the next diagram *]
    localNodes.last->p[]; p.elm[]->e[]; e.Center->pos1;
    else
    titleNode.Center->pos1;
    if);
    pos1.x+gppProp.DownOnPage->pos1.x;
    (theCenter,pos1)->UpdateNextFree;
    titleNode[]->lastSimple[];
    localNodes.scan [* count the nodes in tree position *]
    (# d: ^DiagramNode;
    do
    (if current## <= DiagramNode##
    // true then
    current[]->d[];
    (if d.theTreeConn[]
    // none then current[]->lastSimple[]; [* in simple diagram *]
    else
    (if firstTree[]
    // none then current[]->firstTree[]
    if);
    current[]->lastTree[];
    no+1->no;
    
    if)
    if)
    #);
    (if true [* calculate adjustment *]
    // (no > 1) then [* adjust them *]
    firstTree.Center->pos1;
    lastTree.Center->pos2;
    (pos2.x-pos1.x) div 2->dist;
    lastSimple.Center->pos2;
    dist-(pos2.x-pos1.x)->dist;
    
    // (no = 1) then [* center the one *]
    lastSimple.center->pos1;
    localNodes.last->p[];
    p.elm[]->e[];
    e.Center->pos2;
    pos2.x-pos1.x->dist;
    
    else
    [* no subnodes in tree *]
    
    if);
    localNodes.scan [* adjust the subnodes *]
    (# d: ^DiagramNode;
    do
    (if current## <= DiagramNode##
    // true then
    current[]->d[];
    (if d.theTreeConn[]
    // none then [* in simple pattern diagram *] (0,0)
    ->
    current.
    ConcludeDisplay;
    
    else
    [* in tree *]
    (dist,0)->current.ConcludeDisplay;
    if)
    if)
    #)
    #)
    if);
    
    else
    [* just make a simple patterndiagram of all the nodes
    * update NextFreeLine to the y coordinate of the last node in
    * plus offset *]
    (if localNodes.empty
    // true then (theCenter,titleNode.Center)->UpdateNextFree;
    else
    localNodes.scan
    (#  do (0,0)->current.ConcludeDisplay #);
    localNodes.Last->p[];
    p.elm[]->e[];
    (theCenter,e.Center)->UpdateNextFree
    if)
    if);*)
   (*(if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
    (if PatternDiagrams.Detailer[] <> none
    // true then
    PatternDiagrams.Detailer[]->det[];
    (if det.theTreeConn[]
    // none then
    [* the Detailer is part of a blockDiagram and not a tree *]
    (if switch[18] then
    '******** diagrambody-OADDisplay 1 calling new with ********'
    ->putline;
    'x: '->putText;
    theCenter.x->putint;
    newLine;
    'y: '->putText;
    theCenter.y->putint;
    newLine;
    'w: '->putText;
    gppProp.titlewidth->putint;
    newLine;
    'h: '->putText;
    gppProp.height*2->putint;
    newLine;
    
    if);
    (theCenter.x,theCenter.y,gppProp.titlewidth,gppProp.height*2,
    titleNode.defaultShape)->titleNode.new;
    
    else
    [* the new diagram is connected to an existing tree diagram *]
    PatternDiagrams.Detailer.geometry->(x,y,w,h);
    (if switch[18] then
    '******** diagrambody-OADDisplay 2 calling new with ********'
    ->putline;
    'x: '->putText;
    x->putint;
    newLine;
    'y: '->putText;
    y->putint;
    newLine;
    'w: '->putText;
    w->putint;
    newLine;
    'h: '->putText;
    h->putint;
    newLine;
    
    if);
    (x,y,w,h,titleNode.defaultShape)->titleNode.new;
    PatternDiagrams.Detailer[]->titleNode.CreateRegion;
    true->PatternDiagrams.Detailer.moveable;
    false->titleNode.selectable;
    false->titleNode.borderVisible;
    titleNode.theText.clear;
    PatternDiagrams.Detailer[]->CurrentObject;
    
    if);
    
    else
    (if switch[18] then
    '******** diagrambody-OADDisplay 3 calling new with ********'
    ->putline;
    'x: '->putText;
    theCenter.x->putint;
    newLine;
    'y: '->putText;
    theCenter.y->putint;
    newLine;
    'w: '->putText;
    gppProp.titlewidth->putint;
    newLine;
    'h: '->putText;
    gppProp.height*2->putint;
    newLine;
    
    if);
    (theCenter.x,theCenter.y,gppProp.titlewidth,gppProp.height*2,
    titleNode.defaultShape)->titleNode.new;
    
    if);
    
    else
    (if switch[18] then
    '******** diagrambody-OADDisplay 4 calling new with ********'->putline;
    'x: '->putText;
    theCenter.x->putint;
    newLine;
    'y: '->putText;
    theCenter.y->putint;
    newLine;
    'w: '->putText;
    gppProp.titlewidth->putint;
    newLine;
    'h: '->putText;
    gppProp.height*2->putint;
    newLine;
    
    if);
    (theCenter.x,theCenter.y,gppProp.titlewidth*2,gppProp.height,
    titleNode.defaultShape)->titleNode.new;
    
    if); *)
   (* now we can make the diagram: titleNode.new, calls onInit as callback
    * which then calls DisplayDeclarations to display the contaning decls.
    *)
   (* Now we make final adjustment (we must know the number of subnodes
    * before we can do this).
    *
    * If we make trees then we must adjust the localNodes so they
    * are centered
    *)
   (* (if localNodes.empty
    // true then (theCenter,titleNode.Center)->UpdateNextFree;
    else
    localNodes.scan
    (#  do (0,0)->current.ConcludeDisplay #);
    localNodes.Last->p[];
    p.elm[]->e[];
    (theCenter,e.Center)->UpdateNextFree
    if)*)
   
#)
(* FRAGMENTDIAGRAMS *)  

-- OADDiagramSortAttributesAndOperations: DoPart --
do
   70->trace (#  do 'SortAttributesAndOperations'->t #);
   false->repair;
   gppProp.inCompartments->localNodeOrder;
   localNodes.clear;
   attributes.scan
     (#  do current[]->localNodes.append #);
   operations.scan
     (#  do current[]->localNodes.append #);
   localClasses.scan
     (#  do current[]->localNodes.append #);
     (# x,y: @integer
     do
        titleNode.center->(x,y);
        localNodes.scan
          (#  do (x,y+gppProp.height->y)->current.center #);
        showCompartments
     #);
   true->repair  

-- OADDiagramShowCompartmets: DoPart --
do
   (if gppProp.showAttributes then
       false->repair;
       (if not attributes.empty then
           (attributes.head).elm.geometry->(x,y,w,h);
           (if attributes.size > 1 then
               (attributes.last).elm.center->(x2,y2);
               (x,(y2-y) div 2+y,w,attributes.size*h)->(x,y,w,h)
           if);
           (if attributesBox = none then
               &SurroundBox[]->theBox[];
               (x,y,w,h,shape.Rectangle)->theBox.new;
               false->theBox.selectable;
               false->theBox.sizeable;
               titlenode[]->theBox.createRegion;
               (if false then yellow3->theBox.fillType if);
               theBox[]->attributesBox
            else
               (x,y,w,h)->(attributesBox).geometry
           if);
           (if false then (attributesBox).sendToBack if)
        else
           (if attributesBox <> none then
               (attributesBox).delete; none ->attributesBox
           if)
       if);
       (if not operations.empty then
           (operations.head).elm.geometry->(x,y,w,h);
           (if operations.size > 1 then
               (operations.last).elm.center->(x2,y2);
               (x,(y2-y) div 2+y,w,operations.size*h)->(x,y,w,h)
           if);
           (if operationsBox = none then
               &SurroundBox[]->theBox[];
               (x,y,w,h,shape.Rectangle)->theBox.new;
               false->theBox.selectable;
               false->theBox.sizeable;
               titlenode[]->theBox.createRegion;
               (if false then yellow3->theBox.fillType if);
               theBox[]->operationsBox
            else
               (x,y,w,h)->(operationsBox).geometry
           if);
           (if false then (operationsBox).sendToBack if)
        else
           (if operationsBox <> none then
               (operationsBox).delete; none ->operationsBox
           if)
       if);
       (if not localClasses.empty then
           (localClasses.head).elm.geometry->(x,y,w,h);
           (if localClasses.size > 1 then
               (localClasses.last).elm.center->(x2,y2);
               (x,(y2-y) div 2+y,w,localClasses.size*h)->(x,y,w,h)
           if);
           (if localClassesBox = none then
               &SurroundBox[]->theBox[];
               (x,y,w,h,shape.Rectangle)->theBox.new;
               false->theBox.selectable;
               false->theBox.sizeable;
               titlenode[]->theBox.createRegion;
               (if false then yellow3->theBox.fillType if);
               theBox[]->localClassesBox
            else
               (x,y,w,h)->(localClassesBox).geometry
           if);
           (if false then (localClassesBox).sendToBack if)
        else
           (if localClassesBox <> none then
               (localClassesBox).delete; none ->localClassesBox
           if)
       if);
       (if false then localNodes.scan (#  do current.bringToFront #) if);
       70
         ->trace
           (# 
           do
              'after showCompartments: attributesBox=(%i,%i,%i,%i) operationsBox=(%i,%i,%i,%i) localClassesBox=(%i,%i,%i,%i)'
                ->putformat
                  (# 
                  do
                     (if attributesBox <> none then
                         (attributesBox).geometry->(i,i,i,i)
                      else
                         (0,0,0,0)->(i,i,i,i)
                     if);
                     (if operationsBox <> none then
                         (operationsBox).geometry->(i,i,i,i)
                      else
                         (0,0,0,0)->(i,i,i,i)
                     if);
                     (if localClassesBox <> none then
                         (localClassesBox).geometry->(i,i,i,i)
                      else
                         (0,0,0,0)->(i,i,i,i)
                     if)
                  #)
           #);
       true->repair
    else
       TitleNode.geometry->(x,y,w,h);
       (if attributesBox <> none then
           (x,y,w,h)->(attributesBox).geometry
       if);
       (if operationsBox <> none then
           (x,y,w,h)->(operationsBox).geometry
       if);
       (if localClassesBox <> none then
           (x,y,w,h)->(localClassesBox).geometry
       if)
   if)  

-- OADDiagramEditAttribute: DoPart --
do
     (# theDialog: ^private.attributeDialog
     do &private.attributeDialog[]->theDialog[]; theNode[]->theDialog.open
     #)  

-- OADDiagramEditOperation: DoPart --
do
     (# theDialog: ^private.operationDialog
     do &private.operationDialog[]->theDialog[]; theNode[]->theDialog.open
     #)  

-- OADDiagramEditLocalClass: DoPart --
do
     (# theDialog: ^private.localClassDialog
     do &private.localClassDialog[]->theDialog[]; theNode[]->theDialog.open
     #)  

-- OADDiagramNewAttribute: DoPart --
do
     (# theDialog: ^private.attributeDialog
     do &private.attributeDialog[]->theDialog[]; theDialog.open
     #)  

-- OADDiagramNewOperation: DoPart --
do
     (# theDialog: ^private.operationDialog
     do &private.operationDialog[]->theDialog[]; theDialog.open
     #)  

-- OADDiagramNewLocalClass: DoPart --
do
     (# theDialog: ^private.localClassDialog
     do &private.localClassDialog[]->theDialog[]; theDialog.open
     #)  

-- OADDiagramPrivate: Descriptor --
(#
   dialogWindow: theUi.window
     (#
        theTabStops: @tabStops;
        okBtn: @dialogBtn
          (#
             open::<  (#  do 'OK'->label; (60,20)->size; INNER #);
             eventHandler::  (# onMouseUp::  (#  do onOK #) #)
          #);
        cancelBtn: @dialogBtn
          (#
             open::<  (#  do 'Cancel'->label; (60,20)->size; INNER #);
             eventHandler::  (# onMouseUp::  (#  do onCancel #) #)
          #);
        mainCanvas: @mainCanvasDesc;
        mainCanvasDesc:< canvas
          (#
             open::< 
               (# 
               do
                  TRUE->border.visible;
                  theUI.borderStyles.etchedIn->border.style;
                  INNER open
               #)
          #);
        dialogBtn: pushbutton
          (#
             eventHandler::< 
               (#
                  onKeyDown::< 
                    (# 
                    do
                       (if ch = ascii.ht then
                           (if shiftKey then
                               - 1->theTabStops.onTab
                            else
                               1->theTabStops.onTab
                           if)
                       if)
                    #)
               #)
          #);
        dialogTextField: textField
          (#
             eventHandler::< 
               (#
                  onBeforeChange::< 
                    (# t: ^text; ch: @char
                    do
                       theText->t[];
                       (if t[] <> none then
                           (if t.length = 1 then
                               t.reset;
                               t.get->ch;
                               (if ch
                                // ascii.cr // ascii.nl then
                                   onOK; false->allow
                                // ascii.esc then
                                   onCancel; false->allow
                                // ascii.ht then
                                   1->theTabStops.onTab; false->allow
                               if)
                           if)
                       if)
                    #)
               #)
          #);
        onOK:< (#  do INNER onOK #);
        onCancel:< (#  do INNER onCancel; THIS(dialogWindow).close #);
        resizeable::  (#  do false->value #);
        eventhandler::< 
          (# onAboutToClose::<  (#  do false->okToClose #) #);
        open::< 
          (# 
          do
             okBtn.open; cancelBtn.open; mainCanvas.open; INNER open; showModal
          #)
     #);
   attributeDialog: dialogWindow
     (#
        theSimpleNode: ^SimpleNode;
        open::< 
          (#
             theCom: ^mps.comment;
             dynItem: ^betaGram.DynamicItem;
             statItem: ^betaGram.StaticItem;
             indexText: @text;
             help: ^text
          enter theSimpleNode[]
          do
             'Attribute'->title;
             (400,200)->size;
             (if theSimpleNode[] <> none then
                 theSimpleNode.theName->toStyledText
                   ->mainCanvas.nameEdit.contents;
                 (if theSimpleNode.theReferenceSpec.symbol =
                 betaGram.DynamicItem then
                     true->mainCanvas.referenceTypeGroupBox.dynamicRadio.state;
                     theSimpleNode.theReferenceSpec[]->dynItem[];
                     (mps[],(dynItem.getAttributeDenotation).frag[],
                      dynItem.getAttributeDenotation,indextext[],none
                      (*streamName[]*) ,80,0,false (*abstractPresentation*) ,
                      false (*showSemanticErrors*) ,false (*includeComments*) ,
                      false,false,false,false,'',false (*onlyProperties*) ,
                      false,false (*
                                   test*) )->ppFragment;
                     (1,indexText.length-3)->indexText.sub->toStyledText
                       ->mainCanvas.typeEdit.contents
                  else
                     (if theSimpleNode.theReferenceSpec.symbol =
                     betaGram.StaticItem then
                         true
                           ->mainCanvas.referenceTypeGroupBox.staticRadio.state;
                         theSimpleNode.theReferenceSpec[]->statItem[];
                         (mps[],(statItem.getObjectSpecification).frag[],
                          statItem.getObjectSpecification,indextext[],none
                          (*streamName[]*) ,80,0,false (*abstractPresentation*)
                          ,false (*showSemanticErrors*) ,false
                          (*includeComments*) ,false,false,false,false,'',false
                          (*onlyProperties*) ,false,false (*
                                                           test*) )->ppFragment;
                         (1,indexText.length-3)->indexText.sub->toStyledText
                           ->mainCanvas.typeEdit.contents
                     if)
                 if);
                 (if theSimpleNode.theDeclaration.hasComment then
                     (3,1)->theSimpleNode.theDeclaration.getSubcomment
                       ->mainCanvas.descriptionEditor.setText
                 if)
             if);
             (330,170)->okBtn.position;
             (260,170)->cancelBtn.position;
             INNER ;
             (if mainCanvas.nameEdit.length > 0 then
                 mainCanvas.nameEdit.all->mainCanvas.nameEdit.selection
             if);
             mainCanvas.nameEdit[]->theTabStops.add;
             mainCanvas.typeEdit[]->theTabStops.add;
             mainCanvas.descriptionEditor[]->theTabStops.add
          #);
        mainCanvasDesc::< 
          (#
             open::< 
               (# 
               do
                  (380,150)->size;
                  (10,10)->position;
                  nameLabel.open;
                  nameEdit.open;
                  typeLabel.open;
                  typeEdit.open;
                  descriptionEditor.open;
                  descriptionLabel.open;
                  ReferenceTypeGroupbox.open;
                  nameEdit[]->target;
                  INNER
               #);
             nameLabel: @statictext
               (#
                  open::< 
                    (# 
                    do
                       'Name:'->label; (40,13)->size; (10,10)->position; INNER
                    #)
               #);
             nameEdit: @dialogTextField
               (#
                  open::< 
                    (#  do (130,27)->size; (50,10)->position; INNER #)
               #);
             typeLabel: @statictext
               (#
                  open::< 
                    (# 
                    do
                       'Type:'->label;
                       (60,16)->size;
                       (195,10)->position;
                       INNER
                    #)
               #);
             typeEdit: @dialogTextField
               (#
                  open::< 
                    (#  do (130,27)->size; (230,10)->position; INNER #)
               #);
             descriptionEditor: @texteditor
               (#
                  open::< 
                    (#  do (220,80)->size; (140,60)->position; INNER #);
                  eventHandler:: 
                    (#
                       onKeyDown::< 
                         (# 
                         do
                            (if ch = ascii.ht then
                                (if shiftKey then
                                    - 1->theTabStops.onTab
                                 else
                                    1->theTabStops.onTab
                                if)
                            if)
                         #)
                    #);
                  setText:
                    (# t: ^text
                    enter t[]
                    do t[]->toStyledText->contents.contents
                    #)
               #);
             descriptionLabel: @statictext
               (#
                  open::< 
                    (# 
                    do
                       'Description:'->label;
                       (76,15)->size;
                       (140,45)->position;
                       INNER
                    #)
               #);
             ReferenceTypeGroupbox: @groupbox
               (#
                  open::< 
                    (# 
                    do
                       'Reference type'->title;
                       (105,95)->size;
                       (20,45)->position;
                       staticRadio.open;
                       dynamicRadio.open;
                       true->staticRadio.state;
                       INNER
                    #);
                  staticRadio: @groupRadioButton
                    (#
                       open::< 
                         (# 
                         do
                            'Static'->label;
                            (60,16)->size;
                            (15,25)->position;
                            INNER
                         #);
                       eventHandler:: 
                         (#
                            onKeyDown::< 
                              (# 
                              do
                                 (if ch = ascii.ht then
                                     (if shiftKey then
                                         - 1->theTabStops.onTab
                                      else
                                         1->theTabStops.onTab
                                     if)
                                 if)
                              #)
                         #)
                    #);
                  dynamicRadio: @groupRadioButton
                    (#
                       open::< 
                         (# 
                         do
                            'Dynamic'->label;
                            (70,16)->size;
                            (15,55)->position;
                            INNER
                         #);
                       eventHandler:: 
                         (#
                            onKeyDown::< 
                              (# 
                              do
                                 (if ch = ascii.ht then
                                     (if shiftKey then
                                         - 1->theTabStops.onTab
                                      else
                                         1->theTabStops.onTab
                                     if)
                                 if)
                              #)
                         #)
                    #)
               #)
          #);
        getParseText:
          (# t: @text
          do
             (if not (mainCanvas.nameEdit.contents).empty then
                 mainCanvas.nameEdit.contents->t.puttext
              else
                 '<<NameDecl>>'->t.puttext
             if);
             ':'->t.puttext;
             (if not (mainCanvas.descriptionEditor.contents.contents).empty then
                 '(* '->t.puttext;
                 mainCanvas.descriptionEditor.contents.contents->t.puttext;
                 ' *)'->t.puttext
             if);
             (if mainCanvas.ReferenceTypeGroupBox.staticRadio.state then
                 '@'->t.puttext
              else
                 (if mainCanvas.ReferenceTypeGroupBox.dynamicRadio.state then
                     '^'->t.puttext
                 if)
             if);
             (if not (mainCanvas.typeEdit.contents).empty then
                 mainCanvas.typeEdit.contents->t.puttext
              else
                 (if mainCanvas.ReferenceTypeGroupBox.staticRadio.state then
                     '<<ObjectSpecification>>'->t.puttext
                  else
                     (if mainCanvas.ReferenceTypeGroupBox.staticRadio.state then
                         '<<AttributeDenotation>>'->t.puttext
                      else
                         '<<referenceSpecification>>'->t.puttext
                     if)
                 if)
             if)
          exit t[]
          #);
        onOK::< 
          (# ok: @boolean
          do
             false->repair;
             gppProp.busy->gppProp.globalInteractiveMode;
             (theSimpleNode[],getParseText)->generateCode->ok;
             (if ok then
                 gppProp.noGlobalInteractiveMode->gppProp.globalInteractiveMode;
                 autosave;
                 THIS(attributeDialog).close
             if);
             true->repair
          #)
     #);
   patternDialog: dialogWindow
     (#
        thePatternNode: ^PatternNode;
        otherThanNameChanged: @boolean;
        open::< 
          (# theCom: ^mps.comment; help: ^text; commentPos: @integer
          enter thePatternNode[]
          do
             (385,275)->size;
             (235,245)->okBtn.position;
             (165,245)->cancelBtn.position;
             (if thePatternNode[] <> none then
                 thePatternNode.theName->toStyledText
                   ->mainCanvas.nameEdit.contents;
                 (if true
                  // thePatternNode## = PatternNode## then
                     true->mainCanvas.typeGB.NormalRadio.state; 3->commentPos
                  // thePatternNode## = VirtualNode## then
                     true->mainCanvas.typeGB.virtualRadio.state; 4->commentPos
                  // thePatternNode## = BindingNode## then
                     true->mainCanvas.typeGB.bindingRadio.state; 5->commentPos
                  // thePatternNode## = FinalNode## then
                     true->mainCanvas.typeGB.finalRadio.state; 4->commentPos
                  else
                 (* should not happen *)
                     3->commentPos
                 if);
                 (if thePatternNode.theDeclaration.hasComment then
                     (commentPos,1)->thePatternNode.theDeclaration.getSubcomment
                       ->mainCanvas.descriptionEditor.setText
                 if);
                 false->otherThanNameChanged
             if);
             INNER ;
             (if mainCanvas.nameEdit.length > 0 then
                 mainCanvas.nameEdit.all->mainCanvas.nameEdit.selection
             if);
             mainCanvas.nameEdit[]->theTabStops.add;
             mainCanvas.descriptionEditor[]->theTabStops.add
          #);
        mainCanvasDesc::< 
          (#
             open::< 
               (# 
               do
                  (365,205)->size;
                  (10,30)->position;
                  nameLabel.open;
                  nameEdit.open;
                  typeGB.open;
                  descriptionEditor.open;
                  statictext1.open;
                  INNER
               #);
             nameLabel: @statictext
               (#
                  open::< 
                    (# 
                    do 'Name:'->label; (36,13)->size; (5,15)->position; INNER
                    #)
               #);
             nameEdit: @dialogTextField
               (#
                  open::< 
                    (#  do (230,27)->size; (45,10)->position; INNER #)
               #);
             typeGB: @groupbox
               (#
                  open::< 
                    (# 
                    do
                       'Type'->title;
                       (365,45)->size;
                       (10,45)->position;
                       normalRadio.open;
                       virtualRadio.open;
                       bindingRadio.open;
                       finalRadio.open;
                       INNER
                    #);
                  normalRadio: @groupRadioButton
                    (#
                       open::< 
                         (# 
                         do
                            'Normal'->label;
                            (60,16)->size;
                            (10,20)->position;
                            INNER
                         #);
                       
                    #);
                  virtualRadio: @groupRadioButton
                    (#
                       open::< 
                         (# 
                         do
                            'Virtual'->label;
                            (60,16)->size;
                            (80,20)->position;
                            INNER
                         #);
                       eventHandler:: 
                         (#
                            onStateChanged:: 
                              (#  do true->otherThanNameChanged #)
                         #)
                    #);
                  bindingRadio: @groupRadioButton
                    (#
                       open::< 
                         (# 
                         do
                            'Binding'->label;
                            (63,17)->size;
                            (150,20)->position;
                            INNER
                         #);
                       eventHandler:: 
                         (#
                            onStateChanged:: 
                              (#  do true->otherThanNameChanged #)
                         #)
                    #);
                  finalRadio: @groupRadioButton
                    (#
                       open::< 
                         (# 
                         do
                            'Final Binding'->label;
                            (99,17)->size;
                            (225,20)->position;
                            INNER
                         #);
                       eventHandler:: 
                         (#
                            onStateChanged:: 
                              (#  do true->otherThanNameChanged #)
                         #)
                    #)
               #);
             descriptionEditor: @texteditor
               (#
                  open::< 
                    (#  do (365,80)->size; (10,115)->position; INNER #);
                  contentsType:: 
                    (#
                       eventHandler:: 
                         (#
                            onTextChanged:: 
                              (#  do true->otherThanNameChanged #)
                         #)
                    #);
                  eventHandler:: 
                    (#
                       onKeyDown::< 
                         (# 
                         do
                            (if ch = ascii.ht then
                                (if shiftKey then
                                    - 1->theTabStops.onTab
                                 else
                                    1->theTabStops.onTab
                                if)
                            if)
                         #)
                    #);
                  setText:
                    (# t: ^text
                    enter t[]
                    do t[]->toStyledText->contents.contents
                    #)
               #);
             statictext1: @statictext
               (#
                  open::< 
                    (# 
                    do
                       'Description:'->label;
                       (76,15)->size;
                       (10,100)->position;
                       INNER
                    #)
               #)
          #);
        getParseText:<
          (# t,indextext: @text; mainPartText: ^text
          do
             INNER getParseText;
             (if not (mainCanvas.nameEdit.contents).empty then
                 mainCanvas.nameEdit.contents->t.puttext
              else
                 '<<NameDecl>>'->t.puttext
             if);
             (if true
              // mainCanvas.typeGB.virtualRadio.state then
                 ':<'->t.puttext
              // mainCanvas.typeGB.bindingRadio.state then
                 '::<'->t.puttext
              // mainCanvas.typeGB.finalRadio.state then
                 '::'->t.puttext
              else
                 ':'->t.puttext
             if);
             (if not (mainCanvas.descriptionEditor.contents.contents).empty then
                 '(* '->t.puttext;
                 mainCanvas.descriptionEditor.contents.contents->t.puttext;
                 ' *)'->t.puttext
             if);
             (if thePatternNode[] <> none then
                 (mps[],(thePatternNode.theDeclaration.getSon2).frag[],
                  thePatternNode.theDeclaration.getSon2,indextext[],none
                  (*streamName[]*) ,80,0,false (*abstractPresentation*) ,false
                  (*showSemanticErrors*) ,true (*includeComments*) ,false,false,
                  false,false,'',false (*onlyProperties*) ,false,false
                  (*
                   test*) )->ppFragment;
                 indexText[]->t.puttext
              else
                 mainPartText[]->t.puttext
             if)
          exit t[]
          #);
        getParseName:
          (# t,indextext: @text
          do
             (if not (mainCanvas.nameEdit.contents).empty then
                 mainCanvas.nameEdit.contents->t.puttext
              else
                 '<<NameDecl>>'->t.puttext
             if)
          exit t[]
          #);
        onOK::< 
          (# ok: @boolean; theNode: ^PatternDiagramNode
          do
             false->repair;
             gppProp.busy->gppProp.globalInteractiveMode;
             (if thePatternNode[] <> none then
                 (if otherThanNameChanged then
                     (thePatternNode[],getParseText)->generateCode->ok
                  else
                     (thePatternNode[],getParseName)->generateName->ok
                 if)
              else
                 (thePatternNode[],getParseText)->generateCode->ok;
                 currentObject->theNode[];
                 INNER onOK
             if);
             (if ok then
                 gppProp.noGlobalInteractiveMode->gppProp.globalInteractiveMode;
                 autosave;
                 THIS(patternDialog).close
             if);
             true->repair
          #)
     #);
   operationDialog: patternDialog
     (#
        open::<  (#  do 'Operation'->title #);
        getParseText::<  (#  do '(# do #)'->mainPartText[] #)
     #);
   localClassDialog: patternDialog
     (#
        open::<  (#  do 'Class'->title #);
        getParseText::<  (#  do '(# #)'->mainPartText[] #);
        onOK::<  (#  do theNode.detail #)
     #);
   generateCode:
     (#
        createNewNonTerminalNode:
          (# 
          do
             (if localNodes.empty then
                 titleNode.getASTNode->keepAST[];
                 (if keepAST[] <> none then
                     (keepAST[],1)->(titleNode.theSifEditor).changeFocus
                 if);
                 (titleNode.theSifEditor).insertOptionals;
                 (if localnodes.empty then
                     (keepAST[],'<<AttributeDeclOpt>>')
                       ->(titleNode.theSifEditor).parse
                 if);
                 true->optionalsInserted;
                 currentFocus[]->oldFocus[];
                 (LocalNodes.head).elm[]->currentFocus[]->currentObject;
                 currentFocus[]->theNonTerminalNode[];
                 (theNonTerminalNode.unExp[],1)
                   ->(currentFocus.theSifEditor).changeFocus
              else
                 currentFocus[]->oldFocus[];
                 (LocalNodes.last).elm[]->currentFocus[]->currentObject;
                 currentFocus.getASTNode->anAST[];
                 (if anAST[] <> none then
                     (anAST[],1)->(currentFocus.theSifEditor).changeFocus
                  else
                     (if currentFocus## <= nonTerminalNode## then
                         currentFocus[]->theNonTerminalNode[];
                         (theNonTerminalNode.unExp[],1)
                           ->(currentFocus.theSifEditor).changeFocus
                      else
                         (if currentFocus## <= SlotNode## then
                             currentFocus[]->theSlotNode[];
                             (theSlotNode.unExp[],1)
                               ->(currentFocus.theSifEditor).changeFocus
                         if)
                     if)
                 if);
                 (currentFocus.theSifEditor).after
             if)
          #);
        parseErrorText: ^text;
        help: @text;
        keepAST,anAST: ^mps.ast;
        optionalsInserted,ok,allOK: @boolean;
        theNonTerminalNode: ^nonterminalNode;
        theSlotNode: ^slotNode;
        errorPos: @integer;
        dn: ^DiagramNode;
        t: ^text;
        x,y: @integer;
        detailed: @boolean
     enter (dn[],t[])
     do
        (if dn[] <> none then
            currentFocus[]->oldFocus[];
            (if dn.currentDecomposDiagram <> none then
                true->detailed;
                (dn.currentDecomposDiagram).titleNode.center->(x,y)
            if);
            dn[]->currentFocus[]->currentObject;
            (dn.theDeclaration[],t)->(dn.theSifEditor).parse
              ->(ok,errorPos,parseErrorText[]);
            (if not ok then
                'Parse error. Trying to parse:\n\n%s\n\nError:\n%s'
                  ->help.putformat (#  do t[]->s; parseErrorText[]->s #);
                help[]->alertUser
             else
                (if detailed then
                    (if currentFocus[] <> none then
                        currentFocus.detail;
                        (x,y)->(currentFocus.theDiagram).titleNode.center
                    if)
                if);
                true->allOK
            if)
         else
            createNewNonTerminalNode;
            (if currentFocus## <= NonTerminalNode## then
                currentFocus[]->theNonTerminalNode[];
                (theNonTerminalNode.unExp[],t)
                  ->(theNonTerminalNode.theSifEditor).parse
                  ->(ok,errorPos,parseErrorText[]);
                (if not ok then
                    'Parse error. Trying to parse:\n\n%s\n\nError:\n%s'
                      ->help.putformat
                        (#  do t[]->s; parseErrorText[]->s #);
                    help[]->alertUser
                 else
                    true->allOK
                if)
             else
                'unexpected last node in diagram %s\n'
                  ->stdErr.putformat (#  do titletext[]->s #);
                true->allOK
            if);
            (if ok and optionalsInserted then
                (if keepAST[] <> none then
                    (keepAST[],1)->(titleNode.theSifEditor).changeFocus
                if);
                (titleNode.theSifEditor).removeOptionals
            if)
        if)
     exit allOK
     #);
   generateName:
     (#
        dn: ^DiagramNode;
        t,parseErrorText: ^text;
        errorPos: @integer;
        help: @text;
        ok,allOK: @boolean
     enter (dn[],t[])
     do
        (if dn[] <> none then
            currentFocus[]->oldFocus[];
            dn[]->currentFocus[]->currentObject;
            (dn.theDeclaration.getSon1,t)->(dn.theSifEditor).parse
              ->(ok,errorPos,parseErrorText[]);
            (if not ok then
                'Parse error. Trying to parse:\n\n%s\n\nError:\n%s'
                  ->help.putformat (#  do t[]->s; parseErrorText[]->s #);
                help[]->alertUser
             else
                true->allOK
            if)
        if)
     exit allOK
     #);
   toStyledText:
     (# t: ^text; st: ^styledText
     enter t[]
     do &StyledText[]->st[]; t->st; 
     exit st[]
     #)
#)  

-- PatternAttDiagramDisplay: Descriptor --
(#  do (if theAST[] <> none then theAST.index->titleNode.astIndex if) #)  

-- FragmentDiagramNew: Descriptor --
(#
   w,h: @Integer;
   groupTitle: ^PatternDiagramNode;
   e: ^LocalNodes.element;
   p: ^Localnodes.theCellType;
   theDummyGroup: ^mps.fragmentgroup
do
   (theGroup).fullname->fullname;
   (if switch[70] then
       'FragmentDiagramNew: fullname=%s\n'->putformat (#  do fullname->s #)
   if);
   (*   theGroup->theDummyGroup[];
    theDummyGroup.name->mps.ExpandToFullPath->fullname; *)
   INNER New;
   PatternDiagrams.theList.scanPropertyDiagrams
     (# 
     do
        (if thisDiagram.theGroup
         // theGroup then
            (if thisDiagram.localNodes.empty
             // false then
                thisDiagram.localnodes.last->p[];
                p.elm[]->e[];
                e.geometry->(x,y,w,h);
                
             else
                thisDiagram.titleNode.geometry->(x,y,w,h); 
            if);
            thisDiagram.titleNode[]->groupTitle[];
            
        if);
        
     #);
   y+gppProp.DownOnPage->y;
   (* CalculateNextCenter -> (x,y); *)
   x-(w div 2)+(gppProp.titlewidth div 2)->x;
   (if switch[70] then
       '******** diagrambody-FragmentDiagramNew: calling new with ********'
         ->putline;
       'x: '->putText;
       x->putint;
       newLine;
       'y: '->putText;
       y->putint;
       newLine;
       'w: '->putText;
       gppProp.titlewidth->putint;
       newLine;
       'h: '->putText;
       gppProp.height->putint;
       newLine;
       
   if);
   (x,y,gppProp.titlewidth,gppProp.height,titleNode.defaultShape)
     ->titleNode.new;
   groupTitle[]->titleNode.CreateRegion;
   (0,none ,THIS(FragmentDiagram)[])->PatternDiagrams.theList.insertPD;
   
#)  

-- FragmentDiagramOnRemove: DoPart --
do
   PatternDiagrams.theList.find
     (# predicate::  (#  do THIS(FragmentDiagram)[] = current.e[]->value #)
     do current[]->patternDiagrams.theList.at->patternDiagrams.theList.delete
     #)  

-- FragmentDiagramTitleInit: Descriptor --
(# theDummyGroup: ^mps.fragmentgroup
do (* show fragments starting at low-left of the titleNode *)
   UDPrivate.UDFragmentDiagram->UserDataInit;
   UDfullname.Init;
   UDtheGroup.Init;
   gppProp.fontSize->theText.size;
   textJust.leftJustification->theText.just;
   false->BorderVisible;
   (if not initialisingSaved then
       (x-(w+1) div 2,y-((h+1) div 2))->(x,y);
       theGroup->theDummyGroup[];
       (if theDummyGroup[] <> none then
           theDummyGroup.fragmentList.scan
             (#
                f: ^mps.fragmentform;
                theRoot: ^MPS.AST;
                theNode: ^FragmentNode;
                
             do
                (if current.type = mps.formType then
                    current.f[]->f[];
                    f.root[]->theRoot[];
                    (if theRoot.symbol
                     // betaGram.DescriptorForm then
                        &DescriptorNode[]->theNode[]; 
                     // betaGram.AttributesForm then
                        &AttributesNode[]->theNode[]; 
                     // betaGram.DoPart then
                        &DoPartNode[]->theNode[]
                     else
                        'Other type'->stdErr.putline; 
                    if);
                    gppProp.height+y->y;
                    (if theNode[] <> none then
                        THIS(FragmentDiagram)[]->theNode.theDiagram;
                        ((x,y),current.f[])->theNode.display;
                        (0,0)->theNode.ConcludeDisplay
                    if);
                    
                if);
                
             #)
        else
           'FragmentDiagramTitleInit: theGroup is none!'->stdErr.putline
       if);
       'Fragments'->titleText;
       titletext->theText.set;
       ((x,y),(x,y))->UpdateNextFree;
       scanner: PatternDiagrams.theList.scanPropertyDiagrams
         (#
            x1,y1,w1,h1: @Integer;
            (* go find the property diagram of theGroup *)
            
         do
            (if thisDiagram.theGroup
             // theGroup then
                (thisDiagram.theSurroundBox).geometry->(x1,y1,w1,h1);
                (x+gppProp.width,y1+(h1 div 2)+((y-y1+(h1 div 2)) div 2)+1,
                 gppProp.width*2+20, (* width *) y-y1+gppProp.height)
                (* height *) ->(thisDiagram.theSurroundBox).geometry;
                leave scanner;
                
            if);
            
         #);
       0->MaxWidth;
       0->MaxHeight;
       titleNode[]->updateMaxWH;
       localNodes.scan
         (#  do current[]->updateMaxWH #);
       localNodes.adjustSizes
   if);
   
#)  

-- FragmentDiagramTitleDump: DoPart --
do 'FragmentDiagram.titleNode'->nodetype[]; INNER dump  

-- InsertFragmentNode: DoPart --
do
     (#
        previousNode: ^PatternDiagramNode;
        i: @Integer;
        x,y,w,h: @Integer;
        startPos: @point;
        displayNode:
          (#
             theRoot: ^MPS.AST;
             theNode: ^FragmentNode;
             dummy: ^mps.fragmentform;
             dummy2: ^mps.fragmentGroup
          do
             previousNode.geometry->(x,y,w,h);
             (x-(w+1) div 2,y-((h+1) div 2))->(x,y);
             previousNode[]->patterndiagrams.addAfterNode[];
             (if ff.type = mps.formType then
                 ff.root[]->theRoot[];
                 (if theRoot.symbol
                  // betaGram.DescriptorForm then
                     &DescriptorNode[]->theNode[]; 
                  // betaGram.AttributesForm then
                     &AttributesNode[]->theNode[]; 
                  // betaGram.DoPart then
                     &DoPartNode[]->theNode[]
                  else
                     'Other type'->putline; 
                 if);
                 gppProp.height+y->y;
                 THIS(FragmentDiagram)[]->theNode.theDiagram;
                 ((x,y),ff[])->theNode.display;
                 (0,0)->theNode.ConcludeDisplay;
                 theNode.theFragment->dummy[];
                 scanner: PatternDiagrams.theList.scanPropertyDiagrams
                   (#
                      x1,y1,w1,h1: @Integer;
                      (* go find the property diagram of theGroup *)
                      
                   do
                   (*'thisDiagram.theGroup: '->puttext;
                    (thisDiagram.theGroup).fullname->putline;
                    'ff.father: '->puttext;
                    (ff.father).fullname->putline;*)
                      thisDiagram.theGroup->dummy2[];
                      (if thisDiagram.theGroup = ff.father then
                      (* update the surroundBox of the property diagram *)
                          (thisDiagram.theSurroundBox).geometry->(x1,y1,w1,h1);
                          (x1,y1+(gppProp.height div 2),w1, (* width *) h1+
                           gppProp.height) (* height *)
                            ->(thisDiagram.theSurroundBox).geometry;
                          leave scanner;
                          
                      if);
                      
                   #);
                 
             if)
          #);
        aText: @Text;
        connectorList,inheritanceEnds: ^ObjectList;
        theTitleNode: ^theListDiagram.title;
        theListdiagram: ^ListDiagram;
        
     do
        60
          ->trace
            (# 
            do
               'Gpp ------- InsertFragmentNode: %i %s'
                 ->putformat (#  do pos->i; ff.fullname->s;  #)
            #);
        1->i;
        (if pos = 0 then titleNode[]->previousNode[]; displayNode if);
        localnodes.scan
          (# aText: @Text; 
          do
             (if switch[60] then
                 'InsertDiagramNode: examening no '->puttext;
                 i->putint;
                 ' element in localnodes - '->puttext;
                 current.thetext.get->aText;
                 aText[]->putline
             if);
             (if i
              // pos then current[]->previousNode[]; displayNode
              else
                 (if (* what about this? (current[]<>aNode[]) and *) (i > pos)
                  // true then
                     (if switch[60]
                      // true then
                         'InsertDiagramNode: move down '->puttext;
                         current.theText.get->aText;
                         aText[]->putline;
                         
                     if);
                     current.center->(x,y);
                     (x,y+gppProp.height)->current.center;
                     
                 if)
             if);
             i+1->i;
             
          #);
        (if patterndiagrams.newNode[] = none then
            'OOBS: newNode is NONE'->screen.putline; 
         else
            (if pos <> 0 then
                (patterndiagrams.newNode[],
                 patterndiagrams.addAfterNode[]->localNodes.at)
                  ->localNodes.insertAfter
             else
                (if switch[60] then
                    'InsertDiagramNode - prepending in localNodes: '->puttext;
                    patterndiagrams.newNode.theText.get->aText;
                    aText[]->putline
                if);
                patterndiagrams.newNode[]
                  ->
                    localNodes.prepend
                    (*The new node is the topmost localNode when pos=0*)
            if);
            
        if);
        none ->patterndiagrams.addAfterNode[];
        localNodes.adjustSizes;
        60->trace (#  do 'Gpp ------- InsertFragmentNode END'->t #);
        
     #)  

-- deleteFragmentNode: DoPart --
do
     (#
        dListDiagram: ^FragmentDiagram;
        dFragmentNode: ^dListDiagram.FragmentNode;
        x,y,w,h: @Integer;
        dx,dy: @Integer;
        t: @text;
        theGroup: ^mps.fragmentGroup
     do
        60
          ->trace
            (# theNode: ^PatternDiagramNode
            do
               d[]->theNode[];
               'Gpp ------- DeleteFragmentNode: %s'
                 ->t.putformat
                   (# help: @text
                   do theNode.thetext.get->help; help[]->s
                   #)
            #);
        d.theDiagram->dListDiagram[];
        d[]->dFragmentNode[];
        dListDiagram.theGroup->theGroup[];
        (if dFragmentNode.currentDecomposDiagram <> none then
            (dFragmentNode.currentDecomposDiagram).titleNode.abstract; 
        if);
        d.geometry->(dx,dy,w,h);
        scanner: localnodes.scan
          (# aText: ^Text; 
          do
             (if switch[60] then
                 'DeleteDiagramNode - current in scanner: '->puttext;
                 current.theText.get->t;
                 t[]->putline;
                 
             if);
             (if current[] = d[] then
                 d.delete
              else
                 current.center->(x,y);
                 (if y > dy then
                     (x,y-gppProp.height)->current.center;
                     (if switch[60]
                      // true then
                         'DeleteDiagramNode - element moved: '->puttext;
                         current.theText.get->t;
                         t[]->putline;
                         
                     if)
                 if)
             if)
          #);
        scanner: PatternDiagrams.theList.scanPropertyDiagrams
          (#
             x1,y1,w1,h1: @Integer;
             (* go find the property diagram of theGroup *)
             
          do
          (*'thisDiagram.theGroup: '->puttext;
           (thisDiagram.theGroup).fullname->putline;
           'ff.father: '->puttext;
           (ff.father).fullname->putline;*)
             (if thisDiagram.theGroup = theGroup[] then
             (* update the surroundBox of the property diagram *)
                 (thisDiagram.theSurroundBox).geometry->(x1,y1,w1,h1);
                 (x1,y1-(gppProp.height div 2),w1, (* width *) h1-
                  gppProp.height) (* height *)
                   ->(thisDiagram.theSurroundBox).geometry;
                 leave scanner;
                 
             if);
             
          #);
        (if switch[60] then 'DeleteDiagramNode end of scanner'->putline if);
        d[]->localnodes.at->localnodes.delete;
        0->MaxWidth;
        0->MaxHeight;
        titleNode[]->updateMaxWH;
        localNodes.scan
          (#  do current[]->updateMaxWH #);
        localNodes.adjustSizes;
        60->trace (#  do 'Gpp ------- DeleteFragmentNode END'->t #);
        
     #)  

-- OOADDiagramPopupNewOnStatus: DoPart --
do
   (not (theSifEditor).sifisEditingMode) and (not (theSifEditor).isReadOnly)
     ->value  

-- OOADDiagramOpenSubEditorOnStatus: DoPart --
do
   (theParentNode <> none ) and (not (theSifEditor).sifisEditingMode) and
   (not (theSifEditor).isReadOnly)->value  

