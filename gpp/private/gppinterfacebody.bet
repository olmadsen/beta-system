ORIGIN 'diagramattributes';
(* switch
 * 1  = general debugging
 * 21 = IndexIDList
 * 22 = AstReplaced
 *)
INCLUDE 'objectgppproperties'
        '~beta/designenv/v1.5/private/userdatabody';
-- IndexIDListInsert: DescriptorForm --
(#
do
   (if switch[21]
    // true then
       '%21GPP: Insert element indexed: '->screen.puttext;
       a->screen.putint;
       screen.newline;
   if)
#)  

-- ASTToNode: DescriptorForm --
(#
do
   (if switch[21] then 'ASTtoNode: '->putText if);
   (if anAST[]
    // none then 'ASTtoNode: anAST is none!'->putLine;
    else
       (if switch[21] then anAST.index->putInt; if);
       search:
       anAST.index
         ->indexIDList.scan
           (#
           do
              currentNode[]->theNode[];
              (if theNode.getFragment
               // none then
                  'ASTtoNode: theNode.getFragment is none!'->putLine;
               else
                  (if
                  (theNode.getFragment).fullName->(anAST.frag.fullname).equal
                   then
                      leave search
                  if)
              if);
           #);
       (if switch[21] then
           ' return: '->putText;
           (if theNode[]
            // none then 'none'->putLine
            else
               theNode.id->putInt; newLine
           if);
       if)
   if);
#)  

-- ASTToNodeListUpdate: DescriptorForm --
(# ff: ^FragmentForm; oldASTName: ^Text;
do
   (if switch[21] then 'ASTtoNodeListUpdate: '->putText; if);
   (if oldAST[]
    // none then 'ASTtoNodeListUpdate: oldAST is none!'->putLine;
    else
       (if switch[21] then oldAST.index->putInt; ' '->put; if);
       (if newAST[]
        // none then 'ASTtoNodeListUpdate: newAST is none!'->putLine;
        else
           (if switch[21] then newAST.index->putInt; if);
           search:
           oldAST.index
             ->indexIDList.scan
               (#
               do
                  currentNode[]->theNode[];
                  (if theNode.getFragment
                   // none then
                      'ASTtoNodeListUpdate: theNode.getFragment is none!'
                        ->putLine;
                   else
                      theNode.getFragment->ff[];
                      oldAST.frag.fullname->oldASTName[];
                      (if ff.fullname->oldASTName.equal then
                          newAst.Index->indexIDList.impl[i]; leave search
                      if)
                  if);
               #)
       if);
       (if switch[21] then
           ' return: '->putText;
           (if theNode[]
            // none then 'none'->putLine
            else
               theNode.id->putInt; newLine
           if);
       if);
   if)
#)  

-- GppPromptForText: DescriptorForm --
(# status: @Text; prompt: [1] @char; answerRep: [64] @Char; t: @Text
do
   message->prompt;
   (if (prompt,@@ answerRep[1])->DSUIGetString then
       @@ answerRep[1]->cStringToCharRep->t; t.copy->confirm
    else
       cancel
   if)
#)  

-- InitGPP: DescriptorForm --
(#
do
   betaGram.init;
   metaGram.init;
   '~beta/grammars/beta/v2.4/beta-parser.btab'->expandToFullPath
     ->betaGram.parser.initialize;
   ('~beta/grammars/beta/v2.4/beta-meta-beta'->expandToFullPath,screen[])
     ->top.open->betaGram.grammarAST[];
#)  

-- OADDocumentInit: DescriptorForm --
(# (* setup the DesignOA menus we like to use in OADDocument *)
do (* DocEditMenu.init; *)
   INNER onInit;
   (UserMenu7,'Page')->PageMenu.init;
   (UserMenu3,'Options')->OptionsMenu.init;
   (UserMenu4,'Display')->DisplayMenu.init;
   (UserMenu5,'Object')-> (*kja&toby 1.9.94*) ObjectMenu.init;
   MenuId.CreateMenu->DisplayMenu.insertBefore;
   true->OGppProp.StaticRefCheck;
   true->OGppProp.LocalIncludeScan->ObjectMenu.LocalIncludeScan.check;
   true->OGppProp.ShowDynamicCreations->ObjectMenu.ToggleDynamicCreations.check;
   true->OGppProp.ShowOperationCalls->ObjectMenu.ToggleProcedureCalls.check;
   (*(UserMenu6,'Marks') -> MarkMenu.init;*)
   (* new document makes a new page by default
    * if we like a special page the make it here *)
   &OADPage[]->newPage[];
   (* set/clear appopriate check marks in the menus *)
   (*MarkMenu.CheckCheckMarks;*)
   OptionsMenu.CheckCheckMarks;
#)  

-- OADPageOnInit: DescriptorForm --
(# integerData: @integer; ok: @Boolean; listsize,last: @integer
do
   (if userDataVerbose then
       'onInit called on OADPage with id='->puttext;
       id->putint;
       newline;
       'Reading OADPage UserDataID: '->puttext
   if);
   (Id,1,@@ integerData)->UDReadType->ok;
   (if ok then
       (if userDataVerbose then
           'Read OADPage UserDataID succeed: '->puttext;
           integerData->putint;
           newline
       if);
       (integerData,ID)->UserDataIDMap.putID;
    else
       (if userDataVerbose then 'Read OADPage UserDataID fail'->putline if)
   if);
   ID->integerData;
   (Id,1,@@ integerData,4)->UDWriteType->ok;
   (if ok then
       (if userDataVerbose then
           'Write OADPage UserDataID succeed: '->puttext;
           integerData->putint;
           newline
       if)
    else
       (if userDataVerbose then 'Write OADPage UserDataID fail'->putline if)
   if);
   (if THIS(OADPage)[] = theGroupPage[] then
       (theGroupPage.ID,499,@@ listsize)->UDReadType->ok;
       (if ok then
           listsize->IndexIDList.impl.new;
           (if userDataVerbose then
               'Read IndexIDList.impl.range succeed: '->puttext;
               listsize->putint;
               newline
           if);
           (theGroupPage.ID,500,@@ last)->UDReadType->ok;
           (if ok then
               last->IndexIDList.last;
               (if userDataVerbose then
                   'Read IndexIDList.last succeed: '->puttext;
                   last->putint;
                   newline
               if);
               (for i: listsize repeat
                 (theGroupPage.ID,500+i,@@ IndexIDList.impl[i])->UDReadType->ok;
                 (if ok then
                     (if userDataVerbose then
                         'Read IndexIDList succeed: '->puttext;
                         'element no '->puttext;
                         i->putint;
                         'element '->puttext;
                         IndexIDList.impl[i]->putint;
                         newline
                     if)
                  else
                     'Read IndexIDList fail: '->puttext
                 if)
               for)
            else
               (if userDataVerbose then
                   'Read IndexIDList.last fail: '->puttext
               if)
           if)
        else
           (if userDataVerbose then
               'Read IndexIDList.impl.range fail: '->puttext
           if)
       if)
   if);
   false->borderVisible;
   (*gppProp.NextPositionStartX*)
   250->nextX;
   (*gppProp.NextPositionStartY*)
   250->nextY;
   true->doScrollIntoView;
#)  

-- CalculateNextCenter: DescriptorForm --
(# x,y,w,h: @Integer; p: ^OADPage;
do
   (if PatternDiagrams.theList.size
    // 0 then (* first diagram on page *)
       CurrentPage->p[];
       p.Geometry->(x,y,w,h);
       (* center, width, and height of PAGE *)
       y-(h div 2)+gppProp.DownOnPage->PatternDiagrams.NextFreeLine;
       x-(w div 2)+gppProp.RightOnPage->PatternDiagrams.NextFreeColumn;
       PatternDiagrams.NextFreeLine->PatternDiagrams.SecondFreeLine;
       PatternDiagrams.NextFreeColumn+gppProp.width+gppProp.RightFromPrevious
         ->PatternDiagrams.SecondFreeColumn;
   if);
   (PatternDiagrams.NextFreeColumn,PatternDiagrams.NextFreeLine)->theCenter;
   (*(nextX,nextY)->theCenter;*)
#)  

-- UpdateNextFree: DescriptorForm --
(# w,h: @Integer;
do
   (if x-gppProp.width > theCenter.x then
   (* we have the last box on another column than the title *)
       x->PatternDiagrams.NextFreeColumn;
   if);
   (PatternDiagrams.NextFreeLine,y+gppProp.DownFromPrefix)->Max
     ->PatternDiagrams.NextFreeLine;
   (PatternDiagrams.SecondFreeColumn,x+gppProp.width+gppProp.RightFromPrevious)
     ->Max->PatternDiagrams.SecondFreeColumn;
   (* check that nextFreeLine is inside the bound of the page *)
   THIS(OADPage).Geometry->(x,y,w,h);
   (if PatternDiagrams.NextFreeLine > y+(h div 2) then
   (* PatternDiagrams.SecondFreeLine -> PatternDiagrams.NextFreeLine;*)
       y-(h div 2)+gppProp.DownOnPage->PatternDiagrams.NextFreeLine;
       (if PatternDiagrams.NextFreeColumn < theCenter.x then
           PatternDiagrams.SecondFreeColumn->PatternDiagrams.NextFreeColumn;
           PatternDiagrams.SecondFreeColumn+gppProp.width+
           gppProp.RightFromPrevious->PatternDiagrams.SecondFreeColumn;
       if);
   if);
#)  

-- StartCreatePrefix: DescriptorForm --
(#
   PC: Connector
     (#
        onInit::< 
          (# prefixTitle,title: ^PatternDiagramNode; a,b: ^Node;
          do
             0->Orient;
             GetEnds->(a[],b[]);
             (if (a[] <> none ) and (b[] <> none )
              // true then
                 (if a.struc <= PatternDiagramNode##
                  // true then a[]->title[];
                  else
                     'Incorrect pattern node selected'->gppalert;
                 if);
                 (if b.struc <= PatternDiagramNode##
                  // true then
                     b[]->prefixtitle[];
                     (if prefixtitle.theDiagram
                      // none then 'Incorrect prefix selected'->gppalert;
                      else
                         (prefixtitle.theDiagram).titlenode[]->prefixtitle[];
                     if)
                  else
                     'Incorrect prefix selected'->gppalert;
                 if);
                 (prefixTitle[],title[])->PrefixExpand;
              else
                 'Incorrect nodes selected in prefix creation'->gppalert;
             if);
          #);
        interactivenew::< 
          (# cursorformat::<  (# do cursor.arrow->curs #) #)
     #);
   aPC: ^PC;
do
   &PC[]->aPC[];
   'Specify Prefix by first selecting the Pattern and then the prefix'
     ->aPC.interactivenew;
#)  

-- updateASTfromDisk: DescriptorForm --
(# g: ^FragmentGroup; ff: ^FragmentForm; anAST: ^AST;
do
   (if switch[22]
    // true then
       'Gpp ------- updateASTfromDisk'->putLine;
       'oldindex: '->putText;
       oldindex->putInt;
       newLine;
   if);
   true->status;
   (*oldIndex->IndexIDList.IndextoObject->theObject[];*)
   oldIndex
     ->oldff.indexToNode
       (#
          indexOutOfRange::< 
            (# do 'indexOutOfRange'->putLine; true->continue; #);
          noSuchSymbol::< 
            (# do 'noSuchSymbol'->putLine; true->continue; #);
          grammarGenRefArrayError::< 
            (# do 'grammarGenRefArrayError'->putLine; true->continue; #)
       #)->anAST[];
   (if anAST[] = none then
       'Gpp updateASTfromDisk: node not found'->putLine
    else
       anAST[]->ASTtoNode->theObject[];
       (if theObject[]
        // none then
           (if CurrentFocus[] <> none
            // true then
               CurrentFocus.getFragment->ff[];
               (if ff[]
                // none then
                   'Freja: UpdateASTfromDisk: Cannot find FragmentForm for CurrentFocus'
                     ->screen.putline;
                else
                   (if anAST[]
                    // none then 'Freja[[Old AST is: none'->screen.putLine
                    else
                       (if switch[22]
                        // true then
                           'Freja[[Old AST is: '->screen.puttext;
                           anAST.index->screen.putint;
                           ' symbol: '->screen.puttext;
                           anAST.symbol->betagram.symboltoname->screen.puttext;
                           ']]'->screen.putline;
                       if);
                       L:
                       (if 1
                        // 1 then
                           anAST.father->anAST[];
                           (if anAST[] <> none
                            // true then
                            (*anAST.index->IndexIDList.IndextoObject->theObject[];*)
                               anAST[]->ASTtoNode->theObject[];
                               (if switch[1]
                                // true then
                                   'Freja[[N''th father to old AST is: '
                                     ->screen.puttext;
                                   anAST.index->screen.putint;
                                   ' symbol: '->screen.puttext;
                                   anAST.symbol->betagram.symboltoname
                                     ->screen.puttext;
                                   ']]'->screen.putline;
                               if);
                               (if theObject[] // none then restart L if);
                           if)
                       if);
                   if)
               if)
            else
               'Freja: UpdateASTfromDisk: CurrentFocus is NONE'->screen.putline;
               false->status;
           if);
       if);
       (if theObject[] <> none
        // true then (* object found; read the AST from disk *)
           theObject.getGroup->g[];
           (if g[] <> none
            // true then (* read the AST in from disk *)
               (if switch[2]
                // true then 'Reading in new AST'->statusbar.set
               if);
               (if switch[22]
                // true then
                   'Freja[[Reading in new AST... ]]'->screen.putline;
               if);
               g.init;
               screen[]->g.unpack;
               (oldff[],theObject[])->(theObject.theDiagram).updateASTfromDisk
                 ->newff[];
               (*  (if g.CheckDiskRepresentation
                // true then
                (oldff[],theObject[])->(theObject.theDiagram).updateASTfromDisk
                ->newff[];
                INNER updateASTfromDisk
                else
                false->status;
                'Freja: UpdateASTfromDisk: AST not changed on disk!'
                ->screen.putline;
                if); *)
               INNER updateASTfromDisk;
               (if switch[2] // true then statusbar.reset if);
            else
               false->status;
               'Freja: UpdateASTfromDisk: cannot find FragmentDiagram'
                 ->screen.putline;
           if);
        else
           false->status;
           'Freja: UpdateASTfromDisk: cannot find old object'->screen.putline;
       if)
   if);
   (if switch[22]
    // true then 'Gpp ------- End updateASTfromDisk'->putLine;
   if);
#)  

-- gppChangedFocus: DescriptorForm --
(#
do
   true->OKtoChange;
   INNER changedFocus;
   (if OKToChange then
       newObject[]->CurrentFocus[]
    else
       oldObject[]->currentObject
   if)
#)  

-- newFragment: DescriptorForm --
(#
do (if switch[22] // true then 'Gpp ------- newFragment'->putLine; if);
#)  

-- astReplaced: DescriptorForm --
(#
   oldAst,newAst: ^ast;
   pos: @integer;
   theDiagram: ^Diagram;
   doListReplace: @boolean;
   deleted: @boolean;
   dummyFilter: ##external;
   pageList: ^ObjectList;
   filename: @Text;
   cancelled: ^integerRef;
   prompt: @text;
   count: @ShortRef;
   list: @IntegerRef;
do
   (if switch[22]
    // true then
       'Gpp ------- astReplaced'->putLine;
       'oldindex: '->putText;
       oldindex->putInt;
       newLine;
       'newindex: '->putText;
       newindex->putInt;
       newLine;
   if);
   true->status;
   oldIndex
     ->ff.indexToNode
       (#
          indexOutOfRange::< 
            (# do 'indexOutOfRange'->putLine; true->continue; #);
          noSuchSymbol::< 
            (# do 'noSuchSymbol'->putLine; true->continue; #);
          grammarGenRefArrayError::< 
            (# do 'grammarGenRefArrayError'->putLine; true->continue; #)
       #)->oldAST[];
   (if oldAST[] = none then
       'Gpp astReplaced: old node not found'->putLine
    else
       thisOp:
         (#
         do
            (ff[],oldIndex)
              ->updateASTfromDisk
                (#
                do
                   newIndex
                     ->newff.indexToNode
                       (#
                          indexOutOfRange::< 
                            (#
                            do 'indexOutOfRange'->putLine; true->continue;
                            #);
                          noSuchSymbol::< 
                            (#
                            do 'noSuchSymbol'->putLine; true->continue;
                            #);
                          grammarGenRefArrayError::< 
                            (#
                            do
                               'grammarGenRefArrayError'->putLine;
                               true->continue;
                            #)
                       #)->newAST[];
                   (if newAST[] = none then
                       'Gpp astReplaced: new node not found'->putLine;
                       leave thisOP
                   if);
                   (if oldAST.kind
                    // kinds.unExpanded then
                    (* this is an ECOOP94 hack, must be generalized *)
                       (if newAst.kind
                        // kinds.interior then
                           (if switch[22]
                            // true then 'expanding a nonterminal'->putLine;
                           if);
                           (if NewAST.symbol
                            // betaGram.nameDcl then
                               (if switch[22]
                                // true then '  it is a nameDcl'->putLine;
                               if);
                            else
                               (if (NewAST.struc <= betaGram.attributeDecl##)
                                // true then
                                   (if switch[22]
                                    // true then
                                       '  it is a declaration: '->putText;
                                       NewAST.symbol->putInt;
                                       newLine;
                                   if);
                                   true->doListReplace;
                                else
                               if)
                           if);
                        // kinds.optional then
                           oldAST[]->ASTtoNode->theObject[];
                           (if theObject[] <> none then
                               theObject.theDiagram->theDiagram[];
                               (theObject[],true)->theDiagram.deleteDiagramNode;
                               true->deleted;
                           if)
                       if)
                    // kinds.interior then
                       (if newAST.kind = kinds.interior then
                           (if oldAST## <= betaGram.attributeDecl## then
                               (if newAST## <= betaGram.attributeDecl## then
                                   (if oldAST## <> newAST## then
                                       true->doListReplace
                                   if)
                               if)
                           if)
                        else
                           true->doListReplace
                       if)
                   if);
                   (if doListReplace
                    // true then
                       oldAST.sonNo->pos;
                       (if switch[22]
                        // true then
                           'sonNo is: '->putText; pos->putInt; newLine
                       if);
                       (*oldIndex->IndexIDList.IndextoObject->theObject[];*)
                       oldAST[]->ASTtoNode->theObject[];
                       (if theObject[] <> none then
                           theObject.theDiagram->theDiagram[];
                           (*
                            (theObject[],true)->theObject.theDiagram.deleteDiagramNode;
                            (pos,newAST[])->theDiagram.insertDiagramNode;    
                            * *)
                           (theObject[],newAST[])
                             ->theDiagram.replaceDiagramNode;
                       if)
                    else
                       (if not deleted then
                           (if theObject[] <> none then
                               (oldAst[],newAst[])
                                 ->(theObject.theDiagram).updateDiagramNode
                            else
                               'astReplaced: theObject is none'->putline
                           if)
                       if);
                   if)
                #);
            Redraw
         #)
   if);
   autosave;
   (* refresh the page, due to update delay *)
#)  

-- listElementInserted: DescriptorForm --
(#
(* listElementInserted:
 * # <editorId> listElementInserted <fatherIndex> <position> <synCatNo> <synCatName>
 *) father: ^expanded; newAst,firstBorn: ^ast; pos: @integer
do
   (if switch[22]
    // true then
       'Gpp ------- listElementInserted'->putLine;
       'fatherIndex: '->putText;
       fatherIndex->putInt;
       newLine;
       'position: '->putText;
       position->putInt;
       newLine;
   if);
   fatherIndex
     ->ff.indexToNode
       (#
          indexOutOfRange::< 
            (# do 'indexOutOfRange'->putLine; true->continue; #);
          noSuchSymbol::< 
            (# do 'noSuchSymbol'->putLine; true->continue; #);
          grammarGenRefArrayError::< 
            (# do 'grammarGenRefArrayError'->putLine; true->continue; #)
       #)->father[];
   (if father[] = none then
       'Gpp listElementInserted: father not found'->putLine
    else
       father.getson1->firstBorn[];
       (ff[],firstBorn.index)
         ->updateASTfromDisk
           (#
           do
              (if (newff[] <> none )
               // true then
                  fatherIndex
                    ->newff.indexToNode
                      (#
                         indexOutOfRange::< 
                           (#
                           do 'indexOutOfRange'->putLine; true->continue;
                           #);
                         noSuchSymbol::< 
                           (#
                           do 'noSuchSymbol'->putLine; true->continue;
                           #);
                         grammarGenRefArrayError::< 
                           (#
                           do
                              'grammarGenRefArrayError'->putLine;
                              true->continue;
                           #)
                      #)->father[];
                  (if (father[] <> none )
                   // true then
                      position->pos->father.get->newAST[];
                      (pos-1,newAST[])
                        ->(theObject.theDiagram).insertDiagramNode;
                   else
                      'Gpp ------- listElementInserted: father is none'
                        ->putLine;
                  if);
               else
                  'Gpp ------- listElementInserted: newff is none'->putLine;
              if);
           #);
       Redraw
   if);
   autosave;
   (* refresh the page, due to update delay *)
#)  

-- listElementsDeleted: DescriptorForm --
(#
(* changeSpec:
 * <fatherIndex> <position> <length> <oldElements>
 *  <oldElements> ::= { <elementIndex> } i    (i = <length>)
 *)
   fatherIndex,position,length: @integer;
   oldElements: [1] @integer;
   father: ^expanded;
   anAst: ^ast;
do
   (if switch[22]
    // true then
       'Gpp ------- listElementsDeleted'->putLine; changeSpec[]->putLine;
   if);
   changeSpec.getInt->fatherIndex;
   changeSpec.getInt->position;
   changeSpec.getInt->length;
   (if switch[22]
    // true then
       'fatherIndex: '->putText;
       fatherIndex->putInt;
       newLine;
       'position: '->putText;
       position->putInt;
       newLine;
       'length: '->putText;
       length->putInt;
       newLine;
   if);
   length-1->oldElements.extend;
   (for i: length repeat changeSpec.getInt->oldElements[i] for);
   (if switch[22]
    // true then
       'oldElements: '->putText;
       (for i: length repeat oldElements[i]->putInt; ' '->put; for);
       newLine;
   if);
   fatherIndex
     ->ff.indexToNode
       (#
          indexOutOfRange::< 
            (# do 'indexOutOfRange'->putLine; true->continue; #);
          noSuchSymbol::< 
            (# do 'noSuchSymbol'->putLine; true->continue; #);
          grammarGenRefArrayError::< 
            (# do 'grammarGenRefArrayError'->putLine; true->continue; #)
       #)->father[];
   thisOp:
   (if father[] = none then
       'Gpp listElementInserted: father not found'->putLine
    else
       position->father.get->anAST[];
       (ff[],anAst.index)
         ->updateASTfromDisk
           (#
           do (*(theObject[],0 ) -> theObject.theDiagram.remakePP;*)
              (for i: length repeat
              (*oldElements[i]->IndexIDList.IndextoObject->theObject[];*)
                oldElements[i]
                  ->ff.indexToNode
                    (#
                       indexOutOfRange::< 
                         (#
                         do 'indexOutOfRange'->putLine; true->continue;
                         #);
                       noSuchSymbol::< 
                         (#
                         do 'noSuchSymbol'->putLine; true->continue;
                         #);
                       grammarGenRefArrayError::< 
                         (#
                         do
                            'grammarGenRefArrayError'->putLine; true->continue;
                         #)
                    #)->anAST[];
                (if anAST[] = none then
                    'Gpp listElementInserted: old node not found'->putLine;
                    leave thisOp
                if);
                anAST[]->ASTtoNode->theObject[];
                (if theObject[] <> none then
                    (theObject[],true)
                      ->(theObject.theDiagram).deleteDiagramNode;
                if)
              for)
           #);
       Redraw
   if);
   autosave;
   (* refresh the page, due to update delay *)
#)  

-- listElementsReplaced: DescriptorForm --
(#
(* changeSpec:
 * <fatherIndex> <position> <length> <oldElements> <newLength> 
 * <oldElements> ::= { <elementIndex> } i    (i = <length>)
 *)
   fatherIndex,position,length,newLength: @integer;
   oldElements: [1] @integer;
   father: ^expanded;
   oldAst,newAst,anAST: ^ast;
   theDiagram: ^Diagram;
   pos,oldIndex: @integer
do
   (if switch[22]
    // true then
       'Gpp ------- listElementsReplaced'->putLine; changeSpec[]->putLine;
   if);
   changeSpec.getInt->fatherIndex;
   changeSpec.getInt->position;
   changeSpec.getInt->length;
   (if switch[22]
    // true then
       'fatherIndex: '->putText;
       fatherIndex->putInt;
       newLine;
       'position: '->putText;
       position->putInt;
       newLine;
       'length: '->putText;
       length->putInt;
       newLine;
   if);
   (if length > 0 then
       length-1->oldElements.extend;
       (for i: length repeat changeSpec.getInt->oldElements[i] for);
       oldElements[1]->oldIndex
    else
   (* in this case there is no old node, e.g. when undoing 
    delete of list elements *)
       fatherIndex->oldIndex
   if);
   changeSpec.getInt->newLength;
   (if switch[22]
    // true then
       'oldElements: '->putText;
       (for i: length repeat oldElements[i]->putInt; ' '->put; for);
       newLine;
       'newLength: '->putText;
       newLength->putInt;
       newLine;
   if);
   thisOp:
     (#
     do
        (ff[],oldIndex)
          ->updateASTfromDisk
            (#
            do
               (for i: length repeat
               (*oldElements[i]->IndexIDList.IndextoObject->theObject[];*)
                 oldElements[i]
                   ->ff.indexToNode
                     (#
                        indexOutOfRange::< 
                          (#
                          do 'indexOutOfRange'->putLine; true->continue;
                          #);
                        noSuchSymbol::< 
                          (#
                          do 'noSuchSymbol'->putLine; true->continue;
                          #);
                        grammarGenRefArrayError::< 
                          (#
                          do
                             'grammarGenRefArrayError'->putLine;
                             true->continue;
                          #)
                     #)->anAST[];
                 (if anAST[] = none then
                     'Gpp listElementReplaced: old node not found'->putLine;
                     leave thisOp
                 if);
                 anAST[]->ASTtoNode->theObject[];
                 (if theObject[] <> none then
                     theObject.theDiagram->theDiagram[];
                     (theObject[],true)
                       ->(theObject.theDiagram).deleteDiagramNode;
                 if)
               for);
               fatherIndex
                 ->newff.indexToNode
                   (#
                      indexOutOfRange::< 
                        (#
                        do 'indexOutOfRange'->putLine; true->continue;
                        #);
                      noSuchSymbol::< 
                        (# do 'noSuchSymbol'->putLine; true->continue; #);
                      grammarGenRefArrayError::< 
                        (#
                        do 'grammarGenRefArrayError'->putLine; true->continue;
                        #)
                   #)->father[];
               (if father[] = none then
                   'Gpp listElementReplaced: father node not found'->putLine;
                   leave thisOp
               if);
               (for i: newlength repeat
                 position+i-1->pos->father.get->newAST[];
                 (if theDiagram[] = none then
                     'Gpp: ListElementsReplaced: theDiagram is none!!'->putLine
                  else
                     (pos-1,newAST[])->theDiagram.insertDiagramNode
                 if);
               for);
            #);
        Redraw
     #);
   autosave;
   ;
   (* refresh the page, due to update delay *)
#)  

-- makeAnchors: DescriptorForm --
(# noOfNodes,i: @Integer; theObject: ^PatternDiagramNode;
do
(*'Freja[[MakeAnchors: '->screen.puttext;
 indexList[]->screen.puttext;
 ']]'->screen.putline;
 indexList.reset;
 indexList.getInt->noOfNodes;
 (for noOfNodes repeat
 indexList.getInt->i->IndexIDList.IndextoObject->theObject[];
 (if theObject[] <> none
 // true then theObject.MakeAnchor;
 else
 'Freja[[No node is presented with index: '->screen.puttext;
 i->screen.putint;
 ']]'->screen.putline;
 if)
 for);
 * *)
#)  

-- getExtension: DescriptorForm --
(# index: @Integer;
do
   '.'->name.findCh (# do inx->index; #);
   (index,name.length)->name.sub->extension[];
#)  

-- removeExtension: DescriptorForm --
(# rest: ^Text; index: @Integer;
do
   '.'->name.findCh (# do inx->index; #);
   (index,name.length)->name.sub->rest[];
   (if ('.bet'->rest.equal) or ('.ast'->rest.equal)
    // true then (index,name.length)->name.delete;
   if);
#)  

-- doStartup: DescriptorForm --
(# arg: ^Text; swt: @Text; SwitchMode: @Boolean; N: @Integer;
do
   (if NoOfArguments > 1
    // true then
       (for i: NoOfArguments-1 repeat
         i+1->Arguments->arg[];
         0->arg.setpos;
         (if SwitchMode
          // true then
             arg.getint->N;
             (if True
              // (0 < N) and (N <= switch.range) then
                 True->Switch[N];
              // N = 0 then
                 false->SwitchMode;
             if)
          else
             (if arg.peek
              // '-' then
                 arg.get;
                 (if arg.peek
                  // 'd' // 'D' then
                     arg.get;
                     (if arg.eos
                      // true then
                         true->switch[1];
                      // false then
                         (if arg.peek
                          // 'e' then
                             arg.get;
                             (if arg.peek // 'x' then dexterOn if);
                         if)
                     if);
                  // 'p' // 'P' then
                     (i+2->Arguments,i+3->Arguments)->activatedFromSif; i+2->i;
                  // 's' // 'S' then
                     true->SwitchMode; swt.clear;
                 if);
              else
                 arg->removeExtension->openFragmentGroup;
             if)
         if)
       for)
   if)
#)  

-- GetGroupName: DescriptorForm --
(* ask user for a group name *)
  (# name: @Text; ext: ^text;
  do
     'Select a .bet or .ast file'->DSFileNameDialog->name;
     (if name.length > 0
      // true then
         name->getExtension->ext[];
         (if ('.bet'->ext.equal) or ('.ast'->ext.equal) then
             name->removeExtension->name;
             (if switch[1]
              // true then 'Opening: '->puttext; name[]->putline;
             if);
             name->openFragmentGroup
          else
             'You must select a .bet or .ast file!'->DSUIUserAckMessage
         if);
     if);
  #)  

-- OpenFragmentGroup: DescriptorForm --
(#
   myDocument: ^OADDocument;
   opened: @boolean;
   propd: ^myDocument.theGroupPage.PropertyDiagram;
   fragd: ^myDocument.theGroupPage.FragmentDiagram;
   mess: @Text;
   NoOfForms: @Integer;
do
   (if switch[2]
    // true then
       'Opening: '->mess.puttext; name[]->mess.puttext; mess->statusbar.set;
   if);
   thisOperation:
   (name[]->ExpandToFullPath,screen[])
     ->top.open
       (#
          WriteAccessOnLstFileError::< 
            (#
            do
               'Access error on .lst file'->mess;
               mess->DSUIUserAckMessage;
               statusbar.reset;
               true->continue (*'Access error on .lst file'->myException*)
            #);
          writeAccessError::< 
            (#
            do
               'No write access'->mess;
               mess->DSUIUserAckMessage;
               statusbar.reset;
               true
                 ->continue
                 (*'Write access error'->myException
                  * *)
            #);
          startingParsing::< 
            (#
            do
               'Parsing '->mess;
               name[]->mess.putText;
               mess->DSUIUserAckMessage;
               statusbar.reset;
            #);
          ParseErrors::< 
            (#
            do
               none ->f[];
               none ->theCatcher[];
               mess->DSUIUserAckMessage;
               statusbar.reset;
               leave thisOperation
            #)
       #)->fg[];
   (if fg[]
    // none then
       'Cannot open fragmentgroup: '->mess;
       name[]->mess.puttext;
       mess->DSUIUserAckMessage;
       statusbar.reset;
    else
       fg.fragmentlist.scan
         (#
         do (if current.type // formtype then noofforms+1->noofforms if)
         #);
       (if (* fg[] -> isChecked//false *) true
        // false then
           'FragmentGroup '''->puttext;
           name[]->puttext;
           ''' not checked.'->putline;
           'Must be checked by compiler before it can be shown...'->putline;
        else
           (if theDocument[]
            // none then
               &OADDocument[]->myDocument[];
               myDocument.new;
               (if NoOfForms
                // 1 then
                   myDocument.CurrentPage->myDocument.theWorkPage[];
                   'WorkSheet'->myDocument.theWorkPage.PageTitle;
                   &myDocument.OADPage[]->myDocument.theGroupPage[];
                   myDocument.theGroupPage.InvisibleNew;
                   myDocument.theWorkPage[]->myDocument.CurrentPage;
                else
                   myDocument.CurrentPage->myDocument.theGroupPage[];
                   myDocument[]->theDocument[]->theOADDocument[];
               if);
               'Group Window'->myDocument.theGroupPage.PageTitle;
            else
               theDocument[]->myDocument[];
               (if NoOfForms
                // 1 then
                else
                   myDocument.theGroupPage.visible;
               if);
           if);
           scanner:
           myDocument.theGroupPage.PatternDiagrams.theList.scanPropertyDiagrams
             (#
             do
                (if fg.name->(thisDiagram.fullname).equal
                 // true then true->opened; leave scanner;
                if);
             #);
           (if opened
            // true then (* fragment already shown: just show the page *)
               myDocument.theGroupPage[]->myDocument.CurrentPage;
            else
               (if switch[2]
                // true then 'Scanning Properties'->statusbar.set;
               if);
               &myDocument.theGroupPage.PropertyDiagram[]->propd[];
               (fg[],true,name[]->ExpandToFullPath)->propd.new;
               &myDocument.theGroupPage.FragmentDiagram[]->fragd[];
               (if switch[2]
                // true then 'Scanning Fragments'->statusbar.set;
               if);
               fg[]->fragd.new;
           if);
           (if switch[2] // true then statusbar.reset; if);
           (if NoOfForms
            // 1 then
               myDocument.theGroupPage.FragmentDiagram##
                 ->myDocument.theGroupPage.ScanDiagrams
                   (#
                   do
                      current[]->fragd[];
                      (if fg[]
                       // fragd.theGroup then (* find formname in the diagram *)
                          fragd.localnodes.scan (# do current.detail #)
                      if)
                   #)
           if);
       if)
   if)
#)  

-- OpenFragmentForm: DescriptorForm --
(#
   index: @Integer;
   groupname,formname: ^Text;
   fg: ^FragmentGroup;
   theDoc: ^OADDocument;
   theDiagram: ^theDoc.theGroupPage.FragmentDiagram;
   noOfForms: @integer;
do (* first open the group, and then open the form *)
   '-'->name.findCh (# do inx->index; #);
   (1,index-1)->name.sub->groupname[];
   groupname->openFragmentGroup->fg[];
   (index+1,name.length)->name.sub->formname[];
   fg.fragmentlist.scan
     (#
     do
        (if current.type
         // formtype then
            noofforms+1->noofforms;
            (if (current.f.name->formName.equal)
             // true then current.f[]->ff[]
            if)
        if)
     #);
   theDocument[]->theDoc[];
   (*   'Scanning prop diagrams: ' -> screen.puttext; fg.name -> screen.puttext;
    '-' -> screen.put; formname[] -> screen.putline;*)
   theDoc.theGroupPage.FragmentDiagram##
     ->theDoc.TheGroupPage.ScanDiagrams
       (#
       do
          current[]->theDiagram[];
          theDiagram.fullname->screen.putline;
          (if fg[]
           // theDiagram.theGroup then (* find formname in the diagram *)
              theDiagram.localnodes.scan
                (# t: ^text;
                do
                   &Text[]->t[];
                   current.theText.get->t;
                   ':'->t.findCh (# do inx->index #);
                   (1,index-1)->t.sub->t[];
                   (*'Form: ' -> screen.puttext; t[] -> screen.putline;*)
                   EditorID->current.SifEditorInstanceNo;
                   (if (formname[]->t.equal) and (noOfForms > 1)
                    // true then
                    (* if noOfForms = 1 the form has already been opened 
                     * by openFragmentGroup
                     *)
                       current.detail;
                   if)
                #)
          if)
       #)
#)  

-- autosave: DescriptorForm --
(#
   dummyFilter: ##external;
   pageList: ^ObjectList;
   filename: @Text;
   cancelled: ^integerRef;
   prompt: @text;
   count: @ShortRef;
   list: @IntegerRef
do
   '#0 autoSave'->sendSifCommand;
   SaveLists;
   'autosave.diag'->filename.puttext;
   (count[],list[])->DSStrGetPageList;
   &integerRef[]->cancelled[];
   ' '->prompt.puttext;
   (@@ filename.T[1],false,cancelled[],true,count,list,dummyFilter##,prompt)
     ->DSFileSavePagesAsDiagram
#)  

-- SaveLists: DescriptorForm --
(#
   theListDiagram: ^theOADDocument.theWorkPage.ListDiagram;
   theReference: ^theListDiagram.titleNode.PatternDiagNodeReference;
   ok: @Boolean;
   listsize,last: @integer
do
   theDocument[]->theOADDocument[];
   theOADDocument.theWorkPage.PatternDiagrams.theList.scan
     (#
     do
        current.e[]->theListDiagram[];
        theListDiagram.titleNode.resetLocalNodesUD
     #);
   theOADDocument.theGroupPage.PatternDiagrams.theList.scan
     (#
     do
        current.e[]->theListDiagram[];
        theListDiagram.titleNode.resetLocalNodesUD
     #);
   theOADDocument.theWorkPage.PatternDiagrams.theList.scan
     (#
     do
        current.e[]->theListDiagram[];
        theListDiagram.localNodes.scan
          (#
          do
             &theListDiagram.titleNode.PatternDiagNodeReference[]
               ->theReference[];
             theReference.InitLocalNode;
             current[]->theReference;
             (* code for saving decomposDiagrams list
              
              (if current.struc <= theListDiagram.abstractNode then
              current[]->theAbstractNode[];
              theAbstractNode.decomposDiagrams.scan
              (#
              do
              &theAbstractNode.PatternDiagReference[]->theDiagReference[];
              theDiagReference.InitDecomposDiagram;
              current[]->theDiagReference
              #)
              if) *)
          #)
     #);
   theOADDocument.theGroupPage.PatternDiagrams.theList.scan
     (#
     do
        current.e[]->theListDiagram[];
        theListDiagram.localNodes.scan
          (#
          do
             &theListDiagram.titleNode.PatternDiagNodeReference[]
               ->theReference[];
             theReference.InitLocalNode;
             current[]->theReference;
             (* code for saving decomposDiagrams list
              
              (if current.struc <= theListDiagram.abstractNode then
              current[]->theAbstractNode[];
              theAbstractNode.decomposDiagrams.scan
              (#
              do
              &theAbstractNode.PatternDiagReference[]->theDiagReference[];
              theDiagReference.InitDecomposDiagram;
              current[]->theDiagReference
              #)
              if) *)
          #)
     #);
   (theOADDocument.theGroupPage.ID,499,@@ listsize)->UDReadType->ok;
   (if ok then
       (for i: listsize repeat
         (theOADDocument.theGroupPage.ID,500+i)->UDDeleteType->ok;
         (if ok then
             (if userDataVerbose then
                 'For id '->puttext;
                 theOADDocument.theGroupPage.ID->putint;
                 ' and attributeID '->puttext;
                 500+i->putint;
                 ' delete IndexIDList userdata succeed'->putline
             if)
          else
             (if userDataVerbose then
                 'For id '->puttext;
                 theOADDocument.theGroupPage.ID->putint;
                 ' and attributeID '->puttext;
                 500+i->putint;
                 ' delete IndexIDList userdata fail'->putline
             if)
         if)
       for)
    else
       (if userDataVerbose then 'listsize read fail'->putline if)
   if);
   IndexIDList.impl.range->listsize;
   (theOADDocument.theGroupPage.ID,499,@@ listsize,4)->UDWriteType->ok;
   (if ok then
       (if userDataVerbose then
           'Write IndexIDList.impl.range succeed: '->puttext;
           listsize->putint;
           newline
       if);
       IndexIDList.last->last;
       (theOADDocument.theGroupPage.ID,500,@@ last,4)->UDWriteType->ok;
       (if ok then
           (if userDataVerbose then
               'Write IndexIDList.last succeed: '->puttext;
               last->putint;
               newline
           if);
           (for i: listsize repeat
             (theOADDocument.theGroupPage.ID,500+i,@@ IndexIDList.impl[i],4)
               ->UDWriteType->ok;
             (if ok then
                 (if userDataVerbose then
                     'Write IndexIDList succeed: '->puttext;
                     'element no '->puttext;
                     i->putint;
                     'element '->puttext;
                     IndexIDList.impl[i]->putint;
                     newline
                 if)
              else
                 (if userDataVerbose then
                     'Write IndexIDList fail: '->puttext
                 if)
             if)
           for)
        else
           (if userDataVerbose then
               'Write IndexIDList.last fail: '->puttext
           if)
       if)
    else
       (if userDataVerbose then
           'Write IndexIDList.impl.range fail: '->puttext
       if)
   if)
#)  

-- ScanDiagrams: DescriptorForm --
(#
do
   PatternDiagrams.theList.scan
     (#
     do
        current.e[]->THIS(ScanDiagrams).current[];
        (if theDiagramType##
         // none then INNER ScanDiagrams;
         else
            (if current.e.struc <= theDiagramType##
             // true then INNER ScanDiagrams;
            if)
        if)
     #)
#)  

-- MarkNodeDisplay: DescriptorForm --
(#
do
   (pos.x,pos.y,gppProp.marksize,gppProp.marksize)->new;
   theNode[]->thePatternDiagramNode;
   THIS(MarkNode)[]->(thePatternDiagramNode).theMarkNode;
   false->sizeable;
#)  

-- MarkNodeOnInit: DescriptorForm --
(#
do
   UDPrivate.UDMarkNode->UserDataInit;
   thePatternDiagramNode.Init;
   6->theText.size;
   false->moveable;
   false->sizeable;
   (if not initialisingSaved then theNode[]->CreateRegion if);
#)  

-- titleGetFragment: DescriptorForm --
(# fn: ^FragmentNode;
do
   (if theFragmentNode <> none
    // true then theFragmentNode->fn[]; fn.theFragment->f[];
    else
       'DiagramNode: GetFragment: no FragmentNode'->screen.putline
   if)
#)  

