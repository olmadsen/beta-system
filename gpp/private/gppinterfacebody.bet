ORIGIN 'diagramattributes';
(* switch
 * 1  = general debugging
 * 21 = IndexIDList
 * 22 = AstReplaced
 *)
INCLUDE 'objectgppproperties'
        '~beta/designenv/v1.5/private/userdatabody';
-- IndexIDListInsert: DescriptorForm --
(#
do
   (if switch[21]
    // true then
       '%21GPP: Insert element indexed: '->screen.puttext;
       a->screen.putint;
       screen.newline;
   if)
#)  

-- InitGPP: DescriptorForm --
(#
do
   betaGram.init;
   metaGram.init;
   '~beta/grammars/beta/v2.4/beta-parser.btab'->expandToFullPath
     ->betaGram.parser.initialize;
   ('~beta/grammars/beta/v2.4/beta-meta-beta'->expandToFullPath,screen[])
     ->top.open->betaGram.grammarAST[];
#)  

-- OADDocumentInit: DescriptorForm --
(# (* setup the DesignOA menus we like to use in OADDocument *)
do (* DocEditMenu.init; *)
   INNER onInit;
   (UserMenu7,'Page')->PageMenu.init;
   (UserMenu3,'Options')->OptionsMenu.init;
   (UserMenu4,'Display')->DisplayMenu.init;
   (UserMenu5,'Object')-> (*kja&toby 1.9.94*) ObjectMenu.init;
   true->OGppProp.StaticRefCheck;
   true->OGppProp.LocalIncludeScan->ObjectMenu.LocalIncludeScan.check;
   true->OGppProp.ShowDynamicCreations->ObjectMenu.ToggleDynamicCreations.check;
   true->OGppProp.ShowOperationCalls->ObjectMenu.ToggleProcedureCalls.check;
   (*(UserMenu6,'Marks') -> MarkMenu.init;*)
   (* new document makes a new page by default
    * if we like a special page the make it here *)
   &OADPage[]->newPage[];
   (* set/clear appopriate check marks in the menus *)
   (*MarkMenu.CheckCheckMarks;*)
   OptionsMenu.CheckCheckMarks;
#)  

-- OADPageOnInit: DescriptorForm --
(# integerData: @integer; ok: @Boolean
do
   (if userDataVerbose then
       'onInit called on OADPage with id='->puttext;
       id->putint;
       newline;
       'Reading OADPage UserDataID: '->puttext
   if);
   (Id,1,@@ integerData)->UDReadType->ok;
   (if ok then
       (if userDataVerbose then
           'Read OADPage UserDataID succeed: '->puttext;
           integerData->putint;
           newline
       if);
       (integerData,ID)->UserDataIDMap.putID;
    else
       (if userDataVerbose then 'Read OADPage UserDataID fail'->putline if)
   if);
   ID->integerData;
   (Id,1,@@ integerData,4)->UDWriteType->ok;
   (if ok then
       (if userDataVerbose then
           'Write OADPage UserDataID succeed: '->puttext;
           integerData->putint;
           newline
       if)
    else
       (if userDataVerbose then 'Write OADPage UserDataID fail'->putline if)
   if);
   false->borderVisible;
   (*gppProp.NextPositionStartX*)
   250->nextX;
   (*gppProp.NextPositionStartY*)
   250->nextY;
   true->doScrollIntoView;
#)  

-- CalculateNextCenter: DescriptorForm --
(# x,y,w,h: @Integer; p: ^OADPage;
do
   (if PatternDiagrams.theList.size
    // 0 then (* first diagram on page *)
       CurrentPage->p[];
       p.Geometry->(x,y,w,h);
       (* center, width, and height of PAGE *)
       y-(h div 2)+gppProp.DownOnPage->PatternDiagrams.NextFreeLine;
       x-(w div 2)+gppProp.RightOnPage->PatternDiagrams.NextFreeColumn;
       PatternDiagrams.NextFreeLine->PatternDiagrams.SecondFreeLine;
       PatternDiagrams.NextFreeColumn+gppProp.width+gppProp.RightFromPrevious
         ->PatternDiagrams.SecondFreeColumn;
   if);
   (PatternDiagrams.NextFreeColumn,PatternDiagrams.NextFreeLine)->theCenter;
   (*(nextX,nextY)->theCenter;*)
#)  

-- UpdateNextFree: DescriptorForm --
(# w,h: @Integer;
do
   (if x-gppProp.width > theCenter.x then
   (* we have the last box on another column than the title *)
       x->PatternDiagrams.NextFreeColumn;
   if);
   (PatternDiagrams.NextFreeLine,y+gppProp.DownFromPrefix)->Max
     ->PatternDiagrams.NextFreeLine;
   (PatternDiagrams.SecondFreeColumn,x+gppProp.width+gppProp.RightFromPrevious)
     ->Max->PatternDiagrams.SecondFreeColumn;
   (* check that nextFreeLine is inside the bound of the page *)
   THIS(OADPage).Geometry->(x,y,w,h);
   (if PatternDiagrams.NextFreeLine > y+(h div 2) then
   (* PatternDiagrams.SecondFreeLine -> PatternDiagrams.NextFreeLine;*)
       y-(h div 2)+gppProp.DownOnPage->PatternDiagrams.NextFreeLine;
       (if PatternDiagrams.NextFreeColumn < theCenter.x then
           PatternDiagrams.SecondFreeColumn->PatternDiagrams.NextFreeColumn;
           PatternDiagrams.SecondFreeColumn+gppProp.width+
           gppProp.RightFromPrevious->PatternDiagrams.SecondFreeColumn;
       if);
   if);
#)  

-- StartCreatePrefix: DescriptorForm --
(#
   PC: Connector
     (#
        onInit::< 
          (# prefixTitle,title: ^PatternDiagramNode; a,b: ^Node;
          do
             0->Orient;
             GetEnds->(a[],b[]);
             (if (a[] <> none ) and (b[] <> none )
              // true then
                 (if a.struc <= PatternDiagramNode##
                  // true then a[]->title[];
                  else
                     'Incorrect pattern node selected'->gppalert;
                 if);
                 (if b.struc <= PatternDiagramNode##
                  // true then
                     b[]->prefixtitle[];
                     (if prefixtitle.theDiagram
                      // none then 'Incorrect prefix selected'->gppalert;
                      else
                         (prefixtitle.theDiagram).titlenode[]->prefixtitle[];
                     if)
                  else
                     'Incorrect prefix selected'->gppalert;
                 if);
                 (prefixTitle[],title[])->PrefixExpand;
              else
                 'Incorrect nodes selected in prefix creation'->gppalert;
             if);
          #);
        interactivenew::< 
          (# cursorformat::<  (# do cursor.arrow->curs #) #)
     #);
   aPC: ^PC;
do
   &PC[]->aPC[];
   'Specify Prefix by first selecting the Pattern and then the prefix'
     ->aPC.interactivenew;
#)  

-- updateASTfromDisk: DescriptorForm --
(# g: ^FragmentGroup; ff: ^FragmentForm; anAST: ^AST;
do
   (if switch[22]
    // true then
       'Gpp ------- updateASTfromDisk'->putLine;
       'oldindex: '->putText;
       oldindex->putInt;
       newLine;
   if);
   true->status;
   oldIndex->IndexIDList.IndextoObject->theObject[];
   (if theObject[]
    // none then
       (if CurrentFocus[] <> none
        // true then
           CurrentFocus.getFragment->ff[];
           (if ff[]
            // none then
               'Freja: UpdateASTfromDisk: Cannot find FragmentForm for CurrentFocus'
                 ->screen.putline;
            else
               oldIndex->ff.indexToNode->anAST[];
               (if anAST[]
                // none then 'Freja[[Old AST is: none'->screen.putLine
                else
                   (if switch[22]
                    // true then
                       'Freja[[Old AST is: '->screen.puttext;
                       anAST.index->screen.putint;
                       ' symbol: '->screen.puttext;
                       anAST.symbol->betagram.symboltoname->screen.puttext;
                       ']]'->screen.putline;
                   if);
                   L:
                   (if 1
                    // 1 then
                       anAST.father->anAST[];
                       (if anAST[] <> none
                        // true then
                           anAST.index->IndexIDList.IndextoObject->theObject[];
                           (if switch[1]
                            // true then
                               'Freja[[N''th father to old AST is: '
                                 ->screen.puttext;
                               anAST.index->screen.putint;
                               ' symbol: '->screen.puttext;
                               anAST.symbol->betagram.symboltoname
                                 ->screen.puttext;
                               ']]'->screen.putline;
                           if);
                           (if theObject[] // none then restart L if);
                       if)
                   if);
               if)
           if)
        else
           'Freja: UpdateASTfromDisk: CurrentFocus is NONE'->screen.putline;
           false->status;
       if);
   if);
   (if theObject[] <> none
    // true then (* object found; read the AST from disk *)
       theObject.getGroup->g[];
       (if g[] <> none
        // true then (* read the AST in from disk *)
           (if switch[2]
            // true then 'Reading in new AST'->statusbar.set
           if);
           (if switch[22]
            // true then 'Freja[[Reading in new AST... ]]'->screen.putline;
           if);
           (if g.CheckDiskRepresentation
            // true then
               (oldff[],theObject[])->(theObject.theDiagram).updateASTfromDisk
                 ->newff[];
               INNER updateASTfromDisk;
            else
               false->status;
               'Freja: UpdateASTfromDisk: AST not changed on disk!'
                 ->screen.putline;
           if);
           (if switch[2] // true then statusbar.reset if);
        else
           false->status;
           'Freja: UpdateASTfromDisk: cannot find FragmentDiagram'
             ->screen.putline;
       if);
    else
       false->status;
       'Freja: UpdateASTfromDisk: cannot find old object'->screen.putline;
   if);
   (if switch[22]
    // true then 'Gpp ------- End updateASTfromDisk'->putLine;
   if);
#)  

-- newFragment: DescriptorForm --
(#
do (if switch[22] // true then 'Gpp ------- newFragment'->putLine; if);
#)  

-- astReplaced: DescriptorForm --
(#
   oldAst,newAst: ^ast;
   pos: @integer;
   theDiagram: ^Diagram;
   doListReplace: @boolean;
do
   (if switch[22]
    // true then
       'Gpp ------- astReplaced'->putLine;
       'oldindex: '->putText;
       oldindex->putInt;
       newLine;
       'newindex: '->putText;
       newindex->putInt;
       newLine;
   if);
   true->status;
   oldIndex->ff.indexToNode->oldAst[];
   (ff[],oldIndex)
     ->updateASTfromDisk
       (#
       do
          newIndex->newff.indexToNode->newAst[];
          (if oldAST.kind
           // kinds.unExpanded then
           (* this is an ECOOP94 hack, must be generalized *)
              (if newAst.kind
               // kinds.interior then
                  (if switch[22]
                   // true then 'expanding a nonterminal'->putLine;
                  if);
                  (if NewAST.symbol
                   // betaGram.nameDcl then
                      (if switch[22]
                       // true then '  it is a nameDcl'->putLine;
                      if);
                   else
                      (if (NewAST.struc <= betaGram.attributeDecl##)
                       // true then
                          (if switch[22]
                           // true then
                              '  it is a declaration: '->putText;
                              NewAST.symbol->putInt;
                              newLine;
                          if);
                          true->doListReplace;
                       else
                          ' unexpected symbol: '->putText;
                          newAST.symbol->putInt;
                          newLine;
                      if)
                  if);
              if)
           // kinds.interior then
              (if newAST.kind = kinds.interior then
                  (if oldAST## <= betaGram.attributeDecl## then
                      (if newAST## <= betaGram.attributeDecl## then
                          (if oldAST## <> newAST## then
                              true->doListReplace
                          if)
                      if)
                  if)
               else
                  true->doListReplace
              if)
          if);
          (if doListReplace
           // true then
              oldAST.sonNo->pos;
              (if switch[22]
               // true then 'sonNo is: '->putText; pos->putInt; newLine
              if);
              oldIndex->IndexIDList.IndextoObject->theObject[];
              (if theObject[] <> none then
                  theObject.theDiagram->theDiagram[];
                  (*
                   (theObject[],true)->theObject.theDiagram.deleteDiagramNode;
                   (pos,newAST[])->theDiagram.insertDiagramNode;    
                   * *)
                  (theObject[],newAST[])->theDiagram.replaceDiagramNode;
              if)
           else
              (oldAst[],newAst[])->(theObject.theDiagram).updateDiagramNode;
          if)
       #);
   Redraw;
   (* refresh the page, due to update delay *)
#)  

-- listElementInserted: DescriptorForm --
(#
(* listElementInserted:
 * # <editorId> listElementInserted <fatherIndex> <position> <synCatNo> <synCatName>
 *) father: ^expanded; newAst,firstBorn: ^ast; pos: @integer
do
   (if switch[22]
    // true then
       'Gpp ------- listElementInserted'->putLine;
       'fatherIndex: '->putText;
       fatherIndex->putInt;
       newLine;
       'position: '->putText;
       position->putInt;
       newLine;
   if);
   fatherIndex->ff.indexToNode->father[];
   father.getson1->firstBorn[];
   (ff[],firstBorn.index)
     ->updateASTfromDisk
       (#
       do
          (if (newff[] <> none )
           // true then
              fatherIndex->newFF.indexToNode->father[];
              (if (father[] <> none )
               // true then
                  position->pos->father.get->newAST[];
                  (pos-1,newAST[])->(theObject.theDiagram).insertDiagramNode;
               else
                  'Gpp ------- listElementInserted: father is none'->putLine;
              if);
           else
              'Gpp ------- listElementInserted: newff is none'->putLine;
          if);
       #);
   Redraw;
   (* refresh the page, due to update delay *)
#)  

-- listElementsDeleted: DescriptorForm --
(#
(* changeSpec:
 * <fatherIndex> <position> <length> <oldElements>
 *  <oldElements> ::= { <elementIndex> } i    (i = <length>)
 *)
   fatherIndex,position,length: @integer;
   oldElements: [1] @integer;
   father: ^expanded;
   anAst: ^ast;
do
   (if switch[22]
    // true then
       'Gpp ------- listElementsDeleted'->putLine; changeSpec[]->putLine;
   if);
   changeSpec.getInt->fatherIndex;
   changeSpec.getInt->position;
   changeSpec.getInt->length;
   (if switch[22]
    // true then
       'fatherIndex: '->putText;
       fatherIndex->putInt;
       newLine;
       'position: '->putText;
       position->putInt;
       newLine;
       'length: '->putText;
       length->putInt;
       newLine;
   if);
   length-1->oldElements.extend;
   (for i: length repeat changeSpec.getInt->oldElements[i] for);
   (if switch[22]
    // true then
       'oldElements: '->putText;
       (for i: length repeat oldElements[i]->putInt; ' '->put; for);
       newLine;
   if);
   fatherIndex->ff.indexToNode->father[];
   position->father.get->anAST[];
   (ff[],anAst.index)
     ->updateASTfromDisk
       (#
       do (*(theObject[],0 ) -> theObject.theDiagram.remakePP;*)
          (for i: length repeat
            oldElements[i]->IndexIDList.IndextoObject->theObject[];
            (if theObject[] <> none then
                (theObject[],true)->(theObject.theDiagram).deleteDiagramNode;
            if)
          for)
       #);
   Redraw;
   (* refresh the page, due to update delay *)
#)  

-- listElementsReplaced: DescriptorForm --
(#
(* changeSpec:
 * <fatherIndex> <position> <length> <oldElements> <newLength> 
 * <oldElements> ::= { <elementIndex> } i    (i = <length>)
 *)
   fatherIndex,position,length,newLength: @integer;
   oldElements: [1] @integer;
   father: ^expanded;
   oldAst,newAst: ^ast;
   theDiagram: ^Diagram;
   pos: @integer
do
   (if switch[22]
    // true then
       'Gpp ------- listElementsReplaced'->putLine; changeSpec[]->putLine;
   if);
   changeSpec.getInt->fatherIndex;
   changeSpec.getInt->position;
   changeSpec.getInt->length;
   (if switch[22]
    // true then
       'fatherIndex: '->putText;
       fatherIndex->putInt;
       newLine;
       'position: '->putText;
       position->putInt;
       newLine;
       'length: '->putText;
       length->putInt;
       newLine;
   if);
   length-1->oldElements.extend;
   (for i: length repeat changeSpec.getInt->oldElements[i] for);
   changeSpec.getInt->newLength;
   (if switch[22]
    // true then
       'oldElements: '->putText;
       (for i: length repeat oldElements[i]->putInt; ' '->put; for);
       newLine;
       'newLength: '->putText;
       newLength->putInt;
       newLine;
   if);
   (ff[],oldElements[1])
     ->updateASTfromDisk
       (#
       do
          (for i: length repeat
            oldElements[i]->IndexIDList.IndextoObject->theObject[];
            (if theObject[] <> none then
                theObject.theDiagram->theDiagram[];
                (theObject[],true)->(theObject.theDiagram).deleteDiagramNode;
            if)
          for);
          fatherIndex->newFF.indexToNode->father[];
          (for i: newlength repeat
            position+i-1->pos->father.get->newAST[];
            (pos-1,newAST[])->theDiagram.insertDiagramNode;
          for)
       #);
   Redraw;
   (* refresh the page, due to update delay *)
#)  

-- makeAnchors: DescriptorForm --
(# noOfNodes,i: @Integer; theObject: ^PatternDiagramNode;
do
   'Freja[[MakeAnchors: '->screen.puttext;
   indexList[]->screen.puttext;
   ']]'->screen.putline;
   indexList.reset;
   indexList.getInt->noOfNodes;
   (for noOfNodes repeat
     indexList.getInt->i->IndexIDList.IndextoObject->theObject[];
     (if theObject[] <> none
      // true then theObject.MakeAnchor;
      else
         'Freja[[No node is presented with index: '->screen.puttext;
         i->screen.putint;
         ']]'->screen.putline;
     if)
   for);
#)  

-- getExtension: DescriptorForm --
(# index: @Integer;
do
   '.'->name.findCh (# do inx->index; #);
   (index,name.length)->name.sub->extension[];
#)  

-- removeExtension: DescriptorForm --
(# rest: ^Text; index: @Integer;
do
   '.'->name.findCh (# do inx->index; #);
   (index,name.length)->name.sub->rest[];
   (if ('.bet'->rest.equal) or ('.ast'->rest.equal)
    // true then (index,name.length)->name.delete;
   if);
#)  

-- doStartup: DescriptorForm --
(# arg: ^Text; swt: @Text; SwitchMode: @Boolean; N: @Integer;
do
   (if NoOfArguments > 1
    // true then
       (for i: NoOfArguments-1 repeat
         i+1->Arguments->arg[];
         0->arg.setpos;
         (if SwitchMode
          // true then
             arg.getint->N;
             (if True
              // (0 < N) and (N <= switch.range) then
                 True->Switch[N];
              // N = 0 then
                 false->SwitchMode;
             if)
          else
             (if arg.peek
              // '-' then
                 arg.get;
                 (if arg.peek
                  // 'd' // 'D' then
                     arg.get;
                     (if arg.eos
                      // true then
                         true->switch[1];
                      // false then
                         (if arg.peek
                          // 'e' then
                             arg.get;
                             (if arg.peek // 'x' then dexterOn if);
                         if)
                     if);
                  // 'p' // 'P' then
                     (i+2->Arguments,i+3->Arguments)->activatedFromSif; i+2->i;
                  // 's' // 'S' then
                     true->SwitchMode; swt.clear;
                 if);
              else
                 arg->removeExtension->openFragmentGroup;
             if)
         if)
       for)
   if)
#)  

-- GetGroupName: DescriptorForm --
(* ask user for a group name *)
  (# name: @Text; ext: ^text;
  do
     'Select a .bet or .ast file'->DSFileNameDialog->name;
     (if name.length > 0
      // true then
         name->getExtension->ext[];
         (if ('.bet'->ext.equal) or ('.ast'->ext.equal) then
             name->removeExtension->name;
             (if switch[1]
              // true then 'Opening: '->puttext; name[]->putline;
             if);
             name->openFragmentGroup
          else
             'You must select a .bet or .ast file!'->DSUIUserAckMessage
         if);
     if);
  #)  

-- OpenFragmentGroup: DescriptorForm --
(#
   myDocument: ^OADDocument;
   opened: @boolean;
   propd: ^myDocument.theGroupPage.PropertyDiagram;
   fragd: ^myDocument.theGroupPage.FragmentDiagram;
   mess: @Text;
   NoOfForms: @Integer;
do
   (if switch[2]
    // true then
       'Opening: '->mess.puttext; name[]->mess.puttext; mess->statusbar.set;
   if);
   thisOperation:
   (name[]->ExpandToFullPath,screen[])
     ->top.open
       (#
          WriteAccessOnLstFileError::< 
            (#
            do
               'Access error on .lst file'->mess;
               mess->DSUIUserAckMessage;
               statusbar.reset;
               true->continue (*'Access error on .lst file'->myException*)
            #);
          writeAccessError::< 
            (#
            do
               'No write access'->mess;
               mess->DSUIUserAckMessage;
               statusbar.reset;
               true
                 ->continue
                 (*'Write access error'->myException
                  * *)
            #);
          startingParsing::< 
            (#
            do
               'Parsing '->mess;
               name[]->mess.putText;
               mess->DSUIUserAckMessage;
               statusbar.reset;
            #);
          ParseErrors::< 
            (#
            do
               none ->f[];
               none ->theCatcher[];
               mess->DSUIUserAckMessage;
               statusbar.reset;
               leave thisOperation
            #)
       #)->fg[];
   (if fg[]
    // none then
       'Cannot open fragmentgroup: '->mess;
       name[]->mess.puttext;
       mess->DSUIUserAckMessage;
       statusbar.reset;
    else
       fg.fragmentlist.scan
         (#
         do (if current.type // formtype then noofforms+1->noofforms if)
         #);
       (if (* fg[] -> isChecked//false *) true
        // false then
           'FragmentGroup '''->puttext;
           name[]->puttext;
           ''' not checked.'->putline;
           'Must be checked by compiler before it can be shown...'->putline;
        else
           (if theDocument[]
            // none then
               &OADDocument[]->myDocument[];
               myDocument.new;
               (if NoOfForms
                // 1 then
                   myDocument.CurrentPage->myDocument.theWorkPage[];
                   'WorkSheet'->myDocument.theWorkPage.PageTitle;
                   &myDocument.OADPage[]->myDocument.theGroupPage[];
                   myDocument.theGroupPage.InvisibleNew;
                   myDocument.theWorkPage[]->myDocument.CurrentPage;
                else
                   myDocument.CurrentPage->myDocument.theGroupPage[];
                   myDocument[]->theDocument[]->theOADDocument[];
               if);
               'Group Window'->myDocument.theGroupPage.PageTitle;
            else
               theDocument[]->myDocument[];
               (if NoOfForms
                // 1 then
                else
                   myDocument.theGroupPage.visible;
               if);
           if);
           scanner:
           myDocument.theGroupPage.PatternDiagrams.theList.scanPropertyDiagrams
             (#
             do
                (if fg.name->(thisDiagram.fullname).equal
                 // true then true->opened; leave scanner;
                if);
             #);
           (if opened
            // true then (* fragment already shown: just show the page *)
               myDocument.theGroupPage[]->myDocument.CurrentPage;
            else
               (if switch[2]
                // true then 'Scanning Properties'->statusbar.set;
               if);
               &myDocument.theGroupPage.PropertyDiagram[]->propd[];
               (fg[],true,name[]->ExpandToFullPath)->propd.new;
               &myDocument.theGroupPage.FragmentDiagram[]->fragd[];
               (if switch[2]
                // true then 'Scanning Fragments'->statusbar.set;
               if);
               fg[]->fragd.new;
           if);
           (if switch[2] // true then statusbar.reset; if);
           (if NoOfForms
            // 1 then
               myDocument.theGroupPage.FragmentDiagram##
                 ->myDocument.theGroupPage.ScanDiagrams
                   (#
                   do
                      current[]->fragd[];
                      (if fg[]
                       // fragd.theGroup then (* find formname in the diagram *)
                          fragd.localnodes.scan (# do current.detail #)
                      if)
                   #)
           if);
       if)
   if)
#)  

-- OpenFragmentForm: DescriptorForm --
(#
   index: @Integer;
   groupname,formname: ^Text;
   fg: ^FragmentGroup;
   theDoc: ^OADDocument;
   theDiagram: ^theDoc.theGroupPage.FragmentDiagram;
   noOfForms: @integer;
do (* first open the group, and then open the form *)
   '-'->name.findCh (# do inx->index; #);
   (1,index-1)->name.sub->groupname[];
   groupname->openFragmentGroup->fg[];
   (index+1,name.length)->name.sub->formname[];
   fg.fragmentlist.scan
     (#
     do
        (if current.type
         // formtype then
            noofforms+1->noofforms;
            (if (current.f.name->formName.equal)
             // true then current.f[]->ff[]
            if)
        if)
     #);
   theDocument[]->theDoc[];
   (*   'Scanning prop diagrams: ' -> screen.puttext; fg.name -> screen.puttext;
    '-' -> screen.put; formname[] -> screen.putline;*)
   theDoc.theGroupPage.FragmentDiagram##
     ->theDoc.TheGroupPage.ScanDiagrams
       (#
       do
          current[]->theDiagram[];
          theDiagram.fullname->screen.putline;
          (if fg[]
           // theDiagram.theGroup then (* find formname in the diagram *)
              theDiagram.localnodes.scan
                (# t: ^text;
                do
                   &Text[]->t[];
                   current.theText.get->t;
                   ':'->t.findCh (# do inx->index #);
                   (1,index-1)->t.sub->t[];
                   (*'Form: ' -> screen.puttext; t[] -> screen.putline;*)
                   EditorID->current.SifEditorInstanceNo;
                   (if (formname[]->t.equal) and (noOfForms > 1)
                    // true then
                    (* if noOfForms = 1 the form has already been opened 
                     * by openFragmentGroup
                     *)
                       current.detail;
                   if)
                #)
          if)
       #)
#)  

-- ScanDiagrams: DescriptorForm --
(#
do
   PatternDiagrams.theList.scan
     (#
     do
        current.e[]->THIS(ScanDiagrams).current[];
        (if theDiagramType##
         // none then INNER ScanDiagrams;
         else
            (if current.e.struc <= theDiagramType##
             // true then INNER ScanDiagrams;
            if)
        if)
     #)
#)  

-- MarkNodeDisplay: DescriptorForm --
(#
do
   (pos.x,pos.y,gppProp.marksize,gppProp.marksize)->new;
   theNode[]->thePatternDiagramNode;
   THIS(MarkNode)[]->(thePatternDiagramNode).theMarkNode;
   false->sizeable;
#)  

-- MarkNodeOnInit: DescriptorForm --
(#
do
   UDPrivate.UDMarkNode->UserDataInit;
   thePatternDiagramNode.Init;
   6->theText.size;
   false->moveable;
   false->sizeable;
   (if not initialisingSaved then theNode[]->CreateRegion if);
#)  

-- titleGetFragment: DescriptorForm --
(# fn: ^FragmentNode;
do
   (if theFragmentNode <> none
    // true then theFragmentNode->fn[]; fn.theFragment->f[];
    else
       'DiagramNode: GetFragment: no FragmentNode'->screen.putline
   if)
#)  

