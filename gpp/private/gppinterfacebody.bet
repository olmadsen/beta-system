ORIGIN 'diagramattributes';
(* switch
 * 1  = general debugging
 * 21 = IndexIDList
 * 22 = AstReplaced
 *)
INCLUDE 'objectgppproperties'
        '~beta/designenv/v1.5/private/userdatabody';
-- IndexIDListInsert: Descriptor --
(# 
do
   (if switch[21]
    // true then
       '%21GPP: Insert element indexed: '->screen.puttext;
       a->screen.putint;
       screen.newline;
       
   if)
#)  

-- ASTToNode: Descriptor --
(# 
do
   (if switch[21] then 'ASTtoNode: '->putText if);
   (if anAST[]
    // none then 'ASTtoNode: anAST is none!'->putLine; 
    else
       (if switch[21] then anAST.index->putInt;  if);
       search:
       anAST.index
         ->indexIDList.scan
           (# 
           do
              currentNode[]->theNode[];
              (if theNode.getFragment
               // none then
                  'ASTtoNode: theNode.getFragment is none!'->putLine; 
               else
                  (if
                  (theNode.getFragment).fullName->(anAST.frag.fullname).equal
                   then
                      leave search
                  if)
              if);
              
           #);
       (if switch[21] then
           ' return: '->putText;
           (if theNode[]
            // none then 'none'->putLine
            else
               theNode.id->putInt; newLine
           if);
           
       if)
   if);
   
#)  

-- ASTToNodeListUpdate: Descriptor --
(# ff: ^FragmentForm; oldASTName: ^Text; 
do
   (if switch[21] then 'ASTtoNodeListUpdate: '->putText;  if);
   (if oldAST[]
    // none then 'ASTtoNodeListUpdate: oldAST is none!'->putLine; 
    else
       (if switch[21] then oldAST.index->putInt; ' '->put;  if);
       (if newAST[]
        // none then 'ASTtoNodeListUpdate: newAST is none!'->putLine; 
        else
           (if switch[21] then newAST.index->putInt;  if);
           search:
           oldAST.index
             ->indexIDList.scan
               (# 
               do
                  currentNode[]->theNode[];
                  (if theNode.getFragment
                   // none then
                      'ASTtoNodeListUpdate: theNode.getFragment is none!'
                        ->putLine;
                      
                   else
                      theNode.getFragment->ff[];
                      oldAST.frag.fullname->oldASTName[];
                      (if ff.fullname->oldASTName.equal then
                          newAst.Index->indexIDList.impl[i]; leave search
                      if)
                  if);
                  
               #)
       if);
       (if switch[21] then
           ' return: '->putText;
           (if theNode[]
            // none then 'none'->putLine
            else
               theNode.id->putInt; newLine
           if);
           
       if);
       
   if)
#)  

-- GppPromptForText: Descriptor --
(# status: @Text; prompt: [1] @char; answerRep: [64] @Char; t: @Text
do
   message->prompt;
   (if (prompt,@@ answerRep[1])->DSUIGetString then
       @@ answerRep[1]->cStringToCharRep->t; t.copy->confirm
    else
       cancel
   if)
#)  

-- InitGPP: Descriptor --
(# 
do
   betaGram.init;
   metaGram.init;
   '~beta/grammars/beta/v2.4/beta-parser.btab'->expandToFullPath
     ->betaGram.parser.initialize;
   ('~beta/grammars/beta/v2.4/beta-meta-beta'->expandToFullPath,screen[])
     ->top.open->betaGram.grammarAST[];
   metaGram[]->GrammarTable.meta[];
   
#)  

-- OADDocumentInit: Descriptor --
(# (* setup the DesignOA menus we like to use in OADDocument *) 
do (* DocEditMenu.init; *)
   INNER onInit;
   (* (UserMenu3,'Options')->OptionsMenu.init; *)
   (UserMenu7,'Page')->PageMenu.init;
   (UserMenu4,'View')->DisplayMenu.init;
   (UserMenu5,'Object')-> (*kja&toby 1.9.94*) ObjectMenu.init;
   MenuId.CreateMenu->DisplayMenu.insertBefore;
   true->OGppProp.StaticRefCheck;
   true->OGppProp.LocalIncludeScan->ObjectMenu.LocalIncludeScan.check;
   true->OGppProp.ShowDynamicCreations->ObjectMenu.ToggleDynamicCreations.check;
   true->OGppProp.ShowOperationCalls->ObjectMenu.ToggleProcedureCalls.check;
   (*(UserMenu6,'Marks') -> MarkMenu.init;*)
   (* new document makes a new page by default
    * if we like a special page the make it here *)
   &OADPage[]->newPage[];
   (* set/clear appopriate check marks in the menus *)
   (*MarkMenu.CheckCheckMarks;*)
   OptionsMenu.CheckCheckMarks;
   
#)  

-- OADPageOnInit: Descriptor --
(# integerData: @integer; ok: @Boolean; listsize,last: @integer
do
   (if userDataVerbose then
       'onInit called on OADPage with id='->puttext;
       id->putint;
       newline;
       'Reading OADPage UserDataID: '->puttext
   if);
   (Id,1,@@ integerData)->UDReadType->ok;
   (if ok then
       (if userDataVerbose then
           'Read OADPage UserDataID succeed: '->puttext;
           integerData->putint;
           newline
       if);
       (integerData,ID)->UserDataIDMap.putID;
       
    else
       (if userDataVerbose then 'Read OADPage UserDataID fail'->putline if)
   if);
   ID->integerData;
   (Id,1,@@ integerData,4)->UDWriteType->ok;
   (if ok then
       (if userDataVerbose then
           'Write OADPage UserDataID succeed: '->puttext;
           integerData->putint;
           newline
       if)
    else
       (if userDataVerbose then 'Write OADPage UserDataID fail'->putline if)
   if);
   (if THIS(OADPage)[] = theGroupPage[] then
       (theGroupPage.ID,499,@@ listsize)->UDReadType->ok;
       (if ok then
           listsize->IndexIDList.impl.new;
           (if userDataVerbose then
               'Read IndexIDList.impl.range succeed: '->puttext;
               listsize->putint;
               newline
           if);
           (theGroupPage.ID,500,@@ last)->UDReadType->ok;
           (if ok then
               last->IndexIDList.last;
               (if userDataVerbose then
                   'Read IndexIDList.last succeed: '->puttext;
                   last->putint;
                   newline
               if);
               (for i: listsize repeat
                 (theGroupPage.ID,500+i,@@ IndexIDList.impl[i])->UDReadType->ok;
                 (if ok then
                     (if userDataVerbose then
                         'Read IndexIDList succeed: '->puttext;
                         'element no '->puttext;
                         i->putint;
                         'element '->puttext;
                         IndexIDList.impl[i]->putint;
                         newline
                     if)
                  else
                     'Read IndexIDList fail: '->puttext
                 if)
               for)
            else
               (if userDataVerbose then
                   'Read IndexIDList.last fail: '->puttext
               if)
           if)
        else
           (if userDataVerbose then
               'Read IndexIDList.impl.range fail: '->puttext
           if)
       if)
   if);
   (ID,240,@@ NextX)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read NextX succeed'->putline
        else
           'Read NextX fail'->putline
       if)
   if);
   (ID,241,@@ NextY)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read NextY succeed'->putline
        else
           'Read NextY fail'->putline
       if)
   if);
   (ID,250,@@ patternDiagrams.NextFreeLine)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read NextFreeLine succeed'->putline
        else
           'Read NextFreeLine fail'->putline
       if)
   if);
   (ID,251,@@ patternDiagrams.NextFreeColumn)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read NextFreeColumn succeed'->putline
        else
           'Read NextFreeColumn fail'->putline
       if)
   if);
   (ID,252,@@ patternDiagrams.SecondFreeLine)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read SecondFreeline succeed'->putline
        else
           'Read SecondFreeLine fail'->putline
       if)
   if);
   (ID,253,@@ patternDiagrams.SecondFreeColumn)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read SecondFreeColumn succeed'->putline
        else
           'Read SecondFreeColumn fail'->putline
       if)
   if);
   false->borderVisible;
   (*gppProp.NextPositionStartX*)
   250->nextX;
   (*gppProp.NextPositionStartY*)
   250->nextY;
   true->doScrollIntoView;
   
#)  

-- CalculateNextCenter: Descriptor --
(# x,y,w,h: @Integer; p: ^OADPage; 
do
   (if PatternDiagrams.theList.size
    // 0 then (* first diagram on page *)
       CurrentPage->p[];
       p.Geometry->(x,y,w,h);
       (* center, width, and height of PAGE *)
       y-(h div 2)+gppProp.DownOnPage->PatternDiagrams.NextFreeLine;
       x-(w div 2)+gppProp.RightOnPage->PatternDiagrams.NextFreeColumn;
       PatternDiagrams.NextFreeLine->PatternDiagrams.SecondFreeLine;
       PatternDiagrams.NextFreeColumn+gppProp.width+gppProp.RightFromPrevious
         ->PatternDiagrams.SecondFreeColumn;
       
   if);
   (PatternDiagrams.NextFreeColumn,PatternDiagrams.NextFreeLine)->theCenter;
   (*(nextX,nextY)->theCenter;*)
   
#)  

-- UpdateNextFree: Descriptor --
(# w,h: @Integer; 
do
   (if x-gppProp.width > theCenter.x then
   (* we have the last box on another column than the title *)
       x->PatternDiagrams.NextFreeColumn; 
   if);
   (PatternDiagrams.NextFreeLine,y+gppProp.DownFromPrefix)->Max
     ->PatternDiagrams.NextFreeLine;
   (PatternDiagrams.SecondFreeColumn,x+gppProp.width+gppProp.RightFromPrevious)
     ->Max->PatternDiagrams.SecondFreeColumn;
   (* check that nextFreeLine is inside the bound of the page *)
   THIS(OADPage).Geometry->(x,y,w,h);
   (if PatternDiagrams.NextFreeLine > y+(h div 2) then
   (* PatternDiagrams.SecondFreeLine -> PatternDiagrams.NextFreeLine;*)
       y-(h div 2)+gppProp.DownOnPage->PatternDiagrams.NextFreeLine;
       (if PatternDiagrams.NextFreeColumn < theCenter.x then
           PatternDiagrams.SecondFreeColumn->PatternDiagrams.NextFreeColumn;
           PatternDiagrams.SecondFreeColumn+gppProp.width+
           gppProp.RightFromPrevious->PatternDiagrams.SecondFreeColumn;
           
       if);
       
   if);
   
#)  

-- StartCreatePrefix: Descriptor --
(#
   PC: Connector
     (#
        onInit::< 
          (# prefixTitle,title: ^PatternDiagramNode; a,b: ^Node; 
          do
             0->Orient;
             GetEnds->(a[],b[]);
             (if (a[] <> none ) and (b[] <> none )
              // true then
                 (if a.struc <= PatternDiagramNode##
                  // true then a[]->title[]; 
                  else
                     'Incorrect pattern node selected'->gppalert; 
                 if);
                 (if b.struc <= PatternDiagramNode##
                  // true then
                     b[]->prefixtitle[];
                     (if prefixtitle.theDiagram
                      // none then 'Incorrect prefix selected'->gppalert; 
                      else
                         (prefixtitle.theDiagram).titlenode[]->prefixtitle[]; 
                     if)
                  else
                     'Incorrect prefix selected'->gppalert; 
                 if);
                 (prefixTitle[],title[])->PrefixExpand;
                 
              else
                 'Incorrect nodes selected in prefix creation'->gppalert; 
             if);
             
          #);
        interactivenew::< 
          (# cursorformat::<  (#  do cursor.arrow->curs #) #)
     #);
   aPC: ^PC;
   
do
   &PC[]->aPC[];
   'Specify Prefix by first selecting the Pattern and then the prefix'
     ->aPC.interactivenew;
   
#)  

-- updateASTfromDisk: Descriptor --
(# g: ^FragmentGroup; ff: ^FragmentForm; anAST: ^AST; 
do
   (if switch[22]
    // true then
       'Gpp ------- updateASTfromDisk'->putLine;
       'oldindex: '->putText;
       oldindex->putInt;
       newLine;
       
   if);
   true->status;
   (*oldIndex->IndexIDList.IndextoObject->theObject[];*)
   oldIndex
     ->oldff.indexToNode
       (#
          indexOutOfRange::< 
            (#  do 'indexOutOfRange'->putLine; true->continue;  #);
          noSuchSymbol::< 
            (#  do 'noSuchSymbol'->putLine; true->continue;  #);
          grammarGenRefArrayError::< 
            (#  do 'grammarGenRefArrayError'->putLine; true->continue;  #)
       #)->anAST[];
   (if anAST[] = none then
       'Gpp updateASTfromDisk: node not found'->putLine
    else
       anAST[]->ASTtoNode->theObject[];
       (if theObject[]
        // none then
           (if CurrentFocus[] <> none
            // true then
               CurrentFocus.getFragment->ff[];
               (if ff[]
                // none then
                   'Freja: UpdateASTfromDisk: Cannot find FragmentForm for CurrentFocus'
                     ->screen.putline;
                   
                else
                   (if anAST[]
                    // none then 'Freja[[Old AST is: none'->screen.putLine
                    else
                       (if switch[22]
                        // true then
                           'Freja[[Old AST is: '->screen.puttext;
                           anAST.index->screen.putint;
                           ' symbol: '->screen.puttext;
                           anAST.symbol->betagram.symboltoname->screen.puttext;
                           ']]'->screen.putline;
                           
                       if);
                       L:
                       (if 1
                        // 1 then
                           anAST.father->anAST[];
                           (if anAST[] <> none
                            // true then
                            (*anAST.index->IndexIDList.IndextoObject->theObject[];*)
                               anAST[]->ASTtoNode->theObject[];
                               (if switch[1]
                                // true then
                                   'Freja[[N''th father to old AST is: '
                                     ->screen.puttext;
                                   anAST.index->screen.putint;
                                   ' symbol: '->screen.puttext;
                                   anAST.symbol->betagram.symboltoname
                                     ->screen.puttext;
                                   ']]'->screen.putline;
                                   
                               if);
                               (if theObject[] // none then restart L if);
                               
                           if)
                       if);
                       
                   if)
               if)
            else
               'Freja: UpdateASTfromDisk: CurrentFocus is NONE'->screen.putline;
               false->status;
               
           if);
           
       if);
       (if theObject[] <> none
        // true then (* object found; read the AST from disk *)
           theObject.getGroup->g[];
           (if g[] <> none
            // true then (* read the AST in from disk *)
               (if switch[2]
                // true then 'Reading in new AST'->statusbar.set
               if);
               (if switch[22]
                // true then
                   'Freja[[Reading in new AST... ]]'->screen.putline; 
               if);
               g.init;
               screen[]->g.unpack;
               (oldff[],theObject[])->(theObject.theDiagram).updateASTfromDisk
                 ->newff[];
               INNER updateASTfromDisk;
               (if switch[2] // true then statusbar.reset if);
               
            else
               false->status;
               'Freja: UpdateASTfromDisk: cannot find FragmentDiagram'
                 ->screen.putline;
               
           if);
           
        else
           false->status;
           'Freja: UpdateASTfromDisk: cannot find old object'->screen.putline;
           
       if)
   if);
   (if switch[22]
    // true then 'Gpp ------- End updateASTfromDisk'->putLine; 
   if);
   
#)  

-- gppChangedFocus: Descriptor --
(# 
do (* true->OKtoChange;*)
   currentFocus[]->oldFocus[];
   newObject[]
     ->CurrentFocus[]
     (*  else
      oldObject[]->currentObject
      if)*) ;
   (* (if OKToChange then*)
   INNER changedFocus
#)  

-- newFragment: Descriptor --
(# 
do (if switch[22] // true then 'Gpp ------- newFragment'->putLine;  if); 
#)  

-- astReplaced: Descriptor --
(#
   oldAst,newAst: ^ast;
   pos: @integer;
   theDiagram: ^Diagram;
   doListReplace: @boolean;
   deleted: @boolean;
   dummyFilter: ##external;
   pageList: ^ObjectList;
   filename: @Text;
   nonterminalName: ^Text;
   cancelled: ^integerRef;
   prompt: @text;
   count: @ShortRef;
   list: @IntegerRef;
   theListDiagram: ^ListDiagram;
   theAbstractNode: ^theListDiagram.AbstractNode;
   theunexp: ^unexpanded;
   
do
   (if switch[22]
    // true then
       'Gpp ------- astReplaced'->putLine;
       'oldindex: '->putText;
       oldindex->putInt;
       newLine;
       'newindex: '->putText;
       newindex->putInt;
       newLine;
       
   if);
   true->status;
   oldIndex
     ->ff.indexToNode
       (#
          indexOutOfRange::< 
            (#  do 'indexOutOfRange'->putLine; true->continue;  #);
          noSuchSymbol::< 
            (#  do 'noSuchSymbol'->putLine; true->continue;  #);
          grammarGenRefArrayError::< 
            (#  do 'grammarGenRefArrayError'->putLine; true->continue;  #)
       #)->oldAST[];
   (if oldAST[] = none then
       'Gpp astReplaced: old node not found'->putLine
    else
       thisOp:
         (# 
         do
            (ff[],oldIndex)
              ->updateASTfromDisk
                (# 
                do
                   newIndex
                     ->newff.indexToNode
                       (#
                          indexOutOfRange::< 
                            (# 
                            do 'indexOutOfRange'->putLine; true->continue; 
                            #);
                          noSuchSymbol::< 
                            (# 
                            do 'noSuchSymbol'->putLine; true->continue; 
                            #);
                          grammarGenRefArrayError::< 
                            (# 
                            do
                               'grammarGenRefArrayError'->putLine;
                               true->continue;
                               
                            #)
                       #)->newAST[];
                   (if newAST[] = none then
                       'Gpp astReplaced: new node not found'->putLine;
                       leave thisOP
                   if);
                   (if oldAST.kind
                    // kinds.unExpanded then
                    (* this is an ECOOP94 hack, must be generalized *)
                       (if newAst.kind
                        // kinds.interior then
                           (if switch[22]
                            // true then 'expanding a nonterminal'->putLine; 
                           if);
                           (if NewAST.symbol
                            // betaGram.nameDcl then
                               (if switch[22]
                                // true then '  it is a nameDcl'->putLine; 
                               if);
                               
                            else
                               (if (NewAST.struc <= betaGram.attributeDecl##)
                                // true then
                                   (if switch[22]
                                    // true then
                                       '  it is a declaration: '->putText;
                                       NewAST.symbol->putInt;
                                       newLine;
                                       
                                   if);
                                   true->doListReplace;
                                   
                                else
                                   
                               if)
                           if);
                           
                        // kinds.optional then
                           oldAST[]->ASTtoNode->theObject[];
                           (if theObject[] <> none then
                               theObject.theDiagram->theDiagram[];
                               (theObject[],true)->theDiagram.deleteDiagramNode;
                               true->deleted;
                               
                           if)
                       if)
                    // kinds.interior then
                       (if newAST.kind = kinds.interior then
                           (if oldAST## <= betaGram.attributeDecl## then
                               (if newAST## <= betaGram.attributeDecl## then
                                   (if oldAST## <> newAST## then
                                       true->doListReplace
                                   if)
                               if)
                           if)
                        else
                           true->doListReplace
                       if)
                    // kinds.optional then
                       (if newAST.kind = kinds.unexpanded then
                           newAST[]->theunexp[];
                           theunexp.nonTerminalSymbol->betaGram.symbolToName
                             ->nonterminalName[];
                           (if 'AttributeDeclOpt'->nonterminalName.equal then
                               theObject.theDiagram->theListDiagram[];
                               (if theObject## <= theListDiagram.AbstractNode##
                                then
                                   theObject[]->theAbstractNode[];
                                   (if theAbstractNode.currentDecomposDiagram <>
                                   none then
                                       (newAST.sonNo-1,newAST[])
                                         ->
                                           (
                                           theAbstractNode.
                                             currentDecomposDiagram).
                                           insertDiagramNode
                                   if)
                               if)
                           if)
                       if)
                   if);
                   (if doListReplace
                    // true then
                       oldAST.sonNo->pos;
                       (if switch[22]
                        // true then
                           'sonNo is: '->putText; pos->putInt; newLine
                       if);
                       oldAST[]->ASTtoNode->theObject[];
                       (if theObject[] <> none then
                           theObject.theDiagram->theDiagram[];
                           (*
                            (theObject[],true)->theObject.theDiagram.deleteDiagramNode;
                            (pos,newAST[])->theDiagram.insertDiagramNode;    
                            * *)
                           (theObject[],newAST[])
                             ->theDiagram.replaceDiagramNode;
                           
                       if)
                    else
                       (if not deleted then
                           (if theObject[] <> none then
                               (oldAst[],newAst[])
                                 ->(theObject.theDiagram).updateDiagramNode
                            else
                               'astReplaced: theObject is none'->putline
                           if)
                       if);
                       
                   if)
                #);
            Redraw
         #)
   if);
   autosave;
   (* refresh the page, due to update delay *)
   
#)  

-- listElementInserted: Descriptor --
(#
(* listElementInserted:
 * # <editorId> listElementInserted <fatherIndex> <position> <synCatNo> <synCatName>
 *) father: ^expanded; newAst,firstBorn: ^ast; pos: @integer
do
   (if switch[22]
    // true then
       'Gpp ------- listElementInserted'->putLine;
       'fatherIndex: '->putText;
       fatherIndex->putInt;
       newLine;
       'position: '->putText;
       position->putInt;
       newLine;
       
   if);
   fatherIndex
     ->ff.indexToNode
       (#
          indexOutOfRange::< 
            (#  do 'indexOutOfRange'->putLine; true->continue;  #);
          noSuchSymbol::< 
            (#  do 'noSuchSymbol'->putLine; true->continue;  #);
          grammarGenRefArrayError::< 
            (#  do 'grammarGenRefArrayError'->putLine; true->continue;  #)
       #)->father[];
   (if father[] = none then
       'Gpp listElementInserted: father not found'->putLine
    else
       father.getson1->firstBorn[];
       (ff[],firstBorn.index)
         ->updateASTfromDisk
           (# 
           do
              (if (newff[] <> none )
               // true then
                  fatherIndex
                    ->newff.indexToNode
                      (#
                         indexOutOfRange::< 
                           (# 
                           do 'indexOutOfRange'->putLine; true->continue; 
                           #);
                         noSuchSymbol::< 
                           (# 
                           do 'noSuchSymbol'->putLine; true->continue; 
                           #);
                         grammarGenRefArrayError::< 
                           (# 
                           do
                              'grammarGenRefArrayError'->putLine;
                              true->continue;
                              
                           #)
                      #)->father[];
                  (if (father[] <> none )
                   // true then
                      position->pos->father.get->newAST[];
                      (pos-1,newAST[])
                        ->(theObject.theDiagram).insertDiagramNode;
                      
                   else
                      'Gpp ------- listElementInserted: father is none'
                        ->putLine;
                      
                  if);
                  
               else
                  'Gpp ------- listElementInserted: newff is none'->putLine; 
              if);
              
           #);
       Redraw
   if);
   autosave;
   (* refresh the page, due to update delay *)
   
#)  

-- listElementsDeleted: Descriptor --
(#
(* changeSpec:
 * <fatherIndex> <position> <length> <oldElements>
 *  <oldElements> ::= { <elementIndex> } i    (i = <length>)
 *)
   fatherIndex,position,length: @integer;
   oldElements: [1] @integer;
   father: ^expanded;
   anAst: ^ast;
   
do
   (if switch[22]
    // true then
       'Gpp ------- listElementsDeleted'->putLine; changeSpec[]->putLine; 
   if);
   changeSpec.getInt->fatherIndex;
   changeSpec.getInt->position;
   changeSpec.getInt->length;
   (if switch[22]
    // true then
       'fatherIndex: '->putText;
       fatherIndex->putInt;
       newLine;
       'position: '->putText;
       position->putInt;
       newLine;
       'length: '->putText;
       length->putInt;
       newLine;
       
   if);
   length-1->oldElements.extend;
   (for i: length repeat changeSpec.getInt->oldElements[i] for);
   (if switch[22]
    // true then
       'oldElements: '->putText;
       (for i: length repeat oldElements[i]->putInt; ' '->put;  for);
       newLine;
       
   if);
   fatherIndex
     ->ff.indexToNode
       (#
          indexOutOfRange::< 
            (#  do 'indexOutOfRange'->putLine; true->continue;  #);
          noSuchSymbol::< 
            (#  do 'noSuchSymbol'->putLine; true->continue;  #);
          grammarGenRefArrayError::< 
            (#  do 'grammarGenRefArrayError'->putLine; true->continue;  #)
       #)->father[];
   thisOp:
   (if father[] = none then
       'Gpp listElementInserted: father not found'->putLine
    else
       position->father.get->anAST[];
       (ff[],anAst.index)
         ->updateASTfromDisk
           (# 
           do (*(theObject[],0 ) -> theObject.theDiagram.remakePP;*)
              (for i: length repeat
              (*oldElements[i]->IndexIDList.IndextoObject->theObject[];*)
                oldElements[i]
                  ->ff.indexToNode
                    (#
                       indexOutOfRange::< 
                         (# 
                         do 'indexOutOfRange'->putLine; true->continue; 
                         #);
                       noSuchSymbol::< 
                         (# 
                         do 'noSuchSymbol'->putLine; true->continue; 
                         #);
                       grammarGenRefArrayError::< 
                         (# 
                         do
                            'grammarGenRefArrayError'->putLine; true->continue; 
                         #)
                    #)->anAST[];
                (if anAST[] = none then
                    'Gpp listElementInserted: old node not found'->putLine;
                    leave thisOp
                if);
                anAST[]->ASTtoNode->theObject[];
                (if theObject[] <> none then
                    (theObject[],true)
                      ->(theObject.theDiagram).deleteDiagramNode;
                    
                if)
              for)
           #);
       Redraw
   if);
   autosave;
   (* refresh the page, due to update delay *)
   
#)  

-- listElementsReplaced: Descriptor --
(#
(* changeSpec:
 * <fatherIndex> <position> <length> <oldElements> <newLength> 
 * <oldElements> ::= { <elementIndex> } i    (i = <length>)
 *)
   fatherIndex,position,length,newLength: @integer;
   oldElements: [1] @integer;
   father: ^expanded;
   oldAst,newAst,anAST: ^ast;
   theDiagram: ^Diagram;
   pos,oldIndex: @integer
do
   (if switch[22]
    // true then
       'Gpp ------- listElementsReplaced'->putLine; changeSpec[]->putLine; 
   if);
   changeSpec.getInt->fatherIndex;
   changeSpec.getInt->position;
   changeSpec.getInt->length;
   (if switch[22]
    // true then
       'fatherIndex: '->putText;
       fatherIndex->putInt;
       newLine;
       'position: '->putText;
       position->putInt;
       newLine;
       'length: '->putText;
       length->putInt;
       newLine;
       
   if);
   (if length > 0 then
       length-1->oldElements.extend;
       (for i: length repeat changeSpec.getInt->oldElements[i] for);
       oldElements[1]->oldIndex
    else
   (* in this case there is no old node, e.g. when undoing 
    delete of list elements *)
       fatherIndex->oldIndex
   if);
   changeSpec.getInt->newLength;
   (if switch[22]
    // true then
       'oldElements: '->putText;
       (for i: length repeat oldElements[i]->putInt; ' '->put;  for);
       newLine;
       'newLength: '->putText;
       newLength->putInt;
       newLine;
       
   if);
   thisOp:
     (# 
     do
        (ff[],oldIndex)
          ->updateASTfromDisk
            (# 
            do
               (for i: length repeat
               (*oldElements[i]->IndexIDList.IndextoObject->theObject[];*)
                 oldElements[i]
                   ->ff.indexToNode
                     (#
                        indexOutOfRange::< 
                          (# 
                          do 'indexOutOfRange'->putLine; true->continue; 
                          #);
                        noSuchSymbol::< 
                          (# 
                          do 'noSuchSymbol'->putLine; true->continue; 
                          #);
                        grammarGenRefArrayError::< 
                          (# 
                          do
                             'grammarGenRefArrayError'->putLine;
                             true->continue;
                             
                          #)
                     #)->anAST[];
                 (if anAST[] = none then
                     'Gpp listElementReplaced: old node not found'->putLine;
                     leave thisOp
                 if);
                 anAST[]->ASTtoNode->theObject[];
                 (if theObject[] <> none then
                     theObject.theDiagram->theDiagram[];
                     (theObject[],true)
                       ->(theObject.theDiagram).deleteDiagramNode;
                     
                 if)
               for);
               fatherIndex
                 ->newff.indexToNode
                   (#
                      indexOutOfRange::< 
                        (# 
                        do 'indexOutOfRange'->putLine; true->continue; 
                        #);
                      noSuchSymbol::< 
                        (#  do 'noSuchSymbol'->putLine; true->continue;  #);
                      grammarGenRefArrayError::< 
                        (# 
                        do 'grammarGenRefArrayError'->putLine; true->continue; 
                        #)
                   #)->father[];
               (if father[] = none then
                   'Gpp listElementReplaced: father node not found'->putLine;
                   leave thisOp
               if);
               (for i: newlength repeat
                 position+i-1->pos->father.get->newAST[];
                 (if theDiagram[] = none then
                     'Gpp: ListElementsReplaced: theDiagram is none!!'->putLine
                  else
                     (pos-1,newAST[])->theDiagram.insertDiagramNode
                 if);
                 
               for);
               
            #);
        Redraw
     #);
   autosave;
   ;
   (* refresh the page, due to update delay *)
   
#)  

-- makeAnchors: Descriptor --
(# noOfNodes,i: @Integer; theObject: ^PatternDiagramNode; 
do
(*'Freja[[MakeAnchors: '->screen.puttext;
 indexList[]->screen.puttext;
 ']]'->screen.putline;
 indexList.reset;
 indexList.getInt->noOfNodes;
 (for noOfNodes repeat
 indexList.getInt->i->IndexIDList.IndextoObject->theObject[];
 (if theObject[] <> none
 // true then theObject.MakeAnchor;
 else
 'Freja[[No node is presented with index: '->screen.puttext;
 i->screen.putint;
 ']]'->screen.putline;
 if)
 for);
 * *) 
#)  

-- getExtension: Descriptor --
(# index: @Integer; 
do
   '.'->name.findCh (#  do inx->index;  #);
   (index,name.length)->name.sub->extension[];
   
#)  

-- removeExtension: Descriptor --
(# rest: ^Text; index: @Integer; 
do (*(if ('.bet'->rest.equal) or (astFileExtension->rest.equal)
    // true then*)
   '.'->name.findCh (#  do inx->index;  #);
   (index,name.length)->name.sub->rest[];
   (* if);*)
   (index,name.length)->name.delete;
   ;
   (*(if ('.bet'->rest.equal) or (astFileExtension->rest.equal)
    // true then*)
   
#)  

-- doStartup: Descriptor --
(#
   arg: ^Text;
   swt: @Text;
   SwitchMode: @Boolean;
   N: @Integer;
   myDocument: ^OADDocument;
   count: @ShortRef;
   list: @IntegerRef;
   pages: [0] @integer;
   thePage: ^theDocument.Page;
   theOADPage: ^theOADDocument.OADPage;
   theObject: ^thePage.DesignObject;
   theConnID: @integer;
   ext: ^Text;
   
do
   (if NoOfArguments > 1
    // true then
       (for i: NoOfArguments-1 repeat
         i+1->Arguments->arg[];
         0->arg.setpos;
         (if SwitchMode
          // true then
             arg.getint->N;
             (if True
              // (0 < N) and (N <= switch.range) then
                 True->Switch[N]; 
              // N = 0 then
                 false->SwitchMode; 
             if)
          else
             (if arg.peek
              // '-' then
                 arg.get;
                 (if arg.peek
                  // 'd' // 'D' then
                     arg.get;
                     (if arg.eos
                      // true then
                         true->switch[1]; 
                      // false then
                         (if arg.peek
                          // 'e' then
                             arg.get;
                             (if arg.peek // 'x' then dexterOn if);
                             
                         if)
                     if);
                     
                  // 'p' // 'P' then
                     (i+2->Arguments,i+3->Arguments)->activatedFromSif; i+2->i; 
                  // 's' // 'S' then
                     true->SwitchMode; swt.clear; 
                 if);
                 
              else
                 (if arg.length > 0
                  // true then
                     arg->getExtension->ext[];
                     (if ('.bet'->ext.equal) or (astFileExtension->ext.equal)
                      then
                         arg->removeExtension->arg;
                         arg.copy->currentDiagramName[];
                         '.diag'->currentDiagramName.append;
                         (if switch[1]
                          // true then 'Opening: '->puttext; arg[]->putline; 
                         if);
                         arg->openFragmentGroup
                      else
                         (if '.diag'->ext.equal then
                             arg->checkAutoSaveFile;
                             (if arg->checkDiagFile then
                                 arg[]->currentDiagramName[];
                                 (@@ arg.T[1])->DSFileOpenDiagram;
                                 &OADDocument[]->theDocument[]
                                   ->theOADDocument[];
                                 theDocument.onInit;
                                 (count[],list[])->DSStrGetPageList;
                                 (count,list)->GetIntList->pages;
                                 (if pages.range > 0 then
                                     (for i: pages.range repeat
                                       (if i = 1 then
                                           &theOADDocument.OADPage[]->thePage[]
                                             ->theOADDocument.theGroupPage[];
                                           
                                        else
                                           &theOADDocument.OADPage[]->thePage[]
                                             ->theOADDocument.theWorkPage[];
                                           
                                       if)
                                       (* toby 24-11-94: VERY temporary hack (i hope)!!*)
                                       ;
                                       pages[i]->thePage.onInit;
                                       true->thePage.PageCallBack.specialNode;
                                       thePage.onReadDiagram;
                                       
                                     for);
                                     theOADDocument.theWorkPage[]
                                       ->theDocument.CurrentPage;
                                     theOADDocument.updateUserDataIDs;
                                     loop
                                       (#
                                          i: @integer;
                                          while::< 
                                            (# 
                                            do
                                               (i+2 <= IndexIDList.impl.range)
                                                 ->value
                                            #)
                                       do
                                          i+2->i;
                                          (if IndexIDList.impl[i] <> 0 then
                                              (if userDataVerbose then
                                                  'IndexIDList: updating '
                                                    ->puttext;
                                                  indexidlist.impl[i]->putint
                                              if);
                                              IndexIDList.impl[i]
                                                ->
                                                  theOADDocument.UserDataIDMap.
                                                    getID->IndexIDList.impl[i];
                                              (if userDataVerbose then
                                                  ' to '->puttext;
                                                  indexidlist.impl[i]->putint;
                                                  newline
                                              if)
                                          if)
                                       #);
                                     theOADDocument.theWorkPage.PatternDiagrams.
                                       theList.scan
                                       (#
                                          theListDiagram:
                                            ^theOADDocument.theWorkPage.
                                               ListDiagram
                                       do
                                          current.e[]->theListDiagram[];
                                          theListDiagram[]
                                            ->
                                              theOADDocument.theWorkPage.
                                                PageCallBack.MakeLocalNodes;
                                          theListDiagram.titleNode.thePrefixConn
                                          .getID->theConnID;
                                          (if theConnID <> 0 then
                                              (theListDiagram[],theConnID)
                                                ->
                                                  theOADDocument.theGroupPage.
                                                    PageCallBack.MakeConn
                                          if)
                                       #);
                                     theOADDocument.theGroupPage.PatternDiagrams
                                     .theList.scan
                                       (#
                                          theListDiagram:
                                            ^theOADDocument.theGroupPage.
                                               ListDiagram
                                       do
                                          current.e[]->theListDiagram[];
                                          theListDiagram[]
                                            ->
                                              theOADDocument.theGroupPage.
                                                PageCallBack.MakeLocalNodes;
                                          theListDiagram.titleNode.thePrefixConn
                                          .getID->theConnID;
                                          (if theConnID <> 0 then
                                              (theListDiagram[],theConnID)
                                                ->
                                                  theOADDocument.theGroupPage.
                                                    PageCallBack.MakeConn
                                          if)
                                       #);
                                     theOADDocument.theWorkPage.PatternDiagrams.
                                       theList.scan
                                       (#
                                          theListDiagram:
                                            ^theOADDocument.theWorkPage.
                                               ListDiagram;
                                          thisOADDiagram:
                                            ^theOADDocument.theWorkPage.
                                               OADDiagram;
                                          thisFragmentDiagram:
                                            ^theOADDocument.theWorkPage.
                                               FragmentDiagram;
                                          theDummyDesc:
                                            ^betaGram.ObjectDescriptor;
                                          thisPatternAttDiagram:
                                            ^theOADDocument.theWorkPage.
                                               PatternAttDiagram;
                                          theDummyAST: ^AST
                                       do
                                          current.e[]->theListDiagram[];
                                          (if current.e.struc <=
                                          theOADDocument.theWorkPage.
                                            OADDiagram##
                                           // true then
                                              current.e[]->thisOADDiagram[];
                                              thisOADDiagram.titlenode.theText.
                                                get->thisOADDiagram.titleText;
                                              (if thisOADDiagram.theDescriptor
                                              <> none then
                                                  thisOADDiagram.theDescriptor
                                                    ->theDummyDesc[];
                                                  theDummyDesc.index
                                                    ->current.index;
                                                  (if thisOADDiagram## <=
                                                  theOADDocument.theWorkPage.
                                                    PatternAttDiagram## then
                                                      thisOADDiagram[]
                                                        ->
                                                          thisPatternAttDiagram[];
                                                      thisPatternAttDiagram.
                                                        theAST->theDummyAST[];
                                                      theDummyAST.index
                                                        ->current.index
                                                  if)
                                              if);
                                              
                                          if);
                                          (if current.e.struc <=
                                          theOADDocument.theWorkPage.
                                            FragmentDiagram## then
                                              current.e[]
                                                ->thisFragmentDiagram[];
                                              thisFragmentDiagram.titlenode.
                                                theText.get
                                                ->thisFragmentDiagram.titleText
                                          if)
                                       #);
                                     theOADDocument.theGroupPage.PatternDiagrams
                                     .theList.scan
                                       (#
                                          theListDiagram:
                                            ^theOADDocument.theGroupPage.
                                               ListDiagram;
                                          thisOADDiagram:
                                            ^theOADDocument.theGroupPage.
                                               OADDiagram;
                                          thisFragmentDiagram:
                                            ^theOADDocument.theGroupPage.
                                               FragmentDiagram;
                                          theDummyDesc:
                                            ^betaGram.ObjectDescriptor;
                                          thisPatternAttDiagram:
                                            ^theOADDocument.theGroupPage.
                                               PatternAttDiagram;
                                          theDummyAST: ^AST
                                       do
                                          current.e[]->theListDiagram[];
                                          (if current.e.struc <=
                                          theOADDocument.theGroupPage.
                                            OADDiagram##
                                           // true then
                                              current.e[]->thisOADDiagram[];
                                              thisOADDiagram.titlenode.theText.
                                                get->thisOADDiagram.titleText;
                                              (if thisOADDiagram.theDescriptor
                                              <> none then
                                                  thisOADDiagram.theDescriptor
                                                    ->theDummyDesc[];
                                                  theDummyDesc.index
                                                    ->current.index;
                                                  (if thisOADDiagram## <=
                                                  theOADDocument.theGroupPage.
                                                    PatternAttDiagram## then
                                                      thisOADDiagram[]
                                                        ->
                                                          thisPatternAttDiagram[];
                                                      thisPatternAttDiagram.
                                                        theAST->theDummyAST[];
                                                      theDummyAST.index
                                                        ->current.index
                                                  if)
                                              if);
                                              
                                          if);
                                          (if current.e.struc <=
                                          theOADDocument.theGroupPage.
                                            FragmentDiagram## then
                                              current.e[]
                                                ->thisFragmentDiagram[];
                                              thisFragmentDiagram.titlenode.
                                                theText.get
                                                ->thisFragmentDiagram.titleText
                                          if)
                                       #)
                                  else
                                     'The selected .diag file does not have the right file format!'
                                       ->DSUIUserAckMessage
                                 if)
                             if)
                          else
                             'Please select a .bet, .ast or .diag file!'
                               ->GppAlert
                         if)
                     if);
                     
                 if);
                 
             if)
         if)
       for)
   if)
#)  

-- GetGroupName: Descriptor --
(* ask user for a group name *)
  (# name: @Text; ext: ^text; 
  do
     'Select a .bet or .ast file'->DSFileNameDialog->name;
     (if name.length > 0
      // true then
         name->getExtension->ext[];
         (if ('.bet'->ext.equal) or ('.ast'->ext.equal) then
             name->removeExtension->name;
             (if switch[1]
              // true then 'Opening: '->puttext; name[]->putline; 
             if);
             name->openFragmentGroup
          else
             'You must select a .bet or .ast file!'->DSUIUserAckMessage
         if);
         
     if);
     
  #)  

-- OpenFragmentGroup: Descriptor --
(#
   myDocument: ^OADDocument;
   opened: @boolean;
   propd: ^myDocument.theGroupPage.PropertyDiagram;
   fragd: ^myDocument.theGroupPage.FragmentDiagram;
   mess: @Text;
   NoOfForms: @Integer;
   groupFile,autosaveGroupFile,tildeGroupFile: @file;
   ok: @boolean;
   
do
   (if switch[2]
    // true then
       'Opening: '->mess.puttext; name[]->mess.puttext; mess->statusbar.set; 
   if);
   '.ast'->name.copyAppend->groupFile.name;
   '.ast#'->name.copyAppend->autosaveGroupFile.name;
   '.ast~'->name.copyAppend->tildeGroupFile.name;
   (if switch[17] then
       'Freja OpenFragmentGroup: '->putLine;
       groupFile.name->putLine;
       autosaveGroupFile.name->putLine;
       tildeGroupFile.name->putLine
   if);
   (if autosaveGroupFile.entry.exists and groupFile.entry.exists then
       (if autosaveGroupFile.entry.modtime > groupFile.entry.modtime then
           'Autosave file is newer, recover?'->DSUIGetUserYesOrNo->ok;
           (if OK then
               'mv .ast# .ast'->putLine;
               groupFile.name->autoSaveGroupFile.entry.rename
            else
               (if tildeGroupFile.entry.exists then
                   'mv .ast~ .ast'->putLine;
                   groupFile.name->tildeGroupFile.entry.rename;
                   'rm .ast#'->putLine;
                   autosaveGroupFile.delete
               if)
           if)
       if)
   if);
   thisOperation:
   (name[]->ExpandToFullPath,screen[])
     ->top.open
       (#
          WriteAccessOnLstFileError::< 
            (# 
            do
               'Access error on .lst file'->mess;
               mess->DSUIUserAckMessage;
               statusbar.reset;
               true->continue (*'Access error on .lst file'->myException*)
            #);
          writeAccessError::< 
            (# 
            do
               'No write access'->mess;
               mess->DSUIUserAckMessage;
               statusbar.reset;
               true
                 ->continue
                 (*'Write access error'->myException
                  * *)
            #);
          startingParsing::< 
            (# 
            do
               'Parsing '->mess;
               name[]->mess.putText;
               mess->DSUIUserAckMessage;
               statusbar.reset;
               
            #);
          ParseErrors::< 
            (# 
            do
               none ->f[];
               none ->theCatcher[];
               mess->DSUIUserAckMessage;
               statusbar.reset;
               leave thisOperation
            #)
       #)->fg[];
   (if fg[]
    // none then
       'Cannot open fragmentgroup: '->mess;
       name[]->mess.puttext;
       mess->DSUIUserAckMessage;
       statusbar.reset;
       
    else
       fg.fragmentlist.scan
         (# 
         do (if current.type // formtype then noofforms+1->noofforms if)
         #);
       (if (* fg[] -> isChecked//false *) true
        // false then
           'FragmentGroup '''->puttext;
           name[]->puttext;
           ''' not checked.'->putline;
           'Must be checked by compiler before it can be shown...'->putline;
           
        else
           (if theDocument[]
            // none then
               &OADDocument[]->myDocument[];
               myDocument.new;
               (if NoOfForms
                // 1 then
                   myDocument.CurrentPage->myDocument.theWorkPage[];
                   'WorkSheet'->myDocument.theWorkPage.PageTitle;
                   &myDocument.OADPage[]->myDocument.theGroupPage[];
                   myDocument.theGroupPage.InvisibleNew;
                   myDocument.theWorkPage[]->myDocument.CurrentPage;
                   
                else
                   myDocument.CurrentPage->myDocument.theGroupPage[];
                   myDocument[]->theDocument[]->theOADDocument[];
                   
               if);
               'Group Window'->myDocument.theGroupPage.PageTitle;
               
            else
               theDocument[]->myDocument[];
               (if NoOfForms
                // 1 then 
                else
                   myDocument.theGroupPage.visible; 
               if);
               
           if);
           scanner:
           myDocument.theGroupPage.PatternDiagrams.theList.scanPropertyDiagrams
             (# 
             do
                (if fg.name->(thisDiagram.fullname).equal
                 // true then true->opened; leave scanner; 
                if);
                
             #);
           (if opened
            // true then (* fragment already shown: just show the page *)
               myDocument.theGroupPage[]->myDocument.CurrentPage; 
            else
               (if switch[2]
                // true then 'Scanning Properties'->statusbar.set; 
               if);
               &myDocument.theGroupPage.PropertyDiagram[]->propd[];
               (fg[],true,name[]->ExpandToFullPath)->propd.new;
               &myDocument.theGroupPage.FragmentDiagram[]->fragd[];
               (if switch[2]
                // true then 'Scanning Fragments'->statusbar.set; 
               if);
               fg[]->fragd.new;
               
           if);
           (if switch[2] // true then statusbar.reset;  if);
           (if NoOfForms
            // 1 then
               myDocument.theGroupPage.FragmentDiagram##
                 ->myDocument.theGroupPage.ScanDiagrams
                   (# 
                   do
                      current[]->fragd[];
                      (if fg[]
                       // fragd.theGroup then (* find formname in the diagram *)
                          fragd.localnodes.scan (#  do current.detail #)
                      if)
                   #)
           if);
           
       if)
   if)
#)  

-- OpenFragmentForm: Descriptor --
(#
   index: @Integer;
   groupname,formname: ^Text;
   fg: ^FragmentGroup;
   theDoc: ^OADDocument;
   theDiagram: ^theDoc.theGroupPage.FragmentDiagram;
   noOfForms: @integer;
   
do (* first open the group, and then open the form *)
   '-'->name.findCh (#  do inx->index;  #);
   (1,index-1)->name.sub->groupname[];
   groupname->openFragmentGroup->fg[];
   (index+1,name.length)->name.sub->formname[];
   fg.fragmentlist.scan
     (# 
     do
        (if current.type
         // formtype then
            noofforms+1->noofforms;
            (if (current.f.name->formName.equal)
             // true then current.f[]->ff[]
            if)
        if)
     #);
   theDocument[]->theDoc[];
   theDoc.theGroupPage.FragmentDiagram##
     ->theDoc.TheGroupPage.ScanDiagrams
       (# 
       do
          current[]->theDiagram[];
          theDiagram.fullname->screen.putline;
          (if fg[]
           // theDiagram.theGroup then (* find formname in the diagram *)
              theDiagram.localnodes.scan
                (# t: ^text; 
                do
                   &Text[]->t[];
                   current.theText.get->t;
                   ':'->t.findCh (#  do inx->index #);
                   (1,index-1)->t.sub->t[];
                   EditorID->current.SifEditorInstanceNo;
                   (if (formname[]->t.equal) and (noOfForms > 1)
                    // true then
                    (* if noOfForms = 1 the form has already been opened 
                     * by openFragmentGroup
                     *)
                       current.detail; 
                   if)
                #)
          if)
       #)
#)  

-- autosave: Descriptor --
(#
   dummyFilter: ##external;
   pageList: ^ObjectList;
   filename: @Text;
   cancelled: ^integerRef;
   prompt: @text;
   count: @ShortRef;
   list: @IntegerRef
do
   '#0 autoSave'->sendSifCommand;
   SaveLists;
   (if currentDiagramName[] <> none then
       currentDiagramName[]->filename.puttext;
       '#'->filename.append;
       (count[],list[])->DSStrGetPageList;
       &integerRef[]->cancelled[];
       ' '->prompt.puttext;
       (@@ filename.T[1],false,cancelled[],true,count,list,dummyFilter##,prompt)
         ->DSFileSavePagesAsDiagram
    else
       'Autosave: No current diagram??'->putline
   if)
#)  

-- checkAutoSaveFile: Descriptor --
(#
   diagFile,autosaveDiagFile,tildeDiagFile: @file;
   groupFile,autosaveGroupFile,tildeGroupFile: @file;
   ok: @boolean;
   groupName: ^text
do
   name[]->diagFile.name;
   '#'->name.copyAppend->autosaveDiagFile.name;
   '~'->name.copyAppend->tildeDiagFile.name;
   (if switch[17] then
       'Freja checkAutoSaveFile:'->putLine;
       diagFile.name->putLine;
       autosaveDiagFile.name->putLine;
       tildeDiagFile.name->putLine
   if);
   (if autosaveDiagFile.entry.exists and diagFile.entry.exists then
       name.copy->groupName[];
       groupName->removeExtension->groupName;
       '.ast'->groupName.append;
       groupName[]->groupFile.name;
       '#'->groupName.copyAppend->autosaveGroupFile.name;
       '~'->groupName.copyAppend->tildeGroupFile.name;
       (if switch[17] then
           groupFile.name->putLine;
           autosaveGroupFile.name->putLine;
           tildeGroupFile.name->putLine
       if);
       (if autosaveDiagFile.entry.modtime > diagFile.entry.modtime then
           'Autosave file is newer, recover?'->DSUIGetUserYesOrNo->ok;
           (if OK then
               'mv .diag# .diag'->putLine;
               diagFile.name->autoSaveDiagFile.entry.rename;
               (if autosaveGroupFile.entry.exists then
                   'mv .ast# .ast'->putLine;
                   groupFile.name->autoSaveGroupFile.entry.rename
               if)
            else
           (* (if tildeDiagFile.entry.exists then
            'mv .diag~ .diag'->putLine;
            diagFile.name->tildeDiagFile.entry.rename
            if);*)
               'rm .diag#'->putLine;
               autosaveDiagFile.delete;
               (if tildeGroupFile.entry.exists then
                   'mv .ast~ .ast'->putLine;
                   groupFile.name->tildeGroupFile.entry.rename
               if);
               (if autoSaveGroupFile.entry.exists then
                   'rm .ast#'->putLine; autosaveGroupFile.delete
               if)
           if)
       if)
   if)
#)  

-- checkDiagFile: Descriptor --
(# diagFile: @file; groupFile,betFile: @file; groupName,help: ^text
do
   true->OK;
   'Consistency check failed!'->help[];
   help.newLine;
   name[]->diagFile.name;
   (if switch[17] then
       'Freja checkDiagFile:'->putLine; diagFile.name->putLine
   if);
   (if diagFile.entry.exists then
       name.copy->groupName[];
       groupName->removeExtension->groupName;
       '.bet'->groupName.copyAppend->betFile.name;
       '.ast'->groupName.append;
       groupName[]->groupFile.name;
       (if groupFile.entry.exists then
       (* no we cannot be sure of that 
        (if groupFile.entry.modtime > diagFile.entry.modtime then
        groupFile.name->help.putLine; help.newLine;
        'is newer than'->help.putLine; help.newLine;
        diagFile.name->help.putText;
        help->gppAlert;
        false->OK
        if)*)
           
        else
           groupFile.name->help.putLine;
           'does not exist'->help.putText;
           help->gppAlert;
           false->OK
       if);
       (if OK and betFile.entry.exists then
           (if betFile.entry.modtime > diagFile.entry.modtime then
               betFile.name->help.putLine;
               'is newer than'->help.putLine;
               diagFile.name->help.putText;
               help->gppAlert;
               false->OK
           if)
       if);
       (if OK and groupFile.entry.exists and betFile.entry.exists then
           (if betFile.entry.modtime > groupFile.entry.modtime then
               betFile.name->help.putLine;
               'is newer than'->help.putLine;
               groupFile.name->help.putText;
               help->gppAlert;
               false->OK
           if)
       if)
   if)
#)  

-- scanASTfiles: Descriptor --
(# f: @file; t: ^Text
do
   name[]->f.name;
   f.openRead;
   loop:
     (# 
     do
        (if not f.eos then
            f.getLine->t[];
            (if t[] = none then leave loop if);
            t.reset;
            t.getAtom->currentGroupName[];
            f.getline->t[];
            (if t[] = none then leave loop if);
            t.reset;
            t.getInt->currentModTime;
            INNER scanASTfiles;
            restart loop
        if)
     #);
   f.close
#)  

-- SaveLists: Descriptor --
(#
   theListDiagram: ^theOADDocument.theWorkPage.ListDiagram;
   fd: ^theOADDocument.theGroupPage.FragmentDiagram;
   theReference: ^theListDiagram.titleNode.PatternDiagNodeReference;
   ok: @Boolean;
   listsize,last: @integer;
   f: @file;
   fileName: @Text
do
   theDocument[]->theOADDocument[];
   theOADDocument.theWorkPage.PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->theListDiagram[];
        theListDiagram.titleNode.resetLocalNodesUD
     #);
   theOADDocument.theGroupPage.PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->theListDiagram[];
        theListDiagram.titleNode.resetLocalNodesUD
     #);
   theOADDocument.theWorkPage.PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->theListDiagram[];
        theListDiagram.localNodes.scan
          (# 
          do
             &theListDiagram.titleNode.PatternDiagNodeReference[]
               ->theReference[];
             theReference.InitLocalNode;
             current[]->theReference;
             
          #)
     #);
   (if currentDiagramName[] <> none then
       currentDiagramName->removeExtension->fileName;
       '.freja'->fileName.Append->f.name;
       f.openWrite
    else
       'No currentDiagramName?'->putline
   if);
   theOADDocument.theGroupPage.PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->theListDiagram[];
        (if theListDiagram## <= theOADDocument.theGroupPage.fragmentDiagram##
         then
            theListDiagram[]->fd[];
            fd.fullname->f.putline;
            (fd.theGroup).modtime->f.putint;
            ' '->f.putline
        if);
        theListDiagram.localNodes.scan
          (# 
          do
             &theListDiagram.titleNode.PatternDiagNodeReference[]
               ->theReference[];
             theReference.InitLocalNode;
             current[]->theReference;
             
          #)
     #);
   f.close;
   (theOADDocument.theGroupPage.ID,499,@@ listsize)->UDReadType->ok;
   (if ok then
       (for i: listsize repeat
         (theOADDocument.theGroupPage.ID,500+i)->UDDeleteType->ok;
         (if ok then
             (if userDataVerbose then
                 'For id '->puttext;
                 theOADDocument.theGroupPage.ID->putint;
                 ' and attributeID '->puttext;
                 500+i->putint;
                 ' delete IndexIDList userdata succeed'->putline
             if)
          else
             (if userDataVerbose then
                 'For id '->puttext;
                 theOADDocument.theGroupPage.ID->putint;
                 ' and attributeID '->puttext;
                 500+i->putint;
                 ' delete IndexIDList userdata fail'->putline
             if)
         if)
       for)
    else
       (if userDataVerbose then 'listsize read fail'->putline if)
   if);
   IndexIDList.impl.range->listsize;
   (theOADDocument.theGroupPage.ID,499,@@ listsize,4)->UDWriteType->ok;
   (if ok then
       (if userDataVerbose then
           'Write IndexIDList.impl.range succeed: '->puttext;
           listsize->putint;
           newline
       if);
       IndexIDList.last->last;
       (theOADDocument.theGroupPage.ID,500,@@ last,4)->UDWriteType->ok;
       (if ok then
           (if userDataVerbose then
               'Write IndexIDList.last succeed: '->puttext;
               last->putint;
               newline
           if);
           (for i: listsize repeat
             (theOADDocument.theGroupPage.ID,500+i,@@ IndexIDList.impl[i],4)
               ->UDWriteType->ok;
             (if ok then
                 (if userDataVerbose then
                     'Write IndexIDList succeed: '->puttext;
                     'element no '->puttext;
                     i->putint;
                     'element '->puttext;
                     IndexIDList.impl[i]->putint;
                     newline
                 if)
              else
                 (if userDataVerbose then
                     'Write IndexIDList fail: '->puttext
                 if)
             if)
           for)
        else
           (if userDataVerbose then
               'Write IndexIDList.last fail: '->puttext
           if)
       if)
    else
       (if userDataVerbose then
           'Write IndexIDList.impl.range fail: '->puttext
       if)
   if);
   (theOADDocument.theWorkPage.ID,240,@@ theOADDocument.theWorkPage.nextX,4)
     ->UDWriteType->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextX succeed'->putline
        else
           'Write NextX fail'->putline
       if)
   if);
   (theOADDocument.theWorkPage.ID,241,@@ theOADDocument.theWorkPage.nextY,4)
     ->UDWriteType->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextY succeed'->putline
        else
           'Write NextY fail'->putline
       if)
   if);
   (theOADDocument.theWorkPage.ID,250,@@
    theOADDocument.theWorkPage.patternDiagrams.NextFreeLine,4)->UDWriteType->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextFreeLine succeed'->putline
        else
           'Write NextFreeLine fail'->putline
       if)
   if);
   (theOADDocument.theWorkPage.ID,251,@@
    theOADDocument.theWorkPage.patternDiagrams.NextFreeColumn,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextFreeColumn succeed'->putline
        else
           'Write NextFreeColumn fail'->putline
       if)
   if);
   (theOADDocument.theWorkPage.ID,252,@@
    theOADDocument.theWorkPage.patternDiagrams.SecondFreeLine,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write SecondFreeLine succeed'->putline
        else
           'Write SecondFreeLine fail'->putline
       if)
   if);
   (theOADDocument.theWorkPage.ID,253,@@
    theOADDocument.theWorkPage.patternDiagrams.SecondFreeColumn,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write SecondFreeColumn succeed'->putline
        else
           'Write SecondFreeColumn fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,240,@@ theOADDocument.theGroupPage.nextX,4)
     ->UDWriteType->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextX succeed'->putline
        else
           'Write NextX fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,241,@@ theOADDocument.theGroupPage.nextY,4)
     ->UDWriteType->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextY succeed'->putline
        else
           'Write NextY fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,250,@@
    theOADDocument.theGroupPage.patternDiagrams.NextFreeLine,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextFreeLine succeed'->putline
        else
           'Write NextFreeLine fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,251,@@
    theOADDocument.theGroupPage.patternDiagrams.NextFreeColumn,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextFreeColumn succeed'->putline
        else
           'Write NextFreeColumn fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,252,@@
    theOADDocument.theGroupPage.patternDiagrams.SecondFreeLine,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write SecondFreeLine succeed'->putline
        else
           'Write SecondFreeLine fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,253,@@
    theOADDocument.theGroupPage.patternDiagrams.SecondFreeColumn,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write SecondFreeColumn succeed'->putline
        else
           'Write SecondFreeColumn fail'->putline
       if)
   if)
#)  

-- ScanDiagrams: Descriptor --
(# 
do
   PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->THIS(ScanDiagrams).current[];
        (if theDiagramType##
         // none then INNER ScanDiagrams; 
         else
            (if current.e.struc <= theDiagramType##
             // true then INNER ScanDiagrams; 
            if)
        if)
     #)
#)  

-- MarkNodeDisplay: Descriptor --
(# 
do
   (pos.x,pos.y,gppProp.marksize,gppProp.marksize)->new;
   theNode[]->thePatternDiagramNode;
   THIS(MarkNode)[]->(thePatternDiagramNode).theMarkNode;
   false->sizeable;
   
#)  

-- MarkNodeOnInit: Descriptor --
(# 
do
   UDPrivate.UDMarkNode->UserDataInit;
   thePatternDiagramNode.Init;
   6->theText.size;
   false->moveable;
   false->sizeable;
   (if not initialisingSaved then theNode[]->CreateRegion if);
   
#)  

-- titleGetFragment: Descriptor --
(# fn: ^FragmentNode; 
do
   (if theFragmentNode <> none
    // true then theFragmentNode->fn[]; fn.theFragment->f[]; 
    else
       'DiagramNode: GetFragment: no FragmentNode'->screen.putline
   if)
#)  

-- AssociationConnectorDisplay: Descriptor --
(# 
do
   (THIS(AssociationNode)[],theDiag.titleNode[])->new;
   (if aType
    // one then
       '1'->theText.set
    // many then
       (if secondMany then
           'm'->theText.set
        else
           true->secondMany; 'n'->theText.set
       if)
    else
       'AssociationConnectorDisplay: Unknown type of association!'->putline
   if);
   aType->type;
   theDiag[]->theDiagram;
   
#)  

-- AssociationConnectorOnInit: Descriptor --
(#  do 0->Orient; type.init; theDiagram.init #)  

-- AssociationNodeDisplay: Descriptor --
(# x1,x2,y1,y2,x,y: @integer; con1,con2: ^AssociationConnector
do
   diagram1.titleNode.center->(x1,y1);
   diagram2.titleNode.center->(x2,y2);
   (x2+x1) div 2->x;
   (y2+y1) div 2->y;
   (x,y,0,0)->new;
   &AssociationConnector[]->con1[];
   &AssociationConnector[]->con2[];
   (type1,diagram1[])->con1.display;
   (type2,diagram2[])->con2.display;
   (*can only be assigned to persistent c1,c2 after init (in display).*)
   con1[]->c1;
   con2[]->c2
#)  

-- AssociationNodeOnDoubleClick: Descriptor --
(# theListDiagram: ^ListDiagram; aPatternNode: ^theListDiagram.PatternNode
do
   (if thePatternNode <> none then
       (thePatternNode).theDiagram->theListDiagram[];
       thePatternNode->aPatternNode[];
       (if aPatternNode[] <> none then
           (if aPatternNode.hasAttributes then
               delete; aPatternNode.detail; 
            else
               'Association has no attributes??'->putline
           if)
        else
           'No association pattern declaration??'->putline
       if)
   if)
#)  

-- AssociationNodeDetail: Descriptor --
(#  do  #)  

-- AssociationNodeOnInit: Descriptor --
(#  do thePatternNode.init; c1.init; c2.init #)  

-- AssociationNodeNew: Descriptor --
(# p: [8] @integer
do
   0->p[1];
   - 10->p[2];
   10->p[3];
   0->p[4];
   0->p[5];
   10->p[6];
   - 10->p[7];
   0->p[8];
   (for i: p.range repeat p[i]->wcoord->p[i] for);
   (THIS(OADPage).ID,4,@@ p[1])->DSStrCreatePolygon->onInit;
   (x,y)->move;
   true->doneInInner
#)  

-- DeletableConnectorGetOtherEnd: Descriptor --
(# node1,node2: ^IDObject
do
   true->getEnds->(node1[],node2[]);
   (if (Start[] = node1[]) or (Start[] = node2[]) then
       (if Start[] = node1[] then
           node2[]->OtherEnd[]
        else
           node1[]->OtherEnd[]
       if)
    else
       'GetOtherEnd: Start is not in either end!'->putline
   if)
#)  

-- DynamicItemConnectorOnInit: Descriptor --
(#
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theOtherOADDiagram: ^OADDiagram;
   aDiagramNode: ^theOtherListDiagram.DiagramNode;
   aSimpleNode: ^theListDiagram.SimpleNode;
   t: ^Text;
   titleText: @text;
   anAST,aDeclAST: ^AST;
   theDesc: ^betaGram.ObjectDescriptor;
   anExp: ^Expanded;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   theAttrDecl: ^betaGram.AttributeDecl;
   existingConnectors: ^ObjectList;
   theCon: ^Connector
do
   (if switch[1] then 'DynamicItemConnector onInit!'->putline if);
   UDPrivate.UDDynamicItemConnector->UserDataInit;
   (if not initialisingSaved then
       true->THIS(DynamicItemConnector).getEnds->(node1[],node2[]);
       (if (node1## <= PatternDiagramNode##) and
       (node2## <= PatternDiagramNode##) then
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           node2[]->anotherPatternDiagramNode[];
           (if (aPatternDiagramNode## <= theListDiagram.SimpleNode##) then
               aPatternDiagramNode[]->aSimpleNode[];
               aPatternDiagramNode.getASTNode->anExp[];
               '#'->t[];
               aPatternDiagramNode.SifEditorInstanceNo->t.putint;
               ' parse '->t.puttext;
               anExp.index->t.putint;
               ' '->t.puttext;
               anExp.getSon1->theNames[];
               theNames.getSon1->theNameDcl[];
               theNameDcl.getNameDecl->anAST[];
               (if anAST.kind = kinds.unExpanded then
                   '<<NameDecl>>'->t.puttext
                else
                   theNameDcl.getText->t.puttext
               if);
               ':^'->t.append;
               anotherPatternDiagramNode.thisDiagram->theOtherListDiagram[];
               (if theOtherListDiagram[] <> none then
                   (if anotherPatternDiagramNode## <=
                   theOtherListDiagram.title## then
                       theOtherListDiagram[]->theOtherOADDiagram[];
                       theOtherOADDiagram.theDescriptor->theDesc[];
                       theDesc.father->anExp[];
                       anExp[]->aSimpleNode.theQualification;
                       anExp.getSon1->theNames[];
                       theNames.getSon1->theNameDcl[];
                       theNameDcl.getNameDecl->aDeclAST[];
                       (if aDeclAST.kind = kinds.unExpanded then
                           '<<NameAppl>>'->t.puttext
                        else
                           theNameDcl.getText->t.puttext
                       if);
                       (if theListDiagram[] = theOtherListDiagram[] then
                           Delete
                        else
                           THIS(DynamicItemConnector)[]
                             ->aSimpleNode.theReferenceConnector;
                           
                       if);
                       t[]->sendSifCommand
                   if)
                else
                   anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
                   (if
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.PatternNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.VirtualNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.BindingNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.FinalNode##) then
                       anotherPatternDiagramNode[]->aDiagramNode[];
                       aDiagramNode.theDeclaration->theAttrDecl[];
                       theAttrDecl[]->aSimpleNode.theQualification;
                       theAttrDecl.getSon1->theNames[];
                       theNames.getSon1->theNameDcl[];
                       theNameDcl.getNameDecl->anAST[];
                       (if anAST.kind = kinds.unExpanded then
                           '<<NameAppl>>'->t.puttext
                        else
                           theNameDcl.getText->t.puttext
                       if);
                       (if theListDiagram[] = theOtherListDiagram[] then
                           Delete
                        else
                           THIS(DynamicItemConnector)[]
                             ->aSimpleNode.theReferenceConnector
                       if);
                       t[]->sendSifCommand
                    else
                       Delete;
                       'The destination is not a pattern, virtual, binding or final declaration!'
                         ->DSUIUserAckMessage
                   if)
               if)
            else
               Delete;
               'The source is not a simple declaration!'->DSUIUserAckMessage
           if)
        else
           Delete;
           'Source or destination is not part of a pattern diagram!'
             ->DSUIUserAckMessage
       if);
       (if ID <> 0 (*A connector was created*) then
           node1.getconnectors->existingConnectors[];
           (if existingConnectors[] <> none then
               existingConnectors.scan
                 (# 
                 do
                    (if (current[] <> THIS(dynamicItemConnector)[]) and
                    ((current## <= DynamicItemConnector##) or
                     (current## <= DynamicComponentConnector##)) then
                        current[]->theCon[]; theCon.delete
                    if)
                 #)
           if)
       if)
   if)
#)  

-- DynamicItemConnectorOnDelete: Descriptor --
(#
   node1,node2,dummy: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theSimpleNode: ^theListDiagram.SimpleNode;
   anAST: ^AST;
   theDeclaration: ^betaGram.AttributeDecl;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   t: ^Text
do
   (if switch[1] then 'DynamicItemConnector onDelete!'->putline if);
   true->getEnds->(node1[],node2[]);
   node1.theDiagram->theListDiagram[];
   node2.theDiagram->theOtherListDiagram[];
   (if node2## <= theOtherListDiagram.SimpleNode## then
       node1[]->dummy[];
       node2[]->node1[];
       dummy[]->node2[];
       theListDiagram[]->theOtherListDiagram[]
   if);
   '#'->t[];
   node1.SifEditorInstanceNo->t.putint;
   ' parse '->t.puttext;
   node1[]->theSimpleNode[];
   none ->theSimpleNode.theReferenceConnector;
   none ->theSimpleNode.theQualification;
   theSimpleNode.theDeclaration->theDeclaration[];
   theDeclaration.index->t.putint;
   ' '->t.puttext;
   theDeclaration.getSon1->theNames[];
   theNames.getSon1->theNameDcl[];
   theNameDcl.getNameDecl->anAST[];
   (if anAST.kind = kinds.unExpanded then
       '<<NameDecl>>'->t.puttext
    else
       theNameDcl.getText->t.puttext
   if);
   ':^ <<AttributeDenotation>>'->t.append;
   t[]->sendSifCommand;
   
#)  

-- DynamicItemConnectorOnReattach: Descriptor --
(#
   node1,node2,dummy: ^DesignObject;
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theOtherOADDiagram: ^OADDiagram;
   aSimpleNode: ^theListDiagram.SimpleNode;
   aDiagramNode: ^theOtherListDiagram.DiagramNode;
   anAST,aDeclAST: ^AST;
   anExp: ^Expanded;
   theAttrDecl: ^betaGram.AttributeDecl;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   theDesc: ^betaGram.ObjectDescriptor;
   t: ^Text;
   titleText: @Text;
   theCon: ^Connector
do
   true->getEnds->(node1[],node2[]);
   (if switch[1] then
       'DynamicItemConnectorOnReattach!'->putline;
       'node1: '->puttext;
       node1.id->putint;
       newline;
       'node2: '->puttext;
       node2.id->putint;
       newline
   if);
   (if whichEnd then
       (if theNew## <= PatternDiagramNode## then
           theNew[]->anotherPatternDiagramNode[];
           anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           aPatternDiagramNode[]->aSimpleNode[];
           aPatternDiagramNode.getASTNode->anExp[];
           '#'->t[];
           aPatternDiagramNode.SifEditorInstanceNo->t.putint;
           ' parse '->t.puttext;
           anExp.index->t.putint;
           ' '->t.puttext;
           anExp.getSon1->theNames[];
           theNames.getSon1->theNameDcl[];
           theNameDcl.getNameDecl->anAST[];
           (if anAST.kind = kinds.unExpanded then
               '<<NameDecl>>'->t.puttext
            else
               theNameDcl.getText->t.puttext
           if);
           ':^'->t.append;
           (if anotherPatternDiagramNode## <= theOtherListDiagram.title## then
               theOtherListDiagram[]->theOtherOADDiagram[];
               theOtherOADDiagram.theDescriptor->theDesc[];
               theDesc.father->anExp[];
               anExp[]->aSimpleNode.theQualification;
               anExp.getSon1->theNames[];
               theNames.getSon1->theNameDcl[];
               theNameDcl.getNameDecl->aDeclAST[];
               (if aDeclAST.kind = kinds.unExpanded then
                   '<<NameAppl>>'->t.puttext
                else
                   theNameDcl.getText->t.puttext
               if);
               (if theListDiagram[] = theOtherListDiagram[] then
                   Delete
                else
                   THIS(DynamicItemConnector)[]
                     ->aSimpleNode.theReferenceConnector;
                   
               if);
               t[]->sendSifCommand
            else
               (if
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.PatternNode##) or
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.VirtualNode##) or
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.BindingNode##) or
               (anotherPatternDiagramNode## <= theOtherListDiagram.FinalNode##)
                then
                   anotherPatternDiagramNode[]->aDiagramNode[];
                   aDiagramNode.theDeclaration->theAttrDecl[];
                   theAttrDecl[]->aSimpleNode.theQualification;
                   theAttrDecl.getSon1->theNames[];
                   theNames.getSon1->theNameDcl[];
                   theNameDcl.getNameDecl->anAST[];
                   (if anAST.kind = kinds.unExpanded then
                       '<<NameAppl>>'->t.puttext
                    else
                       theNameDcl.getText->t.puttext
                   if);
                   (if theListDiagram[] = theOtherListDiagram[] then
                       Delete
                   if);
                   t[]->sendSifCommand
                else
                   'The destination is not a pattern, virtual, binding or final declaration!'
                     ->DSUIUserAckMessage;
                   false->ok
               if)
           if)
        else
           'The relation has been attached to a node that is not part of a pattern diagram'
             ->DSUIUserAckMessage;
           false->ok
       if)
    else
       'Moving simpleDecl end of relation not yet implemented!'
         ->DSUIUserAckMessage;
       false->ok
   if)
#)  

-- DynamicComponentConnectorOnInit: Descriptor --
(#
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theOtherOADDiagram: ^OADDiagram;
   aSimpleNode: ^theListDiagram.SimpleNode;
   aDiagramNode: ^theOtherListDiagram.DiagramNode;
   t: ^Text;
   titleText: @text;
   anAST,aDeclAST: ^AST;
   theDesc: ^betaGram.ObjectDescriptor;
   anExp: ^Expanded;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   theAttrDecl: ^betaGram.AttributeDecl;
   existingConnectors: ^ObjectList;
   theCon: ^Connector
do
   (if switch[1] then 'DynamicComponentConnector onInit!'->putline if);
   UDPrivate.UDDynamicComponentConnector->UserDataInit;
   (if not initialisingSaved then
       true->getEnds->(node1[],node2[]);
       (if (node1## <= PatternDiagramNode##) and
       (node2## <= PatternDiagramNode##) then
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           node2[]->anotherPatternDiagramNode[];
           (if (aPatternDiagramNode## <= theListDiagram.SimpleNode##) then
               aPatternDiagramNode[]->aSimpleNode[];
               aPatternDiagramNode.getASTNode->anExp[];
               '#'->t[];
               aPatternDiagramNode.SifEditorInstanceNo->t.putint;
               ' parse '->t.puttext;
               anExp.index->t.putint;
               ' '->t.puttext;
               anExp.getSon1->theNames[];
               theNames.getSon1->theNameDcl[];
               theNameDcl.getNameDecl->anAST[];
               (if anAST.kind = kinds.unExpanded then
                   '<<NameDecl>>'->t.puttext
                else
                   theNameDcl.getText->t.puttext
               if);
               ':^|'->t.append;
               anotherPatternDiagramNode.thisDiagram->theOtherListDiagram[];
               (if theOtherListDiagram[] <> none then
                   (if anotherPatternDiagramNode## <=
                   theOtherListDiagram.title## then
                       theOtherListDiagram[]->theOtherOADDiagram[];
                       theOtherOADDiagram.theDescriptor->theDesc[];
                       theDesc.father->anExp[];
                       anExp[]->aSimpleNode.theQualification;
                       anExp.getSon1->theNames[];
                       theNames.getSon1->theNameDcl[];
                       theNameDcl.getNameDecl->aDeclAST[];
                       (if aDeclAST.kind = kinds.unExpanded then
                           '<<NameAppl>>'->t.puttext
                        else
                           theNameDcl.getText->t.puttext
                       if);
                       (if theListDiagram[] = theOtherListDiagram[] then
                           Delete
                        else
                           THIS(DynamicComponentConnector)[]
                             ->aSimpleNode.theReferenceConnector
                       if);
                       t[]->sendSifCommand
                   if)
                else
                   anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
                   (if
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.PatternNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.VirtualNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.BindingNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.FinalNode##) then
                       anotherPatternDiagramNode[]->aDiagramNode[];
                       aDiagramNode.theDeclaration->theAttrDecl[];
                       theAttrDecl[]->aSimpleNode.theQualification;
                       theAttrDecl.getSon1->theNames[];
                       theNames.getSon1->theNameDcl[];
                       theNameDcl.getNameDecl->anAST[];
                       (if anAST.kind = kinds.unExpanded then
                           '<<NameAppl>>'->t.puttext
                        else
                           theNameDcl.getText->t.puttext
                       if);
                       (if theListDiagram[] = theOtherListDiagram[] then
                           Delete
                        else
                           THIS(DynamicComponentConnector)[]
                             ->aSimpleNode.theReferenceConnector
                       if);
                       t[]->sendSifCommand
                    else
                       Delete;
                       'The destination is not a pattern, virtual, binding or final  declaration!'
                         ->DSUIUserAckMessage
                   if)
               if)
            else
               Delete;
               'The source is not a simple declaration!'->DSUIUserAckMessage
           if)
        else
           Delete;
           'Source or destination is not part of a pattern diagram!'
             ->DSUIUserAckMessage
       if);
       (if ID <> 0 (*A connector was created*) then
           node1.getconnectors->existingConnectors[];
           (if existingConnectors[] <> none then
               existingConnectors.scan
                 (# 
                 do
                    (if (current[] <> THIS(dynamicComponentConnector)[]) and
                    ((current## <= DynamicItemConnector##) or
                     (current## <= DynamicComponentConnector##)) then
                        current[]->theCon[]; theCon.delete
                    if)
                 #)
           if)
       if)
   if)
#)  

-- DynamicComponentConnectorOnDelete: Descriptor --
(#
   node1,node2,dummy: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theSimpleNode: ^theListDiagram.SimpleNode;
   anAST: ^AST;
   theDeclaration: ^betaGram.AttributeDecl;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   t: ^Text
do
   (if switch[1] then 'DynamicItemConnector onDelete!'->putline if);
   true->getEnds->(node1[],node2[]);
   node1.theDiagram->theListDiagram[];
   node2.theDiagram->theOtherListDiagram[];
   (if node2## <= theOtherListDiagram.SimpleNode## then
       node1[]->dummy[];
       node2[]->node1[];
       dummy[]->node2[];
       theListDiagram[]->theOtherListDiagram[]
   if);
   '#'->t[];
   node1.SifEditorInstanceNo->t.putint;
   ' parse '->t.puttext;
   node1[]->theSimpleNode[];
   none ->theSimpleNode.theReferenceConnector;
   none ->theSimpleNode.theQualification;
   theSimpleNode.theDeclaration->theDeclaration[];
   theDeclaration.index->t.putint;
   ' '->t.puttext;
   theDeclaration.getSon1->theNames[];
   theNames.getSon1->theNameDcl[];
   theNameDcl.getNameDecl->anAST[];
   (if anAST.kind = kinds.unExpanded then
       '<<NameDecl>>'->t.puttext
    else
       theNameDcl.getText->t.puttext
   if);
   ':^| <<AttributeDenotation>>'->t.append;
   t[]->sendSifCommand;
   
#)  

-- DynamicComponentConnectorOnReattach: Descriptor --
(#
   node1,node2,dummy: ^DesignObject;
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theOtherOADDiagram: ^OADDiagram;
   aSimpleNode: ^theListDiagram.SimpleNode;
   aDiagramNode: ^theOtherListDiagram.DiagramNode;
   anAST,aDeclAST: ^AST;
   anExp: ^Expanded;
   theAttrDecl: ^betaGram.AttributeDecl;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   theDesc: ^betaGram.ObjectDescriptor;
   t: ^Text;
   titleText: @Text;
   theCon: ^Connector
do
   true->getEnds->(node1[],node2[]);
   (if switch[1] then
       'DynamicComponentConnectorOnReattach!'->putline;
       'node1: '->puttext;
       node1.id->putint;
       newline;
       'node2: '->puttext;
       node2.id->putint;
       newline
   if);
   (if whichEnd then
       (if theNew## <= PatternDiagramNode## then
           theNew[]->anotherPatternDiagramNode[];
           anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           aPatternDiagramNode[]->aSimpleNode[];
           aPatternDiagramNode.getASTNode->anExp[];
           '#'->t[];
           aPatternDiagramNode.SifEditorInstanceNo->t.putint;
           ' parse '->t.puttext;
           anExp.index->t.putint;
           ' '->t.puttext;
           anExp.getSon1->theNames[];
           theNames.getSon1->theNameDcl[];
           theNameDcl.getNameDecl->anAST[];
           (if anAST.kind = kinds.unExpanded then
               '<<NameDecl>>'->t.puttext
            else
               theNameDcl.getText->t.puttext
           if);
           ':^|'->t.append;
           (if anotherPatternDiagramNode## <= theOtherListDiagram.title## then
               theOtherListDiagram[]->theOtherOADDiagram[];
               theOtherOADDiagram.theDescriptor->theDesc[];
               theDesc.father->anExp[];
               anExp[]->aSimpleNode.theQualification;
               anExp.getSon1->theNames[];
               theNames.getSon1->theNameDcl[];
               theNameDcl.getNameDecl->aDeclAST[];
               (if aDeclAST.kind = kinds.unExpanded then
                   '<<NameAppl>>'->t.puttext
                else
                   theNameDcl.getText->t.puttext
               if);
               (if theListDiagram[] = theOtherListDiagram[] then
                   Delete
                else
                   THIS(DynamicComponentConnector)[]
                     ->aSimpleNode.theReferenceConnector;
                   
               if);
               t[]->sendSifCommand
            else
               (if
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.PatternNode##) or
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.VirtualNode##) or
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.BindingNode##) or
               (anotherPatternDiagramNode## <= theOtherListDiagram.FinalNode##)
                then
                   anotherPatternDiagramNode[]->aDiagramNode[];
                   aDiagramNode.theDeclaration->theAttrDecl[];
                   theAttrDecl.getSon1->theNames[];
                   theNames.getSon1->theNameDcl[];
                   theNameDcl.getNameDecl->anAST[];
                   (if anAST.kind = kinds.unExpanded then
                       '<<NameAppl>>'->t.puttext
                    else
                       theNameDcl.getText->t.puttext
                   if);
                   (if theListDiagram[] = theOtherListDiagram[] then
                       Delete
                   if);
                   t[]->sendSifCommand
                else
                   'The destination is not a pattern, virtual, binding or final declaration!'
                     ->DSUIUserAckMessage;
                   false->ok
               if)
           if)
        else
           'The relation has been attached to a node that is not part of a pattern diagram'
             ->DSUIUserAckMessage;
           false->ok
       if)
    else
       'Moving simpleDecl end of relation not yet implemented!'
         ->DSUIUserAckMessage;
       false->ok
   if)
#)  

-- GppFileNameDialog: Descriptor --
(#
   cstr: @IntegerRef;
   filt: external
     (# ok: @integer; fisk: @Integer; 
     enter fisk
     do cExternalEntry; true->ok; 
     exit ok
     #);
   cStringToCharR: external
     (# cStr: @integer; c: [1] @char
     enter cStr
     do 'copyInput'->callC; 
     exit c
     #);
   DSF: external
     (#
        ok: @boolean;
        requestlabel,okButtonLabel,initialPath: [1] @char;
        filterProc: ##external;
        exitPathPP: ^IntegerRef;
        
     enter (requestlabel,okButtonLabel,initialPath,filterProc##,exitPathPP[])
     do 'DSFile_NameDialog'->callC; 
     exit ok
     #);
   
do
   (if (message,label,'',filt##,cstr[])->DSF
    // true then cstr->cStringToCharR->filename; 
   if);
   
#)  

