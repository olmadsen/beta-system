ORIGIN 'diagramattributes';
(* switch
 * 1  = general debugging
 * 21 = IndexIDList
 * 22 = AstReplaced
 *)
INCLUDE 'objectgppproperties'
        '~beta/designenv/v2.2/private/userdatabody';
-- IndexIDListInsert: Descriptor --
(# 
do
   (if switch[21]
    // true then
       '%21GPP: Insert element indexed: '->screen.puttext;
       a->screen.putint;
       screen.newline;
       
   if)
#)  

-- PatternDiagramNodeOnSelect: DoPart --
do
   (if theSifEditor <> none then
       (if (theSifEditor).isReadOnly then setReadOnly else unsetReadOnly if)
    else
       setReadOnly
   if);
   INNER onSelect  

-- ASTToNode: Descriptor --
(# 
do
   (if switch[21] then 'ASTtoNode: '->putText if);
   (if anAST[]
    // none then 'ASTtoNode: anAST is none!'->putLine; 
    else
       (if switch[21] then anAST.index->putInt;  if);
       search:
       anAST.index
         ->indexIDList.scan
           (# theObject: ^PatternDiagramNode; ff: ^mps.fragmentForm
           do
              currentNode[]->theObject[];
              (if theObject.getFragment
               // none then
                  'ASTtoNode: theNode.getFragment is none!'->putLine; 
               else
                  theObject.getFragment->ff[];
                  (if ff[] = anAST.frag[] then
                      theObject[]->theNode[]; leave search
                  if)
              if);
              
           #);
       (if switch[21] then
           ' return: '->putText;
           (if theNode[]
            // none then 'none'->putLine
            else
               theNode.id->putInt; newLine
           if);
           
       if)
   if);
   
#)  

-- ASTToNodeListUpdate: Descriptor --
(# ff: ^mps.fragmentform; oldASTName: ^Text; 
do
   (if switch[21] then 'ASTtoNodeListUpdate: '->putText;  if);
   (if oldAST[]
    // none then 'ASTtoNodeListUpdate: oldAST is none!'->putLine; 
    else
       (if switch[21] then oldAST.index->putInt; ' '->put;  if);
       (if newAST[]
        // none then 'ASTtoNodeListUpdate: newAST is none!'->putLine; 
        else
           (if switch[21] then newAST.index->putInt;  if);
           search:
           oldAST.index
             ->indexIDList.scan
               (# theObject: ^PatternDiagramNode
               do
                  currentNode[]->theObject[];
                  (if theObject.getFragment
                   // none then
                      'ASTtoNodeListUpdate: theNode.getFragment is none!'
                        ->putLine;
                      
                   else
                      theObject.getFragment->ff[];
                      (if ff[] = newAST.frag[] then
                          newAst.Index->indexIDList.impl[i];
                          theObject[]->theNode[];
                          leave search
                      if)
                  if);
                  
               #)
       if);
       (if switch[21] then
           ' return: '->putText;
           (if theNode[]
            // none then 'none'->putLine
            else
               theNode.id->putInt; newLine
           if);
           
       if);
       
   if)
#)  

-- RemoveListElement: Descriptor --
(# theNode: ^patternDiagramNode
do
   (if switch[21] then 'RemoveListElement'->putText if);
   (if anAST[] = none then
       'RemoveListElement: anAST is none!'->putLine; putLine; 
    else
       (if switch[21] then anAST.index->putInt;  if);
       search:
       anAST.index
         ->indexIDList.RemoveScan
           (# 
           do 0->IndexIDList.impl[i]; 0->IndexIDList.impl[i+1]; leave search; 
           #)
   if)
#)  

-- GppPromptForText: Descriptor --
(# status: @Text; prompt: [1] @char; answerRep: [64] @Char; t: @Text
do
   message->prompt;
   (if (prompt,@@ answerRep[1])->DSUIGetString then
       @@ answerRep[1]->cStringToCharRep->t; t.copy->confirm
    else
       cancel
   if)
#)  

-- topDotOpen: Descriptor --
(#
   index: @integer;
   formname,groupname: ^text;
   t: @text;
   fg: ^mps.fragmentgroup
do
   '-'->fullname.findCh (#  do inx->index;  #);
   (index+1,fullname.length)->fullname.sub->formname[];
   (if formname.empty then
       (fullname[],t[])->mps.top.open->f[]
    else
       (1,index-1)->fullname.sub->groupname[];
       (if not groupname.empty then
           (groupname[],t[])->mps.top.open->fg[];
           (if fg[] <> none then
               (formname[],t[])->fg.open->f[]
            else
               'topDotOpen: Could not open group: '->puttext;
               groupname[]->putline
           if)
        else
           'topDotOpen: Groupname is empty!?'->putline
       if)
   if)
#)  

-- InitGPP: Descriptor --
(# grammarWithPath,help: ^text; gg: ^mps.fragmentgroup; bobsfile: @file; 
do
(* mps;
 metaGram.init;
 metaGram[]->mps.GrammarTable.meta[];
 betaGram.init;
 
 '~beta/grammars/beta/v2.4/beta'->grammarWithPath[];
 (grammarWithPath[],screen[])->mps.top.open->gg[];
 (if gg[]
 // none then
 'Could not open: '->screen.putText;
 grammarWithPath[]->putLine;
 (failure,'')->stop;
 
 if);
 ('meta',screen[])->gg.open->gg[];
 (if gg[]
 // none then
 'Could not open: '->screen.putText;
 '-meta'->grammarWithPath.copyAppend->screen.putLine;
 (failure,'')->stop;
 
 else
 ('beta',screen[])->gg.open->betaGram.grammarAst[];
 (if betaGram.grammarAst[]
 // none then
 'No grammarAst for '->screen.putText;
 grammarWithPath[]->screen.putLine;
 (failure,'')->stop;
 
 else
 '-parser'->help[];
 mps.parserFileExtension->help.append;
 help[]->grammarWithPath.copyAppend->mps.expandToFullPath
 ->bobsFile.name;
 (if bobsFile.entry.exists
 // true then
 bobsFile.name->betaGram.parser.initialize;
 ('objectdescriptor','descriptor')
 ->betaGram.parser.privatePart.b.defineNonTAlias;
 ('attributedecl','attributes')
 ->betaGram.parser.privatePart.b.defineNonTAlias;
 
 else
 'No parser available: '->screen.putText;
 bobsFile.name->screen.putLine;
 
 if);
 
 if);
 
 if);*) 
#)  

-- OADDocumentInit: Descriptor --
(# (* setup the DesignOA menus we like to use in OADDocument *) 
do (* DocEditMenu.init; *)
   (UserMenu4,'View')->ViewMenu.init;
   true->ViewMenu.ShowAttributesItem.check;
   true->ViewMenu.SimpleAsNameAndTypeItem.check;
   true->ViewMenu.ReferencesItem.check;
   true->ViewMenu.SpecializationsItem.check;
   true->ViewMenu.AssociationsItem.check;
   (UserMenu7,'Page')->PageMenu.init;
   (UserMenu5,'Object')-> (*kja&toby 1.9.94*) ObjectMenu.init;
   ObjectMenu.disable;
   true->OGppProp.ShowDynamicCreations->ObjectMenu.ToggleDynamicCreations.check;
   true->OGppProp.ShowOperationCalls->ObjectMenu.ToggleProcedureCalls.check;
   true->OGppProp.LocalIncludeScan->ObjectMenu.LocalIncludeScan.check;
   INNER onInit;
   true->OGppProp.StaticRefCheck;
   (* (UserMenu3,'Options')->OptionsMenu.init; *)
   (*(UserMenu6,'Marks') -> MarkMenu.init;*)
   (* new document makes a new page by default
    * if we like a special page the make it here *)
   &OADPage[]->newPage[];
   (* set/clear appopriate check marks in the menus *)
   (*MarkMenu.CheckCheckMarks;*)
   (* OptionsMenu.CheckCheckMarks; *)
   
#)  

-- OADPageOnInit: Descriptor --
(#
   integerData: @integer;
   ok: @Boolean;
   listsize,last,showAttributesInteger,referencesInteger,specializationsInteger,
     associationsInteger,SimpleDeclDisplayInteger,x,y,w,h: @integer;
   xref,yref: @IntegerRef
do
   (if userDataVerbose then
       'onInit called on OADPage with id='->puttext;
       id->putint;
       newline;
       'Reading OADPage UserDataID: '->puttext
   if);
   (Id,1,@@ integerData)->UDReadType->ok;
   (if ok then
       (if userDataVerbose then
           'Read OADPage UserDataID succeed: '->puttext;
           integerData->putint;
           newline
       if);
       (integerData,ID)->UserDataIDMap.putID;
       
    else
       (if userDataVerbose then 'Read OADPage UserDataID fail'->putline if)
   if);
   ID->integerData;
   (Id,1,@@ integerData,4)->UDWriteType->ok;
   (if ok then
       (if userDataVerbose then
           'Write OADPage UserDataID succeed: '->puttext;
           integerData->putint;
           newline
       if)
    else
       (if userDataVerbose then 'Write OADPage UserDataID fail'->putline if)
   if);
   (if THIS(OADPage)[] = theGroupPage[] then
       (theGroupPage.ID,499,@@ listsize)->UDReadType->ok;
       (if ok then
           listsize->IndexIDList.impl.new;
           (if userDataVerbose then
               'Read IndexIDList.impl.range succeed: '->puttext;
               listsize->putint;
               newline
           if);
           (theGroupPage.ID,500,@@ last)->UDReadType->ok;
           (if ok then
               last->IndexIDList.last;
               (if userDataVerbose then
                   'Read IndexIDList.last succeed: '->puttext;
                   last->putint;
                   newline
               if);
               (for i: listsize repeat
                 (theGroupPage.ID,500+i,@@ IndexIDList.impl[i])->UDReadType->ok;
                 (if ok then
                     (if userDataVerbose then
                         'Read IndexIDList succeed: '->puttext;
                         'element no '->puttext;
                         i->putint;
                         'element '->puttext;
                         IndexIDList.impl[i]->putint;
                         newline
                     if)
                  else
                     'Read IndexIDList fail: '->puttext
                 if)
               for)
            else
               (if userDataVerbose then
                   'Read IndexIDList.last fail'->putline
               if)
           if)
        else
           (if userDataVerbose then
               'Read IndexIDList.impl.range fail: '->puttext
           if)
       if);
       (theGroupPage.ID,260,@@ showAttributesInteger)->UDReadType->ok;
       (if ok then
           (if showAttributesInteger = 1 then
               true->gppProp.showAttributes->ViewMenu.ShowAttributesItem.check
            else
               (if showAttributesInteger = 0 then
                   false->gppProp.showAttributes
                     ->ViewMenu.ShowAttributesItem.check
               if)
           if);
           (if userDataVerbose then
               'Read showAttributes succeed: '->puttext;
               showAttributesInteger->putint;
               newline
           if)
        else
           (if userDataVerbose then 'Read showAttributes fail'->putline if)
       if);
       (theGroupPage.ID,261,@@ referencesInteger)->UDReadType->ok;
       (if ok then
           (if referencesInteger = 1 then
               true->gppProp.references->ViewMenu.referencesItem.check
            else
               (if referencesInteger = 0 then
                   false->gppProp.references->ViewMenu.referencesItem.check
               if)
           if);
           (if userDataVerbose then
               'Read references succeed: '->puttext;
               referencesInteger->putint;
               newline
           if)
        else
           (if userDataVerbose then 'Read references fail'->putline if)
       if);
       (theGroupPage.ID,262,@@ specializationsInteger)->UDReadType->ok;
       (if ok then
           (if specializationsInteger = 1 then
               true->gppProp.specializations->ViewMenu.specializationsItem.check
            else
               (if specializationsInteger = 0 then
                   false->gppProp.specializations
                     ->ViewMenu.specializationsItem.check
               if)
           if);
           (if userDataVerbose then
               'Read specializations succeed: '->puttext;
               specializationsInteger->putint;
               newline
           if)
        else
           (if userDataVerbose then 'Read specializations fail'->putline if)
       if);
       (theGroupPage.ID,263,@@ associationsInteger)->UDReadType->ok;
       (if ok then
           (if associationsInteger = 1 then
               true->gppProp.associations->ViewMenu.associationsItem.check
            else
               (if associationsInteger = 0 then
                   false->gppProp.associations->ViewMenu.associationsItem.check
               if)
           if);
           (if userDataVerbose then
               'Read associations succeed: '->puttext;
               associationsInteger->putint;
               newline
           if)
        else
           (if userDataVerbose then 'Read associations fail'->putline if)
       if);
       (theGroupPage.ID,264,@@ SimpleDeclDisplayInteger)->UDReadType->ok;
       (if ok then
           SimpleDeclDisplayInteger->gppProp.SimpleDeclDisplay;
           (if userDataVerbose then
               'Read SimpleDeclDisplay succeed: '->puttext;
               SimpleDeclDisplayInteger->putint;
               newline
           if);
           false->ViewMenu.SimpleAsNameAndTypeItem.Check;
           false->ViewMenu.SimpleAsNameItem.Check;
           false->ViewMenu.SimpleAsTypeItem.Check;
           false->ViewMenu.SimpleAsNameAndKindItem.Check;
           (if gppProp.SimpleDeclDisplay
            // gppProp.asNameAndType then
               true->ViewMenu.SimpleAsNameAndTypeItem.check
            // gppProp.asName then
               true->ViewMenu.SimpleAsNameItem.check
            // gppProp.asType then
               true->ViewMenu.SimpleAsTypeItem.check
            // gppProp.asNameAndKind then
               true->ViewMenu.SimpleAsNameAndKindItem.check
           if)
        else
           (if userDataVerbose then 'Read SimpleDeclDisplay fail'->putline if)
       if)
   if);
   patternDiagrams.AssociationList.load;
   patternDiagrams.InheritanceList.load;
   patternDiagrams.DynReferenceList.load;
   (ID,240,@@ NextX)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read NextX succeed'->putline
        else
           'Read NextX fail'->putline
       if)
   if);
   (ID,241,@@ NextY)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read NextY succeed'->putline
        else
           'Read NextY fail'->putline
       if)
   if);
   (ID,250,@@ patternDiagrams.NextFreeLine)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read NextFreeLine succeed'->putline
        else
           'Read NextFreeLine fail'->putline
       if)
   if);
   (ID,251,@@ patternDiagrams.NextFreeColumn)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read NextFreeColumn succeed'->putline
        else
           'Read NextFreeColumn fail'->putline
       if)
   if);
   (ID,252,@@ patternDiagrams.SecondFreeLine)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read SecondFreeline succeed'->putline
        else
           'Read SecondFreeLine fail'->putline
       if)
   if);
   (ID,253,@@ patternDiagrams.SecondFreeColumn)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read SecondFreeColumn succeed'->putline
        else
           'Read SecondFreeColumn fail'->putline
       if)
   if);
   (*  THIS(OADPage).geometry->(x,y,w,h);
    'OADPageOnInit: OADPage geometry '->puttext;
    x->putint;
    ' '->puttext;
    y->putint;
    ' '->puttext;
    w->putint;
    ' '->puttext;
    h->putint;
    newline;
    (if (w = 0) and (h = 0) then
    
    (ID,256,@@ w)->UDReadType->ok;
    (if userDataVerbose then
    (if ok then
    'Read w succeed'->putline
    else
    'Read w fail'->putline
    if)
    if);
    (ID,257,@@ h)->UDReadType->ok;
    (if userDataVerbose then
    (if ok then
    'Read h succeed'->putline
    else
    'Read h fail'->putline
    if)
    if);
    'OADPageOnInit: OADPage geometry after UDRead '->puttext;
    x->putint;
    ' '->puttext;
    y->putint;
    ' '->puttext;
    w->putint;
    ' '->puttext;
    h->putint;
    newline;
    (if (THIS(Page).ID,w,h)->DSWtAttrAdjustObjectSize
    // false then 'PageSetGeo: could not set size'->putline
    if);
    (if (THIS(Page).ID,xref[],yref[])->DSRdAttrGetObjectSize
    // true then xref->w; yref->h; 
    else
    'PageGetGeometry Size: error'->putline; 
    if);
    'OADPageOnInit: OADPage geometry after setSize'->puttext;
    x->putint;
    ' '->puttext;
    y->putint;
    ' '->puttext;
    w->putint;
    ' '->puttext;
    h->putint;
    newline
    if);*)
   false->borderVisible;
   (if nextX = 0 then 250->nextX if);
   (if nextY = 0 then 250->nextY if);
   (*gppProp.NextPositionStartX*)
   (*gppProp.NextPositionStartY*)
   true->doScrollIntoView;
   
#)  

-- CalculateNextCenter: Descriptor --
(# x,y,w,h: @Integer; p: ^OADPage; 
do
   (if PatternDiagrams.theList.size
    // 0 then (* first diagram on page *)
       CurrentPage->p[];
       p.Geometry->(x,y,w,h);
       (* center, width, and height of PAGE *)
       y-(h div 2)+gppProp.DownOnPage->PatternDiagrams.NextFreeLine;
       x-(w div 2)+gppProp.RightOnPage->PatternDiagrams.NextFreeColumn;
       PatternDiagrams.NextFreeLine->PatternDiagrams.SecondFreeLine;
       PatternDiagrams.NextFreeColumn+gppProp.width+gppProp.RightFromPrevious
         ->PatternDiagrams.SecondFreeColumn;
       
   if);
   (PatternDiagrams.NextFreeColumn,PatternDiagrams.NextFreeLine)->theCenter;
   (*(nextX,nextY)->theCenter;*)
   
#)  

-- UpdateNextFree: Descriptor --
(# w,h: @Integer; xref,yref: @IntegerRef; 
do
   (if x-gppProp.width > theCenter.x then
       'UpdateNextFree: we have the last box on another column than the title ?'
         ->putline;
       x->PatternDiagrams.NextFreeColumn;
       
   if);
   ;
   (PatternDiagrams.NextFreeLine,y+gppProp.DownFromPrefix)->Max
     ->PatternDiagrams.NextFreeLine;
   (PatternDiagrams.SecondFreeColumn,x+gppProp.width+gppProp.RightFromPrevious)
     ->Max->PatternDiagrams.SecondFreeColumn;
   0->y;
   730->h;
   (if PatternDiagrams.NextFreeLine > y+(h div 2) then
   (* PatternDiagrams.SecondFreeLine -> PatternDiagrams.NextFreeLine;*)
       y-(h div 2)+gppProp.DownOnPage->PatternDiagrams.NextFreeLine;
       (if true (* PatternDiagrams.NextFreeColumn < theCenter.x *) then
           PatternDiagrams.SecondFreeColumn->PatternDiagrams.NextFreeColumn;
           PatternDiagrams.SecondFreeColumn+gppProp.width+
           gppProp.RightFromPrevious->PatternDiagrams.SecondFreeColumn;
           
       if);
       
   if);
   
#)  

-- StartCreatePrefix: Descriptor --
(#
   PC: Connector
     (#
        onInit::< 
          (# prefixTitle,title: ^PatternDiagramNode; a,b: ^Node; 
          do
             0->Orient;
             GetEnds->(a[],b[]);
             (if (a[] <> none ) and (b[] <> none )
              // true then
                 (if a.struc <= PatternDiagramNode##
                  // true then a[]->title[]; 
                  else
                     'Incorrect pattern node selected'->gppalert; 
                 if);
                 (if b.struc <= PatternDiagramNode##
                  // true then
                     b[]->prefixtitle[];
                     (if prefixtitle.theDiagram
                      // none then 'Incorrect prefix selected'->gppalert; 
                      else
                         (prefixtitle.theDiagram).titlenode[]->prefixtitle[]; 
                     if)
                  else
                     'Incorrect prefix selected'->gppalert; 
                 if);
                 (prefixTitle[],title[])->PrefixExpand;
                 
              else
                 'Incorrect nodes selected in prefix creation'->gppalert; 
             if);
             
          #);
        interactivenew::< 
          (# cursorformat::<  (#  do cursor.arrow->curs #) #)
     #);
   aPC: ^PC;
   
do
   &PC[]->aPC[];
   'Specify Prefix by first selecting the Pattern and then the prefix'
     ->aPC.interactivenew;
   
#)  

-- gppChangedFocus: Descriptor --
(# 
do (* true->OKtoChange;*)
   currentFocus[]->oldFocus[];
   newObject[]
     ->CurrentFocus[] (*  else
                       oldObject[]->currentObject
                       if)*) ;
   (*  currentFocus[]->currentObject (#  do true->autoPan #); *)
   (* (if OKToChange then*)
   INNER changedFocus
#)  

-- ASTtoNearestNode: DoPart --
do
   anAST[]->ASTtoNode->node[];
   (if node[] = none then
       L:
       (if true then
           anAST.father->anAST[];
           (if anAST[] <> none then
               anAST[]->ASTtoNode->node[];
               (if node[] = none then restart L if);
               
           if)
       if);
       
   if)  

-- newFragment: Descriptor --
(# 
do (if switch[22] // true then 'Gpp ------- newFragment'->putLine;  if); 
#)  

-- fragmentChanged: DoPart --
do
     (# foundDiagram: ^ListDiagram
     do
        FragmentDiagram##
          ->ScanDiagrams
            (# theDiagram: ^FragmentDiagram; theRegionList: ^ObjectList
            do
               current[]->theDiagram[];
               (if ff.father
                // theDiagram.theGroup then (* find formname in the diagram *)
                   theDiagram[]->foundDiagram[];
                   theDiagram.localnodes.scan
                     (#
                        theFragmentNode: ^theDiagram.FragmentNode;
                        t: ^text;
                        index: @integer;
                        w1,h1: @integer;
                        
                     do
                        current[]->theFragmentNode[];
                        (if ff[] = theFragmentNode.theFragment then
                            ff[]->theFragmentNode.redisplay;
                            (if theFragmentNode.currentDecomposDiagram <> none
                             then
                                (ff.father).name->t[];
                                '/'->t.findCh (#  do inx->index #);
                                (index+1,t.length)->t.sub->t[];
                                '-'->t.put;
                                theFragmentNode.theName->t.puttext;
                                t
                                  ->
                                    (theFragmentNode.currentDecomposDiagram).
                                    titleNode.theText.set;
                                (theFragmentNode.currentDecomposDiagram).
                                titleNode.getRegionList->theRegionList[];
                                (if theRegionList[] <> none then
                                    theRegionList.scan
                                      (# anObj: ^DesignObject
                                      do current[]->anObj[]; anObj.unmakeRegion
                                      #);
                                    
                                if);
                                (theFragmentNode.currentDecomposDiagram).
                                titleNode.FitToText;
                                (theFragmentNode.currentDecomposDiagram).
                                titleNode.Size->(w1,h1);
                                ((w1,gppProp.titleWidth)->max,h1)
                                  ->
                                    (theFragmentNode.currentDecomposDiagram).
                                    titleNode.size;
                                (if theRegionList[] <> none then
                                    theRegionList.scan
                                      (# anObj: ^DesignObject
                                      do
                                         current[]->anObj[];
                                         (theFragmentNode.currentDecomposDiagram
                                         ).titleNode[]->anObj.createRegion
                                      #)
                                if);
                                t
                                  ->
                                    (theFragmentNode.currentDecomposDiagram).
                                    titleText
                            if)
                        if)
                     #)
               if)
            #);
        foundDiagram.localNodes.adjustsizes;
        autosave
     #)  

-- fragmentInserted: DoPart --
do
   FragmentDiagram##
     ->ScanDiagrams
       (# theDiagram: ^FragmentDiagram; pos: @integer
       do
          current[]->theDiagram[];
          (if ff.father
           // theDiagram.theGroup then (* find formname in the diagram *)
              1->pos;
              scanner: (ff.father).fragmentList.scan
                (# 
                do
                   (if current.type
                    // mps.linkType then (* ignore *)
                       
                    // mps.groupType then
                       'Groups in groups not suported'->putline; 
                    // mps.formType then
                       (if current.f[] = ff[] then
                           leave scanner
                        else
                           pos+1->pos
                       if);
                       
                   if);
                   
                #);
              (pos-1,ff[])->theDiagram.insertFragmentNode
          if)
       #);
   autosave  

-- fragmentDeleted: DoPart --
do
   scanner:
   FragmentDiagram##
     ->ScanDiagrams
       (# theDiagram: ^FragmentDiagram; pos: @integer
       do
          current[]->theDiagram[];
          (if ff.father = theDiagram.theGroup then
              theDiagram.localNodes.scan
                (# theFragmentNode: ^theDiagram.FragmentNode
                do
                   current[]->theFragmentNode[];
                   (if ff[] = theFragmentNode.theFragment then
                       theFragmentNode[]->theDiagram.deleteFragmentNode;
                       leave scanner
                   if)
                #)
          if)
       #);
   autosave  

-- astReplaced: DoPart --
do
   thisOp:
     (#
        theObject: ^PatternDiagramNode;
        pos: @integer;
        theDiagram: ^Diagram;
        doListReplace: @boolean;
        deleted: @boolean;
        dummyFilter: ##external;
        pageList: ^ObjectList;
        filename: @Text;
        nonterminalName: ^Text;
        cancelled: ^integerRef;
        prompt: @text;
        count: @ShortRef;
        list: @IntegerRef;
        theListDiagram: ^ListDiagram;
        theAbstractNode: ^theListDiagram.AbstractNode;
        theunexp: ^mps.unexpanded;
        
     do
        (if switch[22]
         // true then
            'Gpp ------- astReplaced  '->puttext;
            'oldindex: '->putText;
            oldAst.index->putInt;
            '  '->puttext;
            'newindex: '->putText;
            newAst.index->putInt;
            newLine;
            
        if);
        (if private.dynamicReferenceQual[] <> none then
            (newAST[],private.dynamicReferenceQual[])
              ->patternDiagrams.DynReferenceList.insert
        if);
        (if oldAST.kind
         // mps.kinds.unExpanded then
         (* this is an ECOOP94 hack, must be generalized *)
            (if newAst.kind
             // mps.kinds.interior then
                (if switch[22]
                 // true then 'expanding a nonterminal'->putLine; 
                if);
                (if NewAST## <= betaGram.attributeDecl## then
                    (if switch[22] then
                        'It is a declaration: '->putText;
                        NewAST.symbol->putInt;
                        newLine;
                        
                    if);
                    true->doListReplace;
                    
                if);
                
             // mps.kinds.optional then
                oldAST[]->ASTtoNode->theObject[];
                (if theObject[] <> none then
                    theObject.theDiagram->theDiagram[];
                    (theObject[],true)->theDiagram.deleteDiagramNode;
                    true->deleted;
                    
                 else
                    leave thisOp
                if)
            if)
         // mps.kinds.interior then
            oldAST[]->patternDiagrams.AssociationList.update;
            oldAST[]->patternDiagrams.InheritanceList.update;
            oldAST[]->patternDiagrams.dynReferenceList.update;
            (if newAST.kind = mps.kinds.interior then
                (if oldAST## <= betaGram.attributeDecl## then
                    (if newAST## <= betaGram.attributeDecl## then
                        (if oldAST## <> newAST## then true->doListReplace if)
                    if)
                if)
             else
                true->doListReplace
            if)
         // mps.kinds.optional then
            (if newAST.kind = mps.kinds.unexpanded then
                newAST[]->theunexp[];
                theunexp.nonTerminalSymbol->betaGram.symbolToName
                  ->nonterminalName[];
                (if 'AttributeDeclOpt'->nonterminalName.equal then
                    oldAst[]->ASTtoNearestNode->theObject[];
                    (if theObject[] <> none then
                        theObject.theDiagram->theListDiagram[];
                        (if theObject## <= theListDiagram.AbstractNode## then
                            theObject[]->theAbstractNode[];
                            (if theAbstractNode.currentDecomposDiagram <> none
                             then
                                (newAST.sonNo-1,newAST[])
                                  ->
                                    (theAbstractNode.currentDecomposDiagram).
                                    insertDiagramNode;
                                leave thisOp
                            if)
                        if)
                     else
                        'astReplaced: theObject is none'->putline; leave thisOp
                    if)
                if)
            if)
        if);
        (if doListReplace then
            oldAST[]->ASTtoNode->theObject[];
            (if theObject[] <> none then
                theObject.theDiagram->theDiagram[];
                (*
                 (theObject[],true)->theObject.theDiagram.deleteDiagramNode;
                 (pos,newAST[])->theDiagram.insertDiagramNode;    
                 * *)
                (theObject[],newAST[])->theDiagram.replaceDiagramNode;
                
            if)
         else
            (if not deleted then
                oldAST[]->ASTtoNearestNode->theObject[];
                (if theObject[] <> none then
                    (if private.dynamicReferenceQual[] <> none then
                        none ->private.dynamicReferenceQual[]
                    if);
                    (oldAst[],newAst[])
                      ->(theObject.theDiagram).updateDiagramNode
                 else
                    'astReplaced: theObject is none'->putline
                if)
            if);
            
        if);
        Redraw;
        autosave;
        
     #)  

-- listElementInserted: Descriptor --
(#
   theObject: ^PatternDiagramNode;
   newAst,firstBorn: ^mps.ast;
   pos,i,noOfSons: @integer
do
   (if switch[22]
    // true then
       'Gpp ------- listElementInserted  '->puttext;
       'fatherIndex: '->putText;
       father.index->putInt;
       '  '->puttext;
       'position: '->putText;
       position->putInt;
       newLine;
       
   if);
   (if position = 1 then
       father.getSon2->firstBorn[]
    else
       father.getson1->firstBorn[]
   if);
   (if firstBorn.kind = mps.kinds.optional then
       father.noOfSons->noOfSons;
       2->i;
       loop:
         (# 
         do
            (if noOfSons >= i then
                i->father.get->firstBorn[];
                (if (firstBorn.kind = mps.kinds.optional) or (position = i) then
                    i+1->i; restart loop
                if)
             else
                none ->firstBorn[]
            if)
         #)
   if);
   position->pos->father.get->newAST[];
   1->i;
   scanner: father.scan
     (# 
     do
        (if not (i = position) then
            (if current.kind = mps.kinds.optional then pos-1->pos if); i+1->i
         else
            leave scanner
        if)
     #);
   firstBorn[]->ASTtoNearestNode->theObject[];
   (if theObject[] <> none then
       (pos-1,newAST[])->(theObject.theDiagram).insertDiagramNode;
       Redraw;
       autosave
    else
       'listElementInserted: theObject is none'->putline
   if)
#)  

-- listElementsDeleted: Descriptor --
(# theObject: ^PatternDiagramNode
do
   (if switch[22]
    // true then 'Gpp ------- listElementsDeleted'->putLine; 
   if);
   (for i: length repeat
     oldElements[i][]->patternDiagrams.AssociationList.update;
     oldElements[i][]->patternDiagrams.InheritanceList.update;
     oldElements[i][]->patternDiagrams.dynReferenceList.update;
     oldElements[i][]->ASTtoNode->theObject[];
     (if theObject[] <> none then
         (theObject[],true)->(theObject.theDiagram).deleteDiagramNode; 
     if)
   for);
   Redraw;
   autosave;
   
#)  

-- listElementsReplaced: Descriptor --
(#
(* changeSpec:
 * <fatherIndex> <position> <length> <oldElements> <newLength> 
 * <oldElements> ::= { <elementIndex> } i    (i = <length>)
 *)
   oldAst,newAst,anAST: ^mps.ast;
   theDiagram: ^Diagram;
   pos,oldIndex,j: @integer;
   theObject: ^PatternDiagramNode
do
   (if switch[22]
    // true then 'Gpp ------- listElementsReplaced'->putLine; 
   if);
   (for i: length repeat
     oldElements[i][]->patternDiagrams.AssociationList.update;
     oldElements[i][]->patternDiagrams.InheritanceList.update;
     oldElements[i][]->patternDiagrams.dynReferenceList.update;
     oldElements[i][]->ASTtoNode->theObject[];
     (if theObject[] <> none then
         theObject.theDiagram->theDiagram[];
         (theObject[],true)->(theObject.theDiagram).deleteDiagramNode;
         
     if)
   for);
   (for i: newlength repeat
     position+i-1->pos->father.get->newAST[];
     (if not (newAST.kind = mps.kinds.optional) then
         (if theDiagram[] = none then
             'Gpp: ListElementsReplaced: theDiagram is none!!'->putLine
          else
             1->j;
             scanner: father.scan
               (# 
               do
                  (if not (j = position+i-1) then
                      (if current.kind = mps.kinds.optional then
                          pos-1->pos
                      if);
                      j+1->j
                   else
                      leave scanner
                  if)
               #);
             (pos-1,newAST[])->theDiagram.insertDiagramNode
         if)
     if);
     
   for);
   Redraw;
   autosave;
   
#)  

-- makeAnchors: Descriptor --
(# noOfNodes,i: @Integer; theObject: ^PatternDiagramNode; 
do
(*'Freja[[MakeAnchors: '->screen.puttext;
 indexList[]->screen.puttext;
 ']]'->screen.putline;
 indexList.reset;
 indexList.getInt->noOfNodes;
 (for noOfNodes repeat
 indexList.getInt->i->AstToNode->theObject[];
 (if theObject[] <> none
 // true then theObject.MakeAnchor;
 else
 'Freja[[No node is presented with index: '->screen.puttext;
 i->screen.putint;
 ']]'->screen.putline;
 if)
 for);
 * *) 
#)  

-- getExtension: Descriptor --
(# index: @Integer; 
do
   '.'->name.findCh (#  do inx->index;  #);
   (if index <= 1 then
       ''->extension[]
    else
       (index,name.length)->name.sub->extension[]
   if);
   
#)  

-- removeExtension: Descriptor --
(# rest: ^Text; index: @Integer; 
do
(*(if ('.bet'->rest.equal) or (astFileExtension->rest.equal)
 // true then*)
   '.'->name.findCh (#  do inx->index;  #);
   (index,name.length)->name.sub->rest[];
   (* if);*)
   (index,name.length)->name.delete;
   ;
   (*(if ('.bet'->rest.equal) or (astFileExtension->rest.equal)
    // true then*)
   
#)  

-- doStartup: Descriptor --
(#
   arg: ^Text;
   swt: @Text;
   SwitchMode: @Boolean;
   N: @Integer;
   ext: ^Text;
   help: @text;
   didRecover,ok: @boolean;
   diagFile,astFile,betFile: @file;
   
do
   (if NoOfArguments > 1
    // true then
       (for i: NoOfArguments-1 repeat
         i+1->Arguments->arg[];
         0->arg.setpos;
         (if SwitchMode
          // true then
             arg.getint->N;
             (if True
              // (0 < N) and (N <= switch.range) then
                 True->Switch[N]; 
              // N = 0 then
                 false->SwitchMode; 
             if)
          else
             (if arg.peek
              // '-' then
                 arg.get;
                 (if arg.peek
                  // 'd' // 'D' then
                     arg.get;
                     (if arg.eos
                      // true then
                         true->switch[1]; 
                      // false then
                         (if arg.peek
                          // 'e' then
                             arg.get;
                             (if arg.peek // 'x' then dexterOn if);
                             
                         if)
                     if);
                     
                  // 's' // 'S' then
                     true->SwitchMode; swt.clear; 
                 if);
                 
              else
                 (if arg.length > 0
                  // true then
                     arg->getExtension->ext[];
                     (if ('.bet'->ext.equal) or
                     (mps.astFileExtension->ext.equal) then
                         arg->removeExtension->arg;
                         arg.copy->diagFile.name;
                         arg.copy->astFile.name;
                         arg.copy->betFile.name;
                         '.diag'->arg.copyAppend->diagFile.name;
                         '.ast'->arg.copyAppend->astFile.name;
                         '.bet'->arg.copyAppend->betFile.name;
                         (if diagFile.entry.exists then
                             (if astFile.entry.exists then
                                 (if diagFile.entry.modtime >
                                 astFile.entry.modtime then
                                     (if betFile.entry.exists then
                                         (if betFile.entry.modtime >
                                         diagFile.entry.modtime then
                                             (if currentDiagramName[] = none
                                              then
                                                 arg.copy->currentDiagramName[];
                                                 '.diag'
                                                   ->currentDiagramName.append;
                                                 
                                             if);
                                             arg->openFragmentGroup
                                          else
                                             '.diag file is newer, open instead?'
                                               ->DSUIGetUserYesOrNo->ok;
                                             (if ok then
                                                 '.diag'->arg.append;
                                                 arg->checkAutoSaveFile
                                                   ->didRecover;
                                                 (if
                                                 (arg,didRecover,true)
                                                   ->checkDiagFile then
                                                     arg->openDiagram
                                                 if)
                                              else
                                                 (if currentDiagramName[] = none
                                                 then
                                                     arg.copy
                                                       ->currentDiagramName[];
                                                     '.diag'
                                                       ->
                                                         currentDiagramName.
                                                           append;
                                                     
                                                 if);
                                                 arg->openFragmentGroup
                                             if)
                                         if)
                                      else
                                         '.diag file is newer, open instead?'
                                           ->DSUIGetUserYesOrNo->ok;
                                         (if ok then
                                             '.diag'->arg.append;
                                             arg->checkAutoSaveFile->didRecover;
                                             (if
                                             (arg,didRecover,true)
                                               ->checkDiagFile then
                                                 arg->openDiagram
                                             if)
                                          else
                                             (if currentDiagramName[] = none
                                              then
                                                 arg.copy->currentDiagramName[];
                                                 '.diag'
                                                   ->currentDiagramName.append;
                                                 
                                             if);
                                             arg->openFragmentGroup
                                         if)
                                     if)
                                  else
                                     (if currentDiagramName[] = none then
                                         arg.copy->currentDiagramName[];
                                         '.diag'->currentDiagramName.append;
                                         
                                     if);
                                     arg->openFragmentGroup
                                 if)
                              else
                                 (if currentDiagramName[] = none then
                                     arg.copy->currentDiagramName[];
                                     '.diag'->currentDiagramName.append;
                                     
                                 if);
                                 arg->openFragmentGroup
                             if)
                          else
                             (if currentDiagramName[] = none then
                                 arg.copy->currentDiagramName[];
                                 '.diag'->currentDiagramName.append;
                                 
                             if);
                             arg->openFragmentGroup
                         if)
                      else
                         (if '.diag'->ext.equal then
                             arg->checkAutoSaveFile->didRecover;
                             (if (arg,didRecover,true)->checkDiagFile then
                                 arg->openDiagram
                             if)
                          else
                             (if ext.empty then
                                 arg.copy->diagFile.name;
                                 arg.copy->astFile.name;
                                 arg.copy->betFile.name;
                                 '.diag'->arg.copyAppend->diagFile.name;
                                 '.ast'->arg.copyAppend->astFile.name;
                                 '.bet'->arg.copyAppend->betFile.name;
                                 (if diagFile.entry.exists then
                                     (if astFile.entry.exists then
                                         (if betFile.entry.exists then
                                             (if betFile.entry.modtime >
                                             diagFile.entry.modtime then
                                                 '.bet file is newer than .diag file.\nOpen .bet file?'
                                                   ->DSUIGetUserYesOrNo->ok;
                                                 (if ok then
                                                     (if currentDiagramName[] =
                                                     none then
                                                         arg.copy
                                                           ->
                                                             currentDiagramName[];
                                                         '.diag'
                                                           ->
                                                             currentDiagramName.
                                                               append;
                                                         
                                                     if);
                                                     arg->openFragmentGroup
                                                 if)
                                              else
                                                 '.diag'->arg.append;
                                                 arg->checkAutoSaveFile
                                                   ->didRecover;
                                                 (if
                                                 (arg,didRecover,true)
                                                   ->checkDiagFile then
                                                     arg->openDiagram
                                                 if)
                                             if)
                                          else
                                             '.diag'->arg.append;
                                             arg->checkAutoSaveFile->didRecover;
                                             (if
                                             (arg,didRecover,true)
                                               ->checkDiagFile then
                                                 arg->openDiagram
                                             if)
                                         if);
                                         (*  (if diagFile.entry.modtime > astFile.entry.modtime then
                                          (if betFile.entry.exists then
                                          (if betFile.entry.modtime > diagFile.entry.modtime
                                          then
                                          '.bet file is newer than .diag file.\nOpen .bet file?'
                                          ->DSUIGetUserYesOrNo->ok;
                                          (if ok then
                                          (if currentDiagramName[] = none then
                                          arg.copy->currentDiagramName[];
                                          '.diag'->currentDiagramName.append;
                                          
                                          if);
                                          arg->openFragmentGroup
                                          if)
                                          else
                                          '.diag'->arg.append;
                                          arg->checkAutoSaveFile->didRecover;
                                          (if (arg,didRecover,true)->checkDiagFile then
                                          arg->openDiagram
                                          if)
                                          if)
                                          else
                                          '.diag'->arg.append;
                                          arg->checkAutoSaveFile->didRecover;
                                          (if (arg,didRecover,true)->checkDiagFile then
                                          arg->openDiagram
                                          if)
                                          if)
                                          else
                                          '.ast file is newer than .diag file.\nOpen .ast file?'
                                          ->DSUIGetUserYesOrNo->ok;
                                          (if ok then
                                          (if currentDiagramName[] = none then
                                          arg.copy->currentDiagramName[];
                                          '.diag'->currentDiagramName.append;
                                          
                                          if);
                                          arg->openFragmentGroup
                                          if)
                                          if)*)
                                         
                                      else
                                         (if betFile.entry.exists then
                                             'No .ast file exists for .diag file.\nOpen .bet file?'
                                               ->DSUIGetUserYesOrNo->ok;
                                             (if ok then
                                                 (if currentDiagramName[] = none
                                                 then
                                                     arg.copy
                                                       ->currentDiagramName[];
                                                     '.diag'
                                                       ->
                                                         currentDiagramName.
                                                           append;
                                                     
                                                 if);
                                                 arg->openFragmentGroup
                                             if)
                                          else
                                             '.diag'->arg.append;
                                             arg->checkAutoSaveFile->didRecover;
                                             (if
                                             (arg,didRecover,true)
                                               ->checkDiagFile then
                                                 arg->openDiagram
                                             if)
                                         if)
                                     if)
                                  else
                                     (if astFile.entry.exists or
                                     betFile.entry.exists then
                                         (if currentDiagramName[] = none then
                                             arg.copy->currentDiagramName[];
                                             '.diag'->currentDiagramName.append;
                                             
                                         if);
                                         arg->openFragmentGroup
                                      else
                                         'Please select a .bet, .ast or .diag file!'
                                           ->GppAlert
                                     if)
                                 if)
                              else
                                 'Please select a .bet, .ast or .diag file!'
                                   ->GppAlert
                             if)
                         if)
                     if);
                     
                 if);
                 
             if)
         if)
       for)
   if)
#)  

-- GetGroupName: Descriptor --
(* ask user for a group name *)
  (# name: @Text; ext: ^text; 
  do
     'Select a .bet or .ast file'->DSFileNameDialog->name;
     (if name.length > 0
      // true then
         name->getExtension->ext[];
         (if ('.bet'->ext.equal) or ('.ast'->ext.equal) then
             name->removeExtension->name;
             (if switch[1]
              // true then 'Opening: '->puttext; name[]->putline; 
             if);
             name->openFragmentGroup
          else
             'You must select a .bet or .ast file!'->DSUIUserAckMessage
         if);
         
     if);
     
  #)  

-- OpenFragmentGroup: Descriptor --
(#
   myDocument: ^OADDocument;
   opened: @boolean;
   propd: ^myDocument.theGroupPage.PropertyDiagram;
   fragd: ^myDocument.theGroupPage.FragmentDiagram;
   mess: @Text;
   FragmentDoesNotExistText,diagFileName,frejaFileName: ^text;
   NoOfForms: @Integer;
   groupFile,autosaveGroupFile,tildeGroupFile,autoSaveFrejaFile: @file;
   ok,doNotOpenAstFile: @boolean;
   
do
   (if switch[2]
    // true then
       'Opening: '->mess.puttext;
       name[]->mess.puttext;
       mess[]
         ->putLine
         (*
          * mess->statusbar.set; 
          *)
   if);
   '.ast'->name.copyAppend->groupFile.name;
   '.ast#'->name.copyAppend->autosaveGroupFile.name;
   '.ast~'->name.copyAppend->tildeGroupFile.name;
   '.freja'->name.copyAppend->frejaFileName[];
   '.freja#'->name.copyAppend->autoSaveFrejaFile.name;
   (if switch[17] then
       'Freja OpenFragmentGroup: '->putLine;
       groupFile.name->putLine;
       autosaveGroupFile.name->putLine;
       tildeGroupFile.name->putLine
   if);
   (if autosaveGroupFile.entry.exists and groupFile.entry.exists then
       (if autosaveGroupFile.entry.modtime > groupFile.entry.modtime then
           (if autoSaveFrejaFile.entry.exists then
               (if autosaveFrejaFile.entry.modtime > groupFile.entry.modtime
                then
                   'Autosave file is newer, recover?'->DSUIGetUserYesOrNo->ok;
                   (if ok then
                       'mv .freja# .freja'->putLine;
                       FrejaFileName[]->autoSaveFrejaFile.entry.rename;
                       '.diag'->name.copyAppend->diagFileName[];
                       diagFileName->recoverDiagFile;
                       (if (diagFileName,true,false)->checkDiagFile then
                           diagFileName->openDiagram; true->doNotOpenAstFile
                        else
                           'mv .ast# .ast'->putLine;
                           groupFile.name->autoSaveGroupFile.entry.rename
                       if)
                   if)
                else
                   'Autosave .ast file is newer, recover?'->DSUIGetUserYesOrNo
                     ->ok;
                   (if ok then
                       'mv .ast# .ast'->putLine;
                       groupFile.name->autoSaveGroupFile.entry.rename
                   if)
               if)
            else
               'Autosave .ast file is newer, recover?'->DSUIGetUserYesOrNo->ok;
               (if ok then
                   'mv .ast# .ast'->putLine;
                   groupFile.name->autoSaveGroupFile.entry.rename
               if)
           if)
       if)
   if);
   (if not doNotOpenAstFile then
       thisOperation:
       (name[]->mps.ExpandToFullPath,screen[])
         ->mps.top.open
           (#
              fragmentNotExisting::< 
                (# t: ^text
                do
                   'Fragment file does not exist '->FragmentDoesNotExistText[];
                   leave thisOperation
                #);
              WriteAccessOnLstFileError::< 
                (# 
                do
                   'Access error on .lst file'->mess;
                   mess->DSUIUserAckMessage;
                   (* statusbar.reset;*)
                   true->continue (*'Access error on .lst file'->myException*)
                #);
              writeAccessError::< 
                (# 
                do
                   'No write access'->mess;
                   mess->DSUIUserAckMessage;
                   (* statusbar.reset;*)
                   true
                     ->continue
                     (*'Write access error'->myException
                      * *)
                #);
              startingParsing::< 
                (# 
                do
                   'Parsing '->mess;
                   name[]->mess.putText;
                   mess->DSUIUserAckMessage;
                   
                #);
              ParseErrors::< 
                (# 
                do
                   none ->f[];
                   none ->mps.theCatcher[];
                   mess->DSUIUserAckMessage;
                   leave thisOperation
                #)
           #)->fg[];
       (if fg[]
        // none then
           'Cannot open fragmentgroup: '->mess;
           name[]->mess.puttext;
           (if FragmentDoesNotExistText[] <> none then
               mess.newline; FragmentDoesNotExistText[]->mess.puttext
           if);
           mess->DSUIUserAckMessage;
           
        else
           fg.fragmentlist.scan
             (# 
             do
                (if current.type
                 // mps.formtype then noofforms+1->noofforms
                if)
             #);
           (if (* fg[] -> isChecked//false *) true
            // false then
               'FragmentGroup '''->puttext;
               name[]->puttext;
               ''' not checked.'->putline;
               'Must be checked by compiler before it can be shown...'->putline;
               
            else
               (if theDocument[]
                // none then
                   &OADDocument[]->myDocument[];
                   myDocument.new;
                   (if NoOfForms
                    // 1 then
                       myDocument.CurrentPage->myDocument.theWorkPage[];
                       'WorkSheet'->myDocument.theWorkPage.PageTitle;
                       &myDocument.OADPage[]->myDocument.theGroupPage[];
                       myDocument.theGroupPage.InvisibleNew;
                       myDocument.theWorkPage[]->myDocument.CurrentPage;
                       
                    else
                       myDocument.CurrentPage->myDocument.theGroupPage[];
                       myDocument[]->theDocument[]->theOADDocument[];
                       &myDocument.OADPage[]->myDocument.theWorkPage[];
                       myDocument.theWorkPage.InvisibleNew;
                       'WorkSheet'->myDocument.theWorkPage.PageTitle;
                       
                   if);
                   'Group Window'->myDocument.theGroupPage.PageTitle;
                   
                else
                   theDocument[]->myDocument[];
                   (if NoOfForms
                    // 1 then 
                    else
                       myDocument.theGroupPage.visible; 
                   if);
                   
               if);
               scanner:
               myDocument.theGroupPage.PatternDiagrams.theList.
                 scanPropertyDiagrams
                 (# 
                 do
                    (if fg.name->(thisDiagram.fullname).equal
                     // true then true->opened; leave scanner; 
                    if);
                    
                 #);
               (if opened
                // true then (* fragment already shown: just show the page *)
                   myDocument.theGroupPage[]->myDocument.CurrentPage; 
                else
                   (if switch[2]
                    // true then
                       'Scanning Properties'->putLine (*statusbar.set; *)
                   if);
                   &myDocument.theGroupPage.PropertyDiagram[]->propd[];
                   (fg[],true,name[]->mps.ExpandToFullPath)->propd.new;
                   &myDocument.theGroupPage.FragmentDiagram[]->fragd[];
                   (if switch[2]
                    // true then
                       'Scanning Fragments'->putLine (*statusbar.set; *)
                   if);
                   fg[]->fragd.new;
                   
               if);
               (if NoOfForms
                // 1 then
                   myDocument.theGroupPage.FragmentDiagram##
                     ->myDocument.theGroupPage.ScanDiagrams
                       (# 
                       do
                          current[]->fragd[];
                          (if fg[]
                           // fragd.theGroup then
                           (* find formname in the diagram *)
                              fragd.localnodes.scan (#  do current.detail #)
                          if)
                       #)
               if);
               
           if)
       if)
   if)
#)  

-- OpenFragmentForm: Descriptor --
(#
   index: @Integer;
   groupname,formname: ^Text;
   fg: ^mps.fragmentgroup;
   theDoc: ^OADDocument;
   theDiagram: ^theDoc.theGroupPage.FragmentDiagram;
   noOfForms: @integer;
   
do (* first open the group, and then open the form *)
   '-'->name.findCh (#  do inx->index;  #);
   (1,index-1)->name.sub->groupname[];
   groupname->openFragmentGroup->fg[];
   (index+1,name.length)->name.sub->formname[];
   fg.fragmentlist.scan
     (# 
     do
        (if current.type
         // mps.formtype then
            noofforms+1->noofforms;
            (if (current.f.name->formName.equal)
             // true then current.f[]->ff[]
            if)
        if)
     #);
   theDocument[]->theDoc[];
   theDoc.theGroupPage.FragmentDiagram##
     ->theDoc.TheGroupPage.ScanDiagrams
       (# 
       do
          current[]->theDiagram[];
          theDiagram.fullname->screen.putline;
          (if fg[]
           // theDiagram.theGroup then (* find formname in the diagram *)
              theDiagram.localnodes.scan
                (# t: ^text; 
                do
                   &Text[]->t[];
                   current.theText.get->t;
                   ':'->t.findCh (#  do inx->index #);
                   (1,index-1)->t.sub->t[];
                   se[]->current.theSifEditor;
                   (if (formname[]->t.equal) and (noOfForms > 1)
                    // true then
                    (* if noOfForms = 1 the form has already been opened 
                     * by openFragmentGroup
                     *)
                       current.detail; 
                   if)
                #)
          if)
       #)
#)  

-- autosave: Descriptor --
(#
   dummyFilter: ##external;
   filename,filename2: @Text;
   pageList: ^ObjectList;
   cancelled: ^integerRef;
   prompt: @text;
   count: @ShortRef;
   list: @IntegerRef
do
   sifAutoSave;
   (if currentDiagramName[] <> none then
       currentDiagramName->removeExtension->fileName;
       '.freja#'->fileName.Append;
       (if switch[17] then
           'Freja autosave:'->putLine; filename[]->putLine; 
       if);
       
    else
       'No currentDiagramName?'->putline
   if);
   SaveLists;
   (if currentDiagramName[] <> none then
       filename2.clear;
       currentDiagramName[]->filename2.puttext;
       '#'->filename2.append;
       (if switch[17] then
           'Freja autosave:'->putLine; filename2[]->putLine; 
       if);
       (count[],list[])->DSStrGetPageList;
       &integerRef[]->cancelled[];
       ' '->prompt.puttext;
       (@@ filename2.T[1],false,cancelled[],true,count,list,dummyFilter##,
        prompt)->DSFileSavePagesAsDiagram
    else
       'Autosave: No current diagram??'->putline
   if)
#)  

-- checkAutoSaveFile: Descriptor --
(#
   frejaFile,autosaveFrejaFile,diagFile,autosaveDiagFile: @file;
   groupFile,autosaveGroupFile: @file;
   ok,doRecover,doNotRecover: @boolean;
   groupName,frejaFileName,autosaveFrejaFileName,diagFileName: ^text
do
   name[]->diagFileName[]->diagFile.name;
   '#'->name.copyAppend->autosaveDiagFile.name;
   name.copy->groupName[];
   groupName->removeExtension->groupName;
   '.freja'->groupName.copyAppend->frejaFileName[]->frejafile.name;
   '.freja#'->groupName.copyAppend->autoSaveFrejaFileName[]
     ->autosavefrejafile.name;
   (if switch[17] then
       'Freja checkAutoSaveFile:'->putLine;
       diagFile.name->putLine;
       autosaveDiagFile.name->putLine;
       frejaFile.name->putLine;
       autosaveFrejaFile.name->putLine;
       
   if);
   (if autosaveFrejaFile.entry.exists then
       (if FrejaFile.entry.exists then
           (if autosaveFrejaFile.entry.modtime > FrejaFile.entry.modtime then
               'Autosave file is newer, recover?'->DSUIGetUserYesOrNo->ok;
               (if OK then
                   'mv .freja# .freja'->putLine;
                   FrejaFile.name->autoSaveFrejaFile.entry.rename;
                   true->doRecover;
                   
                else
               (* no not anymore
                (if tildeFrejaFile.entry.exists then
                *)
                   'rm .freja#'->putLine;
                   autosaveFrejaFile.delete;
                   (* no not anymore 
                    'mv .freja~ .freja'->putLine;
                    FrejaFile.name->tildeFrejaFile.entry.rename;
                    *)
                   true
                     ->doNotRecover
                     (* else
                      '.freja~ does not exist!!'->putLine
                      if);*)
               if)
           if)
        else
           'no .freja file?!'->putLine;
           'No .diag file, recover from Autosave file?'->DSUIGetUserYesOrNo->ok;
           (if OK then
               'mv .freja# .freja'->putLine;
               FrejaFile.name->autoSaveFrejaFile.entry.rename;
               true->doRecover;
               
           if)
       if);
       
    else
       (if switch[17] then 'no .freja# file'->putLine if)
   if);
   (if doRecover then
       name->recoverDiagFile; true->didRecover; 
    else
       (if doNotRecover then
           (if autosaveDiagFile.entry.exists and diagFile.entry.exists then
               (if autosaveDiagFile.entry.modtime > diagFile.entry.modtime then
                   'rm .diag#'->putLine; autosaveDiagFile.delete
                else
                   'autosaveDiagFile.entry.modtime IS NOT > diagFile.entry.modtime'
                     ->putLine;
                   
               if);
               frejaFileName
                 ->scanAstFiles
                   (# 
                   do
                      currentGroupName->groupName;
                      '.ast'->groupName.append;
                      groupName[]->groupFile.name;
                      '#'->groupName.copyAppend->autosaveGroupFile.name;
                      (*'~'->groupName.copyAppend->tildeGroupFile.name;*)
                      (if switch[17] then
                          groupFile.name->putLine;
                          autosaveGroupFile.name->putLine;
                          (* tildeGroupFile.name->putLine*)
                          
                      if);
                      (if groupFile.entry.exists then
                      (* no not anymore 
                       (if tildeGroupFile.entry.exists then
                       (if switch[17] then
                       tildeGroupFile.name->putText;
                       ': '->putText;
                       tildeGroupFile.entry.modtime->putInt;
                       newLine
                       if);
                       'mv .ast~ .ast'->putLine;
                       groupFile.name
                       ->tildeGroupFile.entry.rename
                       
                       if);
                       *)
                          (if autoSaveGroupFile.entry.exists then
                              'rm .ast#'->putLine; autosaveGroupFile.delete
                          if)
                      if)
                   #)
           if)
       if)
   if)
#)  

-- checkDiagFile: Descriptor --
(#
   diagFile,frejaFile,groupFile,betFile: @file;
   groupName,frejaFileName,help: ^text;
   tryRevert,doOpen: @boolean
do
   thisOperation:
     (# 
     do
        true->OK;
        'Consistency check failed!'->help[];
        help.newLine;
        name[]->diagFile.name;
        (if switch[17] then
            'Freja checkDiagFile:'->putLine;
            diagFile.name->putLine;
            'fromRecovery: '->putText;
            fromRecovery->putInt;
            newlIne;
            
        if);
        (if diagFile.entry.exists then
            name.copy->groupName[];
            groupName->removeExtension->groupName;
            '.freja'->groupName.copyAppend->frejaFileName[]->frejafile.name;
            (if frejafile.entry.exists then
                scanning:
                frejaFileName
                  ->scanAstFiles
                    (# 
                    do
                       currentGroupName->groupName;
                       '.bet'->groupName.copyAppend->betFile.name;
                       '.ast'->groupName.append;
                       groupName[]->groupFile.name;
                       (if groupFile.entry.exists then
                       (* no we cannot be sure of that 
                        (if groupFile.entry.modtime > diagFile.entry.modtime then
                        groupFile.name->help.putLine; help.newLine;
                        'is newer than'->help.putLine; help.newLine;
                        diagFile.name->help.putText;
                        help->gppAlert;
                        false->OK
                        if)*)
                           (if groupFile.entry.modtime <> currentModTime then
                               groupFile.name->help.putLine;
                               'is inconsistent with'->help.putLine;
                               diagFile.name->help.putLine;
                               help[]->putline;
                               false->OK;
                               'modtime of .ast file: '->putText;
                               groupFile.entry.modtime->putInt;
                               newLine;
                               'expected modtime: '->putText;
                               currentModtime->putInt;
                               newLine;
                               (if fromRecovery then
                                   (if canTryRevert then true->tryRevert if)
                                else
                                   'Open .ast or .bet file instead?'
                                     ->help.putText;
                                   help->DSUIGetUserYesOrNo->doOpen;
                                   (if doOpen then
                                       groupname->removeExtension->groupname;
                                       (if currentDiagramName[] = none then
                                           groupName.copy->currentDiagramName[];
                                           '.diag'->currentDiagramName.append
                                       if);
                                       groupName->openFragmentGroup
                                   if)
                               if);
                               leave scanning
                           if)
                        else
                           groupFile.name->help.putLine;
                           'does not exist'->help.putLine;
                           (if betFile.entry.exists then
                               'Open .bet file instead?'->help.putLine;
                               help->DSUIGetUserYesOrNo->doOpen;
                               (if doOpen then
                                   groupname->removeExtension->groupname;
                                   (if currentDiagramName[] = none then
                                       groupName.copy->currentDiagramName[];
                                       '.diag'->currentDiagramName.append
                                   if);
                                   groupName->openFragmentGroup
                               if)
                            else
                               help->gppAlert
                           if);
                           help[]->putLine;
                           false->OK
                       if);
                       (if OK and betFile.entry.exists then
                           (if betFile.entry.modtime > diagFile.entry.modtime
                            then
                               betFile.name->help.putLine;
                               'is newer than'->help.putLine;
                               diagFile.name->help.putLine;
                               'Open .bet file instead?'->help.putText;
                               (if not fromRecovery then
                                   help->DSUIGetUserYesOrNo->doOpen;
                                   (if doOpen then
                                       groupname->removeExtension->groupname;
                                       (if currentDiagramName[] = none then
                                           groupName.copy->currentDiagramName[];
                                           '.diag'->currentDiagramName.append
                                       if);
                                       groupName->openFragmentGroup
                                   if)
                               if);
                               help[]->putLine;
                               false->OK
                           if)
                       if);
                       (if OK and groupFile.entry.exists and
                       betFile.entry.exists then
                           (if betFile.entry.modtime > groupFile.entry.modtime
                            then
                               betFile.name->help.putLine;
                               'is newer than'->help.putLine;
                               groupFile.name->help.putLine;
                               'Open .bet file instead?'->help.putText;
                               (if not fromRecovery then
                                   help->DSUIGetUserYesOrNo->doOpen;
                                   (if doOpen then
                                       groupname->removeExtension->groupname;
                                       (if currentDiagramName[] = none then
                                           groupName.copy->currentDiagramName[];
                                           '.diag'->currentDiagramName.append
                                       if);
                                       groupName->openFragmentGroup
                                   if)
                               if);
                               help[]->putLine;
                               false->OK
                           if)
                       if)
                    #)
             else
                frejaFile.name->help.putLine;
                ' does not exist'->help.putLine;
                false->OK;
                'Open .ast or .bet file instead?'->help.putText;
                help->DSUIGetUserYesOrNo->doOpen;
                (if doOpen then
                    groupname->removeExtension->groupname;
                    (if currentDiagramName[] = none then
                        groupName.copy->currentDiagramName[];
                        '.diag'->currentDiagramName.append
                    if);
                    groupName->openFragmentGroup
                if);
                help[]->putLine;
                false->OK
            if)
         else
            diagFile.name->putText; ' does not exist!!'->putLine
        if)
     #);
   (if tryRevert then 'tryRevert'->putLIne; (name,true)->revert if)
#)  

-- revert: Descriptor --
(#
   ok: @Boolean;
   frejaFile,autosaveFrejaFile,tildeFrejaFile,diagFile,autosaveDiagFile,
     tildeDiagFile: @file;
   groupFile,autosaveGroupFile,tildeGroupFile: @file;
   groupName,frejaFileName,autoSaveFrejaFileName,tildeFrejaFileName,help: ^text
do
   thisOperation:
     (# 
     do
        name[]->diagFile.name;
        '#'->name.copyAppend->autosaveDiagFile.name;
        '~'->name.copyAppend->tildeDiagFile.name;
        (if switch[17] then
            'Freja revert:'->putLine;
            diagFile.name->putLine;
            autosaveDiagFile.name->putLine;
            tildeDiagFile.name->putLine
        if);
        (if badRecovery then
            'Revert to latest saved diagram?'->DSUIGetUserYesOrNo->ok
         else
            true->ok
        if);
        (if ok then
            name.copy->groupName[];
            groupName->removeExtension->groupName;
            '.freja'->groupName.copyAppend->frejaFileName[]->frejaFile.name;
            '.freja#'->groupName.copyAppend->autosaveFrejaFileName[]
              ->autosaveFrejaFile.name;
            '.freja~'->groupName.copyAppend->tildeFrejaFileName[]
              ->tildeFrejaFile.name;
            (if badRecovery then
                (if tildeFrejaFile.entry.exists then
                    (if tildeDiagFile.entry.exists then
                        'mv .diag~ .diag'->putLine;
                        diagFile.name
                          ->
                            tildeDiagFile.entry.rename
                            (* frejaFile.name->tildeFrejaFile.entry.rename *)
                     else
                        'No .diag~ file!!'->putLine; leave thisOperation
                    if);
                    tildeFrejaFileName
                      ->scanAstFiles
                        (# 
                        do
                           currentGroupName->groupName;
                           '.ast'->groupName.append;
                           groupName[]->groupFile.name;
                           '~'->groupName.copyAppend->tildeGroupFile.name;
                           (if switch[17] then
                               groupName[]->putLine;
                               tildeGroupFile.name->putLine
                           if);
                           (if tildeGroupFile.entry.exists and
                           groupFile.entry.exists then
                               'mv .ast~ .ast'->putLine;
                               groupFile.name->tildeGroupFile.entry.rename
                           if)
                        #);
                    'mv .freja~ .freja'->putLine;
                    frejaFile.name->tildeFrejaFile.entry.rename;
                    name->openDiagram
                 else
                    'No .freja~ file!!'->putLine
                if)
             else
                (if autosaveFrejaFile.entry.exists then
                    autosaveFrejaFileName
                      ->scanAstFiles
                        (# 
                        do
                           currentGroupName->groupName;
                           '.ast'->groupName.append;
                           groupName[]->groupFile.name;
                           '#'->groupName.copyAppend->autosaveGroupFile.name;
                           '~'->groupName.copyAppend->tildeGroupFile.name;
                           (if switch[17] then
                               groupName[]->putLine;
                               autosaveGroupFile.name->putLine;
                               tildeGroupFile.name->putLine
                           if);
                           (if autosaveGroupFile.entry.exists then
                               'rm .ast#'->putLine; autosaveGroupFile.delete
                           if);
                           (if tildeGroupFile.entry.exists and
                           groupFile.entry.exists then
                               'mv .ast~ .ast'->putLine;
                               groupFile.name->tildeGroupFile.entry.rename
                           if)
                        #);
                    (if tildeFrejaFile.entry.exists then
                        'mv .freja~ .freja'->putLine;
                        frejaFile.name->tildeFrejaFile.entry.rename
                     else
                        'No .freja~ file!!'->putLine
                    if);
                    (if autosaveDiagFile.entry.exists then
                        'rm .diag#'->putLine; autoSaveDiagFile.delete
                    if);
                    'rm .freja#'->putLine;
                    autosaveFrejaFile.delete;
                    closeDiagram;
                    name->openDiagram
                if)
            if)
        if)
     #)
#)
(*
 -- FrejaOptionsMenuInit: Descriptor --
 (#  do (UserMenu3+13,'With Dexter')->WithDexterItem.init;  #)  
 
 -- FrejaOptionsMenuCheckMarks: Descriptor --
 (#  do withDexter->WithDexterItem.check #)  
 *)  

-- recoverDiagFile: DoPart --
do
     (#
        diagFile,autosaveDiagFile,groupFile,autosaveGroupFile: @file;
        groupName,frejaFileName,diagFileName: ^text
     do
        name[]->diagFileName[]->diagFile.name;
        '#'->name.copyAppend->autosaveDiagFile.name;
        name.copy->groupName[];
        groupName->removeExtension->groupName;
        '.freja'->groupName.copyAppend->frejaFileName[];
        (if autosaveDiagFile.entry.exists and diagFile.entry.exists then
            (if autosaveDiagFile.entry.modtime > diagFile.entry.modtime then
            (* no not any more
             'mv .diag .diag~'->putLine;
             tildeDiagFileName[]->diagFile.entry.rename;
             *)
                'mv .diag# .diag'->putLine;
                diagFileName[]->autoSaveDiagFile.entry.rename
             else
                'autosaveDiagFile.entry.modtime IS NOT > diagFile.entry.modtime'
                  ->putLine;
                
            if);
            frejaFileName
              ->scanAstFiles
                (# 
                do
                   currentGroupName->groupName;
                   '.ast'->groupName.append;
                   groupName[]->groupFile.name;
                   '#'->groupName.copyAppend->autosaveGroupFile.name;
                   (if switch[17] then
                       groupFile.name->putLine; autosaveGroupFile.name->putLine
                   if);
                   (if groupFile.entry.exists then
                       (if autosaveGroupFile.entry.exists then
                           (if switch[17] then
                               groupFile.name->putText;
                               ': '->putText;
                               groupFile.entry.modtime->putInt;
                               newLine;
                               autosaveGroupFile.name->putText;
                               ': '->putText;
                               autosaveGroupFile.entry.modtime->putInt;
                               newLine
                           if);
                           (if autosaveGroupFile.entry.modtime >
                           groupFile.entry.modtime then
                               'mv .ast# .ast'->putLine;
                               groupFile.name->autoSaveGroupFile.entry.rename
                            else
                               'autosaveGroupFile.entry.modtime IS NOT > groupFile.entry.modtime'
                                 ->putLine;
                               
                           if)
                       if)
                    else
                       
                   if)
                #)
         else
            (if autosaveDiagFile.entry.exists then
                'mv .diag# .diag'->putLine;
                diagFileName[]->autoSaveDiagFile.entry.rename;
                frejaFileName
                  ->scanAstFiles
                    (# 
                    do
                       currentGroupName->groupName;
                       '.ast'->groupName.append;
                       groupName[]->groupFile.name;
                       '#'->groupName.copyAppend->autosaveGroupFile.name;
                       (if switch[17] then
                           groupFile.name->putLine;
                           autosaveGroupFile.name->putLine
                       if);
                       (if groupFile.entry.exists then
                           (if autosaveGroupFile.entry.exists then
                               (if switch[17] then
                                   groupFile.name->putText;
                                   ': '->putText;
                                   groupFile.entry.modtime->putInt;
                                   newLine;
                                   autosaveGroupFile.name->putText;
                                   ': '->putText;
                                   autosaveGroupFile.entry.modtime->putInt;
                                   newLine
                               if);
                               (if autosaveGroupFile.entry.modtime >
                               groupFile.entry.modtime then
                                   'mv .ast# .ast'->putLine;
                                   groupFile.name
                                     ->autoSaveGroupFile.entry.rename
                                else
                                   'autosaveGroupFile.entry.modtime IS NOT > groupFile.entry.modtime'
                                     ->putLine;
                                   
                               if)
                           if)
                        else
                           
                       if)
                    #)
            if)
        if)
     #)  

-- scanASTfiles: Descriptor --
(# f: @file; t: ^Text
do
   name[]->f.name;
   (if f.entry.exists then
       f.openRead;
       loop:
         (# 
         do
            (if not f.eos then
                f.getLine->t[];
                (if t[] = none then leave loop if);
                t.reset;
                t.getAtom->currentGroupName[];
                f.getline->t[];
                (if t[] = none then leave loop if);
                t.reset;
                t.getInt->currentModTime;
                INNER scanASTfiles;
                restart loop
            if)
         #);
       f.close
    else
       name.copy->t[]; ' does not exist'->t.append; t->DSUIUserAckMessage
   if)
#)  

-- makeFrejaFile: Descriptor --
(#
   f: @file;
   fileName: @Text;
   groupFile,recoveryGroupFile: @file;
   lastChar: @char;
   help: @text;
   fd: ^theOADDocument.theGroupPage.FragmentDiagram;
   theListDiagram: ^theOADDocument.theGroupPage.ListDiagram;
   dirWriteable: (# f: @file enter f.name exit f.entry.writeable #)
do
   l:
   (if name[] <> none then
       name[]->f.name;
       (if switch[17] then
           'Freja makeFrejaFile:'->putLine; f.name->putLine; 
       if);
       (if (f.entry.path.head->dirWriteable)
        // true then
           (if f.entry.writeable
            // true then f.openWrite
            else
                 (# t: @text
                 do
                    'No write access to the file: "'->t;
                    f.name->t.append;
                    '"'->t.putline;
                    t[]->alertUser;
                    leave l
                 #)
           if)
        else
             (# t: @text
             do
                'No write access to the directory: "'->t;
                f.entry.path.head->t.append;
                '"'->t.putline;
                t[]->alertUser;
                leave l
             #)
       if);
       theDocument[]->theOADDocument[];
       (if theOADDocument[] = none then
           'theOADDocument[] is none'->putLine
        else
           (if theOADDocument.theGroupPage[] = none then
               'theOADDocument.theGroupPage[] is none'->putLine
            else
               (if theOADDocument.theGroupPage.patternDiagrams[] = none then
                   'theOADDocument.theGroupPage.patternDiagrams[] is none'
                     ->putLine
                else
                   (if theOADDocument.theGroupPage.patternDiagrams.theList[] =
                   none then
                       'theOADDocument.theGroupPage.patternDiagrams.theList[] is none'
                         ->putLine
                    else
                       theOADDocument.theGroupPage.PatternDiagrams.theList.scan
                         (# 
                         do
                            current.e[]->theListDiagram[];
                            (if theListDiagram## <=
                            theOADDocument.theGroupPage.fragmentDiagram## then
                                theListDiagram[]->fd[];
                                fd.fullname->f.putline;
                                name.length->name.inxGet->lastChar;
                                (if (lastChar = '#') or (lastChar = '~') then
                                    (if switch[17] then
                                        'it is a recovery file'->putLine
                                    if);
                                    help.clear;
                                    lastChar->help.put;
                                    help[]
                                      ->((fd.theGroup).diskFileName).copyAppend
                                      ->recoveryGroupFile.name;
                                    (if recoveryGroupFile.entry.exists then
                                        recoveryGroupFile.entry.modtime
                                          ->f.putInt;
                                        (if switch[17] then
                                            fd.fullname->putline;
                                            recoveryGroupFile.entry.modtime
                                              ->putint;
                                            ' '->putline;
                                            
                                        if);
                                        
                                     else
                                        (if lastChar = '#' then
                                            (fd.theGroup).diskFileName
                                              ->groupFile.name;
                                            (if switch[17] then
                                                fd.fullname->putline;
                                                '(fd.theGroup).modtime: '
                                                  ->putText;
                                                (fd.theGroup).modtime->putint;
                                                ' '->putline;
                                                
                                            if);
                                            (if groupFile.entry.exists then
                                                (if switch[17] then
                                                    'groupFile.entry.modtime: '
                                                      ->putText;
                                                    groupFile.entry.modtime
                                                      ->putInt;
                                                    newLine
                                                if);
                                                groupFile.entry.modtime
                                                  ->f.putInt;
                                                
                                             else
                                                'No group file!!'->putLine
                                            if)
                                         else
                                            'No recoveryGroupFile: '->putText;
                                            recoveryGroupFile.name->putLine;
                                            'Should not happen!!'->putLine
                                        if)
                                    if)
                                 else
                                    (fd.theGroup).diskFileName->groupFile.name;
                                    (if switch[17] then
                                        fd.fullname->putline;
                                        '(fd.theGroup).modtime: '->putText;
                                        (fd.theGroup).modtime->putint;
                                        ' '->putline;
                                        
                                    if);
                                    (* (fd.theGroup).modtime->f.putint;*)
                                    (if groupFile.entry.exists then
                                        (if switch[17] then
                                            'groupFile.entry.modtime: '
                                              ->putText;
                                            groupFile.entry.modtime->putInt;
                                            newLine
                                        if);
                                        groupFile.entry.modtime->f.putInt;
                                        
                                     else
                                        'No group file!!'->putLine
                                    if)
                                if);
                                ' '->f.putline
                            if)
                         #)
                   if)
               if)
           if)
       if);
       f.close
    else
       'makeFrejaFile: name is none!!'->putline
   if)
#)  

-- openDiagram: Descriptor --
(#
   count: @ShortRef;
   list: @IntegerRef;
   pages,nodes,conns,regions: [0] @Integer;
   thePage: ^theDocument.Page;
   theOADPage: ^theOADDocument.OADPage;
   theObject: ^thePage.DesignObject;
   theConnID: @integer;
   num,w,h,vis: @IntegerRef;
   nameStr: [64] @char;
   t: @text;
   
do
   name[]->currentDiagramName[];
   'Loading '->puttext;
   name[]->putline;
   (@@ name.T[1])->DSFileOpenDiagram;
   &OADDocument[]->theDocument[]->theOADDocument[];
   theDocument.onInit;
   (count[],list[])->DSStrGetPageList;
   (count,list)->GetIntList->pages;
   (if pages.range > 0 then
       (for i: pages.range repeat
         (if i = 1 then
             &theOADDocument.OADPage[]
               ->thePage[] (* ->theOADDocument.theGroupPage[];*)
          else
             &theOADDocument.OADPage[]
               ->thePage[] (*->theOADDocument.theWorkPage[];*)
         if)
         (* toby 24-11-94: VERY temporary hack (i hope)!!*)
         ;
         (if (pages[i],@@ nameStr[1],num[],w[],h[],vis[])->DSRdAttrGetPageAttr
          // true then @@ nameStr[1]->cStringToCharRep->t; 
          else
             'Could not read page name before initialization'->putline
         if);
         (if 'Group Window'->t.equal then
             thePage[]->theOADDocument.theGroupPage[]
          else
             thePage[]->theOADDocument.theWorkPage[]
         if);
         pages[i]->thePage.onInit;
         true->thePage.PageCallBack.specialNode;
         thePage.onReadDiagram;
         
       for);
       theOADDocument.theWorkPage[]->theDocument.CurrentPage;
       theOADDocument.updateUserDataIDs;
       loop
         (#
            i: @integer;
            while::<  (#  do (i+2 <= IndexIDList.impl.range)->value #)
         do
            i+2->i;
            (if IndexIDList.impl[i] <> 0 then
                (if userDataVerbose then
                    'IndexIDList: updating '->puttext;
                    indexidlist.impl[i]->putint
                if);
                IndexIDList.impl[i]->theOADDocument.UserDataIDMap.getID
                  ->IndexIDList.impl[i];
                (if userDataVerbose then
                    ' to '->puttext; indexidlist.impl[i]->putint; newline
                if)
            if)
         #);
       theOADDocument.theWorkPage.PatternDiagrams.theList.scan
         (# theListDiagram: ^theOADDocument.theWorkPage.ListDiagram
         do
            current.e[]->theListDiagram[];
            theListDiagram[]
              ->theOADDocument.theWorkPage.PageCallBack.MakeLocalNodes;
            theListDiagram.titleNode.thePrefixConn.getID->theConnID;
            (if theConnID <> 0 then
                (theListDiagram[],theConnID)
                  ->theOADDocument.theWorkPage.PageCallBack.MakeConn
            if);
            theListDiagram.titleNode.thesimplePrefixConn.getID->theConnID;
            (if theConnID <> 0 then
                (theListDiagram[],theConnID)
                  ->theOADDocument.theWorkPage.PageCallBack.MakeConn
            if)
         #);
       theOADDocument.theGroupPage.PatternDiagrams.theList.scan
         (# theListDiagram: ^theOADDocument.theGroupPage.ListDiagram
         do
            current.e[]->theListDiagram[];
            theListDiagram[]
              ->theOADDocument.theGroupPage.PageCallBack.MakeLocalNodes;
            theListDiagram.titleNode.thePrefixConn.getID->theConnID;
            (if theConnID <> 0 then
                (theListDiagram[],theConnID)
                  ->theOADDocument.theGroupPage.PageCallBack.MakeConn
            if);
            theListDiagram.titleNode.theSimplePrefixConn.getID->theConnID;
            (if theConnID <> 0 then
                (theListDiagram[],theConnID)
                  ->theOADDocument.theWorkPage.PageCallBack.MakeConn
            if)
         #);
       theOADDocument.theWorkPage.PatternDiagrams.theList.scan
         (#
            theListDiagram: ^theOADDocument.theWorkPage.ListDiagram;
            thisOADDiagram: ^theOADDocument.theWorkPage.OADDiagram;
            thisFragmentDiagram: ^theOADDocument.theWorkPage.FragmentDiagram;
            theDummyDesc: ^betaGram.ObjectDescriptor;
            thisPatternAttDiagram:
              ^theOADDocument.theWorkPage.PatternAttDiagram;
            theDummyAST: ^MPS.AST
         do
            current.e[]->theListDiagram[];
            (if current.e.struc <= theOADDocument.theWorkPage.OADDiagram##
             // true then
                current.e[]->thisOADDiagram[];
                thisOADDiagram.titlenode.theText.get->thisOADDiagram.titleText;
                (if thisOADDiagram.theDescriptor <> none then
                    thisOADDiagram.theDescriptor->theDummyDesc[];
                    theDummyDesc.index->current.index;
                    (if thisOADDiagram## <=
                    theOADDocument.theWorkPage.PatternAttDiagram## then
                        thisOADDiagram[]->thisPatternAttDiagram[];
                        thisPatternAttDiagram.theAST->theDummyAST[];
                        theDummyAST.index->current.index
                    if)
                if);
                
            if);
            (if current.e.struc <= theOADDocument.theWorkPage.FragmentDiagram##
             then
                current.e[]->thisFragmentDiagram[];
                thisFragmentDiagram.titlenode.theText.get
                  ->thisFragmentDiagram.titleText
            if)
         #);
       theOADDocument.theGroupPage.PatternDiagrams.theList.scan
         (#
            theListDiagram: ^theOADDocument.theGroupPage.ListDiagram;
            thisOADDiagram: ^theOADDocument.theGroupPage.OADDiagram;
            thisFragmentDiagram: ^theOADDocument.theGroupPage.FragmentDiagram;
            thePropertyDiagram: ^theOADDocument.theGroupPage.PropertyDiagram;
            theDummyDesc: ^betaGram.ObjectDescriptor;
            thisPatternAttDiagram:
              ^theOADDocument.theGroupPage.PatternAttDiagram;
            theDummyAST: ^MPS.AST;
            theNodeID: @integer
         do
            current.e[]->theListDiagram[];
            (if current.e.struc <= theOADDocument.theGroupPage.OADDiagram##
             // true then
                current.e[]->thisOADDiagram[];
                thisOADDiagram.titlenode.theText.get->thisOADDiagram.titleText;
                (if thisOADDiagram.theDescriptor <> none then
                    thisOADDiagram.theDescriptor->theDummyDesc[];
                    theDummyDesc.index->current.index;
                    (if thisOADDiagram## <=
                    theOADDocument.theGroupPage.PatternAttDiagram## then
                        thisOADDiagram[]->thisPatternAttDiagram[];
                        thisPatternAttDiagram.theAST->theDummyAST[];
                        theDummyAST.index->current.index
                    if)
                if);
                (if thisOADDiagram## <=
                theOADDocument.theGroupPage.propertyDiagram## then
                    thisOADDiagram[]->thePropertyDiagram[];
                    thePropertyDiagram.titleNode.UDSurroundBox.getID->theNodeID;
                    (if theNodeID <> 0 then
                        (thePropertyDiagram[],theNodeID)
                          ->
                            theOADDocument.theGroupPage.pageCallback.
                              makeSurroundBox
                    if)
                if);
                
            if);
            (if current.e.struc <= theOADDocument.theGroupPage.FragmentDiagram##
             then
                current.e[]->thisFragmentDiagram[];
                thisFragmentDiagram.titlenode.theText.get
                  ->thisFragmentDiagram.titleText
            if)
         #)
    else
       'The selected .diag file does not have the right file format!'
         ->DSUIUserAckMessage
   if)
#)  

-- closeDiagram: Descriptor --
(#
   CheckMenu:
     (# theID: @Integer; theMenu: ^BasicMenu; 
     enter theID
     do
        theID->MenuBar.findMenu->theMenu[];
        (if theMenu[] <> none then
            theMenu[]->MenuBar.remove; theID->DSMenuDeleteMenu
        if);
        
     #);
   pages: ^ObjectList
do
   UserMenu1->CheckMenu;
   UserMenu2->CheckMenu;
   (* UserMenu3 is the fileMenu - do not remove! *)
   UserMenu4->CheckMenu;
   UserMenu5->CheckMenu;
   UserMenu6->CheckMenu;
   UserMenu7->CheckMenu;
   UserMenu8->CheckMenu;
   UserMenu9->CheckMenu;
   UserMenu10->CheckMenu;
   DSMenuShowMenuBar;
   theDocument.GetPages->pages[];
   (if pages[]
    // none then 
    else
       pages.scan
         (# dummy: ^theDocument.Page
         do
            current[]->dummy[];
            (if dummy[]
             // none then 'CloseItem: Page is node'->putline; 
             else
                dummy.close
            if);
            
         #);
       
   if);
   theDocument.close
#)  

-- SaveLists: Descriptor --
(#
   theListDiagram: ^theOADDocument.theWorkPage.ListDiagram;
   fd: ^theOADDocument.theGroupPage.FragmentDiagram;
   theReference: ^theListDiagram.titleNode.PatternDiagNodeReference;
   ok: @Boolean;
   listsize,last,showAttributesInteger,referencesInteger,specializationsInteger,
     associationsInteger,SimpleDeclDisplayInteger,x,y,w,h: @integer;
   fileName: @text
do
   theDocument[]->theOADDocument[];
   theOADDocument.theWorkPage.PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->theListDiagram[];
        theOADDocument.localNodesUserDataStart+theListDiagram.localNodes.size
          ->theListDiagram.titleNode.OldLocalNodesUDAttributes;
        theListDiagram.titleNode.resetLocalNodesUD
     #);
   theOADDocument.theGroupPage.PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->theListDiagram[];
        theOADDocument.localNodesUserDataStart+theListDiagram.localNodes.size
          ->theListDiagram.titleNode.OldLocalNodesUDAttributes;
        theListDiagram.titleNode.resetLocalNodesUD
     #);
   theOADDocument.theWorkPage.PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->theListDiagram[];
        theListDiagram.localNodes.scan
          (# 
          do
             &theListDiagram.titleNode.PatternDiagNodeReference[]
               ->theReference[];
             theReference.InitLocalNode;
             current[]->theReference;
             
          #)
     #);
   theOADDocument.theGroupPage.PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->theListDiagram[];
        theListDiagram.localNodes.scan
          (# 
          do
             &theListDiagram.titleNode.PatternDiagNodeReference[]
               ->theReference[];
             theReference.InitLocalNode;
             current[]->theReference;
             
          #)
     #);
   (theOADDocument.theGroupPage.ID,499,@@ listsize)->UDReadType->ok;
   (if ok then
       (for i: listsize repeat
         (theOADDocument.theGroupPage.ID,500+i)->UDDeleteType->ok;
         (if ok then
             (if userDataVerbose then
                 'For id '->puttext;
                 theOADDocument.theGroupPage.ID->putint;
                 ' and attributeID '->puttext;
                 500+i->putint;
                 ' delete IndexIDList userdata succeed'->putline
             if)
          else
             (if userDataVerbose then
                 'For id '->puttext;
                 theOADDocument.theGroupPage.ID->putint;
                 ' and attributeID '->puttext;
                 500+i->putint;
                 ' delete IndexIDList userdata fail'->putline
             if)
         if)
       for)
    else
       (if userDataVerbose then 'listsize read fail'->putline if)
   if);
   IndexIDList.impl.range->listsize;
   (theOADDocument.theGroupPage.ID,499,@@ listsize,4)->UDWriteType->ok;
   (if ok then
       (if userDataVerbose then
           'Write IndexIDList.impl.range succeed: '->puttext;
           listsize->putint;
           newline
       if);
       IndexIDList.last->last;
       (theOADDocument.theGroupPage.ID,500,@@ last,4)->UDWriteType->ok;
       (if ok then
           (if userDataVerbose then
               'Write IndexIDList.last succeed: '->puttext;
               last->putint;
               newline
           if);
           (for i: listsize repeat
             (theOADDocument.theGroupPage.ID,500+i,@@ IndexIDList.impl[i],4)
               ->UDWriteType->ok;
             (if ok then
                 (if userDataVerbose then
                     'Write IndexIDList succeed: '->puttext;
                     'element no '->puttext;
                     i->putint;
                     'element '->puttext;
                     IndexIDList.impl[i]->putint;
                     newline
                 if)
              else
                 (if userDataVerbose then
                     'Write IndexIDList fail: '->puttext
                 if)
             if)
           for)
        else
           (if userDataVerbose then
               'Write IndexIDList.last fail: '->puttext
           if)
       if)
    else
       (if userDataVerbose then
           'Write IndexIDList.impl.range fail: '->puttext
       if)
   if);
   theOADDocument.theWorkPage.patternDiagrams.AssociationList.save;
   theOADDocument.theWorkPage.patternDiagrams.InheritanceList.save;
   theOADDocument.theWorkPage.patternDiagrams.DynReferenceList.save;
   (theOADDocument.theWorkPage.ID,240,@@ theOADDocument.theWorkPage.nextX,4)
     ->UDWriteType->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextX succeed'->putline
        else
           'Write NextX fail'->putline
       if)
   if);
   (theOADDocument.theWorkPage.ID,241,@@ theOADDocument.theWorkPage.nextY,4)
     ->UDWriteType->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextY succeed'->putline
        else
           'Write NextY fail'->putline
       if)
   if);
   (theOADDocument.theWorkPage.ID,250,@@
    theOADDocument.theWorkPage.patternDiagrams.NextFreeLine,4)->UDWriteType->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextFreeLine succeed'->putline
        else
           'Write NextFreeLine fail'->putline
       if)
   if);
   (theOADDocument.theWorkPage.ID,251,@@
    theOADDocument.theWorkPage.patternDiagrams.NextFreeColumn,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextFreeColumn succeed'->putline
        else
           'Write NextFreeColumn fail'->putline
       if)
   if);
   (theOADDocument.theWorkPage.ID,252,@@
    theOADDocument.theWorkPage.patternDiagrams.SecondFreeLine,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write SecondFreeLine succeed'->putline
        else
           'Write SecondFreeLine fail'->putline
       if)
   if);
   (theOADDocument.theWorkPage.ID,253,@@
    theOADDocument.theWorkPage.patternDiagrams.SecondFreeColumn,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write SecondFreeColumn succeed'->putline
        else
           'Write SecondFreeColumn fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,240,@@ theOADDocument.theGroupPage.nextX,4)
     ->UDWriteType->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextX succeed'->putline
        else
           'Write NextX fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,241,@@ theOADDocument.theGroupPage.nextY,4)
     ->UDWriteType->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextY succeed'->putline
        else
           'Write NextY fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,250,@@
    theOADDocument.theGroupPage.patternDiagrams.NextFreeLine,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextFreeLine succeed'->putline
        else
           'Write NextFreeLine fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,251,@@
    theOADDocument.theGroupPage.patternDiagrams.NextFreeColumn,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextFreeColumn succeed'->putline
        else
           'Write NextFreeColumn fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,252,@@
    theOADDocument.theGroupPage.patternDiagrams.SecondFreeLine,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write SecondFreeLine succeed'->putline
        else
           'Write SecondFreeLine fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,253,@@
    theOADDocument.theGroupPage.patternDiagrams.SecondFreeColumn,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write SecondFreeColumn succeed'->putline
        else
           'Write SecondFreeColumn fail'->putline
       if)
   if);
   (if theOADDocument.gppProp.showAttributes then
       1->showAttributesInteger
    else
       0->showAttributesInteger
   if);
   (theOADDocument.theGroupPage.ID,260,@@ showAttributesInteger,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write showAttributes succeed'->putline
        else
           'Write showAttributes fail'->putline
       if)
   if);
   (if theOADDocument.gppProp.references then
       1->referencesInteger
    else
       0->referencesInteger
   if);
   (theOADDocument.theGroupPage.ID,261,@@ referencesInteger,4)->UDWriteType->ok;
   (if userDataVerbose then
       (if ok then
           'Write references succeed'->putline
        else
           'Write references fail'->putline
       if)
   if);
   (if theOADDocument.gppProp.specializations then
       1->specializationsInteger
    else
       0->specializationsInteger
   if);
   (theOADDocument.theGroupPage.ID,262,@@ specializationsInteger,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write specializationsInteger succeed'->putline
        else
           'Write specializationsInteger fail'->putline
       if)
   if);
   (if theOADDocument.gppProp.associations then
       1->associationsInteger
    else
       0->associationsInteger
   if);
   (theOADDocument.theGroupPage.ID,263,@@ associationsInteger,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write associations succeed'->putline
        else
           'Write associations fail'->putline
       if)
   if);
   theOADDocument.gppProp.SimpleDeclDisplay->SimpleDeclDisplayInteger;
   (theOADDocument.theGroupPage.ID,264,@@ SimpleDeclDisplayInteger,4)
     ->UDWriteType->ok;
   (if userDataVerbose then
       (if ok then
           'Write SimpleDeclDisplay succeed'->putline
        else
           'Write SimpleDeclDisplay fail'->putline
       if)
   if)
#)  

-- ScanDiagrams: Descriptor --
(# 
do
   PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->THIS(ScanDiagrams).current[];
        (if theDiagramType##
         // none then INNER ScanDiagrams; 
         else
            (if current.e.struc <= theDiagramType##
             // true then INNER ScanDiagrams; 
            if)
        if)
     #)
#)  

-- MarkNodeDisplay: Descriptor --
(# 
do
   (pos.x,pos.y,gppProp.marksize,gppProp.marksize)->new;
   theNode[]->thePatternDiagramNode;
   THIS(MarkNode)[]->(thePatternDiagramNode).theMarkNode;
   false->sizeable;
   
#)  

-- MarkNodeOnInit: Descriptor --
(# 
do
   UDPrivate.UDMarkNode->UserDataInit;
   thePatternDiagramNode.Init;
   6->theText.size;
   false->moveable;
   false->sizeable;
   (if not initialisingSaved then theNode[]->CreateRegion if);
   
#)  

-- titleGetFragment: Descriptor --
(# fn: ^FragmentNode; 
do
   (if theFragmentNode <> none
    // true then theFragmentNode->fn[]; fn.theFragment->f[]; 
    else
       'DiagramNode: GetFragment: no FragmentNode'->screen.putline
   if)
#)  

-- AssociationConnectorDisplay: Descriptor --
(# 
do
   (THIS(AssociationNode)[],theDiag.titleNode[])->new;
   (if aType
    // one then
       '1'->theText.set
    // many then
       (if secondMany then
           'm'->theText.set
        else
           true->secondMany; 'n'->theText.set
       if)
    else
       'AssociationConnectorDisplay: Unknown type of association!'->putline
   if);
   aType->type;
   theDiag[]->theDiagram;
   
#)  

-- AssociationConnectorOnDelete: Descriptor --
(#
   n1,n2: ^DesignObject;
   thePatternNode: ^PatternDiagramNode;
   theAssociationNode: ^AssociationNode;
   anAST: ^mps.ast
do
   (if switch[1] then 'AssociationsConnector onDelete'->putline if);
   true->getEnds->(n1[],n2[]);
   (if n1[] <> none then
       (if n1## <= AssociationNode## then n1[]->theAssociationNode[] if)
   if);
   (if n2[] <> none then
       (if n2## <= AssociationNode## then n2[]->theAssociationNode[] if)
   if);
   (if theAssociationNode[] <> none then
       (if theAssociationNode.thePatternNode <> none then
           theAssociationNode.thePatternNode->thePatternNode[]
       if);
       theAssociationNode.delete;
       (if thePatternNode[] <> none then
           thePatternNode[]->currentObject;
           thePatternNode.getASTNode->anAST[];
           (if anAST[] <> none then
               (anAST[],1)->(thePatternNode.theSifEditor).changeFocus;
               (thePatternNode.theSifEditor).cut
           if)
       if)
   if)
#)  

-- AssociationConnectorOnReattach: Descriptor --
(# 
do 'Moving association relation is not yet implemented!'->AlertUser; false->ok
#)  

-- AssociationConnectorOnInit: Descriptor --
(# 
do
   0->Orient;
   UDPrivate.UDAssociationConnector->UserDataInit;
   type.init;
   theDiagram.init
#)  

-- AssociationConnectorDump: Descriptor --
(# 
do
   '********theDiagram********'->putline;
   (if theDiagram <> none then
       (theDiagram).titleText[]->putline
    else
       'is NONE!'->putline
   if);
   '****type****'->putline;
   type->putint;
   newline;
   INNER dump
#)  

-- AssociationNodeDisplay: Descriptor --
(#
   x1,x2,y1,y2,x,y: @integer;
   con1,con2: ^AssociationConnector;
   points: [6] @integer
do
   diagram1.titleNode.center->(x1,y1);
   (if diagram1[] = diagram2[] then (* Associate to self *)
       x1-50->x; y1-50->y
    else
       diagram2.titleNode.center->(x2,y2); (x2+x1) div 2->x; (y2+y1) div 2->y
   if);
   (x,y,0,0)->new;
   &AssociationConnector[]->con1[];
   &AssociationConnector[]->con2[];
   (type1,diagram1[])->con1.display;
   (type2,diagram2[])->con2.display;
   con1[]->c1;
   con2[]->c2;
   (*can only be assigned to persistent c1,c2 after init (in display).*)
   (if diagram1[] = diagram2[] then
       x1->points[3];
       y->points[4];
       points->con1.points;
       con1.redraw;
       x->points[3];
       y1->points[4];
       points->con2.points;
       con2.redraw;
       diagram1.titleNode[]->createRegion
   if)
#)  

-- AssociationNodeOnDoubleClick: Descriptor --
(#
   theListDiagram: ^ListDiagram;
   aPatternNode: ^theListDiagram.PatternNode;
   endOne,endTwo: ^PatternDiagramNode;
   x,y,typeOne,typeTwo: @integer
do
   (if thePatternNode <> none then
       (thePatternNode).theDiagram->theListDiagram[];
       thePatternNode->aPatternNode[];
       (if aPatternNode[] <> none then
           (if aPatternNode.hasAttributes then
           (* center->(x,y);
            THIS(AssociationNode)[]->(c1).getOtherEnd->endOne[];
            (c1).type->typeOne;
            THIS(AssociationNode)[]->(c2).getOtherEnd->endTwo[];
            (c2).type->typeTwo;
            delete; *)
               aPatternNode.detail;
               (* (x,y)->(aPatternNode.currentDecomposDiagram).titlenode.move *)
               
            else
               'Association has no attributes??'->putline
           if)
        else
           'No association pattern declaration??'->putline
       if)
   if)
#)  

-- AssociationNodeDetail: Descriptor --
(#  do  #)  

-- AssociationNodeOnInit: Descriptor --
(# 
do
   UDPrivate.UDAssociationNode->UserDataInit;
   thePatternNode.init;
   c1.init;
   c2.init
#)  

-- AssociationNodeNew: Descriptor --
(# p: [8] @integer
do
   0->p[1];
   - 10->p[2];
   10->p[3];
   0->p[4];
   0->p[5];
   10->p[6];
   - 10->p[7];
   0->p[8];
   (for i: p.range repeat p[i]->wcoord->p[i] for);
   (THIS(OADPage).ID,4,@@ p[1])->DSStrCreatePolygon->onInit;
   (x,y)->move;
   true->doneInInner
#)  

-- AssociationNodeDump: Descriptor --
(# 
do
   '****thePatternNode****'->putline;
   (if thePatternNode <> none then
       (thePatternNode).ID->putint; newline
    else
       ' is NONE!'->putline
   if);
   '****c1****'->putline;
   (if c1 <> none then (c1).dump else ' is NONE!'->putline if);
   '****c2****'->putline;
   (if c2 <> none then (c2).dump else ' is NONE!'->putline if);
   INNER dump
#)  

-- DeletableConnectorGetOtherEnd: Descriptor --
(# node1,node2: ^IDObject
do
   true->getEnds->(node1[],node2[]);
   (if (Start[] = node1[]) or (Start[] = node2[]) then
       (if Start[] = node1[] then
           node2[]->OtherEnd[]
        else
           node1[]->OtherEnd[]
       if)
    else
       (if switch[1] then
           'GetOtherEnd: Start is not in either end'->putline
       if)
   if)
#)  

-- DynamicItemConnectorOnInit: Descriptor --
(#
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theOtherOADDiagram: ^OADDiagram;
   aDiagramNode: ^theOtherListDiagram.DiagramNode;
   aSimpleNode: ^theListDiagram.SimpleNode;
   aNonTerminalNode: ^theListDiagram.NonTerminalNode;
   t: ^Text;
   titleText: @text;
   anAST,aDeclAST: ^MPS.AST;
   theDesc: ^betaGram.ObjectDescriptor;
   anExp,anotherExp: ^mps.expanded;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   theAttrDecl: ^betaGram.AttributeDecl;
   existingConnectors: ^ObjectList;
   theCon: ^Connector
do
   (if switch[1] then 'DynamicItemConnector onInit!'->putline if);
   UDPrivate.UDDynamicItemConnector->UserDataInit;
   (if not initialisingSaved then
       true->THIS(DynamicItemConnector).getEnds->(node1[],node2[]);
       (if (node1## <= PatternDiagramNode##) and
       (node2## <= PatternDiagramNode##) then
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           node2[]->anotherPatternDiagramNode[];
           (if (aPatternDiagramNode## <= theListDiagram.SimpleNode##) then
               aPatternDiagramNode[]->aSimpleNode[];
               aPatternDiagramNode.getASTNode->anExp[];
               anExp.getSon1->theNames[];
               theNames.getSon1->theNameDcl[];
               theNameDcl.getNameDecl->anAST[];
               (if anAST.kind = mps.kinds.unExpanded then
                   '<<NameDecl>>'->t[]
                else
                   theNameDcl.getText->t[]
               if);
               ':^'->t.append;
               anotherPatternDiagramNode.thisDiagram->theOtherListDiagram[];
               (if theOtherListDiagram[] <> none then
                   (if anotherPatternDiagramNode## <=
                   theOtherListDiagram.title## then
                       theOtherListDiagram[]->theOtherOADDiagram[];
                       theOtherOADDiagram.theDescriptor->theDesc[];
                       theDesc.father->anotherExp[];
                       (if anotherExp## <= betaGram.AttributeDecl## then
                           anotherExp[]->aSimpleNode.theQualification;
                           anotherExp[]->private.dynamicReferenceQual[];
                           (anExp[],anotherExp[])->getQualificationWithPath
                             ->t.puttext;
                           (if theListDiagram[] = theOtherListDiagram[] then
                               Delete
                            else
                               THIS(DynamicItemConnector)[]
                                 ->aSimpleNode.theReferenceConnector;
                               
                           if);
                           (anExp[],t)->(aPatternDiagramNode.theSifEditor).parse
                        else
                           Delete;
                           'Destination is singularly defined'->AlertUser
                       if)
                   if)
                else
                   anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
                   (if
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.PatternNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.VirtualNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.BindingNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.FinalNode##) then
                       anotherPatternDiagramNode[]->aDiagramNode[];
                       aDiagramNode.theDeclaration->theAttrDecl[];
                       theAttrDecl[]->aSimpleNode.theQualification;
                       theAttrDecl[]->private.dynamicReferenceQual[];
                       (anExp[],theAttrDecl[])->getQualificationWithPath
                         ->t.puttext;
                       (if theListDiagram[] = theOtherListDiagram[] then
                           Delete
                        else
                           (if aDiagramNode.currentDecomposDiagram <> none then
                               (if aDiagramNode.currentDecomposDiagram <>
                               theListDiagram[] then
                                   (aPatternDiagramNode.getTopParent,
                                    aPatternDiagramNode[],
                                    (aDiagramNode.currentDecomposDiagram).
                                    titleNode.getTopParent,
                                    (aDiagramNode.currentDecomposDiagram).
                                    titleNode[])->setEnds;
                                   THIS(DynamicItemConnector)[]
                                     ->aSimpleNode.theReferenceConnector
                                else
                                   Delete
                               if)
                            else
                               THIS(DynamicItemConnector)[]
                                 ->aSimpleNode.theReferenceConnector
                           if)
                       if);
                       (anExp[],t)->(aPatternDiagramNode.theSifEditor).parse
                    else
                       Delete;
                       'The destination is not a pattern, virtual, binding or final declaration'
                         ->AlertUser
                   if)
               if)
            else
               (if aPatternDiagramNode## <= theListDiagram.NonTerminalNode##
                then
                   aPatternDiagramNode[]->aNonTerminalNode[];
                   '<<NameDecl>>:^'->t[];
                   anotherPatternDiagramNode.thisDiagram->theOtherListDiagram[];
                   (if theOtherListDiagram[] <> none then
                       (if anotherPatternDiagramNode## <=
                       theOtherListDiagram.title## then
                           theOtherListDiagram[]->theOtherOADDiagram[];
                           theOtherOADDiagram.theDescriptor->theDesc[];
                           theDesc.father->anotherExp[];
                           (if anotherExp## <= betaGram.AttributeDecl## then
                               anotherExp[]->private.dynamicReferenceQual[];
                               (aNonTerminalNode.unExp,anotherExp[])
                                 ->getQualificationWithPath->t.puttext;
                               (if theListDiagram[] = theOtherListDiagram[] then
                                   Delete
                                else
                                   THIS(DynamicItemConnector)[]
                                     ->private.dynamicConnector[]
                               if);
                               (aNonTerminalNode.unExp,t)
                                 ->(aNonTerminalNode.theSifEditor).parse
                            else
                               Delete;
                               'Destination is singularly defined'->AlertUser
                           if)
                       if)
                    else
                       anotherPatternDiagramNode.theDiagram
                         ->theOtherListDiagram[];
                       (if
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.PatternNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.VirtualNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.BindingNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.FinalNode##) then
                           anotherPatternDiagramNode[]->aDiagramNode[];
                           aDiagramNode.theDeclaration->theAttrDecl[];
                           theAttrDecl[]->private.dynamicReferenceQual[];
                           (aNonTerminalNode.unExp,theAttrDecl[])
                             ->getQualificationWithPath->t.puttext;
                           (if theListDiagram[] = theOtherListDiagram[] then
                               Delete
                            else
                               THIS(DynamicItemConnector)[]
                                 ->private.dynamicConnector[]
                           if);
                           (aNonTerminalNode.unExp,t)
                             ->(aNonTerminalNode.theSifEditor).parse
                        else
                           Delete;
                           'The destination is not a pattern, virtual, binding or final declaration'
                             ->AlertUser
                       if)
                   if)
                else
                   Delete;
                   'Source must be either a nonterminal or a simple declaration'
                     ->AlertUser
               if)
           if)
        else
           Delete;
           'Source or destination is not part of a pattern diagram'->AlertUser
       if);
       (if ID <> 0 (*A connector was created*) then
           (if (not gppProp.references) or (not gppProp.showAttributes) then
               false->BorderVisible; false->selectable
           if);
           node1.getconnectors->existingConnectors[];
           (if existingConnectors[] <> none then
               existingConnectors.scan
                 (# 
                 do
                    (if (current[] <> THIS(dynamicItemConnector)[]) and
                    ((current## <= DynamicItemConnector##) or
                     (current## <= DynamicComponentConnector##)) then
                        current[]->theCon[]; theCon.delete
                    if)
                 #)
           if)
       if)
   if)
#)  

-- DynamicItemConnectorOnDelete: Descriptor --
(#
   node1,node2,dummy: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theSimpleNode: ^theListDiagram.SimpleNode;
   anAST: ^MPS.AST;
   theDeclaration: ^betaGram.AttributeDecl;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   t: ^Text
do
   (if switch[1] then 'DynamicItemConnector onDelete!'->putline if);
   true->getEnds->(node1[],node2[]);
   node1.theDiagram->theListDiagram[];
   node2.theDiagram->theOtherListDiagram[];
   (if node2## <= theOtherListDiagram.SimpleNode## then
       node1[]->dummy[];
       node2[]->node1[];
       dummy[]->node2[];
       theListDiagram[]->theOtherListDiagram[]
   if);
   node1[]->theSimpleNode[];
   none ->theSimpleNode.theReferenceConnector;
   none ->theSimpleNode.theQualification;
   theSimpleNode.theDeclaration->theDeclaration[];
   theDeclaration.getSon1->theNames[];
   theNames.getSon1->theNameDcl[];
   theNameDcl.getNameDecl->anAST[];
   (if anAST.kind = mps.kinds.unExpanded then
       '<<NameDecl>>'->t[]
    else
       theNameDcl.getText->t[]
   if);
   ':^ <<AttributeDenotation>>'->t.append;
   (theDeclaration[],t)->(node1.theSifEditor).parse;
   
#)  

-- DynamicItemConnectorOnReattach: Descriptor --
(#
   node1,node2,dummy: ^DesignObject;
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theOtherOADDiagram: ^OADDiagram;
   aSimpleNode: ^theListDiagram.SimpleNode;
   aDiagramNode: ^theOtherListDiagram.DiagramNode;
   anAST,aDeclAST: ^MPS.AST;
   anExp,anotherExp: ^mps.expanded;
   theAttrDecl: ^betaGram.AttributeDecl;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   theDesc: ^betaGram.ObjectDescriptor;
   t: ^Text;
   titleText: @Text;
   theCon: ^Connector
do
   true->getEnds->(node1[],node2[]);
   (if switch[1] then
       'DynamicItemConnectorOnReattach!'->putline;
       'node1: '->puttext;
       node1.id->putint;
       newline;
       'node2: '->puttext;
       node2.id->putint;
       newline
   if);
   (if whichEnd then
       (if theNew## <= PatternDiagramNode## then
           theNew[]->anotherPatternDiagramNode[];
           anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           aPatternDiagramNode[]->aSimpleNode[];
           aPatternDiagramNode.getASTNode->anExp[];
           anExp.getSon1->theNames[];
           theNames.getSon1->theNameDcl[];
           theNameDcl.getNameDecl->anAST[];
           (if anAST.kind = mps.kinds.unExpanded then
               '<<NameDecl>>'->t[]
            else
               theNameDcl.getText->t[]
           if);
           ':^'->t.append;
           (if anotherPatternDiagramNode## <= theOtherListDiagram.title## then
               theOtherListDiagram[]->theOtherOADDiagram[];
               theOtherOADDiagram.theDescriptor->theDesc[];
               theDesc.father->anotherExp[];
               (anExp[],anotherExp[])->patternDiagrams.dynReferenceList.insert;
               anotherExp[]->aSimpleNode.theQualification;
               (anExp[],anotherExp[])->getQualificationWithPath->t.puttext;
               (if theListDiagram[] = theOtherListDiagram[] then
                   Delete
                else
                   THIS(DynamicItemConnector)[]
                     ->aSimpleNode.theReferenceConnector;
                   
               if);
               (anExp[],t)->(aPatternDiagramNode.theSifEditor).parse
            else
               (if
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.PatternNode##) or
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.VirtualNode##) or
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.BindingNode##) or
               (anotherPatternDiagramNode## <= theOtherListDiagram.FinalNode##)
                then
                   anotherPatternDiagramNode[]->aDiagramNode[];
                   aDiagramNode.theDeclaration->theAttrDecl[];
                   (anExp[],theAttrDecl[])
                     ->patternDiagrams.dynReferenceList.insert;
                   theAttrDecl[]->aSimpleNode.theQualification;
                   (anExp[],theAttrDecl[])->getQualificationWithPath->t.puttext;
                   (if theListDiagram[] = theOtherListDiagram[] then
                       Delete
                    else
                       (if aDiagramNode.currentDecomposDiagram <> none then
                           (if aDiagramNode.currentDecomposDiagram <>
                           theListDiagram[] then
                               (aPatternDiagramNode.getTopParent,
                                aPatternDiagramNode[],
                                (aDiagramNode.currentDecomposDiagram).titleNode.
                                  getTopParent,
                                (aDiagramNode.currentDecomposDiagram).
                                titleNode[])->setEnds;
                               false->ok;
                               THIS(DynamicItemConnector)[]
                                 ->aSimpleNode.theReferenceConnector
                            else
                               Delete
                           if)
                        else
                           THIS(DynamicItemConnector)[]
                             ->aSimpleNode.theReferenceConnector
                       if)
                   if);
                   (anExp[],t)->(aPatternDiagramNode.theSifEditor).parse
                else
                   'The destination is not a pattern, virtual, binding or final declaration'
                     ->AlertUser;
                   false->ok
               if)
           if)
        else
           'The relation has been attached to a node that is not part of a pattern diagram'
             ->AlertUser;
           false->ok
       if)
    else
       'Moving simpleDecl end of relation not yet implemented'->AlertUser;
       false->ok
   if)
#)  

-- DynamicComponentConnectorOnInit: Descriptor --
(#
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theOtherOADDiagram: ^OADDiagram;
   aSimpleNode: ^theListDiagram.SimpleNode;
   aNonTerminalNode: ^theListDiagram.NonTerminalNode;
   aDiagramNode: ^theOtherListDiagram.DiagramNode;
   t: ^Text;
   titleText: @text;
   anAST,aDeclAST: ^MPS.AST;
   theDesc: ^betaGram.ObjectDescriptor;
   anExp,anotherExp: ^mps.expanded;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   theAttrDecl: ^betaGram.AttributeDecl;
   existingConnectors: ^ObjectList;
   theCon: ^Connector
do
   (if switch[1] then 'DynamicComponentConnector onInit!'->putline if);
   UDPrivate.UDDynamicComponentConnector->UserDataInit;
   (if not initialisingSaved then
       true->getEnds->(node1[],node2[]);
       (if (node1## <= PatternDiagramNode##) and
       (node2## <= PatternDiagramNode##) then
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           node2[]->anotherPatternDiagramNode[];
           (if (aPatternDiagramNode## <= theListDiagram.SimpleNode##) then
               aPatternDiagramNode[]->aSimpleNode[];
               aPatternDiagramNode.getASTNode->anExp[];
               anExp.getSon1->theNames[];
               theNames.getSon1->theNameDcl[];
               theNameDcl.getNameDecl->anAST[];
               (if anAST.kind = mps.kinds.unExpanded then
                   '<<NameDecl>>'->t[]
                else
                   theNameDcl.getText->t[]
               if);
               ':^|'->t.append;
               anotherPatternDiagramNode.thisDiagram->theOtherListDiagram[];
               (if theOtherListDiagram[] <> none then
                   (if anotherPatternDiagramNode## <=
                   theOtherListDiagram.title## then
                       theOtherListDiagram[]->theOtherOADDiagram[];
                       theOtherOADDiagram.theDescriptor->theDesc[];
                       theDesc.father->anotherExp[];
                       (if anotherExp## <= betaGram.AttributeDecl## then
                           anotherExp[]->aSimpleNode.theQualification;
                           anotherExp[]->private.dynamicReferenceQual[];
                           (anExp[],anotherExp[])->getQualificationWithPath
                             ->t.puttext;
                           (if theListDiagram[] = theOtherListDiagram[] then
                               Delete
                            else
                               THIS(DynamicComponentConnector)[]
                                 ->aSimpleNode.theReferenceConnector;
                               
                           if);
                           (anExp[],t)->(aPatternDiagramNode.theSifEditor).parse
                        else
                           'Destination is singularly defined'->AlertUser
                       if)
                   if)
                else
                   anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
                   (if
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.PatternNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.VirtualNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.BindingNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.FinalNode##) then
                       anotherPatternDiagramNode[]->aDiagramNode[];
                       aDiagramNode.theDeclaration->theAttrDecl[];
                       theAttrDecl[]->aSimpleNode.theQualification;
                       theAttrDecl[]->private.dynamicReferenceQual[];
                       (anExp[],theAttrDecl[])->getQualificationWithPath
                         ->t.puttext;
                       (if theListDiagram[] = theOtherListDiagram[] then
                           Delete
                        else
                           (if aDiagramNode.currentDecomposDiagram <> none then
                               (if aDiagramNode.currentDecomposDiagram <>
                               theListDiagram[] then
                                   (aPatternDiagramNode.getTopParent,
                                    aPatternDiagramNode[],
                                    (aDiagramNode.currentDecomposDiagram).
                                    titleNode.getTopParent,
                                    (aDiagramNode.currentDecomposDiagram).
                                    titleNode[])->setEnds;
                                   THIS(DynamicComponentConnector)[]
                                     ->aSimpleNode.theReferenceConnector
                                else
                                   Delete
                               if)
                            else
                               THIS(DynamicComponentConnector)[]
                                 ->aSimpleNode.theReferenceConnector
                           if)
                       if);
                       (anExp[],t)->(aPatternDiagramNode.theSifEditor).parse
                    else
                       Delete;
                       'The destination is not a pattern, virtual, binding or final declaration'
                         ->AlertUser
                   if)
               if)
            else
               (if aPatternDiagramNode## <= theListDiagram.NonTerminalNode##
                then
                   aPatternDiagramNode[]->aNonTerminalNode[];
                   '<<NameDecl>>:^|'->t[];
                   anotherPatternDiagramNode.thisDiagram->theOtherListDiagram[];
                   (if theOtherListDiagram[] <> none then
                       (if anotherPatternDiagramNode## <=
                       theOtherListDiagram.title## then
                           theOtherListDiagram[]->theOtherOADDiagram[];
                           theOtherOADDiagram.theDescriptor->theDesc[];
                           theDesc.father->anotherExp[];
                           (if anotherExp## <= betaGram.AttributeDecl## then
                               anotherExp.getSon1->theNames[];
                               anotherExp[]->private.dynamicReferenceQual[];
                               (aNonTerminalNode.unExp,anotherExp[])
                                 ->getQualificationWithPath->t.puttext;
                               (if theListDiagram[] = theOtherListDiagram[] then
                                   Delete
                                else
                                   THIS(DynamicComponentConnector)[]
                                     ->private.dynamicConnector[]
                               if);
                               (aNonTerminalNode.unExp,t)
                                 ->(aNonTerminalNode.theSifEditor).parse
                            else
                               'Destination is singularly defined'->AlertUser
                           if)
                       if)
                    else
                       anotherPatternDiagramNode.theDiagram
                         ->theOtherListDiagram[];
                       (if
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.PatternNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.VirtualNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.BindingNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.FinalNode##) then
                           anotherPatternDiagramNode[]->aDiagramNode[];
                           aDiagramNode.theDeclaration->theAttrDecl[];
                           theAttrDecl[]->private.dynamicReferenceQual[];
                           (aNonTerminalNode.unExp,theAttrDecl[])
                             ->getQualificationWithPath->t.puttext;
                           (if theListDiagram[] = theOtherListDiagram[] then
                               Delete
                            else
                               
                           if);
                           (aNonTerminalNode.unExp,t)
                             ->(aNonTerminalNode.theSifEditor).parse
                        else
                           Delete;
                           'The destination is not a pattern, virtual, binding or final declaration'
                             ->AlertUser
                       if)
                   if)
                else
                   Delete;
                   'Source must be either a nonterminal or a simple declaration'
                     ->AlertUser
               if)
           if)
        else
           Delete;
           'Source or destination is not part of a pattern diagram'->AlertUser
       if);
       (if ID <> 0 (*A connector was created*) then
           (if (not gppProp.references) or (not gppProp.showAttributes) then
               false->BorderVisible; false->selectable
           if);
           node1.getconnectors->existingConnectors[];
           (if existingConnectors[] <> none then
               existingConnectors.scan
                 (# 
                 do
                    (if (current[] <> THIS(dynamicComponentConnector)[]) and
                    ((current## <= DynamicItemConnector##) or
                     (current## <= DynamicComponentConnector##)) then
                        current[]->theCon[]; theCon.delete
                    if)
                 #)
           if)
       if)
   if)
#)  

-- DynamicComponentConnectorOnDelete: Descriptor --
(#
   node1,node2,dummy: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theSimpleNode: ^theListDiagram.SimpleNode;
   anAST: ^MPS.AST;
   theDeclaration: ^betaGram.AttributeDecl;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   t: ^Text
do
   (if switch[1] then 'DynamicItemConnector onDelete!'->putline if);
   true->getEnds->(node1[],node2[]);
   node1.theDiagram->theListDiagram[];
   node2.theDiagram->theOtherListDiagram[];
   (if node2## <= theOtherListDiagram.SimpleNode## then
       node1[]->dummy[];
       node2[]->node1[];
       dummy[]->node2[];
       theListDiagram[]->theOtherListDiagram[]
   if);
   node1[]->theSimpleNode[];
   none ->theSimpleNode.theReferenceConnector;
   none ->theSimpleNode.theQualification;
   theSimpleNode.theDeclaration->theDeclaration[];
   theDeclaration.getSon1->theNames[];
   theNames.getSon1->theNameDcl[];
   theNameDcl.getNameDecl->anAST[];
   (if anAST.kind = mps.kinds.unExpanded then
       '<<NameDecl>>'->t[]
    else
       theNameDcl.getText->t[]
   if);
   ':^| <<AttributeDenotation>>'->t.append;
   (theDeclaration[],t)->(node1.theSifEditor).parse;
   
#)  

-- DynamicComponentConnectorOnReattach: Descriptor --
(#
   node1,node2,dummy: ^DesignObject;
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theOtherOADDiagram: ^OADDiagram;
   aSimpleNode: ^theListDiagram.SimpleNode;
   aDiagramNode: ^theOtherListDiagram.DiagramNode;
   anAST,aDeclAST: ^MPS.AST;
   anExp,anotherExp: ^mps.expanded;
   theAttrDecl: ^betaGram.AttributeDecl;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   theDesc: ^betaGram.ObjectDescriptor;
   t: ^Text;
   titleText: @Text;
   theCon: ^Connector
do
   true->getEnds->(node1[],node2[]);
   (if switch[1] then
       'DynamicComponentConnectorOnReattach!'->putline;
       'node1: '->puttext;
       node1.id->putint;
       newline;
       'node2: '->puttext;
       node2.id->putint;
       newline
   if);
   (if whichEnd then
       (if theNew## <= PatternDiagramNode## then
           theNew[]->anotherPatternDiagramNode[];
           anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           aPatternDiagramNode[]->aSimpleNode[];
           aPatternDiagramNode.getASTNode->anExp[];
           anExp.getSon1->theNames[];
           theNames.getSon1->theNameDcl[];
           theNameDcl.getNameDecl->anAST[];
           (if anAST.kind = mps.kinds.unExpanded then
               '<<NameDecl>>'->t[]
            else
               theNameDcl.getText->t[]
           if);
           ':^|'->t.append;
           (if anotherPatternDiagramNode## <= theOtherListDiagram.title## then
               theOtherListDiagram[]->theOtherOADDiagram[];
               theOtherOADDiagram.theDescriptor->theDesc[];
               theDesc.father->anotherExp[];
               anotherExp[]->aSimpleNode.theQualification;
               (anExp[],anotherExp[])->getQualificationWithPath->t.puttext;
               (if theListDiagram[] = theOtherListDiagram[] then
                   Delete
                else
                   THIS(DynamicComponentConnector)[]
                     ->aSimpleNode.theReferenceConnector;
                   
               if);
               (anExp[],t)->(aPatternDiagramNode.theSifEditor).parse
            else
               (if
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.PatternNode##) or
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.VirtualNode##) or
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.BindingNode##) or
               (anotherPatternDiagramNode## <= theOtherListDiagram.FinalNode##)
                then
                   anotherPatternDiagramNode[]->aDiagramNode[];
                   aDiagramNode.theDeclaration->theAttrDecl[];
                   (anExp[],theAttrDecl[])->getQualificationWithPath->t.puttext;
                   (if theListDiagram[] = theOtherListDiagram[] then
                       Delete
                    else
                       (if aDiagramNode.currentDecomposDiagram <> none then
                           (if aDiagramNode.currentDecomposDiagram <>
                           theListDiagram[] then
                               (aPatternDiagramNode.getTopParent,
                                aPatternDiagramNode[],
                                (aDiagramNode.currentDecomposDiagram).titleNode.
                                  getTopParent,
                                (aDiagramNode.currentDecomposDiagram).
                                titleNode[])->setEnds;
                               false->ok;
                               THIS(DynamicComponentConnector)[]
                                 ->aSimpleNode.theReferenceConnector
                            else
                               Delete
                           if)
                        else
                           THIS(DynamicComponentConnector)[]
                             ->aSimpleNode.theReferenceConnector
                       if)
                   if);
                   (anExp[],t)->(aPatternDiagramNode.theSifEditor).parse
                else
                   'The destination is not a pattern, virtual, binding or final declaration'
                     ->AlertUser;
                   false->ok
               if)
           if)
        else
           'The relation has been attached to a node that is not part of a pattern diagram'
             ->AlertUser;
           false->ok
       if)
    else
       'Moving simpleDecl end of relation not yet implemented'->AlertUser;
       false->ok
   if)
#)  

-- getQualificationWithPath: Descriptor --
(#
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   aDeclAST,nca,ncDecl: ^MPS.AST;
   keepT: ^Text;
   qualSonNo,refSonNo: @integer;
   getSurroundingDecl:
     (# anAST: ^MPS.AST; attDecl: ^betaGram.AttributeDecl
     enter anAST[]
     do
        (if anAST.father
         // none then 
         else
            anAst.father->anAST[];
            (if anAST.symbol
             // BetaGram.PatternDecl // betaGram.VirtualDecl
             // betaGram.BindingDecl // betaGram.FinalDecl
             // betaGram.SimpleDecl then
                anAST[]->attDecl[]
             else
                anAST[]->getSurroundingDecl->attDecl[]
            if)
        if)
     exit attDecl[]
     #)
do
   qual.getSon1->theNames[];
   theNames.getSon1->theNameDcl[];
   theNameDcl.getNameDecl->aDeclAST[];
   (if aDeclAST.kind = mps.kinds.unExpanded then
       '<<NameAppl>>'->t[]->keepT[]
    else
       theNameDcl.getText->t[]->keepT[]
   if);
   (if not (ref[]->qual.equal) then
       (if ref.frag[] = qual.frag[] then
           ref[]->qual.nearestCommonAncestor->(nca[],qualSonNo,refSonNo);
           (if not (nca## <= betaGram.AttributeDecl##) then
               nca[]->getSurroundingDecl->ncDecl[]
           if)
       if);
       (if ncDecl[] = none then
           loop:
             (# 
             do
                qual[]->getSurroundingDecl->qual[];
                (if qual[] <> none then
                    qual.getSon1->theNames[];
                    theNames.getSon1->theNameDcl[];
                    theNameDcl.getNameDecl->aDeclAST[];
                    (if aDeclAST.kind = mps.kinds.unExpanded then
                        '<<NameAppl>>.'->t.prepend
                     else
                        '.'->t.prepend; theNameDcl.getText->t.prepend
                    if);
                    restart loop
                if)
             #)
        else
           (if not (qual[]->ncDecl.equal) then
               qual[]->getSurroundingDecl->qual[];
               (if qual[] <> none then
                   (if not (qual[]->ncDecl.equal) then
                       loop:
                         (# 
                         do
                            qual.getSon1->theNames[];
                            theNames.getSon1->theNameDcl[];
                            theNameDcl.getNameDecl->aDeclAST[];
                            (if aDeclAST.kind = mps.kinds.unExpanded then
                                '<<NameAppl>>.'->t.prepend
                             else
                                '.'->t.prepend; theNameDcl.getText->t.prepend
                            if);
                            qual[]->getSurroundingDecl->qual[];
                            (if qual[] <> none then
                                (if not (qual[]->ncDecl.equal) then
                                    restart loop
                                if)
                             else
                                keepT[]->t[]
                            if)
                         #)
                   if)
                else
                   keepT[]->T[]
               if)
           if)
       if)
   if)
#)  

-- GppFileNameDialog: Descriptor --
(#
   cstr: @IntegerRef;
   filt: external
     (# ok: @integer; fisk: @Integer; 
     enter fisk
     do cExternalEntry; true->ok
     exit ok
     #);
   cStringToCharR: external
     (# cStr: @integer; c: [1] @char
     enter cStr
     do 'copyInput'->callC; 
     exit c
     #);
   DSF: external
     (#
        ok: @boolean;
        requestlabel,okButtonLabel,initialPath: [1] @char;
        filterProc: ##external;
        exitPathPP: ^IntegerRef;
        
     enter (requestlabel,okButtonLabel,initialPath,filterProc##,exitPathPP[])
     do 'DSFile_NameDialog'->callC; 
     exit ok
     #);
   
do
   (if (message,label,'',filt##,cstr[])->DSF
    // true then cstr->cStringToCharR->filename; 
   if);
   
#)  

-- GppOADPagePrivate: Descriptor --
(#
   dynamicReferenceQual: ^betaGram.AttributeDecl;
   dynamicConnector: ^DeletableConnector
#)  

-- getSynCatNo: DoPart --
do
   (if
   ((node.kind = mps.kinds.unexpanded) or (node.kind = mps.kinds.optional)) then
       node[]->nontNode[]; nontNode.nonterminalSymbol->synCatNo
    else
       node.symbol->synCatNo
   if)  

-- setReadOnly: DoPart --
do INNER setReadOnly  

-- unsetReadOnly: DoPart --
do INNER unsetReadOnly  

