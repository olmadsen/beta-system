ORIGIN 'diagramattributes';
INCLUDE '~toby/beta/designenv/v2.3/private/userdatabody'
        '../treeprettyprint';
-- BoxToNode: DoPart --
do (if theNode## <= SurroundBox## then theNode.getParent->theNode[];  if)  

-- ASTToNode: Descriptor --
(# 
do
   (if switch[12] then 'ASTtoNode: '->putText if);
   (if anAST[]
    // none then 'ASTtoNode: anAST is none!'->putLine; 
    else
       (if switch[12] then anAST.index->putInt;  if);
       search:
         (# 
         do
            (if theWorkPage[] <> none then
                theWorkPage.patternDiagrams.theList.scan
                  (# theListDiagram: ^theWorkPage.ListDiagram
                  do
                     (if current.e## <= theWorkPage.ListDiagram## then
                         current.e[]->theListDiagram[];
                         theListDiagram.localNodes.scan
                           (#
                              theDiagramNode: ^theListDiagram.DiagramNode;
                              theNonTerminalNode:
                                ^theListDiagram.NonTerminalNode;
                              theSlotNode: ^theListDiagram.SlotNode
                           do
                              (if current## <= theListDiagram.DiagramNode## then
                                  current[]->theDiagramNode[];
                                  (if
                                  theDiagramNode.theDeclaration->anAST.equal
                                   then
                                      theDiagramNode[]->theNode[]; leave search
                                  if)
                              if);
                              (if current## <= theListDiagram.NonTerminalNode##
                               then
                                  current[]->theNonTerminalNode[];
                                  (if theNonTerminalNode.unExp->anAST.equal then
                                      theNonTerminalNode[]->theNode[];
                                      leave search
                                  if)
                              if);
                              (if current## <= theListDiagram.SlotNode## then
                                  current[]->theSlotNode[];
                                  (if theSlotNode.unExp->anAST.equal then
                                      theSlotNode[]->theNode[]; leave search
                                  if)
                              if)
                           #)
                     if)
                  #)
            if);
            theGroupPage.patternDiagrams.theList.scan
              (# theListDiagram: ^theGroupPage.ListDiagram
              do
                 (if current.e## <= theGroupPage.ListDiagram## then
                     current.e[]->theListDiagram[];
                     theListDiagram.localNodes.scan
                       (# 
                       do
                          (if current.astIndex = anAST.index then
                              current[]->theNode[]; leave search
                          if);
                          (* 
                           Loops indefinetly in connection with New Prg./Lib.
                           (if current## <= theListDiagram.FragmentNode## then
                           current[]->theFragmentNode[];
                           (if theFragmentNode.theRoot->anAST.equal then
                           theFragmentNode[]->theNode[]; leave search
                           if)
                           if)*)
                          
                       #)
                 if)
              #)
         #);
       (*        search:
        anAST.index
        ->indexIDList.scan
        (# theObject: ^PatternDiagramNode; ff: ^mps.fragmentForm
        do
        currentNode[]->theObject[];
        (if theObject.getFragment
        // none then
        'ASTtoNode: theNode.getFragment is none!'->putLine; 
        else
        theObject.getFragment->ff[];
        (if ff[] = anAST.frag[] then
        theObject[]->theNode[]; leave search
        if)
        if);
        
        #);*)
       (if switch[12] then
           ' return: '->putText;
           (if theNode[]
            // none then 'none'->putLine
            else
               theNode.id->putInt; newLine
           if);
           
       if)
   if);
   
#)  

-- ASTToNodeListUpdate: Descriptor --
(# ff: ^mps.fragmentform; oldASTName: ^Text; 
do
   (if switch[12] then 'ASTtoNodeListUpdate: '->putText;  if);
   (if oldAST[]
    // none then 'ASTtoNodeListUpdate: oldAST is none!'->putLine; 
    else
       (if switch[12] then oldAST.index->putInt; ' '->put;  if);
       (if newAST[]
        // none then 'ASTtoNodeListUpdate: newAST is none!'->putLine; 
        else
           search:
             (# 
             do
                (if theWorkPage[] <> none then
                    theWorkPage.patternDiagrams.theList.scan
                      (# theListDiagram: ^theWorkPage.ListDiagram
                      do
                         (if current.e## <= theWorkPage.ListDiagram## then
                             current.e[]->theListDiagram[];
                             theListDiagram.localNodes.scan
                               (#
                                  theDiagramNode: ^theListDiagram.DiagramNode;
                                  theNonTerminalNode:
                                    ^theListDiagram.NonTerminalNode
                               do
                                  (if current## <= theListDiagram.DiagramNode##
                                   then
                                      current[]->theDiagramNode[];
                                      (if
                                      theDiagramNode.theDeclaration
                                        ->oldAST.equal then
                                          theDiagramNode[]->theNode[]
                                      if)
                                  if);
                                  (if current## <=
                                  theListDiagram.NonTerminalNode## then
                                      current[]->theNonTerminalNode[];
                                      (if
                                      theNonTerminalNode.unExp->oldAST.equal
                                       then
                                          theNonTerminalNode[]->theNode[]
                                      if)
                                  if)
                               #)
                         if)
                      #)
                if);
                theGroupPage.patternDiagrams.theList.scan
                  (# theListDiagram: ^theGroupPage.ListDiagram
                  do
                     (if current.e## <= theGroupPage.ListDiagram## then
                         current.e[]->theListDiagram[];
                         theListDiagram.localNodes.scan
                           (# 
                           do
                              (if current.astIndex = oldAST.index then
                                  current[]->theNode[]; leave search
                              if)
                              (*(if current## <= theListDiagram.FragmentNode## then
                               current[]->theFragmentNode[];
                               (if theFragmentNode.theRoot->oldAST.equal then
                               theFragmentNode[]->theNode[]
                               if)
                               if)*)
                           #)
                     if)
                  #)
             #);
           (*           (if switch[21] then newAST.index->putInt;  if);
            search:
            oldAST.index
            ->indexIDList.scan
            (# theObject: ^PatternDiagramNode
            do
            currentNode[]->theObject[];
            (if theObject.getFragment
            // none then
            'ASTtoNodeListUpdate: theNode.getFragment is none!'
            ->putLine;
            
            else
            theObject.getFragment->ff[];
            (if ff[] = newAST.frag[] then
            newAst.Index->indexIDList.impl[i];
            theObject[]->theNode[];
            leave search
            if)
            if);
            
            #)*)
           
       if);
       (if switch[12] then
           ' return: '->putText;
           (if theNode[]
            // none then 'none'->putLine
            else
               theNode.id->putInt; newLine
           if);
           
       if);
       
   if)
#)  

-- RemoveListElement: Descriptor --
(# theNode: ^patternDiagramNode
do
   (if switch[60] then 'RemoveListElement'->putText if);
   (if anAST[] = none then
       'RemoveListElement: anAST is none!'->putLine; putLine; 
    else
       (if switch[60] then anAST.index->putInt;  if);
       search:
       anAST.index
         ->indexIDList.RemoveScan
           (# 
           do 0->IndexIDList.impl[i]; 0->IndexIDList.impl[i+1]; leave search; 
           #)
   if)
#)  

-- InitGPP: Descriptor --
(#  do  #)  

-- OADPageOnInit: Descriptor --
(#
   integerData: @integer;
   ok: @Boolean;
   listsize,last,showAttributesInteger,referencesInteger,specializationsInteger,
     associationsInteger,SimpleDeclDisplayInteger,x,y,w,h: @integer;
   xref,yref: @IntegerRef;
   thePalette: ^Palette;
   theRndRect: ^thePalette.RectNode
do
   (if userDataVerbose then
       'onInit called on OADPage with id='->puttext;
       id->putint;
       newline;
       'Reading OADPage UserDataID: '->puttext
   if);
   (Id,1,@@ integerData)->UDReadType->ok;
   (if ok then
       (if userDataVerbose then
           'Read OADPage UserDataID succeed: '->puttext;
           integerData->putint;
           newline
       if);
       (integerData,ID)->UserDataIDMap.putID;
       
    else
       (if userDataVerbose then 'Read OADPage UserDataID fail'->putline if)
   if);
   ID->integerData;
   (Id,1,@@ integerData,4)->UDWriteType->ok;
   (if ok then
       (if userDataVerbose then
           'Write OADPage UserDataID succeed: '->puttext;
           integerData->putint;
           newline
       if)
    else
       (if userDataVerbose then 'Write OADPage UserDataID fail'->putline if)
   if);
   (if THIS(OADPage)[] = theGroupPage[] then
       (theGroupPage.ID,499,@@ listsize)->UDReadType->ok;
       (if ok then
           listsize->IndexIDList.impl.new;
           (if userDataVerbose then
               'Read IndexIDList.impl.range succeed: '->puttext;
               listsize->putint;
               newline
           if);
           (theGroupPage.ID,500,@@ last)->UDReadType->ok;
           (if ok then
               last->IndexIDList.last;
               (if userDataVerbose then
                   'Read IndexIDList.last succeed: '->puttext;
                   last->putint;
                   newline
               if);
               (for i: listsize repeat
                 (theGroupPage.ID,500+i,@@ IndexIDList.impl[i])->UDReadType->ok;
                 (if ok then
                     (if userDataVerbose then
                         'Read IndexIDList succeed: '->puttext;
                         'element no '->puttext;
                         i->putint;
                         'element '->puttext;
                         IndexIDList.impl[i]->putint;
                         newline
                     if)
                  else
                     'Read IndexIDList fail: '->puttext
                 if)
               for)
            else
               (if userDataVerbose then
                   'Read IndexIDList.last fail'->putline
               if)
           if)
        else
           (if userDataVerbose then
               'Read IndexIDList.impl.range fail: '->puttext
           if)
       if);
       (theGroupPage.ID,260,@@ showAttributesInteger)->UDReadType->ok;
       (if ok then
           (if showAttributesInteger = 1 then
               true->gppProp.showAttributes
            else
               (if showAttributesInteger = 0 then
                   false->gppProp.showAttributes
               if)
           if);
           (if userDataVerbose then
               'Read showAttributes succeed: '->puttext;
               showAttributesInteger->putint;
               newline
           if)
        else
           (if userDataVerbose then 'Read showAttributes fail'->putline if)
       if);
       (theGroupPage.ID,261,@@ referencesInteger)->UDReadType->ok;
       (if ok then
           (if referencesInteger = 1 then
               true->gppProp.references
            else
               (if referencesInteger = 0 then false->gppProp.references if)
           if);
           (if userDataVerbose then
               'Read references succeed: '->puttext;
               referencesInteger->putint;
               newline
           if)
        else
           (if userDataVerbose then 'Read references fail'->putline if)
       if);
       (theGroupPage.ID,262,@@ specializationsInteger)->UDReadType->ok;
       (if ok then
           (if specializationsInteger = 1 then
               true->gppProp.specializations
            else
               (if specializationsInteger = 0 then
                   false->gppProp.specializations
               if)
           if);
           (if userDataVerbose then
               'Read specializations succeed: '->puttext;
               specializationsInteger->putint;
               newline
           if)
        else
           (if userDataVerbose then 'Read specializations fail'->putline if)
       if);
       (theGroupPage.ID,263,@@ associationsInteger)->UDReadType->ok;
       (if ok then
           (if associationsInteger = 1 then
               true->gppProp.associations
            else
               (if associationsInteger = 0 then
                   false->gppProp.associations
               if)
           if);
           (if userDataVerbose then
               'Read associations succeed: '->puttext;
               associationsInteger->putint;
               newline
           if)
        else
           (if userDataVerbose then 'Read associations fail'->putline if)
       if);
       (theGroupPage.ID,264,@@ SimpleDeclDisplayInteger)->UDReadType->ok;
       (if ok then
           SimpleDeclDisplayInteger->gppProp.SimpleDeclDisplay;
           (if userDataVerbose then
               'Read SimpleDeclDisplay succeed: '->puttext;
               SimpleDeclDisplayInteger->putint;
               newline
           if)
        else
           (if userDataVerbose then 'Read SimpleDeclDisplay fail'->putline if)
       if)
   if);
   patternDiagrams.AssociationList.load;
   patternDiagrams.InheritanceList.load;
   patternDiagrams.AggregationList.load;
   (ID,240,@@ NextX)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read NextX succeed'->putline
        else
           'Read NextX fail'->putline
       if)
   if);
   (ID,241,@@ NextY)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read NextY succeed'->putline
        else
           'Read NextY fail'->putline
       if)
   if);
   (ID,250,@@ patternDiagrams.NextFreeLine)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read NextFreeLine succeed'->putline
        else
           'Read NextFreeLine fail'->putline
       if)
   if);
   (ID,251,@@ patternDiagrams.NextFreeColumn)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read NextFreeColumn succeed'->putline
        else
           'Read NextFreeColumn fail'->putline
       if)
   if);
   (ID,252,@@ patternDiagrams.SecondFreeLine)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read SecondFreeline succeed'->putline
        else
           'Read SecondFreeLine fail'->putline
       if)
   if);
   (ID,253,@@ patternDiagrams.SecondFreeColumn)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read SecondFreeColumn succeed'->putline
        else
           'Read SecondFreeColumn fail'->putline
       if)
   if);
   (*  THIS(OADPage).geometry->(x,y,w,h);
    'OADPageOnInit: OADPage geometry '->puttext;
    x->putint;
    ' '->puttext;
    y->putint;
    ' '->puttext;
    w->putint;
    ' '->puttext;
    h->putint;
    newline;
    (if (w = 0) and (h = 0) then
    
    (ID,256,@@ w)->UDReadType->ok;
    (if userDataVerbose then
    (if ok then
    'Read w succeed'->putline
    else
    'Read w fail'->putline
    if)
    if);
    (ID,257,@@ h)->UDReadType->ok;
    (if userDataVerbose then
    (if ok then
    'Read h succeed'->putline
    else
    'Read h fail'->putline
    if)
    if);
    'OADPageOnInit: OADPage geometry after UDRead '->puttext;
    x->putint;
    ' '->puttext;
    y->putint;
    ' '->puttext;
    w->putint;
    ' '->puttext;
    h->putint;
    newline;
    (if (THIS(Page).ID,w,h)->DSWtAttrAdjustObjectSize
    // false then 'PageSetGeo: could not set size'->putline
    if);
    (if (THIS(Page).ID,xref[],yref[])->DSRdAttrGetObjectSize
    // true then xref->w; yref->h; 
    else
    'PageGetGeometry Size: error'->putline; 
    if);
    'OADPageOnInit: OADPage geometry after setSize'->puttext;
    x->putint;
    ' '->puttext;
    y->putint;
    ' '->puttext;
    w->putint;
    ' '->puttext;
    h->putint;
    newline
    if);*)
   false->borderVisible;
   (if nextX = 0 then 250->nextX if);
   (if nextY = 0 then 250->nextY if);
   true->doScrollIntoView;
   (*gppProp.NextPositionStartX*)
   (*gppProp.NextPositionStartY*)
   
#)  

-- CalculateNextCenter: Descriptor --
(# x,y,w,h: @Integer; p: ^OADPage; 
do
   (if PatternDiagrams.theList.size
    // 0 then (* first diagram on page *)
       CurrentPage->p[];
       p.Geometry->(x,y,w,h);
       (* center, width, and height of PAGE *)
       y-(h div 2)+gppProp.DownOnPage->PatternDiagrams.NextFreeLine;
       x-(w div 2)+gppProp.RightOnPage->PatternDiagrams.NextFreeColumn;
       PatternDiagrams.NextFreeLine->PatternDiagrams.SecondFreeLine;
       PatternDiagrams.NextFreeColumn+gppProp.width+gppProp.RightFromPrevious
         ->PatternDiagrams.SecondFreeColumn;
       
   if);
   (PatternDiagrams.NextFreeColumn,PatternDiagrams.NextFreeLine)->theCenter;
   (*(nextX,nextY)->theCenter;*)
   
#)  

-- UpdateNextFree: Descriptor --
(# w,h: @Integer; xref,yref: @IntegerRef; 
do
   (if x-gppProp.width > theCenter.x then
       'UpdateNextFree: we have the last box on another column than the title ?'
         ->putline;
       x->PatternDiagrams.NextFreeColumn;
       
   if);
   ;
   (PatternDiagrams.NextFreeLine,y+gppProp.DownFromPrefix)->Max
     ->PatternDiagrams.NextFreeLine;
   (PatternDiagrams.SecondFreeColumn,x+gppProp.width+gppProp.RightFromPrevious)
     ->Max->PatternDiagrams.SecondFreeColumn;
   0->y;
   730->h;
   (if PatternDiagrams.NextFreeLine > y+(h div 2) then
   (* PatternDiagrams.SecondFreeLine -> PatternDiagrams.NextFreeLine;*)
       y-(h div 2)+gppProp.DownOnPage->PatternDiagrams.NextFreeLine;
       (if true (* PatternDiagrams.NextFreeColumn < theCenter.x *) then
           PatternDiagrams.SecondFreeColumn->PatternDiagrams.NextFreeColumn;
           PatternDiagrams.SecondFreeColumn+gppProp.width+
           gppProp.RightFromPrevious->PatternDiagrams.SecondFreeColumn;
           
       if);
       
   if);
   
#)  

-- prettyprintSubPatterns: DoPart --
do
     (#
        treeNode: treePPNode
          (#
             element::< PatternDeclDiagram;
             width::< 
               (#
                  thePatternDeclDiagram: ^PatternDeclDiagram;
                  x,y,h,w1,w2: @integer
               do
                  elm[]->thePatternDeclDiagram[];
                  (if gppProp.showAttributes then
                      (if thePatternDeclDiagram.localNodes.empty then
                          thePatternDeclDiagram.titleNode.geometry->(x,y,w,h)
                       else
                          (thePatternDeclDiagram.localNodes.last).elm.geometry
                            ->(x,y,w1,h);
                          thePatternDeclDiagram.titleNode.geometry->(x,y,w2,h);
                          (w1,w2)->max->w
                      if)
                   else
                      thePatternDeclDiagram.titleNode.geometry->(x,y,w,h)
                  if)
               #);
             print::<  (#  do elm.titleText[]->puttext #)
          #);
        buildTree:
          (# theNode,aNode: ^treeNode; subList: ^DiagramList
          enter theNode[]
          do
             theNode->PatternDiagrams.inheritanceList.GetSubPatternDiagrams
               ->subList[];
             subList.scan
               (# 
               do
                  &treeNode[]->aNode[];
                  current.e[]->aNode.elm[];
                  aNode[]->theNode.appendSon;
                  aNode[]->buildTree
               #)
          #);
        x,y,width,heigth,titleWidth,delta,x1,y1,maxY: @Integer;
        root: ^treeNode;
        h: ^treePPhead;
        pos,firstPos: @real
     do
        &treeNode[]->root[];
        thePatternDeclDiagram[]->root.elm[];
        root[]->buildTree;
        (root[],h[],0,gppProp.rightOnPage)->treePPposition->(pos,h[]);
        (if h[] <> none then
            (if switch[90] then h.print; newline if);
            (if h.first[] <> none then
                h.first.pnode.elm[]->thePatternDeclDiagram[];
                thePatternDeclDiagram.titleNode.center->(x,y);
                (if gppProp.showAttributes then
                    (if not thePatternDeclDiagram.localNodes.empty then
                        (thePatternDeclDiagram.localNodes.last).elm.center
                          ->(x,y)
                    if)
                if);
                y+gppProp.DownFromPrefix->y;
                minInt->maxY;
                h.first.pos->firstPos;
                (if h.next[] <> none then
                    loop:
                      (# 
                      do
                         h.next.first.pnode.elm[]->thePatternDeclDiagram[];
                         thePatternDeclDiagram.titleNode.geometry
                           ->(x1,y1,titleWidth,heigth);
                         0->delta;
                         (if gppProp.showAttributes then
                             (if not thePatternDeclDiagram.localNodes.empty then
                                 (thePatternDeclDiagram.localNodes.last).elm.
                                   geometry->(x1,y1,width,heigth);
                                 (if width > titleWidth then
                                     width div 2-titleWidth div 2->delta
                                 if)
                             if)
                         if);
                         x+(h.next.first.pos-firstPos)-delta->x1;
                         (x1,y)->thePatternDeclDiagram.titleNode.center;
                         (if gppProp.showAttributes then
                             (if not thePatternDeclDiagram.localNodes.empty then
                                 (thePatternDeclDiagram.localNodes.last).elm.
                                   center->(x1,y1);
                                 (maxY,y1)->max->maxY
                             if)
                         if);
                         (if h.next.first.next[] <> none then
                             h.next.first.next[]->h.next.first[]; restart loop
                          else
                             (if h.next.next[] <> none then
                                 ((y,maxY)->max)+gppProp.DownFromPrefix->y;
                                 h.next.next[]->h.next[];
                                 restart loop
                             if)
                         if)
                      #)
                if)
            if);
            (*             (if false then
             *                 (if h.first[] <> none then
             *                     h.first.pnode.elm[]->thePatternDeclDiagram[];
             *                     thePatternDeclDiagram.titleNode.center->(x,y);
             *                     (if gppProp.showAttributes then
             *                         (if not thePatternDeclDiagram.localNodes.empty then
             *                             (thePatternDeclDiagram.localNodes.last).elm.center
             *                               ->(x,y)
             *                         if)
             *                     if);
             *                     y+gppProp.DownFromPrefix->y;
             *                     minInt->maxY;
             *                     h.first.pos->firstPos;
             *                     (if h.next[] <> none then
             *                         loop:
             *                           (# 
             *                           do
             *                              h.next.first.pnode.elm[]->thePatternDeclDiagram[];
             *                              thePatternDeclDiagram.titleNode.geometry
             *                                ->(x1,y1,width,heigth);
             *                              (if gppProp.showAttributes then
             *                                  (if not thePatternDeclDiagram.localNodes.empty
             *                                   then
             *                                      (thePatternDeclDiagram.localNodes.last).elm
             *                                      .geometry->(x1,y1,width,heigth)
             *                                  if)
             *                              if);
             *                              (h.next.first.pos-firstPos)*
             *                              (gppProp.rightOnPage+width)+x->x1;
             *                              (x1,y)->thePatternDeclDiagram.titleNode.center;
             *                              thePatternDeclDiagram.titletext[]->puttext;
             *                              ' '->puttext;
             *                              x1->putint;
             *                              newline;
             *                              (if gppProp.showAttributes then
             *                                  (if not thePatternDeclDiagram.localNodes.empty
             *                                   then
             *                                      (thePatternDeclDiagram.localNodes.last).elm
             *                                      .center->(x1,y1);
             *                                      (maxY,y1)->max->maxY
             *                                  if)
             *                              if);
             *                              (if h.next.first.next[] <> none then
             *                                  h.next.first.next[]->h.next.first[];
             *                                  restart loop
             *                               else
             *                                  (if h.next.next[] <> none then
             *                                      ((y,maxY)->max)+gppProp.DownFromPrefix->y;
             *                                      h.next.next[]->h.next[];
             *                                      restart loop
             *                                  if)
             *                              if)
             *                           #)
             *                     if)
             *                 if)
             *              else
             *                 
             *             if)
             *  
             *)
            
         else
            'h is NONE!'->putline
        if)
     #)  

-- edgeSpecializations: DoPart --
do
     (#
        subList: ^DiagramList;
        x,y,lx,ly,x1,y1,yMin: @integer;
        p: [8] @integer
     do
        thePatternDeclDiagram.titleNode.center->(x,y);
        (if thePatternDeclDiagram.localNodes.empty then
            (x,y)->(lx,ly)
         else
            (thePatternDeclDiagram.localNodes.last).elm.center->(lx,ly)
        if);
        thePatternDeclDiagram[]
          ->PatternDiagrams.inheritanceList.GetSubPatternDiagrams->subList[];
        maxInt->yMin;
        subList.scan
          (# 
          do current.e.titleNode.center->(x1,y1); (y1,yMin)->min->yMin
          #);
        subList.scan
          (# 
          do
             current.e.titleNode.center->(x1,y1);
             x1->p[3];
             (ly+yMin) div 2->p[4];
             lx->p[5];
             (ly+yMin) div 2->p[6];
             p->(current.e.titleNode.thePrefixConn).points;
             x1->p[3];
             (y+yMin) div 2->p[4];
             x->p[5];
             (y+yMin) div 2->p[6];
             p->(current.e.titleNode.theSimplePrefixConn).points;
             current.e[]->edgeSpecializations
          #)
     #)  

-- gppChangedFocus: Descriptor --
(# 
do (* true->OKtoChange;*)
   currentFocus[]->oldFocus[];
   newObject[]
     ->CurrentFocus[]
     (*  else
      oldObject[]->currentObject
      if)*) ;
   (*  currentFocus[]->currentObject (#  do true->autoPan #); *)
   (* (if OKToChange then*)
   INNER changedFocus
#)  

-- ASTtoNearestNode: DoPart --
do
   anAST[]->ASTtoNode->node[];
   (if node[] = none then
       L:
       (if true then
           anAST.father->anAST[];
           (if anAST[] <> none then
               anAST[]->ASTtoNode->node[];
               (if node[] = none then restart L if);
               
           if)
       if);
       
   if)  

-- sifNotificationNewFragment: DoPart --
do
   INNER ;
   (if switch[40] // true then 'Gpp ------- newFragment'->putLine;  if);
   ;
     

-- propertiesChanged: DoPart --
do
   scanner: PatternDiagrams.theList.scanPropertyDiagrams
     (# 
     do
        (if fg[] = thisDiagram.theGroup then
            thisDiagram.redisplay; leave scanner; 
        if);
        
     #);
   autosave  

-- fragmentChanged: DoPart --
do
     (# foundDiagram: ^ListDiagram
     do
        FragmentDiagram##
          ->ScanDiagrams
            (# theDiagram: ^FragmentDiagram; theRegionList: ^ObjectList
            do
               current[]->theDiagram[];
               (if ff.father
                // theDiagram.theGroup then (* find formname in the diagram *)
                   theDiagram[]->foundDiagram[];
                   theDiagram.localnodes.scan
                     (#
                        theFragmentNode: ^theDiagram.FragmentNode;
                        t: ^text;
                        index: @integer;
                        w1,h1: @integer;
                        
                     do
                        current[]->theFragmentNode[];
                        (if ff[] = theFragmentNode.theFragment then
                            ff[]->theFragmentNode.redisplay;
                            (if theFragmentNode.currentDecomposDiagram <> none
                             then
                                (ff.father).name->t[];
                                '/'->t.findAll (#  do inx->index #);
                                (index+1,t.length)->t.sub->t[];
                                '-'->t.put;
                                theFragmentNode.theName->t.puttext;
                                t
                                  ->
                                    (theFragmentNode.currentDecomposDiagram).
                                    titleNode.theText.set;
                                (theFragmentNode.currentDecomposDiagram).
                                titleNode.getRegionList->theRegionList[];
                                (if theRegionList[] <> none then
                                    theRegionList.scan
                                      (# anObj: ^DesignObject
                                      do current[]->anObj[]; anObj.unmakeRegion
                                      #);
                                    
                                if);
                                (theFragmentNode.currentDecomposDiagram).
                                titleNode.FitToText;
                                (theFragmentNode.currentDecomposDiagram).
                                titleNode.Size->(w1,h1);
                                ((w1,gppProp.titleWidth)->max,h1)
                                  ->
                                    (theFragmentNode.currentDecomposDiagram).
                                    titleNode.size;
                                (if theRegionList[] <> none then
                                    theRegionList.scan
                                      (# anObj: ^DesignObject
                                      do
                                         current[]->anObj[];
                                         (theFragmentNode.currentDecomposDiagram
                                         ).titleNode[]->anObj.createRegion
                                      #)
                                if);
                                t
                                  ->
                                    (theFragmentNode.currentDecomposDiagram).
                                    titleText
                            if)
                        if)
                     #)
               if)
            #);
        (if foundDiagram[] <> none then
            foundDiagram.localNodes.adjustsizes; autosave
        if)
     #)  

-- fragmentInserted: DoPart --
do
   FragmentDiagram##
     ->ScanDiagrams
       (# theDiagram: ^FragmentDiagram; pos: @integer
       do
          current[]->theDiagram[];
          (if ff.father
           // theDiagram.theGroup then (* find formname in the diagram *)
              1->pos;
              scanner: (ff.father).fragmentList.scan
                (# 
                do
                   (if current.type
                    // mps.linkType then (* ignore *)
                       
                    // mps.groupType then
                       'Groups in groups not suported'->putline; 
                    // mps.formType then
                       (if current.f[] = ff[] then
                           leave scanner
                        else
                           pos+1->pos
                       if);
                       
                   if);
                   
                #);
              (pos-1,ff[])->theDiagram.insertFragmentNode
          if)
       #);
   autosave  

-- fragmentDeleted: DoPart --
do
   scanner:
   FragmentDiagram##
     ->ScanDiagrams
       (# theDiagram: ^FragmentDiagram; pos: @integer
       do
          current[]->theDiagram[];
          (if ff.father = theDiagram.theGroup then
              theDiagram.localNodes.scan
                (# theFragmentNode: ^theDiagram.FragmentNode
                do
                   current[]->theFragmentNode[];
                   (if ff[] = theFragmentNode.theFragment then
                       theFragmentNode[]->theDiagram.deleteFragmentNode;
                       leave scanner
                   if)
                #)
          if)
       #);
   autosave  

-- astReplaced: DoPart --
do
   thisOp:
     (#
        theObject: ^PatternDiagramNode;
        pos: @integer;
        theDiagram: ^Diagram;
        doListReplace: @boolean;
        deleted: @boolean;
        dummyFilter: ##external;
        pageList: ^ObjectList;
        filename: @Text;
        nonterminalName: ^Text;
        cancelled: ^integerRef;
        prompt: @text;
        count: @ShortRef;
        list: @IntegerRef;
        theListDiagram: ^ListDiagram;
        theAbstractNode: ^theListDiagram.AbstractNode;
        theunexp: ^mps.unexpanded;
        
     do
        (if switch[60]
         // true then
            'Gpp ------- astReplaced  '->puttext;
            'oldindex: '->putText;
            oldAst.index->putInt;
            '  '->puttext;
            'newindex: '->putText;
            newAst.index->putInt;
            newLine;
            
        if);
        (if oldAST.kind
         // mps.kinds.unExpanded then
         (* this is an ECOOP94 hack, must be generalized
          TOBY: - meanwhile I think it has been :-) *)
            (if newAst.kind
             // mps.kinds.interior then
                (if switch[60]
                 // true then 'expanding a nonterminal'->putLine; 
                if);
                (if NewAST## <= betaGram.attributeDecl## then
                    (if switch[60] then
                        'It is a declaration: '->putText;
                        NewAST.symbol->putInt;
                        newLine;
                        
                    if);
                    true->doListReplace;
                    
                if);
                
             // mps.kinds.optional then
                oldAST[]->ASTtoNode->theObject[];
                (if theObject[] <> none then
                    theObject.theDiagram->theDiagram[];
                    (theObject[],true)->theDiagram.deleteDiagramNode;
                    true->deleted;
                    
                 else
                    leave thisOp
                if)
             // mps.kinds.unExpanded then
                (if switch[60] then
                    'astReplaced: unExpanded replacing unExpanded'->putline
                if)
            if)
         // mps.kinds.interior then
            oldAST[]->patternDiagrams.AssociationList.update;
            oldAST[]->patternDiagrams.InheritanceList.update;
            oldAST[]->patternDiagrams.AggregationList.update;
            (if newAST.kind
             // mps.kinds.interior then
                (if oldAST## <= betaGram.attributeDecl## then
                    (if newAST## <= betaGram.attributeDecl## then
                        (if oldAST## <> newAST## then true->doListReplace if)
                    if)
                if)
             // mps.kinds.optional then
                oldAST[]->ASTtoNode->theObject[];
                (if theObject[] <> none then
                    theObject.theDiagram->theDiagram[];
                    (theObject[],true)->theDiagram.deleteDiagramNode;
                    true->deleted;
                    
                 else
                    leave thisOp
                if)
             else
            (* updateDiagramNode *)
                
            if)
         // mps.kinds.optional then
            (if newAST.kind = mps.kinds.unexpanded then
                newAST[]->theunexp[];
                theunexp.nonTerminalSymbol->betaGram.symbolToName
                  ->nonterminalName[];
                (if 'AttributeDeclOpt'->nonterminalName.equal then
                    oldAst[]->ASTtoNearestNode->theObject[];
                    (if theObject[] <> none then
                        theObject.theDiagram->theListDiagram[];
                        (if theObject## <= theListDiagram.AbstractNode## then
                            theObject[]->theAbstractNode[];
                            (if theAbstractNode.currentDecomposDiagram <> none
                             then
                                (newAST.sonNo-1,newAST[])
                                  ->
                                    (theAbstractNode.currentDecomposDiagram).
                                    insertDiagramNode;
                                leave thisOp
                            if)
                        if)
                     else
                        'astReplaced: theObject is none'->putline; leave thisOp
                    if)
                if)
            if)
        if);
        (if doListReplace then
            oldAST[]->ASTtoNode->theObject[];
            (if theObject[] <> none then
                theObject.theDiagram->theDiagram[];
                (*
                 (theObject[],true)->theObject.theDiagram.deleteDiagramNode;
                 (pos,newAST[])->theDiagram.insertDiagramNode;    
                 * *)
                (theObject[],newAST[])->theDiagram.replaceDiagramNode;
                
            if)
         else
            (if not deleted then
                oldAST[]->ASTtoNearestNode->theObject[];
                (if theObject[] <> none then
                    (oldAst[],newAst[])
                      ->(theObject.theDiagram).updateDiagramNode
                 else
                    'astReplaced: theObject is none'->putline
                if)
            if);
            
        if);
        Redraw;
        autosave;
        
     #)  

-- listElementInserted: Descriptor --
(#
   theObject: ^PatternDiagramNode;
   newAst,firstBorn: ^mps.ast;
   pos,i,noOfSons: @integer
do
   (if switch[60]
    // true then
       'Gpp ------- listElementInserted  '->puttext;
       'fatherIndex: '->putText;
       father.index->putInt;
       '  '->puttext;
       'position: '->putText;
       position->putInt;
       newLine;
       
   if);
   (if position = 1 then
       father.getSon2->firstBorn[]
    else
       father.getson1->firstBorn[]
   if);
   (if firstBorn.kind = mps.kinds.optional then
       father.noOfSons->noOfSons;
       2->i;
       loop:
         (# 
         do
            (if noOfSons >= i then
                i->father.get->firstBorn[];
                (if (firstBorn.kind = mps.kinds.optional) or (position = i) then
                    i+1->i; restart loop
                if)
             else
                none ->firstBorn[]
            if)
         #)
   if);
   position->pos->father.get->newAST[];
   1->i;
   scanner: father.scan
     (# 
     do
        (if not (i = position) then
            (if current.kind = mps.kinds.optional then pos-1->pos if); i+1->i
         else
            leave scanner
        if)
     #);
   firstBorn[]->ASTtoNearestNode->theObject[];
   (if theObject[] <> none then
       (pos-1,newAST[])->(theObject.theDiagram).insertDiagramNode;
       Redraw;
       autosave
    else
       'listElementInserted: theObject is none'->putline
   if)
#)  

-- listElementsDeleted: Descriptor --
(# theObject: ^PatternDiagramNode
do
   (if switch[60]
    // true then 'Gpp ------- listElementsDeleted'->putLine; 
   if);
   (for i: length repeat
     oldElements[i][]->patternDiagrams.AssociationList.update;
     oldElements[i][]->patternDiagrams.InheritanceList.update;
     oldElements[i][]->patternDiagrams.AggregationList.update;
     oldElements[i][]->ASTtoNode->theObject[];
     (if theObject[] <> none then
         (theObject[],true)->(theObject.theDiagram).deleteDiagramNode; 
     if)
   for);
   Redraw;
   autosave;
   
#)  

-- listElementsReplaced: Descriptor --
(#
(* changeSpec:
 * <fatherIndex> <position> <length> <oldElements> <newLength> 
 * <oldElements> ::= { <elementIndex> } i    (i = <length>)
 *)
   oldAst,newAst,anAST: ^mps.ast;
   theDiagram: ^Diagram;
   pos,oldIndex,j: @integer;
   theObject: ^PatternDiagramNode
do
   (if switch[60]
    // true then 'Gpp ------- listElementsReplaced'->putLine; 
   if);
   (for i: length repeat
     oldElements[i][]->patternDiagrams.AssociationList.update;
     oldElements[i][]->patternDiagrams.InheritanceList.update;
     oldElements[i][]->patternDiagrams.AggregationList.update;
     oldElements[i][]->ASTtoNode->theObject[];
     (if theObject[] <> none then
         theObject.theDiagram->theDiagram[];
         (theObject[],true)->(theObject.theDiagram).deleteDiagramNode;
         
     if)
   for);
   (for i: newlength repeat
     position+i-1->pos->father.get->newAST[];
     (if not (newAST.kind = mps.kinds.optional) then
         (if theDiagram[] = none then
             'Gpp: ListElementsReplaced: theDiagram is none!!'->putLine
          else
             1->j;
             scanner: father.scan
               (# 
               do
                  (if not (j = position+i-1) then
                      (if current.kind = mps.kinds.optional then
                          pos-1->pos
                      if);
                      j+1->j
                   else
                      leave scanner
                  if)
               #);
             (pos-1,newAST[])->theDiagram.insertDiagramNode
         if)
     if);
     
   for);
   Redraw;
   autosave;
   
#)  

-- ScanDiagrams: Descriptor --
(# 
do
   PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->THIS(ScanDiagrams).current[];
        (if theDiagramType##
         // none then INNER ScanDiagrams; 
         else
            (if current.e## <= theDiagramType##
             // true then INNER ScanDiagrams; 
            if)
        if)
     #)
#)  

-- MarkNodeDisplay: Descriptor --
(# 
do
   (pos.x,pos.y,gppProp.marksize,gppProp.marksize)->new;
   theNode[]->thePatternDiagramNode;
   THIS(MarkNode)[]->(thePatternDiagramNode).theMarkNode;
   false->sizeable;
   
#)  

-- MarkNodeOnInit: Descriptor --
(# 
do
   UDPrivate.UDMarkNode->UserDataInit;
   thePatternDiagramNode.Init;
   6->theText.size;
   false->moveable;
   false->sizeable;
   (if not initialisingSaved then theNode[]->CreateRegion if);
   
#)  

-- titleGetFragment: Descriptor --
(# fn: ^FragmentNode; 
do
   (if theFragmentNode <> none
    // true then theFragmentNode->fn[]; fn.theFragment->f[]; 
    else
       'DiagramNode: GetFragment: no FragmentNode'->screen.putline
   if)
#)  

-- ListDiagramTitleDump: DoPart --
do
   '********theSurroundBox********'->putline;
   (if theSurroundBox <> none then
       (theSurroundBox).ID->putint; newline
    else
       'is NONE!'->putline
   if);
   '********MaxHeight********'->putline;
   MaxHeight->putint;
   newline;
   '********MaxWidth********'->putline;
   MaxWidth->putint;
   newline  

-- SurroundBoxOnInit: DoPart --
do UDPrivate.UDSurroundBox->UserDataInit; false->selectable; false->sizeable  

-- UserdataLabelNodeVisibleSet: DoPart --
do
   (if v then
       invisibleText->help[];
       help->theText.set;
       none ->invisibleText;
       true->selectable
    else
       (if theText.length > 0 then
           theText.get->t; t[]->invisibleText; theText.clear
       if);
       false->selectable
   if)  

-- UserDataLabelNodeVisibleGet: DoPart --
do (if invisibleText <> none then true->v else  if)  

-- UserDataLabelNodeNew: DoPart --
do
   (THIS(Page).ID,x->wcoord,y->wcoord,w->wcoord,h->wcoord,txt)->DSStrCreateLabel
     ->onInit;
   INNER new;
     

-- UserDataLabelNodeOnInit: DoPart --
do
   UDPrivate.UDLabelNode->UserDataInit;
   invisibleText.init;
   gppProp.fontSize->theText.size  

-- DeletableConnectorGetOtherEnd: Descriptor --
(# node1,node2: ^IDObject
do
   true->getEnds->(node1[],node2[]);
   (if (Start[] = node1[]) or (Start[] = node2[]) then
       (if Start[] = node1[] then
           node2[]->OtherEnd[]
        else
           node1[]->OtherEnd[]
       if)
    else
       (if switch[1] then
           'GetOtherEnd: Start is not in either end'->putline
       if)
   if)
#)  

-- AggregationRoleDisplay: DoPart --
do
   (if leftRole = none then
       (x+gppProp.halfDiamondNodeWidth,y)->move; true->BorderVisible
   if);
   INNER display  

-- AggregationRoleRedisplay: DoPart --
do
   (if THIS(Role)[] = leftRole then
       (if private.kind = gppProp.byValue then
           1 (* Black *) ->fillType; redraw; 'filltype set to 1'->putline
        else
           0->fillType; redraw; 'filltype set to 0'->putline
       if)
   if)  

-- AggregationRoleNew: DoPart --
do
   (if leftRole = none then
       0->p[1];
       - gppProp.halfDiamondNodeHeight->p[2];
       gppProp.halfDiamondNodeWidth->p[3];
       0->p[4];
       0->p[5];
       gppProp.halfDiamondNodeHeight->p[6];
       - gppProp.halfDiamondNodeWidth->p[7];
       0->p[8];
       (for i: p.range repeat p[i]->wcoord->p[i] for);
       (theWorkPage.ID,4,@@ p[1])->DSStrCreatePolygon->onInit;
       (if private.kind = gppProp.byValue then 1 (* Black *) ->fillType if);
       (x,y)->move;
       true->doneInInner
   if)  

-- AggregationRoleOnInit: DoPart --
do INNER onInit  

-- GeneralRelationshipOnInit: DoPart --
do 0->Orient  

-- RoleDisplay: DoPart --
do
   theNode.geometry->(x,y,w,h);
   (if leftRole = none (* then we are creating the left role *) then
       x+w div 2->x
    else
       x-w div 2->x
   if);
   (x,y,0,0)->new;
   false->BorderVisible;
   false->selectable;
   theNode[]->CreateRegion;
   (if theName[] <> none (* role names are optional *) then
       &UserDataLabelNode[]->l[];
       (x,y,10,10,theName)->l.new;
       l.fitToText;
       l.geometry->(lx,ly,lw,lh);
       (if leftRole = none then x+lw div 2+5->lx else x-lw div 2-5->lx if);
       y-10->ly;
       (lx,ly)->l.move;
       THIS(Role)[]->l.createRegion;
       l[]->name
   if);
   &UserDataLabelNode[]->l[];
   &text[]->mul[];
   (if multiplicityFrom < 0 then
       '*'->mul[]
    else
       multiplicityFrom->mul.putint;
       (if multiplicityFrom <> multiplicityTo then
           '..'->mul.puttext;
           (if multiplicityTo < 0 then
               '*'->mul.puttext
            else
               multiplicityTo->mul.putint
           if)
       if)
   if);
   (x,y,10,10,mul)->l.new;
   l.fitToText;
   l.geometry->(lx,ly,lw,lh);
   (if leftRole = none then x+lw div 2+5->lx else x-lw div 2-5->lx if);
   y+10->ly;
   (lx,ly)->l.move;
   THIS(Role)[]->l.createRegion;
   l[]->multiplicity;
   theNode[]->thePatternDiagramNode;
   INNER display  

-- RoleRedisplay: DoPart --
do
   (if theName[] <> none then
       (if name <> none then
           theName->(name).theText.set
        else
           &UserDataLabelNode[]->l[];
           (x,y,10,10,theName)->l.new;
           l.fitToText;
           l.geometry->(lx,ly,lw,lh);
           (if leftRole = THIS(Role)[] then
               x+lw div 2+5->lx
            else
               x-lw div 2-5->lx
           if);
           y-10->ly;
           (lx,ly)->l.move;
           THIS(Role)[]->l.createRegion;
           l[]->name
       if)
   if);
   &text[]->mul[];
   (if multiplicityFrom < 0 then
       '*'->mul[]
    else
       multiplicityFrom->mul.putint;
       (if multiplicityFrom <> multiplicityTo then
           '..'->mul.puttext;
           (if multiplicityTo < 0 then
               '*'->mul.puttext
            else
               multiplicityTo->mul.putint
           if)
       if)
   if);
   mul->(multiplicity).theText.set;
   INNER redisplay  

-- RoleOnInit: DoPart --
do
   UDPrivate.UDRole->UserDataInit;
   name.init;
   Multiplicity.init;
   thePatternDiagramNode.init;
   false->selectable;
   false->sizeable;
   INNER onInit  

-- RoleDump: DoPart --
do
   '****name****'->putline;
   (if name <> none then
       (name).theText.get->t; t[]->putline
    else
       ' is NONE!'->putline
   if);
   '****Multiplicity****'->putline;
   (if Multiplicity <> none then
       (Multiplicity).theText.get->t; t[]->putline
    else
       ' is NONE!'->putline
   if);
   '****thePatternDiagramNode****'->putline;
   (if thePatternDiagramNode <> none then
       (thePatternDiagramNode).id->putint; newline
    else
       ' is NONE!'->putline
   if)  

-- AssociationConnectorGenerateCode: DoPart --
do
   true->ok;
   INNER generateCode;
   (if not doneInInner then
         (#
            theParentNode,lastNode: ^PatternDiagramNode;
            theNonTerminalNode: ^theParentDiagram.NonTerminalNode;
            theListDiagram,theOtherListDiagram,theParentDiagram: ^ListDiagram;
            theOADDiagram,theOtherOADDiagram: ^OADDiagram;
            anAST,anotherAST,testAST,testAST2,lastAST,aDeclAST,anotherDeclAST:
              ^mps.ast;
            theDesc,theOtherDesc: ^betaGram.ObjectDescriptor;
            anExp,anotherExp: ^mps.expanded;
            theNames,theOtherNames: ^betaGram.Names;
            theNameDcl,theOtherNameDcl: ^betaGram.NameDcl;
            help,indextext: @Text;
            t,theLeftName,theRightName,dummyQual: ^Text;
            index: @integer;
            isManyToMany:
              (# 
              exit ((leftMulTo = - 1) or (leftMulTo > 1)) and
              ((rightMulTo = - 1) or (rightMulTo > 1))
              #);
            isOneToMany:
              (# 
              exit ((leftMulTo = 0) or (leftMulTo = 1)) and
              ((rightMulTo = - 1) or (rightMulTo > 1))
              #);
            isManyToOne:
              (# 
              exit ((leftMulTo = - 1) or (leftMulTo > 1)) and
              ((rightMulTo = 0) or (rightMulTo = 1))
              #);
            parseAfter:
              (#
                 theListDiagram: ^ListDiagram;
                 parseText: ^text;
                 theNonTerminalNode: ^theListDiagram.NonTerminalNode;
                 anAST: ^mps.ast
              enter (theListDiagram[],parseText[])
              do
                 currentFocus[]->oldFocus[];
                 (theListDiagram.LocalNodes.last).elm[]->currentFocus[]
                   ->currentObject;
                 currentFocus.getASTNode->anAST[];
                 (if anAST[] <> none then
                     (anAST[],1)->(currentFocus.theSifEditor).changeFocus
                  else
                     currentFocus[]->theNonTerminalNode[];
                     (theNonTerminalNode.unExp,1)
                       ->(currentFocus.theSifEditor).changeFocus
                 if);
                 (currentFocus.theSifEditor).after;
                 currentFocus[]->theNonTerminalNode[];
                 (theNonTerminalNode.unExp,parseText)
                   ->(theNonTerminalNode.theSifEditor).parse
              #)
         do
            aPatternDiagramNode.theDiagram->theListDiagram[];
            anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
            (if (theListDiagram## <= FragmentDiagram##) or
            (theOtherListDiagram## <= FragmentDiagram##) then
                'Source and/or destination is a fragment diagram'->AlertUser;
                false->ok
             else
                (if (theListDiagram## <= PatternAttDiagram##) or
                (theOtherListDiagram## <= PatternAttDiagram##) then
                    'Source and/or destination is an attributes form diagram'
                      ->AlertUser;
                    false->ok
                 else
                    (if theListDiagram.localNodes.empty then
                        theListDiagram.titleNode.getASTNode->anAST[];
                        (if anAST[] <> none then
                            (anAST[],1)
                              ->
                                (theListDiagram.titleNode.theSifEditor).
                                changeFocus
                        if);
                        (theListDiagram.titleNode.theSifEditor).insertOptionals
                    if);
                    (if theOtherListDiagram.localNodes.empty then
                        theOtherListDiagram.titleNode.getASTNode->anAST[];
                        (if anAST[] <> none then
                            (anAST[],1)
                              ->
                                (theOtherListDiagram.titleNode.theSifEditor).
                                changeFocus
                        if);
                        (theOtherListDiagram.titleNode.theSifEditor).
                        insertOptionals
                    if);
                    theListDiagram[]->theOADDiagram[];
                    theOtherListDiagram[]->theOtherOADDiagram[];
                    theOADDiagram.theDescriptor->theDesc[];
                    theOtherOADDiagram.theDescriptor->theOtherDesc[];
                    theDesc.father->anAST[];
                    theOtherDesc.father->anotherAST[];
                    anAST.father->testAST[];
                    anotherAST.father->testAST2[];
                    (if (testAST[] <> none ) and (testAST2[] <> none ) then
                        (if (anAST.symbol <> betaGram.StaticItem) and
                        (anotherAST.symbol <> betaGram.StaticItem) then
                            (if theListDiagram[] <> theOtherListDiagram[] then
                                theListDiagram.theParentNode->theParentNode[];
                                theParentNode.theDiagram->theParentDiagram[];
                                (theParentDiagram.localNodes.last).elm[]
                                  ->lastNode[];
                                lastNode.getAstNode->lastAST[];
                                (if lastAST[] = none then
                                    (if lastNode## <=
                                    theParentDiagram.NonterminalNode## then
                                        lastNode[]->theNonTerminalNode[];
                                        theNonTerminalNode.unexp->lastAST[]
                                     else
                                        'No AST for last node??'->stdErr.putline
                                    if)
                                if);
                                (if lastAST[] <> none then
                                    anAST[]->anExp[];
                                    (if leftRoleName[] <> none then
                                        leftRoleName.copy->theleftName[]
                                     else
                                        anExp.getSon1->theNames[];
                                        theNames.getSon1->theNameDcl[];
                                        theNameDcl.getNameDecl->aDeclAST[];
                                        (if aDeclAST.kind = mps.kinds.unExpanded
                                         then
                                            'NoName'->theLeftName[]
                                         else
                                            theNameDcl.getText->theLeftName[]
                                        if)
                                    if);
                                    anotherAST[]->anotherExp[];
                                    (if rightRoleName[] <> none then
                                        rightRoleName.copy->theRightName[]
                                     else
                                        anotherExp.getSon1->theOtherNames[];
                                        theOtherNames.getSon1
                                          ->theOtherNameDcl[];
                                        theOtherNameDcl.getNameDecl
                                          ->anotherDeclAST[];
                                        (if anotherDeclAST.kind =
                                        mps.kinds.unExpanded then
                                            'NoName'->theRightName[]
                                         else
                                            theOtherNameDcl.getText
                                              ->theRightName[]
                                        if)
                                    if);
                                    (if theName[] <> none then
                                        theName.copy->t[]
                                     else
                                        theLeftName.copy->t[];
                                        theRightName[]->t.puttext
                                    if);
                                    (if implementation
                                     // gppProp.noimplementation then
                                        ':OneToOneAssociation(# leftType::< '
                                          ->t.puttext;
                                        (lastAST[],anAST[])
                                          ->getQualificationWithPath->t.puttext;
                                        '; rightType::< '->t.puttext;
                                        (lastAST[],anotherAST[])
                                          ->getQualificationWithPath->t.puttext;
                                        ' #) '->t.puttext
                                     // gppProp.list then
                                        (if true
                                         // isManyToMany then
                                            ':ManyToManyAssociation(# leftType::< '
                                              ->t.puttext;
                                            (lastAST[],anAST[])
                                              ->getQualificationWithPath
                                              ->t.puttext;
                                            '; rightType::< '->t.puttext;
                                            (lastAST[],anotherAST[])
                                              ->getQualificationWithPath
                                              ->t.puttext;
                                            ' #) '->t.puttext
                                         // isOneToMany then
                                            ':OneToManyAssociation(# oneType::< '
                                              ->t.puttext;
                                            (lastAST[],anAST[])
                                              ->getQualificationWithPath
                                              ->t.puttext;
                                            '; ManyElmType::< '->t.puttext;
                                            (lastAST[],anotherAST[])
                                              ->getQualificationWithPath
                                              ->t.puttext;
                                            ' #) '->t.puttext
                                         // isManyToOne then
                                            ':OneToManyAssociation(# oneType::< '
                                              ->t.puttext;
                                            (lastAST[],anotherAST[])
                                              ->getQualificationWithPath
                                              ->t.puttext;
                                            '; ManyElmType::< '->t.puttext;
                                            (lastAST[],anAST[])
                                              ->getQualificationWithPath
                                              ->t.puttext;
                                            ' #) '->t.puttext
                                        if)
                                     else
                                        'Implementation not implemented yet :-)'
                                          ->alertUser
                                    if);
                                    (theParentDiagram[],t[])->parseAfter;
                                    currentFocus[]->associationNode;
                                    t.clear;
                                    (theListDiagram.localNodes.last).elm[]
                                      ->lastNode[];
                                    lastNode.getAstNode->lastAST[];
                                    (if lastAST[] = none then
                                        (if lastNode## <=
                                        theListDiagram.NonterminalNode## then
                                            lastNode[]->theNonTerminalNode[];
                                            theNonTerminalNode.unexp->lastAST[]
                                         else
                                            'No AST for last node??'
                                              ->stdErr.putline
                                        if)
                                    if);
                                    (if lastAST[] <> none then
                                        (if rightRoleName[] <> none then
                                            rightRoleName[]->t.puttext
                                         else
                                            'the'->t.puttext;
                                            theLeftName[]->t.puttext;
                                            theRightName[]->t.puttext
                                        if);
                                        ':^'->t.puttext;
                                        (if theName[] <> none then
                                            theName[]->t.puttext
                                         else
                                            theLeftName[]->t.puttext;
                                            theRightName[]->t.puttext
                                        if);
                                        (theListDiagram[],t[])->parseAfter;
                                        currentFocus[]->left[]
                                    if);
                                    t.clear;
                                    (theOtherListDiagram.localNodes.last).elm[]
                                      ->lastNode[];
                                    lastNode.getAstNode->lastAST[];
                                    (if lastAST[] = none then
                                        (if lastNode## <=
                                        theOtherListDiagram.NonterminalNode##
                                         then
                                            lastNode[]->theNonTerminalNode[];
                                            theNonTerminalNode.unexp->lastAST[]
                                         else
                                            'No AST for last node??'
                                              ->stdErr.putline
                                        if)
                                    if);
                                    (if lastAST[] <> none then
                                        (if leftRoleName[] <> none then
                                            leftRoleName[]->t.puttext
                                         else
                                            'the'->t.puttext;
                                            theLeftName[]->t.puttext;
                                            theRightName[]->t.puttext
                                        if);
                                        ':^'->t.puttext;
                                        (lastAST[],anAST[])
                                          ->getQualificationWithPath
                                          ->dummyQual[];
                                        '.'
                                          ->dummyQual.findAll
                                            (#  do inx->index #);
                                        (index+1,dummyQual.length)
                                          ->dummyQual.delete;
                                        dummyQual[]->t.puttext;
                                        (if theName[] <> none then
                                            theName[]->t.puttext
                                         else
                                            theLeftName[]->t.puttext;
                                            theRightName[]->t.puttext
                                        if);
                                        (theOtherListDiagram[],t[])->parseAfter;
                                        currentFocus[]->right[]
                                    if)
                                 else
                                    'lastAST is NONE??'->stdErr.putline
                                if)
                             else
                                'Source and destination is the same diagram'
                                  ->AlertUser;
                                false->ok
                            if)
                         else
                            'Source and/or destination is singularly defined'
                              ->AlertUser;
                            false->ok
                        if)
                     else
                        'Source and/or destination is a descriptor form diagram'
                          ->AlertUser;
                        false->ok
                    if)
                if)
            if)
         #)
   if)  

-- AssociationConnectorGetValuesFromCode: DoPart --
do INNER getValuesFromCode; (if not doneInInner then  if)  

-- AssociationConnectorGetEnds: DoPart --
do
   (if (leftRole <> none ) and (rightRole <> none ) then
       (leftRole).thePatternDiagramNode->node1[];
       (rightRole).thePatternDiagramNode->node2[]
    else
       'left and/or right role is none!?'->putline
   if)  

-- AssociationConnectorSetEnds: DoPart --
do INNER setends  

-- AssociationConnectorInteractiveNew: DoPart --
do
   name[]->private.name[];
   implementation->private.implementation;
   leftRoleName[]->private.leftRoleName[];
   rightRoleName[]->private.rightRoleName[];
   leftMulFrom->private.leftMulFrom;
   leftMulTo->private.leftMulTo;
   rightMulFrom->private.rightMulFrom;
   rightMulTo->private.rightMulTo;
   description[]->private.description[];
   INNER interactiveNew  

-- AssociationConnectorRedisplay: DoPart --
do
   name[]->private.name[];
   implementation->private.implementation;
   leftMulFrom->private.leftMulFrom;
   leftMulTo->private.leftMulTo;
   rightMulFrom->private.rightMulFrom;
   rightMulTo->private.rightMulTo;
   description[]->private.description[];
   (if not (THIS(AssociationConnector)## <= AggregationConnector##) then
       (if (name[] <> none ) and (not ('<<NameDecl>>'->name.equal)) then
           name->(THIS(AssociationConnector).name).theText.set
       if)
   if);
   INNER redisplay;
   (none ,leftMulFrom,leftMulTo)->(leftRole).redisplay;
   (none ,rightMulFrom,rightMulTo)->(rightRole).redisplay;
   gppProp.noGlobalInteractiveMode->gppProp.globalInteractiveMode  

-- AssociationConnectorOnDelete: DoPart --
do INNER onDelete  

-- AssociationConnectorOnReattach: DoPart --
do INNER onReattach  

-- AssociationConnectorOnDoubleClick: DoPart --
do INNER onDoubleClick  

-- AssociationConnectorOnInit: DoPart --
do
     (#
        nd1,nd2: @integerRef;
        node1,node2: ^node;
        succeded: @boolean;
        theRole: ^Role;
        lx,ly,rx,ry: @integer;
        l: ^UserDataLabelNode
     do
        (if switch[30] or switch[53] then
            'AssociationConnector onInit'->putline
        if);
        UDPrivate.UDAssociationConnector->UserDataInit;
        name.init;
        associationNode.init;
        leftRole.init;
        rightRole.init;
        0->Orient;
        INNER onInit;
        (if not InitialisingSaved then
            (ID,true,nd1[],nd2[])->DSRdAttrGetConnEnds;
            nd1->theObjectList.find->node1[];
            nd2->theObjectList.find->node2[];
            (if (node1[] <> none ) and (node2[] <> none ) then
                (if ((node1[]->BoxToNode->node1[]) <> none ) and
                ((node2[]->BoxToNode->node2[]) <> none ) then
                    (if (node1## <= PatternDiagramNode##) and
                    (node2## <= PatternDiagramNode##) then
                        (node1[],node2[],private.name.copy,
                         private.implementation,private.leftRoleName[],
                         private.rightRoleName[],private.leftMulFrom,
                         private.leftMulTo,private.rightMulFrom,
                         private.rightMulTo)->generateCode
                          ->(succeded,left[],right[]);
                        (if not succeded then delete if);
                        
                     else
                        Delete;
                        'Source or destination is not part of a pattern diagram'
                          ->AlertUser
                    if)
                 else
                    Delete;
                    'Source or destination is not part of a pattern diagram'
                      ->AlertUser
                if)
             else
                Delete
            if);
            (if (ID->theObjectList.find) <> none (*A connector was created*)
             then
                &Role[]->theRole[];
                (private.leftRoleName[],private.leftMulFrom,private.leftMulTo,
                 left[])->theRole.display;
                theRole[]->leftRole;
                &Role[]->theRole[];
                (private.rightRoleName[],private.rightMulFrom,
                 private.rightMulTo,right[])->theRole.display;
                theRole[]->rightRole;
                ((leftRole).getTopParent,leftRole,(rightRole).getTopParent,
                 rightRole)->setEnds;
                (if not
                (THIS(AssociationConnector)## <= AggregationConnector##) then
                    (if (private.name[] <> none ) and
                    (not ('<<NameDecl>>'->private.name.equal)) then
                        (leftRole).center->(lx,ly);
                        (rightRole).center->(rx,ry);
                        &UserDataLabelNode[]->l[];
                        (lx+((rx-lx) div 2),ly+((ry-ly) div 2),10,10,
                         private.name)->l.new;
                        l.fitToText;
                        (lx+((rx-lx) div 2),ly+((ry-ly) div 2)-10)->l.move;
                        THIS(AssociationConnector)[]->l.createRegion;
                        l[]->name
                    if)
                if)
            if);
            gppProp.noGlobalInteractiveMode->gppProp.globalInteractiveMode;
            statusbar.reset
        if)
     #)  

-- AssocConnectorDump: DoPart --
do
   '****name****'->putline;
   (if name <> none then
       (name).theText.get->t; t[]->putline
    else
       ' is NONE!'->putline
   if);
   '****associationNode****'->putline;
   (if associationNode <> none then
       (associationNode).id->putint; newline
   if);
   '****leftRole****'->putline;
   (if leftRole <> none then (leftRole).dump else ' is NONE!'->putline if);
   '****rightRole****'->putline;
   (if rightRole <> none then (rightRole).dump else ' is NONE!'->putline if);
   INNER dump  

-- AssociationConnectorPrivate: Descriptor --
(#
   name,description,leftRoleName,rightRoleName: ^text;
   implementation,leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer
#)  

-- AggregationConnectorOnDelete: DoPart --
do
   (if switch[54] then 'AggregationConnector onDelete'->putline if);
   ((leftRole).thePatternDiagramNode).getAstNode->anAST[];
   (if anAST[] <> none then
       (anAST[],1)
         ->(((leftRole).thePatternDiagramNode).theSifEditor).changeFocus;
       (((leftRole).thePatternDiagramNode).theSifEditor).cut
   if)  

-- AggregationConnectorOnReattach: DoPart --
do
   patternDiagrams.AggregationList.find
     (#
        theName,description: ^Text;
        kind,implementation: @integer;
        answer,x,y,w,h: @integer;
        succeded: @boolean;
        node1,node2,dummy: ^DesignObject;
        left,right: ^PatternDiagramNode;
        anAST: ^mps.ast;
        predicate:: 
          (# anAST: ^mps.ast
          do
             ((rightRole).thePatternDiagramNode).getASTNode->anAST[];
             (if not
             (anAST## <= betaGram.AttributeDecl##)
             (* in case it was a titlenode *) then
                 anAST[]->patternDiagrams.astUtils.getEnclosingDecl->anAST[]
             if);
             (if switch[54] then
                 'AggregationConnector onReattach - Comparing: %i %i and %i %i/n'
                   ->putformat
                     (# 
                     do
                        current.left->i;
                        (((leftRole).thePatternDiagramNode).getASTNode).index
                          ->i;
                        current.right->i;
                        anAST.index->i
                     #)
             if);
             (current.left =
              (((leftRole).thePatternDiagramNode).getASTNode).index) and
             ((((leftRole).thePatternDiagramNode).getASTNode).frag.fullname
                ->current.leftFrag.equal) and (current.right = anAST.index) and
             (anAST.frag.fullname->current.rightFrag.equal)->value
          #);
        notFound:: 
          (# 
          do
             ('Move Aggregation',
              'The aggregation code has been edited in Sif,\nCheck the program to insure consistency?\n\n- "No" will generate code as consistenly as\npossible with the current code.\n')
               ->promptForBoolean->answer;
             (if answer
              // yes then
                 false->ok;
                 ((leftRole).thePatternDiagramNode).getAstNode->anAST[];
                 (if anAST[] <> none then anAST.frag.father->callChecker if)
              // no then
                 true->getEnds->(node1[],node2[]);
                 (if switch[54] then
                     'AggregrationConnector onReattach: node1=%i node2=%i theNew=%i'
                       ->putformat
                         (#  do node1.id->i; node2.id->i; theNew.id->i #)
                 if);
                 getValuesFromCode->(theName[],implementation,private.kind);
                 (if whichEnd then
                     theNew[]->BoxToNode->theNew[];
                     (if theNew## <= PatternDiagramNode## then
                         (node1[],theNew[],theName[],implementation,none ,none ,
                          1,1,1,1,kind)->generateCode
                           ->(succeded,left[],right[]);
                         (if succeded then
                             whichEndUpdateRoles
                          else
                             false->ok
                         if)
                      else
                         'The relation has been attached to a node that is not part of a pattern diagram'
                           ->AlertUser;
                         false->ok
                     if)
                  else
                     'Moving simpleDecl end of relation not yet implemented'
                       ->AlertUser;
                     false->ok
                 if)
              // cancel then
                 false->ok
             if)
          #);
        whichEndUpdateRoles:
          (# 
          do
             (rightRole).unMakeRegion;
             right[]->(rightRole).thePatternDiagramNode;
             (none ,current.leftMulFrom,current.leftMulTo)
               ->(leftRole).redisplay;
             (none ,current.rightMulFrom,current.rightMulTo)
               ->(rightRole).redisplay;
             ((leftRole).getTopParent,leftRole,(rightRole).getTopParent,
              rightRole)->setEnds;
             false->ok;
             right.geometry->(x,y,w,h);
             x-w div 2->x;
             (x,y)->(rightRole).move;
             right[]->(rightRole).createRegion
          #)
     do
        true->getEnds->(node1[],node2[]);
        (if switch[54] then
            'AggregrationConnector onReattach: node1=%i node2=%i theNew=%i'
              ->putformat (#  do node1.id->i; node2.id->i; theNew.id->i #)
        if);
        getValuesFromCode->(theName[],implementation,kind);
        (if whichEnd then
            theNew[]->BoxToNode->theNew[];
            (if theNew## <= PatternDiagramNode## then
                (node1[],theNew[],theName[],implementation,none ,none ,
                 current.leftMulFrom,current.leftMulTo,current.rightMulFrom,
                 current.rightMulTo,kind)->generateCode
                  ->(succeded,left[],right[]);
                (if succeded then whichEndUpdateRoles else false->ok if)
             else
                'The relation has been attached to a node that is not part of a pattern diagram'
                  ->AlertUser;
                false->ok
            if)
         else
            'Moving simpleDecl end of relation not yet implemented'->AlertUser;
            false->ok
        if)
     #)  

-- AggregationConnectorOnDoubleClick: DoPart --
do
   patternDiagrams.AggregationList.find
     (#
        theName,description: ^Text;
        kind,implementation: @integer;
        predicate:: 
          (# anAST: ^mps.ast
          do
             ((rightRole).thePatternDiagramNode).getASTNode->anAST[];
             (if not
             (anAST## <= betaGram.AttributeDecl##)
             (* in case it was a titlenode *) then
                 anAST[]->patternDiagrams.astUtils.getEnclosingDecl->anAST[]
             if);
             (if switch[54] then
                 'AggregationConnector onDoubleClick - Comparing: %i %i and %i %i/n'
                   ->putformat
                     (# 
                     do
                        current.left->i;
                        (((leftRole).thePatternDiagramNode).getASTNode).index
                          ->i;
                        current.right->i;
                        anAST.index->i
                     #)
             if);
             (current.left =
              (((leftRole).thePatternDiagramNode).getASTNode).index) and
             ((((leftRole).thePatternDiagramNode).getASTNode).frag.fullname
                ->current.leftFrag.equal) and (current.right = anAST.index) and
             (anAST.frag.fullname->current.rightFrag.equal)->value
          #);
        notFound:: 
          (# ok: @integer; anAST: ^mps.ast
          do
             ('Aggregation Doubleclick',
              'The aggregation code has been edited in Sif,\nCheck the program to insure consistency?\n- "No" will launch the aggregation dialog\nwith settings that are as consistent as\npossible with the code.\n')
               ->promptForBoolean->ok;
             (if ok
              // yes then
                 ((leftRole).thePatternDiagramNode).getAstNode->anAST[];
                 (if anAST[] <> none then anAST.frag.father->callChecker if)
              // no then
                 getValuesFromCode->(theName[],implementation,kind);
                 (THIS(AggregationConnector)[],theName[],kind,implementation,1,
                  1,1,1,description[])->openAggregationDialog
              // cancel then
                 
             if)
          #)
     do
        getValuesFromCode->(theName[],implementation,kind);
        (THIS(AggregationConnector)[],theName[],kind,implementation,
         current.leftMulFrom,current.leftMulTo,current.rightMulFrom,
         current.rightMulTo,description[])->openAggregationDialog
     #)  

-- AggregationConnectorInterativeNew: DoPart --
do kind->private.kind; INNER InteractiveNew  

-- AggregationConnectorGenerateCode: DoPart --
do
     (#
        theNode,dummyNode: ^node;
        t,qualification,includeString: ^text;
        theListDiagram,theOtherListDiagram: ^ListDiagram;
        theOtherOADDiagram: ^OADDiagram;
        aDiagramNode: ^theOtherListDiagram.DiagramNode;
        aSimpleNode: ^theListDiagram.SimpleAttributeDecl;
        aNonTerminalNode: ^theListDiagram.NonTerminalNode;
        titleText: @text;
        anAST,aDeclAST,rightAst: ^MPS.AST;
        theDesc: ^betaGram.ObjectDescriptor;
        anExp,anotherExp: ^mps.expanded;
        theNames: ^betaGram.Names;
        theNameDcl: ^betaGram.NameDcl;
        theAttrDecl: ^betaGram.AttributeDecl;
        regions,existingConnectors: ^ObjectList;
        theCon: ^Connector;
        theAggrCon: ^AggregationConnector;
        x,y,w,h: @integer
     do
        true->doneInInner;
        aPatternDiagramNode.theDiagram->theListDiagram[];
        (if aPatternDiagramNode## <= theListDiagram.NonTerminalNode## then
            aPatternDiagramNode[]->aNonTerminalNode[]; theName.copy->t[]
         else
            (if aPatternDiagramNode## <= theListDiagram.SimpleAttributeDecl##
             then
                aPatternDiagramNode[]->aSimpleNode[];
                aPatternDiagramNode.getASTNode->anExp[];
                (* If no name was specified
                 check if simpleDecl already
                 has name and use that if so *)
                (if '<<NameDecl>>'->theName.equal then
                    anExp.getSon1->theNames[];
                    theNames.getSon1->theNameDcl[];
                    theNameDcl.getNameDecl->anAST[];
                    (if anAST.kind = mps.kinds.unExpanded then
                        theName.copy->t[]
                     else
                        theNameDcl.getText->t[]
                    if)
                 else
                    theName.copy->t[]
                if)
             else
                currentFocus[]->oldFocus[];
                (if theListDiagram.localNodes.empty then
                    theListDiagram.titleNode[]->currentFocus[]->currentObject;
                    theListDiagram.titleNode.getASTNode->anAST[];
                    (if anAST[] <> none then
                        (anAST[],1)
                          ->(theListDiagram.titleNode.theSifEditor).changeFocus
                    if);
                    (theListDiagram.titleNode.theSifEditor).insertOptionals;
                    (theListDiagram.localNodes.last).elm[]->aNonTerminalNode[];
                    currentFocus[]->oldFocus[];
                    aNonTerminalNode[]->currentFocus[]->currentObject;
                    (aNonTerminalNode.unExp,1)
                      ->(theListDiagram.titleNode.theSifEditor).changeFocus
                 else
                    (if (theListDiagram.localNodes.last).elm.struc <=
                    theListDiagram.NonTerminalNode## then
                        (theListDiagram.localNodes.last).elm[]
                          ->aNonTerminalNode[];
                        aNonTerminalNode.unExp->anAST[]
                     else
                        (theListDiagram.localNodes.last).elm.getASTNode->anAST[]
                    if);
                    (theListDiagram.localNodes.last).elm[]->currentFocus[]
                      ->currentObject;
                    (anAST[],1)
                      ->(theListDiagram.titleNode.theSifEditor).changeFocus;
                    (theListDiagram.titleNode.theSifEditor).after
                if);
                currentObject->aNonTerminalNode[];
                theName.copy->t[]
            if)
        if);
        anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
        (if anotherPatternDiagramNode## <= theOtherListDiagram.title## then
            theOtherListDiagram[]->theOtherOADDiagram[];
            theOtherOADDiagram.theDescriptor->theDesc[];
            theDesc.father->anotherExp[];
            (if anotherExp## <= betaGram.AttributeDecl## then
                (if aNonTerminalNode[] <> none then
                    (aNonTerminalNode.unExp,anotherExp[])
                      ->getQualificationWithPath->qualification[]
                 else
                    (anExp[],anotherExp[])->getQualificationWithPath
                      ->qualification[]
                if);
                (if theListDiagram[] = theOtherListDiagram[] then Delete if)
             else
                false->ok; 'Destination is singularly defined'->AlertUser
            if)
         else
            (if
            (anotherPatternDiagramNode## <= theOtherListDiagram.PatternNode##)
            or
            (anotherPatternDiagramNode## <= theOtherListDiagram.VirtualNode##)
            or
            (anotherPatternDiagramNode## <= theOtherListDiagram.BindingNode##)
            or (anotherPatternDiagramNode## <= theOtherListDiagram.FinalNode##)
             then
                anotherPatternDiagramNode[]->aDiagramNode[];
                aDiagramNode.theDeclaration->theAttrDecl[];
                (if aNonTerminalNode[] <> none then
                    (aNonTerminalNode.unExp,theAttrDecl[])
                      ->getQualificationWithPath->qualification[]
                 else
                    (anExp[],theAttrDecl[])->getQualificationWithPath
                      ->qualification[]
                if);
                (if theListDiagram[] = theOtherListDiagram[] then Delete if)
             else
                false->ok;
                'The destination is not a pattern, virtual, binding or final declaration'
                  ->AlertUser
            if)
        if);
        (if qualification[] <> none then
            ':'->t.puttext;
            (if implementation
             // gppProp.noImplementation then
                (if private.kind
                 // gppProp.byValue then
                    '@'->t.puttext
                 // gppProp.byReference then
                    '^'->t.puttext
                if);
                qualification[]->t.puttext
             // gppProp.Repetition then
                '['->t.puttext;
                (if rightMulTo > 0 then
                    rightMulTo->t.putint
                 else
                    100->t.putint
                if);
                ']'->t.puttext;
                (if private.kind
                 // gppProp.byValue then
                    '@'->t.puttext
                 // gppProp.byReference then
                    '^'->t.puttext
                if);
                qualification[]->t.puttext
             else
                '@'->t.puttext;
                '~beta/containers/v1.5/'->includeString[];
                (if implementation
                 // gppProp.ArrayContainer then
                    'ArrayContainer'->t.puttext;
                    'arrayContainer'->includeString.puttext
                 // gppProp.HashTable then
                    'HashTable'->t.puttext; 'hashTable'->includeString.puttext
                 // gppProp.ExtensibleHashTable then
                    'ExtensibleHashTable'->t.puttext;
                    'hashTable'->includeString.puttext
                 // gppProp.List then
                    'List'->t.puttext; 'list'->includeString.puttext
                 // gppProp.Set then
                    'Set'->t.puttext; 'sets'->includeString.puttext
                 // gppProp.MultiSet then
                    'MultiSet'->t.puttext; 'sets'->includeString.puttext
                 // gppProp.Stack then
                    'Stack'->t.puttext; 'seqContainers'->includeString.puttext
                 // gppProp.Queue then
                    'Queue'->t.puttext; 'seqContainers'->includeString.puttext
                 // gppProp.PriorityQueue then
                    'PriorityQueue'->t.puttext;
                    'seqContainers'->includeString.puttext
                if);
                '(# element::'->t.puttext;
                qualification[]->t.puttext;
                ' #)'->t.puttext
            if);
            &Node[]->dummyNode[];
            (0,0,0,0)->dummyNode.new;
            (dummyNode.getTopParent,dummyNode[],
             theOtherListDiagram.titleNode.getTopParent,
             theOtherListDiagram.titleNode[])->setEnds;
            (if aNonTerminalNode[] <> none then
                (aNonTerminalNode.unExp,t)
                  ->(aNonTerminalNode.theSifEditor).parse;
                currentObject->aSimpleNode[]
             else
                (if (aSimpleNode.theAggregationConnector <> none ) and
                (aSimpleNode.theAggregationConnector <> THIS(
                 AggregationConnector)[]) then
                    aSimpleNode.theAggregationConnector->theAggrCon[];
                    theAggrCon.leftRole->theNode[];
                    theAggrCon.rightRole->dummyNode[];
                    theAggrCon.delete;
                    theNode.delete;
                    dummyNode.delete
                if);
                (anExp[],t)->(aSimpleNode.theSifEditor).parse;
                (* if simpleNode is replaced by repetitionNode
                 or vice-versa aSimpleNode has to be set *)
                currentObject->aSimpleNode[]
            if);
            (if includeString[] <> none then
                ((aSimpleNode.theDeclaration).frag.father,'INCLUDE',
                 includeString[])->sifAddProp
            if);
            (if aDiagramNode[] <> none then
                (if aDiagramNode.currentDecomposDiagram <> none then
                    (if aDiagramNode.currentDecomposDiagram <> theListDiagram[]
                     then
                        aSimpleNode[]->left[];
                        (aDiagramNode.currentDecomposDiagram).titleNode[]
                          ->right[]
                     else
                        Delete
                    if)
                 else
                    aSimpleNode[]->left[]; aDiagramNode[]->right[]
                if)
             else
                aSimpleNode[]->left[]; theOtherListDiagram.titleNode[]->right[]
            if)
        if);
        (if (ID->theObjectList.find) <> none (*A connector was created*) then
            right.getAstNode->rightAst[];
            (if not (rightAst## <= betaGram.AttributeDecl##) then
                rightAst[]->patternDiagrams.astUtils.getEnclosingDecl
                  ->rightAst[]
            if);
            (aSimpleNode.theDeclaration,rightAst[],leftMulFrom,leftMulTo,
             rightMulFrom,rightMulTo)->patternDiagrams.AggregationList.insert;
            THIS(AggregationConnector)[]->aSimpleNode.theAggregationConnector
        if)
     #)  

-- AggregationConnectorGetValuesFromCode: DoPart --
do
     (#
        description,prefixName: ^Text;
        theListDiagram: ^ListDiagram;
        anAST: ^mps.AST;
        theAttributeDecl: ^betaGram.AttributeDecl;
        theNames: ^betaGram.Names;
        theNameDcl: ^betaGram.NameDcl;
        anExp: ^mps.expanded;
        thePatternDecl: ^betaGram.PatternDecl;
        theObjectDescriptor: ^betaGram.ObjectDescriptor;
        thePrefix: ^betaGram.Prefix;
        theNameApl: ^betaGram.NameApl
     do
        true->doneInInner;
        ((leftRole).thePatternDiagramNode).theDiagram->theListDiagram[];
        (if ((leftRole).thePatternDiagramNode).struc <=
        theListDiagram.SimpleAttributeDecl## then
            ((leftRole).thePatternDiagramNode).getASTNode->theAttributeDecl[];
            theAttributeDecl.getSon1->theNames[];
            theNames.getSon1->theNameDcl[];
            theNameDcl.getNameDecl->anAST[];
            (if not (anAST.kind = mps.kinds.unExpanded) then
                theNameDcl.getText->theName[]
            if);
            (if theAttributeDecl## <= betaGram.SimpleDecl## then
                theAttributeDecl.getSon2->anAST[];
                (if anAST.symbol
                 // betaGram.StaticItem then
                    gppProp.byValue->kind;
                    anAST[]->anExp[];
                    anExp.getSon1->anAST[];
                    (if anAST.symbol = betaGram.ObjectDescriptor then
                        anAST[]->theObjectDescriptor[];
                        theObjectDescriptor.getPrefixOpt->anAST[];
                        (if anAST.kind = mps.kinds.interior then
                            anAST[]->thePrefix[];
                            thePrefix.getAttributeDenotation->anAST[];
                            (if anAST.symbol = betaGram.NameApl then
                                anAST[]->theNameApl[];
                                theNameApl.getNameAppl->anAST[];
                                (if anAST.kind <> mps.kinds.unExpanded then
                                    theNameApl.getText->prefixName[];
                                    (if true
                                     // ('arrayContainer'->prefixName.equalNCS)
                                     then
                                        gppProp.arrayContainer->implementation
                                     // ('hashTable'->prefixName.equalNCS) then
                                        gppProp.hashTable->implementation
                                     //
                                     ('extensibleHashTable'
                                        ->prefixName.equalNCS) then
                                        gppProp.extensibleHashTable
                                          ->implementation
                                     // ('List'->prefixName.equalNCS) then
                                        gppProp.List->implementation
                                     // ('Set'->prefixName.equalNCS) then
                                        gppProp.Set->implementation
                                     // ('MultiSet'->prefixName.equalNCS) then
                                        gppProp.MultiSet->implementation
                                     // ('Stack'->prefixName.equalNCS) then
                                        gppProp.Stack->implementation
                                     // ('Queue'->prefixName.equalNCS) then
                                        gppProp.Queue->implementation
                                     // ('PriorityQueue'->prefixName.equalNCS)
                                     then
                                        gppProp.PriorityQueue->implementation
                                    if);
                                    (if implementation <>
                                    gppProp.noImplementation then
                                        gppProp.byReference->kind
                                    if)
                                if);
                                
                            if)
                        if)
                    if)
                 // betaGram.DynamicItem then
                    gppProp.byReference->kind
                 else
                (* code inconsistency - set to default *)
                    gppProp.byReference->kind
                if)
             else
                (if theAttributeDecl## <= betaGram.RepetitionDecl## then
                    gppProp.repetition->implementation;
                    theAttributeDecl.getSon3->anAST[];
                    (if anAST.symbol
                     // betaGram.StaticItem then
                        gppProp.byValue->kind
                     // betaGram.DynamicItem then
                        gppProp.byReference->kind
                     else
                    (* code inconsistency - set to default *)
                        gppProp.byReference->kind
                    if)
                if)
            if)
        if)
     #)  

-- AggregationConnectorRedisplay: DoPart --
do
     (#
        t,qualification: ^text;
        anExp: ^mps.expanded;
        anAST,newLeft: ^mps.ast;
        thePatternDiagramNode: ^PatternDiagramNode;
        theListDiagram: ^ListDiagram
     do
        kind->private.kind;
        ((leftRole).thePatternDiagramNode).getASTNode->anExp[];
        ((rightRole).thePatternDiagramNode).getASTNode->anAST[];
        (if not (anAST## <= betaGram.AttributeDecl##) (* it is a title *) then
            anAST[]->patternDiagrams.astUtils.getEnclosingDecl->anAST[]
        if);
        (anExp[],anAST[])->getQualificationWithPath->qualification[];
        (if qualification[] <> none then
            name[]->t[];
            ':'->t.puttext;
            (leftRole).thePatternDiagramNode->thePatternDiagramNode[];
            thePatternDiagramNode.theDiagram->theListDiagram[];
            (if implementation
             // gppProp.noImplementation then
                (if kind
                 // gppProp.byValue then
                    '@'->t.puttext
                 // gppProp.byReference then
                    '^'->t.puttext
                if);
                (if thePatternDiagramNode## <= theListDiagram.RepetitionNode##
                 then
                (* To prevent role from being deleted when RepetitionNode
                 is replaced by SimpleNode *)
                    (leftRole).unmakeRegion
                 else
                    none ->thePatternDiagramNode[]
                if);
                qualification[]->t.puttext
             // gppProp.Repetition then
                '['->t.puttext;
                (if rightMulTo > 0 then
                    rightMulTo->t.putint
                 else
                    100->t.putint
                if);
                ']'->t.puttext;
                (if kind
                 // gppProp.byValue then
                    '@'->t.puttext
                 // gppProp.byReference then
                    '^'->t.puttext
                if);
                qualification[]->t.puttext;
                (if thePatternDiagramNode## <= theListDiagram.SimpleNode## then
                (* To prevent role from being deleted when SimpleNode
                 is replaced by RepetitionNode *)
                    (leftRole).unmakeRegion
                 else
                    none ->thePatternDiagramNode[]
                if)
             else
                '@'->t.puttext;
                (if implementation
                 // gppProp.ArrayContainer then
                    'ArrayContainer'->t.puttext
                 // gppProp.HashTable then
                    'HashTable'->t.puttext
                 // gppProp.ExtensibleHashTable then
                    'ExtensibleHashTable'->t.puttext
                 // gppProp.List then
                    'List'->t.puttext
                 // gppProp.Set then
                    'Set'->t.puttext
                 // gppProp.MultiSet then
                    'MultiSet'->t.puttext
                 // gppProp.Stack then
                    'Stack'->t.puttext
                 // gppProp.Queue then
                    'Queue'->t.puttext
                 // gppProp.PriorityQueue then
                    'PriorityQueue'->t.puttext
                if);
                '(# element::'->t.puttext;
                qualification[]->t.puttext;
                ' #)'->t.puttext;
                (if thePatternDiagramNode## <= theListDiagram.RepetitionNode##
                 then
                (* To prevent role from being deleted when RepetitionNode
                 is replaced by SimpleNode *)
                    (leftRole).unmakeRegion
                 else
                    none ->thePatternDiagramNode[]
                if)
            if);
            (anExp[],t)
              ->(((leftRole).thePatternDiagramNode).theSifEditor).parse;
            (if thePatternDiagramNode[] <> none then
                currentObject->(leftRole).thePatternDiagramNode;
                (leftRole).thePatternDiagramNode->(leftRole).createRegion
            if);
            ((leftRole).thePatternDiagramNode).getASTNode->newLeft[];
            (anExp[],anAST[],newLeft[],leftMulFrom,leftMulTo,rightMulFrom,
             rightMulTo)->patternDiagrams.AggregationList.updateElement
        if)
     #)  

-- AggregationConnectorOnInit: DoPart --
do
   (if switch[30] or switch[54] then
       'AggregationConnector onInit'->putline
   if);
   UDPrivate.UDAggregationConnector->UserDataInit  

-- AggregationConnectorPrivate: Descriptor --
(# kind: @integer #)  

-- AggregationConnectorDump: DoPart --
do INNER dump  

-- getQualificationWithPath: Descriptor --
(#
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   aDeclAST,nca,ncDecl: ^MPS.AST;
   keepT: ^Text;
   qualSonNo,refSonNo: @integer;
   getSurroundingDecl:
     (# anAST: ^MPS.AST; attDecl: ^betaGram.AttributeDecl
     enter anAST[]
     do
        (if anAST.father
         // none then 
         else
            anAst.father->anAST[];
            (if anAST.symbol
             // BetaGram.PatternDecl // betaGram.VirtualDecl
             // betaGram.BindingDecl // betaGram.FinalDecl
             // betaGram.SimpleDecl then
                anAST[]->attDecl[]
             else
                anAST[]->getSurroundingDecl->attDecl[]
            if)
        if)
     exit attDecl[]
     #)
do
   qual.getSon1->theNames[];
   theNames.getSon1->theNameDcl[];
   theNameDcl.getNameDecl->aDeclAST[];
   (if aDeclAST.kind = mps.kinds.unExpanded then
       '<<NameAppl>>'->t[]->keepT[]
    else
       theNameDcl.getText->t[]->keepT[]
   if);
   (if not (ref[]->qual.equal) then
       (if ref.frag[] = qual.frag[] then
           ref[]->qual.nearestCommonAncestor->(nca[],qualSonNo,refSonNo);
           (if not (nca## <= betaGram.AttributeDecl##) then
               nca[]->getSurroundingDecl->ncDecl[]
           if)
       if);
       (if ncDecl[] = none then
           loop:
             (# 
             do
                qual[]->getSurroundingDecl->qual[];
                (if qual[] <> none then
                    qual.getSon1->theNames[];
                    theNames.getSon1->theNameDcl[];
                    theNameDcl.getNameDecl->aDeclAST[];
                    (if aDeclAST.kind = mps.kinds.unExpanded then
                        '<<NameAppl>>.'->t.prepend
                     else
                        '.'->t.prepend; theNameDcl.getText->t.prepend
                    if);
                    restart loop
                if)
             #)
        else
           (if not (qual[]->ncDecl.equal) then
               qual[]->getSurroundingDecl->qual[];
               (if qual[] <> none then
                   (if not (qual[]->ncDecl.equal) then
                       loop:
                         (# 
                         do
                            qual.getSon1->theNames[];
                            theNames.getSon1->theNameDcl[];
                            theNameDcl.getNameDecl->aDeclAST[];
                            (if aDeclAST.kind = mps.kinds.unExpanded then
                                '<<NameAppl>>.'->t.prepend
                             else
                                '.'->t.prepend; theNameDcl.getText->t.prepend
                            if);
                            qual[]->getSurroundingDecl->qual[];
                            (if qual[] <> none then
                                (if not (qual[]->ncDecl.equal) then
                                    restart loop
                                if)
                             else
                                keepT[]->t[]
                            if)
                         #)
                   if)
                else
                   keepT[]->T[]
               if)
           if)
       if)
   if)
#)  

-- GppOADPagePrivate: Descriptor --
(#  #)  

-- getSynCatNo: DoPart --
do
   (if
   ((node.kind = mps.kinds.unexpanded) or (node.kind = mps.kinds.optional)) then
       node[]->nontNode[]; nontNode.nonterminalSymbol->synCatNo
    else
       node.symbol->synCatNo
   if)  

