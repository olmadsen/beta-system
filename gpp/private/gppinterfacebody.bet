ORIGIN 'diagramattributes';
(* switch
 * 1  = general debugging
 * 21 = IndexIDList
 * 22 = AstReplaced
 *)
INCLUDE 'objectgppproperties'
        '~beta/designenv/v1.5/private/userdatabody';
-- IndexIDListInsert: Descriptor --
(# 
do
   (if switch[21]
    // true then
       '%21GPP: Insert element indexed: '->screen.puttext;
       a->screen.putint;
       screen.newline;
       
   if)
#)  

-- ASTToNode: Descriptor --
(# 
do
   (if switch[21] then 'ASTtoNode: '->putText if);
   (if anAST[]
    // none then 'ASTtoNode: anAST is none!'->putLine; 
    else
       (if switch[21] then anAST.index->putInt;  if);
       search:
       anAST.index
         ->indexIDList.scan
           (# 
           do
              currentNode[]->theNode[];
              (if theNode.getFragment
               // none then
                  'ASTtoNode: theNode.getFragment is none!'->putLine; 
               else
                  (if
                  (theNode.getFragment).fullName->(anAST.frag.fullname).equal
                   then
                      leave search
                  if)
              if);
              
           #);
       (if switch[21] then
           ' return: '->putText;
           (if theNode[]
            // none then 'none'->putLine
            else
               theNode.id->putInt; newLine
           if);
           
       if)
   if);
   
#)  

-- ASTToNodeListUpdate: Descriptor --
(# ff: ^FragmentForm; oldASTName: ^Text; 
do
   (if switch[21] then 'ASTtoNodeListUpdate: '->putText;  if);
   (if oldAST[]
    // none then 'ASTtoNodeListUpdate: oldAST is none!'->putLine; 
    else
       (if switch[21] then oldAST.index->putInt; ' '->put;  if);
       (if newAST[]
        // none then 'ASTtoNodeListUpdate: newAST is none!'->putLine; 
        else
           (if switch[21] then newAST.index->putInt;  if);
           search:
           oldAST.index
             ->indexIDList.scan
               (# 
               do
                  currentNode[]->theNode[];
                  (if theNode.getFragment
                   // none then
                      'ASTtoNodeListUpdate: theNode.getFragment is none!'
                        ->putLine;
                      
                   else
                      theNode.getFragment->ff[];
                      oldAST.frag.fullname->oldASTName[];
                      (if ff.fullname->oldASTName.equal then
                          newAst.Index->indexIDList.impl[i]; leave search
                      if)
                  if);
                  
               #)
       if);
       (if switch[21] then
           ' return: '->putText;
           (if theNode[]
            // none then 'none'->putLine
            else
               theNode.id->putInt; newLine
           if);
           
       if);
       
   if)
#)  

-- RemoveListElement: Descriptor --
(# theNode: ^patternDiagramNode
do
   (if switch[21] then 'RemoveListElement'->putText if);
   (if anAST[] = none then
       'RemoveListElement: anAST is none!'->putLine; putLine; 
    else
       (if switch[21] then anAST.index->putInt;  if);
       search:
       anAST.index
         ->indexIDList.RemoveScan
           (# 
           do 0->IndexIDList.impl[i]; 0->IndexIDList.impl[i+1]; leave search; 
           #)
   if)
#)  

-- GppPromptForText: Descriptor --
(# status: @Text; prompt: [1] @char; answerRep: [64] @Char; t: @Text
do
   message->prompt;
   (if (prompt,@@ answerRep[1])->DSUIGetString then
       @@ answerRep[1]->cStringToCharRep->t; t.copy->confirm
    else
       cancel
   if)
#)  

-- InitGPP: Descriptor --
(# 
do
   betaGram.init;
   metaGram.init;
   '~beta/grammars/beta/v2.4/beta-parser.btab'->expandToFullPath
     ->betaGram.parser.initialize;
   ('~beta/grammars/beta/v2.4/beta-meta-beta'->expandToFullPath,screen[])
     ->top.open->betaGram.grammarAST[];
   metaGram[]->GrammarTable.meta[];
   
#)  

-- OADDocumentInit: Descriptor --
(# (* setup the DesignOA menus we like to use in OADDocument *) 
do (* DocEditMenu.init; *)
   INNER onInit;
   (UserMenu7,'Page')->PageMenu.init;
   (UserMenu4,'View')->ViewMenu.init;
   (UserMenu5,'Object')-> (*kja&toby 1.9.94*) ObjectMenu.init;
   MenuId.CreateMenu->ViewMenu.insertBefore;
   true->ViewMenu.SimpleAsNameAndTypeItem.check;
   true->ViewMenu.ReferencesItem.check;
   true->ViewMenu.SpecializationsItem.check;
   true->ViewMenu.AssociationsItem.check;
   true->OGppProp.StaticRefCheck;
   true->OGppProp.LocalIncludeScan->ObjectMenu.LocalIncludeScan.check;
   true->OGppProp.ShowDynamicCreations->ObjectMenu.ToggleDynamicCreations.check;
   true->OGppProp.ShowOperationCalls->ObjectMenu.ToggleProcedureCalls.check;
   (* (UserMenu3,'Options')->OptionsMenu.init; *)
   (*(UserMenu6,'Marks') -> MarkMenu.init;*)
   (* new document makes a new page by default
    * if we like a special page the make it here *)
   &OADPage[]->newPage[];
   (* set/clear appopriate check marks in the menus *)
   (*MarkMenu.CheckCheckMarks;*)
   (* OptionsMenu.CheckCheckMarks; *)
   
#)  

-- OADPageOnInit: Descriptor --
(# integerData: @integer; ok: @Boolean; listsize,last: @integer
do
   (if userDataVerbose then
       'onInit called on OADPage with id='->puttext;
       id->putint;
       newline;
       'Reading OADPage UserDataID: '->puttext
   if);
   (Id,1,@@ integerData)->UDReadType->ok;
   (if ok then
       (if userDataVerbose then
           'Read OADPage UserDataID succeed: '->puttext;
           integerData->putint;
           newline
       if);
       (integerData,ID)->UserDataIDMap.putID;
       
    else
       (if userDataVerbose then 'Read OADPage UserDataID fail'->putline if)
   if);
   ID->integerData;
   (Id,1,@@ integerData,4)->UDWriteType->ok;
   (if ok then
       (if userDataVerbose then
           'Write OADPage UserDataID succeed: '->puttext;
           integerData->putint;
           newline
       if)
    else
       (if userDataVerbose then 'Write OADPage UserDataID fail'->putline if)
   if);
   (if THIS(OADPage)[] = theGroupPage[] then
       (theGroupPage.ID,499,@@ listsize)->UDReadType->ok;
       (if ok then
           listsize->IndexIDList.impl.new;
           (if userDataVerbose then
               'Read IndexIDList.impl.range succeed: '->puttext;
               listsize->putint;
               newline
           if);
           (theGroupPage.ID,500,@@ last)->UDReadType->ok;
           (if ok then
               last->IndexIDList.last;
               (if userDataVerbose then
                   'Read IndexIDList.last succeed: '->puttext;
                   last->putint;
                   newline
               if);
               (for i: listsize repeat
                 (theGroupPage.ID,500+i,@@ IndexIDList.impl[i])->UDReadType->ok;
                 (if ok then
                     (if userDataVerbose then
                         'Read IndexIDList succeed: '->puttext;
                         'element no '->puttext;
                         i->putint;
                         'element '->puttext;
                         IndexIDList.impl[i]->putint;
                         newline
                     if)
                  else
                     'Read IndexIDList fail: '->puttext
                 if)
               for)
            else
               (if userDataVerbose then
                   'Read IndexIDList.last fail: '->puttext
               if)
           if)
        else
           (if userDataVerbose then
               'Read IndexIDList.impl.range fail: '->puttext
           if)
       if)
   if);
   patternDiagrams.AssociationList.load;
   patternDiagrams.InheritanceList.load;
   patternDiagrams.DynReferenceList.load;
   (ID,240,@@ NextX)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read NextX succeed'->putline
        else
           'Read NextX fail'->putline
       if)
   if);
   (ID,241,@@ NextY)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read NextY succeed'->putline
        else
           'Read NextY fail'->putline
       if)
   if);
   (ID,250,@@ patternDiagrams.NextFreeLine)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read NextFreeLine succeed'->putline
        else
           'Read NextFreeLine fail'->putline
       if)
   if);
   (ID,251,@@ patternDiagrams.NextFreeColumn)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read NextFreeColumn succeed'->putline
        else
           'Read NextFreeColumn fail'->putline
       if)
   if);
   (ID,252,@@ patternDiagrams.SecondFreeLine)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read SecondFreeline succeed'->putline
        else
           'Read SecondFreeLine fail'->putline
       if)
   if);
   (ID,253,@@ patternDiagrams.SecondFreeColumn)->UDReadType->ok;
   (if userDataVerbose then
       (if ok then
           'Read SecondFreeColumn succeed'->putline
        else
           'Read SecondFreeColumn fail'->putline
       if)
   if);
   false->borderVisible;
   (*gppProp.NextPositionStartX*)
   250->nextX;
   (*gppProp.NextPositionStartY*)
   250->nextY;
   true->doScrollIntoView;
   
#)  

-- CalculateNextCenter: Descriptor --
(# x,y,w,h: @Integer; p: ^OADPage; 
do
   (if PatternDiagrams.theList.size
    // 0 then (* first diagram on page *)
       CurrentPage->p[];
       p.Geometry->(x,y,w,h);
       (* center, width, and height of PAGE *)
       y-(h div 2)+gppProp.DownOnPage->PatternDiagrams.NextFreeLine;
       x-(w div 2)+gppProp.RightOnPage->PatternDiagrams.NextFreeColumn;
       PatternDiagrams.NextFreeLine->PatternDiagrams.SecondFreeLine;
       PatternDiagrams.NextFreeColumn+gppProp.width+gppProp.RightFromPrevious
         ->PatternDiagrams.SecondFreeColumn;
       
   if);
   (PatternDiagrams.NextFreeColumn,PatternDiagrams.NextFreeLine)->theCenter;
   (*(nextX,nextY)->theCenter;*)
   
#)  

-- UpdateNextFree: Descriptor --
(# w,h: @Integer; 
do
   (if x-gppProp.width > theCenter.x then
   (* we have the last box on another column than the title *)
       x->PatternDiagrams.NextFreeColumn; 
   if);
   (PatternDiagrams.NextFreeLine,y+gppProp.DownFromPrefix)->Max
     ->PatternDiagrams.NextFreeLine;
   (PatternDiagrams.SecondFreeColumn,x+gppProp.width+gppProp.RightFromPrevious)
     ->Max->PatternDiagrams.SecondFreeColumn;
   (* check that nextFreeLine is inside the bound of the page *)
   THIS(OADPage).Geometry->(x,y,w,h);
   (if PatternDiagrams.NextFreeLine > y+(h div 2) then
   (* PatternDiagrams.SecondFreeLine -> PatternDiagrams.NextFreeLine;*)
       y-(h div 2)+gppProp.DownOnPage->PatternDiagrams.NextFreeLine;
       (if true (* PatternDiagrams.NextFreeColumn < theCenter.x *) then
           PatternDiagrams.SecondFreeColumn->PatternDiagrams.NextFreeColumn;
           PatternDiagrams.SecondFreeColumn+gppProp.width+
           gppProp.RightFromPrevious->PatternDiagrams.SecondFreeColumn;
           
       if);
       
   if);
   
#)  

-- StartCreatePrefix: Descriptor --
(#
   PC: Connector
     (#
        onInit::< 
          (# prefixTitle,title: ^PatternDiagramNode; a,b: ^Node; 
          do
             0->Orient;
             GetEnds->(a[],b[]);
             (if (a[] <> none ) and (b[] <> none )
              // true then
                 (if a.struc <= PatternDiagramNode##
                  // true then a[]->title[]; 
                  else
                     'Incorrect pattern node selected'->gppalert; 
                 if);
                 (if b.struc <= PatternDiagramNode##
                  // true then
                     b[]->prefixtitle[];
                     (if prefixtitle.theDiagram
                      // none then 'Incorrect prefix selected'->gppalert; 
                      else
                         (prefixtitle.theDiagram).titlenode[]->prefixtitle[]; 
                     if)
                  else
                     'Incorrect prefix selected'->gppalert; 
                 if);
                 (prefixTitle[],title[])->PrefixExpand;
                 
              else
                 'Incorrect nodes selected in prefix creation'->gppalert; 
             if);
             
          #);
        interactivenew::< 
          (# cursorformat::<  (#  do cursor.arrow->curs #) #)
     #);
   aPC: ^PC;
   
do
   &PC[]->aPC[];
   'Specify Prefix by first selecting the Pattern and then the prefix'
     ->aPC.interactivenew;
   
#)  

-- updateASTfromDisk: Descriptor --
(# g: ^FragmentGroup; ff: ^FragmentForm; anAST: ^AST; 
do
   (if switch[22]
    // true then
       'Gpp ------- updateASTfromDisk'->putLine;
       'oldindex: '->putText;
       oldindex->putInt;
       newLine;
       
   if);
   true->status;
   (*oldIndex->IndexIDList.IndextoObject->theObject[];*)
   oldIndex
     ->oldff.indexToNode
       (#
          indexOutOfRange::< 
            (#  do 'indexOutOfRange'->putLine; true->continue;  #);
          noSuchSymbol::< 
            (#  do 'noSuchSymbol'->putLine; true->continue;  #);
          grammarGenRefArrayError::< 
            (#  do 'grammarGenRefArrayError'->putLine; true->continue;  #)
       #)->anAST[];
   (if anAST[] = none then
       'Gpp updateASTfromDisk: node not found'->putLine
    else
       anAST[]->ASTtoNode->theObject[];
       (if theObject[]
        // none then
           (if CurrentFocus[] <> none
            // true then
               CurrentFocus.getFragment->ff[];
               (if ff[]
                // none then
                   'Freja: UpdateASTfromDisk: Cannot find FragmentForm for CurrentFocus'
                     ->screen.putline;
                   
                else
                   (if anAST[]
                    // none then 'Freja[[Old AST is: none'->screen.putLine
                    else
                       (if switch[22]
                        // true then
                           'Freja[[Old AST is: '->screen.puttext;
                           anAST.index->screen.putint;
                           ' symbol: '->screen.puttext;
                           anAST.symbol->betagram.symboltoname->screen.puttext;
                           ']]'->screen.putline;
                           
                       if);
                       L:
                       (if 1
                        // 1 then
                           anAST.father->anAST[];
                           (if anAST[] <> none
                            // true then
                            (*anAST.index->IndexIDList.IndextoObject->theObject[];*)
                               anAST[]->ASTtoNode->theObject[];
                               (if switch[1]
                                // true then
                                   'Freja[[N''th father to old AST is: '
                                     ->screen.puttext;
                                   anAST.index->screen.putint;
                                   ' symbol: '->screen.puttext;
                                   anAST.symbol->betagram.symboltoname
                                     ->screen.puttext;
                                   ']]'->screen.putline;
                                   
                               if);
                               (if theObject[] // none then restart L if);
                               
                           if)
                       if);
                       
                   if)
               if)
            else
               'Freja: UpdateASTfromDisk: CurrentFocus is NONE'->screen.putline;
               false->status;
               
           if);
           
       if);
       (if theObject[] <> none
        // true then (* object found; read the AST from disk *)
           theObject.getGroup->g[];
           (if g[] <> none
            // true then (* read the AST in from disk *)
            (*(if switch[2]
             // true then 'Reading in new AST'->statusbar.set
             if);*)
               (if switch[22]
                // true then
                   'Freja[[Reading in new AST... ]]'->screen.putline; 
               if);
               g.init;
               screen[]->g.unpack;
               (oldff[],theObject[])->(theObject.theDiagram).updateASTfromDisk
                 ->newff[];
               INNER updateASTfromDisk;
               (*               (if switch[2] // true then statusbar.reset if);*)
               
            else
               false->status;
               'Freja: UpdateASTfromDisk: cannot find FragmentDiagram'
                 ->screen.putline;
               
           if);
           
        else
           false->status;
           'Freja: UpdateASTfromDisk: cannot find old object'->screen.putline;
           
       if)
   if);
   (if switch[22]
    // true then 'Gpp ------- End updateASTfromDisk'->putLine; 
   if);
   
#)  

-- gppChangedFocus: Descriptor --
(# 
do (* true->OKtoChange;*)
   currentFocus[]->oldFocus[];
   newObject[]
     ->CurrentFocus[] (*  else
                       oldObject[]->currentObject
                       if)*) ;
   currentFocus[]->currentObject (#  do true->autoPan #);
   (* (if OKToChange then*)
   INNER changedFocus
#)  

-- newFragment: Descriptor --
(# 
do (if switch[22] // true then 'Gpp ------- newFragment'->putLine;  if); 
#)  

-- astReplaced: Descriptor --
(#
   oldAst,newAst: ^ast;
   pos: @integer;
   theDiagram: ^Diagram;
   doListReplace: @boolean;
   deleted: @boolean;
   dummyFilter: ##external;
   pageList: ^ObjectList;
   filename: @Text;
   nonterminalName: ^Text;
   cancelled: ^integerRef;
   prompt: @text;
   count: @ShortRef;
   list: @IntegerRef;
   theListDiagram: ^ListDiagram;
   theAbstractNode: ^theListDiagram.AbstractNode;
   theunexp: ^unexpanded;
   
do
   (if switch[22]
    // true then
       'Gpp ------- astReplaced'->putLine;
       'oldindex: '->putText;
       oldindex->putInt;
       newLine;
       'newindex: '->putText;
       newindex->putInt;
       newLine;
       
   if);
   true->status;
   oldIndex
     ->ff.indexToNode
       (#
          indexOutOfRange::< 
            (#  do 'indexOutOfRange'->putLine; true->continue;  #);
          noSuchSymbol::< 
            (#  do 'noSuchSymbol'->putLine; true->continue;  #);
          grammarGenRefArrayError::< 
            (#  do 'grammarGenRefArrayError'->putLine; true->continue;  #)
       #)->oldAST[];
   (if oldAST[] = none then
       'Gpp astReplaced: old node not found'->putLine
    else
       thisOp:
         (# 
         do
            (ff[],oldIndex)
              ->updateASTfromDisk
                (# 
                do
                   newIndex
                     ->newff.indexToNode
                       (#
                          indexOutOfRange::< 
                            (# 
                            do 'indexOutOfRange'->putLine; true->continue; 
                            #);
                          noSuchSymbol::< 
                            (# 
                            do 'noSuchSymbol'->putLine; true->continue; 
                            #);
                          grammarGenRefArrayError::< 
                            (# 
                            do
                               'grammarGenRefArrayError'->putLine;
                               true->continue;
                               
                            #)
                       #)->newAST[];
                   (if private.dynamicReferenceQual[] <> none then
                       (newAST[],private.dynamicReferenceQual[])
                         ->patternDiagrams.DynReferenceList.insert
                   if);
                   (if newAST[] = none then
                       'Gpp astReplaced: new node not found'->putLine;
                       leave thisOP
                   if);
                   (if oldAST.kind
                    // kinds.unExpanded then
                    (* this is an ECOOP94 hack, must be generalized *)
                       (if newAst.kind
                        // kinds.interior then
                           (if switch[22]
                            // true then 'expanding a nonterminal'->putLine; 
                           if);
                           (if NewAST.symbol
                            // betaGram.nameDcl then
                               (if switch[22]
                                // true then '  it is a nameDcl'->putLine; 
                               if);
                               
                            else
                               (if (NewAST.struc <= betaGram.attributeDecl##)
                                // true then
                                   (if switch[22]
                                    // true then
                                       '  it is a declaration: '->putText;
                                       NewAST.symbol->putInt;
                                       newLine;
                                       
                                   if);
                                   true->doListReplace;
                                   
                                else
                                   
                               if)
                           if);
                           
                        // kinds.optional then
                           oldAST[]->ASTtoNode->theObject[];
                           (if theObject[] <> none then
                               theObject.theDiagram->theDiagram[];
                               (theObject[],true)->theDiagram.deleteDiagramNode;
                               true->deleted;
                               
                           if)
                       if)
                    // kinds.interior then
                       oldAST[]->patternDiagrams.AssociationList.update;
                       oldAST[]->patternDiagrams.InheritanceList.update;
                       (if newAST.kind = kinds.interior then
                           (if oldAST## <= betaGram.attributeDecl## then
                               (if newAST## <= betaGram.attributeDecl## then
                                   (if oldAST## <> newAST## then
                                       true->doListReplace
                                   if)
                               if)
                           if)
                        else
                           true->doListReplace
                       if)
                    // kinds.optional then
                       (if newAST.kind = kinds.unexpanded then
                           newAST[]->theunexp[];
                           theunexp.nonTerminalSymbol->betaGram.symbolToName
                             ->nonterminalName[];
                           (if 'AttributeDeclOpt'->nonterminalName.equal then
                               theObject.theDiagram->theListDiagram[];
                               (if theObject## <= theListDiagram.AbstractNode##
                                then
                                   theObject[]->theAbstractNode[];
                                   (if theAbstractNode.currentDecomposDiagram <>
                                   none then
                                       (newAST.sonNo-1,newAST[])
                                         ->
                                           (
                                           theAbstractNode.
                                             currentDecomposDiagram).
                                           insertDiagramNode
                                   if)
                               if)
                           if)
                       if)
                   if);
                   (if doListReplace
                    // true then
                       oldAST.sonNo->pos;
                       (if switch[22]
                        // true then
                           'sonNo is: '->putText; pos->putInt; newLine
                       if);
                       oldAST[]->ASTtoNode->theObject[];
                       (if theObject[] <> none then
                           theObject.theDiagram->theDiagram[];
                           (*
                            (theObject[],true)->theObject.theDiagram.deleteDiagramNode;
                            (pos,newAST[])->theDiagram.insertDiagramNode;    
                            * *)
                           (theObject[],newAST[])
                             ->theDiagram.replaceDiagramNode;
                           
                       if)
                    else
                       (if not deleted then
                           (if theObject[] <> none then
                               (if private.dynamicReferenceQual[] <> none then
                                   none ->private.dynamicReferenceQual[]
                               if);
                               (oldAst[],newAst[])
                                 ->(theObject.theDiagram).updateDiagramNode
                            else
                               'astReplaced: theObject is none'->putline
                           if)
                       if);
                       
                   if)
                #);
            Redraw
         #)
   if);
   autosave;
   
#)  

-- listElementInserted: Descriptor --
(#
(* listElementInserted:
 * # <editorId> listElementInserted <fatherIndex> <position> <synCatNo> <synCatName>
 *) father: ^expanded; newAst,firstBorn: ^ast; pos,noOfSons,i: @integer
do
   (if switch[22]
    // true then
       'Gpp ------- listElementInserted'->putLine;
       'fatherIndex: '->putText;
       fatherIndex->putInt;
       newLine;
       'position: '->putText;
       position->putInt;
       newLine;
       
   if);
   fatherIndex
     ->ff.indexToNode
       (#
          indexOutOfRange::< 
            (#  do 'indexOutOfRange'->putLine; true->continue;  #);
          noSuchSymbol::< 
            (#  do 'noSuchSymbol'->putLine; true->continue;  #);
          grammarGenRefArrayError::< 
            (#  do 'grammarGenRefArrayError'->putLine; true->continue;  #)
       #)->father[];
   (if father[] = none then
       'Gpp listElementInserted: father not found'->putLine
    else
       father.getson1->firstBorn[];
       (if firstBorn.kind = kinds.optional then
           father.noOfSons->noOfSons;
           2->i;
           loop:
             (# 
             do
                (if noOfSons >= i then
                    i->father.get->firstBorn[];
                    (if firstBorn.kind = kinds.optional then
                        i+1->i; restart loop
                    if)
                 else
                    none ->firstBorn[]
                if)
             #)
       if);
       (if firstBorn[] <> none then
           (ff[],firstBorn.index)
             ->updateASTfromDisk
               (# 
               do
                  (if (newff[] <> none )
                   // true then
                      fatherIndex
                        ->newff.indexToNode
                          (#
                             indexOutOfRange::< 
                               (# 
                               do 'indexOutOfRange'->putLine; true->continue; 
                               #);
                             noSuchSymbol::< 
                               (# 
                               do 'noSuchSymbol'->putLine; true->continue; 
                               #);
                             grammarGenRefArrayError::< 
                               (# 
                               do
                                  'grammarGenRefArrayError'->putLine;
                                  true->continue;
                                  
                               #)
                          #)->father[];
                      (if (father[] <> none )
                       // true then
                          position->pos->father.get->newAST[];
                          1->i;
                          scanner: father.scan
                            (# 
                            do
                               (if not (i = position) then
                                   (if current.kind = kinds.optional then
                                       pos-1->pos
                                   if);
                                   i+1->i
                                else
                                   leave scanner
                               if)
                            #);
                          (pos-1,newAST[])
                            ->(theObject.theDiagram).insertDiagramNode;
                          
                       else
                          'Gpp ------- listElementInserted: father is none'
                            ->putLine;
                          
                      if);
                      
                   else
                      'Gpp ------- listElementInserted: newff is none'->putLine;
                      
                  if);
                  
               #)
       if);
       Redraw
   if);
   autosave;
   (* refresh the page, due to update delay *)
   
#)  

-- listElementsDeleted: Descriptor --
(#
(* changeSpec:
 * <fatherIndex> <position> <length> <oldElements>
 *  <oldElements> ::= { <elementIndex> } i    (i = <length>)
 *)
   fatherIndex,position,length: @integer;
   oldElements: [1] @integer;
   father: ^expanded;
   anAst: ^ast;
   
do
   (if switch[22]
    // true then
       'Gpp ------- listElementsDeleted'->putLine; changeSpec[]->putLine; 
   if);
   changeSpec.getInt->fatherIndex;
   changeSpec.getInt->position;
   changeSpec.getInt->length;
   (if switch[22]
    // true then
       'fatherIndex: '->putText;
       fatherIndex->putInt;
       newLine;
       'position: '->putText;
       position->putInt;
       newLine;
       'length: '->putText;
       length->putInt;
       newLine;
       
   if);
   length-1->oldElements.extend;
   (for i: length repeat changeSpec.getInt->oldElements[i] for);
   (if switch[22]
    // true then
       'oldElements: '->putText;
       (for i: length repeat oldElements[i]->putInt; ' '->put;  for);
       newLine;
       
   if);
   fatherIndex
     ->ff.indexToNode
       (#
          indexOutOfRange::< 
            (#  do 'indexOutOfRange'->putLine; true->continue;  #);
          noSuchSymbol::< 
            (#  do 'noSuchSymbol'->putLine; true->continue;  #);
          grammarGenRefArrayError::< 
            (#  do 'grammarGenRefArrayError'->putLine; true->continue;  #)
       #)->father[];
   thisOp:
   (if father[] = none then
       'Gpp listElementInserted: father not found'->putLine
    else
       position->father.get->anAST[];
       (ff[],anAst.index)
         ->updateASTfromDisk
           (# 
           do (*(theObject[],0 ) -> theObject.theDiagram.remakePP;*)
              (for i: length repeat
              (*oldElements[i]->IndexIDList.IndextoObject->theObject[];*)
                oldElements[i]
                  ->ff.indexToNode
                    (#
                       indexOutOfRange::< 
                         (# 
                         do 'indexOutOfRange'->putLine; true->continue; 
                         #);
                       noSuchSymbol::< 
                         (# 
                         do 'noSuchSymbol'->putLine; true->continue; 
                         #);
                       grammarGenRefArrayError::< 
                         (# 
                         do
                            'grammarGenRefArrayError'->putLine; true->continue; 
                         #)
                    #)->anAST[];
                (if anAST[] = none then
                    'Gpp listElementInserted: old node not found'->putLine;
                    leave thisOp
                if);
                anAST[]->patternDiagrams.AssociationList.update;
                anAST[]->patternDiagrams.InheritanceList.update;
                anAST[]->ASTtoNode->theObject[];
                (if theObject[] <> none then
                    (theObject[],true)
                      ->(theObject.theDiagram).deleteDiagramNode;
                    
                if)
              for)
           #);
       Redraw
   if);
   autosave;
   (* refresh the page, due to update delay *)
   
#)  

-- listElementsReplaced: Descriptor --
(#
(* changeSpec:
 * <fatherIndex> <position> <length> <oldElements> <newLength> 
 * <oldElements> ::= { <elementIndex> } i    (i = <length>)
 *)
   fatherIndex,position,length,newLength: @integer;
   oldElements: [1] @integer;
   father: ^expanded;
   oldAst,newAst,anAST: ^ast;
   theDiagram: ^Diagram;
   pos,oldIndex,j: @integer
do
   (if switch[22]
    // true then
       'Gpp ------- listElementsReplaced'->putLine; changeSpec[]->putLine; 
   if);
   changeSpec.getInt->fatherIndex;
   changeSpec.getInt->position;
   changeSpec.getInt->length;
   (if switch[22]
    // true then
       'fatherIndex: '->putText;
       fatherIndex->putInt;
       newLine;
       'position: '->putText;
       position->putInt;
       newLine;
       'length: '->putText;
       length->putInt;
       newLine;
       
   if);
   (if length > 0 then
       length-1->oldElements.extend;
       (for i: length repeat changeSpec.getInt->oldElements[i] for);
       oldElements[1]->oldIndex
    else
   (* in this case there is no old node, e.g. when undoing 
    delete of list elements *)
       fatherIndex->oldIndex
   if);
   changeSpec.getInt->newLength;
   (if switch[22]
    // true then
       'oldElements: '->putText;
       (for i: length repeat oldElements[i]->putInt; ' '->put;  for);
       newLine;
       'newLength: '->putText;
       newLength->putInt;
       newLine;
       
   if);
   thisOp:
     (# 
     do
        (ff[],oldIndex)
          ->updateASTfromDisk
            (# 
            do
               (for i: length repeat
               (*oldElements[i]->IndexIDList.IndextoObject->theObject[];*)
                 oldElements[i]
                   ->ff.indexToNode
                     (#
                        indexOutOfRange::< 
                          (# 
                          do 'indexOutOfRange'->putLine; true->continue; 
                          #);
                        noSuchSymbol::< 
                          (# 
                          do 'noSuchSymbol'->putLine; true->continue; 
                          #);
                        grammarGenRefArrayError::< 
                          (# 
                          do
                             'grammarGenRefArrayError'->putLine;
                             true->continue;
                             
                          #)
                     #)->anAST[];
                 (if anAST[] = none then
                     'Gpp listElementReplaced: old node not found'->putLine;
                     leave thisOp
                 if);
                 anAST[]->patternDiagrams.AssociationList.update;
                 anAST[]->patternDiagrams.InheritanceList.update;
                 anAST[]->ASTtoNode->theObject[];
                 (if theObject[] <> none then
                     theObject.theDiagram->theDiagram[];
                     (theObject[],true)
                       ->(theObject.theDiagram).deleteDiagramNode;
                     
                 if)
               for);
               fatherIndex
                 ->newff.indexToNode
                   (#
                      indexOutOfRange::< 
                        (# 
                        do 'indexOutOfRange'->putLine; true->continue; 
                        #);
                      noSuchSymbol::< 
                        (#  do 'noSuchSymbol'->putLine; true->continue;  #);
                      grammarGenRefArrayError::< 
                        (# 
                        do 'grammarGenRefArrayError'->putLine; true->continue; 
                        #)
                   #)->father[];
               (if father[] = none then
                   'Gpp listElementReplaced: father node not found'->putLine;
                   leave thisOp
               if);
               (for i: newlength repeat
                 position+i-1->pos->father.get->newAST[];
                 (if not (newAST.kind = kinds.optional) then
                     (if theDiagram[] = none then
                         'Gpp: ListElementsReplaced: theDiagram is none!!'
                           ->putLine
                      else
                         1->j;
                         scanner: father.scan
                           (# 
                           do
                              (if not (j = position+i-1) then
                                  (if current.kind = kinds.optional then
                                      pos-1->pos
                                  if);
                                  j+1->j
                               else
                                  leave scanner
                              if)
                           #);
                         (pos-1,newAST[])->theDiagram.insertDiagramNode
                     if)
                 if);
                 
               for);
               
            #);
        Redraw
     #);
   autosave;
   ;
   (* refresh the page, due to update delay *)
   
#)  

-- makeAnchors: Descriptor --
(# noOfNodes,i: @Integer; theObject: ^PatternDiagramNode; 
do
(*'Freja[[MakeAnchors: '->screen.puttext;
 indexList[]->screen.puttext;
 ']]'->screen.putline;
 indexList.reset;
 indexList.getInt->noOfNodes;
 (for noOfNodes repeat
 indexList.getInt->i->AstToNode->theObject[];
 (if theObject[] <> none
 // true then theObject.MakeAnchor;
 else
 'Freja[[No node is presented with index: '->screen.puttext;
 i->screen.putint;
 ']]'->screen.putline;
 if)
 for);
 * *) 
#)  

-- getExtension: Descriptor --
(# index: @Integer; 
do
   '.'->name.findCh (#  do inx->index;  #);
   (index,name.length)->name.sub->extension[];
   
#)  

-- removeExtension: Descriptor --
(# rest: ^Text; index: @Integer; 
do
(*(if ('.bet'->rest.equal) or (astFileExtension->rest.equal)
 // true then*)
   '.'->name.findCh (#  do inx->index;  #);
   (index,name.length)->name.sub->rest[];
   (* if);*)
   (index,name.length)->name.delete;
   ;
   (*(if ('.bet'->rest.equal) or (astFileExtension->rest.equal)
    // true then*)
   
#)  

-- doStartup: Descriptor --
(#
   arg: ^Text;
   swt: @Text;
   SwitchMode: @Boolean;
   N: @Integer;
   myDocument: ^OADDocument;
   count: @ShortRef;
   list: @IntegerRef;
   pages: [0] @integer;
   thePage: ^theDocument.Page;
   theOADPage: ^theOADDocument.OADPage;
   theObject: ^thePage.DesignObject;
   theConnID: @integer;
   ext: ^Text;
   didRecover: @boolean;
   
do
   (if NoOfArguments > 1
    // true then
       (for i: NoOfArguments-1 repeat
         i+1->Arguments->arg[];
         0->arg.setpos;
         (if SwitchMode
          // true then
             arg.getint->N;
             (if True
              // (0 < N) and (N <= switch.range) then
                 True->Switch[N]; 
              // N = 0 then
                 false->SwitchMode; 
             if)
          else
             (if arg.peek
              // '-' then
                 arg.get;
                 (if arg.peek
                  // 'd' // 'D' then
                     arg.get;
                     (if arg.eos
                      // true then
                         true->switch[1]; 
                      // false then
                         (if arg.peek
                          // 'e' then
                             arg.get;
                             (if arg.peek // 'x' then dexterOn if);
                             
                         if)
                     if);
                     
                  // 'p' // 'P' then
                     (i+2->Arguments,i+3->Arguments)->activatedFromSif; i+2->i; 
                  // 's' // 'S' then
                     true->SwitchMode; swt.clear; 
                 if);
                 
              else
                 (if arg.length > 0
                  // true then
                     arg->getExtension->ext[];
                     (if ('.bet'->ext.equal) or (astFileExtension->ext.equal)
                      then
                         arg->removeExtension->arg;
                         (if currentDiagramName[] = none then
                             arg.copy->currentDiagramName[];
                             '.diag'->currentDiagramName.append;
                             
                         if);
                         (if switch[1]
                          // true then 'Opening: '->puttext; arg[]->putline; 
                         if);
                         arg->openFragmentGroup
                      else
                         (if '.diag'->ext.equal then
                             arg->checkAutoSaveFile->didRecover;
                             (if (arg,didRecover)->checkDiagFile then
                                 arg->openDiagram
                             if)
                          else
                             'Please select a .bet, .ast or .diag file!'
                               ->GppAlert
                         if)
                     if);
                     
                 if);
                 
             if)
         if)
       for)
   if)
#)  

-- GetGroupName: Descriptor --
(* ask user for a group name *)
  (# name: @Text; ext: ^text; 
  do
     'Select a .bet or .ast file'->DSFileNameDialog->name;
     (if name.length > 0
      // true then
         name->getExtension->ext[];
         (if ('.bet'->ext.equal) or ('.ast'->ext.equal) then
             name->removeExtension->name;
             (if switch[1]
              // true then 'Opening: '->puttext; name[]->putline; 
             if);
             name->openFragmentGroup
          else
             'You must select a .bet or .ast file!'->DSUIUserAckMessage
         if);
         
     if);
     
  #)  

-- OpenFragmentGroup: Descriptor --
(#
   myDocument: ^OADDocument;
   opened: @boolean;
   propd: ^myDocument.theGroupPage.PropertyDiagram;
   fragd: ^myDocument.theGroupPage.FragmentDiagram;
   mess: @Text;
   NoOfForms: @Integer;
   groupFile,autosaveGroupFile,tildeGroupFile: @file;
   ok: @boolean;
   
do
   (if switch[2]
    // true then
       'Opening: '->mess.puttext;
       name[]->mess.puttext;
       mess[]
         ->putLine
         (*
          * mess->statusbar.set; 
          *)
   if);
   '.ast'->name.copyAppend->groupFile.name;
   '.ast#'->name.copyAppend->autosaveGroupFile.name;
   '.ast~'->name.copyAppend->tildeGroupFile.name;
   (if switch[17] then
       'Freja OpenFragmentGroup: '->putLine;
       groupFile.name->putLine;
       autosaveGroupFile.name->putLine;
       tildeGroupFile.name->putLine
   if);
   (if autosaveGroupFile.entry.exists and groupFile.entry.exists then
       (if autosaveGroupFile.entry.modtime > groupFile.entry.modtime then
           'Autosave file is newer, recover?'->DSUIGetUserYesOrNo->ok;
           (if OK then
               'mv .ast# .ast'->putLine;
               groupFile.name->autoSaveGroupFile.entry.rename
            else
               (if tildeGroupFile.entry.exists then
                   'mv .ast~ .ast'->putLine;
                   groupFile.name->tildeGroupFile.entry.rename;
                   'rm .ast#'->putLine;
                   autosaveGroupFile.delete
               if)
           if)
       if)
   if);
   thisOperation:
   (name[]->ExpandToFullPath,screen[])
     ->top.open
       (#
          WriteAccessOnLstFileError::< 
            (# 
            do
               'Access error on .lst file'->mess;
               mess->DSUIUserAckMessage;
               (* statusbar.reset;*)
               true->continue (*'Access error on .lst file'->myException*)
            #);
          writeAccessError::< 
            (# 
            do
               'No write access'->mess;
               mess->DSUIUserAckMessage;
               (* statusbar.reset;*)
               true
                 ->continue
                 (*'Write access error'->myException
                  * *)
            #);
          startingParsing::< 
            (# 
            do
               'Parsing '->mess;
               name[]->mess.putText;
               mess->DSUIUserAckMessage;
               (*               statusbar.reset;*)
               
            #);
          ParseErrors::< 
            (# 
            do
               none ->f[];
               none ->theCatcher[];
               mess->DSUIUserAckMessage;
               (*               statusbar.reset;*)
               leave thisOperation
            #)
       #)->fg[];
   (if fg[]
    // none then
       'Cannot open fragmentgroup: '->mess;
       name[]->mess.puttext;
       mess->DSUIUserAckMessage;
       (*       statusbar.reset;*)
       
    else
       fg.fragmentlist.scan
         (# 
         do (if current.type // formtype then noofforms+1->noofforms if)
         #);
       (if (* fg[] -> isChecked//false *) true
        // false then
           'FragmentGroup '''->puttext;
           name[]->puttext;
           ''' not checked.'->putline;
           'Must be checked by compiler before it can be shown...'->putline;
           
        else
           (if theDocument[]
            // none then
               &OADDocument[]->myDocument[];
               myDocument.new;
               (if NoOfForms
                // 1 then
                   myDocument.CurrentPage->myDocument.theWorkPage[];
                   'WorkSheet'->myDocument.theWorkPage.PageTitle;
                   &myDocument.OADPage[]->myDocument.theGroupPage[];
                   myDocument.theGroupPage.InvisibleNew;
                   myDocument.theWorkPage[]->myDocument.CurrentPage;
                   
                else
                   myDocument.CurrentPage->myDocument.theGroupPage[];
                   myDocument[]->theDocument[]->theOADDocument[];
                   
               if);
               'Group Window'->myDocument.theGroupPage.PageTitle;
               
            else
               theDocument[]->myDocument[];
               (if NoOfForms
                // 1 then 
                else
                   myDocument.theGroupPage.visible; 
               if);
               
           if);
           scanner:
           myDocument.theGroupPage.PatternDiagrams.theList.scanPropertyDiagrams
             (# 
             do
                (if fg.name->(thisDiagram.fullname).equal
                 // true then true->opened; leave scanner; 
                if);
                
             #);
           (if opened
            // true then (* fragment already shown: just show the page *)
               myDocument.theGroupPage[]->myDocument.CurrentPage; 
            else
               (if switch[2]
                // true then
                   'Scanning Properties'->putLine (*statusbar.set; *)
               if);
               &myDocument.theGroupPage.PropertyDiagram[]->propd[];
               (fg[],true,name[]->ExpandToFullPath)->propd.new;
               &myDocument.theGroupPage.FragmentDiagram[]->fragd[];
               (if switch[2]
                // true then
                   'Scanning Fragments'->putLine (*statusbar.set; *)
               if);
               fg[]->fragd.new;
               
           if);
           (*           (if switch[2] // true then statusbar.reset;  if);*)
           (if NoOfForms
            // 1 then
               myDocument.theGroupPage.FragmentDiagram##
                 ->myDocument.theGroupPage.ScanDiagrams
                   (# 
                   do
                      current[]->fragd[];
                      (if fg[]
                       // fragd.theGroup then (* find formname in the diagram *)
                          fragd.localnodes.scan (#  do current.detail #)
                      if)
                   #)
           if);
           
       if)
   if)
#)  

-- OpenFragmentForm: Descriptor --
(#
   index: @Integer;
   groupname,formname: ^Text;
   fg: ^FragmentGroup;
   theDoc: ^OADDocument;
   theDiagram: ^theDoc.theGroupPage.FragmentDiagram;
   noOfForms: @integer;
   
do (* first open the group, and then open the form *)
   '-'->name.findCh (#  do inx->index;  #);
   (1,index-1)->name.sub->groupname[];
   groupname->openFragmentGroup->fg[];
   (index+1,name.length)->name.sub->formname[];
   fg.fragmentlist.scan
     (# 
     do
        (if current.type
         // formtype then
            noofforms+1->noofforms;
            (if (current.f.name->formName.equal)
             // true then current.f[]->ff[]
            if)
        if)
     #);
   theDocument[]->theDoc[];
   theDoc.theGroupPage.FragmentDiagram##
     ->theDoc.TheGroupPage.ScanDiagrams
       (# 
       do
          current[]->theDiagram[];
          theDiagram.fullname->screen.putline;
          (if fg[]
           // theDiagram.theGroup then (* find formname in the diagram *)
              theDiagram.localnodes.scan
                (# t: ^text; 
                do
                   &Text[]->t[];
                   current.theText.get->t;
                   ':'->t.findCh (#  do inx->index #);
                   (1,index-1)->t.sub->t[];
                   EditorID->current.SifEditorInstanceNo;
                   (if (formname[]->t.equal) and (noOfForms > 1)
                    // true then
                    (* if noOfForms = 1 the form has already been opened 
                     * by openFragmentGroup
                     *)
                       current.detail; 
                   if)
                #)
          if)
       #)
#)  

-- autosave: Descriptor --
(#
   dummyFilter: ##external;
   filename,filename2: @Text;
   pageList: ^ObjectList;
   cancelled: ^integerRef;
   prompt: @text;
   count: @ShortRef;
   list: @IntegerRef
do
   '#0 autoSave'->sendSifCommand;
   (if currentDiagramName[] <> none then
       currentDiagramName->removeExtension->fileName;
       '.freja#'->fileName.Append;
       (if switch[17] then
           'Freja autosave:'->putLine; filename[]->putLine; 
       if);
       
    else
       'No currentDiagramName?'->putline
   if);
   SaveLists;
   (if currentDiagramName[] <> none then
       filename2.clear;
       currentDiagramName[]->filename2.puttext;
       '#'->filename2.append;
       (if switch[17] then
           'Freja autosave:'->putLine; filename2[]->putLine; 
       if);
       (count[],list[])->DSStrGetPageList;
       &integerRef[]->cancelled[];
       ' '->prompt.puttext;
       (@@ filename2.T[1],false,cancelled[],true,count,list,dummyFilter##,
        prompt)->DSFileSavePagesAsDiagram
    else
       'Autosave: No current diagram??'->putline
   if)
#)  

-- checkAutoSaveFile: Descriptor --
(#
   frejaFile,autosaveFrejaFile,tildeFrejaFile,diagFile,autosaveDiagFile,
     tildeDiagFile: @file;
   groupFile,autosaveGroupFile,tildeGroupFile: @file;
   ok,doRecover,doNotRecover: @boolean;
   groupName,frejaFileName,autosaveFrejaFileName,tildeFrejaFileName,
     diagFileName,tildeDiagFileName: ^text
do
   name[]->diagFileName[]->diagFile.name;
   '#'->name.copyAppend->autosaveDiagFile.name;
   '~'->name.copyAppend->tildeDiagFileName[]->tildeDiagFile.name;
   name.copy->groupName[];
   groupName->removeExtension->groupName;
   '.freja'->groupName.copyAppend->frejaFileName[]->frejafile.name;
   '.freja#'->groupName.copyAppend->autoSaveFrejaFileName[]
     ->autosavefrejafile.name;
   '.freja~'->groupName.copyAppend->tildeFrejaFileName[]->tildefrejafile.name;
   (if switch[17] then
       'Freja checkAutoSaveFile:'->putLine;
       diagFile.name->putLine;
       autosaveDiagFile.name->putLine;
       tildeDiagFile.name->putLine;
       frejaFile.name->putLine;
       autosaveFrejaFile.name->putLine;
       tildeFrejaFile.name->putLine;
       
   if);
   (if autosaveFrejaFile.entry.exists then
       (if FrejaFile.entry.exists then
           (if autosaveFrejaFile.entry.modtime > FrejaFile.entry.modtime then
               'Autosave file is newer, recover?'->DSUIGetUserYesOrNo->ok;
               (if OK then
                   'mv .freja# .freja'->putLine;
                   FrejaFile.name->autoSaveFrejaFile.entry.rename;
                   true->doRecover;
                   
                else
                   (if tildeFrejaFile.entry.exists then
                       'rm .freja#'->putLine;
                       autosaveFrejaFile.delete;
                       'mv .freja~ .freja'->putLine;
                       FrejaFile.name->tildeFrejaFile.entry.rename;
                       true->doNotRecover
                    else
                       '.freja~ does not exist!!'->putLine
                   if);
                   
               if)
           if)
        else
           'no .freja file?!'->putLine;
           'No .diag file, recover from Autosave file?'->DSUIGetUserYesOrNo->ok;
           (if OK then
               'mv .freja# .freja'->putLine;
               FrejaFile.name->autoSaveFrejaFile.entry.rename;
               true->doRecover;
               
           if)
       if);
       
    else
       (if switch[17] then 'no .freja# file'->putLine if)
   if);
   (if doRecover then
       (if autosaveDiagFile.entry.exists and diagFile.entry.exists then
           (if autosaveDiagFile.entry.modtime > diagFile.entry.modtime then
               'mv .diag .diag~'->putLine;
               tildeDiagFileName[]->diagFile.entry.rename;
               'mv .diag# .diag'->putLine;
               diagFileName[]->autoSaveDiagFile.entry.rename
            else
               'autosaveDiagFile.entry.modtime IS NOT > diagFile.entry.modtime'
                 ->putLine;
               
           if);
           frejaFileName
             ->scanAstFiles
               (# 
               do
                  currentGroupName->groupName;
                  '.ast'->groupName.append;
                  groupName[]->groupFile.name;
                  '#'->groupName.copyAppend->autosaveGroupFile.name;
                  (if switch[17] then
                      groupFile.name->putLine; autosaveGroupFile.name->putLine
                  if);
                  (if groupFile.entry.exists then
                      (if autosaveGroupFile.entry.exists then
                          (if switch[17] then
                              groupFile.name->putText;
                              ': '->putText;
                              groupFile.entry.modtime->putInt;
                              newLine;
                              autosaveGroupFile.name->putText;
                              ': '->putText;
                              autosaveGroupFile.entry.modtime->putInt;
                              newLine
                          if);
                          (if autosaveGroupFile.entry.modtime >
                          groupFile.entry.modtime then
                              'mv .ast# .ast'->putLine;
                              groupFile.name->autoSaveGroupFile.entry.rename
                           else
                              'autosaveGroupFile.entry.modtime IS NOT > groupFile.entry.modtime'
                                ->putLine;
                              
                          if)
                      if)
                   else
                      
                  if)
               #)
        else
           (if autosaveDiagFile.entry.exists then
               'mv .diag# .diag'->putLine;
               diagFileName[]->autoSaveDiagFile.entry.rename;
               frejaFileName
                 ->scanAstFiles
                   (# 
                   do
                      currentGroupName->groupName;
                      '.ast'->groupName.append;
                      groupName[]->groupFile.name;
                      '#'->groupName.copyAppend->autosaveGroupFile.name;
                      (if switch[17] then
                          groupFile.name->putLine;
                          autosaveGroupFile.name->putLine
                      if);
                      (if groupFile.entry.exists then
                          (if autosaveGroupFile.entry.exists then
                              (if switch[17] then
                                  groupFile.name->putText;
                                  ': '->putText;
                                  groupFile.entry.modtime->putInt;
                                  newLine;
                                  autosaveGroupFile.name->putText;
                                  ': '->putText;
                                  autosaveGroupFile.entry.modtime->putInt;
                                  newLine
                              if);
                              (if autosaveGroupFile.entry.modtime >
                              groupFile.entry.modtime then
                                  'mv .ast# .ast'->putLine;
                                  groupFile.name->autoSaveGroupFile.entry.rename
                               else
                                  'autosaveGroupFile.entry.modtime IS NOT > groupFile.entry.modtime'
                                    ->putLine;
                                  
                              if)
                          if)
                       else
                          
                      if)
                   #)
           if)
       if);
       true->didRecover;
       
    else
       (if doNotRecover then
           (if autosaveDiagFile.entry.exists and diagFile.entry.exists then
               (if autosaveDiagFile.entry.modtime > diagFile.entry.modtime then
                   'rm .diag#'->putLine; autosaveDiagFile.delete
                else
                   'autosaveDiagFile.entry.modtime IS NOT > diagFile.entry.modtime'
                     ->putLine;
                   
               if);
               frejaFileName
                 ->scanAstFiles
                   (# 
                   do
                      currentGroupName->groupName;
                      '.ast'->groupName.append;
                      groupName[]->groupFile.name;
                      '#'->groupName.copyAppend->autosaveGroupFile.name;
                      '~'->groupName.copyAppend->tildeGroupFile.name;
                      (if switch[17] then
                          groupFile.name->putLine;
                          autosaveGroupFile.name->putLine;
                          tildeGroupFile.name->putLine
                      if);
                      (if groupFile.entry.exists then
                          (if tildeGroupFile.entry.exists then
                              (if switch[17] then
                                  tildeGroupFile.name->putText;
                                  ': '->putText;
                                  tildeGroupFile.entry.modtime->putInt;
                                  newLine
                              if);
                              'mv .ast~ .ast'->putLine;
                              groupFile.name->tildeGroupFile.entry.rename
                          if);
                          (if autoSaveGroupFile.entry.exists then
                              'rm .ast#'->putLine; autosaveGroupFile.delete
                          if)
                      if)
                   #)
           if)
       if)
   if)
#)  

-- checkDiagFile: Descriptor --
(#
   diagFile,frejaFile,groupFile,betFile: @file;
   groupName,frejaFileName,help: ^text;
   tryRevert: @boolean
do
   thisOperation:
     (# 
     do
        true->OK;
        'Consistency check failed!'->help[];
        help.newLine;
        name[]->diagFile.name;
        (if switch[17] then
            'Freja checkDiagFile:'->putLine;
            diagFile.name->putLine;
            'fromRecovery: '->putText;
            fromRecovery->putInt;
            newlIne;
            
        if);
        (if diagFile.entry.exists then
            name.copy->groupName[];
            groupName->removeExtension->groupName;
            '.freja'->groupName.copyAppend->frejaFileName[]->frejafile.name;
            (if frejafile.entry.exists then
                scanning:
                frejaFileName
                  ->scanAstFiles
                    (# 
                    do
                       currentGroupName->groupName;
                       '.bet'->groupName.copyAppend->betFile.name;
                       '.ast'->groupName.append;
                       groupName[]->groupFile.name;
                       (if groupFile.entry.exists then
                       (* no we cannot be sure of that 
                        (if groupFile.entry.modtime > diagFile.entry.modtime then
                        groupFile.name->help.putLine; help.newLine;
                        'is newer than'->help.putLine; help.newLine;
                        diagFile.name->help.putText;
                        help->gppAlert;
                        false->OK
                        if)*)
                           (if groupFile.entry.modtime <> currentModTime then
                               groupFile.name->help.putLine;
                               'is inconsistent with'->help.putLine;
                               diagFile.name->help.putLine;
                               'Open .ast or .bet file instead'->help.putText;
                               help->gppAlert;
                               help[]->putLine;
                               false->OK;
                               'modtime of .ast file: '->putText;
                               groupFile.entry.modtime->putInt;
                               newLine;
                               'expected modtime: '->putText;
                               currentModtime->putInt;
                               newLine;
                               (if fromRecovery then true->tryRevert if);
                               leave scanning
                           if)
                        else
                           groupFile.name->help.putLine;
                           'does not exist'->help.putLine;
                           'Open .bet file instead'->help.putLine;
                           help->gppAlert;
                           help[]->putLine;
                           false->OK
                       if);
                       (if OK and betFile.entry.exists then
                           (if betFile.entry.modtime > diagFile.entry.modtime
                            then
                               betFile.name->help.putLine;
                               'is newer than'->help.putLine;
                               diagFile.name->help.putLine;
                               'Open .ast or .bet file instead'->help.putText;
                               help->gppAlert;
                               help[]->putLine;
                               false->OK
                           if)
                       if);
                       (if OK and groupFile.entry.exists and
                       betFile.entry.exists then
                           (if betFile.entry.modtime > groupFile.entry.modtime
                            then
                               betFile.name->help.putLine;
                               'is newer than'->help.putLine;
                               groupFile.name->help.putLine;
                               'Open .bet file instead'->help.putText;
                               help->gppAlert;
                               help[]->putLine;
                               false->OK
                           if)
                       if)
                    #)
             else
                frejaFile.name->help.putLine;
                ' does not exist'->help.putLine;
                false->OK;
                'Open .ast or .bet file instead'->help.putText;
                help->gppAlert;
                help[]->putLine
            if)
         else
            diagFile.name->putText; ' does not exist!!'->putLine
        if)
     #);
   (if tryRevert then 'tryRevert'->putLIne; (name,true)->revert if)
#)  

-- revert: Descriptor --
(#
   ok: @Boolean;
   frejaFile,autosaveFrejaFile,tildeFrejaFile,diagFile,autosaveDiagFile,
     tildeDiagFile: @file;
   groupFile,autosaveGroupFile,tildeGroupFile: @file;
   groupName,frejaFileName,autoSaveFrejaFileName,tildeFrejaFileName,help: ^text
do
   thisOperation:
     (# 
     do
        name[]->diagFile.name;
        '#'->name.copyAppend->autosaveDiagFile.name;
        '~'->name.copyAppend->tildeDiagFile.name;
        (if switch[17] then
            'Freja revert:'->putLine;
            diagFile.name->putLine;
            autosaveDiagFile.name->putLine;
            tildeDiagFile.name->putLine
        if);
        (if badRecovery then
            'Revert to latest saved diagram?'->DSUIGetUserYesOrNo->ok
         else
            true->ok
        if);
        (if ok then
            name.copy->groupName[];
            groupName->removeExtension->groupName;
            '.freja'->groupName.copyAppend->frejaFileName[]->frejaFile.name;
            '.freja#'->groupName.copyAppend->autosaveFrejaFileName[]
              ->autosaveFrejaFile.name;
            '.freja~'->groupName.copyAppend->tildeFrejaFileName[]
              ->tildeFrejaFile.name;
            (if badRecovery then
                (if tildeFrejaFile.entry.exists then
                    (if tildeDiagFile.entry.exists then
                        'mv .diag~ .diag'->putLine;
                        diagFile.name
                          ->
                            tildeDiagFile.entry.rename
                            (* frejaFile.name->tildeFrejaFile.entry.rename *)
                     else
                        'No .diag~ file!!'->putLine; leave thisOperation
                    if);
                    tildeFrejaFileName
                      ->scanAstFiles
                        (# 
                        do
                           currentGroupName->groupName;
                           '.ast'->groupName.append;
                           groupName[]->groupFile.name;
                           '~'->groupName.copyAppend->tildeGroupFile.name;
                           (if switch[17] then
                               groupName[]->putLine;
                               tildeGroupFile.name->putLine
                           if);
                           (if tildeGroupFile.entry.exists and
                           groupFile.entry.exists then
                               'mv .ast~ .ast'->putLine;
                               groupFile.name->tildeGroupFile.entry.rename
                           if)
                        #);
                    'mv .freja~ .freja'->putLine;
                    frejaFile.name->tildeFrejaFile.entry.rename;
                    name->openDiagram
                 else
                    'No .freja~ file!!'->putLine
                if)
             else
                (if autosaveFrejaFile.entry.exists then
                    autosaveFrejaFileName
                      ->scanAstFiles
                        (# 
                        do
                           currentGroupName->groupName;
                           '.ast'->groupName.append;
                           groupName[]->groupFile.name;
                           '#'->groupName.copyAppend->autosaveGroupFile.name;
                           '~'->groupName.copyAppend->tildeGroupFile.name;
                           (if switch[17] then
                               groupName[]->putLine;
                               autosaveGroupFile.name->putLine;
                               tildeGroupFile.name->putLine
                           if);
                           (if autosaveGroupFile.entry.exists then
                               'rm .ast#'->putLine; autosaveGroupFile.delete
                           if);
                           (if tildeGroupFile.entry.exists and
                           groupFile.entry.exists then
                               'mv .ast~ .ast'->putLine;
                               groupFile.name->tildeGroupFile.entry.rename
                           if)
                        #);
                    (if tildeFrejaFile.entry.exists then
                        'mv .freja~ .freja'->putLine;
                        frejaFile.name->tildeFrejaFile.entry.rename
                     else
                        'No .freja~ file!!'->putLine
                    if);
                    (if autosaveDiagFile.entry.exists then
                        'rm .diag#'->putLine; autoSaveDiagFile.delete
                    if);
                    'rm .freja#'->putLine;
                    autosaveFrejaFile.delete;
                    closeDiagram;
                    name->openDiagram
                if)
            if)
        if)
     #)
#)
(*
 -- FrejaOptionsMenuInit: Descriptor --
 (#  do (UserMenu3+13,'With Dexter')->WithDexterItem.init;  #)  
 
 -- FrejaOptionsMenuCheckMarks: Descriptor --
 (#  do withDexter->WithDexterItem.check #)  
 *)  

-- scanASTfiles: Descriptor --
(# f: @file; t: ^Text
do
   name[]->f.name;
   f.openRead;
   loop:
     (# 
     do
        (if not f.eos then
            f.getLine->t[];
            (if t[] = none then leave loop if);
            t.reset;
            t.getAtom->currentGroupName[];
            f.getline->t[];
            (if t[] = none then leave loop if);
            t.reset;
            t.getInt->currentModTime;
            INNER scanASTfiles;
            restart loop
        if)
     #);
   f.close
#)  

-- makeFrejaFile: Descriptor --
(#
   f: @file;
   fileName: @Text;
   groupFile,recoveryGroupFile: @file;
   lastChar: @char;
   help: @text;
   fd: ^theOADDocument.theGroupPage.FragmentDiagram;
   theListDiagram: ^theOADDocument.theGroupPage.ListDiagram;
   dirWriteable: (# f: @file enter f.name exit f.entry.writeable #)
do
   l:
   (if name[] <> none then
       name[]->f.name;
       (if switch[17] then
           'Freja makeFrejaFile:'->putLine; f.name->putLine; 
       if);
       (if (f.entry.path.head->dirWriteable)
        // true then
           (if f.entry.writeable
            // true then f.openWrite
            else
                 (# t: @text
                 do
                    'No write access to the file: "'->t;
                    f.name->t.append;
                    '"'->t.putline;
                    'No write access!'->gppAlert;
                    leave l
                 #)
           if)
        else
             (# t: @text
             do
                'No write access to the directory: "'->t;
                f.entry.path.head->t.append;
                '"'->t.putline;
                'No write access!'->gppAlert;
                leave l
             #)
       if);
       theDocument[]->theOADDocument[];
       (if theOADDocument[] = none then
           'theOADDocument[] is none'->putLine
        else
           (if theOADDocument.theGroupPage[] = none then
               'theOADDocument.theGroupPage[] is none'->putLine
            else
               (if theOADDocument.theGroupPage.patternDiagrams[] = none then
                   'theOADDocument.theGroupPage.patternDiagrams[] is none'
                     ->putLine
                else
                   (if theOADDocument.theGroupPage.patternDiagrams.theList[] =
                   none then
                       'theOADDocument.theGroupPage.patternDiagrams.theList[] is none'
                         ->putLine
                    else
                       theOADDocument.theGroupPage.PatternDiagrams.theList.scan
                         (# 
                         do
                            current.e[]->theListDiagram[];
                            (if theListDiagram## <=
                            theOADDocument.theGroupPage.fragmentDiagram## then
                                theListDiagram[]->fd[];
                                fd.fullname->f.putline;
                                name.length->name.inxGet->lastChar;
                                (if (lastChar = '#') or (lastChar = '~') then
                                    (if switch[17] then
                                        'it is a recovery file'->putLine
                                    if);
                                    help.clear;
                                    lastChar->help.put;
                                    help[]
                                      ->((fd.theGroup).diskFileName).copyAppend
                                      ->recoveryGroupFile.name;
                                    (if recoveryGroupFile.entry.exists then
                                        recoveryGroupFile.entry.modtime
                                          ->f.putInt;
                                        (if switch[17] then
                                            fd.fullname->putline;
                                            recoveryGroupFile.entry.modtime
                                              ->putint;
                                            ' '->putline;
                                            
                                        if);
                                        
                                     else
                                        (if lastChar = '#' then
                                            (fd.theGroup).diskFileName
                                              ->groupFile.name;
                                            (if switch[17] then
                                                fd.fullname->putline;
                                                '(fd.theGroup).modtime: '
                                                  ->putText;
                                                (fd.theGroup).modtime->putint;
                                                ' '->putline;
                                                
                                            if);
                                            (if groupFile.entry.exists then
                                                (if switch[17] then
                                                    'groupFile.entry.modtime: '
                                                      ->putText;
                                                    groupFile.entry.modtime
                                                      ->putInt;
                                                    newLine
                                                if);
                                                groupFile.entry.modtime
                                                  ->f.putInt;
                                                
                                             else
                                                'No group file!!'->putLine
                                            if)
                                         else
                                            'No recoveryGroupFile: '->putText;
                                            recoveryGroupFile.name->putLine;
                                            'Should not happen!!'->putLine
                                        if)
                                    if)
                                 else
                                    (fd.theGroup).diskFileName->groupFile.name;
                                    (if switch[17] then
                                        fd.fullname->putline;
                                        '(fd.theGroup).modtime: '->putText;
                                        (fd.theGroup).modtime->putint;
                                        ' '->putline;
                                        
                                    if);
                                    (* (fd.theGroup).modtime->f.putint;*)
                                    (if groupFile.entry.exists then
                                        (if switch[17] then
                                            'groupFile.entry.modtime: '
                                              ->putText;
                                            groupFile.entry.modtime->putInt;
                                            newLine
                                        if);
                                        groupFile.entry.modtime->f.putInt;
                                        
                                     else
                                        'No group file!!'->putLine
                                    if)
                                if);
                                ' '->f.putline
                            if)
                         #)
                   if)
               if)
           if)
       if);
       f.close
    else
       'makeFrejaFile: name is none!!'->putline
   if)
#)  

-- openDiagram: Descriptor --
(#
   count: @ShortRef;
   list: @IntegerRef;
   pages,nodes,conns,regions: [0] @Integer;
   thePage: ^theDocument.Page;
   theOADPage: ^theOADDocument.OADPage;
   theObject: ^thePage.DesignObject;
   theConnID: @integer;
   
do
   name[]->currentDiagramName[];
   'Loading '->puttext;
   name[]->putline;
   (@@ name.T[1])->DSFileOpenDiagram;
   &OADDocument[]->theDocument[]->theOADDocument[];
   theDocument.onInit;
   (count[],list[])->DSStrGetPageList;
   (count,list)->GetIntList->pages;
   (if pages.range > 0 then
       (for i: pages.range repeat
         (if i = 1 then
             &theOADDocument.OADPage[]->thePage[]
               ->theOADDocument.theGroupPage[];
             
          else
             &theOADDocument.OADPage[]->thePage[]->theOADDocument.theWorkPage[];
             
         if)
         (* toby 24-11-94: VERY temporary hack (i hope)!!*)
         ;
         pages[i]->thePage.onInit;
         true->thePage.PageCallBack.specialNode;
         thePage.onReadDiagram;
         
       for);
       theOADDocument.theWorkPage[]->theDocument.CurrentPage;
       theOADDocument.updateUserDataIDs;
       loop
         (#
            i: @integer;
            while::<  (#  do (i+2 <= IndexIDList.impl.range)->value #)
         do
            i+2->i;
            (if IndexIDList.impl[i] <> 0 then
                (if userDataVerbose then
                    'IndexIDList: updating '->puttext;
                    indexidlist.impl[i]->putint
                if);
                IndexIDList.impl[i]->theOADDocument.UserDataIDMap.getID
                  ->IndexIDList.impl[i];
                (if userDataVerbose then
                    ' to '->puttext; indexidlist.impl[i]->putint; newline
                if)
            if)
         #);
       theOADDocument.theWorkPage.PatternDiagrams.theList.scan
         (# theListDiagram: ^theOADDocument.theWorkPage.ListDiagram
         do
            current.e[]->theListDiagram[];
            theListDiagram[]
              ->theOADDocument.theWorkPage.PageCallBack.MakeLocalNodes;
            theListDiagram.titleNode.thePrefixConn.getID->theConnID;
            (if theConnID <> 0 then
                (theListDiagram[],theConnID)
                  ->theOADDocument.theWorkPage.PageCallBack.MakeConn
            if)
         #);
       theOADDocument.theGroupPage.PatternDiagrams.theList.scan
         (# theListDiagram: ^theOADDocument.theGroupPage.ListDiagram
         do
            current.e[]->theListDiagram[];
            theListDiagram[]
              ->theOADDocument.theGroupPage.PageCallBack.MakeLocalNodes;
            theListDiagram.titleNode.thePrefixConn.getID->theConnID;
            (if theConnID <> 0 then
                (theListDiagram[],theConnID)
                  ->theOADDocument.theGroupPage.PageCallBack.MakeConn
            if)
         #);
       theOADDocument.theWorkPage.PatternDiagrams.theList.scan
         (#
            theListDiagram: ^theOADDocument.theWorkPage.ListDiagram;
            thisOADDiagram: ^theOADDocument.theWorkPage.OADDiagram;
            thisFragmentDiagram: ^theOADDocument.theWorkPage.FragmentDiagram;
            theDummyDesc: ^betaGram.ObjectDescriptor;
            thisPatternAttDiagram:
              ^theOADDocument.theWorkPage.PatternAttDiagram;
            theDummyAST: ^AST
         do
            current.e[]->theListDiagram[];
            (if current.e.struc <= theOADDocument.theWorkPage.OADDiagram##
             // true then
                current.e[]->thisOADDiagram[];
                thisOADDiagram.titlenode.theText.get->thisOADDiagram.titleText;
                (if thisOADDiagram.theDescriptor <> none then
                    thisOADDiagram.theDescriptor->theDummyDesc[];
                    theDummyDesc.index->current.index;
                    (if thisOADDiagram## <=
                    theOADDocument.theWorkPage.PatternAttDiagram## then
                        thisOADDiagram[]->thisPatternAttDiagram[];
                        thisPatternAttDiagram.theAST->theDummyAST[];
                        theDummyAST.index->current.index
                    if)
                if);
                
            if);
            (if current.e.struc <= theOADDocument.theWorkPage.FragmentDiagram##
             then
                current.e[]->thisFragmentDiagram[];
                thisFragmentDiagram.titlenode.theText.get
                  ->thisFragmentDiagram.titleText
            if)
         #);
       theOADDocument.theGroupPage.PatternDiagrams.theList.scan
         (#
            theListDiagram: ^theOADDocument.theGroupPage.ListDiagram;
            thisOADDiagram: ^theOADDocument.theGroupPage.OADDiagram;
            thisFragmentDiagram: ^theOADDocument.theGroupPage.FragmentDiagram;
            theDummyDesc: ^betaGram.ObjectDescriptor;
            thisPatternAttDiagram:
              ^theOADDocument.theGroupPage.PatternAttDiagram;
            theDummyAST: ^AST
         do
            current.e[]->theListDiagram[];
            (if current.e.struc <= theOADDocument.theGroupPage.OADDiagram##
             // true then
                current.e[]->thisOADDiagram[];
                thisOADDiagram.titlenode.theText.get->thisOADDiagram.titleText;
                (if thisOADDiagram.theDescriptor <> none then
                    thisOADDiagram.theDescriptor->theDummyDesc[];
                    theDummyDesc.index->current.index;
                    (if thisOADDiagram## <=
                    theOADDocument.theGroupPage.PatternAttDiagram## then
                        thisOADDiagram[]->thisPatternAttDiagram[];
                        thisPatternAttDiagram.theAST->theDummyAST[];
                        theDummyAST.index->current.index
                    if)
                if);
                
            if);
            (if current.e.struc <= theOADDocument.theGroupPage.FragmentDiagram##
             then
                current.e[]->thisFragmentDiagram[];
                thisFragmentDiagram.titlenode.theText.get
                  ->thisFragmentDiagram.titleText
            if)
         #)
    else
       'The selected .diag file does not have the right file format!'
         ->DSUIUserAckMessage
   if)
#)  

-- closeDiagram: Descriptor --
(#
   CheckMenu:
     (# theID: @Integer; theMenu: ^BasicMenu; 
     enter theID
     do
        theID->MenuBar.findMenu->theMenu[];
        (if theMenu[] <> none then
            theMenu[]->MenuBar.remove; theID->DSMenuDeleteMenu
        if);
        
     #);
   pages: ^ObjectList
do
   UserMenu1->CheckMenu;
   UserMenu2->CheckMenu;
   (* UserMenu3 is the fileMenu - do not remove! *)
   UserMenu4->CheckMenu;
   UserMenu5->CheckMenu;
   UserMenu6->CheckMenu;
   UserMenu7->CheckMenu;
   UserMenu8->CheckMenu;
   UserMenu9->CheckMenu;
   UserMenu10->CheckMenu;
   DSMenuShowMenuBar;
   theDocument.GetPages->pages[];
   (if pages[]
    // none then 
    else
       pages.scan
         (# dummy: ^theDocument.Page
         do
            current[]->dummy[];
            (if dummy[]
             // none then 'CloseItem: Page is node'->putline; 
             else
                dummy.close
            if);
            
         #);
       
   if);
   theDocument.close
#)  

-- SaveLists: Descriptor --
(#
   theListDiagram: ^theOADDocument.theWorkPage.ListDiagram;
   fd: ^theOADDocument.theGroupPage.FragmentDiagram;
   theReference: ^theListDiagram.titleNode.PatternDiagNodeReference;
   ok: @Boolean;
   listsize,last: @integer;
   fileName: @text
do
   theDocument[]->theOADDocument[];
   theOADDocument.theWorkPage.PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->theListDiagram[];
        theOADDocument.localNodesUserDataStart+theListDiagram.localNodes.size
          ->theListDiagram.titleNode.OldLocalNodesUDAttributes;
        theListDiagram.titleNode.resetLocalNodesUD
     #);
   theOADDocument.theGroupPage.PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->theListDiagram[];
        theOADDocument.localNodesUserDataStart+theListDiagram.localNodes.size
          ->theListDiagram.titleNode.OldLocalNodesUDAttributes;
        theListDiagram.titleNode.resetLocalNodesUD
     #);
   theOADDocument.theWorkPage.PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->theListDiagram[];
        theListDiagram.localNodes.scan
          (# 
          do
             &theListDiagram.titleNode.PatternDiagNodeReference[]
               ->theReference[];
             theReference.InitLocalNode;
             current[]->theReference;
             
          #)
     #);
   theOADDocument.theGroupPage.PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->theListDiagram[];
        theListDiagram.localNodes.scan
          (# 
          do
             &theListDiagram.titleNode.PatternDiagNodeReference[]
               ->theReference[];
             theReference.InitLocalNode;
             current[]->theReference;
             
          #)
     #);
   (theOADDocument.theGroupPage.ID,499,@@ listsize)->UDReadType->ok;
   (if ok then
       (for i: listsize repeat
         (theOADDocument.theGroupPage.ID,500+i)->UDDeleteType->ok;
         (if ok then
             (if userDataVerbose then
                 'For id '->puttext;
                 theOADDocument.theGroupPage.ID->putint;
                 ' and attributeID '->puttext;
                 500+i->putint;
                 ' delete IndexIDList userdata succeed'->putline
             if)
          else
             (if userDataVerbose then
                 'For id '->puttext;
                 theOADDocument.theGroupPage.ID->putint;
                 ' and attributeID '->puttext;
                 500+i->putint;
                 ' delete IndexIDList userdata fail'->putline
             if)
         if)
       for)
    else
       (if userDataVerbose then 'listsize read fail'->putline if)
   if);
   IndexIDList.impl.range->listsize;
   (theOADDocument.theGroupPage.ID,499,@@ listsize,4)->UDWriteType->ok;
   (if ok then
       (if userDataVerbose then
           'Write IndexIDList.impl.range succeed: '->puttext;
           listsize->putint;
           newline
       if);
       IndexIDList.last->last;
       (theOADDocument.theGroupPage.ID,500,@@ last,4)->UDWriteType->ok;
       (if ok then
           (if userDataVerbose then
               'Write IndexIDList.last succeed: '->puttext;
               last->putint;
               newline
           if);
           (for i: listsize repeat
             (theOADDocument.theGroupPage.ID,500+i,@@ IndexIDList.impl[i],4)
               ->UDWriteType->ok;
             (if ok then
                 (if userDataVerbose then
                     'Write IndexIDList succeed: '->puttext;
                     'element no '->puttext;
                     i->putint;
                     'element '->puttext;
                     IndexIDList.impl[i]->putint;
                     newline
                 if)
              else
                 (if userDataVerbose then
                     'Write IndexIDList fail: '->puttext
                 if)
             if)
           for)
        else
           (if userDataVerbose then
               'Write IndexIDList.last fail: '->puttext
           if)
       if)
    else
       (if userDataVerbose then
           'Write IndexIDList.impl.range fail: '->puttext
       if)
   if);
   theOADDocument.theWorkPage.patternDiagrams.AssociationList.save;
   theOADDocument.theWorkPage.patternDiagrams.InheritanceList.save;
   theOADDocument.theWorkPage.patternDiagrams.DynReferenceList.save;
   (theOADDocument.theWorkPage.ID,240,@@ theOADDocument.theWorkPage.nextX,4)
     ->UDWriteType->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextX succeed'->putline
        else
           'Write NextX fail'->putline
       if)
   if);
   (theOADDocument.theWorkPage.ID,241,@@ theOADDocument.theWorkPage.nextY,4)
     ->UDWriteType->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextY succeed'->putline
        else
           'Write NextY fail'->putline
       if)
   if);
   (theOADDocument.theWorkPage.ID,250,@@
    theOADDocument.theWorkPage.patternDiagrams.NextFreeLine,4)->UDWriteType->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextFreeLine succeed'->putline
        else
           'Write NextFreeLine fail'->putline
       if)
   if);
   (theOADDocument.theWorkPage.ID,251,@@
    theOADDocument.theWorkPage.patternDiagrams.NextFreeColumn,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextFreeColumn succeed'->putline
        else
           'Write NextFreeColumn fail'->putline
       if)
   if);
   (theOADDocument.theWorkPage.ID,252,@@
    theOADDocument.theWorkPage.patternDiagrams.SecondFreeLine,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write SecondFreeLine succeed'->putline
        else
           'Write SecondFreeLine fail'->putline
       if)
   if);
   (theOADDocument.theWorkPage.ID,253,@@
    theOADDocument.theWorkPage.patternDiagrams.SecondFreeColumn,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write SecondFreeColumn succeed'->putline
        else
           'Write SecondFreeColumn fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,240,@@ theOADDocument.theGroupPage.nextX,4)
     ->UDWriteType->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextX succeed'->putline
        else
           'Write NextX fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,241,@@ theOADDocument.theGroupPage.nextY,4)
     ->UDWriteType->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextY succeed'->putline
        else
           'Write NextY fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,250,@@
    theOADDocument.theGroupPage.patternDiagrams.NextFreeLine,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextFreeLine succeed'->putline
        else
           'Write NextFreeLine fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,251,@@
    theOADDocument.theGroupPage.patternDiagrams.NextFreeColumn,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write NextFreeColumn succeed'->putline
        else
           'Write NextFreeColumn fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,252,@@
    theOADDocument.theGroupPage.patternDiagrams.SecondFreeLine,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write SecondFreeLine succeed'->putline
        else
           'Write SecondFreeLine fail'->putline
       if)
   if);
   (theOADDocument.theGroupPage.ID,253,@@
    theOADDocument.theGroupPage.patternDiagrams.SecondFreeColumn,4)->UDWriteType
     ->ok;
   (if userDataVerbose then
       (if ok then
           'Write SecondFreeColumn succeed'->putline
        else
           'Write SecondFreeColumn fail'->putline
       if)
   if)
#)  

-- ScanDiagrams: Descriptor --
(# 
do
   PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->THIS(ScanDiagrams).current[];
        (if theDiagramType##
         // none then INNER ScanDiagrams; 
         else
            (if current.e.struc <= theDiagramType##
             // true then INNER ScanDiagrams; 
            if)
        if)
     #)
#)  

-- MarkNodeDisplay: Descriptor --
(# 
do
   (pos.x,pos.y,gppProp.marksize,gppProp.marksize)->new;
   theNode[]->thePatternDiagramNode;
   THIS(MarkNode)[]->(thePatternDiagramNode).theMarkNode;
   false->sizeable;
   
#)  

-- MarkNodeOnInit: Descriptor --
(# 
do
   UDPrivate.UDMarkNode->UserDataInit;
   thePatternDiagramNode.Init;
   6->theText.size;
   false->moveable;
   false->sizeable;
   (if not initialisingSaved then theNode[]->CreateRegion if);
   
#)  

-- titleGetFragment: Descriptor --
(# fn: ^FragmentNode; 
do
   (if theFragmentNode <> none
    // true then theFragmentNode->fn[]; fn.theFragment->f[]; 
    else
       'DiagramNode: GetFragment: no FragmentNode'->screen.putline
   if)
#)  

-- AssociationConnectorDisplay: Descriptor --
(# 
do
   (THIS(AssociationNode)[],theDiag.titleNode[])->new;
   (if aType
    // one then
       '1'->theText.set
    // many then
       (if secondMany then
           'm'->theText.set
        else
           true->secondMany; 'n'->theText.set
       if)
    else
       'AssociationConnectorDisplay: Unknown type of association!'->putline
   if);
   aType->type;
   theDiag[]->theDiagram;
   
#)  

-- AssociationConnectorOnDelete: Descriptor --
(# n1,n2: ^DesignObject
do
   (if switch[1] then 'AssociationsConnector onDelete'->putline if);
   true->getEnds->(n1[],n2[]);
   (if n1[] <> none then
       (if n1## <= AssociationNode## then n1.delete if)
   if);
   (if n2[] <> none then
       (if n2## <= AssociationNode## then n2.delete if)
   if)
#)  

-- AssociationConnectorOnReattach: Descriptor --
(# 
do
   'Moving association relation is not yet implemented!'->DSUIUserAckMessage;
   false->ok
#)  

-- AssociationConnectorOnInit: Descriptor --
(# 
do
   0->Orient;
   UDPrivate.UDAssociationConnector->UserDataInit;
   type.init;
   theDiagram.init
#)  

-- AssociationConnectorDump: Descriptor --
(# 
do
   '********theDiagram********'->putline;
   (if theDiagram <> none then
       (theDiagram).titleText[]->putline
    else
       'is NONE!'->putline
   if);
   '****type****'->putline;
   type->putint;
   newline;
   INNER dump
#)  

-- AssociationNodeDisplay: Descriptor --
(# x1,x2,y1,y2,x,y: @integer; con1,con2: ^AssociationConnector
do
   diagram1.titleNode.center->(x1,y1);
   diagram2.titleNode.center->(x2,y2);
   (x2+x1) div 2->x;
   (y2+y1) div 2->y;
   (x,y,0,0)->new;
   &AssociationConnector[]->con1[];
   &AssociationConnector[]->con2[];
   (type1,diagram1[])->con1.display;
   (type2,diagram2[])->con2.display;
   con1[]->c1;
   (*can only be assigned to persistent c1,c2 after init (in display).*)
   con2[]->c2
#)  

-- AssociationNodeOnDoubleClick: Descriptor --
(#
   theListDiagram: ^ListDiagram;
   aPatternNode: ^theListDiagram.PatternNode;
   endOne,endTwo: ^PatternDiagramNode;
   x,y,typeOne,typeTwo: @integer
do
   (if thePatternNode <> none then
       (thePatternNode).theDiagram->theListDiagram[];
       thePatternNode->aPatternNode[];
       (if aPatternNode[] <> none then
           (if aPatternNode.hasAttributes then
           (* center->(x,y);
            THIS(AssociationNode)[]->(c1).getOtherEnd->endOne[];
            (c1).type->typeOne;
            THIS(AssociationNode)[]->(c2).getOtherEnd->endTwo[];
            (c2).type->typeTwo;
            delete; *)
               aPatternNode.detail;
               (* (x,y)->(aPatternNode.currentDecomposDiagram).titlenode.move *)
               
            else
               'Association has no attributes??'->putline
           if)
        else
           'No association pattern declaration??'->putline
       if)
   if)
#)  

-- AssociationNodeDetail: Descriptor --
(#  do  #)  

-- AssociationNodeOnInit: Descriptor --
(# 
do
   UDPrivate.UDAssociationNode->UserDataInit;
   thePatternNode.init;
   c1.init;
   c2.init
#)  

-- AssociationNodeNew: Descriptor --
(# p: [8] @integer
do
   0->p[1];
   - 10->p[2];
   10->p[3];
   0->p[4];
   0->p[5];
   10->p[6];
   - 10->p[7];
   0->p[8];
   (for i: p.range repeat p[i]->wcoord->p[i] for);
   (THIS(OADPage).ID,4,@@ p[1])->DSStrCreatePolygon->onInit;
   (x,y)->move;
   true->doneInInner
#)  

-- AssociationNodeDump: Descriptor --
(# 
do
   '****thePatternNode****'->putline;
   (if thePatternNode <> none then
       (thePatternNode).ID->putint; newline
    else
       ' is NONE!'->putline
   if);
   '****c1****'->putline;
   (if c1 <> none then (c1).dump else ' is NONE!'->putline if);
   '****c2****'->putline;
   (if c2 <> none then (c2).dump else ' is NONE!'->putline if);
   INNER dump
#)  

-- DeletableConnectorGetOtherEnd: Descriptor --
(# node1,node2: ^IDObject
do
   true->getEnds->(node1[],node2[]);
   (if (Start[] = node1[]) or (Start[] = node2[]) then
       (if Start[] = node1[] then
           node2[]->OtherEnd[]
        else
           node1[]->OtherEnd[]
       if)
    else
       (if switch[1] then
           'GetOtherEnd: Start is not in either end'->putline
       if)
   if)
#)  

-- DynamicItemConnectorOnInit: Descriptor --
(#
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theOtherOADDiagram: ^OADDiagram;
   aDiagramNode: ^theOtherListDiagram.DiagramNode;
   aSimpleNode: ^theListDiagram.SimpleNode;
   aNonTerminalNode: ^theListDiagram.NonTerminalNode;
   t: ^Text;
   titleText: @text;
   anAST,aDeclAST: ^AST;
   theDesc: ^betaGram.ObjectDescriptor;
   anExp,anotherExp: ^Expanded;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   theAttrDecl: ^betaGram.AttributeDecl;
   existingConnectors: ^ObjectList;
   theCon: ^Connector
do
   (if switch[1] then 'DynamicItemConnector onInit!'->putline if);
   UDPrivate.UDDynamicItemConnector->UserDataInit;
   (if not initialisingSaved then
       true->THIS(DynamicItemConnector).getEnds->(node1[],node2[]);
       (if (node1## <= PatternDiagramNode##) and
       (node2## <= PatternDiagramNode##) then
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           node2[]->anotherPatternDiagramNode[];
           (if (aPatternDiagramNode## <= theListDiagram.SimpleNode##) then
               aPatternDiagramNode[]->aSimpleNode[];
               aPatternDiagramNode.getASTNode->anExp[];
               '#'->t[];
               aPatternDiagramNode.SifEditorInstanceNo->t.putint;
               ' parse '->t.puttext;
               anExp.index->t.putint;
               ' '->t.puttext;
               anExp.getSon1->theNames[];
               theNames.getSon1->theNameDcl[];
               theNameDcl.getNameDecl->anAST[];
               (if anAST.kind = kinds.unExpanded then
                   '<<NameDecl>>'->t.puttext
                else
                   theNameDcl.getText->t.puttext
               if);
               ':^'->t.append;
               anotherPatternDiagramNode.thisDiagram->theOtherListDiagram[];
               (if theOtherListDiagram[] <> none then
                   (if anotherPatternDiagramNode## <=
                   theOtherListDiagram.title## then
                       theOtherListDiagram[]->theOtherOADDiagram[];
                       theOtherOADDiagram.theDescriptor->theDesc[];
                       theDesc.father->anotherExp[];
                       (if anotherExp## <= betaGram.AttributeDecl## then
                           anotherExp[]->aSimpleNode.theQualification;
                           anotherExp[]->private.dynamicReferenceQual[];
                           (anExp[],anotherExp[])->getQualificationWithPath
                             ->t.puttext;
                           (if theListDiagram[] = theOtherListDiagram[] then
                               Delete
                            else
                               THIS(DynamicItemConnector)[]
                                 ->aSimpleNode.theReferenceConnector;
                               
                           if);
                           t[]->sendSifCommand
                        else
                           Delete;
                           'Destination is singularly defined'
                             ->DSUIUserAckMessage
                       if)
                   if)
                else
                   anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
                   (if
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.PatternNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.VirtualNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.BindingNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.FinalNode##) then
                       anotherPatternDiagramNode[]->aDiagramNode[];
                       aDiagramNode.theDeclaration->theAttrDecl[];
                       theAttrDecl[]->aSimpleNode.theQualification;
                       theAttrDecl[]->private.dynamicReferenceQual[];
                       (anExp[],theAttrDecl[])->getQualificationWithPath
                         ->t.puttext;
                       (if theListDiagram[] = theOtherListDiagram[] then
                           Delete
                        else
                           THIS(DynamicItemConnector)[]
                             ->aSimpleNode.theReferenceConnector
                       if);
                       t[]->sendSifCommand
                    else
                       Delete;
                       'The destination is not a pattern, virtual, binding or final declaration!'
                         ->DSUIUserAckMessage
                   if)
               if)
            else
               (if aPatternDiagramNode## <= theListDiagram.NonTerminalNode##
                then
                   aPatternDiagramNode[]->aNonTerminalNode[];
                   '#'->t[];
                   aNonTerminalNode.SifEditorInstanceNo->t.putint;
                   ' parse '->t.puttext;
                   (aNonTerminalNode.unExp).index->t.putint;
                   ' '->t.puttext;
                   '<<NameDecl>>:^'->t.append;
                   anotherPatternDiagramNode.thisDiagram->theOtherListDiagram[];
                   (if theOtherListDiagram[] <> none then
                       (if anotherPatternDiagramNode## <=
                       theOtherListDiagram.title## then
                           theOtherListDiagram[]->theOtherOADDiagram[];
                           theOtherOADDiagram.theDescriptor->theDesc[];
                           theDesc.father->anotherExp[];
                           (if anotherExp## <= betaGram.AttributeDecl## then
                               anotherExp[]->private.dynamicReferenceQual[];
                               (aNonTerminalNode.unExp,anotherExp[])
                                 ->getQualificationWithPath->t.puttext;
                               (if theListDiagram[] = theOtherListDiagram[] then
                                   Delete
                                else
                                   THIS(DynamicItemConnector)[]
                                     ->private.dynamicConnector[]
                               if);
                               t[]->sendSifCommand
                            else
                               Delete;
                               'Destination is singularly defined'
                                 ->DSUIUserAckMessage
                           if)
                       if)
                    else
                       anotherPatternDiagramNode.theDiagram
                         ->theOtherListDiagram[];
                       (if
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.PatternNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.VirtualNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.BindingNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.FinalNode##) then
                           anotherPatternDiagramNode[]->aDiagramNode[];
                           aDiagramNode.theDeclaration->theAttrDecl[];
                           theAttrDecl[]->private.dynamicReferenceQual[];
                           (aNonTerminalNode.unExp,theAttrDecl[])
                             ->getQualificationWithPath->t.puttext;
                           (if theListDiagram[] = theOtherListDiagram[] then
                               Delete
                            else
                               THIS(DynamicItemConnector)[]
                                 ->private.dynamicConnector[]
                           if);
                           t[]->sendSifCommand
                        else
                           Delete;
                           'The destination is not a pattern, virtual, binding or final declaration!'
                             ->DSUIUserAckMessage
                       if)
                   if)
                else
                   Delete;
                   'Source must be either a nonterminal or a simple declaration'
                     ->DSUIUserAckMessage
               if)
           if)
        else
           Delete;
           'Source or destination is not part of a pattern diagram!'
             ->DSUIUserAckMessage
       if);
       (if ID <> 0 (*A connector was created*) then
           (if not gppProp.references then false->BorderVisible if);
           node1.getconnectors->existingConnectors[];
           (if existingConnectors[] <> none then
               existingConnectors.scan
                 (# 
                 do
                    (if (current[] <> THIS(dynamicItemConnector)[]) and
                    ((current## <= DynamicItemConnector##) or
                     (current## <= DynamicComponentConnector##)) then
                        current[]->theCon[]; theCon.delete
                    if)
                 #)
           if)
       if)
   if)
#)  

-- DynamicItemConnectorOnDelete: Descriptor --
(#
   node1,node2,dummy: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theSimpleNode: ^theListDiagram.SimpleNode;
   anAST: ^AST;
   theDeclaration: ^betaGram.AttributeDecl;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   t: ^Text
do
   (if switch[1] then 'DynamicItemConnector onDelete!'->putline if);
   true->getEnds->(node1[],node2[]);
   node1.theDiagram->theListDiagram[];
   node2.theDiagram->theOtherListDiagram[];
   (if node2## <= theOtherListDiagram.SimpleNode## then
       node1[]->dummy[];
       node2[]->node1[];
       dummy[]->node2[];
       theListDiagram[]->theOtherListDiagram[]
   if);
   '#'->t[];
   node1.SifEditorInstanceNo->t.putint;
   ' parse '->t.puttext;
   node1[]->theSimpleNode[];
   none ->theSimpleNode.theReferenceConnector;
   none ->theSimpleNode.theQualification;
   theSimpleNode.theDeclaration->theDeclaration[];
   theDeclaration.index->t.putint;
   ' '->t.puttext;
   theDeclaration.getSon1->theNames[];
   theNames.getSon1->theNameDcl[];
   theNameDcl.getNameDecl->anAST[];
   (if anAST.kind = kinds.unExpanded then
       '<<NameDecl>>'->t.puttext
    else
       theNameDcl.getText->t.puttext
   if);
   ':^ <<AttributeDenotation>>'->t.append;
   t[]->sendSifCommand;
   
#)  

-- DynamicItemConnectorOnReattach: Descriptor --
(#
   node1,node2,dummy: ^DesignObject;
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theOtherOADDiagram: ^OADDiagram;
   aSimpleNode: ^theListDiagram.SimpleNode;
   aDiagramNode: ^theOtherListDiagram.DiagramNode;
   anAST,aDeclAST: ^AST;
   anExp,anotherExp: ^Expanded;
   theAttrDecl: ^betaGram.AttributeDecl;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   theDesc: ^betaGram.ObjectDescriptor;
   t: ^Text;
   titleText: @Text;
   theCon: ^Connector
do
   true->getEnds->(node1[],node2[]);
   (if switch[1] then
       'DynamicItemConnectorOnReattach!'->putline;
       'node1: '->puttext;
       node1.id->putint;
       newline;
       'node2: '->puttext;
       node2.id->putint;
       newline
   if);
   (if whichEnd then
       (if theNew## <= PatternDiagramNode## then
           theNew[]->anotherPatternDiagramNode[];
           anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           aPatternDiagramNode[]->aSimpleNode[];
           aPatternDiagramNode.getASTNode->anExp[];
           '#'->t[];
           aPatternDiagramNode.SifEditorInstanceNo->t.putint;
           ' parse '->t.puttext;
           anExp.index->t.putint;
           ' '->t.puttext;
           anExp.getSon1->theNames[];
           theNames.getSon1->theNameDcl[];
           theNameDcl.getNameDecl->anAST[];
           (if anAST.kind = kinds.unExpanded then
               '<<NameDecl>>'->t.puttext
            else
               theNameDcl.getText->t.puttext
           if);
           ':^'->t.append;
           (if anotherPatternDiagramNode## <= theOtherListDiagram.title## then
               theOtherListDiagram[]->theOtherOADDiagram[];
               theOtherOADDiagram.theDescriptor->theDesc[];
               theDesc.father->anotherExp[];
               anotherExp[]->aSimpleNode.theQualification;
               (anExp[],anotherExp[])->getQualificationWithPath->t.puttext;
               (if theListDiagram[] = theOtherListDiagram[] then
                   Delete
                else
                   THIS(DynamicItemConnector)[]
                     ->aSimpleNode.theReferenceConnector;
                   
               if);
               t[]->sendSifCommand
            else
               (if
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.PatternNode##) or
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.VirtualNode##) or
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.BindingNode##) or
               (anotherPatternDiagramNode## <= theOtherListDiagram.FinalNode##)
                then
                   anotherPatternDiagramNode[]->aDiagramNode[];
                   aDiagramNode.theDeclaration->theAttrDecl[];
                   theAttrDecl[]->aSimpleNode.theQualification;
                   (anExp[],theAttrDecl[])->getQualificationWithPath->t.puttext;
                   (if theListDiagram[] = theOtherListDiagram[] then
                       Delete
                   if);
                   t[]->sendSifCommand
                else
                   'The destination is not a pattern, virtual, binding or final declaration!'
                     ->DSUIUserAckMessage;
                   false->ok
               if)
           if)
        else
           'The relation has been attached to a node that is not part of a pattern diagram'
             ->DSUIUserAckMessage;
           false->ok
       if)
    else
       'Moving simpleDecl end of relation not yet implemented!'
         ->DSUIUserAckMessage;
       false->ok
   if)
#)  

-- DynamicComponentConnectorOnInit: Descriptor --
(#
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theOtherOADDiagram: ^OADDiagram;
   aSimpleNode: ^theListDiagram.SimpleNode;
   aNonTerminalNode: ^theListDiagram.NonTerminalNode;
   aDiagramNode: ^theOtherListDiagram.DiagramNode;
   t: ^Text;
   titleText: @text;
   anAST,aDeclAST: ^AST;
   theDesc: ^betaGram.ObjectDescriptor;
   anExp,anotherExp: ^Expanded;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   theAttrDecl: ^betaGram.AttributeDecl;
   existingConnectors: ^ObjectList;
   theCon: ^Connector
do
   (if switch[1] then 'DynamicComponentConnector onInit!'->putline if);
   UDPrivate.UDDynamicComponentConnector->UserDataInit;
   (if not initialisingSaved then
       true->getEnds->(node1[],node2[]);
       (if (node1## <= PatternDiagramNode##) and
       (node2## <= PatternDiagramNode##) then
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           node2[]->anotherPatternDiagramNode[];
           (if (aPatternDiagramNode## <= theListDiagram.SimpleNode##) then
               aPatternDiagramNode[]->aSimpleNode[];
               aPatternDiagramNode.getASTNode->anExp[];
               '#'->t[];
               aPatternDiagramNode.SifEditorInstanceNo->t.putint;
               ' parse '->t.puttext;
               anExp.index->t.putint;
               ' '->t.puttext;
               anExp.getSon1->theNames[];
               theNames.getSon1->theNameDcl[];
               theNameDcl.getNameDecl->anAST[];
               (if anAST.kind = kinds.unExpanded then
                   '<<NameDecl>>'->t.puttext
                else
                   theNameDcl.getText->t.puttext
               if);
               ':^|'->t.append;
               anotherPatternDiagramNode.thisDiagram->theOtherListDiagram[];
               (if theOtherListDiagram[] <> none then
                   (if anotherPatternDiagramNode## <=
                   theOtherListDiagram.title## then
                       theOtherListDiagram[]->theOtherOADDiagram[];
                       theOtherOADDiagram.theDescriptor->theDesc[];
                       theDesc.father->anotherExp[];
                       (if anotherExp## <= betaGram.AttributeDecl## then
                           anotherExp[]->aSimpleNode.theQualification;
                           anotherExp[]->private.dynamicReferenceQual[];
                           (anExp[],anotherExp[])->getQualificationWithPath
                             ->t.puttext;
                           (if theListDiagram[] = theOtherListDiagram[] then
                               Delete
                            else
                               THIS(DynamicComponentConnector)[]
                                 ->aSimpleNode.theReferenceConnector;
                               
                           if);
                           t[]->sendSifCommand
                        else
                           'Destination is singularly defined'
                             ->DSUIUserAckMessage
                       if)
                   if)
                else
                   anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
                   (if
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.PatternNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.VirtualNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.BindingNode##) or
                   (anotherPatternDiagramNode## <=
                    theOtherListDiagram.FinalNode##) then
                       anotherPatternDiagramNode[]->aDiagramNode[];
                       aDiagramNode.theDeclaration->theAttrDecl[];
                       theAttrDecl[]->aSimpleNode.theQualification;
                       theAttrDecl[]->private.dynamicReferenceQual[];
                       (anExp[],theAttrDecl[])->getQualificationWithPath
                         ->t.puttext;
                       (if theListDiagram[] = theOtherListDiagram[] then
                           Delete
                        else
                           THIS(DynamicComponentConnector)[]
                             ->aSimpleNode.theReferenceConnector
                       if);
                       t[]->sendSifCommand
                    else
                       Delete;
                       'The destination is not a pattern, virtual, binding or final declaration!'
                         ->DSUIUserAckMessage
                   if)
               if)
            else
               (if aPatternDiagramNode## <= theListDiagram.NonTerminalNode##
                then
                   aPatternDiagramNode[]->aNonTerminalNode[];
                   '#'->t[];
                   aNonTerminalNode.SifEditorInstanceNo->t.putint;
                   ' parse '->t.puttext;
                   (aNonTerminalNode.unExp).index->t.putint;
                   ' '->t.puttext;
                   '<<NameDecl>>:^|'->t.append;
                   anotherPatternDiagramNode.thisDiagram->theOtherListDiagram[];
                   (if theOtherListDiagram[] <> none then
                       (if anotherPatternDiagramNode## <=
                       theOtherListDiagram.title## then
                           theOtherListDiagram[]->theOtherOADDiagram[];
                           theOtherOADDiagram.theDescriptor->theDesc[];
                           theDesc.father->anotherExp[];
                           (if anotherExp## <= betaGram.AttributeDecl## then
                               anotherExp.getSon1->theNames[];
                               anotherExp[]->private.dynamicReferenceQual[];
                               (aNonTerminalNode.unExp,anotherExp[])
                                 ->getQualificationWithPath->t.puttext;
                               (if theListDiagram[] = theOtherListDiagram[] then
                                   Delete
                                else
                                   THIS(DynamicComponentConnector)[]
                                     ->private.dynamicConnector[]
                               if);
                               t[]->sendSifCommand
                            else
                               'Destination is singularly defined'
                                 ->DSUIUserAckMessage
                           if)
                       if)
                    else
                       anotherPatternDiagramNode.theDiagram
                         ->theOtherListDiagram[];
                       (if
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.PatternNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.VirtualNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.BindingNode##) or
                       (anotherPatternDiagramNode## <=
                        theOtherListDiagram.FinalNode##) then
                           anotherPatternDiagramNode[]->aDiagramNode[];
                           aDiagramNode.theDeclaration->theAttrDecl[];
                           theAttrDecl[]->private.dynamicReferenceQual[];
                           (aNonTerminalNode.unExp,theAttrDecl[])
                             ->getQualificationWithPath->t.puttext;
                           (if theListDiagram[] = theOtherListDiagram[] then
                               Delete
                            else
                               
                           if);
                           t[]->sendSifCommand
                        else
                           Delete;
                           'The destination is not a pattern, virtual, binding or final declaration!'
                             ->DSUIUserAckMessage
                       if)
                   if)
                else
                   Delete;
                   'Source must be either a nonterminal or a simple declaration'
                     ->DSUIUserAckMessage
               if)
           if)
        else
           Delete;
           'Source or destination is not part of a pattern diagram!'
             ->DSUIUserAckMessage
       if);
       (if ID <> 0 (*A connector was created*) then
           (if not gppProp.references then false->BorderVisible if);
           node1.getconnectors->existingConnectors[];
           (if existingConnectors[] <> none then
               existingConnectors.scan
                 (# 
                 do
                    (if (current[] <> THIS(dynamicComponentConnector)[]) and
                    ((current## <= DynamicItemConnector##) or
                     (current## <= DynamicComponentConnector##)) then
                        current[]->theCon[]; theCon.delete
                    if)
                 #)
           if)
       if)
   if)
#)  

-- DynamicComponentConnectorOnDelete: Descriptor --
(#
   node1,node2,dummy: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theSimpleNode: ^theListDiagram.SimpleNode;
   anAST: ^AST;
   theDeclaration: ^betaGram.AttributeDecl;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   t: ^Text
do
   (if switch[1] then 'DynamicItemConnector onDelete!'->putline if);
   true->getEnds->(node1[],node2[]);
   node1.theDiagram->theListDiagram[];
   node2.theDiagram->theOtherListDiagram[];
   (if node2## <= theOtherListDiagram.SimpleNode## then
       node1[]->dummy[];
       node2[]->node1[];
       dummy[]->node2[];
       theListDiagram[]->theOtherListDiagram[]
   if);
   '#'->t[];
   node1.SifEditorInstanceNo->t.putint;
   ' parse '->t.puttext;
   node1[]->theSimpleNode[];
   none ->theSimpleNode.theReferenceConnector;
   none ->theSimpleNode.theQualification;
   theSimpleNode.theDeclaration->theDeclaration[];
   theDeclaration.index->t.putint;
   ' '->t.puttext;
   theDeclaration.getSon1->theNames[];
   theNames.getSon1->theNameDcl[];
   theNameDcl.getNameDecl->anAST[];
   (if anAST.kind = kinds.unExpanded then
       '<<NameDecl>>'->t.puttext
    else
       theNameDcl.getText->t.puttext
   if);
   ':^| <<AttributeDenotation>>'->t.append;
   t[]->sendSifCommand;
   
#)  

-- DynamicComponentConnectorOnReattach: Descriptor --
(#
   node1,node2,dummy: ^DesignObject;
   aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theOtherOADDiagram: ^OADDiagram;
   aSimpleNode: ^theListDiagram.SimpleNode;
   aDiagramNode: ^theOtherListDiagram.DiagramNode;
   anAST,aDeclAST: ^AST;
   anExp,anotherExp: ^Expanded;
   theAttrDecl: ^betaGram.AttributeDecl;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   theDesc: ^betaGram.ObjectDescriptor;
   t: ^Text;
   titleText: @Text;
   theCon: ^Connector
do
   true->getEnds->(node1[],node2[]);
   (if switch[1] then
       'DynamicComponentConnectorOnReattach!'->putline;
       'node1: '->puttext;
       node1.id->putint;
       newline;
       'node2: '->puttext;
       node2.id->putint;
       newline
   if);
   (if whichEnd then
       (if theNew## <= PatternDiagramNode## then
           theNew[]->anotherPatternDiagramNode[];
           anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
           node1[]->aPatternDiagramNode[];
           aPatternDiagramNode.theDiagram->theListDiagram[];
           aPatternDiagramNode[]->aSimpleNode[];
           aPatternDiagramNode.getASTNode->anExp[];
           '#'->t[];
           aPatternDiagramNode.SifEditorInstanceNo->t.putint;
           ' parse '->t.puttext;
           anExp.index->t.putint;
           ' '->t.puttext;
           anExp.getSon1->theNames[];
           theNames.getSon1->theNameDcl[];
           theNameDcl.getNameDecl->anAST[];
           (if anAST.kind = kinds.unExpanded then
               '<<NameDecl>>'->t.puttext
            else
               theNameDcl.getText->t.puttext
           if);
           ':^|'->t.append;
           (if anotherPatternDiagramNode## <= theOtherListDiagram.title## then
               theOtherListDiagram[]->theOtherOADDiagram[];
               theOtherOADDiagram.theDescriptor->theDesc[];
               theDesc.father->anotherExp[];
               anotherExp[]->aSimpleNode.theQualification;
               (anExp[],anotherExp[])->getQualificationWithPath->t.puttext;
               (if theListDiagram[] = theOtherListDiagram[] then
                   Delete
                else
                   THIS(DynamicComponentConnector)[]
                     ->aSimpleNode.theReferenceConnector;
                   
               if);
               t[]->sendSifCommand
            else
               (if
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.PatternNode##) or
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.VirtualNode##) or
               (anotherPatternDiagramNode## <=
                theOtherListDiagram.BindingNode##) or
               (anotherPatternDiagramNode## <= theOtherListDiagram.FinalNode##)
                then
                   anotherPatternDiagramNode[]->aDiagramNode[];
                   aDiagramNode.theDeclaration->theAttrDecl[];
                   (anExp[],theAttrDecl[])->getQualificationWithPath->t.puttext;
                   (if theListDiagram[] = theOtherListDiagram[] then
                       Delete
                   if);
                   t[]->sendSifCommand
                else
                   'The destination is not a pattern, virtual, binding or final declaration!'
                     ->DSUIUserAckMessage;
                   false->ok
               if)
           if)
        else
           'The relation has been attached to a node that is not part of a pattern diagram'
             ->DSUIUserAckMessage;
           false->ok
       if)
    else
       'Moving simpleDecl end of relation not yet implemented!'
         ->DSUIUserAckMessage;
       false->ok
   if)
#)  

-- getQualificationWithPath: Descriptor --
(#
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   aDeclAST,nca,ncDecl: ^AST;
   keepT: ^Text;
   qualSonNo,refSonNo: @integer;
   getSurroundingDecl:
     (# anAST: ^AST; attDecl: ^betaGram.AttributeDecl
     enter anAST[]
     do
        (if anAST.father
         // none then 
         else
            anAst.father->anAST[];
            (if anAST.symbol
             // BetaGram.PatternDecl // betaGram.VirtualDecl
             // betaGram.BindingDecl // betaGram.FinalDecl
             // betaGram.SimpleDecl then
                anAST[]->attDecl[]
             else
                anAST[]->getSurroundingDecl->attDecl[]
            if)
        if)
     exit attDecl[]
     #)
do
   qual.getSon1->theNames[];
   theNames.getSon1->theNameDcl[];
   theNameDcl.getNameDecl->aDeclAST[];
   (if aDeclAST.kind = kinds.unExpanded then
       '<<NameAppl>>'->t[]->keepT[]
    else
       theNameDcl.getText->t[]->keepT[]
   if);
   (*ref=qual only happens with associations*)
   (if not (ref[]->qual.equal) then
       (if ref.frag[] = qual.frag[] then
           ref[]->qual.nearestCommonAncestor->(nca[],qualSonNo,refSonNo);
           (if not (nca## <= betaGram.AttributeDecl##) then
               nca[]->getSurroundingDecl->ncDecl[]
           if)
       if);
       (if ncDecl[] = none then
           loop:
             (# 
             do
                qual[]->getSurroundingDecl->qual[];
                (if qual[] <> none then
                    qual.getSon1->theNames[];
                    theNames.getSon1->theNameDcl[];
                    theNameDcl.getNameDecl->aDeclAST[];
                    (if aDeclAST.kind = kinds.unExpanded then
                        '<<NameAppl>>.'->t.prepend
                     else
                        '.'->t.prepend; theNameDcl.getText->t.prepend
                    if);
                    restart loop
                if)
             #)
        else
           (if not (qual[]->ncDecl.equal) then
               qual[]->getSurroundingDecl->qual[];
               (if qual[] <> none then
                   (if not (qual[]->ncDecl.equal) then
                       loop:
                         (# 
                         do
                            qual.getSon1->theNames[];
                            theNames.getSon1->theNameDcl[];
                            theNameDcl.getNameDecl->aDeclAST[];
                            (if aDeclAST.kind = kinds.unExpanded then
                                '<<NameAppl>>.'->t.prepend
                             else
                                '.'->t.prepend; theNameDcl.getText->t.prepend
                            if);
                            qual[]->getSurroundingDecl->qual[];
                            (if qual[] <> none then
                                (if not (qual[]->ncDecl.equal) then
                                    restart loop
                                if)
                             else
                                keepT[]->t[]
                            if)
                         #)
                   if)
                else
                   keepT[]->T[]
               if)
           if)
       if)
   if)
#)  

-- GppFileNameDialog: Descriptor --
(#
   cstr: @IntegerRef;
   filt: external
     (# ok: @integer; fisk: @Integer; 
     enter fisk
     do cExternalEntry; true->ok; 
     exit ok
     #);
   cStringToCharR: external
     (# cStr: @integer; c: [1] @char
     enter cStr
     do 'copyInput'->callC; 
     exit c
     #);
   DSF: external
     (#
        ok: @boolean;
        requestlabel,okButtonLabel,initialPath: [1] @char;
        filterProc: ##external;
        exitPathPP: ^IntegerRef;
        
     enter (requestlabel,okButtonLabel,initialPath,filterProc##,exitPathPP[])
     do 'DSFile_NameDialog'->callC; 
     exit ok
     #);
   
do
   (if (message,label,'',filt##,cstr[])->DSF
    // true then cstr->cStringToCharR->filename; 
   if);
   
#)  

-- GppOADPagePrivate: Descriptor --
(#
   dynamicReferenceQual: ^betaGram.AttributeDecl;
   dynamicConnector: ^DeletableConnector
#)  

