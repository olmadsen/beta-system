ORIGIN 'diagramattributes';
INCLUDE '../treeprettyprint';
-- prependCurrentPath: DoPart --
do
   name.lgth->len;
   '/'->name.findAll (#  do (if inx < len then inx->i if) #);
   (if i = 0 then mps.thePathHandler.currentDirectory->name.prepend if)  

-- BoxToNode: DoPart --
do
   (if theNode## <= SurroundBox## then
         (# idObj: ^IDObject
         do
            theNode.getParent->idObj[];
            (if idObj[] <> none then
                (if idObj## <= DesignObject## then
                    idObj[]->theNode[]
                 else
                    'BoxToNode: Surroundbox parent is not a DesignObject?!'
                      ->stdErr.putline
                if)
             else
                'BoxToNode: Surroundbox has no parent?!'->stdErr.putline
            if)
         #)
   if)  

-- ASTToNode: Descriptor --
(# 
do
   (if switch[12] then 'ASTtoNode: '->putText if);
   (if anAST[]
    // none then 'ASTtoNode: anAST is none!'->stdErr.putLine; 
    else
       (if switch[12] then anAST.index->putInt;  if);
       search:
         (# 
         do
            (if theWorkPage[] <> none then
                theWorkPage.patternDiagrams.theList.scan
                  (# theListDiagram: ^theWorkPage.ListDiagram
                  do
                     (if current.e## <= theWorkPage.ListDiagram## then
                         current.e[]->theListDiagram[];
                         theListDiagram.localNodes.scan
                           (#
                              theDiagramNode: ^theListDiagram.DiagramNode;
                              theNonTerminalNode:
                                ^theListDiagram.NonTerminalNode;
                              theSlotNode: ^theListDiagram.SlotNode
                           do
                              (if current## <= theListDiagram.DiagramNode## then
                                  current[]->theDiagramNode[];
                                  (if
                                  theDiagramNode.theDeclaration->anAST.equal
                                   then
                                      theDiagramNode[]->theNode[]; leave search
                                  if)
                              if);
                              (if current## <= theListDiagram.NonTerminalNode##
                               then
                                  current[]->theNonTerminalNode[];
                                  (if theNonTerminalNode.unExp->anAST.equal then
                                      theNonTerminalNode[]->theNode[];
                                      leave search
                                  if)
                              if);
                              (if current## <= theListDiagram.SlotNode## then
                                  current[]->theSlotNode[];
                                  (if theSlotNode.unExp->anAST.equal then
                                      theSlotNode[]->theNode[]; leave search
                                  if)
                              if)
                           #)
                     if)
                  #)
            if);
            theGroupPage.patternDiagrams.theList.scan
              (# theFragmentDiagram: ^theGroupPage.FragmentDiagram
              do
                 (if current.e## <= theGroupPage.FragmentDiagram## then
                     current.e[]->theFragmentDiagram[];
                     theFragmentDiagram.localNodes.scan
                       (# 
                       do
                          (if (current.astIndex = anAST.index) and
                          ((anAST.frag.father).fullname
                             ->(theFragmentDiagram.fullname).equal) then
                              current[]->theNode[]; leave search
                          if);
                          (* 
                           Loops indefinetly in connection with New Prg./Lib.
                           (if current## <= theListDiagram.FragmentNode## then
                           current[]->theFragmentNode[];
                           (if theFragmentNode.theRoot->anAST.equal then
                           theFragmentNode[]->theNode[]; leave search
                           if)
                           if)*)
                          
                       #)
                 if)
              #)
         #);
       (*        search:
        anAST.index
        ->indexIDList.scan
        (# theObject: ^PatternDiagramNode; ff: ^mps.fragmentForm
        do
        currentNode[]->theObject[];
        (if theObject.getFragment
        // none then
        'ASTtoNode: theNode.getFragment is none!'->putLine; 
        else
        theObject.getFragment->ff[];
        (if ff[] = anAST.frag[] then
        theObject[]->theNode[]; leave search
        if)
        if);
        
        #);*)
       (if switch[12] then
           ' return: '->putText;
           (if theNode[]
            // none then 'none'->putLine
            else
               theNode.id->putInt; newLine
           if);
           
       if)
   if);
   
#)  

-- ASTToNodeListUpdate: Descriptor --
(# ff: ^mps.fragmentform; oldASTName: ^Text; 
do
   (if switch[12] then 'ASTtoNodeListUpdate: '->putText;  if);
   (if oldAST[]
    // none then 'ASTtoNodeListUpdate: oldAST is none!'->putLine; 
    else
       (if switch[12] then oldAST.index->putInt; ' '->put;  if);
       (if newAST[]
        // none then 'ASTtoNodeListUpdate: newAST is none!'->putLine; 
        else
           search:
             (# 
             do
                (if theWorkPage[] <> none then
                    theWorkPage.patternDiagrams.theList.scan
                      (# theListDiagram: ^theWorkPage.ListDiagram
                      do
                         (if current.e## <= theWorkPage.ListDiagram## then
                             current.e[]->theListDiagram[];
                             theListDiagram.localNodes.scan
                               (#
                                  theDiagramNode: ^theListDiagram.DiagramNode;
                                  theNonTerminalNode:
                                    ^theListDiagram.NonTerminalNode
                               do
                                  (if current## <= theListDiagram.DiagramNode##
                                   then
                                      current[]->theDiagramNode[];
                                      (if
                                      theDiagramNode.theDeclaration
                                        ->oldAST.equal then
                                          theDiagramNode[]->theNode[]
                                      if)
                                  if);
                                  (if current## <=
                                  theListDiagram.NonTerminalNode## then
                                      current[]->theNonTerminalNode[];
                                      (if
                                      theNonTerminalNode.unExp->oldAST.equal
                                       then
                                          theNonTerminalNode[]->theNode[]
                                      if)
                                  if)
                               #)
                         if)
                      #)
                if);
                theGroupPage.patternDiagrams.theList.scan
                  (# theListDiagram: ^theGroupPage.ListDiagram
                  do
                     (if current.e## <= theGroupPage.ListDiagram## then
                         current.e[]->theListDiagram[];
                         theListDiagram.localNodes.scan
                           (# 
                           do
                              (if current.astIndex = oldAST.index then
                                  current[]->theNode[]; leave search
                              if)
                              (*(if current## <= theListDiagram.FragmentNode## then
                               current[]->theFragmentNode[];
                               (if theFragmentNode.theRoot->oldAST.equal then
                               theFragmentNode[]->theNode[]
                               if)
                               if)*)
                           #)
                     if)
                  #)
             #);
           (*           (if switch[21] then newAST.index->putInt;  if);
            search:
            oldAST.index
            ->indexIDList.scan
            (# theObject: ^PatternDiagramNode
            do
            currentNode[]->theObject[];
            (if theObject.getFragment
            // none then
            'ASTtoNodeListUpdate: theNode.getFragment is none!'
            ->putLine;
            
            else
            theObject.getFragment->ff[];
            (if ff[] = newAST.frag[] then
            newAst.Index->indexIDList.impl[i];
            theObject[]->theNode[];
            leave search
            if)
            if);
            
            #)*)
           
       if);
       (if switch[12] then
           ' return: '->putText;
           (if theNode[]
            // none then 'none'->putLine
            else
               theNode.id->putInt; newLine
           if);
           
       if);
       
   if)
#)  

-- RemoveListElement: Descriptor --
(# theNode: ^patternDiagramNode
do
   (if switch[60] then 'RemoveListElement'->putText if);
   (if anAST[] = none then
       'RemoveListElement: anAST is none!'->putLine; putLine; 
    else
       (if switch[60] then anAST.index->putInt;  if);
       search:
       anAST.index
         ->indexIDList.RemoveScan
           (# 
           do 0->IndexIDList.impl[i]; 0->IndexIDList.impl[i+1]; leave search; 
           #)
   if)
#)  

-- InitGPP: Descriptor --
(#  do  #)  

-- OADPageOnInit: Descriptor --
(#
   integerData: @integer;
   ok: @Boolean;
   listsize,last,showAttributesInteger,referencesInteger,specializationsInteger,
     associationsInteger,SimpleDeclDisplayInteger,x,y,w,h: @integer;
   thePalette: ^Palette;
   theRndRect: ^thePalette.RectNode
do
   (if userDataVerbose then
       'onInit called on OADPage with id='->puttext;
       id->putint;
       newline;
       'Reading OADPage UserDataID: '->puttext
   if);
   (id,1)->readIntegerUserData->integerData;
   (if integerData <> 0 then
       (integerData,id)->UserDataIDMap.putID;
       (if THIS(OADPage)[] = theGroupPage[] then
           (theGroupPage.ID,499)->readIntegerUserData->listsize;
           (if listsize > 0 then
               listsize->IndexIDList.impl.new;
               (theGroupPage.ID,500)->readIntegerUserData->IndexIDList.last;
               (for i: listsize repeat
                 (theGroupPage.ID,500+i)->readIntegerUserData
                   ->IndexIDList.impl[i]
               for)
           if);
           (theGroupPage.ID,260)->readIntegerUserData->showAttributesInteger;
           (if showAttributesInteger = 1 then
               true->gppProp.showAttributes
            else
               (if showAttributesInteger = 0 then
                   false->gppProp.showAttributes
               if)
           if);
           (theGroupPage.ID,261)->readIntegerUserData->referencesInteger;
           (if referencesInteger = 1 then
               true->gppProp.references
            else
               (if referencesInteger = 0 then false->gppProp.references if)
           if);
           (theGroupPage.ID,262)->readIntegerUserData->specializationsInteger;
           (if specializationsInteger = 1 then
               true->gppProp.specializations
            else
               (if specializationsInteger = 0 then
                   false->gppProp.specializations
               if)
           if);
           (theGroupPage.ID,263)->readIntegerUserData->associationsInteger;
           (if associationsInteger = 1 then
               true->gppProp.associations
            else
               (if associationsInteger = 0 then
                   false->gppProp.associations
               if)
           if);
           (theGroupPage.ID,264)->readIntegerUserData->gppProp.SimpleDeclDisplay
       if);
       patternDiagrams.AssociationList.load;
       patternDiagrams.InheritanceList.load;
       patternDiagrams.AggregationList.load;
       (ID,240)->readIntegerUserData->nextX;
       (ID,241)->readIntegerUserData->nextY;
       (ID,250)->readIntegerUserData->patternDiagrams.NextFreeLine;
       (ID,251)->readIntegerUserData->patternDiagrams.NextFreeColumn;
       (ID,252)->readIntegerUserData->patternDiagrams.SecondFreeLine;
       (ID,253)->readIntegerUserData->patternDiagrams.SecondFreeColumn
   if);
   (id,1,id)->writeIntegerUserData;
   false->borderVisible;
   (if nextX = 0 then 250->nextX if);
   (if nextY = 0 then 250->nextY if);
   true->doScrollIntoView;
   
#)  

-- CalculateNextCenter: Descriptor --
(# x,y,w,h: @Integer; p: ^OADPage; 
do
   (if PatternDiagrams.theList.size
    // 0 then (* first diagram on page *)
       CurrentPage->p[];
       p.Geometry->(x,y,w,h);
       (* center, width, and height of PAGE *)
       y-(h div 2)+gppProp.DownOnPage->PatternDiagrams.NextFreeLine;
       x-(w div 2)+gppProp.RightOnPage->PatternDiagrams.NextFreeColumn;
       PatternDiagrams.NextFreeLine->PatternDiagrams.SecondFreeLine;
       PatternDiagrams.NextFreeColumn+gppProp.width+gppProp.RightFromPrevious
         ->PatternDiagrams.SecondFreeColumn;
       
   if);
   (PatternDiagrams.NextFreeColumn,PatternDiagrams.NextFreeLine)->theCenter;
   (*(nextX,nextY)->theCenter;*)
   
#)  

-- UpdateNextFree: Descriptor --
(# w,h: @Integer; 
do
   (if x-gppProp.width > theCenter.x then
       'UpdateNextFree: we have the last box on another column than the title ?'
         ->putline;
       x->PatternDiagrams.NextFreeColumn;
       
   if);
   ;
   (PatternDiagrams.NextFreeLine,y+gppProp.DownFromPrefix)->Max
     ->PatternDiagrams.NextFreeLine;
   (PatternDiagrams.SecondFreeColumn,x+gppProp.width+gppProp.RightFromPrevious)
     ->Max->PatternDiagrams.SecondFreeColumn;
   0->y;
   730->h;
   (if PatternDiagrams.NextFreeLine > y+(h div 2) then
   (* PatternDiagrams.SecondFreeLine -> PatternDiagrams.NextFreeLine;*)
       y-(h div 2)+gppProp.DownOnPage->PatternDiagrams.NextFreeLine;
       (if true (* PatternDiagrams.NextFreeColumn < theCenter.x *) then
           PatternDiagrams.SecondFreeColumn->PatternDiagrams.NextFreeColumn;
           PatternDiagrams.SecondFreeColumn+gppProp.width+
           gppProp.RightFromPrevious->PatternDiagrams.SecondFreeColumn;
           
       if);
       
   if);
   
#)  

-- prettyprintSubPatterns: DoPart --
do
     (#
        treeNode: treePPNode
          (#
             element::< PatternDeclDiagram;
             width::< 
               (#
                  thePatternDeclDiagram: ^PatternDeclDiagram;
                  x,y,h,w1,w2: @integer
               do
                  elm[]->thePatternDeclDiagram[];
                  (if gppProp.showAttributes then
                      (if thePatternDeclDiagram.localNodes.empty then
                          thePatternDeclDiagram.titleNode.geometry->(x,y,w,h)
                       else
                          (thePatternDeclDiagram.localNodes.last).elm.geometry
                            ->(x,y,w1,h);
                          thePatternDeclDiagram.titleNode.geometry->(x,y,w2,h);
                          (w1,w2)->max->w
                      if)
                   else
                      thePatternDeclDiagram.titleNode.geometry->(x,y,w,h)
                  if)
               #);
             print::<  (#  do elm.titleText[]->puttext #)
          #);
        buildTree:
          (# theNode,aNode: ^treeNode; subList: ^SortableDiagramList
          enter theNode[]
          do
             theNode
               ->PatternDiagrams.inheritanceList.GetSortableSubPatternDiagrams
               ->subList[];
             subList.sort;
             subList.scan
               (# 
               do
                  &treeNode[]->aNode[];
                  current[]->aNode.elm[];
                  aNode[]->theNode.appendSon;
                  aNode[]->buildTree
               #)
          #);
        x,y,width,heigth,titleWidth,delta,x1,y1,maxY: @Integer;
        root: ^treeNode;
        h: ^treePPhead;
        pos,firstPos: @real
     do
        &treeNode[]->root[];
        thePatternDeclDiagram[]->root.elm[];
        root[]->buildTree;
        (root[],h[],0,gppProp.rightOnPage)->treePPposition->(pos,h[]);
        (if h[] <> none then
            (if switch[90] then h.print; newline if);
            (if h.first[] <> none then
                h.first.pnode.elm[]->thePatternDeclDiagram[];
                thePatternDeclDiagram.titleNode.center->(x,y);
                (if gppProp.showAttributes then
                    (if not thePatternDeclDiagram.localNodes.empty then
                        (thePatternDeclDiagram.localNodes.last).elm.center
                          ->(x,y)
                    if)
                if);
                y+gppProp.DownFromPrefix->y;
                minInt->maxY;
                h.first.pos->firstPos;
                (if h.next[] <> none then
                    loop:
                      (# 
                      do
                         h.next.first.pnode.elm[]->thePatternDeclDiagram[];
                         thePatternDeclDiagram.titleNode.geometry
                           ->(x1,y1,titleWidth,heigth);
                         0->delta;
                         (if gppProp.showAttributes then
                             (if not thePatternDeclDiagram.localNodes.empty then
                                 (thePatternDeclDiagram.localNodes.last).elm.
                                   geometry->(x1,y1,width,heigth);
                                 (if width > titleWidth then
                                     width div 2-titleWidth div 2->delta
                                 if)
                             if)
                         if);
                         x+(h.next.first.pos-firstPos)-delta->x1;
                         (x1,y)->thePatternDeclDiagram.titleNode.center;
                         (if gppProp.showAttributes then
                             (if not thePatternDeclDiagram.localNodes.empty then
                                 (thePatternDeclDiagram.localNodes.last).elm.
                                   center->(x1,y1);
                                 (maxY,y1)->max->maxY
                             if)
                         if);
                         (if h.next.first.next[] <> none then
                             h.next.first.next[]->h.next.first[]; restart loop
                          else
                             (if h.next.next[] <> none then
                                 ((y,maxY)->max)+gppProp.DownFromPrefix->y;
                                 h.next.next[]->h.next[];
                                 restart loop
                             if)
                         if)
                      #)
                if)
            if);
            (*             (if false then
             *                 (if h.first[] <> none then
             *                     h.first.pnode.elm[]->thePatternDeclDiagram[];
             *                     thePatternDeclDiagram.titleNode.center->(x,y);
             *                     (if gppProp.showAttributes then
             *                         (if not thePatternDeclDiagram.localNodes.empty then
             *                             (thePatternDeclDiagram.localNodes.last).elm.center
             *                               ->(x,y)
             *                         if)
             *                     if);
             *                     y+gppProp.DownFromPrefix->y;
             *                     minInt->maxY;
             *                     h.first.pos->firstPos;
             *                     (if h.next[] <> none then
             *                         loop:
             *                           (# 
             *                           do
             *                              h.next.first.pnode.elm[]->thePatternDeclDiagram[];
             *                              thePatternDeclDiagram.titleNode.geometry
             *                                ->(x1,y1,width,heigth);
             *                              (if gppProp.showAttributes then
             *                                  (if not thePatternDeclDiagram.localNodes.empty
             *                                   then
             *                                      (thePatternDeclDiagram.localNodes.last).elm
             *                                      .geometry->(x1,y1,width,heigth)
             *                                  if)
             *                              if);
             *                              (h.next.first.pos-firstPos)*
             *                              (gppProp.rightOnPage+width)+x->x1;
             *                              (x1,y)->thePatternDeclDiagram.titleNode.center;
             *                              thePatternDeclDiagram.titletext[]->puttext;
             *                              ' '->puttext;
             *                              x1->putint;
             *                              newline;
             *                              (if gppProp.showAttributes then
             *                                  (if not thePatternDeclDiagram.localNodes.empty
             *                                   then
             *                                      (thePatternDeclDiagram.localNodes.last).elm
             *                                      .center->(x1,y1);
             *                                      (maxY,y1)->max->maxY
             *                                  if)
             *                              if);
             *                              (if h.next.first.next[] <> none then
             *                                  h.next.first.next[]->h.next.first[];
             *                                  restart loop
             *                               else
             *                                  (if h.next.next[] <> none then
             *                                      ((y,maxY)->max)+gppProp.DownFromPrefix->y;
             *                                      h.next.next[]->h.next[];
             *                                      restart loop
             *                                  if)
             *                              if)
             *                           #)
             *                     if)
             *                 if)
             *              else
             *                 
             *             if)
             *  
             *)
            
         else
            'h is NONE!'->putline
        if)
     #)  

-- edgeSpecializations: DoPart --
do
     (#
        subList: ^DiagramList;
        x,y,lx,ly,x1,y1,yMin: @integer;
        p: [8] @integer
     do
        thePatternDeclDiagram.titleNode.center->(x,y);
        (if thePatternDeclDiagram.localNodes.empty then
            (x,y)->(lx,ly)
         else
            (thePatternDeclDiagram.localNodes.last).elm.center->(lx,ly)
        if);
        thePatternDeclDiagram[]
          ->PatternDiagrams.inheritanceList.GetSubPatternDiagrams->subList[];
        maxInt->yMin;
        subList.scan
          (# 
          do current.e.titleNode.center->(x1,y1); (y1,yMin)->min->yMin
          #);
        subList.scan
          (# 
          do
             current.e.titleNode.center->(x1,y1);
             x1->p[3];
             (ly+yMin) div 2->p[4];
             lx->p[5];
             (ly+yMin) div 2->p[6];
             p->(current.e.titleNode.thePrefixConn).points;
             current.e[]->edgeSpecializations
          #)
     #)  

-- gppChangedFocus: Descriptor --
(# 
do (* true->OKtoChange;*)
   currentFocus[]->oldFocus[];
   newObject[]
     ->CurrentFocus[]
     (*  else
      oldObject[]->currentObject
      if)*) ;
   (*  currentFocus[]->currentObject (#  do true->autoPan #); *)
   (* (if OKToChange then*)
   INNER changedFocus
#)  

-- ASTtoNearestNode: DoPart --
do
   (if anAST[] <> none then
       (if switch[60] or switch[12] then
           'ASTtoNearestNode: anAST=%i\n'
             ->putformat (#  do anAST.index->i #)
       if);
       anAST[]->ASTtoNode->node[];
       (if node[] = none then
           L:
           (if true then
               anAST.father->anAST[];
               (if anAST[] <> none then
                   anAST[]->ASTtoNode->node[];
                   (if node[] = none then restart L if);
                   
               if)
           if);
           
       if);
       (if switch[60] or switch[12] then
           'ASTtoNearestNode: node=%i\n'
             ->putformat
               (#  do (if node[] <> none then node.id->i else 0->i if) #)
       if)
    else
       'ASTtoNearestNode: anAST is NONE!?'->stdErr.putline;
       (if switch[60] or switch[12] then
           'ASTtoNearestNode: anAST is none'->putline
       if)
   if)  

-- sifNotificationNewFragment: DoPart --
do
   INNER ;
   (if switch[40] // true then 'Gpp ------- newFragment'->putLine;  if);
   ;
     

-- propertiesChanged: DoPart --
do
   scanner: PatternDiagrams.theList.scanPropertyDiagrams
     (# 
     do
        (if fg[] = thisDiagram.theGroup then
            thisDiagram.redisplay; leave scanner; 
        if);
        
     #);
   autosave  

-- fragmentChanged: DoPart --
do
     (# foundDiagram: ^ListDiagram
     do
        FragmentDiagram##
          ->ScanDiagrams
            (# theDiagram: ^FragmentDiagram; theRegionList: ^ObjectList
            do
               current[]->theDiagram[];
               (if ff.father
                // theDiagram.theGroup then (* find formname in the diagram *)
                   theDiagram[]->foundDiagram[];
                   theDiagram.localnodes.scan
                     (#
                        theFragmentNode: ^theDiagram.FragmentNode;
                        t: ^text;
                        index: @integer;
                        w1,h1: @integer;
                        
                     do
                        current[]->theFragmentNode[];
                        (if ff[] = theFragmentNode.theFragment then
                            ff[]->theFragmentNode.redisplay;
                            (if theFragmentNode.currentDecomposDiagram <> none
                             then
                                (ff.father).name->t[];
                                '/'->t.findAll (#  do inx->index #);
                                (index+1,t.length)->t.sub->t[];
                                '-'->t.put;
                                theFragmentNode.theName->t.puttext;
                                t
                                  ->
                                    (theFragmentNode.currentDecomposDiagram).
                                    titleNode.theText.set;
                                (theFragmentNode.currentDecomposDiagram).
                                titleNode.getRegionList->theRegionList[];
                                (if theRegionList[] <> none then
                                    theRegionList.scan
                                      (# anObj: ^DesignObject
                                      do current[]->anObj[]; anObj.unmakeRegion
                                      #);
                                    
                                if);
                                (theFragmentNode.currentDecomposDiagram).
                                titleNode.FitToText;
                                (theFragmentNode.currentDecomposDiagram).
                                titleNode.Size->(w1,h1);
                                ((w1,gppProp.titleWidth)->max,h1)
                                  ->
                                    (theFragmentNode.currentDecomposDiagram).
                                    titleNode.size;
                                (if theRegionList[] <> none then
                                    theRegionList.scan
                                      (# anObj: ^DesignObject
                                      do
                                         current[]->anObj[];
                                         (theFragmentNode.currentDecomposDiagram
                                         ).titleNode[]->anObj.createRegion
                                      #)
                                if);
                                t
                                  ->
                                    (theFragmentNode.currentDecomposDiagram).
                                    titleText
                            if)
                        if)
                     #)
               if)
            #);
        (if foundDiagram[] <> none then
            foundDiagram.localNodes.adjustsizes; autosave
        if)
     #)  

-- fragmentInserted: DoPart --
do
   FragmentDiagram##
     ->ScanDiagrams
       (# theDiagram: ^FragmentDiagram; pos: @integer
       do
          current[]->theDiagram[];
          (if ff.father
           // theDiagram.theGroup then (* find formname in the diagram *)
              1->pos;
              scanner: (ff.father).fragmentList.scan
                (# 
                do
                   (if current.type = mps.formType then
                       (if current.f[] = ff[] then
                           leave scanner
                        else
                           pos+1->pos
                       if);
                       
                   if);
                   
                #);
              (pos-1,ff[])->theDiagram.insertFragmentNode
          if)
       #);
   autosave  

-- fragmentDeleted: DoPart --
do
   scanner:
   FragmentDiagram##
     ->ScanDiagrams
       (# theDiagram: ^FragmentDiagram; pos: @integer
       do
          current[]->theDiagram[];
          (if ff.father = theDiagram.theGroup then
              theDiagram.localNodes.scan
                (# theFragmentNode: ^theDiagram.FragmentNode
                do
                   current[]->theFragmentNode[];
                   (if ff[] = theFragmentNode.theFragment then
                       theFragmentNode[]->theDiagram.deleteFragmentNode;
                       leave scanner
                   if)
                #)
          if)
       #);
   autosave  

-- astReplaced: DoPart --
do
   thisOp:
     (#
        theObject: ^PatternDiagramNode;
        pos: @integer;
        theDiagram: ^Diagram;
        doListReplace: @boolean;
        deleted: @boolean;
        dummyFilter: ##external;
        pageList: ^ObjectList;
        filename: @Text;
        nonterminalName: ^Text;
        prompt: @text;
        theListDiagram: ^ListDiagram;
        theAbstractNode: ^theListDiagram.AbstractNode;
        theunexp: ^mps.unexpanded;
        
     do
        (if switch[60]
         // true then
            'Gpp ------- astReplaced  '->puttext;
            'oldindex: '->putText;
            oldAst.index->putInt;
            '  '->puttext;
            'newindex: '->putText;
            newAst.index->putInt;
            newLine;
            
        if);
        (if oldAST.kind
         // mps.kinds.unExpanded then
         (* this is an ECOOP94 hack, must be generalized
          TOBY: - meanwhile I think it has been :-) *)
            (if newAst.kind
             // mps.kinds.interior then
                (if switch[60]
                 // true then 'expanding a nonterminal'->putLine; 
                if);
                (if NewAST## <= betaGram.attributeDecl## then
                    (if switch[60] then
                        'It is a declaration: '->putText;
                        NewAST.symbol->putInt;
                        newLine;
                        
                    if);
                    true->doListReplace;
                    
                if);
                
             // mps.kinds.optional then
                oldAST[]->ASTtoNode->theObject[];
                (if theObject[] <> none then
                    theObject.theDiagram->theDiagram[];
                    (theObject[],true)->theDiagram.deleteDiagramNode;
                    true->deleted;
                    
                 else
                    leave thisOp
                if)
             // mps.kinds.unExpanded then
                (if switch[60] then
                    'astReplaced: unExpanded replacing unExpanded'->putline
                if)
            if)
         // mps.kinds.interior then
            oldAST[]->patternDiagrams.AssociationList.update;
            oldAST[]->patternDiagrams.InheritanceList.update;
            oldAST[]->patternDiagrams.AggregationList.update;
            (if newAST.kind
             // mps.kinds.interior then
                (if oldAST## <= betaGram.attributeDecl## then
                    (if newAST## <= betaGram.attributeDecl## then
                        (if oldAST## <> newAST## then true->doListReplace if)
                    if)
                if)
             // mps.kinds.optional then
                oldAST[]->ASTtoNode->theObject[];
                (if theObject[] <> none then
                    theObject.theDiagram->theDiagram[];
                    (theObject[],true)->theDiagram.deleteDiagramNode;
                    true->deleted;
                    
                 else
                    leave thisOp
                if)
             else
            (* updateDiagramNode *)
                
            if)
         // mps.kinds.optional then
            (if newAST.kind
             // mps.kinds.unexpanded then
                newAST[]->theunexp[];
                theunexp.nonTerminalSymbol->betaGram.symbolToName
                  ->nonterminalName[];
                (if 'AttributeDeclOpt'->nonterminalName.equal then
                    oldAst[]->ASTtoNearestNode->theObject[];
                    (if theObject[] <> none then
                        theObject.theDiagram->theListDiagram[];
                        (if theObject## <= theListDiagram.AbstractNode## then
                            theObject[]->theAbstractNode[];
                            (if theAbstractNode.currentDecomposDiagram <> none
                             then
                                (newAST.sonNo-1,newAST[])
                                  ->
                                    (theAbstractNode.currentDecomposDiagram).
                                    insertDiagramNode;
                                leave thisOp
                            if)
                        if)
                     else
                        'astReplaced: theObject is none'->stdErr.putline;
                        leave thisOp
                    if)
                if)
             // mps.kinds.interior then
                (if newAST## <= betaGram.AttributeDecl## then
                    oldAst[]->ASTtoNearestNode->theObject[];
                    (if theObject[] <> none then
                        theObject.theDiagram->theListDiagram[];
                        (if theObject## <= theListDiagram.AbstractNode## then
                            theObject[]->theAbstractNode[];
                            (if theAbstractNode.currentDecomposDiagram <> none
                             then
                                (newAST.sonNo-1,newAST[])
                                  ->
                                    (theAbstractNode.currentDecomposDiagram).
                                    insertDiagramNode;
                                leave thisOp
                            if)
                        if)
                     else
                        'astReplaced: theObject is none'->stdErr.putline;
                        leave thisOp
                    if)
                if)
            if)
        if);
        (if doListReplace then
            oldAST[]->ASTtoNode->theObject[];
            (if theObject[] <> none then
                theObject.theDiagram->theDiagram[];
                (*
                 (theObject[],true)->theObject.theDiagram.deleteDiagramNode;
                 (pos,newAST[])->theDiagram.insertDiagramNode;    
                 * *)
                (theObject[],newAST[])->theDiagram.replaceDiagramNode;
                
            if)
         else
            (if not deleted then
                oldAST[]->ASTtoNearestNode->theObject[];
                (if theObject[] <> none then
                    (oldAst[],newAst[])
                      ->(theObject.theDiagram).updateDiagramNode
                 else
                    'astReplaced: theObject is none'->stdErr.putline
                if)
            if);
            
        if);
        Redraw;
        autosave;
        
     #)  

-- listElementInserted: Descriptor --
(#
   theObject: ^PatternDiagramNode;
   newAst,firstBorn: ^mps.ast;
   pos,i,noOfSons: @integer;
   theListDiagram: ^ListDiagram;
   theFragmentNode: ^theListDiagram.FragmentNode
do
   (if switch[60] then
       'Gpp ------- listElementInserted\nfatherIndex: %i position: %i\nfather frag: %s\n'
         ->putformat
           (#  do father.index->i; position->i; father.frag.fullname->s #)
   if);
   (if position = 1 then
       father.getSon2->firstBorn[]
    else
       father.getson1->firstBorn[]
   if);
   (if firstBorn.kind = mps.kinds.optional then
       father.noOfSons->noOfSons;
       2->i;
       loop:
         (# 
         do
            (if noOfSons >= i then
                i->father.get->firstBorn[];
                (if (firstBorn.kind = mps.kinds.optional) or (position = i) then
                    i+1->i; restart loop
                if)
             else
                none ->firstBorn[]
            if)
         #)
   if);
   position->pos->father.get->newAST[];
   1->i;
   scanner: father.scan
     (# 
     do
        (if not (i = position) then
            (if current.kind = mps.kinds.optional then pos-1->pos if); i+1->i
         else
            leave scanner
        if)
     #);
   (if firstBorn[] <> none then
       firstBorn[]->ASTtoNearestNode->theObject[]
    else
       father[]->ASTtoNearestNode->theObject[]
   if);
   (if theObject[] <> none then
       theObject.theDiagram->theListDiagram[];
       (if theObject## <= theListDiagram.FragmentNode## then
           theObject[]->theFragmentNode[];
           (if theFragmentNode.currentDecomposDiagram = none then
               theFragmentNode.detail
            else
               (pos-1,newAST[])
                 ->(theFragmentNode.currentDecomposDiagram).insertDiagramNode
           if)
        else
           (pos-1,newAST[])->(theObject.theDiagram).insertDiagramNode
       if);
       Redraw;
       autosave
    else
       'listElementInserted: theObject is none'->stdErr.putline
   if);
   (if switch[60] then 'Gpp ------- listElementInserted END'->putline if)
#)  

-- listElementsDeleted: Descriptor --
(# theObject: ^PatternDiagramNode
do
   (if switch[60]
    // true then 'Gpp ------- listElementsDeleted'->putLine; 
   if);
   (for i: length repeat
     oldElements[i][]->patternDiagrams.AssociationList.update;
     oldElements[i][]->patternDiagrams.InheritanceList.update;
     oldElements[i][]->patternDiagrams.AggregationList.update;
     oldElements[i][]->ASTtoNode->theObject[];
     (if theObject[] <> none then
         (theObject[],true)->(theObject.theDiagram).deleteDiagramNode; 
     if)
   for);
   Redraw;
   autosave;
   
#)  

-- listElementsReplaced: Descriptor --
(#
(* changeSpec:
 * <fatherIndex> <position> <length> <oldElements> <newLength> 
 * <oldElements> ::= { <elementIndex> } i    (i = <length>)
 *)
   oldAst,newAst,anAST: ^mps.ast;
   theDiagram: ^Diagram;
   pos,oldIndex,j: @integer;
   theObject: ^PatternDiagramNode
do
   (if switch[60]
    // true then 'Gpp ------- listElementsReplaced'->putLine; 
   if);
   (for i: length repeat
     oldElements[i][]->patternDiagrams.AssociationList.update;
     oldElements[i][]->patternDiagrams.InheritanceList.update;
     oldElements[i][]->patternDiagrams.AggregationList.update;
     oldElements[i][]->ASTtoNode->theObject[];
     (if theObject[] <> none then
         theObject.theDiagram->theDiagram[];
         (theObject[],true)->(theObject.theDiagram).deleteDiagramNode;
         
     if)
   for);
   (for i: newlength repeat
     position+i-1->pos->father.get->newAST[];
     (if not (newAST.kind = mps.kinds.optional) then
         (if theDiagram[] = none then
             'Gpp: ListElementsReplaced: theDiagram is none!!'->putLine
          else
             1->j;
             scanner: father.scan
               (# 
               do
                  (if not (j = position+i-1) then
                      (if current.kind = mps.kinds.optional then
                          pos-1->pos
                      if);
                      j+1->j
                   else
                      leave scanner
                  if)
               #);
             (pos-1,newAST[])->theDiagram.insertDiagramNode
         if)
     if);
     
   for);
   Redraw;
   autosave;
   
#)  

-- ScanDiagrams: Descriptor --
(# 
do
   PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->THIS(ScanDiagrams).current[];
        (if theDiagramType##
         // none then INNER ScanDiagrams; 
         else
            (if current.e## <= theDiagramType##
             // true then INNER ScanDiagrams; 
            if)
        if)
     #)
#)  

-- MarkNodeDisplay: Descriptor --
(# 
do
   (pos.x,pos.y,gppProp.marksize,gppProp.marksize)->new;
   theNode[]->thePatternDiagramNode;
   THIS(MarkNode)[]->(thePatternDiagramNode).theMarkNode;
   false->sizeable;
   
#)  

-- MarkNodeOnInit: Descriptor --
(# 
do
   UDPrivate.UDMarkNode->UserDataInit;
   thePatternDiagramNode.Init;
   6->theText.size;
   false->moveable;
   false->sizeable;
   (if not initialisingSaved then theNode[]->CreateRegion if);
   
#)  

-- titleGetFragment: Descriptor --
(# fn: ^FragmentNode; 
do
   (if theFragmentNode <> none
    // true then theFragmentNode->fn[]; fn.theFragment->f[]; 
    else
       'DiagramNode: GetFragment: no FragmentNode'->screen.putline
   if)
#)  

-- ListDiagramTitleDump: DoPart --
do
   '********theSurroundBox********'->putline;
   (if theSurroundBox <> none then
       (theSurroundBox).ID->putint; newline
    else
       'is NONE!'->putline
   if);
   '********MaxHeight********'->putline;
   MaxHeight->putint;
   newline;
   '********MaxWidth********'->putline;
   MaxWidth->putint;
   newline;
   INNER dump  

-- SurroundBoxOnInit: DoPart --
do UDPrivate.UDSurroundBox->UserDataInit; false->selectable; false->sizeable  

-- UserdataLabelNodeVisibleSet: DoPart --
do
   (if v then
       (if invisibleText <> none then
           invisibleText->help[]; help->theText.set; none ->invisibleText
       if);
       true->selectable
    else
       (if theText.length > 0 then
           theText.get->t; t[]->invisibleText; theText.clear
       if);
       false->selectable
   if)  

-- UserDataLabelNodeVisibleGet: DoPart --
do (if invisibleText <> none then true->v else  if)  

-- UserDataLabelNodeOnInit: DoPart --
do
   UDPrivate.UDLabelNode->UserDataInit;
   invisibleText.init;
   gppProp.fontSize->theText.size  

-- DeletableConnectorVisibleGet: DoPart --
do BorderVisible->v; INNER get  

-- DeletableConnectorVisibleSet: DoPart --
do
   v->borderVisible;
   v->selectable;
   (if v then
       (if invisibleText <> none then
           invisibleText->help[]; help->theText.set; none ->invisibleText
       if)
    else
       (if theText.length > 0 then
           theText.get->t; t[]->invisibleText; theText.clear
       if)
   if);
   INNER set  

-- DeletableConnectorGetOtherEnd: Descriptor --
(# node1,node2: ^IDObject
do
   true->getEnds->(node1[],node2[]);
   (if (Start[] = node1[]) or (Start[] = node2[]) then
       (if Start[] = node1[] then
           node2[]->OtherEnd[]
        else
           node1[]->OtherEnd[]
       if)
    else
       (if switch[1] then
           'GetOtherEnd: Start is not in either end'->putline
       if)
   if)
#)  

-- AggregationRoleVisibleSet: DoPart --
do
   (if THIS(Role)[] = leftRole then
       v->borderVisible;
       (if v then
           (thePatternDiagramNode).getAstNode->anAST[];
           (if anAST.symbol
            // betaGram.SimpleDecl then
               anAST[]->theSimpleDecl[];
               theSimpleDecl.getReferenceSpecification->anAST[];
               (if anAST.symbol = betaGram.StaticItem then
                   (if v then 1->fillType else 0->fillType if)
               if)
            // betaGram.RepetitionDecl then
               anAST[]->theRepetitionDecl[];
               theRepetitionDecl.getReferenceSpecification->anAST[];
               (if anAST.symbol = betaGram.StaticItem then
                   (if v then 1->fillType else 0->fillType if)
               if)
           if)
       if)
   if)  

-- AggregationRoleDisplay: DoPart --
do
   (if leftRole = none then
       (x+gppProp.halfDiamondNodeWidth,y)->move; true->BorderVisible
   if);
   INNER display  

-- AggregationRoleRedisplay: DoPart --
do
   (if THIS(Role)[] = leftRole then
       (if private.kind = gppProp.byValue then
           1 (* Black *) ->fillType; redraw
        else
           0->fillType; redraw
       if)
   if)  

-- AggregationRoleNew: DoPart --
do
   (if leftRole = none then
       0->p[1];
       - gppProp.halfDiamondNodeHeight->p[2];
       gppProp.halfDiamondNodeWidth->p[3];
       0->p[4];
       0->p[5];
       gppProp.halfDiamondNodeHeight->p[6];
       - gppProp.halfDiamondNodeWidth->p[7];
       0->p[8];
       (for i: p.range repeat p[i]->wcoord->p[i] for);
       (theWorkPage.ID,4,@@ p[1])->designUtils.createPolygon->onInit;
       (if private.kind = gppProp.byValue then 1 (* Black *) ->fillType if);
       (x,y)->move;
       true->doneInInner
   if)  

-- AggregationRoleOnInit: DoPart --
do INNER onInit  

-- PrefixConnectorOnInit: DoPart --
do
     (#
        aPatternDiagramNode,anotherPatternDiagramNode: ^PatternDiagramNode;
        theListDiagram,theOtherListDiagram: ^ListDiagram;
        theOADDiagram,theOtherOADDiagram,superDiagram: ^OADDiagram;
        theOtherPatternDeclDiagram: ^PatternDeclDiagram;
        aDiagramNode: ^theOtherListDiagram.DiagramNode;
        t: ^Text;
        titleText: @text;
        theDesc,theOtherDesc: ^betaGram.ObjectDescriptor;
        anAST,anotherAST,testAST,testAST2,aDeclAST: ^MPS.AST;
        anExp: ^mps.expanded;
        theNames: ^betaGram.Names;
        theNameDcl: ^betaGram.NameDcl;
        theMainPart: ^betaGram.MainPart;
        node1,node2: ^designObject;
        didCreate: @boolean
     do
        (if switch[50] or switch[30] then
            'PrefixConnector onInit!'->putline
        if);
        UDPrivate.UDPrefixConnector->UserDataInit;
        (if not initialisingSaved then
            (if not gppProp.specializations then
                false->BorderVisible; false->selectable
            if);
            true->getEnds->(node2[],node1[]);
            (if (node1[] <> none ) and (node2[] <> none ) then
                (if ((node1[]->BoxToNode->node1[]) <> none ) and
                ((node2[]->BoxToNode->node2[]) <> none ) then
                    (if (node1## <= PatternDiagramNode##) and
                    (node2## <= PatternDiagramNode##) then
                        node1[]->aPatternDiagramNode[];
                        aPatternDiagramNode.theDiagram->theListDiagram[];
                        node2[]->anotherPatternDiagramNode[];
                        anotherPatternDiagramNode.theDiagram
                          ->theOtherListDiagram[];
                        (if (anotherPatternDiagramNode.theSifEditor).isReadOnly
                         then
                            (anotherPatternDiagramNode.theDiagram).titleText[]
                              ->t[];
                            ' is read-only - can not generate code for specialization'
                              ->t.puttext;
                            t[]->alertUser
                         else
                            (if (theListDiagram## <= FragmentDiagram##) or
                            (theOtherListDiagram## <= FragmentDiagram##) then
                                'Source and/or destination is a fragment diagram'
                                  ->AlertUser
                             else
                                (if (theListDiagram## <= PatternAttDiagram##) or
                                (theOtherListDiagram## <= PatternAttDiagram##)
                                 then
                                    'Source and/or destination is an attributes form diagram'
                                      ->AlertUser
                                 else
                                    theListDiagram[]->theOADDiagram[];
                                    theOtherListDiagram[]->theOtherOADDiagram[];
                                    theOADDiagram.theDescriptor->theDesc[];
                                    theOtherOADDiagram.theDescriptor
                                      ->theOtherDesc[];
                                    theDesc.father->anAST[];
                                    (if anAST## <=
                                    betaGram.referenceSpecification## then
                                        'The destination is a singular object'
                                          ->AlertUser
                                     else
                                        theOtherDesc.father->anotherAST[];
                                        anAST.father->testAST[];
                                        anotherAST.father->testAST2[];
                                        (if (testAST[] <> none ) and
                                        (testAST2[] <> none ) then
                                            (if theListDiagram[] <>
                                            theOtherListDiagram[] then
                                                theOtherDesc.getPrefixOpt
                                                  ->anotherAST[];
                                                anAST[]->anExp[];
                                                anExp.getSon1->theNames[];
                                                theNames.getSon1->theNameDcl[];
                                                theNameDcl.getNameDecl
                                                  ->aDeclAST[];
                                                (if aDeclAST.kind =
                                                mps.kinds.unExpanded then
                                                    '<<NameAppl>>'->t[]
                                                 else
                                                    theNameDcl.getText->t[]
                                                if);
                                                (anotherAST[],t)
                                                  ->
                                                    (
                                                    anotherPatternDiagramNode.
                                                      theSifEditor).parse;
                                                theListDiagram.titleNode[]
                                                  ->
                                                    theOtherListDiagram.
                                                      titleNode.CreateRegion;
                                                (if
                                                theOtherListDiagram.titleNode.
                                                  thePrefixConn <> none then
                                                    (
                                                    theOtherListDiagram.
                                                      titleNode.thePrefixConn).
                                                    delete
                                                if);
                                                THIS(PrefixConnector)[]
                                                  ->
                                                    theOtherListDiagram.
                                                      titleNode.thePrefixConn;
                                                theOtherListDiagram[]
                                                  ->
                                                    theOtherPatternDeclDiagram[];
                                                theDesc[]
                                                  ->
                                                    theOtherPatternDeclDiagram.
                                                      thePrefix;
                                                theOtherPatternDeclDiagram.
                                                  theParentNode->aDiagramNode[];
                                                theDesc[]
                                                  ->aDiagramNode.thePrefix;
                                                (if
                                                (theOtherDesc.father).symbol =
                                                betaGram.staticItem then
                                                    ((theOtherDesc.father).
                                                     father,theDesc.father)
                                                      ->
                                                        patternDiagrams.
                                                          InheritanceList.insert
                                                 else
                                                    (theOtherDesc.father,
                                                     theDesc.father)
                                                      ->
                                                        patternDiagrams.
                                                          InheritanceList.insert
                                                if);
                                                (theOtherListDiagram.titleNode.
                                                   getTopParent,
                                                 theOtherListDiagram.
                                                   titleNode[],
                                                 (theListDiagram.theSurroundBox)
                                                   .getTopParent,
                                                 theListDiagram.theSurroundBox)
                                                  ->setEnds;
                                                true->didCreate;
                                                (if gppProp.DiagramPositioning =
                                                gppProp.AllAuto then
                                                    theOADDiagram[]
                                                      ->prettyprintSubPatterns
                                                if)
                                             else
                                                'Source and destination is the same diagram'
                                                  ->AlertUser
                                            if)
                                         else
                                            'Source and/or destination is a descriptor form diagram'
                                              ->AlertUser
                                        if)
                                    if)
                                if)
                            if)
                        if)
                     else
                        'Source or destination is not part of a pattern diagram'
                          ->AlertUser
                    if)
                 else
                    'Source or destination is not part of a pattern diagram'
                      ->AlertUser
                if)
             else
                (if switch[50] then
                    'SpecializationConnectorOnInit: node1 and/or node2 was none'
                      ->putline
                if)
            if);
            (if not didCreate then delete if);
            statusbar.reset
        if);
        INNER onInit
     #)  

-- PrefixConnectorOnDelete: Descriptor --
(#
   node1,node2: ^PatternDiagramNode;
   theTitleNode: ^theOADDiagram.title;
   theDiagramNode: ^theOADDiagram.DiagramNode;
   titleText: @Text;
   theOADDiagram: ^OADDiagram;
   thePatternDeclDiagram: ^PatternDeclDiagram;
   anAST: ^MPS.AST;
   theDesc: ^betaGram.ObjectDescriptor;
   theMainPart: ^betaGram.MainPart;
   object1,object2: ^designObject;
   theParentNode: ^PatternDiagramNode;
   theParentDiagram: ^ListDiagram;
   theParentDiagramNode: ^theParentDiagram.DiagramNode
do
   (if switch[30] or switch[50] then
       'PrefixConnectorConnector onDelete!'->putline
   if);
   true->getEnds->(node1[],BoxToNode->node2[]);
   node1.unmakeregion;
   node1.theDiagram->theOADDiagram[];
   node1[]->theTitleNode[];
   none ->theTitleNode.thePrefixConn;
   theOADDiagram[]->thePatternDeclDiagram[];
   none ->thePatternDeclDiagram.thePrefix;
   theOADDiagram.theParentNode->theDiagramNode[];
   none ->theDiagramNode.thePrefix;
   theOADDiagram.theParentNode->theParentNode[];
   theParentNode.theDiagram->theParentDiagram[];
   theParentNode[]->theParentDiagramNode[];
   theOADDiagram.theDescriptor->theDesc[];
   theDesc.getPrefixOpt->anAST[];
   ''->t[];
   (anAST[],t)->(node2.theSifEditor).parse
#)  

-- PrefixConnectorOnReattach: Descriptor --
(#
   node1,node2: ^DesignObject;
   aPatternDiagramNode,anotherPatternDiagramNode,oldPatternDiagramNode:
     ^PatternDiagramNode;
   theListDiagram,theOtherListDiagram: ^ListDiagram;
   theOADDiagram,theOtherOADDiagram,oldOADDiagram,superDiagram: ^OADDiagram;
   theOtherPatternDeclDiagram,oldPatternDeclDiagram: ^PatternDeclDiagram;
   aDiagramNode: ^theOtherListDiagram.DiagramNode;
   t: ^Text;
   titleText: @text;
   theDesc,theOtherDesc,oldDesc: ^betaGram.ObjectDescriptor;
   anAST,anotherAST,testAST,testAST2,aDeclAST: ^MPS.AST;
   anExp: ^mps.expanded;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   theMainPart: ^betaGram.MainPart
do
   (if switch[50] or switch[30] then
       'PrefixConnector OnReattach!'->putline
   if);
   true->getEnds->(BoxToNode->node2[],BoxToNode->node1[]);
   theNew[]->BoxToNode->theNew[];
   (if whichEnd then
       (if theNew[] <> node1[] then
           (if theNew## <= PatternDiagramNode## then
               theNew[]->aPatternDiagramNode[];
               aPatternDiagramNode.theDiagram->theListDiagram[];
               node2[]->anotherPatternDiagramNode[];
               anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
               (if (anotherPatternDiagramNode.theSifEditor).isReadOnly then
                   (anotherPatternDiagramNode.theDiagram).titleText[]->t[];
                   ' is read-only - can not generate code for specialization'
                     ->t.puttext;
                   t[]->alertUser
                else
                   (if theListDiagram## <= FragmentDiagram## then
                       'The relation has been attached to a fragment diagram'
                         ->AlertUser;
                       false->ok
                    else
                       (if theListDiagram## <= PatternAttDiagram## then
                           'The relation has been attached to an attributes form diagram'
                             ->AlertUser;
                           false->ok
                        else
                           theListDiagram[]->theOADDiagram[];
                           theOtherListDiagram[]->theOtherOADDiagram[];
                           theOADDiagram.theDescriptor->theDesc[];
                           theOtherOADDiagram.theDescriptor->theOtherDesc[];
                           theDesc.father->anAST[];
                           (if anAST## <= betaGram.referenceSpecification## then
                               'The destination is a singular object'
                                 ->AlertUser;
                               false->ok
                            else
                               theOtherDesc.father->anotherAST[];
                               anAST.father->testAST[];
                               anotherAST.father->testAST2[];
                               (if (testAST[] <> none ) and
                               (testAST2[] <> none ) then
                                   (if theListDiagram[] <> theOtherListDiagram[]
                                    then
                                       theOtherDesc.getPrefixOpt->anotherAST[];
                                       anAST[]->anExp[];
                                       anExp.getSon1->theNames[];
                                       theNames.getSon1->theNameDcl[];
                                       theNameDcl.getNameDecl->aDeclAST[];
                                       (if aDeclAST.kind = mps.kinds.unExpanded
                                        then
                                           '<<NameAppl>>'->t[]
                                        else
                                           theNameDcl.getText->t[]
                                       if);
                                       (anotherAST[],t)
                                         ->
                                           (
                                           anotherPatternDiagramNode.
                                             theSifEditor).parse;
                                       theListDiagram.titleNode[]
                                         ->
                                           theOtherListDiagram.titleNode.
                                             CreateRegion;
                                       theOtherListDiagram[]
                                         ->theOtherPatternDeclDiagram[];
                                       theDesc[]
                                         ->theOtherPatternDeclDiagram.thePrefix;
                                       theOtherPatternDeclDiagram.theParentNode
                                         ->aDiagramNode[];
                                       theDesc[]->aDiagramNode.thePrefix;
                                       aDiagramNode.theDeclaration
                                         ->
                                           patternDiagrams.InheritanceList.
                                             remove;
                                       (theOtherDesc.father,theDesc.father)
                                         ->
                                           patternDiagrams.InheritanceList.
                                             insert;
                                       (node2.getTopParent,node2[],
                                        (theListDiagram.theSurroundBox).
                                        getTopParent,
                                        theListDiagram.theSurroundBox)->setEnds;
                                       false->ok;
                                       (if gppProp.diagramPositioning =
                                       gppProp.AllAuto then
                                           theOADDiagram[]
                                             ->prettyprintSubPatterns
                                       if)
                                    else
                                       'Source and destination is the same diagram'
                                         ->AlertUser;
                                       false->ok
                                   if)
                                else
                                   'Source and/or destination is a descriptor form diagram'
                                     ->AlertUser;
                                   false->ok
                               if)
                           if)
                       if)
                   if)
               if)
            else
               'The relation has been attached to a node that is not part of a pattern diagram'
                 ->AlertUser;
               false->ok
           if)
        else
           false->ok
       if)
    else
       (if theNew[] <> node2[] then
           (if theNew## <= PatternDiagramNode## then
               node2[]->oldPatternDiagramNode[];
               node1[]->aPatternDiagramNode[];
               aPatternDiagramNode.theDiagram->theListDiagram[];
               theNew[]->anotherPatternDiagramNode[];
               anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
               (if (anotherPatternDiagramNode.theSifEditor).isReadOnly then
                   (anotherPatternDiagramNode.theDiagram).titleText[]->t[];
                   ' is read-only - can not generate code for specialization'
                     ->t.puttext;
                   t[]->alertUser;
                   false->ok
                else
                   (if theOtherListDiagram## <= FragmentDiagram## then
                       'The relation has been attached to a fragment diagram'
                         ->AlertUser;
                       false->ok
                    else
                       (if theOtherListDiagram## <= PatternAttDiagram## then
                           'The relation has been attached to an attributes form diagram'
                             ->AlertUser;
                           false->ok
                        else
                           oldPatternDiagramNode.theDiagram->oldOADDiagram[];
                           oldOADDiagram.theDescriptor->oldDesc[];
                           theListDiagram[]->theOADDiagram[];
                           theOtherListDiagram[]->theOtherOADDiagram[];
                           theOADDiagram.theDescriptor->theDesc[];
                           theOtherOADDiagram.theDescriptor->theOtherDesc[];
                           theDesc.father->anAST[];
                           (if anAST## <= betaGram.referenceSpecification## then
                               'The destination is a singular object'
                                 ->AlertUser;
                               false->ok
                            else
                               theOtherDesc.father->anotherAST[];
                               anAST.father->testAST[];
                               anotherAST.father->testAST2[];
                               (if (testAST[] <> none ) and
                               (testAST2[] <> none ) then
                                   (if theListDiagram[] <> theOtherListDiagram[]
                                    then
                                       theOtherDesc.getPrefixOpt->anotherAST[];
                                       anAST[]->anExp[];
                                       anExp.getSon1->theNames[];
                                       theNames.getSon1->theNameDcl[];
                                       theNameDcl.getNameDecl->aDeclAST[];
                                       (if aDeclAST.kind = mps.kinds.unExpanded
                                        then
                                           '<<NameAppl>>'->t[]
                                        else
                                           theNameDcl.getText->t[]
                                       if);
                                       (anotherAST[],t)
                                         ->
                                           (
                                           anotherpatternDiagramNode.
                                             theSifEditor).parse;
                                       theListDiagram.titleNode[]
                                         ->
                                           theOtherListDiagram.titleNode.
                                             CreateRegion;
                                       oldPatternDiagramNode.unMakeRegion;
                                       none
                                         ->
                                           oldOADDiagram.titleNode.
                                             thePrefixConn;
                                       oldOADDiagram[]->oldPatternDeclDiagram[];
                                       none ->oldPatternDeclDiagram.thePrefix;
                                       oldPatternDeclDiagram.theParentNode
                                         ->aDiagramNode[];
                                       none ->aDiagramNode.thePrefix;
                                       oldOADDiagram.theParentNode
                                         ->aDiagramNode[];
                                       aDiagramNode.theDeclaration
                                         ->
                                           patternDiagrams.InheritanceList.
                                             remove;
                                       theOtherListDiagram.theParentNode
                                         ->aDiagramNode[];
                                       (if
                                       theOtherListDiagram.titleNode.
                                         thePrefixConn <> none then
                                           aDiagramNode.theDeclaration
                                             ->
                                               patternDiagrams.InheritanceList.
                                                 remove;
                                           (
                                           theOtherListDiagram.titleNode.
                                             thePrefixConn).delete
                                       if);
                                       THIS(prefixConnector)[]
                                         ->
                                           theOtherListDiagram.titleNode.
                                             thePrefixConn;
                                       theOtherListDiagram[]
                                         ->theOtherPatternDeclDiagram[];
                                       theDesc[]
                                         ->theOtherPatternDeclDiagram.thePrefix;
                                       theDesc[]->aDiagramNode.thePrefix;
                                       (theOtherDesc.father,theDesc.father)
                                         ->
                                           patternDiagrams.InheritanceList.
                                             insert;
                                       oldDesc.getPrefixOpt->anotherAST[];
                                       ''->t[];
                                       (anotherAST[],t)
                                         ->
                                           (oldPatternDiagramNode.theSifEditor).
                                           parse;
                                       (theOtherListDiagram.titleNode.
                                          getTopParent,
                                        theOtherListDiagram.titleNode[],
                                        (theListDiagram.theSurroundBox).
                                        getTopParent,
                                        theListDiagram.theSurroundBox)->setEnds;
                                       false->ok;
                                       (if gppProp.DiagramPositioning =
                                       gppProp.AllAuto then
                                           theOADDiagram[]
                                             ->prettyprintSubPatterns
                                       if)
                                    else
                                       'Source and destination is the same diagram'
                                         ->AlertUser;
                                       false->ok
                                   if)
                                else
                                   'Source and/or destination is a descriptor form diagram'
                                     ->AlertUser;
                                   false->ok
                               if)
                           if)
                       if)
                   if)
               if)
            else
               'The relation has been attached to a node that is not part of a pattern diagram'
                 ->AlertUser;
               false->ok
           if)
        else
           false->ok
       if)
   if)
#)  

-- GeneralRelationshipOnInit: DoPart --
do 0->Orient  

-- RoleVisibleSet: DoPart --
do
   (if name <> none then v->(name).visible if);
   v->(multiplicity).visible;
   INNER set  

-- RoleDisplay: DoPart --
do
   theNode.geometry->(x,y,w,h);
   (if leftRole = none (* then we are creating the left role *) then
       x+w div 2->x
    else
       x-w div 2->x
   if);
   (x,y,0,0)->new;
   false->BorderVisible;
   false->selectable;
   theNode[]->CreateRegion;
   (if theName[] <> none (* role names are optional *) then
       &UserDataLabelNode[]->l[];
       (x,y,10,10,theName)->l.new;
       l.fitToText;
       l.geometry->(lx,ly,lw,lh);
       (if leftRole = none then x+lw div 2+5->lx else x-lw div 2-5->lx if);
       y-10->ly;
       (lx,ly)->l.move;
       THIS(Role)[]->l.createRegion;
       l[]->name
   if);
   &UserDataLabelNode[]->l[];
   &text[]->mul[];
   (if multiplicityFrom < 0 then
       '*'->mul[]
    else
       multiplicityFrom->mul.putint;
       (if multiplicityFrom <> multiplicityTo then
           '..'->mul.puttext;
           (if multiplicityTo < 0 then
               '*'->mul.puttext
            else
               multiplicityTo->mul.putint
           if)
       if)
   if);
   (x,y,10,10,mul)->l.new;
   l.fitToText;
   l.geometry->(lx,ly,lw,lh);
   (if leftRole = none then x+lw div 2+5->lx else x-lw div 2-5->lx if);
   y+10->ly;
   (lx,ly)->l.move;
   THIS(Role)[]->l.createRegion;
   l[]->multiplicity;
   theNode[]->thePatternDiagramNode;
   INNER display  

-- RoleRedisplay: DoPart --
do
   (thePatternDiagramNode).geometry->(x,y,w,h);
   (if leftRole = THIS(Role)[] then x+w div 2->x else x-w div 2->x if);
   (if theName[] <> none then
       (if name <> none then
           theName->(name).theText.set
        else
           &UserDataLabelNode[]->l[];
           (x,y,10,10,theName)->l.new;
           l.fitToText;
           l.geometry->(lx,ly,lw,lh);
           (if leftRole = THIS(Role)[] then
               x+lw div 2+5->lx
            else
               x-lw div 2-5->lx
           if);
           y-10->ly;
           (lx,ly)->l.move;
           THIS(Role)[]->l.createRegion;
           l[]->name
       if)
   if);
   &text[]->mul[];
   (if multiplicityFrom < 0 then
       '*'->mul[]
    else
       multiplicityFrom->mul.putint;
       (if multiplicityFrom <> multiplicityTo then
           '..'->mul.puttext;
           (if multiplicityTo < 0 then
               '*'->mul.puttext
            else
               multiplicityTo->mul.putint
           if)
       if)
   if);
   (if multiplicity = none then
       &UserDataLabelNode[]->l[];
       (x,y,10,10,mul)->l.new;
       l.fitToText;
       l.geometry->(lx,ly,lw,lh);
       (if leftRole = THIS(Role)[] then
           x+lw div 2+5->lx
        else
           x-lw div 2-5->lx
       if);
       y+10->ly;
       (lx,ly)->l.move;
       THIS(Role)[]->l.createRegion;
       l[]->multiplicity
   if);
   mul->(multiplicity).theText.set;
   INNER redisplay  

-- RoleOnDrag: DoPart --
do
     (# 
     do
        (if switch[53] or switch[54] then
            'RoleOnDrag: %s=%i %s=%i\n'
              ->putformat
                (# theObject: ^Role; y: @integer; help: @text
                do
                   (if name <> none then
                       (name).theText.get->help; help[]->s
                   if);
                   center->(i,y);
                   THIS(Role)[]->getOtherEnd->theObject[];
                   (if theObject.name <> none then
                       (theObject.name).theText.get->help; help[]->s
                   if);
                   theObject.center->(i,y)
                #)
        if)
     #)  

-- RoleOnInit: DoPart --
do
   UDPrivate.UDRole->UserDataInit;
   name.init;
   Multiplicity.init;
   thePatternDiagramNode.init;
   false->selectable;
   false->sizeable;
   INNER onInit  

-- RoleDump: DoPart --
do
   '****name****'->putline;
   (if name <> none then
       (name).theText.get->t; t[]->putline
    else
       ' is NONE!'->putline
   if);
   '****Multiplicity****'->putline;
   (if Multiplicity <> none then
       (Multiplicity).theText.get->t; t[]->putline
    else
       ' is NONE!'->putline
   if);
   '****thePatternDiagramNode****'->putline;
   (if thePatternDiagramNode <> none then
       (thePatternDiagramNode).id->putint; newline
    else
       ' is NONE!'->putline
   if)  

-- AssociationConnectorGenerateCode: DoPart --
do
   true->ok;
   INNER generateCode;
   (if not doneInInner then
       thisOp:
         (#
            theParentNode: ^PatternDiagramNode;
            theListDiagram,theOtherListDiagram,theParentDiagram: ^ListDiagram;
            theOADDiagram,theOtherOADDiagram: ^OADDiagram;
            aSimpleNode: ^theListDiagram.SimpleAttributeDecl;
            anotherSimpleNode: ^theOtherListDiagram.SimpleAttributeDecl;
            anAST,anotherAST,testAST,testAST2,lastAST,leftLastAST,rightLastAST,
              keepAST,keepOtherAST: ^mps.ast;
            theDesc,theOtherDesc: ^betaGram.ObjectDescriptor;
            t,theLeftName,theRightName,leftQualName,rightQualName,dummyQual,
              leftCode,rightCode: ^Text;
            optionalsInserted,optionalsInsertedOther,parseOK: @Boolean;
            makeName:
              (#
                 anExp: ^mps.expanded;
                 theNames: ^betaGram.Names;
                 theNameDcl: ^betaGram.NameDcl;
                 anAST: ^mps.ast;
                 theName: ^text
              enter anExp[]
              do
                 anExp.getSon1->theNames[];
                 theNames.getSon1->theNameDcl[];
                 theNameDcl.getNameDecl->anAST[];
                 (if anAST.kind = mps.kinds.unExpanded then
                     'NoName'->theName[]
                  else
                     theNameDcl.getText->theName[]
                 if)
              exit theName[]
              #)
         do
            (if (aPatternDiagramNode.theSifEditor).isReadOnly then
                (aPatternDiagramNode.theDiagram).titleText[]->t[];
                ' is read-only - can not generate code for association'
                  ->t.puttext;
                t[]->alertUser;
                false->ok
            if);
            (if (anotherPatternDiagramNode.theSifEditor).isReadOnly then
                (anotherPatternDiagramNode.theDiagram).titleText[]->t[];
                ' is read-only - can not generate code for association'
                  ->t.puttext;
                t[]->alertUser;
                false->ok
            if);
            (if ok then
                aPatternDiagramNode.theDiagram->theListDiagram[];
                anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
                (if (theListDiagram## <= FragmentDiagram##) or
                (theOtherListDiagram## <= FragmentDiagram##) then
                    'Source and/or destination is a fragment diagram'
                      ->AlertUser;
                    false->ok
                 else
                    (if (theListDiagram## <= PatternAttDiagram##) or
                    (theOtherListDiagram## <= PatternAttDiagram##) then
                        'Source and/or destination is an attributes form diagram'
                          ->AlertUser;
                        false->ok
                     else
                        (if theListDiagram.localNodes.empty then
                            theListDiagram.titleNode.getASTNode->keepAST[];
                            (if keepAST[] <> none then
                                (keepAST[],1)
                                  ->
                                    (theListDiagram.titleNode.theSifEditor).
                                    changeFocus
                            if);
                            (theListDiagram.titleNode.theSifEditor).
                            insertOptionals;
                            true->optionalsInserted
                        if);
                        (if theOtherListDiagram.localNodes.empty then
                            theOtherListDiagram.titleNode.getASTNode
                              ->keepOtherAST[];
                            (if keepOtherAST[] <> none then
                                (keepOtherAST[],1)
                                  ->
                                    (theOtherListDiagram.titleNode.theSifEditor)
                                      .changeFocus
                            if);
                            (theOtherListDiagram.titleNode.theSifEditor).
                            insertOptionals;
                            true->optionalsInsertedOther
                        if);
                        theListDiagram[]->theOADDiagram[];
                        theOtherListDiagram[]->theOtherOADDiagram[];
                        theOADDiagram.theDescriptor->theDesc[];
                        theOtherOADDiagram.theDescriptor->theOtherDesc[];
                        theDesc.father->anAST[];
                        theOtherDesc.father->anotherAST[];
                        anAST.father->testAST[];
                        anotherAST.father->testAST2[];
                        (if (testAST[] <> none ) and (testAST2[] <> none ) then
                            (if (anAST.symbol <> betaGram.StaticItem) and
                            (anotherAST.symbol <> betaGram.StaticItem) then
                                (if theListDiagram[] <> theOtherListDiagram[]
                                 then
                                    (theListDiagram.titleNode.getTopParent,
                                     theListDiagram.titleNode[],
                                     theOtherListDiagram.titleNode.getTopParent,
                                     theOtherListDiagram.titleNode[])->setEnds;
                                    theListDiagram.theParentNode
                                      ->theParentNode[];
                                    theParentNode.theDiagram
                                      ->theParentDiagram[];
                                    (theParentDiagram.localNodes.last).elm[]
                                      ->private.getLastAST->lastAST[];
                                    (theListDiagram.localNodes.last).elm[]
                                      ->private.getLastAST->leftLastAST[];
                                    (theOtherListDiagram.localNodes.last).elm[]
                                      ->private.getLastAST->rightLastAst[];
                                    (if (lastAST[] <> none ) and
                                    (leftLastAST[] <> none ) and
                                    (rightLastAST[] <> none ) then
                                        anAST[]->makeName->theLeftName[];
                                        anotherAST[]->makeName->theRightName[];
                                        anAST[]->private.makeQualName
                                          ->leftQualName[];
                                        anotherAST[]->private.makeQualName
                                          ->rightQualName[];
                                        (rightLastAST[],anAST[])
                                          ->getQualificationWithPath
                                          ->dummyQual[];
                                        (leftRoleName[],rightRoleName[],
                                         theLeftName[],theRightName[],
                                         leftQualName[],rightQualName[],
                                         dummyQual[])->private.getTextForCode
                                          ->(t[],leftCode[],rightCode[]);
                                        (if not embed then
                                            (theParentDiagram[],t[])
                                              ->private.parseAfter->parseOK;
                                            (if not parseOK then
                                                false->ok;
                                                'Internal parse error occured - should not happen!'
                                                  ->alertUser;
                                                leave thisOp
                                            if);
                                            currentFocus[]->associationNode
                                        if);
                                        (theListDiagram[],leftCode[])
                                          ->private.parseAfter->parseOK;
                                        (if not parseOK then
                                            false->ok;
                                            'Internal parse error occured - should not happen!'
                                              ->alertUser;
                                            leave thisOp
                                        if);
                                        currentFocus[]->left[]->aSimpleNode[];
                                        THIS(AssociationConnector)[]
                                          ->aSimpleNode.theAssociationConnector;
                                        (theOtherListDiagram[],rightCode[])
                                          ->private.parseAfter->parseOK;
                                        (if not parseOK then
                                            false->ok;
                                            'Internal parse error occured - should not happen!'
                                              ->alertUser;
                                            leave thisOp
                                        if);
                                        currentFocus[]->right[]
                                          ->anotherSimpleNode[];
                                        THIS(AssociationConnector)[]
                                          ->
                                            anotherSimpleNode.
                                              theAssociationConnector;
                                        (if not embed then
                                            (left.getASTNode,right.getASTNode,
                                             leftMulFrom,leftMulTo,rightMulFrom,
                                             rightMulTo,
                                             (associationNode).getASTNode)
                                              ->
                                                patternDiagrams.AssociationList.
                                                  insert
                                         else
                                            (left.getASTNode,right.getASTNode,
                                             leftMulFrom,leftMulTo,rightMulFrom,
                                             rightMulTo,none )
                                              ->
                                                patternDiagrams.AssociationList.
                                                  insert
                                        if);
                                        ((left.getASTNode).frag.father,
                                         'INCLUDE',frejaAssociationsInclude)
                                          ->sifAddProp;
                                        (if (right.getASTNode).frag.father <>
                                        (left.getASTNode).frag.father then
                                            ((right.getASTNode).frag.father,
                                             'INCLUDE',frejaAssociationsInclude)
                                              ->sifAddProp
                                        if)
                                     else
                                        'lastAST is NONE??'->stdErr.putline
                                    if)
                                 else
                                    'Source and destination is the same diagram'
                                      ->AlertUser;
                                    false->ok
                                if)
                             else
                                'Source and/or destination is singularly defined'
                                  ->AlertUser;
                                false->ok
                            if)
                         else
                            'Source and/or destination is a descriptor form diagram'
                              ->AlertUser;
                            false->ok
                        if);
                        (if optionalsInserted then
                            (if keepAST[] <> none then
                                (keepAST[],1)
                                  ->
                                    (theListDiagram.titleNode.theSifEditor).
                                    changeFocus
                            if);
                            (theListDiagram.titleNode.theSifEditor).
                            removeOptionals
                        if);
                        (if optionalsInsertedOther then
                            (if keepOtherAST[] <> none then
                                (keepOtherAST[],1)
                                  ->
                                    (theOtherListDiagram.titleNode.theSifEditor)
                                      .changeFocus
                            if);
                            (theOtherListDiagram.titleNode.theSifEditor).
                            removeOptionals
                        if)
                    if)
                if)
            if)
         #)
   if)  

-- AssociationConnectorGetValuesFromCode: DoPart --
do
   INNER getValuesFromCode;
   (if not doneInInner then
         (#
            theAssociationPattern: ^betaGram.PatternDecl;
            theNames: ^betaGram.Names;
            theNameDcl: ^betaGram.NameDcl;
            anAST: ^mps.ast;
            leftDecl,rightDecl: ^betaGram.SimpleDecl;
            theObjectDescriptor: ^betaGram.ObjectDescriptor;
            thePrefix: ^betaGram.Prefix;
            theNameApl: ^betaGram.NameApl;
            prefixName: ^text;
            help: @text;
            setEmbedImpl:
              (#
                 theDecl: ^betaGram.SimpleDecl;
                 anAST: ^mps.ast;
                 theStaticItem: ^betaGram.StaticItem;
                 os: ^betaGram.ObjectSpecification;
                 prefixName: ^text
              enter theDecl[]
              do
                 (if theDecl[] <> none then
                     theDecl.getreferenceSpecification->anAST[];
                     (if anAST.kind = mps.kinds.interior then
                         (if anAST.symbol = betaGram.StaticItem then
                             anAST[]->theStaticItem[];
                             theStaticItem.getObjectSpecification->os[];
                             (if os.symbol = betaGram.ObjectDescriptor then
                                 os[]->patternDiagrams.astUtils.getPrefixName
                                   ->prefixName[];
                                 (if prefixName[] <> none then
                                     (if 'AssociationMany'->prefixName.equalNCS
                                      then
                                     (* other (Set, hashTable,...) are not yet implemented *)
                                         gppProp.List->implementation
                                     if)
                                 if)
                             if)
                         if)
                     if)
                 if)
              #)
         do
            ((leftrole->lr[]).thePatternDiagramNode).getAstNode->anAST[];
            (if anAST.symbol = betaGram.SimpleDecl then
                anAST[]->leftDecl[];
                leftDecl.getNames->theNames[];
                theNames.getSon1->theNameDcl[];
                theNameDcl.getNameDecl->anAST[];
                (if not (anAST.kind = mps.kinds.unExpanded) then
                    theNameDcl.getText->rightRoleName[]
                if)
            if);
            ((rightrole->rr[]).thePatternDiagramNode).getAstNode->anAST[];
            (if anAST.symbol = betaGram.SimpleDecl then
                anAST[]->rightDecl[];
                rightDecl.getNames->theNames[];
                theNames.getSon1->theNameDcl[];
                theNameDcl.getNameDecl->anAST[];
                (if not (anAST.kind = mps.kinds.unExpanded) then
                    theNameDcl.getText->leftRoleName[]
                if)
            if);
            (if associationNode <> none then
                (associationNode).getAstNode->anAST[];
                (if anAST.symbol = betaGram.PatternDecl then
                    anAST[]->theAssociationPattern[];
                    theAssociationPattern.getNames->theNames[];
                    theNames.getSon1->theNameDcl[];
                    theNameDcl.getNameDecl->anAST[];
                    (if not (anAST.kind = mps.kinds.unExpanded) then
                        theNameDcl.getText->theName[]
                    if);
                    theAssociationPattern.getObjectDescriptor
                      ->patternDiagrams.astUtils.getPrefixName->prefixName[];
                    (if prefixName[] <> none then
                        (if not ('OneToOneAssociation'->prefixName.equalNCS)
                         then
                        (* other (Set, hashTable,...) are not yet implemented *)
                            gppProp.List->implementation
                        if)
                    if)
                if)
             else
                true->embed;
                (if name <> none then
                    (name).theText.get->help;
                    (if help.length > 0 then help[]->theName[] if)
                if);
                leftDecl[]->setEmbedImpl;
                rightDecl[]->setEmbedImpl
            if)
         #)
   if)  

-- AssociationConnectorInteractiveNew: DoPart --
do
   name[]->private.name[];
   implementation->private.implementation;
   leftRoleName[]->private.leftRoleName[];
   rightRoleName[]->private.rightRoleName[];
   leftMulFrom->private.leftMulFrom;
   leftMulTo->private.leftMulTo;
   rightMulFrom->private.rightMulFrom;
   rightMulTo->private.rightMulTo;
   embed->private.embed;
   description[]->private.description[];
   INNER interactiveNew  

-- AssociationConnectorRedisplay: DoPart --
do
   name[]->private.name[];
   leftRoleName[]->private.leftRoleName[];
   rightRoleName[]->private.rightRoleName[];
   implementation->private.implementation;
   leftMulFrom->private.leftMulFrom;
   leftMulTo->private.leftMulTo;
   rightMulFrom->private.rightMulFrom;
   rightMulTo->private.rightMulTo;
   embed->private.embed;
   description[]->private.description[];
   (if not (THIS(AssociationConnector)## <= AggregationConnector##) then
       thisOp:
         (#
            oldLeft,oldRight,oldAssociationPattern: ^mps.ast;
            theParentNode: ^PatternDiagramNode;
            t,theLeftName,theRightName,dummyQual,leftQualName,rightQualName,
              leftCode,rightCode: ^text;
            index,lx,ly,rx,ry: @integer;
            l: ^UserDataLabelNode;
            parseOK: @boolean;
            errorPos: @integer;
            parseErrorText: ^Text
         do
            (if (name[] <> none ) and (not ('<<NameDecl>>'->name.equal)) then
                (if THIS(AssociationConnector).name = none then
                    (leftrole->lr[]).center->(lx,ly);
                    (rightrole->rr[]).center->(rx,ry);
                    &UserDataLabelNode[]->l[];
                    (lx+((rx-lx) div 2),ly+((ry-ly) div 2),10,10,name)->l.new;
                    textStyle.italic->l.theText.style;
                    l.fitToText;
                    (lx+((rx-lx) div 2),ly+((ry-ly) div 2)-10)->l.move;
                    THIS(AssociationConnector)[]->l.createRegion;
                    l[]->THIS(AssociationConnector).name
                 else
                    name->(THIS(AssociationConnector).name).theText.set;
                    textStyle.italic
                      ->(THIS(AssociationConnector).name).theText.style
                if)
            if);
            (if leftRoleName[] <> none then
                leftRoleName.copy->theleftName[]
             else
                'NoName'->theLeftName[]
            if);
            (if rightRoleName[] <> none then
                rightRoleName.copy->theRightName[]
             else
                'NoName'->theRightName[]
            if);
            (if not embed then
                (if (name[] <> none ) and (not ('<<NameDecl>>'->name.equal))
                 then
                    name.copy->t[]
                 else
                    theLeftName.copy->t[]; theRightName[]->t.puttext
                if)
            if);
            ((leftrole->lr[]).thePatternDiagramNode).getASTNode->oldLeft[]
              ->patternDiagrams.astUtils.getEnclosingDecl->private.makeQualName
              ->leftQualName[];
            ((rightrole->rr[]).thePatternDiagramNode).getASTNode->oldRight[]
              ->patternDiagrams.astUtils.getEnclosingDecl->private.makeQualName
              ->rightQualName[];
            (((rightrole->rr[]).thePatternDiagramNode).getAstNode,
             ((leftrole->lr[]).thePatternDiagramNode).getAstNode
               ->patternDiagrams.astUtils.getEnclosingDecl)
              ->getQualificationWithPath->dummyQual[];
            (leftRoleName[],rightRoleName[],theLeftName[],theRightName[],
             leftQualName[],rightQualName[],dummyQual[])->private.getTextForCode
              ->(t[],leftCode[],rightCode[]);
            (if not embed then
                (if associationNode = none then
                    (((leftrole->lr[]).thePatternDiagramNode).theDiagram).
                    theParentNode->theParentNode[];
                    (theParentNode.theDiagram,t[])->private.parseAfter->parseOK;
                    (if not parseOK then
                        'Internal parse error occured - should not happen!'
                          ->alertUser;
                        leave thisOp
                    if);
                    currentFocus[]->associationNode
                 else
                    (associationNode).getAstNode->oldAssociationPattern[];
                    ((associationNode).getAstNode,t)
                      ->((associationNode).theSifEditor).parse
                      ->(parseOK,errorPos,parseErrorText[]);
                    (if not parseOK then
                        'Internal parse error - should not happen(!):'
                          ->stdErr.putline;
                        'trying to parse: '->stdErr.putline;
                        t[]->stdErr.putline;
                        'Error:'->stdErr.putline;
                        parseErrorText[]->stdErr.putline;
                        'Internal parse error occured - should not happen!'
                          ->alertUser;
                        leave thisOp
                    if)
                if)
             else
                (if associationNode <> none then
                    (associationNode).getAstNode->oldAssociationPattern[]
                if)
            if);
            (((leftrole->lr[]).thePatternDiagramNode).getAstNode,leftCode)
              ->(((leftrole->lr[]).thePatternDiagramNode).theSifEditor).parse
              ->(parseOK,errorPos,parseErrorText[]);
            (if not parseOK then
                'Internal parse error - should not happen(!):'->stdErr.putline;
                'trying to parse: '->stdErr.putline;
                leftCode[]->stdErr.putline;
                'Error:'->stdErr.putline;
                parseErrorText[]->stdErr.putline;
                'Internal parse error occured - should not happen!'->alertUser;
                leave thisOp
            if);
            (((rightrole->rr[]).thePatternDiagramNode).getAstNode,rightCode)
              ->(((rightrole->rr[]).thePatternDiagramNode).theSifEditor).parse
              ->(parseOK,errorPos,parseErrorText[]);
            (if not parseOK then
                'Internal parse error - should not happen(!):'->stdErr.putline;
                'trying to parse: '->stdErr.putline;
                rightCode[]->stdErr.putline;
                'Error:'->stdErr.putline;
                parseErrorText[]->stdErr.putline;
                'Internal parse error occured - should not happen!'->alertUser;
                leave thisOp
            if);
            (if not embed then
                (oldLeft[],oldRight[],oldAssociationPattern[],
                 ((leftrole->lr[]).thePatternDiagramNode).getAstNode,
                 ((rightrole->rr[]).thePatternDiagramNode).getAstNode,
                 (associationNode).getAstNode,leftMulFrom,leftMulTo,
                 rightMulFrom,rightMulTo)
                  ->patternDiagrams.AssociationList.updateElement
             else
                (oldLeft[],oldRight[],oldAssociationPattern[],
                 ((leftrole->lr[]).thePatternDiagramNode).getAstNode,
                 ((rightrole->rr[]).thePatternDiagramNode).getAstNode,none ,
                 leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
                  ->patternDiagrams.AssociationList.updateElement;
                (if oldAssociationPattern[] <> none then
                    (oldAssociationPattern[],1)
                      ->((associationNode).theSifEditor).changeFocus;
                    ((associationNode).theSifEditor).cut;
                    none ->associationNode
                if)
            if)
         #)
   if);
   INNER redisplay;
   (leftRoleName[],leftMulFrom,leftMulTo)->(leftrole->lr[]).redisplay;
   (rightRoleName[],rightMulFrom,rightMulTo)->(rightrole->rr[]).redisplay;
   gppProp.noGlobalInteractiveMode->gppProp.globalInteractiveMode;
   autosave  

-- AssociationConnectorVisibleSet: DoPart --
do
   (if name <> none then v->(name).visible if);
   v->(leftrole->lr[]).visible;
   v->(rightrole->rr[]).visible;
   INNER set  

-- AssociationConnectorAttributesVisible: DoPart --
do
   INNER attributesVisible;
   (if v then
       ((leftrole->lr[]).thePatternDiagramNode).center->(px,py);
       (leftrole->lr[]).center->(x,y);
       (x,py)->(leftrole->lr[]).center;
       ((rightrole->rr[]).thePatternDiagramNode).center->(px,py);
       (rightrole->rr[]).center->(x,y);
       (x,py)->(rightrole->rr[]).center
    else
       (((leftrole->lr[]).thePatternDiagramNode).theDiagram).titleNode.center
         ->(px,py);
       (leftrole->lr[]).center->(x,y);
       (x,py)->(leftrole->lr[]).center;
       (((rightrole->rr[]).thePatternDiagramNode).theDiagram).titleNode.center
         ->(px,py);
       (rightrole->rr[]).center->(x,y);
       (x,py)->(rightrole->rr[]).center
   if)  

-- AssociationConnectorOnDelete: DoPart --
do
   (if (leftRole <> none ) and (rightRole <> none ) then
       ((leftrole->lr[]).thePatternDiagramNode).getAstNode->anAST[];
       (if anAST[] <> none then
           (anAST[],1)
             ->
               (((leftrole->lr[]).thePatternDiagramNode).theSifEditor).
               changeFocus;
           (((leftrole->lr[]).thePatternDiagramNode).theSifEditor).cut
       if);
       (if not (THIS(AssociationConnector)## <= AggregationConnector##) then
           ((rightrole->rr[]).thePatternDiagramNode).getAstNode->anAST[];
           (if anAST[] <> none then
               (anAST[],1)
                 ->
                   (((rightrole->rr[]).thePatternDiagramNode).theSifEditor).
                   changeFocus;
               (((rightrole->rr[]).thePatternDiagramNode).theSifEditor).cut
           if);
           (if associationNode <> none then
               (associationNode).getAstNode->anAST[];
               (if anAST[] <> none then
                   (anAST[],1)->((associationNode).theSifEditor).changeFocus;
                   ((associationNode).theSifEditor).cut
               if)
           if)
       if)
    else
       'Connector is internally incomplete (due to recover?!)\ndelete connector by abstract/detail of involved classes'
         ->alertUser;
       'AssociationConnectorOnDelete: leftRole/RightRole is none?!'
         ->stdErr.putline
   if);
   INNER onDelete  

-- AssociationConnectorOnReattach: DoPart --
do
   (if not (THIS(AssociationConnector)## <= AggregationConnector##) then
       'Moving associations is not yet implemented'->alertUser; false->ok
   if);
   INNER onReattach  

-- AssociationConnectorOnDoubleClick: DoPart --
do
   INNER onDoubleClick;
   (if THIS(AssociationConnector)## = AssociationConnector## then
       patternDiagrams.AssociationList.find
         (#
            theName,leftRoleName,rightRoleName,description: ^Text;
            kind,implementation: @integer;
            embed: @boolean;
            predicate:: 
              (# anAST: ^mps.ast
              do
                 ((rightrole->rr[]).thePatternDiagramNode).getASTNode->anAST[];
                 (current.left =
                  (((leftrole->lr[]).thePatternDiagramNode).getASTNode).index)
                 and
                 ((((leftrole->lr[]).thePatternDiagramNode).getASTNode).frag.
                    fullname->current.leftFrag.equal) and
                 (current.right = anAST.index) and
                 (anAST.frag.fullname->current.rightFrag.equal)->value;
                 (if associationNode <> none then
                     (current.associationPattern =
                      ((associationNode).getAstNode).index) and
                     (((associationNode).getAstNode).frag.fullname
                        ->current.associationFrag.equal) and value->value
                 if)
              #);
            notFound:: 
              (#
                 ok: @integer;
                 anAST: ^mps.ast;
                 leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer;
                 tryGetMultiplicities:
                   (#
                      anAST: ^mps.ast;
                      leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer;
                      theAssociationPattern: ^betaGram.PatternDecl;
                      theObjectDescriptor: ^betaGram.ObjectDescriptor;
                      thePrefix: ^betaGram.prefix;
                      theNameApl: ^betaGram.NameApl;
                      prefixName: ^text
                   enter anAST[]
                   do
                      (1,1,1,1)
                        ->(leftMulFrom,leftMulTo,rightMulFrom,rightMulTo);
                      (if anAST.symbol = betaGram.PatternDecl then
                          anAST[]->theAssociationPattern[];
                          theAssociationPattern.getObjectDescriptor
                            ->theObjectDescriptor[];
                          theObjectDescriptor.getPrefixOpt->anAST[];
                          (if anAST.kind = mps.kinds.interior then
                              anAST[]->thePrefix[];
                              thePrefix.getAttributeDenotation->anAST[];
                              (if anAST.symbol = betaGram.NameApl then
                                  anAST[]->theNameApl[];
                                  theNameApl.getNameAppl->anAST[];
                                  (if anAST.kind <> mps.kinds.unExpanded then
                                      theNameApl.getText->prefixName[];
                                      (if true
                                       //
                                       ('OneToOneAssociation'
                                          ->prefixName.equalNCS) then
                                          (1,1,1,1)
                                            ->
                                              (leftMulFrom,leftMulTo,
                                               rightMulFrom,rightMulTo)
                                       //
                                       ('OneToManyAssociation'
                                          ->prefixName.equalNCS) then
                                          (1,1,- 1,- 1)
                                            ->
                                              (leftMulFrom,leftMulTo,
                                               rightMulFrom,rightMulTo)
                                       //
                                       ('ManyToManyAssociation'
                                          ->prefixName.equalNCS) then
                                          (- 1,- 1,- 1,- 1)
                                            ->
                                              (leftMulFrom,leftMulTo,
                                               rightMulFrom,rightMulTo)
                                      if)
                                  if);
                                  
                              if)
                          if)
                      if)
                   exit (leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
                   #)
              do
                 ('Association Doubleclick',
                  'The association code has been edited in Sif,\nCheck the program to insure consistency?\n- "No" will launch the aggregation dialog\nwith settings that are as consistent as\npossible with the code.\n')
                   ->promptForBoolean->ok;
                 (if ok
                  // yes then
                     ((leftrole->lr[]).thePatternDiagramNode).getAstNode
                       ->anAST[];
                     (if anAST[] <> none then
                         anAST.frag.father->callChecker
                     if)
                  // no then
                     getValuesFromCode
                       ->
                         (theName[],leftRoleName[],rightRoleName[],
                          implementation,embed);
                     (if associationNode <> none then
                         (associationNode).getAstNode->tryGetMultiplicities
                           ->(leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
                      else
                         (1,1,1,1)
                           ->(leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
                     if);
                     (THIS(AssociationConnector)[],theName[],leftRoleName[],
                      rightRoleName[],implementation,leftMulFrom,leftMulTo,
                      rightMulFrom,rightMulTo,embed,description[])
                       ->openAssociationDialog
                  // cancel then
                     
                 if)
              #)
         do
            getValuesFromCode
              ->(theName[],leftRoleName[],rightRoleName[],implementation,embed);
            (THIS(AssociationConnector)[],theName[],leftRoleName[],
             rightRoleName[],implementation,current.leftMulFrom,
             current.leftMulTo,current.rightMulFrom,current.rightMulTo,embed,
             description[])->openAssociationDialog
         #)
   if)  

-- AssociationConnectorOnInit: DoPart --
do
     (#
        object1,object2: ^DesignObject;
        node1,node2: ^node;
        succeded: @boolean;
        theRole: ^Role;
        lx,ly,rx,ry: @integer;
        l: ^UserDataLabelNode
     do
        (if switch[30] or switch[53] then
            'AssociationConnector onInit'->putline
        if);
        UDPrivate.UDAssociationConnector->UserDataInit;
        name.init;
        associationNode.init;
        leftRole.init;
        rightRole.init;
        embed.init;
        0->Orient;
        INNER onInit;
        (if not InitialisingSaved then
            true->getEnds->(object1[],object2[]);
            (if (object1[] <> none ) and (object2[] <> none ) then
                (if (object1## <= node##) and (object2## <= node##) then
                    object1[]->node1[];
                    object2[]->node2[];
                    (if ((node1[]->BoxToNode->node1[]) <> none ) and
                    ((node2[]->BoxToNode->node2[]) <> none ) then
                        (if (node1## <= PatternDiagramNode##) and
                        (node2## <= PatternDiagramNode##) then
                            (node1[],node2[],private.name.copy,
                             private.implementation,private.leftRoleName[],
                             private.rightRoleName[],private.leftMulFrom,
                             private.leftMulTo,private.rightMulFrom,
                             private.rightMulTo,private.embed->embed)
                              ->generateCode->(succeded,left[],right[]);
                            (if not succeded then delete if);
                            
                         else
                            Delete;
                            'Source or destination is not part of a pattern diagram'
                              ->AlertUser
                        if)
                     else
                        Delete;
                        'Source or destination is not part of a pattern diagram'
                          ->AlertUser
                    if)
                 else
                    Delete;
                    'Source or destination is not part of a pattern diagram'
                      ->AlertUser
                if)
             else
                Delete
            if);
            (if succeded then
                &Role[]->theRole[];
                (private.leftRoleName[],private.leftMulFrom,private.leftMulTo,
                 left[])->theRole.display;
                theRole[]->leftRole;
                &Role[]->theRole[];
                (private.rightRoleName[],private.rightMulFrom,
                 private.rightMulTo,right[])->theRole.display;
                theRole[]->rightRole;
                ((leftrole->lr[]).getTopParent,leftRole,
                 (rightrole->rr[]).getTopParent,rightrole->rr[])->setEnds;
                (if not
                (THIS(AssociationConnector)## <= AggregationConnector##) then
                    (if (private.name[] <> none ) and
                    (not ('<<NameDecl>>'->private.name.equal)) then
                        (leftrole->lr[]).center->(lx,ly);
                        (rightrole->rr[]).center->(rx,ry);
                        &UserDataLabelNode[]->l[];
                        (lx+((rx-lx) div 2),ly+((ry-ly) div 2),10,10,
                         private.name)->l.new;
                        textStyle.italic->l.theText.style;
                        l.fitToText;
                        (lx+((rx-lx) div 2),ly+((ry-ly) div 2)-10)->l.move;
                        THIS(AssociationConnector)[]->l.createRegion;
                        l[]->name
                    if);
                    (if not gppProp.associations then false->visible if)
                 else
                    (if (not gppProp.references) or
                    (left.theDiagram = right.theDiagram) then
                        false->visible
                    if)
                if);
                (if not gppProp.showAttributes then
                    false->attributesVisible
                if)
            if);
            gppProp.noGlobalInteractiveMode->gppProp.globalInteractiveMode;
            statusbar.reset;
            autosave
        if)
     #)  

-- AssocConnectorDump: DoPart --
do
   '****name****'->putline;
   (if name <> none then
       (name).theText.get->t; t[]->putline
    else
       ' is NONE!'->putline
   if);
   '****embed****\n%s\n'
     ->putformat (# t: @text do embed->t.putBoolean; t[]->s #);
   '****associationNode****'->putline;
   (if associationNode <> none then
       (associationNode).id->putint; newline
   if);
   '****leftRole****'->putline;
   (if leftRole <> none then
       (leftrole->lr[]).dump
    else
       ' is NONE!'->putline
   if);
   '****rightRole****'->putline;
   (if rightRole <> none then
       (rightrole->rr[]).dump
    else
       ' is NONE!'->putline
   if);
   INNER dump  

-- AssociationConnectorPrivate: Descriptor --
(#
   name,description,leftRoleName,rightRoleName: ^text;
   implementation,leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer;
   embed: @boolean;
   makeQualName:
     (#
        theDecl: ^betaGram.AttributeDecl;
        t: ^text;
        theNames: ^betaGram.Names;
        theNameDcl: ^betaGram.NameDcl;
        anAST: ^mps.ast
     enter theDecl[]
     do
        theDecl.getSon1->theNames[];
        theNames.getSon1->theNameDcl[];
        theNameDcl.getNameDecl->anAST[];
        (if anAST.kind = mps.kinds.unExpanded then
            '<<NameAppl>>'->t[]
         else
            theNameDcl.getText->t[]
        if)
     exit t[]
     #);
   isManyToMany:
     (# 
     exit ((leftMulTo = - 1) or (leftMulTo > 1)) and
     ((rightMulTo = - 1) or (rightMulTo > 1))
     #);
   isOneToMany:
     (# 
     exit ((leftMulTo = 0) or (leftMulTo = 1)) and
     ((rightMulTo = - 1) or (rightMulTo > 1))
     #);
   isManyToOne:
     (# 
     exit ((leftMulTo = - 1) or (leftMulTo > 1)) and
     ((rightMulTo = 0) or (rightMulTo = 1))
     #);
   isOneToOne:
     (# 
     exit ((leftMulTo = 0) or (leftMulTo = 1)) and
     ((rightMulTo = 0) or (rightMulTo = 1))
     #);
   parseAfter:
     (#
        theListDiagram: ^ListDiagram;
        parseText: ^text;
        theNonTerminalNode: ^theListDiagram.NonTerminalNode;
        anAST: ^mps.ast;
        ok: @boolean;
        errorPos: @integer;
        parseErrorText: ^Text
     enter (theListDiagram[],parseText[])
     do
        currentFocus[]->oldFocus[];
        (theListDiagram.LocalNodes.last).elm[]->currentFocus[]->currentObject;
        currentFocus.getASTNode->anAST[];
        (if anAST[] <> none then
            (anAST[],1)->(currentFocus.theSifEditor).changeFocus;
            (currentFocus.theSifEditor).after
         else
            currentFocus[]->theNonTerminalNode[];
            (theNonTerminalNode.unExp,1)
              ->(currentFocus.theSifEditor).changeFocus
        if);
        currentFocus[]->theNonTerminalNode[];
        (theNonTerminalNode.unExp,parseText)
          ->(theNonTerminalNode.theSifEditor).parse
          ->(ok,errorPos,parseErrorText[]);
        (if not ok then
            'Internal parse error - should not happen(!):'->stdErr.putline;
            'trying to parse: '->stdErr.putline;
            parseText[]->stdErr.putline;
            'Error:'->stdErr.putline;
            parseErrorText[]->stdErr.putline
        if)
     exit ok
     #);
   getLastAST:
     (#
        lastNode: ^PatternDiagramNode;
        lastAST: ^mps.ast;
        theListDiagram: ^ListDiagram;
        theNonTerminalNode: ^theListDiagram.NonTerminalNode
     enter lastNode[]
     do
        lastNode.getAstNode->lastAST[];
        (if lastAST[] = none then
            lastNode.theDiagram->theListDiagram[];
            (if lastNode## <= theListDiagram.NonterminalNode## then
                lastNode[]->theNonTerminalNode[];
                theNonTerminalNode.unexp->lastAST[]
             else
                'No AST for last node??'->stdErr.putline
            if)
        if)
     exit lastAST[]
     #);
   getTextForCode:
     (#
        leftRoleName,rightRoleName,theLeftName,theRightName,leftQualName,
          rightQualName,dummyQual,t,leftCode,rightCode: ^Text;
        index: @integer
     enter
     (leftRoleName[],rightRoleName[],theLeftName[],theRightName[],
      leftQualName[],rightQualName[],dummyQual[])
     do
        (if not embed then
            (if (name[] <> none ) and (not ('<<NameDecl>>'->name.equal)) then
                name.copy->t[]
             else
                theLeftName.copy->t[]; theRightName[]->t.puttext
            if)
        if);
        (if rightRoleName[] <> none then
            rightRoleName.copy->leftCode[]
         else
            'the'->(theRightName.copy).prepend->leftCode[]
        if);
        (if leftRoleName[] <> none then
            leftRoleName.copy->rightCode[]
         else
            'the'->(theLeftName.copy).prepend->rightCode[]
        if);
        impl:
        (if implementation
         // gppProp.noimplementation then
            (if not embed then
                ':OneToOneAssociation(# leftType::< '->t.puttext;
                leftQualName[]->t.puttext;
                '; rightType::< '->t.puttext;
                rightQualName[]->t.puttext;
                ' #) '->t.puttext
             else
                ':@AssociationOne(# element:: '->leftCode.puttext;
                ':@AssociationOne(# element:: '->rightCode.puttext
            if)
         // gppProp.list then
            (if true
             // private.isManyToMany then
                (if not embed then
                    ':ManyToManyAssociation(# leftType::< '->t.puttext;
                    leftQualName[]->t.puttext;
                    '; rightType::< '->t.puttext;
                    rightQualName[]->t.puttext;
                    ' #) '->t.puttext
                 else
                    ':@AssociationMany(# element:: '->leftCode.puttext;
                    ':@AssociationMany(# element:: '->rightCode.puttext
                if)
             // private.isOneToMany then
                (if not embed then
                    ':OneToManyAssociation(# oneType::< '->t.puttext;
                    leftQualName[]->t.puttext;
                    '; ManyElmType::< '->t.puttext;
                    rightQualName[]->t.puttext;
                    ' #) '->t.puttext
                 else
                    ':@AssociationMany(# element:: '->leftCode.puttext;
                    ':@AssociationOne(# element:: '->rightCode.puttext
                if)
             // private.isManyToOne then
                (if not embed then
                    ':OneToManyAssociation(# oneType::< '->t.puttext;
                    rightQualName[]->t.puttext;
                    '; ManyElmType::< '->t.puttext;
                    leftQualName[]->t.puttext;
                    ' #) '->t.puttext
                 else
                    ':@AssociationOne(# element:: '->leftCode.puttext;
                    ':@AssociationMany(# element:: '->rightCode.puttext
                if)
             // private.isOneToOne then
                (if not embed then
                    ':OneToOneAssociation(# leftType::< '->t.puttext;
                    leftQualName[]->t.puttext;
                    '; rightType::< '->t.puttext;
                    rightQualName[]->t.puttext;
                    ' #) '->t.puttext
                 else
                    ':@AssociationOne(# element:: '->leftCode.puttext;
                    ':@AssociationOne(# element:: '->rightCode.puttext
                if)
            if)
         else
            gppProp.list->implementation;
            'unknown value for implementation: %i - choosing default\n'
              ->stderr.putformat (#  do implementation->i #);
            restart impl
        if);
        (if not embed then
            ':^'->leftCode.puttext;
            (if (name[] <> none ) and (not ('<<NameDecl>>'->name.equal)) then
                name[]->leftCode.puttext
             else
                theLeftName[]->leftCode.puttext;
                theRightName[]->leftCode.puttext
            if);
            ':^'->rightCode.puttext;
            '.'->dummyQual.findAll (#  do inx->index #);
            (index+1,dummyQual.length)->dummyQual.delete;
            dummyQual[]->rightCode.puttext;
            (if (name[] <> none ) and (not ('<<NameDecl>>'->name.equal)) then
                name[]->rightCode.puttext
             else
                theLeftName[]->rightCode.puttext;
                theRightName[]->rightCode.puttext
            if)
         else
            rightQualName[]->leftCode.puttext;
            ' #)'->leftCode.puttext;
            leftQualName[]->rightCode.puttext;
            ' #)'->rightCode.puttext
        if)
     exit (t[],leftCode[],rightCode[])
     #)
#)  

-- AggregationConnectorOnDelete: DoPart --
do INNER onDelete  

-- AggregationConnectorOnReattach: DoPart --
do
   patternDiagrams.AggregationList.find
     (#
        theName,leftRoleName,rightRoleName,description: ^Text;
        kind,implementation: @integer;
        embed: @boolean;
        answer,x,y,w,h: @integer;
        succeded: @boolean;
        node1,node2,dummy: ^DesignObject;
        left,right: ^PatternDiagramNode;
        anAST: ^mps.ast;
        predicate:: 
          (# anAST: ^mps.ast
          do
             ((rightrole->rr[]).thePatternDiagramNode).getASTNode->anAST[];
             (if not
             (anAST## <= betaGram.AttributeDecl##)
             (* in case it was a titlenode *) then
                 anAST[]->patternDiagrams.astUtils.getEnclosingDecl->anAST[]
             if);
             (if switch[54] then
                 'AggregationConnector onReattach - Comparing: %i %i and %i %i\n'
                   ->putformat
                     (# 
                     do
                        current.left->i;
                        (((leftrole->lr[]).thePatternDiagramNode).getASTNode).
                        index->i;
                        current.right->i;
                        anAST.index->i
                     #)
             if);
             (current.left =
              (((leftrole->lr[]).thePatternDiagramNode).getASTNode).index) and
             ((((leftrole->lr[]).thePatternDiagramNode).getASTNode).frag.
                fullname->current.leftFrag.equal) and
             (current.right = anAST.index) and
             (anAST.frag.fullname->current.rightFrag.equal)->value
          #);
        notFound:: 
          (# 
          do
             ('Move Aggregation',
              'The aggregation code has been edited in Sif,\nCheck the program to insure consistency?\n\n- "No" will generate code as consistenly as\npossible with the current code.\n')
               ->promptForBoolean->answer;
             (if answer
              // yes then
                 false->ok;
                 ((leftrole->lr[]).thePatternDiagramNode).getAstNode->anAST[];
                 (if anAST[] <> none then anAST.frag.father->callChecker if)
              // no then
                 getValuesFromCode
                   ->
                     (theName[],leftRoleName[],rightRoleName[],implementation,
                      embed,private.kind);
                 (if whichEnd then
                     theNew[]->BoxToNode->theNew[];
                     (if theNew## <= PatternDiagramNode## then
                         ((leftrole->lr[]).thePatternDiagramNode,theNew[],
                          theName[],implementation,none ,none ,1,1,1,1,true,
                          kind)->generateCode->(succeded,left[],right[]);
                         (if succeded then
                             whichEndUpdateRoles
                          else
                             false->ok
                         if)
                      else
                         'The relation has been attached to a node that is not part of a pattern diagram'
                           ->AlertUser;
                         false->ok
                     if)
                  else
                     'Moving simpleDecl end of relation not yet implemented'
                       ->AlertUser;
                     false->ok
                 if)
              // cancel then
                 false->ok
             if)
          #);
        whichEndUpdateRoles:
          (# 
          do
             (rightrole->rr[]).unMakeRegion;
             right[]->(rightrole->rr[]).thePatternDiagramNode;
             (none ,current.leftMulFrom,current.leftMulTo)
               ->(leftrole->lr[]).redisplay;
             (none ,current.rightMulFrom,current.rightMulTo)
               ->(rightrole->rr[]).redisplay;
             ((leftrole->lr[]).getTopParent,leftRole,
              (rightrole->rr[]).getTopParent,rightrole->rr[])->setEnds;
             false->ok;
             right.geometry->(x,y,w,h);
             x-w div 2->x;
             (x,y)->(rightrole->rr[]).move;
             right[]->(rightrole->rr[]).createRegion
          #)
     do
        getValuesFromCode
          ->
            (theName[],leftRoleName[],rightRoleName[],implementation,embed,
             kind);
        (if whichEnd then
            theNew[]->BoxToNode->theNew[];
            (if theNew## <= PatternDiagramNode## then
                (if (rightrole->rr[]).thePatternDiagramNode <> theNew[] then
                    ((leftrole->lr[]).thePatternDiagramNode,theNew[],theName[],
                     implementation,none ,none ,current.leftMulFrom,
                     current.leftMulTo,current.rightMulFrom,current.rightMulTo,
                     true,kind)->generateCode->(succeded,left[],right[]);
                    (if succeded then whichEndUpdateRoles else false->ok if)
                if)
             else
                'The relation has been attached to a node that is not part of a pattern diagram'
                  ->AlertUser;
                false->ok
            if)
         else
            'Moving simpleDecl end of relation not yet implemented'->AlertUser;
            false->ok
        if)
     #)  

-- AggregationConnectorOnDoubleClick: DoPart --
do
   patternDiagrams.AggregationList.find
     (#
        theName,leftRoleName,rightRoleName,description: ^Text;
        kind,implementation: @integer;
        embed: @boolean;
        predicate:: 
          (# anAST: ^mps.ast
          do
             ((rightrole->rr[]).thePatternDiagramNode).getASTNode->anAST[];
             (if not
             (anAST## <= betaGram.AttributeDecl##)
             (* in case it was a titlenode *) then
                 anAST[]->patternDiagrams.astUtils.getEnclosingDecl->anAST[]
             if);
             (if switch[54] then
                 'AggregationConnector onDoubleClick - Comparing: %i %i and %i %i/n'
                   ->putformat
                     (# 
                     do
                        current.left->i;
                        (((leftrole->lr[]).thePatternDiagramNode).getASTNode).
                        index->i;
                        current.right->i;
                        anAST.index->i
                     #)
             if);
             (current.left =
              (((leftrole->lr[]).thePatternDiagramNode).getASTNode).index) and
             ((((leftrole->lr[]).thePatternDiagramNode).getASTNode).frag.
                fullname->current.leftFrag.equal) and
             (current.right = anAST.index) and
             (anAST.frag.fullname->current.rightFrag.equal)->value
          #);
        notFound:: 
          (# ok: @integer; anAST: ^mps.ast
          do
             ('Aggregation Doubleclick',
              'The aggregation code has been edited in Sif,\nCheck the program to insure consistency?\n- "No" will launch the aggregation dialog\nwith settings that are as consistent as\npossible with the code.\n')
               ->promptForBoolean->ok;
             (if ok
              // yes then
                 ((leftrole->lr[]).thePatternDiagramNode).getAstNode->anAST[];
                 (if anAST[] <> none then anAST.frag.father->callChecker if)
              // no then
                 getValuesFromCode
                   ->
                     (theName[],leftRoleName[],rightRoleName[],implementation,
                      embed,kind);
                 (THIS(AggregationConnector)[],theName[],kind,implementation,1,
                  1,1,1,description[])->openAggregationDialog
              // cancel then
                 
             if)
          #)
     do
        getValuesFromCode
          ->
            (theName[],leftRoleName[],rightRoleName[],implementation,embed,
             kind);
        (THIS(AggregationConnector)[],theName[],kind,implementation,
         current.leftMulFrom,current.leftMulTo,current.rightMulFrom,
         current.rightMulTo,description[])->openAggregationDialog
     #)  

-- AggregationConnectorInterativeNew: DoPart --
do kind->private.kind; INNER InteractiveNew  

-- AggregationConnectorGenerateCode: DoPart --
do
   thisOp:
     (#
        theNode,dummyNode: ^node;
        t,qualification,includeString: ^text;
        theListDiagram,theOtherListDiagram: ^ListDiagram;
        theOtherOADDiagram: ^OADDiagram;
        aDiagramNode: ^theOtherListDiagram.DiagramNode;
        aSimpleNode: ^theListDiagram.SimpleAttributeDecl;
        aNonTerminalNode: ^theListDiagram.NonTerminalNode;
        titleText: @text;
        anAST,aDeclAST,rightAst: ^MPS.AST;
        theDesc: ^betaGram.ObjectDescriptor;
        anExp,anotherExp: ^mps.expanded;
        theNames: ^betaGram.Names;
        theNameDcl: ^betaGram.NameDcl;
        theAttrDecl: ^betaGram.AttributeDecl;
        regions,existingConnectors: ^ObjectList;
        theCon: ^Connector;
        theAggrCon: ^AggregationConnector;
        x,y,w,h: @integer;
        optionalsInserted: @boolean;
        parseOK: @boolean;
        errorPos: @integer;
        parseErrorText: ^Text
     do
        true->doneInInner;
        (if (aPatternDiagramNode.theSifEditor).isReadOnly then
            (aPatternDiagramNode.theDiagram).titleText[]->t[];
            ' is read-only - can not generate code for aggregation'->t.puttext;
            t[]->alertUser;
            false->ok
         else
            (if kind = 0 then private.kind->kind if);
            aPatternDiagramNode.theDiagram->theListDiagram[];
            (if aPatternDiagramNode## <= theListDiagram.NonTerminalNode## then
                aPatternDiagramNode[]->aNonTerminalNode[]; theName.copy->t[]
             else
                (if aPatternDiagramNode## <=
                theListDiagram.SimpleAttributeDecl## then
                    aPatternDiagramNode[]->aSimpleNode[];
                    aPatternDiagramNode.getASTNode->anExp[];
                    (* If no name was specified
                     check if simpleDecl already
                     has name and use that if so *)
                    (if '<<NameDecl>>'->theName.equal then
                        anExp.getSon1->theNames[];
                        theNames.getSon1->theNameDcl[];
                        theNameDcl.getNameDecl->anAST[];
                        (if anAST.kind = mps.kinds.unExpanded then
                            theName.copy->t[]
                         else
                            theNameDcl.getText->t[]
                        if)
                     else
                        theName.copy->t[]
                    if)
                 else
                    currentFocus[]->oldFocus[];
                    (if theListDiagram.localNodes.empty then
                        theListDiagram.titleNode[]->currentFocus[]
                          ->currentObject;
                        theListDiagram.titleNode.getASTNode->anAST[];
                        (if anAST[] <> none then
                            (anAST[],1)
                              ->
                                (theListDiagram.titleNode.theSifEditor).
                                changeFocus
                        if);
                        (theListDiagram.titleNode.theSifEditor).insertOptionals;
                        true->optionalsInserted;
                        (theListDiagram.localNodes.last).elm[]
                          ->aNonTerminalNode[];
                        currentFocus[]->oldFocus[];
                        aNonTerminalNode[]->currentFocus[]->currentObject;
                        (aNonTerminalNode.unExp,1)
                          ->(theListDiagram.titleNode.theSifEditor).changeFocus
                     else
                        (if (theListDiagram.localNodes.last).elm## <=
                        theListDiagram.NonTerminalNode## then
                            (theListDiagram.localNodes.last).elm[]
                              ->aNonTerminalNode[];
                            aNonTerminalNode.unExp->anAST[]
                         else
                            (theListDiagram.localNodes.last).elm.getASTNode
                              ->anAST[]
                        if);
                        (theListDiagram.localNodes.last).elm[]->currentFocus[]
                          ->currentObject;
                        (anAST[],1)
                          ->(theListDiagram.titleNode.theSifEditor).changeFocus;
                        (theListDiagram.titleNode.theSifEditor).after
                    if);
                    currentObject->aNonTerminalNode[];
                    theName.copy->t[]
                if)
            if);
            anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
            (if anotherPatternDiagramNode## <= theOtherListDiagram.title## then
                theOtherListDiagram[]->theOtherOADDiagram[];
                theOtherOADDiagram.theDescriptor->theDesc[];
                theDesc.father->anotherExp[];
                (if anotherExp## <= betaGram.AttributeDecl## then
                    (if aNonTerminalNode[] <> none then
                        (aNonTerminalNode.unExp,anotherExp[])
                          ->getQualificationWithPath->qualification[]
                     else
                        (anExp[],anotherExp[])->getQualificationWithPath
                          ->qualification[]
                    if);
                    (if theListDiagram[] = theOtherListDiagram[] then
                        Delete
                    if)
                 else
                    false->ok; 'Destination is singularly defined'->AlertUser
                if)
             else
                (if
                (anotherPatternDiagramNode## <=
                 theOtherListDiagram.PatternNode##) or
                (anotherPatternDiagramNode## <=
                 theOtherListDiagram.VirtualNode##) or
                (anotherPatternDiagramNode## <=
                 theOtherListDiagram.BindingNode##) or
                (anotherPatternDiagramNode## <= theOtherListDiagram.FinalNode##)
                 then
                    anotherPatternDiagramNode[]->aDiagramNode[];
                    aDiagramNode.theDeclaration->theAttrDecl[];
                    (if aNonTerminalNode[] <> none then
                        (aNonTerminalNode.unExp,theAttrDecl[])
                          ->getQualificationWithPath->qualification[]
                     else
                        (anExp[],theAttrDecl[])->getQualificationWithPath
                          ->qualification[]
                    if)
                 else
                    false->ok;
                    'The destination is not a pattern, virtual, binding or final declaration'
                      ->AlertUser
                if)
            if);
            (if qualification[] <> none then
                ':'->t.puttext;
                (if implementation
                 // gppProp.noImplementation then
                    (if kind
                     // gppProp.byValue then
                        '@'->t.puttext
                     // gppProp.byReference then
                        '^'->t.puttext
                     else
                        '^'->t.puttext;
                        'unknown value for kind: %i - choosing default\n'
                          ->stderr.putformat (#  do kind->i #)
                    if);
                    qualification[]->t.puttext
                 // gppProp.Repetition then
                    '['->t.puttext;
                    (if rightMulTo > 0 then
                        rightMulTo->t.putint
                     else
                        100->t.putint
                    if);
                    ']'->t.puttext;
                    (if kind
                     // gppProp.byValue then
                        '@'->t.puttext
                     // gppProp.byReference then
                        '^'->t.puttext
                     else
                        '^'->t.puttext;
                        'unknown value for kind: %i - choosing default\n'
                          ->stderr.putformat (#  do kind->i #)
                    if);
                    qualification[]->t.puttext
                 else
                    '@'->t.puttext;
                    '~beta/containers/v1.6/'->includeString[];
                    (if implementation
                     // gppProp.ArrayContainer then
                        'ArrayContainer'->t.puttext;
                        'arrayContainer'->includeString.puttext
                     // gppProp.HashTable then
                        'HashTable'->t.puttext;
                        'hashTable'->includeString.puttext
                     // gppProp.ExtensibleHashTable then
                        'ExtensibleHashTable'->t.puttext;
                        'hashTable'->includeString.puttext
                     // gppProp.List then
                        'List'->t.puttext; 'list'->includeString.puttext
                     // gppProp.Set then
                        'Set'->t.puttext; 'sets'->includeString.puttext
                     // gppProp.MultiSet then
                        'MultiSet'->t.puttext; 'sets'->includeString.puttext
                     // gppProp.Stack then
                        'Stack'->t.puttext;
                        'seqContainers'->includeString.puttext
                     // gppProp.Queue then
                        'Queue'->t.puttext;
                        'seqContainers'->includeString.puttext
                     // gppProp.PriorityQueue then
                        'PriorityQueue'->t.puttext;
                        'seqContainers'->includeString.puttext
                     else
                        'Set'->t.puttext;
                        'sets'->includeString.puttext;
                        'unknown value for implementation: %i - choosing default\n'
                          ->stderr.putformat (#  do implementation->i #)
                    if);
                    '(# element::'->t.puttext;
                    qualification[]->t.puttext;
                    ' #)'->t.puttext
                if);
                &Node[]->dummyNode[];
                (0,0,0,0)->dummyNode.new;
                (dummyNode.getTopParent,dummyNode[],
                 theOtherListDiagram.titleNode.getTopParent,
                 theOtherListDiagram.titleNode[])->setEnds;
                (if aNonTerminalNode[] <> none then
                    (aNonTerminalNode.unExp,t)
                      ->(aNonTerminalNode.theSifEditor).parse
                      ->(parseOK,errorPos,parseErrorText[]);
                    (if not parseOK then
                        false->ok;
                        'Internal parse error - should not happen(!):'
                          ->stdErr.putline;
                        'trying to parse: '->stdErr.putline;
                        t[]->stdErr.putline;
                        'Error:'->stdErr.putline;
                        parseErrorText[]->stdErr.putline;
                        'Internal parse error occured - should not happen!'
                          ->alertUser;
                        leave thisOp
                    if);
                    currentObject->aSimpleNode[];
                    (if optionalsInserted then
                        (if anAST[] <> none then
                            (anAST[],1)
                              ->
                                (theListDiagram.titleNode.theSifEditor).
                                changeFocus
                        if);
                        (theListDiagram.titleNode.theSifEditor).removeOptionals
                    if)
                 else
                    (if (aSimpleNode.theAggregationConnector <> none ) and
                    (aSimpleNode.theAggregationConnector <> THIS(
                     AggregationConnector)[]) then
                        aSimpleNode.theAggregationConnector->theAggrCon[];
                        theAggrCon.leftRole->theNode[];
                        theAggrCon.rightRole->dummyNode[];
                        theAggrCon.delete;
                        theNode.delete;
                        dummyNode.delete
                    if);
                    (anExp[],t)->(aSimpleNode.theSifEditor).parse
                      ->(parseOK,errorPos,parseErrorText[]);
                    (if not parseOK then
                        false->ok;
                        'Internal parse error - should not happen(!):'
                          ->stdErr.putline;
                        'trying to parse: '->stdErr.putline;
                        t[]->stdErr.putline;
                        'Error:'->stdErr.putline;
                        parseErrorText[]->stdErr.putline;
                        'Internal parse error occured - should not happen!'
                          ->alertUser;
                        leave thisOp
                    if);
                    (* if simpleNode is replaced by repetitionNode
                     or vice-versa aSimpleNode has to be set *)
                    currentObject->aSimpleNode[]
                if);
                (if includeString[] <> none then
                    ((aSimpleNode.theDeclaration).frag.father,'INCLUDE',
                     includeString[])->sifAddProp
                if);
                (if aDiagramNode[] <> none then
                    (if aDiagramNode.currentDecomposDiagram <> none then
                        aSimpleNode[]->left[];
                        (aDiagramNode.currentDecomposDiagram).titleNode[]
                          ->right[]
                     else
                        aSimpleNode[]->left[]; aDiagramNode[]->right[]
                    if)
                 else
                    aSimpleNode[]->left[];
                    theOtherListDiagram.titleNode[]->right[]
                if)
            if);
            (if ok (*A connector was created*) then
                right.getAstNode->rightAst[];
                (if not (rightAst## <= betaGram.AttributeDecl##) then
                    rightAst[]->patternDiagrams.astUtils.getEnclosingDecl
                      ->rightAst[]
                if);
                (aSimpleNode.theDeclaration,rightAst[],leftMulFrom,leftMulTo,
                 rightMulFrom,rightMulTo)
                  ->patternDiagrams.AggregationList.insert;
                THIS(AggregationConnector)[]
                  ->aSimpleNode.theAggregationConnector
            if)
        if)
     #)  

-- AggregationConnectorGetValuesFromCode: DoPart --
do
     (#
        description,prefixName: ^Text;
        theListDiagram: ^ListDiagram;
        anAST: ^mps.AST;
        theAttributeDecl: ^betaGram.AttributeDecl;
        theNames: ^betaGram.Names;
        theNameDcl: ^betaGram.NameDcl;
        anExp: ^mps.expanded;
        thePatternDecl: ^betaGram.PatternDecl;
        theObjectDescriptor: ^betaGram.ObjectDescriptor;
        thePrefix: ^betaGram.Prefix;
        theNameApl: ^betaGram.NameApl
     do
        true->doneInInner;
        true->embed;
        ((leftrole->lr[]).thePatternDiagramNode).theDiagram->theListDiagram[];
        (if ((leftrole->lr[]).thePatternDiagramNode)._struc <=
        theListDiagram.SimpleAttributeDecl## then
            ((leftrole->lr[]).thePatternDiagramNode).getASTNode
              ->theAttributeDecl[];
            theAttributeDecl.getSon1->theNames[];
            theNames.getSon1->theNameDcl[];
            theNameDcl.getNameDecl->anAST[];
            (if not (anAST.kind = mps.kinds.unExpanded) then
                theNameDcl.getText->theName[]
            if);
            (if theAttributeDecl## <= betaGram.SimpleDecl## then
                theAttributeDecl.getSon2->anAST[];
                (if anAST.symbol
                 // betaGram.StaticItem then
                    gppProp.byValue->kind;
                    anAST[]->anExp[];
                    anExp.getSon1->anAST[];
                    (if anAST.symbol = betaGram.ObjectDescriptor then
                        anAST[]->theObjectDescriptor[];
                        theObjectDescriptor.getPrefixOpt->anAST[];
                        (if anAST.kind = mps.kinds.interior then
                            anAST[]->thePrefix[];
                            thePrefix.getAttributeDenotation->anAST[];
                            (if anAST.symbol = betaGram.NameApl then
                                anAST[]->theNameApl[];
                                theNameApl.getNameAppl->anAST[];
                                (if anAST.kind <> mps.kinds.unExpanded then
                                    theNameApl.getText->prefixName[];
                                    (if true
                                     // ('arrayContainer'->prefixName.equalNCS)
                                     then
                                        gppProp.arrayContainer->implementation
                                     // ('hashTable'->prefixName.equalNCS) then
                                        gppProp.hashTable->implementation
                                     //
                                     ('extensibleHashTable'
                                        ->prefixName.equalNCS) then
                                        gppProp.extensibleHashTable
                                          ->implementation
                                     // ('List'->prefixName.equalNCS) then
                                        gppProp.List->implementation
                                     // ('Set'->prefixName.equalNCS) then
                                        gppProp.Set->implementation
                                     // ('MultiSet'->prefixName.equalNCS) then
                                        gppProp.MultiSet->implementation
                                     // ('Stack'->prefixName.equalNCS) then
                                        gppProp.Stack->implementation
                                     // ('Queue'->prefixName.equalNCS) then
                                        gppProp.Queue->implementation
                                     // ('PriorityQueue'->prefixName.equalNCS)
                                     then
                                        gppProp.PriorityQueue->implementation
                                    if);
                                    (if implementation <>
                                    gppProp.noImplementation then
                                        gppProp.byReference->kind
                                    if)
                                if);
                                
                            if)
                        if)
                    if)
                 // betaGram.DynamicItem then
                    gppProp.byReference->kind
                 else
                (* code inconsistency - set to default *)
                    gppProp.byReference->kind
                if)
             else
                (if theAttributeDecl## <= betaGram.RepetitionDecl## then
                    gppProp.repetition->implementation;
                    theAttributeDecl.getSon3->anAST[];
                    (if anAST.symbol
                     // betaGram.StaticItem then
                        gppProp.byValue->kind
                     // betaGram.DynamicItem then
                        gppProp.byReference->kind
                     else
                    (* code inconsistency - set to default *)
                        gppProp.byReference->kind
                    if)
                if)
            if)
        if);
        (if switch[54] then
            'AggregationConnector-getValuesFromCode: theName=%s leftRoleName=%s rightRoleName=%s implementation=%i kind=%i\n'
              ->putFormat
                (# 
                do
                   (if theName[] <> none then
                       theName[]->s
                    else
                       'NONE'->s
                   if);
                   (if leftRoleName[] <> none then
                       leftRoleName[]->s
                    else
                       'NONE'->s
                   if);
                   (if rightRoleName[] <> none then
                       rightRoleName[]->s
                    else
                       'NONE'->s
                   if);
                   implementation->i;
                   kind->i
                #)
        if)
     #)  

-- AggregationConnectorRedisplay: DoPart --
do
   thisOp:
     (#
        t,qualification,includeString: ^text;
        anExp: ^mps.expanded;
        anAST,newLeft: ^mps.ast;
        thePatternDiagramNode: ^PatternDiagramNode;
        theListDiagram: ^ListDiagram;
        theSimpleNode: ^theListDiagram.SimpleAttributeDecl;
        parseOK: @boolean;
        errorPos: @integer;
        parseErrorText: ^Text
     do
        kind->private.kind;
        ((leftrole->lr[]).thePatternDiagramNode).getASTNode->anExp[];
        ((rightrole->rr[]).thePatternDiagramNode).getASTNode->anAST[];
        (if not (anAST## <= betaGram.AttributeDecl##) (* it is a title *) then
            anAST[]->patternDiagrams.astUtils.getEnclosingDecl->anAST[]
        if);
        (anExp[],anAST[])->getQualificationWithPath->qualification[];
        (if qualification[] <> none then
            name[]->t[];
            ':'->t.puttext;
            (leftrole->lr[]).thePatternDiagramNode->thePatternDiagramNode[];
            thePatternDiagramNode.theDiagram->theListDiagram[];
            (if implementation
             // gppProp.noImplementation then
                (if kind
                 // gppProp.byValue then
                    '@'->t.puttext
                 // gppProp.byReference then
                    '^'->t.puttext
                 else
                    '^'->t.puttext;
                    'unknown value for kind: %i - choosing default\n'
                      ->stderr.putformat (#  do kind->i #)
                if);
                (if thePatternDiagramNode## <= theListDiagram.RepetitionNode##
                 then
                (* To prevent role from being deleted when RepetitionNode
                 is replaced by SimpleNode *)
                    (leftrole->lr[]).unmakeRegion
                 else
                    none ->thePatternDiagramNode[]
                if);
                qualification[]->t.puttext
             // gppProp.Repetition then
                '['->t.puttext;
                (if rightMulTo > 0 then
                    rightMulTo->t.putint
                 else
                    100->t.putint
                if);
                ']'->t.puttext;
                (if kind
                 // gppProp.byValue then
                    '@'->t.puttext
                 // gppProp.byReference then
                    '^'->t.puttext
                 else
                    '^'->t.puttext;
                    'unknown value for kind: %i - choosing default\n'
                      ->stderr.putformat (#  do kind->i #)
                if);
                qualification[]->t.puttext;
                (if thePatternDiagramNode## <= theListDiagram.SimpleNode## then
                (* To prevent role from being deleted when SimpleNode
                 is replaced by RepetitionNode *)
                    (leftrole->lr[]).unmakeRegion
                 else
                    none ->thePatternDiagramNode[]
                if)
             else
                '@'->t.puttext;
                '~beta/containers/v1.5/'->includeString[];
                (if implementation
                 // gppProp.ArrayContainer then
                    'ArrayContainer'->t.puttext;
                    'arrayContainer'->includeString.puttext
                 // gppProp.HashTable then
                    'HashTable'->t.puttext; 'hashTable'->includeString.puttext
                 // gppProp.ExtensibleHashTable then
                    'ExtensibleHashTable'->t.puttext;
                    'hashTable'->includeString.puttext
                 // gppProp.List then
                    'List'->t.puttext; 'list'->includeString.puttext
                 // gppProp.Set then
                    'Set'->t.puttext; 'sets'->includeString.puttext
                 // gppProp.MultiSet then
                    'MultiSet'->t.puttext; 'sets'->includeString.puttext
                 // gppProp.Stack then
                    'Stack'->t.puttext; 'seqContainers'->includeString.puttext
                 // gppProp.Queue then
                    'Queue'->t.puttext; 'seqContainers'->includeString.puttext
                 // gppProp.PriorityQueue then
                    'PriorityQueue'->t.puttext;
                    'seqContainers'->includeString.puttext
                 else
                    'Set'->t.puttext;
                    'sets'->includeString.puttext;
                    'unknown value for implementation: %i - choosing default\n'
                      ->stderr.putformat (#  do implementation->i #)
                if);
                '(# element::'->t.puttext;
                qualification[]->t.puttext;
                ' #)'->t.puttext;
                (if thePatternDiagramNode## <= theListDiagram.RepetitionNode##
                 then
                (* To prevent role from being deleted when RepetitionNode
                 is replaced by SimpleNode *)
                    (leftrole->lr[]).unmakeRegion
                 else
                    none ->thePatternDiagramNode[]
                if)
            if);
            (anExp[],t)
              ->(((leftrole->lr[]).thePatternDiagramNode).theSifEditor).parse
              ->(parseOK,errorPos,parseErrorText[]);
            (if not parseOK then
                'Internal parse error - should not happen(!):'->stdErr.putline;
                'trying to parse: '->stdErr.putline;
                t[]->stdErr.putline;
                'Error:'->stdErr.putline;
                parseErrorText[]->stdErr.putline;
                'Internal parse error occured - should not happen!'->alertUser;
                leave thisOp
            if);
            (if thePatternDiagramNode[] <> none then
                currentObject->(leftrole->lr[]).thePatternDiagramNode;
                (leftrole->lr[]).thePatternDiagramNode
                  ->(leftrole->lr[]).createRegion;
                (leftrole->lr[]).thePatternDiagramNode->theSimpleNode[];
                THIS(AggregationConnector)[]
                  ->theSimpleNode.theAggregationConnector
            if);
            ((leftrole->lr[]).thePatternDiagramNode).getASTNode->newLeft[];
            (if includeString[] <> none then
                (newLeft.frag.father,'INCLUDE',includeString[])->sifAddProp
            if);
            (anExp[],anAST[],newLeft[],leftMulFrom,leftMulTo,rightMulFrom,
             rightMulTo)->patternDiagrams.AggregationList.updateElement
        if)
     #)  

-- AggregationConnectorOnInit: DoPart --
do
   (if switch[30] or switch[54] then
       'AggregationConnector onInit'->putline
   if);
   UDPrivate.UDAggregationConnector->UserDataInit  

-- AggregationConnectorPrivate: Descriptor --
(# kind: @integer #)  

-- AggregationConnectorDump: DoPart --
do INNER dump  

-- getQualificationWithPath: Descriptor --
(#
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   aDeclAST,nca,ncDecl: ^MPS.AST;
   keepT: ^Text;
   qualSonNo,refSonNo: @integer;
   getSurroundingDecl:
     (# anAST: ^MPS.AST; attDecl: ^betaGram.AttributeDecl
     enter anAST[]
     do
        (if anAST.father
         // none then 
         else
            anAst.father->anAST[];
            (if anAST.symbol
             // BetaGram.PatternDecl // betaGram.VirtualDecl
             // betaGram.BindingDecl // betaGram.FinalDecl
             // betaGram.SimpleDecl then
                anAST[]->attDecl[]
             else
                anAST[]->getSurroundingDecl->attDecl[]
            if)
        if)
     exit attDecl[]
     #)
do
   qual.getSon1->theNames[];
   theNames.getSon1->theNameDcl[];
   theNameDcl.getNameDecl->aDeclAST[];
   (if aDeclAST.kind = mps.kinds.unExpanded then
       '<<NameAppl>>'->t[]->keepT[]
    else
       theNameDcl.getText->t[]->keepT[]
   if);
   (if not (ref[]->qual.equal) then
       (if ref.frag[] = qual.frag[] then
           ref[]->qual.nearestCommonAncestor->(nca[],qualSonNo,refSonNo);
           (if not (nca## <= betaGram.AttributeDecl##) then
               nca[]->getSurroundingDecl->ncDecl[]
           if)
       if);
       (if ncDecl[] = none then
           loop:
             (# 
             do
                qual[]->getSurroundingDecl->qual[];
                (if qual[] <> none then
                    qual.getSon1->theNames[];
                    theNames.getSon1->theNameDcl[];
                    theNameDcl.getNameDecl->aDeclAST[];
                    (if aDeclAST.kind = mps.kinds.unExpanded then
                        '<<NameAppl>>.'->t.prepend
                     else
                        '.'->t.prepend; theNameDcl.getText->t.prepend
                    if);
                    restart loop
                if)
             #)
        else
           (if not (qual[]->ncDecl.equal) then
               qual[]->getSurroundingDecl->qual[];
               (if qual[] <> none then
                   (if not (qual[]->ncDecl.equal) then
                       loop:
                         (# 
                         do
                            qual.getSon1->theNames[];
                            theNames.getSon1->theNameDcl[];
                            theNameDcl.getNameDecl->aDeclAST[];
                            (if aDeclAST.kind = mps.kinds.unExpanded then
                                '<<NameAppl>>.'->t.prepend
                             else
                                '.'->t.prepend; theNameDcl.getText->t.prepend
                            if);
                            qual[]->getSurroundingDecl->qual[];
                            (if qual[] <> none then
                                (if not (qual[]->ncDecl.equal) then
                                    restart loop
                                if)
                             else
                                keepT[]->t[]
                            if)
                         #)
                   if)
                else
                   keepT[]->T[]
               if)
           if)
       if)
   if)
#)  

-- GppOADPagePrivate: Descriptor --
(#  #)  

-- getSynCatNo: DoPart --
do
   (if
   ((node.kind = mps.kinds.unexpanded) or (node.kind = mps.kinds.optional)) then
       node[]->nontNode[]; nontNode.nonterminalSymbol->synCatNo
    else
       node.symbol->synCatNo
   if)  

