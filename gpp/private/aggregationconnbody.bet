ORIGIN 'diagramattributes';
INCLUDE 'associationconnbody';
-- AggregationRoleVisibleSet: DoPart --
do
   (if THIS(Role)[] = leftRole then
       v->borderVisible;
       (if v then
       (* (thePatternDiagramNode).getAstNode->anAST[];
        (if anAST.symbol
        // betaGram.SimpleDecl then
        anAST[]->theSimpleDecl[];
        theSimpleDecl.getReferenceSpecification->anAST[];
        (if anAST.symbol = betaGram.StaticItem then
        (if v then 1->fillType else 0->fillType if)
        if)
        // betaGram.RepetitionDecl then
        anAST[]->theRepetitionDecl[];
        theRepetitionDecl.getReferenceSpecification->anAST[];
        (if anAST.symbol = betaGram.StaticItem then
        (if v then 1->fillType else 0->fillType if)
        if)
        if) *)
           (if private.kind = gppProp.byValue then
               Black->fillType
            else
               (- 1,0,0) (* no fill *) ->fillType
           if)
        else
           (if private.kind = gppProp.byValue then
               (- 1,0,0) (* no fill *) ->fillType
           if)
       if)
   if)  

-- AggregationRoleAttachRightSet: DoPart --
do
   (if THIS(Role)[] = leftRole then
       (if v then
           (x+gppProp.halfDiamondNodeWidth,ry)->center
        else
           (x-gppProp.halfDiamondNodeWidth,ry)->center
       if)
   if)  

-- AggregationRoleDisplay: DoPart --
do
   (if leftRole = none then
       (if switch[53] then
           'AggregationRoleDisplay adjusted center on %s\n (leftRole=none)'
             ->putformat
               (# t: @text
               do
                  (if name <> none then
                      (name).theText.get->t; t[]->s
                   else
                      id->t.putint; t[]->s
                  if)
               #)
       if);
       (x+gppProp.halfDiamondNodeWidth,y)->center;
       true->BorderVisible
   if);
   INNER display  

-- AggregationRoleRedisplay: DoPart --
do
   (if THIS(Role)[] = leftRole then
       (if private.kind = gppProp.byValue then
           Black->fillType; redraw
        else
           (- 1,0,0) (* no fill *) ->fillType; redraw
       if)
   if)  

-- AggregationRoleNew: DoPart --
do
   (if leftRole = none then
       0->p[1];
       - gppProp.halfDiamondNodeHeight->p[2];
       gppProp.halfDiamondNodeWidth->p[3];
       0->p[4];
       0->p[5];
       gppProp.halfDiamondNodeHeight->p[6];
       - gppProp.halfDiamondNodeWidth->p[7];
       0->p[8];
       (for i: p.range repeat p[i]->wcoord->p[i] for);
       (theWorkPage.ID,4,p)->designUtils.createPolygon->onInit;
       (* pahe: @@ p[1] replaced by p *)
       (if private.kind = gppProp.byValue then Black->fillType if);
       (x,y)->center;
       true->doneInInner
   if)  

-- AggregationRoleOnInit: DoPart --
do INNER onInit  

-- AggregationConnectorOnDelete: DoPart --
do INNER onDelete  

-- AggregationConnectorOnReattach: DoPart --
do
   patterndiagrams.AggregationList.find
     (#
        theName,leftRoleName,rightRoleName,description: ^Text;
        kind,implementation: @integer;
        embed: @boolean;
        answer,x,y,w,h: @integer;
        succeded: @boolean;
        node1,node2,dummy: ^DesignObject;
        left,right: ^PatternDiagramNode;
        anAST: ^mps.ast;
        predicate:: 
          (# anAST: ^mps.ast
          do
             ((rightrole->rr[]).thePatternDiagramNode).getASTNode->anAST[];
             (if not
             (anAST## <= betaGram.AttributeDecl##)
             (* in case it was a titlenode *) then
                 anAST[]->patterndiagrams.astUtils.getEnclosingDecl->anAST[]
             if);
             (if switch[54] then
                 'AggregationConnector onReattach - Comparing: %i %i and %i %i\n'
                   ->putformat
                     (# 
                     do
                        current.left->i;
                        (((leftrole->lr[]).thePatternDiagramNode).getASTNode).
                        index->i;
                        current.right->i;
                        anAST.index->i
                     #)
             if);
             (current.left =
              (((leftrole->lr[]).thePatternDiagramNode).getASTNode).index) and
             ((((leftrole->lr[]).thePatternDiagramNode).getASTNode).frag.
                fullname->current.leftFrag.equal) and
             (current.right = anAST.index) and
             (anAST.frag.fullname->current.rightFrag.equal)->value
          #);
        notFound:: 
          (# 
          do
             ('Move Aggregation',
              'The aggregation code has been edited in Sif,\nCheck the program to insure consistency?\n\n- "No" will generate code as consistenly as\npossible with the current code.\n')
               ->promptForBoolean->answer;
             (if answer
              // yes then
                 false->ok;
                 ((leftrole->lr[]).thePatternDiagramNode).getAstNode->anAST[];
                 (if anAST[] <> none then anAST.frag.father->callChecker if)
              // no then
                 getValuesFromCode
                   ->
                     (theName[],leftRoleName[],rightRoleName[],implementation,
                      embed,private.kind);
                 (if whichEnd then
                     theNew[]->BoxToNode->theNew[];
                     (if theNew## <= PatternDiagramNode## then
                         ((leftrole->lr[]).thePatternDiagramNode,theNew[],
                          theName[],implementation,none ,none ,1,1,1,1,true,
                          kind)->generateCode->(succeded,left[],right[]);
                         (if succeded then
                             (1,1,1,1)->whichEndUpdateRoles
                          else
                             false->ok
                         if)
                      else
                         'The relation has been attached to a node that is not part of a pattern diagram'
                           ->AlertUser;
                         false->ok
                     if)
                  else
                     'Moving simpleDecl end of relation not yet implemented'
                       ->AlertUser;
                     false->ok
                 if)
              // cancel then
                 false->ok
             if)
          #);
        whichEndUpdateRoles:
          (# leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer
          enter (leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
          do
             (rightrole->rr[]).unMakeRegion;
             right[]->(rightrole->rr[]).thePatternDiagramNode;
             (none ,leftMulFrom,leftMulTo,
              THIS(associationConnector).private.srolename,
              THIS(associationConnector).private.smul,
              THIS(associationConnector).private.srightside)
               ->(leftrole->lr[]).redisplay;
             (none ,rightMulFrom,rightMulTo,
              THIS(associationConnector).private.drolename,
              THIS(associationConnector).private.dmul,
              THIS(associationConnector).private.drightside)
               ->(rightrole->rr[]).redisplay;
             ((leftrole->lr[]).getTopParent,leftRole,
              (rightrole->rr[]).getTopParent,rightrole->rr[])->setEnds;
             false->ok;
             right.geometry->(x,y,w,h);
             x-w div 2->x;
             (x,y)->(rightrole->rr[]).center;
             right[]->(rightrole->rr[]).createRegion
          #)
     do
        getValuesFromCode
          ->
            (theName[],leftRoleName[],rightRoleName[],implementation,embed,
             kind);
        (if whichEnd then
            theNew[]->BoxToNode->theNew[];
            (if theNew## <= PatternDiagramNode## then
                (if (rightrole->rr[]).thePatternDiagramNode <> theNew[] then
                    ((leftrole->lr[]).thePatternDiagramNode,theNew[],theName[],
                     implementation,none ,none ,current.leftMulFrom,
                     current.leftMulTo,current.rightMulFrom,current.rightMulTo,
                     true,kind)->generateCode->(succeded,left[],right[]);
                    (if succeded then
                        (current.leftMulFrom,current.leftMulTo,
                         current.rightMulFrom,current.rightMulTo)
                          ->whichEndUpdateRoles
                     else
                        false->ok
                    if)
                if)
             else
                'The relation has been attached to a node that is not part of a pattern diagram'
                  ->AlertUser;
                false->ok
            if)
         else
            'Moving simpleDecl end of relation not yet implemented'->AlertUser;
            false->ok
        if)
     #)  

-- AggregationConnectorOnDoubleClick: DoPart --
do INNER OnDoubleClick  

-- AggregationConnectorOnRightMouseDown: DoPart --
do
   (if not private.thePopUp.opened then private.thePopUp.open if);
   (1,mousePos,inWindow[])->private.thePopUp.popUp  

-- AggregationConnectorInterativeNew: DoPart --
do kind->private.kind; INNER InteractiveNew  

-- AggregationConnectorEdit: DoPart --
do
   patterndiagrams.AggregationList.find
     (#
        theName,leftRoleName,rightRoleName,description: ^Text;
        kind,implementation: @integer;
        embed: @boolean;
        predicate:: 
          (# anAST: ^mps.ast
          do
             ((rightrole->rr[]).thePatternDiagramNode).getASTNode->anAST[];
             (if not
             (anAST## <= betaGram.AttributeDecl##)
             (* in case it was a titlenode *) then
                 anAST[]->patterndiagrams.astUtils.getEnclosingDecl->anAST[]
             if);
             (if switch[54] then
                 'AggregationConnector onDoubleClick - Comparing: %i %i and %i %i/n'
                   ->putformat
                     (# 
                     do
                        current.left->i;
                        (((leftrole->lr[]).thePatternDiagramNode).getASTNode).
                        index->i;
                        current.right->i;
                        anAST.index->i
                     #)
             if);
             (current.left =
              (((leftrole->lr[]).thePatternDiagramNode).getASTNode).index) and
             ((((leftrole->lr[]).thePatternDiagramNode).getASTNode).frag.
                fullname->current.leftFrag.equal) and
             (current.right = anAST.index) and
             (anAST.frag.fullname->current.rightFrag.equal)->value
          #);
        notFound:: 
          (# ok: @integer; anAST: ^mps.ast
          do
             ('Aggregation Doubleclick',
              'The aggregation code has been edited in Sif,\nCheck the program to insure consistency?\n- "No" will launch the aggregation dialog\nwith settings that are as consistent as\npossible with the code.\n')
               ->promptForBoolean->ok;
             (if ok
              // yes then
                 ((leftrole->lr[]).thePatternDiagramNode).getAstNode->anAST[];
                 (if anAST[] <> none then anAST.frag.father->callChecker if)
              // no then
                 getValuesFromCode
                   ->
                     (theName[],leftRoleName[],rightRoleName[],implementation,
                      embed,kind);
                 (THIS(AggregationConnector)[],theName[],kind,implementation,1,
                  1,1,1,description[])->openAggregationDialog
              // cancel then
                 
             if)
          #)
     do
        getValuesFromCode
          ->
            (theName[],leftRoleName[],rightRoleName[],implementation,embed,
             kind);
        (THIS(AggregationConnector)[],theName[],kind,implementation,
         current.leftMulFrom,current.leftMulTo,current.rightMulFrom,
         current.rightMulTo,description[])->openAggregationDialog
     #)  

-- AggregationConnectorGenerateCode: DoPart --
do
   thisOp:
     (#
        theNode,dummyNode: ^node;
        t,qualification,includeString: ^text;
        theListDiagram,theOtherListDiagram, ldiag: ^ListDiagram;
        theOtherOADDiagram: ^OADDiagram;
        aDiagramNode: ^theOtherListDiagram.DiagramNode;
        aSimpleNode: ^theListDiagram.SimpleAttributeDecl;
        aNonTerminalNode: ^theListDiagram.NonTerminalNode;
        titleText: @text;
        anAST,aDeclAST,rightAst: ^MPS.AST;
        theDesc: ^betaGram.ObjectDescriptor;
        anExp,anotherExp: ^mps.expanded;
        theNames: ^betaGram.Names;
        theNameDcl: ^betaGram.NameDcl;
        theAttrDecl: ^betaGram.AttributeDecl;
        regions,existingConnectors: ^ObjectList;
        theCon: ^Connector;
        theAggrCon: ^AggregationConnector;
        x,y,w,h: @integer;
        optionalsInserted: @boolean;
        parseOK: @boolean;
        errorPos: @integer;
        parseErrorText: ^Text
     do
        true->doneInInner;
        anotherPatternDiagramNode.theDiagram -> ldiag[];
        (if ldiag## <= PatternAttDiagram## then
            'You cannot aggregate to a lib-diagram'->alertUser;
            false->ok; leave thisOp;
        if);
        (if (aPatternDiagramNode.theSifEditor).isReadOnly then
            (aPatternDiagramNode.theDiagram).titleText[]->t[];
            ' is read-only - can not generate code for aggregation'->t.puttext;
            t[]->alertUser;
            false->ok
         else
            (if kind = 0 then private.kind->kind if);
            aPatternDiagramNode.theDiagram->theListDiagram[];
            'DONE: aPatternDiagramNode.theDiagram->theListDiagram[];'->putline;
            (if aPatternDiagramNode## <= theListDiagram.NonTerminalNode## then
                aPatternDiagramNode[]->aNonTerminalNode[]; theName.copy->t[]
             else
                (if aPatternDiagramNode## <=
                theListDiagram.SimpleAttributeDecl## then
                    aPatternDiagramNode[]->aSimpleNode[];
                    aPatternDiagramNode.getASTNode->anExp[];
                    (* If no name was specified
                     check if simpleDecl already
                     has name and use that if so *)
                    (if '<<NameDecl>>'->theName.equal then
                        anExp.getSon1->theNames[];
                        theNames.getSon1->theNameDcl[];
                        theNameDcl.getNameDecl->anAST[];
                        (if anAST.kind = mps.kinds.unExpanded then
                            theName.copy->t[]
                         else
                            theNameDcl.getText->t[]
                        if)
                     else
                        theName.copy->t[]
                    if)
                 else
                    currentFocus[]->oldFocus[];
                    (if theListDiagram.localNodes.empty then
                        theListDiagram.titleNode[]->currentFocus[]
                          ->currentObject;
                        theListDiagram.titleNode.getASTNode->anAST[];
                        (if anAST[] <> none then
                            (anAST[],1)
                              ->
                                (theListDiagram.titleNode.theSifEditor).
                                changeFocus
                        if);
                        (theListDiagram.titleNode.theSifEditor).insertOptionals;
                        true->optionalsInserted;
                        (theListDiagram.localNodes.last).elm[]
                          ->aNonTerminalNode[];
                        currentFocus[]->oldFocus[];
                        aNonTerminalNode[]->currentFocus[]->currentObject;
                        (aNonTerminalNode.unExp[],1)
                          ->(theListDiagram.titleNode.theSifEditor).changeFocus
                     else
                        (if (theListDiagram.localNodes.last).elm## <=
                        theListDiagram.NonTerminalNode## then
                            (theListDiagram.localNodes.last).elm[]
                              ->aNonTerminalNode[];
                            aNonTerminalNode.unExp[]->anAST[]
                         else
                            (theListDiagram.localNodes.last).elm.getASTNode
                              ->anAST[]
                        if);
                        (theListDiagram.localNodes.last).elm[]->currentFocus[]
                          ->currentObject;
                        (anAST[],1)
                          ->(theListDiagram.titleNode.theSifEditor).changeFocus;
                        (theListDiagram.titleNode.theSifEditor).after
                    if);
                    currentObject->aNonTerminalNode[];
                    theName.copy->t[]
                if)
            if);
            anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
            (if anotherPatternDiagramNode## <= theOtherListDiagram.title## then
                theOtherListDiagram[]->theOtherOADDiagram[];
                theOtherOADDiagram.theDescriptor[]->theDesc[];
                theDesc.father->anotherExp[];
                (if anotherExp## <= betaGram.AttributeDecl## then
                    (if aNonTerminalNode[] <> none then
                        (aNonTerminalNode.unExp[],anotherExp[])
                          ->getQualificationWithPath->qualification[]
                     else
                        (anExp[],anotherExp[])->getQualificationWithPath
                          ->qualification[]
                    if);
                    (if theListDiagram[] = theOtherListDiagram[] then
                        Delete
                    if)
                 else
                    false->ok; 'Destination is singularly defined'->AlertUser
                if)
             else
                (if
                (anotherPatternDiagramNode## <=
                 theOtherListDiagram.PatternNode##) or
                (anotherPatternDiagramNode## <=
                 theOtherListDiagram.VirtualNode##) or
                (anotherPatternDiagramNode## <=
                 theOtherListDiagram.BindingNode##) or
                (anotherPatternDiagramNode## <= theOtherListDiagram.FinalNode##)
                 then
                    anotherPatternDiagramNode[]->aDiagramNode[];
                    aDiagramNode.theDeclaration[]->theAttrDecl[];
                    (if aNonTerminalNode[] <> none then
                        (aNonTerminalNode.unExp[],theAttrDecl[])
                          ->getQualificationWithPath->qualification[]
                     else
                        (anExp[],theAttrDecl[])->getQualificationWithPath
                          ->qualification[]
                    if)
                 else
                    false->ok;
                    'The destination is not a pattern, virtual, binding or final declaration'
                      ->AlertUser
                if)
            if);
            (if qualification[] <> none then
                ':'->t.puttext;
                (if implementation
                 // gppProp.noImplementation then
                    (if kind
                     // gppProp.byValue then
                        '@'->t.puttext
                     // gppProp.byReference then
                        '^'->t.puttext
                     else
                        '^'->t.puttext;
                        'unknown value for kind: %i - choosing default\n'
                          ->stderr.putformat (#  do kind->i #)
                    if);
                    qualification[]->t.puttext
                 // gppProp.Repetition then
                    '['->t.puttext;
                    (if rightMulTo > 0 then
                        rightMulTo->t.putint
                     else
                        100->t.putint
                    if);
                    ']'->t.puttext;
                    (if kind
                     // gppProp.byValue then
                        '@'->t.puttext
                     // gppProp.byReference then
                        '^'->t.puttext
                     else
                        '^'->t.puttext;
                        'unknown value for kind: %i - choosing default\n'
                          ->stderr.putformat (#  do kind->i #)
                    if);
                    qualification[]->t.puttext
                 else
                    '@'->t.puttext;
                    '~beta/containers/'->includeString[];
                    (if implementation
                     // gppProp.ArrayContainer then
                        'ArrayContainer'->t.puttext;
                        'arrayContainer'->includeString.puttext
                     // gppProp.HashTable then
                        'HashTable'->t.puttext;
                        'hashTable'->includeString.puttext
                     // gppProp.ExtensibleHashTable then
                        'ExtensibleHashTable'->t.puttext;
                        'hashTable'->includeString.puttext
                     // gppProp.List then
                        'List'->t.puttext; 'list'->includeString.puttext
                     // gppProp.Set then
                        'Set'->t.puttext; 'sets'->includeString.puttext
                     // gppProp.MultiSet then
                        'MultiSet'->t.puttext; 'sets'->includeString.puttext
                     // gppProp.Stack then
                        'Stack'->t.puttext;
                        'seqContainers'->includeString.puttext
                     // gppProp.Queue then
                        'Queue'->t.puttext;
                        'seqContainers'->includeString.puttext
                     // gppProp.PriorityQueue then
                        'PriorityQueue'->t.puttext;
                        'seqContainers'->includeString.puttext
                     else
                        'Set'->t.puttext;
                        'sets'->includeString.puttext;
                        'unknown value for implementation: %i - choosing default\n'
                          ->stderr.putformat (#  do implementation->i #)
                    if);
                    '(# element::'->t.puttext;
                    qualification[]->t.puttext;
                    ' #)'->t.puttext
                if);
                &Node[]->dummyNode[];
                (0,0,0,0)->dummyNode.new;
                (dummyNode.getTopParent,dummyNode[],
                 theOtherListDiagram.titleNode.getTopParent,
                 theOtherListDiagram.titleNode[])->setEnds;
                (if aNonTerminalNode[] <> none then
                    (aNonTerminalNode.unExp[],t)
                      ->(aNonTerminalNode.theSifEditor).parse
                      ->(parseOK,errorPos,parseErrorText[]);
                    (if not parseOK then
                        false->ok;
                        'Internal parse error - should not happen(!):'
                          ->stdErr.putline;
                        'trying to parse: '->stdErr.putline;
                        t[]->stdErr.putline;
                        'Error:'->stdErr.putline;
                        parseErrorText[]->stdErr.putline;
                        'Internal parse error occured - should not happen!'
                          ->alertUser;
                        leave thisOp
                    if);
                    currentObject->aSimpleNode[];
                    (if optionalsInserted then
                        (if anAST[] <> none then
                            (anAST[],1)
                              ->
                                (theListDiagram.titleNode.theSifEditor).
                                changeFocus
                        if);
                        (theListDiagram.titleNode.theSifEditor).removeOptionals
                    if)
                 else
                    (if (aSimpleNode.theAggregationConnector <> none ) and
                    (aSimpleNode.theAggregationConnector <> THIS(
                     AggregationConnector)[]) then
                        aSimpleNode.theAggregationConnector->theAggrCon[];
                        theAggrCon.leftRole->theNode[];
                        theAggrCon.rightRole->dummyNode[];
                        theAggrCon.delete;
                        theNode.delete;
                        dummyNode.delete
                    if);
                    (anExp[],t)->(aSimpleNode.theSifEditor).parse
                      ->(parseOK,errorPos,parseErrorText[]);
                    (if not parseOK then
                        false->ok;
                        'Internal parse error - should not happen(!):'
                          ->stdErr.putline;
                        'trying to parse: '->stdErr.putline;
                        t[]->stdErr.putline;
                        'Error:'->stdErr.putline;
                        parseErrorText[]->stdErr.putline;
                        'Internal parse error occured - should not happen!'
                          ->alertUser;
                        leave thisOp
                    if);
                    (* if simpleNode is replaced by repetitionNode
                     or vice-versa aSimpleNode has to be set *)
                    currentObject->aSimpleNode[]
                if);
                (if includeString[] <> none then
                    (aSimpleNode.theDeclaration.frag.father,'INCLUDE',
                     includeString[])->sifAddProp
                if);
                (if aDiagramNode[] <> none then
                    (if aDiagramNode.currentDecomposDiagram <> none then
                        aSimpleNode[]->left[];
                        (aDiagramNode.currentDecomposDiagram).titleNode[]
                          ->right[]
                     else
                        aSimpleNode[]->left[]; aDiagramNode[]->right[]
                    if)
                 else
                    aSimpleNode[]->left[];
                    theOtherListDiagram.titleNode[]->right[]
                if)
            if);
            (if ok (*A connector was created*) then
                right.getAstNode->rightAst[];
                (if not (rightAst## <= betaGram.AttributeDecl##) then
                    rightAst[]->patterndiagrams.astUtils.getEnclosingDecl
                      ->rightAst[]
                if);
                (aSimpleNode.theDeclaration[],rightAst[],leftMulFrom,leftMulTo,
                 rightMulFrom,rightMulTo)
                  ->patterndiagrams.AggregationList.insert;
                THIS(AggregationConnector)[]
                  ->aSimpleNode.theAggregationConnector
            if)
        if)
     #)  

-- AggregationConnectorGetValuesFromCode: DoPart --
do
     (#
        description,prefixName: ^Text;
        theListDiagram: ^ListDiagram;
        anAST: ^mps.AST;
        theAttributeDecl: ^betaGram.AttributeDecl;
        theNames: ^betaGram.Names;
        theNameDcl: ^betaGram.NameDcl;
        anExp: ^mps.expanded;
        thePatternDecl: ^betaGram.PatternDecl;
        theObjectDescriptor: ^betaGram.ObjectDescriptor;
        thePrefix: ^betaGram.Prefix;
        theNameApl: ^betaGram.NameApl
     do
        true->doneInInner;
        true->embed;
        ((leftrole->lr[]).thePatternDiagramNode).theDiagram->theListDiagram[];
        (if ((leftrole->lr[]).thePatternDiagramNode)._struc <=
        theListDiagram.SimpleAttributeDecl## then
            ((leftrole->lr[]).thePatternDiagramNode).getASTNode
              ->theAttributeDecl[];
            theAttributeDecl.getSon1->theNames[];
            theNames.getSon1->theNameDcl[];
            theNameDcl.getNameDecl->anAST[];
            (if not (anAST.kind = mps.kinds.unExpanded) then
                theNameDcl.getText->theName[]
            if);
            (if theAttributeDecl## <= betaGram.SimpleDecl## then
                theAttributeDecl.getSon2->anAST[];
                (if anAST.symbol
                 // betaGram.StaticItem then
                    gppProp.byValue->kind;
                    anAST[]->anExp[];
                    anExp.getSon1->anAST[];
                    (if anAST.symbol = betaGram.ObjectDescriptor then
                        anAST[]->theObjectDescriptor[];
                        theObjectDescriptor.getPrefixOpt->anAST[];
                        (if anAST.kind = mps.kinds.interior then
                            anAST[]->thePrefix[];
                            thePrefix.getAttributeDenotation->anAST[];
                            (if anAST.symbol = betaGram.NameApl then
                                anAST[]->theNameApl[];
                                theNameApl.getNameAppl->anAST[];
                                (if anAST.kind <> mps.kinds.unExpanded then
                                    theNameApl.getText->prefixName[];
                                    (if true
                                     // ('arrayContainer'->prefixName.equalNCS)
                                     then
                                        gppProp.arrayContainer->implementation
                                     // ('hashTable'->prefixName.equalNCS) then
                                        gppProp.hashTable->implementation
                                     //
                                     ('extensibleHashTable'
                                        ->prefixName.equalNCS) then
                                        gppProp.extensibleHashTable
                                          ->implementation
                                     // ('List'->prefixName.equalNCS) then
                                        gppProp.List->implementation
                                     // ('Set'->prefixName.equalNCS) then
                                        gppProp.Set->implementation
                                     // ('MultiSet'->prefixName.equalNCS) then
                                        gppProp.MultiSet->implementation
                                     // ('Stack'->prefixName.equalNCS) then
                                        gppProp.Stack->implementation
                                     // ('Queue'->prefixName.equalNCS) then
                                        gppProp.Queue->implementation
                                     // ('PriorityQueue'->prefixName.equalNCS)
                                     then
                                        gppProp.PriorityQueue->implementation
                                    if);
                                    (if implementation <>
                                    gppProp.noImplementation then
                                        gppProp.byReference->kind
                                    if)
                                if);
                                
                            if)
                        if)
                    if)
                 // betaGram.DynamicItem then
                    gppProp.byReference->kind
                 else
                (* code inconsistency - set to default *)
                    gppProp.byReference->kind
                if)
             else
                (if theAttributeDecl## <= betaGram.RepetitionDecl## then
                    gppProp.repetition->implementation;
                    theAttributeDecl.getSon3->anAST[];
                    (if anAST.symbol
                     // betaGram.StaticItem then
                        gppProp.byValue->kind
                     // betaGram.DynamicItem then
                        gppProp.byReference->kind
                     else
                    (* code inconsistency - set to default *)
                        gppProp.byReference->kind
                    if)
                if)
            if)
        if);
        (if switch[54] then
            'AggregationConnector-getValuesFromCode: theName=%s leftRoleName=%s rightRoleName=%s implementation=%i kind=%i\n'
              ->putFormat
                (# 
                do
                   (if theName[] <> none then
                       theName[]->s
                    else
                       'NONE'->s
                   if);
                   (if leftRoleName[] <> none then
                       leftRoleName[]->s
                    else
                       'NONE'->s
                   if);
                   (if rightRoleName[] <> none then
                       rightRoleName[]->s
                    else
                       'NONE'->s
                   if);
                   implementation->i;
                   kind->i
                #)
        if)
     #)  

-- AggregationConnectorDisplay: DoPart --
do kind->private.kind; private.thePopup.open  

-- AggregationConnectorRedisplay: DoPart --
do
   (if codeChanged then
       thisOp:
         (#
            t,qualification,includeString: ^text;
            anExp: ^mps.expanded;
            anAST,newLeft: ^mps.ast;
            thePatternDiagramNode: ^PatternDiagramNode;
            theListDiagram: ^ListDiagram;
            theSimpleNode: ^theListDiagram.SimpleAttributeDecl;
            parseOK: @boolean;
            errorPos: @integer;
            parseErrorText: ^Text
         do
            kind->private.kind;
            ((leftrole->lr[]).thePatternDiagramNode).getASTNode->anExp[];
            ((rightrole->rr[]).thePatternDiagramNode).getASTNode->anAST[];
            (if not (anAST## <= betaGram.AttributeDecl##) (* it is a title *)
             then
                anAST[]->patterndiagrams.astUtils.getEnclosingDecl->anAST[]
            if);
            (anExp[],anAST[])->getQualificationWithPath->qualification[];
            (if qualification[] <> none then
                name[]->t[];
                ':'->t.puttext;
                (leftrole->lr[]).thePatternDiagramNode->thePatternDiagramNode[];
                thePatternDiagramNode.theDiagram->theListDiagram[];
                (if implementation
                 // gppProp.noImplementation then
                    (if kind
                     // gppProp.byValue then
                        '@'->t.puttext
                     // gppProp.byReference then
                        '^'->t.puttext
                     else
                        '^'->t.puttext;
                        'unknown value for kind: %i - choosing default\n'
                          ->stderr.putformat (#  do kind->i #)
                    if);
                    (if thePatternDiagramNode## <=
                    theListDiagram.RepetitionNode## then
                    (* To prevent role from being deleted when RepetitionNode
                     is replaced by SimpleNode *)
                        (leftrole->lr[]).unmakeRegion
                     else
                        none ->thePatternDiagramNode[]
                    if);
                    qualification[]->t.puttext
                 // gppProp.Repetition then
                    '['->t.puttext;
                    (if rightMulTo > 0 then
                        rightMulTo->t.putint
                     else
                        100->t.putint
                    if);
                    ']'->t.puttext;
                    (if kind
                     // gppProp.byValue then
                        '@'->t.puttext
                     // gppProp.byReference then
                        '^'->t.puttext
                     else
                        '^'->t.puttext;
                        'unknown value for kind: %i - choosing default\n'
                          ->stderr.putformat (#  do kind->i #)
                    if);
                    qualification[]->t.puttext;
                    (if thePatternDiagramNode## <= theListDiagram.SimpleNode##
                     then
                    (* To prevent role from being deleted when SimpleNode
                     is replaced by RepetitionNode *)
                        (leftrole->lr[]).unmakeRegion
                     else
                        none ->thePatternDiagramNode[]
                    if)
                 else
                    '@'->t.puttext;
                    '~beta/containers/'->includeString[];
                    (if implementation
                     // gppProp.ArrayContainer then
                        'ArrayContainer'->t.puttext;
                        'arrayContainer'->includeString.puttext
                     // gppProp.HashTable then
                        'HashTable'->t.puttext;
                        'hashTable'->includeString.puttext
                     // gppProp.ExtensibleHashTable then
                        'ExtensibleHashTable'->t.puttext;
                        'hashTable'->includeString.puttext
                     // gppProp.List then
                        'List'->t.puttext; 'list'->includeString.puttext
                     // gppProp.Set then
                        'Set'->t.puttext; 'sets'->includeString.puttext
                     // gppProp.MultiSet then
                        'MultiSet'->t.puttext; 'sets'->includeString.puttext
                     // gppProp.Stack then
                        'Stack'->t.puttext;
                        'seqContainers'->includeString.puttext
                     // gppProp.Queue then
                        'Queue'->t.puttext;
                        'seqContainers'->includeString.puttext
                     // gppProp.PriorityQueue then
                        'PriorityQueue'->t.puttext;
                        'seqContainers'->includeString.puttext
                     else
                        'Set'->t.puttext;
                        'sets'->includeString.puttext;
                        'unknown value for implementation: %i - choosing default\n'
                          ->stderr.putformat (#  do implementation->i #)
                    if);
                    '(# element::'->t.puttext;
                    qualification[]->t.puttext;
                    ' #)'->t.puttext;
                    (if thePatternDiagramNode## <=
                    theListDiagram.RepetitionNode## then
                    (* To prevent role from being deleted when RepetitionNode
                     is replaced by SimpleNode *)
                        (leftrole->lr[]).unmakeRegion
                     else
                        none ->thePatternDiagramNode[]
                    if)
                if);
                (anExp[],t)
                  ->
                    (((leftrole->lr[]).thePatternDiagramNode).theSifEditor).
                    parse->(parseOK,errorPos,parseErrorText[]);
                (if not parseOK then
                    'Internal parse error - should not happen(!):'
                      ->stdErr.putline;
                    'trying to parse: '->stdErr.putline;
                    t[]->stdErr.putline;
                    'Error:'->stdErr.putline;
                    parseErrorText[]->stdErr.putline;
                    'Internal parse error occured - should not happen!'
                      ->alertUser;
                    leave thisOp
                if);
                (if thePatternDiagramNode[] <> none then
                    currentObject->(leftrole->lr[]).thePatternDiagramNode;
                    (leftrole->lr[]).thePatternDiagramNode
                      ->(leftrole->lr[]).createRegion;
                    (leftrole->lr[]).thePatternDiagramNode->theSimpleNode[];
                    THIS(AggregationConnector)[]
                      ->theSimpleNode.theAggregationConnector
                if);
                ((leftrole->lr[]).thePatternDiagramNode).getASTNode->newLeft[];
                (if includeString[] <> none then
                    (newLeft.frag.father,'INCLUDE',includeString[])->sifAddProp
                if);
                (anExp[],anAST[],newLeft[],leftMulFrom,leftMulTo,rightMulFrom,
                 rightMulTo)->patterndiagrams.AggregationList.updateElement
            if)
         #)
   if)  

-- AggregationConnectorOnInit: DoPart --
do
   (if switch[30] or switch[54] then
       'AggregationConnector onInit'->putline
   if);
   UDPrivate.UDAggregationConnector->UserDataInit  

-- AggregationConnectorPrivate: Descriptor --
(#
   kind: @integer;
   thePopUp: @theUI.menu
     (#
        opened: @boolean;
        editItem: @menuItem
          (# eventHandler::  (# onSelect::  (#  do edit #);  #); 
          #);
        sep1: @separator;
        hideItem: @menuItem
          (#
             eventHandler:: 
               (#
                  onSelect:: 
                    (# 
                    do
                       (false,THIS(AssociationConnector).private.name[],
                        THIS(AssociationConnector).private.implementation,
                        THIS(AssociationConnector).private.leftRoleName[],
                        THIS(AssociationConnector).private.rightRoleName[],
                        THIS(AssociationConnector).private.leftMulFrom,
                        THIS(AssociationConnector).private.leftMulTo,
                        THIS(AssociationConnector).private.rightMulFrom,
                        THIS(AssociationConnector).private.rightMulTo,
                        THIS(AssociationConnector).private.embed,
                        THIS(AssociationConnector).private.description[],
                        false->THIS(AssociationConnector).private.isVisible,
                        THIS(AssociationConnector).private.vname,
                        THIS(AssociationConnector).private.srolename,
                        THIS(AssociationConnector).private.smul,
                        THIS(AssociationConnector).private.srightside,
                        THIS(AssociationConnector).private.drolename,
                        THIS(AssociationConnector).private.dmul,
                        THIS(AssociationConnector).private.drightside,kind)
                         ->Redisplay
                    #);
                  
               #);
             
          #);
        nameItem: @menuItem
          (#
             eventHandler:: 
               (#
                  onStatus:: 
                    (# 
                    do
                       THIS(AssociationConnector).private.vname->checked;
                       THIS(AssociationConnector).name <> none ->value
                    #);
                  onSelect:: 
                    (# 
                    do
                       (false,THIS(AssociationConnector).private.name[],
                        THIS(AssociationConnector).private.implementation,
                        THIS(AssociationConnector).private.leftRoleName[],
                        THIS(AssociationConnector).private.rightRoleName[],
                        THIS(AssociationConnector).private.leftMulFrom,
                        THIS(AssociationConnector).private.leftMulTo,
                        THIS(AssociationConnector).private.rightMulFrom,
                        THIS(AssociationConnector).private.rightMulTo,
                        THIS(AssociationConnector).private.embed,
                        THIS(AssociationConnector).private.description[],true,
                        not checked->THIS(AssociationConnector).private.vname,
                        THIS(AssociationConnector).private.srolename,
                        THIS(AssociationConnector).private.smul,
                        THIS(AssociationConnector).private.srightside,
                        THIS(AssociationConnector).private.drolename,
                        THIS(AssociationConnector).private.dmul,
                        THIS(AssociationConnector).private.drightside,kind)
                         ->Redisplay
                    #);
                  
               #);
             
          #);
        leftRoleNameItem: @menuItem
          (#
             eventHandler:: 
               (#
                  onStatus:: 
                    (# t: ^text
                    do
                       (((leftRole->lr[]).thePatternDiagramNode).theDiagram).
                       titletext.copy->t[];
                       ' Role'->t.append;
                       t[]->name;
                       THIS(AssociationConnector).private.srolename->checked;
                       (rightRole->rr[]).name <> none ->value
                    #);
                  onSelect:: 
                    (# 
                    do
                       (false,THIS(AssociationConnector).private.name[],
                        THIS(AssociationConnector).private.implementation,
                        THIS(AssociationConnector).private.leftRoleName[],
                        THIS(AssociationConnector).private.rightRoleName[],
                        THIS(AssociationConnector).private.leftMulFrom,
                        THIS(AssociationConnector).private.leftMulTo,
                        THIS(AssociationConnector).private.rightMulFrom,
                        THIS(AssociationConnector).private.rightMulTo,
                        THIS(AssociationConnector).private.embed,
                        THIS(AssociationConnector).private.description[],true,
                        THIS(AssociationConnector).private.vname,
                        not checked
                          ->THIS(AssociationConnector).private.srolename,
                        THIS(AssociationConnector).private.smul,
                        THIS(AssociationConnector).private.srightside,
                        THIS(AssociationConnector).private.drolename,
                        THIS(AssociationConnector).private.dmul,
                        THIS(AssociationConnector).private.drightside,kind)
                         ->Redisplay
                    #);
                  
               #);
             
          #);
        rightRoleNameItem: @menuItem
          (#
             eventHandler:: 
               (#
                  onStatus:: 
                    (# t: ^text
                    do
                       (((rightRole->rr[]).thePatternDiagramNode).theDiagram).
                       titletext.copy->t[];
                       ' Role'->t.append;
                       t[]->name;
                       THIS(AssociationConnector).private.drolename->checked;
                       (rightRole->rr[]).name <> none ->value
                    #);
                  onSelect:: 
                    (# 
                    do
                       (false,THIS(AssociationConnector).private.name[],
                        THIS(AssociationConnector).private.implementation,
                        THIS(AssociationConnector).private.leftRoleName[],
                        THIS(AssociationConnector).private.rightRoleName[],
                        THIS(AssociationConnector).private.leftMulFrom,
                        THIS(AssociationConnector).private.leftMulTo,
                        THIS(AssociationConnector).private.rightMulFrom,
                        THIS(AssociationConnector).private.rightMulTo,
                        THIS(AssociationConnector).private.embed,
                        THIS(AssociationConnector).private.description[],true,
                        THIS(AssociationConnector).private.vname,
                        THIS(AssociationConnector).private.srolename,
                        THIS(AssociationConnector).private.smul,
                        THIS(AssociationConnector).private.srightside,
                        not checked
                          ->THIS(AssociationConnector).private.drolename,
                        THIS(AssociationConnector).private.dmul,
                        THIS(AssociationConnector).private.drightside,kind)
                         ->Redisplay
                    #);
                  
               #);
             
          #);
        leftMulItem: @menuItem
          (#
             eventHandler:: 
               (#
                  onStatus:: 
                    (# t: ^text
                    do
                       (((leftRole->lr[]).thePatternDiagramNode).theDiagram).
                       titletext.copy->t[];
                       ' Role Multiplicity'->t.append;
                       t[]->name;
                       THIS(AssociationConnector).private.smul->checked
                    #);
                  onSelect:: 
                    (# 
                    do
                       (false,THIS(AssociationConnector).private.name[],
                        THIS(AssociationConnector).private.implementation,
                        THIS(AssociationConnector).private.leftRoleName[],
                        THIS(AssociationConnector).private.rightRoleName[],
                        THIS(AssociationConnector).private.leftMulFrom,
                        THIS(AssociationConnector).private.leftMulTo,
                        THIS(AssociationConnector).private.rightMulFrom,
                        THIS(AssociationConnector).private.rightMulTo,
                        THIS(AssociationConnector).private.embed,
                        THIS(AssociationConnector).private.description[],true,
                        THIS(AssociationConnector).private.vname,
                        THIS(AssociationConnector).private.srolename,
                        not checked->THIS(AssociationConnector).private.smul,
                        THIS(AssociationConnector).private.srightside,
                        THIS(AssociationConnector).private.drolename,
                        THIS(AssociationConnector).private.dmul,
                        THIS(AssociationConnector).private.drightside,kind)
                         ->Redisplay
                    #);
                  
               #);
             
          #);
        rightMulItem: @menuItem
          (#
             eventHandler:: 
               (#
                  onStatus:: 
                    (# t: ^text
                    do
                       (((rightRole->rr[]).thePatternDiagramNode).theDiagram).
                       titletext.copy->t[];
                       ' Role Multiplicity'->t.append;
                       t[]->name;
                       THIS(AssociationConnector).private.dmul->checked
                    #);
                  onSelect:: 
                    (# 
                    do
                       (false,THIS(AssociationConnector).private.name[],
                        THIS(AssociationConnector).private.implementation,
                        THIS(AssociationConnector).private.leftRoleName[],
                        THIS(AssociationConnector).private.rightRoleName[],
                        THIS(AssociationConnector).private.leftMulFrom,
                        THIS(AssociationConnector).private.leftMulTo,
                        THIS(AssociationConnector).private.rightMulFrom,
                        THIS(AssociationConnector).private.rightMulTo,
                        THIS(AssociationConnector).private.embed,
                        THIS(AssociationConnector).private.description[],true,
                        THIS(AssociationConnector).private.vname,
                        THIS(AssociationConnector).private.srolename,
                        THIS(AssociationConnector).private.smul,
                        THIS(AssociationConnector).private.srightside,
                        THIS(AssociationConnector).private.drolename,
                        not checked->THIS(AssociationConnector).private.dmul,
                        THIS(AssociationConnector).private.drightside,kind)
                         ->Redisplay
                    #);
                  
               #);
             
          #);
        sep2: @separator;
        leftAttachItem: @menuItem
          (#
             eventHandler:: 
               (#
                  onStatus:: 
                    (# t: ^text
                    do
                       'Attach '->t[];
                       (((leftRole->lr[]).thePatternDiagramNode).theDiagram).
                       titletext[]->t.append;
                       ' Role Right'->t.append;
                       t[]->name;
                       THIS(AssociationConnector).private.srightside->checked
                    #);
                  onSelect:: 
                    (# 
                    do
                       (false,THIS(AssociationConnector).private.name[],
                        THIS(AssociationConnector).private.implementation,
                        THIS(AssociationConnector).private.leftRoleName[],
                        THIS(AssociationConnector).private.rightRoleName[],
                        THIS(AssociationConnector).private.leftMulFrom,
                        THIS(AssociationConnector).private.leftMulTo,
                        THIS(AssociationConnector).private.rightMulFrom,
                        THIS(AssociationConnector).private.rightMulTo,
                        THIS(AssociationConnector).private.embed,
                        THIS(AssociationConnector).private.description[],true,
                        THIS(AssociationConnector).private.vname,
                        THIS(AssociationConnector).private.srolename,
                        THIS(AssociationConnector).private.smul,
                        not checked
                          ->THIS(AssociationConnector).private.srightside,
                        THIS(AssociationConnector).private.drolename,
                        THIS(AssociationConnector).private.dmul,
                        THIS(AssociationConnector).private.drightside,kind)
                         ->Redisplay
                    #);
                  
               #);
             
          #);
        rightAttachItem: @menuItem
          (#
             eventHandler:: 
               (#
                  onStatus:: 
                    (# t: ^text
                    do
                       'Attach '->t[];
                       (((rightRole->rr[]).thePatternDiagramNode).theDiagram).
                       titletext[]->t.append;
                       ' Role Left'->t.append;
                       t[]->name;
                       not THIS(AssociationConnector).private.drightside
                         ->checked
                    #);
                  onSelect:: 
                    (# 
                    do
                       (false,THIS(AssociationConnector).private.name[],
                        THIS(AssociationConnector).private.implementation,
                        THIS(AssociationConnector).private.leftRoleName[],
                        THIS(AssociationConnector).private.rightRoleName[],
                        THIS(AssociationConnector).private.leftMulFrom,
                        THIS(AssociationConnector).private.leftMulTo,
                        THIS(AssociationConnector).private.rightMulFrom,
                        THIS(AssociationConnector).private.rightMulTo,
                        THIS(AssociationConnector).private.embed,
                        THIS(AssociationConnector).private.description[],true,
                        THIS(AssociationConnector).private.vname,
                        THIS(AssociationConnector).private.srolename,
                        THIS(AssociationConnector).private.smul,
                        THIS(AssociationConnector).private.srightside,
                        THIS(AssociationConnector).private.drolename,
                        THIS(AssociationConnector).private.dmul,
                        checked->THIS(AssociationConnector).private.drightside,
                        kind)->Redisplay
                    #);
                  
               #);
             
          #);
        eventHandler::  (# onSelect::  (#  do  #) #);
        open::< 
          (# 
          do
             true->opened;
             editItem.open;
             'Edit...'->editItem.name;
             editItem[]->append;
             sep1.open;
             sep1[]->append;
             hideitem.open;
             'Hide'->hideItem.name;
             hideItem[]->append;
             nameItem.open;
             'Name'->nameItem.name;
             nameItem[]->append;
             leftRoleNameItem.open;
             leftRoleNameItem[]->append;
             rightRoleNameItem.open;
             rightRoleNameItem[]->append;
             leftMulItem.open;
             leftMulItem[]->append;
             rightMulItem.open;
             rightMulItem[]->append;
             sep2.open;
             sep2[]->append;
             leftAttachItem.open;
             leftAttachItem[]->append;
             rightAttachItem.open;
             rightAttachItem[]->append;
             patterndiagrams.AggregationList.find
               (#
                  predicate:: 
                    (# anAST: ^mps.ast
                    do
                       ((rightrole->rr[]).thePatternDiagramNode).getASTNode
                         ->anAST[];
                       (if not
                       (anAST## <= betaGram.AttributeDecl##)
                       (* in case it was a titlenode *) then
                           anAST[]->patterndiagrams.astUtils.getEnclosingDecl
                             ->anAST[]
                       if);
                       (if switch[54] then
                           'AggregationConnector onDoubleClick - Comparing: %i %i and %i %i/n'
                             ->putformat
                               (# 
                               do
                                  current.left->i;
                                  (
                                  ((leftrole->lr[]).thePatternDiagramNode).
                                  getASTNode).index->i;
                                  current.right->i;
                                  anAST.index->i
                               #)
                       if);
                       (current.left =
                        (((leftrole->lr[]).thePatternDiagramNode).getASTNode).
                        index) and
                       ((((leftrole->lr[]).thePatternDiagramNode).getASTNode).
                        frag.fullname->current.leftFrag.equal) and
                       (current.right = anAST.index) and
                       (anAST.frag.fullname->current.rightFrag.equal)->value
                    #);
                  notFound:: 
                    (# ok: @integer; anAST: ^mps.ast
                    do
                       ('Aggregation Edit',
                        'The aggregation code has been edited in Sif,\nCheck the program to insure consistency?\n- "No" will launch the aggregation dialog\nwith settings that are as consistent as\npossible with the code.\n')
                         ->promptForBoolean->ok;
                       (if ok
                        // yes then
                           ((leftrole->lr[]).thePatternDiagramNode).getAstNode
                             ->anAST[];
                           (if anAST[] <> none then
                               anAST.frag.father->callChecker
                           if)
                        // no then
                           getValuesFromCode
                             ->
                               (THIS(AssociationConnector).private.name[],
                                THIS(AssociationConnector).private.
                                  leftRoleName[],
                                THIS(AssociationConnector).private.
                                  rightRoleName[],
                                THIS(AssociationConnector).private.
                                  implementation,
                                THIS(AssociationConnector).private.embed,kind)
                        // cancel then
                           
                       if)
                    #)
               do
                  getValuesFromCode
                    ->
                      (THIS(AssociationConnector).private.name[],
                       THIS(AssociationConnector).private.leftRoleName[],
                       THIS(AssociationConnector).private.rightRoleName[],
                       THIS(AssociationConnector).private.implementation,
                       THIS(AssociationConnector).private.embed,kind);
                  current.leftmulfrom
                    ->THIS(AssociationConnector).private.leftmulfrom;
                  current.leftmulto
                    ->THIS(AssociationConnector).private.leftmulto;
                  current.rightmulfrom
                    ->THIS(AssociationConnector).private.rightmulfrom;
                  current.rightmulto
                    ->THIS(AssociationConnector).private.rightmulto
               #);
             (if THIS(AssociationConnector).name <> none then
                 (THIS(AssociationConnector).name).visible
                   ->THIS(AssociationConnector).private.vname
             if);
             (if (leftRole->lr[]).name <> none then
                 (lr.name).visible->THIS(AssociationConnector).private.srolename
             if);
             (lr.multiplicity).visible->THIS(AssociationConnector).private.smul;
             lr.attachRight->THIS(AssociationConnector).private.srightside;
             (if (rightRole->rr[]).name <> none then
                 (rr.name).visible->THIS(AssociationConnector).private.drolename
             if);
             (rr.multiplicity).visible->THIS(AssociationConnector).private.dmul;
             rr.attachRight->THIS(AssociationConnector).private.drightside
          #)
     #)
#)  

-- AggregationConnectorDump: DoPart --
do INNER dump  

