ORIGIN 'diagramattributes';
LIB_ITEM 'gpp';
INCLUDE '../treeprettyprint';
-- createConnectorText: DoPart --
do
     (# x1,x2,y1,y2,test1,test2: @integer; node1,node2: ^node
     do
        con.getEnds->(node1[],node2[]);
        node1.center->(x1,y1);
        node2.center->(x2,y2);
        &LabelNode[]->theLabel[];
        (x1+((x2-x1) div 2),y1+((y2-y2) div 2),10,10,t)->theLabel.new;
        9->theLabel.theText.size;
        theLabel.fittotext;
        (x1+((x2-x1) div 2),y1+((y2-y2) div 2)-10)->theLabel.center
          ->(test1,test2);
        'createConnectorText: x,y=(%i,%i)\n'
          ->putformat (#  do (test1,test2)->(i,i) #);
        con[]->theLabel.createRegion
     #)  

-- BoxToNode: DoPart --
do
   (if theNode## <= SurroundBox## then
         (# idObj: ^IDObject
         do
            theNode.getParent->idObj[];
            (if idObj[] <> none then
                (if idObj## <= DesignObject## then
                    idObj[]->theNode[]
                 else
                    'BoxToNode: Surroundbox parent is not a DesignObject?!'
                      ->stdErr.putline
                if)
             else
                'BoxToNode: Surroundbox has no parent?!'->stdErr.putline
            if)
         #)
   if)  

-- ASTToNode: Descriptor --
(# 
do
   (if switch[12] then 'ASTtoNode: '->putText if);
   (if anAST[]
    // none then 'ASTtoNode: anAST is none!'->stdErr.putLine; 
    else
       (if switch[12] then anAST.index->putInt; newline;  if);
       search:
         (# 
         do
            (if theWorkPage[] <> none then
                theWorkPage.patternDiagrams.theList.scan
                  (# theListDiagram: ^theWorkPage.ListDiagram
                  do
                     (if current.e## <= theWorkPage.ListDiagram## then
                         current.e[]->theListDiagram[];
                         theListDiagram.localNodes.scan
                           (#
                              theDiagramNode: ^theListDiagram.DiagramNode;
                              theNonTerminalNode:
                                ^theListDiagram.NonTerminalNode;
                              theSlotNode: ^theListDiagram.SlotNode
                           do
                              (if current## <= theListDiagram.DiagramNode## then
                                  current[]->theDiagramNode[];
                                  (if theDiagramNode.theDeclaration[] <> none
                                   then
                                      (if
                                      theDiagramNode.theDeclaration[]
                                        ->anAST.equal then
                                          theDiagramNode[]->theNode[];
                                          leave search
                                      if)
                                  if)
                              if);
                              (if current## <= theListDiagram.NonTerminalNode##
                               then
                                  current[]->theNonTerminalNode[];
                                  (if theNonTerminalNode.unExp[] <> none then
                                      (if
                                      theNonTerminalNode.unExp[]->anAST.equal
                                       then
                                          theNonTerminalNode[]->theNode[];
                                          leave search
                                      if)
                                  if)
                              if);
                              (if current## <= theListDiagram.SlotNode## then
                                  current[]->theSlotNode[];
                                  (if theSlotNode.unExp[] <> none then
                                      (if theSlotNode.unExp[]->anAST.equal then
                                          theSlotNode[]->theNode[]; leave search
                                      if)
                                  if)
                              if)
                           #)
                     if)
                  #)
            if);
            theGroupPage.patternDiagrams.theList.scan
              (# theFragmentDiagram: ^theGroupPage.FragmentDiagram
              do
                 (if current.e## <= theGroupPage.FragmentDiagram## then
                     current.e[]->theFragmentDiagram[];
                     theFragmentDiagram.localNodes.scan
                       (# fn: ^theFragmentDiagram.FragmentNode
                       do
                          (if current## <= theFragmentDiagram.FragmentNode##
                           then
                              current[]->fn[];
                              (if fn.theRoot[]->anAST.equal then
                                  fn[]->theNode[]; leave search
                              if)
                          if)
                       #)
                 if)
              #)
         #);
       (*        search:
        anAST.index
        ->indexIDList.scan
        (# theObject: ^PatternDiagramNode; ff: ^mps.fragmentForm
        do
        currentNode[]->theObject[];
        (if theObject.getFragment
        // none then
        'ASTtoNode: theNode.getFragment is none!'->putLine; 
        else
        theObject.getFragment->ff[];
        (if ff[] = anAST.frag[] then
        theObject[]->theNode[]; leave search
        if)
        if);
        
        #);*)
       (if switch[12] then
           ' return: '->putText;
           (if theNode[]
            // none then 'none'->putLine
            else
               theNode.id->putInt; newLine
           if);
           
       if)
   if);
   
#)  

-- ASTToNodeListUpdate: Descriptor --
(# ff: ^mps.fragmentform; oldASTName: ^Text; 
do
   (if switch[12] then 'ASTtoNodeListUpdate: '->putText;  if);
   (if oldAST[]
    // none then 'ASTtoNodeListUpdate: oldAST is none!'->putLine; 
    else
       (if switch[12] then oldAST.index->putInt; ' '->put;  if);
       (if newAST[]
        // none then 'ASTtoNodeListUpdate: newAST is none!'->putLine; 
        else
           search:
             (# 
             do
                (if theWorkPage[] <> none then
                    theWorkPage.patternDiagrams.theList.scan
                      (# theListDiagram: ^theWorkPage.ListDiagram
                      do
                         (if current.e## <= theWorkPage.ListDiagram## then
                             current.e[]->theListDiagram[];
                             theListDiagram.localNodes.scan
                               (#
                                  theDiagramNode: ^theListDiagram.DiagramNode;
                                  theNonTerminalNode:
                                    ^theListDiagram.NonTerminalNode
                               do
                                  (if current## <= theListDiagram.DiagramNode##
                                   then
                                      current[]->theDiagramNode[];
                                      (if
                                      theDiagramNode.theDeclaration[]
                                        ->oldAST.equal then
                                          theDiagramNode[]->theNode[]
                                      if)
                                  if);
                                  (if current## <=
                                  theListDiagram.NonTerminalNode## then
                                      current[]->theNonTerminalNode[];
                                      (if
                                      theNonTerminalNode.unExp[]->oldAST.equal
                                       then
                                          theNonTerminalNode[]->theNode[]
                                      if)
                                  if)
                               #)
                         if)
                      #)
                if);
                theGroupPage.patternDiagrams.theList.scan
                  (# theListDiagram: ^theGroupPage.ListDiagram
                  do
                     (if current.e## <= theGroupPage.ListDiagram## then
                         current.e[]->theListDiagram[];
                         theListDiagram.localNodes.scan
                           (# 
                           do
                              (if current.astIndex = oldAST.index then
                                  current[]->theNode[]; leave search
                              if)
                              (*(if current## <= theListDiagram.FragmentNode## then
                               current[]->theFragmentNode[];
                               (if theFragmentNode.theRoot->oldAST.equal then
                               theFragmentNode[]->theNode[]
                               if)
                               if)*)
                           #)
                     if)
                  #)
             #);
           (*           (if switch[21] then newAST.index->putInt;  if);
            search:
            oldAST.index
            ->indexIDList.scan
            (# theObject: ^PatternDiagramNode
            do
            currentNode[]->theObject[];
            (if theObject.getFragment
            // none then
            'ASTtoNodeListUpdate: theNode.getFragment is none!'
            ->putLine;
            
            else
            theObject.getFragment->ff[];
            (if ff[] = newAST.frag[] then
            newAst.Index->indexIDList.impl[i];
            theObject[]->theNode[];
            leave search
            if)
            if);
            
            #)*)
           
       if);
       (if switch[12] then
           ' return: '->putText;
           (if theNode[]
            // none then 'none'->putLine
            else
               theNode.id->putInt; newLine
           if);
           
       if);
       
   if)
#)  

-- getQualificationWithPath: Descriptor --
(#
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   aDeclAST,nca,ncDecl: ^MPS.AST;
   keepT: ^Text;
   qualSonNo,refSonNo: @integer;
   getSurroundingDecl:
     (# anAST: ^MPS.AST; attDecl: ^betaGram.AttributeDecl
     enter anAST[]
     do
        (if anAST.father
         // none then 
         else
            anAst.father->anAST[];
            (if anAST.symbol
             // BetaGram.PatternDecl // betaGram.VirtualDecl
             // betaGram.BindingDecl // betaGram.FinalDecl
             // betaGram.SimpleDecl then
                anAST[]->attDecl[]
             else
                anAST[]->getSurroundingDecl->attDecl[]
            if)
        if)
     exit attDecl[]
     #)
do
   qual.getSon1->theNames[];
   theNames.getSon1->theNameDcl[];
   theNameDcl.getNameDecl->aDeclAST[];
   (if aDeclAST.kind = mps.kinds.unExpanded then
       '<<NameAppl>>'->t[]->keepT[]
    else
       theNameDcl.getText->t[]->keepT[]
   if);
   (if not (ref[]->qual.equal) then
       (if ref.frag[] = qual.frag[] then
           ref[]->qual.nearestCommonAncestor->(nca[],qualSonNo,refSonNo);
           (if not (nca## <= betaGram.AttributeDecl##) then
               nca[]->getSurroundingDecl->ncDecl[]
           if)
       if);
       (if ncDecl[] = none then
           loop:
             (# 
             do
                qual[]->getSurroundingDecl->qual[];
                (if qual[] <> none then
                    qual.getSon1->theNames[];
                    theNames.getSon1->theNameDcl[];
                    theNameDcl.getNameDecl->aDeclAST[];
                    (if aDeclAST.kind = mps.kinds.unExpanded then
                        '<<NameAppl>>.'->t.prepend
                     else
                        '.'->t.prepend; theNameDcl.getText->t.prepend
                    if);
                    restart loop
                if)
             #)
        else
           (if not (qual[]->ncDecl.equal) then
               qual[]->getSurroundingDecl->qual[];
               (if qual[] <> none then
                   (if not (qual[]->ncDecl.equal) then
                       loop:
                         (# 
                         do
                            qual.getSon1->theNames[];
                            theNames.getSon1->theNameDcl[];
                            theNameDcl.getNameDecl->aDeclAST[];
                            (if aDeclAST.kind = mps.kinds.unExpanded then
                                '<<NameAppl>>.'->t.prepend
                             else
                                '.'->t.prepend; theNameDcl.getText->t.prepend
                            if);
                            qual[]->getSurroundingDecl->qual[];
                            (if qual[] <> none then
                                (if not (qual[]->ncDecl.equal) then
                                    restart loop
                                if)
                             else
                                keepT[]->t[]
                            if)
                         #)
                   if)
                else
                   keepT[]->T[]
               if)
           if)
       if)
   if)
#)  

-- CalculateNextCenter: Descriptor --
(# x,y,w,h: @Integer; p: ^OADPage; 
do
   (if PatternDiagrams.theList.size
    // 0 then (* first diagram on page *)
       CurrentPage->p[];
       p.Geometry->(x,y,w,h);
       (* center, width, and height of PAGE *)
       y-(h div 2)+gppProp.DownOnPage->patterndiagrams.NextFreeLine;
       x-(w div 2)+gppProp.RightOnPage->patterndiagrams.NextFreeColumn;
       patterndiagrams.NextFreeLine->patterndiagrams.SecondFreeLine;
       patterndiagrams.NextFreeColumn+gppProp.width+gppProp.RightFromPrevious
         ->patterndiagrams.SecondFreeColumn;
       
   if);
   (patterndiagrams.NextFreeColumn,patterndiagrams.NextFreeLine)->theCenter;
   (*(nextX,nextY)->theCenter;*)
   
#)  

-- UpdateNextFree: Descriptor --
(# w,h: @Integer; 
do
   (patterndiagrams.NextFreeLine,y+gppProp.DownFromPrefix)->Max
     ->patterndiagrams.NextFreeLine;
   (patterndiagrams.SecondFreeColumn,x+gppProp.width+gppProp.RightFromPrevious)
     ->Max->patterndiagrams.SecondFreeColumn;
   0->y;
   730->h;
   (if patterndiagrams.NextFreeLine > y+(h div 2) then
   (* patterndiagrams.SecondFreeLine -> patterndiagrams.NextFreeLine;*)
       y-(h div 2)+gppProp.DownOnPage->patterndiagrams.NextFreeLine;
       (if true (* patterndiagrams.NextFreeColumn < theCenter.x *) then
           patterndiagrams.SecondFreeColumn->patterndiagrams.NextFreeColumn;
           patterndiagrams.SecondFreeColumn+gppProp.width+
           gppProp.RightFromPrevious->patterndiagrams.SecondFreeColumn;
           
       if);
       
   if);
   
#)  

-- prettyprintSubPatterns: DoPart --
do
     (#
        treeNode: treePPNode
          (#
             element::< PatternDeclDiagram;
             width::< 
               (#
                  thePatternDeclDiagram: ^PatternDeclDiagram;
                  x,y,h,w1,w2: @integer
               do
                  elm[]->thePatternDeclDiagram[];
                  (if gppProp.showAttributes then
                      (if thePatternDeclDiagram.localNodes.empty then
                          thePatternDeclDiagram.titleNode.geometry->(x,y,w,h)
                       else
                          (thePatternDeclDiagram.localNodes.last).elm.geometry
                            ->(x,y,w1,h);
                          thePatternDeclDiagram.titleNode.geometry->(x,y,w2,h);
                          (w1,w2)->max->w
                      if)
                   else
                      thePatternDeclDiagram.titleNode.geometry->(x,y,w,h)
                  if)
               #);
             print::<  (#  do elm.titleText[]->puttext #)
          #);
        buildTree:
          (# theNode,aNode: ^treeNode; subList: ^SortableDiagramList
          enter theNode[]
          do
             theNode
               ->patterndiagrams.inheritanceList.GetSortableSubPatternDiagrams
               ->subList[];
             subList.sort;
             subList.scan
               (# 
               do
                  &treeNode[]->aNode[];
                  current[]->aNode.elm[];
                  aNode[]->theNode.appendSon;
                  aNode[]->buildTree
               #)
          #);
        x,y,width,heigth,titleWidth,delta,x1,y1,maxY: @Integer;
        root: ^treeNode;
        h: ^treePPhead;
        pos,firstPos: @real
     do
        &treeNode[]->root[];
        thePatternDeclDiagram[]->root.elm[];
        root[]->buildTree;
        (root[],h[],0,gppProp.rightOnPage)->treePPposition->(pos,h[]);
        (if h[] <> none then
            (if switch[90] then h.print; newline if);
            (if h.first[] <> none then
                h.first.pnode.elm[]->thePatternDeclDiagram[];
                thePatternDeclDiagram.titleNode.center->(x,y);
                (if gppProp.showAttributes then
                    (if not thePatternDeclDiagram.localNodes.empty then
                        (thePatternDeclDiagram.localNodes.last).elm.center
                          ->(x,y)
                    if)
                if);
                y+gppProp.DownFromPrefix->y;
                minInt->maxY;
                h.first.pos->firstPos;
                (if h.next[] <> none then
                    loop:
                      (# 
                      do
                         h.next.first.pnode.elm[]->thePatternDeclDiagram[];
                         thePatternDeclDiagram.titleNode.geometry
                           ->(x1,y1,titleWidth,heigth);
                         0->delta;
                         (if gppProp.showAttributes then
                             (if not thePatternDeclDiagram.localNodes.empty then
                                 (thePatternDeclDiagram.localNodes.last).elm.
                                   geometry->(x1,y1,width,heigth);
                                 (if width > titleWidth then
                                     width div 2-titleWidth div 2->delta
                                 if)
                             if)
                         if);
                         x+(h.next.first.pos-firstPos)-delta->x1;
                         (x1,y)->thePatternDeclDiagram.titleNode.center;
                         (if gppProp.showAttributes then
                             (if not thePatternDeclDiagram.localNodes.empty then
                                 (thePatternDeclDiagram.localNodes.last).elm.
                                   center->(x1,y1);
                                 (maxY,y1)->max->maxY
                             if)
                         if);
                         (if h.next.first.next[] <> none then
                             h.next.first.next[]->h.next.first[]; restart loop
                          else
                             (if h.next.next[] <> none then
                                 ((y,maxY)->max)+gppProp.DownFromPrefix->y;
                                 h.next.next[]->h.next[];
                                 restart loop
                             if)
                         if)
                      #)
                if)
            if);
            (*             (if false then
             *                 (if h.first[] <> none then
             *                     h.first.pnode.elm[]->thePatternDeclDiagram[];
             *                     thePatternDeclDiagram.titleNode.center->(x,y);
             *                     (if gppProp.showAttributes then
             *                         (if not thePatternDeclDiagram.localNodes.empty then
             *                             (thePatternDeclDiagram.localNodes.last).elm.center
             *                               ->(x,y)
             *                         if)
             *                     if);
             *                     y+gppProp.DownFromPrefix->y;
             *                     minInt->maxY;
             *                     h.first.pos->firstPos;
             *                     (if h.next[] <> none then
             *                         loop:
             *                           (# 
             *                           do
             *                              h.next.first.pnode.elm[]->thePatternDeclDiagram[];
             *                              thePatternDeclDiagram.titleNode.geometry
             *                                ->(x1,y1,width,heigth);
             *                              (if gppProp.showAttributes then
             *                                  (if not thePatternDeclDiagram.localNodes.empty
             *                                   then
             *                                      (thePatternDeclDiagram.localNodes.last).elm
             *                                      .geometry->(x1,y1,width,heigth)
             *                                  if)
             *                              if);
             *                              (h.next.first.pos-firstPos)*
             *                              (gppProp.rightOnPage+width)+x->x1;
             *                              (x1,y)->thePatternDeclDiagram.titleNode.center;
             *                              thePatternDeclDiagram.titletext[]->puttext;
             *                              ' '->puttext;
             *                              x1->putint;
             *                              newline;
             *                              (if gppProp.showAttributes then
             *                                  (if not thePatternDeclDiagram.localNodes.empty
             *                                   then
             *                                      (thePatternDeclDiagram.localNodes.last).elm
             *                                      .center->(x1,y1);
             *                                      (maxY,y1)->max->maxY
             *                                  if)
             *                              if);
             *                              (if h.next.first.next[] <> none then
             *                                  h.next.first.next[]->h.next.first[];
             *                                  restart loop
             *                               else
             *                                  (if h.next.next[] <> none then
             *                                      ((y,maxY)->max)+gppProp.DownFromPrefix->y;
             *                                      h.next.next[]->h.next[];
             *                                      restart loop
             *                                  if)
             *                              if)
             *                           #)
             *                     if)
             *                 if)
             *              else
             *                 
             *             if)
             *  
             *)
            
         else
            'h is NONE!'->putline
        if)
     #)  

-- edgeSpecializations: DoPart --
do
     (#
        subList: ^DiagramList;
        x,y,lx,ly,x1,y1,yMin: @integer;
        p: [8] @integer
     do
        thePatternDeclDiagram.titleNode.center->(x,y);
        (if thePatternDeclDiagram.localNodes.empty then
            (x,y)->(lx,ly)
         else
            (thePatternDeclDiagram.localNodes.last).elm.center->(lx,ly)
        if);
        thePatternDeclDiagram[]
          ->patterndiagrams.inheritanceList.GetSubPatternDiagrams->subList[];
        maxInt->yMin;
        subList.scan
          (# 
          do current.e.titleNode.center->(x1,y1); (y1,yMin)->min->yMin
          #);
        subList.scan
          (# 
          do
             current.e.titleNode.center->(x1,y1);
             x1->p[3];
             (ly+yMin) div 2->p[4];
             lx->p[5];
             (ly+yMin) div 2->p[6];
             p->(current.e.titleNode.thePrefixConn).points;
             current.e[]->edgeSpecializations
          #)
     #)  

-- gppChangedFocus: Descriptor --
(# 
do (* true->OKtoChange;*)
   currentFocus[]->oldFocus[];
   newObject[]
     ->CurrentFocus[]
     (*  else
      oldObject[]->currentObject
      if)*) ;
   (*  currentFocus[]->currentObject (#  do true->autoPan #); *)
   (* (if OKToChange then*)
   INNER changedFocus
#)  

-- ASTtoNearestNode: DoPart --
do
   (if anAST[] <> none then
       (if switch[60] or switch[12] then
           'ASTtoNearestNode: anAST=%i\n'
             ->putformat (#  do anAST.index->i #)
       if);
       anAST[]->ASTtoNode->node[];
       (if node[] = none then
           L:
           (if true then
               anAST.father->anAST[];
               (if anAST[] <> none then
                   anAST[]->ASTtoNode->node[];
                   (if node[] = none then restart L if);
                   
               if)
           if);
           
       if);
       (if switch[60] or switch[12] then
           'ASTtoNearestNode: node=%i\n'
             ->putformat
               (#  do (if node[] <> none then node.id->i else 0->i if) #)
       if)
    else
       'ASTtoNearestNode: anAST is NONE!?'->stdErr.putline;
       (if switch[60] or switch[12] then
           'ASTtoNearestNode: anAST is none'->putline
       if)
   if)  

-- sifNotificationNewFragment: DoPart --
do
   INNER ;
   (if switch[40] // true then 'Gpp ------- newFragment'->putLine;  if);
   ;
     

-- propertiesChanged: DoPart --
do
   scanner: PatternDiagrams.theList.scanPropertyDiagrams
     (# 
     do
        (if fg[] = thisDiagram.theGroup then
            thisDiagram.redisplay; leave scanner; 
        if);
        
     #);
   autosave  

-- fragmentChanged: DoPart --
do
     (# foundDiagram: ^ListDiagram
     do
        FragmentDiagram##
          ->ScanDiagrams
            (# theDiagram: ^FragmentDiagram; theRegionList: ^ObjectList
            do
               current[]->theDiagram[];
               (if ff.father
                // theDiagram.theGroup then (* find formname in the diagram *)
                   theDiagram[]->foundDiagram[];
                   theDiagram.localnodes.scan
                     (#
                        theFragmentNode: ^theDiagram.FragmentNode;
                        t: ^text;
                        index: @integer;
                        w1,h1: @integer;
                        
                     do
                        current[]->theFragmentNode[];
                        (if ff[] = theFragmentNode.theFragment then
                            ff[]->theFragmentNode.redisplay;
                            (if theFragmentNode.currentDecomposDiagram <> none
                             then
                                (ff.father).name->t[];
                                DirectoryChar
                                  ->t.findAll (#  do inx->index #);
                                (index+1,t.length)->t.sub->t[];
                                '-'->t.put;
                                theFragmentNode.theName->t.puttext;
                                t
                                  ->
                                    (theFragmentNode.currentDecomposDiagram).
                                    titleNode.theText.set;
                                (theFragmentNode.currentDecomposDiagram).
                                titleNode.getRegionList->theRegionList[];
                                (if theRegionList[] <> none then
                                    theRegionList.scan
                                      (# anObj: ^DesignObject
                                      do current[]->anObj[]; anObj.unmakeRegion
                                      #);
                                    
                                if);
                                (theFragmentNode.currentDecomposDiagram).
                                titleNode.FitToText;
                                (theFragmentNode.currentDecomposDiagram).
                                titleNode.Size->(w1,h1);
                                ((w1,gppProp.titleWidth)->max,h1)
                                  ->
                                    (theFragmentNode.currentDecomposDiagram).
                                    titleNode.size;
                                (if theRegionList[] <> none then
                                    theRegionList.scan
                                      (# anObj: ^DesignObject
                                      do
                                         current[]->anObj[];
                                         (theFragmentNode.currentDecomposDiagram
                                         ).titleNode[]->anObj.createRegion
                                      #)
                                if);
                                t
                                  ->
                                    (theFragmentNode.currentDecomposDiagram).
                                    titleText
                            if)
                        if)
                     #)
               if)
            #);
        (if foundDiagram[] <> none then
            foundDiagram.localNodes.adjustsizes; autosave
        if)
     #)  

-- fragmentInserted: DoPart --
do
   FragmentDiagram##
     ->ScanDiagrams
       (# theDiagram: ^FragmentDiagram; pos: @integer
       do
          current[]->theDiagram[];
          (if ff.father = theDiagram.theGroup then
          (* find formname in the diagram *)
              1->pos;
              scanner: (ff.father).fragmentList.scan
                (# 
                do
                   (if current.type = mps.formType then
                       (if current.f[] = ff[] then
                           leave scanner
                        else
                           pos+1->pos
                       if);
                       
                   if);
                   
                #);
              (pos-1,ff[])->theDiagram.insertFragmentNode
          if)
       #);
   autosave  

-- fragmentDeleted: DoPart --
do
   scanner:
   FragmentDiagram##
     ->ScanDiagrams
       (# theDiagram: ^FragmentDiagram; pos: @integer
       do
          current[]->theDiagram[];
          (if ff.father = theDiagram.theGroup then
              theDiagram.localNodes.scan
                (# theFragmentNode: ^theDiagram.FragmentNode
                do
                   current[]->theFragmentNode[];
                   (if ff[] = theFragmentNode.theFragment then
                       theFragmentNode[]->theDiagram.deleteFragmentNode;
                       leave scanner
                   if)
                #)
          if)
       #);
   autosave  

-- astReplaced: DoPart --
do
   false->repair;
   thisOp:
     (#
        theObject: ^PatternDiagramNode;
        pos: @integer;
        theDiagram: ^Diagram;
        doListReplace: @boolean;
        deleted: @boolean;
        dummyFilter: ##external;
        pageList: ^ObjectList;
        filename: @Text;
        nonterminalName: ^Text;
        prompt: @text;
        theListDiagram: ^ListDiagram;
        theAbstractNode: ^theListDiagram.AbstractNode;
        theunexp: ^mps.unexpanded;
        oldElements: ^mps.astList;
        
     do
        60
          ->trace
            (# 
            do
               'gpp-astReplaced: oldindex=%i oldKind=%i newindex=%i newKind=%i\n'
                 ->t.putformat
                   (# 
                   do
                      oldAst.index->i;
                      oldAst.kind->i;
                      newAst.index->i;
                      newAst.kind->i
                   #)
            #);
        (if oldAST.kind
         // mps.kinds.unExpanded then
         (* this is an ECOOP94 hack, must be generalized
          TOBY: - meanwhile I think it has been :-) *)
            (if newAst.kind
             // mps.kinds.interior then
                (if NewAST## <= betaGram.attributeDecl## then
                    true->doListReplace; 
                if)
             // mps.kinds.optional then
                oldAST[]->ASTtoNode->theObject[];
                (if theObject[] <> none then
                    theObject.theDiagram->theDiagram[];
                    (theObject[],true)->theDiagram.deleteDiagramNode;
                    true->deleted
                 else
                    leave thisOp
                if)
             // mps.kinds.unExpanded then
                
            if)
         // mps.kinds.interior then
            oldAST[]->patterndiagrams.AssociationList.update;
            oldAST[]->patterndiagrams.InheritanceList.update;
            oldAST[]->patterndiagrams.AggregationList.update;
            (if newAST.kind
             // mps.kinds.interior then
                (if oldAST## <= betaGram.attributeDecl## then
                    (if newAST## <= betaGram.attributeDecl## then
                        (if oldAST## <> newAST## then true->doListReplace if)
                    if)
                if)
             // mps.kinds.optional then
                oldAST[]->ASTtoNode->theObject[];
                (if theObject[] <> none then
                    theObject.theDiagram->theDiagram[];
                    (theObject[],true)->theDiagram.deleteDiagramNode;
                    true->deleted
                 else
                    leave thisOp
                if)
             // mps.kinds.unexpanded then
                (if newAst[] = newAst.frag.root[] then
                    'astReplaced: newAst is root:'->putline;
                    newAst.dump;
                    '\noldAst'->putline;
                    oldAst.dump;
                    newline;
                    oldAST[]->ASTtoNode->theObject[];
                    (if theObject[] <> none then
                        (if theObject[] = (theObject.theDiagram).theFragmentNode
                         then
                            (theObject.theDiagram).theFragmentNode
                              ->theAbstractNode[];
                            (if theAbstractNode.currentDecomposDiagram <> none
                             then
                                ((theObject.theDiagram).theFragmentNode).
                                abstract
                            if)
                        if);
                        (* theObject.theDiagram->theDiagram[];
                         (theObject[],true)->theDiagram.deleteDiagramNode;
                         true->deleted *)
                        
                     else
                        leave thisOp
                    if)
                 else
                    true->doListReplace
                if)
             else
            (* updateDiagramNode *)
                
            if)
         // mps.kinds.optional then
            (if newAST.kind
             // mps.kinds.unexpanded then
                newAST[]->theunexp[];
                theunexp.nonTerminalSymbol->betaGram.symbolToName
                  ->nonterminalName[];
                (if 'AttributeDeclOpt'->nonterminalName.equal then
                    (newAst.father,newAst.sonNo)->listElementInserted;
                    leave thisOp
                    (* oldAst[]->ASTtoNearestNode->theObject[];
                     (if theObject[] <> none then
                     theObject.theDiagram->theListDiagram[];
                     (if theObject## <= theListDiagram.AbstractNode## then
                     theObject[]->theAbstractNode[];
                     (if theAbstractNode.currentDecomposDiagram <> none
                     then
                     (newAST.sonNo-1,newAST[])
                     ->
                     (theAbstractNode.currentDecomposDiagram).
                     insertDiagramNode;
                     leave thisOp
                     if)
                     if)
                     else
                     'astReplaced: theObject is none'->stdErr.putline;
                     leave thisOp
                     if)*)
                if)
             // mps.kinds.interior then
                (if newAST## <= betaGram.AttributeDecl## then
                    (newAst.father,newAst.sonNo)->listElementInserted;
                    leave thisOp
                    (* oldAst[]->ASTtoNearestNode->theObject[];
                     (if theObject[] <> none then
                     theObject.theDiagram->theListDiagram[];
                     (if theObject## <= theListDiagram.AbstractNode## then
                     theObject[]->theAbstractNode[];
                     (if theAbstractNode.currentDecomposDiagram <> none
                     then
                     (newAST.sonNo-1,newAST[])
                     ->
                     (theAbstractNode.currentDecomposDiagram).
                     insertDiagramNode;
                     leave thisOp
                     if)
                     if)
                     else
                     'astReplaced: theObject is none'->stdErr.putline;
                     leave thisOp
                     if) *)
                if)
            if)
        if);
        (if doListReplace then
            &mps.astList[]->oldElements[];
            oldAST[]->oldElements.elm[1][];
            (newAST.father,newAST.sonNo,1,oldElements[],1)
              ->listElementsReplaced;
            (* oldAST[]->ASTtoNode->theObject[];
             (if theObject[] <> none then
             theObject.theDiagram->theDiagram[];
             [*
             (theObject[],true)->theObject.theDiagram.deleteDiagramNode;
             (pos,newAST[])->theDiagram.insertDiagramNode;    
             *]
             (theObject[],newAST[])->theDiagram.replaceDiagramNode;
             
             if)
             *)
            
         else
            (if not deleted then
                oldAST[]->ASTtoNearestNode->theObject[];
                (if theObject[] <> none then
                    (oldAst[],newAst[])
                      ->(theObject.theDiagram).updateDiagramNode
                 else
                    'astReplaced: theObject is none'->stdErr.putline
                if)
            if);
            
        if);
        Redraw;
        autosave
     #);
   true->repair  

-- listElementInserted: Descriptor --
(#
   getOlderSibling:
     (#
        father: ^mps.expanded;
        pos: @integer;
        theObject: ^PatternDiagramnode;
        ld: ^ListDiagram;
        an: ^ld.AbstractNode;
        olderSibling: ^mps.ast
     enter (father[],pos)
     do
        loop:
        (if pos-1 >= 1 then
            pos-1->father.get->olderSibling[];
            (if olderSibling.kind = mps.kinds.optional then
                pos-1->pos; restart loop
             else
                olderSibling[]->AstToNearestNode->theObject[]
            if)
         else
            father[]->AstToNearestNode->theObject[];
            (if theObject[] <> none then
                theObject.theDiagram->ld[];
                (if theObject## <= ld.AbstractNode## then
                    theObject[]->an[];
                    (if an.currentDecomposDiagram <> none then
                        (an.currentDecomposDiagram).titleNode[]->theObject[]
                     else
                        none ->theObject[]
                    if)
                if)
            if)
        if)
     exit theObject[]
     #);
   theObject: ^PatternDiagramNode;
   newAst: ^mps.ast;
   pos,i,noOfSons: @integer;
   theListDiagram: ^ListDiagram;
   theFragmentNode: ^theListDiagram.FragmentNode
do
   60
     ->trace
       (# 
       do
          'Gpp-listElementInserted: fatherIndex: %i position: %i\nfather frag: %s\n'
            ->t.putformat
              (# 
              do father.index->i; position->i; father.frag.fullname->s
              #)
       #);
   false->repair;
   (father[],position)->getOlderSibling->theObject[];
   position->pos->father.get->newAST[];
   (if newAST.kind <> mps.kinds.optional then
       (if theObject[] <> none then
           theObject.theDiagram->theListDiagram[];
           (if theObject## <= theListDiagram.FragmentNode## then
               theObject[]->theFragmentNode[];
               (if theFragmentNode.currentDecomposDiagram = none then
                   theFragmentNode.detail
               if)
            else
           (* (pos-1,newAST[])->(theObject.theDiagram).insertDiagramNode; *)
               newAST[]->theObject.insertDiagramNode
           if);
           Redraw;
           autosave
        else
           'listElementInserted: theObject is none'->stdErr.putline
       if)
   if);
   true->repair;
   60->trace (#  do 'Gpp-listElementInserted END'->t #)
#)  

-- listElementsDeleted: Descriptor --
(# theObject: ^PatternDiagramNode
do
   60->trace (#  do 'Gpp ------- listElementsDeleted'->t #);
   false->repair;
   (for i: length repeat
     oldElements.elm[i][]->patterndiagrams.AssociationList.update;
     oldElements.elm[i][]->patterndiagrams.InheritanceList.update;
     oldElements.elm[i][]->patterndiagrams.AggregationList.update;
     oldElements.elm[i][]->ASTtoNode->theObject[];
     (if theObject[] <> none then
         (theObject[],true)->(theObject.theDiagram).deleteDiagramNode; 
     if)
   for);
   Redraw;
   true->repair;
   autosave;
   
#)  

-- listElementsReplaced: Descriptor --
(#
(* changeSpec:
 * <fatherIndex> <position> <length> <oldElements> <newLength> 
 * <oldElements> ::= { <elementIndex> } i    (i = <length>)
 *) 
do
   60->trace (#  do 'Gpp ------- listElementsReplaced'->T #);
   false->repair;
   (father[],position,length,oldElements[])->listElementsDeleted;
   (for i: newlength repeat (father[],position+i-1)->listElementInserted for);
   true->repair;
   Redraw;
   autosave;
   
#)  

-- ScanDiagrams: Descriptor --
(# 
do
   PatternDiagrams.theList.scan
     (# 
     do
        current.e[]->THIS(ScanDiagrams).current[];
        (if theDiagramType##
         // none then INNER ScanDiagrams; 
         else
            (if current.e## <= theDiagramType##
             // true then INNER ScanDiagrams; 
            if)
        if)
     #)
#)  

-- onReadDiagram: Descriptor --
(# 
do
(*  THIS(OADPage).PatternDiagrams.theList.scan
 (#
 theListDiagram: ^ListDiagram;
 thisOADDiagram: ^OADDiagram;
 thisFragmentDiagram: ^FragmentDiagram;
 theDummyDesc: ^betaGram.ObjectDescriptor;
 thisPatternAttDiagram: ^PatternAttDiagram;
 theDummyAST: ^MPS.AST
 do
 current.e[]->theListDiagram[];
 (if current.e## <= OADDiagram##
 // true then
 current.e[]->thisOADDiagram[];
 thisOADDiagram.titlenode.theText.get->thisOADDiagram.titleText;
 (if thisOADDiagram.theDescriptor <> none then
 thisOADDiagram.theDescriptor->theDummyDesc[];
 theDummyDesc.index->current.index;
 (if thisOADDiagram## <= PatternAttDiagram## then
 thisOADDiagram[]->thisPatternAttDiagram[];
 thisPatternAttDiagram.theAST->theDummyAST[];
 theDummyAST.index->current.index
 if)
 if);
 if);
 (if current.e## <= FragmentDiagram## then
 current.e[]->thisFragmentDiagram[];
 thisFragmentDiagram.titlenode.theText.get
 ->thisFragmentDiagram.titleText
 if)
 #) *) 
#)  

-- gppOADPagePrivate: Descriptor --
(#  do  #)  

-- OADPageOnInit: Descriptor --
(#
   integerData: @integer;
   ok: @Boolean;
   listsize,last,showAttributesInteger,referencesInteger,specializationsInteger,
     associationsInteger,SimpleDeclDisplayInteger,x,y,w,h: @integer;
   thePalette: ^Palette;
   theRndRect: ^thePalette.RectNode;
   win: ^theUI.window
do
   (if userDataVerbose then
       'onInit called on OADPage with id='->puttext;
       id->putint;
       newline;
       'Reading OADPage UserDataID: '->puttext
   if);
   (id,1)->readIntegerUserData->integerData;
   (if integerData <> 0 then
       (integerData,id)->UserDataIDMap.putID;
       (if THIS(OADPage)[] = theGroupPage[] then
           (theGroupPage.ID,260)->readIntegerUserData->showAttributesInteger;
           (if showAttributesInteger = 1 then
               true->gppProp.showAttributes
            else
               (if showAttributesInteger = 0 then
                   false->gppProp.showAttributes
               if)
           if);
           (theGroupPage.ID,261)->readIntegerUserData->referencesInteger;
           (if referencesInteger = 1 then
               true->gppProp.references
            else
               (if referencesInteger = 0 then false->gppProp.references if)
           if);
           (theGroupPage.ID,262)->readIntegerUserData->specializationsInteger;
           (if specializationsInteger = 1 then
               true->gppProp.specializations
            else
               (if specializationsInteger = 0 then
                   false->gppProp.specializations
               if)
           if);
           (theGroupPage.ID,263)->readIntegerUserData->associationsInteger;
           (if associationsInteger = 1 then
               true->gppProp.associations
            else
               (if associationsInteger = 0 then
                   false->gppProp.associations
               if)
           if);
           (theGroupPage.ID,264)->readIntegerUserData->gppProp.SimpleDeclDisplay
       if);
       patterndiagrams.AssociationList.load;
       patterndiagrams.InheritanceList.load;
       patterndiagrams.AggregationList.load;
       (ID,240)->readIntegerUserData->nextX;
       (ID,241)->readIntegerUserData->nextY;
       (ID,250)->readIntegerUserData->patterndiagrams.NextFreeLine;
       (ID,251)->readIntegerUserData->patterndiagrams.NextFreeColumn;
       (ID,252)->readIntegerUserData->patterndiagrams.SecondFreeLine;
       (ID,253)->readIntegerUserData->patterndiagrams.SecondFreeColumn
   if);
   (id,1,id)->writeIntegerUserData;
   false->borderVisible;
   (if nextX = 0 then 250->nextX if);
   (if nextY = 0 then 250->nextY if);
   true->doScrollIntoView;
   theWindow[]->sifInsertInWindowsMenu;
   INNER onInit
#)  

