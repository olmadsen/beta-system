ORIGIN 'diagramattributes';
-- RoleVisibleSet: DoPart --
do
   (if name <> none then
       (if true
        // THIS(Role)[] = leftRole then
           (if v and (not private.srolename) then  else v->(name).visible if)
        // THIS(Role)[] = rightRole then
           (if v and (not private.drolename) then  else v->(name).visible if)
       if)
   if);
   (if true
    // THIS(Role)[] = leftRole then
       (if v and (not private.smul) then  else v->(multiplicity).visible if)
    // THIS(Role)[] = rightRole then
       (if v and (not private.dmul) then  else v->(multiplicity).visible if)
   if);
   INNER set  

-- RoleAttachRightSet: DoPart --
do
     (# rx,y,w,h,mx,my,mw,mh,nx,ny,nw,nh: @integer
     do
        center->(rx,ry);
        (thePatternDiagramNode).geometry->(x,y,w,h);
        (multiplicity).geometry->(mx,my,mw,mh);
        (if name <> none then (name).geometry->(nx,ny,nw,nh) if);
        (if v then
            x+w div 2->x;
            x+mw div 2+5->mx;
            (if name <> none then x+nw div 2+5->nx if)
         else
            x-w div 2->x;
            x-mw div 2-5->mx;
            (if name <> none then x-nw div 2-5->nx if)
        if);
        (x,ry)->center;
        (mx,my)->(multiplicity).center;
        (if name <> none then (nx,ny)->(name).center if);
        INNER set
     #)  

-- RoleAttachRightGet: DoPart --
do
     (# x,y,rx,ry: @integer
     do
        (thePatternDiagramNode).center->(x,y);
        center->(rx,ry);
        (if rx > x then true->v if)
     #)  

-- RoleDisplay: DoPart --
do
   theNode.geometry->(x,y,w,h);
   (if leftRole = none (* then we are creating the left role *) then
       x+w div 2->x
    else
       x-w div 2->x
   if);
   (x,y,0,0)->new;
   false->BorderVisible;
   false->selectable;
   theNode[]->CreateRegion;
   (if theName[] <> none (* role names are optional *) then
       &UserDataLabelNode[]->l[];
       (x,y,10,10,theName)->l.new;
       l.fitToText;
       l.geometry->(lx,ly,lw,lh);
       (if leftRole = none then x+lw div 2+5->lx else x-lw div 2-5->lx if);
       y-10->ly;
       (lx,ly)->l.center;
       THIS(Role)[]->l.createRegion;
       l[]->name;
       rolename->(name).visible
   if);
   &UserDataLabelNode[]->l[];
   &text[]->mul[];
   (if multiplicityFrom < 0 then
       '*'->mul[]
    else
       multiplicityFrom->mul.putint;
       (if multiplicityFrom <> multiplicityTo then
           '..'->mul.puttext;
           (if multiplicityTo < 0 then
               '*'->mul.puttext
            else
               multiplicityTo->mul.putint
           if)
       if)
   if);
   (x,y,10,10,mul)->l.new;
   l.fitToText;
   l.geometry->(lx,ly,lw,lh);
   (if leftRole = none then x+lw div 2+5->lx else x-lw div 2-5->lx if);
   y+10->ly;
   (lx,ly)->l.center;
   THIS(Role)[]->l.createRegion;
   l[]->multiplicity;
   mult->(multiplicity).visible;
   theNode[]->thePatternDiagramNode;
   rightside->attachRight;
   INNER display  

-- RoleRedisplay: DoPart --
do
   (thePatternDiagramNode).geometry->(x,y,w,h);
   (if leftRole = THIS(Role)[] then x+w div 2->x else x-w div 2->x if);
   (if theName[] <> none then
       (if name <> none then
           theName->(name).theText.set
        else
           &UserDataLabelNode[]->l[];
           (x,y,10,10,theName)->l.new;
           l.fitToText;
           l.geometry->(lx,ly,lw,lh);
           (if leftRole = THIS(Role)[] then
               x+lw div 2+5->lx
            else
               x-lw div 2-5->lx
           if);
           y-10->ly;
           (lx,ly)->l.center;
           THIS(Role)[]->l.createRegion;
           l[]->name
       if);
       rolename->(name).visible
   if);
   &text[]->mul[];
   (if multiplicityFrom < 0 then
       '*'->mul[]
    else
       multiplicityFrom->mul.putint;
       (if multiplicityFrom <> multiplicityTo then
           '..'->mul.puttext;
           (if multiplicityTo < 0 then
               '*'->mul.puttext
            else
               multiplicityTo->mul.putint
           if)
       if)
   if);
   (if multiplicity = none then
       &UserDataLabelNode[]->l[];
       (x,y,10,10,mul)->l.new;
       l.fitToText;
       l.geometry->(lx,ly,lw,lh);
       (if leftRole = THIS(Role)[] then
           x+lw div 2+5->lx
        else
           x-lw div 2-5->lx
       if);
       y+10->ly;
       (lx,ly)->l.center;
       THIS(Role)[]->l.createRegion;
       l[]->multiplicity
   if);
   mul->(multiplicity).theText.set;
   mult->(multiplicity).visible;
   rightside->attachRight;
   INNER redisplay  

-- RoleOnDrag: DoPart --
do
     (# 
     do
        (if switch[53] or switch[54] then
            'RoleOnDrag: %s=%i %s=%i\n'
              ->putformat
                (# theObject: ^Role; y: @integer; help: @text
                do
                   (if name <> none then
                       (name).theText.get->help; help[]->s
                   if);
                   center->(i,y);
                   THIS(Role)[]->getOtherEnd->theObject[];
                   (if theObject.name <> none then
                       (theObject.name).theText.get->help; help[]->s
                   if);
                   theObject.center->(i,y)
                #)
        if)
     #)  

-- RoleOnInit: DoPart --
do
   UDPrivate.UDRole->UserDataInit;
   name.init;
   Multiplicity.init;
   thePatternDiagramNode.init;
   false->selectable;
   false->sizeable;
   INNER onInit  

-- RoleDump: DoPart --
do
   '****name****'->putline;
   (if name <> none then
       (name).theText.get->t; t[]->putline
    else
       ' is NONE!'->putline
   if);
   '****Multiplicity****'->putline;
   (if Multiplicity <> none then
       (Multiplicity).theText.get->t; t[]->putline
    else
       ' is NONE!'->putline
   if);
   '****thePatternDiagramNode****'->putline;
   (if thePatternDiagramNode <> none then
       (thePatternDiagramNode).id->putint; newline
    else
       ' is NONE!'->putline
   if)  

-- AssociationConnectorEdit: DoPart --
do
   INNER edit;
   (if THIS(AssociationConnector)## = AssociationConnector## then
       patterndiagrams.AssociationList.find
         (#
            theName,leftRoleName,rightRoleName,description: ^Text;
            kind,implementation: @integer;
            embed: @boolean;
            predicate:: 
              (# anAST: ^mps.ast
              do
                 ((rightrole->rr[]).thePatternDiagramNode).getASTNode->anAST[];
                 (current.left =
                  (((leftrole->lr[]).thePatternDiagramNode).getASTNode).index)
                 and
                 ((((leftrole->lr[]).thePatternDiagramNode).getASTNode).frag.
                    fullname->current.leftFrag.equal) and
                 (current.right = anAST.index) and
                 (anAST.frag.fullname->current.rightFrag.equal)->value;
                 (if associationNode <> none then
                     (current.associationPattern =
                      ((associationNode).getAstNode).index) and
                     (((associationNode).getAstNode).frag.fullname
                        ->current.associationFrag.equal) and value->value
                 if)
              #);
            notFound:: 
              (#
                 ok: @integer;
                 anAST: ^mps.ast;
                 leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer;
                 tryGetMultiplicities:
                   (#
                      anAST: ^mps.ast;
                      leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer;
                      theAssociationPattern: ^betaGram.PatternDecl;
                      theObjectDescriptor: ^betaGram.ObjectDescriptor;
                      thePrefix: ^betaGram.prefix;
                      theNameApl: ^betaGram.NameApl;
                      prefixName: ^text
                   enter anAST[]
                   do
                      (1,1,1,1)
                        ->(leftMulFrom,leftMulTo,rightMulFrom,rightMulTo);
                      (if anAST.symbol = betaGram.PatternDecl then
                          anAST[]->theAssociationPattern[];
                          theAssociationPattern.getObjectDescriptor
                            ->theObjectDescriptor[];
                          theObjectDescriptor.getPrefixOpt->anAST[];
                          (if anAST.kind = mps.kinds.interior then
                              anAST[]->thePrefix[];
                              thePrefix.getAttributeDenotation->anAST[];
                              (if anAST.symbol = betaGram.NameApl then
                                  anAST[]->theNameApl[];
                                  theNameApl.getNameAppl->anAST[];
                                  (if anAST.kind <> mps.kinds.unExpanded then
                                      theNameApl.getText->prefixName[];
                                      (if true
                                       //
                                       ('OneToOneAssociation'
                                          ->prefixName.equalNCS) then
                                          (1,1,1,1)
                                            ->
                                              (leftMulFrom,leftMulTo,
                                               rightMulFrom,rightMulTo)
                                       //
                                       ('OneToManyAssociation'
                                          ->prefixName.equalNCS) then
                                          (1,1,- 1,- 1)
                                            ->
                                              (leftMulFrom,leftMulTo,
                                               rightMulFrom,rightMulTo)
                                       //
                                       ('ManyToManyAssociation'
                                          ->prefixName.equalNCS) then
                                          (- 1,- 1,- 1,- 1)
                                            ->
                                              (leftMulFrom,leftMulTo,
                                               rightMulFrom,rightMulTo)
                                      if)
                                  if);
                                  
                              if)
                          if)
                      if)
                   exit (leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
                   #)
              do
                 ('Association Doubleclick',
                  'The association code has been edited in Sif,\nCheck the program to insure consistency?\n- "No" will launch the association dialog\nwith settings that are as consistent as\npossible with the code.\n')
                   ->promptForBoolean->ok;
                 (if ok
                  // yes then
                     ((leftrole->lr[]).thePatternDiagramNode).getAstNode
                       ->anAST[];
                     (if anAST[] <> none then
                         anAST.frag.father->callChecker
                     if)
                  // no then
                     getValuesFromCode
                       ->
                         (theName[],leftRoleName[],rightRoleName[],
                          implementation,embed);
                     (if associationNode <> none then
                         (associationNode).getAstNode->tryGetMultiplicities
                           ->(leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
                      else
                         (1,1,1,1)
                           ->(leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
                     if);
                     (THIS(AssociationConnector)[],theName[],leftRoleName[],
                      rightRoleName[],implementation,leftMulFrom,leftMulTo,
                      rightMulFrom,rightMulTo,embed,description[])
                       ->openAssociationDialog
                  // cancel then
                     
                 if)
              #)
         do
            getValuesFromCode
              ->(theName[],leftRoleName[],rightRoleName[],implementation,embed);
            (THIS(AssociationConnector)[],theName[],leftRoleName[],
             rightRoleName[],implementation,current.leftMulFrom,
             current.leftMulTo,current.rightMulFrom,current.rightMulTo,embed,
             description[])->openAssociationDialog
         #)
   if)  

-- AssociationConnectorGenerateCode: DoPart --
do
   true->ok;
   INNER generateCode;
   (if not doneInInner then
       thisOp:
         (#
            theParentNode: ^PatternDiagramNode;
            theListDiagram,theOtherListDiagram,theParentDiagram: ^ListDiagram;
            theOADDiagram,theOtherOADDiagram: ^OADDiagram;
            aSimpleNode: ^theListDiagram.SimpleAttributeDecl;
            anotherSimpleNode: ^theOtherListDiagram.SimpleAttributeDecl;
            anAST,anotherAST,testAST,testAST2,lastAST,leftLastAST,rightLastAST,
              keepAST,keepOtherAST: ^mps.ast;
            theDesc,theOtherDesc: ^betaGram.ObjectDescriptor;
            t,theLeftName,theRightName,leftQualName,rightQualName,dummyQual,
              leftCode,rightCode: ^Text;
            optionalsInserted,optionalsInsertedOther,parseOK: @Boolean;
            makeName:
              (#
                 anExp: ^mps.expanded;
                 theNames: ^betaGram.Names;
                 theNameDcl: ^betaGram.NameDcl;
                 anAST: ^mps.ast;
                 theName: ^text
              enter anExp[]
              do
                 anExp.getSon1->theNames[];
                 theNames.getSon1->theNameDcl[];
                 theNameDcl.getNameDecl->anAST[];
                 (if anAST.kind = mps.kinds.unExpanded then
                     'NoName'->theName[]
                  else
                     theNameDcl.getText->theName[]
                 if)
              exit theName[]
              #)
         do
            (if (aPatternDiagramNode.theSifEditor).isReadOnly then
                (aPatternDiagramNode.theDiagram).titleText[]->t[];
                ' is read-only - can not generate code for association'
                  ->t.puttext;
                t[]->alertUser;
                false->ok
            if);
            (if (anotherPatternDiagramNode.theSifEditor).isReadOnly then
                (anotherPatternDiagramNode.theDiagram).titleText[]->t[];
                ' is read-only - can not generate code for association'
                  ->t.puttext;
                t[]->alertUser;
                false->ok
            if);
            (if ok then
                aPatternDiagramNode.theDiagram->theListDiagram[];
                anotherPatternDiagramNode.theDiagram->theOtherListDiagram[];
                (if (theListDiagram## <= FragmentDiagram##) or
                (theOtherListDiagram## <= FragmentDiagram##) then
                    'Source and/or destination is a fragment diagram'
                      ->AlertUser;
                    false->ok
                 else
                    (if (theListDiagram## <= PatternAttDiagram##) or
                    (theOtherListDiagram## <= PatternAttDiagram##) then
                        'Source and/or destination is an attributes form diagram'
                          ->AlertUser;
                        false->ok
                     else
                        (if theListDiagram.localNodes.empty then
                            theListDiagram.titleNode.getASTNode->keepAST[];
                            (if keepAST[] <> none then
                                (keepAST[],1)
                                  ->
                                    (theListDiagram.titleNode.theSifEditor).
                                    changeFocus
                            if);
                            (theListDiagram.titleNode.theSifEditor).
                            insertOptionals;
                            true->optionalsInserted
                        if);
                        (if theOtherListDiagram.localNodes.empty then
                            theOtherListDiagram.titleNode.getASTNode
                              ->keepOtherAST[];
                            (if keepOtherAST[] <> none then
                                (keepOtherAST[],1)
                                  ->
                                    (theOtherListDiagram.titleNode.theSifEditor)
                                      .changeFocus
                            if);
                            (theOtherListDiagram.titleNode.theSifEditor).
                            insertOptionals;
                            true->optionalsInsertedOther
                        if);
                        theListDiagram[]->theOADDiagram[];
                        theOtherListDiagram[]->theOtherOADDiagram[];
                        theOADDiagram.theDescriptor[]->theDesc[];
                        theOtherOADDiagram.theDescriptor[]->theOtherDesc[];
                        theDesc.father->anAST[];
                        theOtherDesc.father->anotherAST[];
                        anAST.father->testAST[];
                        anotherAST.father->testAST2[];
                        (if (testAST[] <> none ) and (testAST2[] <> none ) then
                            (if (anAST.symbol <> betaGram.StaticItem) and
                            (anotherAST.symbol <> betaGram.StaticItem) then
                                (if theListDiagram[] <> theOtherListDiagram[]
                                 then
                                    (theListDiagram.titleNode.getTopParent,
                                     theListDiagram.titleNode[],
                                     theOtherListDiagram.titleNode.getTopParent,
                                     theOtherListDiagram.titleNode[])->setEnds;
                                    theListDiagram.theParentNode
                                      ->theParentNode[];
                                    theParentNode.theDiagram
                                      ->theParentDiagram[];
                                    (theParentDiagram.localNodes.last).elm[]
                                      ->private.getLastAST->lastAST[];
                                    (theListDiagram.localNodes.last).elm[]
                                      ->private.getLastAST->leftLastAST[];
                                    (theOtherListDiagram.localNodes.last).elm[]
                                      ->private.getLastAST->rightLastAst[];
                                    (if (lastAST[] <> none ) and
                                    (leftLastAST[] <> none ) and
                                    (rightLastAST[] <> none ) then
                                        anAST[]->makeName->theLeftName[];
                                        anotherAST[]->makeName->theRightName[];
                                        anAST[]->private.makeQualName
                                          ->leftQualName[];
                                        anotherAST[]->private.makeQualName
                                          ->rightQualName[];
                                        (rightLastAST[],anAST[])
                                          ->getQualificationWithPath
                                          ->dummyQual[];
                                        (leftRoleName[],rightRoleName[],
                                         theLeftName[],theRightName[],
                                         leftQualName[],rightQualName[],
                                         dummyQual[])->private.getTextForCode
                                          ->(t[],leftCode[],rightCode[]);
                                        (if not embed then
                                            (theParentDiagram[],t[])
                                              ->private.parseAfter->parseOK;
                                            (if not parseOK then
                                                false->ok;
                                                'Internal parse error occured - should not happen!'
                                                  ->alertUser;
                                                leave thisOp
                                            if);
                                            currentFocus[]->associationNode
                                        if);
                                        (theListDiagram[],leftCode[])
                                          ->private.parseAfter->parseOK;
                                        (if not parseOK then
                                            false->ok;
                                            'Internal parse error occured - should not happen!'
                                              ->alertUser;
                                            leave thisOp
                                        if);
                                        currentFocus[]->left[]->aSimpleNode[];
                                        THIS(AssociationConnector)[]
                                          ->aSimpleNode.theAssociationConnector;
                                        (theOtherListDiagram[],rightCode[])
                                          ->private.parseAfter->parseOK;
                                        (if not parseOK then
                                            false->ok;
                                            'Internal parse error occured - should not happen!'
                                              ->alertUser;
                                            leave thisOp
                                        if);
                                        currentFocus[]->right[]
                                          ->anotherSimpleNode[];
                                        THIS(AssociationConnector)[]
                                          ->
                                            anotherSimpleNode.
                                              theAssociationConnector;
                                        (if not embed then
                                            (left.getASTNode,right.getASTNode,
                                             leftMulFrom,leftMulTo,rightMulFrom,
                                             rightMulTo,
                                             (associationNode).getASTNode)
                                              ->
                                                patterndiagrams.AssociationList.
                                                  insert
                                         else
                                            (left.getASTNode,right.getASTNode,
                                             leftMulFrom,leftMulTo,rightMulFrom,
                                             rightMulTo,none )
                                              ->
                                                patterndiagrams.AssociationList.
                                                  insert
                                        if);
                                        ((left.getASTNode).frag.father,
                                         'INCLUDE',frejaAssociationsInclude)
                                          ->sifAddProp;
                                        (if (right.getASTNode).frag.father <>
                                        (left.getASTNode).frag.father then
                                            ((right.getASTNode).frag.father,
                                             'INCLUDE',frejaAssociationsInclude)
                                              ->sifAddProp
                                        if)
                                     else
                                        'lastAST is NONE??'->stdErr.putline
                                    if)
                                 else
                                    'Source and destination is the same diagram'
                                      ->AlertUser;
                                    false->ok
                                if)
                             else
                                'Source and/or destination is singularly defined'
                                  ->AlertUser;
                                false->ok
                            if)
                         else
                            'Source and/or destination is a descriptor form diagram'
                              ->AlertUser;
                            false->ok
                        if);
                        (if optionalsInserted then
                            (if keepAST[] <> none then
                                (keepAST[],1)
                                  ->
                                    (theListDiagram.titleNode.theSifEditor).
                                    changeFocus
                            if);
                            (theListDiagram.titleNode.theSifEditor).
                            removeOptionals
                        if);
                        (if optionalsInsertedOther then
                            (if keepOtherAST[] <> none then
                                (keepOtherAST[],1)
                                  ->
                                    (theOtherListDiagram.titleNode.theSifEditor)
                                      .changeFocus
                            if);
                            (theOtherListDiagram.titleNode.theSifEditor).
                            removeOptionals
                        if)
                    if)
                if)
            if)
         #)
   if)  

-- AssociationConnectorGetValuesFromCode: DoPart --
do
   INNER getValuesFromCode;
   (if not doneInInner then
         (#
            theAssociationPattern: ^betaGram.PatternDecl;
            theNames: ^betaGram.Names;
            theNameDcl: ^betaGram.NameDcl;
            anAST: ^mps.ast;
            leftDecl,rightDecl: ^betaGram.SimpleDecl;
            theObjectDescriptor: ^betaGram.ObjectDescriptor;
            thePrefix: ^betaGram.Prefix;
            theNameApl: ^betaGram.NameApl;
            prefixName: ^text;
            help: @text;
            setEmbedImpl:
              (#
                 theDecl: ^betaGram.SimpleDecl;
                 anAST: ^mps.ast;
                 theStaticItem: ^betaGram.StaticItem;
                 os: ^betaGram.ObjectSpecification;
                 prefixName: ^text
              enter theDecl[]
              do
                 (if theDecl[] <> none then
                     theDecl.getreferenceSpecification->anAST[];
                     (if anAST.kind = mps.kinds.interior then
                         (if anAST.symbol = betaGram.StaticItem then
                             anAST[]->theStaticItem[];
                             theStaticItem.getObjectSpecification->os[];
                             (if os.symbol = betaGram.ObjectDescriptor then
                                 os[]->patterndiagrams.astUtils.getPrefixName
                                   ->prefixName[];
                                 (if prefixName[] <> none then
                                     (if 'AssociationMany'->prefixName.equalNCS
                                      then
                                     (* other (Set, hashTable,...) are not yet implemented *)
                                         gppProp.List->implementation
                                     if)
                                 if)
                             if)
                         if)
                     if)
                 if)
              #)
         do
            ((leftrole->lr[]).thePatternDiagramNode).getAstNode->anAST[];
            (if anAST.symbol = betaGram.SimpleDecl then
                anAST[]->leftDecl[];
                leftDecl.getNames->theNames[];
                theNames.getSon1->theNameDcl[];
                theNameDcl.getNameDecl->anAST[];
                (if not (anAST.kind = mps.kinds.unExpanded) then
                    theNameDcl.getText->rightRoleName[]
                if)
            if);
            ((rightrole->rr[]).thePatternDiagramNode).getAstNode->anAST[];
            (if anAST.symbol = betaGram.SimpleDecl then
                anAST[]->rightDecl[];
                rightDecl.getNames->theNames[];
                theNames.getSon1->theNameDcl[];
                theNameDcl.getNameDecl->anAST[];
                (if not (anAST.kind = mps.kinds.unExpanded) then
                    theNameDcl.getText->leftRoleName[]
                if)
            if);
            (if associationNode <> none then
                (associationNode).getAstNode->anAST[];
                (if anAST.symbol = betaGram.PatternDecl then
                    anAST[]->theAssociationPattern[];
                    theAssociationPattern.getNames->theNames[];
                    theNames.getSon1->theNameDcl[];
                    theNameDcl.getNameDecl->anAST[];
                    (if not (anAST.kind = mps.kinds.unExpanded) then
                        theNameDcl.getText->theName[]
                    if);
                    theAssociationPattern.getObjectDescriptor
                      ->patterndiagrams.astUtils.getPrefixName->prefixName[];
                    (if prefixName[] <> none then
                        (if not ('OneToOneAssociation'->prefixName.equalNCS)
                         then
                        (* other (Set, hashTable,...) are not yet implemented *)
                            gppProp.List->implementation
                        if)
                    if)
                if)
             else
                true->embed;
                (if name <> none then
                    (name).theText.get->help;
                    (if help.length > 0 then help[]->theName[] if)
                if);
                leftDecl[]->setEmbedImpl;
                rightDecl[]->setEmbedImpl
            if)
         #)
   if)  

-- AssociationConnectorInteractiveNew: DoPart --
do
   name[]->private.name[];
   implementation->private.implementation;
   leftRoleName[]->private.leftRoleName[];
   rightRoleName[]->private.rightRoleName[];
   leftMulFrom->private.leftMulFrom;
   leftMulTo->private.leftMulTo;
   rightMulFrom->private.rightMulFrom;
   rightMulTo->private.rightMulTo;
   embed->private.embed;
   description[]->private.description[];
   isVisible->private.isVisible;
   vname->private.vname;
   srolename->private.srolename;
   smul->private.smul;
   srightside->private.srightside;
   drolename->private.drolename;
   dmul->private.dmul;
   drightside->private.drightside;
   INNER interactiveNew  

-- AssociationConnectorDisplay: DoPart --
do
   false->repair;
   53
     ->trace
       (# 
       do
          'AssocationConnectorDisplay:\nname=%s\nleftRoleName=%s\nrightRolename=%s\nimplementation=%i\nleftMulFrom=%i\nleftMulTo=%i\nrightMulFrom=%i\nrightMulTo=%i\nembed=%s\ndescription=%s\nisVisible=%s\nvname=%s\nsrolename=%s\nsmul=%s\nsrightside=%s\ndrolename=%s\ndmul=%s\ndrightside=%s\n'
            ->t.putformat
              (# t: @text
              do
                 (if name[] <> none then name[]->s else 'none'->s if);
                 (if leftrolename[] <> none then
                     leftrolename[]->s
                  else
                     'none'->s
                 if);
                 (if rightrolename[] <> none then
                     rightrolename[]->s
                  else
                     'none'->s
                 if);
                 implementation->i;
                 leftmulfrom->i;
                 leftmulto->i;
                 rightmulfrom->i;
                 rightmulto->i;
                 t.clear;
                 embed->t.putboolean;
                 t[]->s;
                 (if description[] <> none then
                     description[]->s
                  else
                     'none'->s
                 if);
                 t.clear;
                 isVisible->t.putboolean;
                 t[]->s;
                 t.clear;
                 vname->t.putboolean;
                 t[]->s;
                 t.clear;
                 srolename->t.putboolean;
                 t[]->s;
                 t.clear;
                 smul->t.putboolean;
                 t[]->s;
                 t.clear;
                 srightside->t.putboolean;
                 t[]->s;
                 t.clear;
                 drolename->t.putboolean;
                 t[]->s;
                 t.clear;
                 dmul->t.putboolean;
                 t[]->s;
                 t.clear;
                 drightside->t.putboolean;
                 t[]->s
              #)
       #);
   true->initialisingSaved;
   name[]->private.name[];
   implementation->private.implementation;
   leftRoleName[]->private.leftRoleName[];
   rightRoleName[]->private.rightRoleName[];
   leftMulFrom->private.leftMulFrom;
   leftMulTo->private.leftMulTo;
   rightMulFrom->private.rightMulFrom;
   rightMulTo->private.rightMulTo;
   embed->private.embed;
   description[]->private.description[];
   isVisible->private.isVisible;
   vname->private.vname;
   srolename->private.srolename;
   smul->private.smul;
   srightside->private.srightside;
   drolename->private.drolename;
   dmul->private.dmul;
   drightside->private.drightside;
   &Role[]->lr[];
   (rightRoleName[],leftMulFrom,leftMulTo,left[], (*rolename*) srolename,
    (*mult*) smul, (*rightside*) srightside)->lr.display;
   lr[]
     ->leftRole
     (* if aggregation: leftRole<>none in rr.display - prevents diamond on rightRole *)
     ;
   &Role[]->rr[];
   (leftRoleName[],rightMulFrom,rightMulTo,right[], (*rolename*) drolename,
    (*mult*) dmul, (*rightside*) drightside)->rr.display;
   (lr[],rr[])->new;
   lr[]->leftRole;
   rr[]->rightRole;
   (if not (THIS(AssociationConnector)## <= AggregationConnector##) then
       (if (name[] <> none ) and (not ('<<NameDecl>>'->name.equal)) then
           lr.center->(lx,ly);
           rr.center->(rx,ry);
           &UserDataLabelNode[]->l[];
           (lx+((rx-lx) div 2),ly+((ry-ly) div 2),10,10,name)->l.new;
           textStyle.italic->l.theText.style;
           l.fitToText;
           (lx+((rx-lx) div 2),ly+((ry-ly) div 2)-10)->l.center;
           THIS(AssociationConnector)[]->l.createRegion;
           l[]->THIS(AssociationConnector).name;
           vname->(THIS(AssociationConnector).name).visible
       if);
         (# ln,rn: ^ListDiagram.SimpleNode
         do
            left[]->ln[];
            right[]->rn[];
            THIS(AssociationConnector)[]->ln.theAssociationConnector
              ->rn.theAssociationConnector
         #);
       isVisible->visible
    else
         (# ln: ^ListDiagram.SimpleAttributeDecl
         do
            left[]->ln[];
            THIS(AssociationConnector)[]->ln.theAggregationConnector
         #);
       (if (not gppProp.references) or (left.theDiagram = right.theDiagram) then
           false->visible
       if)
   if);
   (if assocNode[] <> none then assocNode[]->associationNode if);
   (if not gppProp.showAttributes then false->attributesVisible if);
   (if not (THIS(AssociationConnector)## <= AggregationConnector##) then
       private.thePopup.open
    else
       INNER display
   if);
   true->repair  

-- AssociationConnectorRedisplay: DoPart --
do
   false->repair;
   53
     ->trace
       (# 
       do
          'AssocationConnectorRedisplay:\nname=%s\nleftRoleName=%s\nrightRolename=%s\nimplementation=%i\nleftMulFrom=%i\nleftMulTo=%i\nrightMulFrom=%i\nrightMulTo=%i\nembed=%s\ndescription=%s\nisVisible=%s\nvname=%s\nsrolename=%s\nsmul=%s\nsrightside=%s\ndrolename=%s\ndmul=%s\ndrightside=%s\n'
            ->t.putformat
              (# t: @text
              do
                 (if name[] <> none then name[]->s else 'none'->s if);
                 (if leftrolename[] <> none then
                     leftrolename[]->s
                  else
                     'none'->s
                 if);
                 (if rightrolename[] <> none then
                     rightrolename[]->s
                  else
                     'none'->s
                 if);
                 implementation->i;
                 leftmulfrom->i;
                 leftmulto->i;
                 rightmulfrom->i;
                 rightmulto->i;
                 t.clear;
                 embed->t.putboolean;
                 t[]->s;
                 (if description[] <> none then
                     description[]->s
                  else
                     'none'->s
                 if);
                 t.clear;
                 isVisible->t.putboolean;
                 t[]->s;
                 t.clear;
                 vname->t.putboolean;
                 t[]->s;
                 t.clear;
                 srolename->t.putboolean;
                 t[]->s;
                 t.clear;
                 smul->t.putboolean;
                 t[]->s;
                 t.clear;
                 srightside->t.putboolean;
                 t[]->s;
                 t.clear;
                 drolename->t.putboolean;
                 t[]->s;
                 t.clear;
                 dmul->t.putboolean;
                 t[]->s;
                 t.clear;
                 drightside->t.putboolean;
                 t[]->s
              #)
       #);
   name[]->private.name[];
   leftRoleName[]->private.leftRoleName[];
   rightRoleName[]->private.rightRoleName[];
   implementation->private.implementation;
   leftMulFrom->private.leftMulFrom;
   leftMulTo->private.leftMulTo;
   rightMulFrom->private.rightMulFrom;
   rightMulTo->private.rightMulTo;
   embed->private.embed;
   description[]->private.description[];
   isVisible->private.isVisible;
   vname->private.vname;
   srolename->private.srolename;
   smul->private.smul;
   srightside->private.srightside;
   drolename->private.drolename;
   dmul->private.dmul;
   drightside->private.drightside;
   false->repair;
   (if not (THIS(AssociationConnector)## <= AggregationConnector##) then
       thisOp:
         (#
            oldLeft,oldRight,oldAssociationPattern: ^mps.ast;
            theParentNode: ^PatternDiagramNode;
            t,theLeftName,theRightName,dummyQual,leftQualName,rightQualName,
              leftCode,rightCode: ^text;
            index,lx,ly,rx,ry: @integer;
            l: ^UserDataLabelNode;
            parseOK: @boolean;
            errorPos: @integer;
            parseErrorText: ^Text
         do
            (if (name[] <> none ) and (not ('<<NameDecl>>'->name.equal)) then
                (if THIS(AssociationConnector).name = none then
                    (leftrole->lr[]).center->(lx,ly);
                    (rightrole->rr[]).center->(rx,ry);
                    &UserDataLabelNode[]->l[];
                    (lx+((rx-lx) div 2),ly+((ry-ly) div 2),10,10,name)->l.new;
                    textStyle.italic->l.theText.style;
                    l.fitToText;
                    (lx+((rx-lx) div 2),ly+((ry-ly) div 2)-10)->l.center;
                    THIS(AssociationConnector)[]->l.createRegion;
                    l[]->THIS(AssociationConnector).name
                 else
                    name->(THIS(AssociationConnector).name).theText.set;
                    textStyle.italic
                      ->(THIS(AssociationConnector).name).theText.style
                if);
                private.vname->(THIS(AssociationConnector).name).visible
            if);
            (if leftRoleName[] <> none then
                leftRoleName.copy->theleftName[]
             else
                'NoName'->theLeftName[]
            if);
            (if rightRoleName[] <> none then
                rightRoleName.copy->theRightName[]
             else
                'NoName'->theRightName[]
            if);
            (if not embed then
                (if (name[] <> none ) and (not ('<<NameDecl>>'->name.equal))
                 then
                    name.copy->t[]
                 else
                    theLeftName.copy->t[]; theRightName[]->t.puttext
                if)
            if);
            (if codeChanged then
                ((leftrole->lr[]).thePatternDiagramNode).getASTNode->oldLeft[]
                  ->patterndiagrams.astUtils.getEnclosingDecl
                  ->private.makeQualName->leftQualName[];
                ((rightrole->rr[]).thePatternDiagramNode).getASTNode->oldRight[]
                  ->patterndiagrams.astUtils.getEnclosingDecl
                  ->private.makeQualName->rightQualName[];
                (((rightrole->rr[]).thePatternDiagramNode).getAstNode,
                 ((leftrole->lr[]).thePatternDiagramNode).getAstNode
                   ->patterndiagrams.astUtils.getEnclosingDecl)
                  ->getQualificationWithPath->dummyQual[];
                (leftRoleName[],rightRoleName[],theLeftName[],theRightName[],
                 leftQualName[],rightQualName[],dummyQual[])
                  ->private.getTextForCode->(t[],leftCode[],rightCode[]);
                (if not embed then
                    (if associationNode = none then
                        (((leftrole->lr[]).thePatternDiagramNode).theDiagram).
                        theParentNode->theParentNode[];
                        (theParentNode.theDiagram,t[])->private.parseAfter
                          ->parseOK;
                        (if not parseOK then
                            'Internal parse error occured - should not happen!'
                              ->alertUser;
                            leave thisOp
                        if);
                        currentFocus[]->associationNode
                     else
                        (associationNode).getAstNode->oldAssociationPattern[];
                        ((associationNode).getAstNode,t)
                          ->((associationNode).theSifEditor).parse
                          ->(parseOK,errorPos,parseErrorText[]);
                        (if not parseOK then
                            'Internal parse error - should not happen(!):'
                              ->stdErr.putline;
                            'trying to parse: '->stdErr.putline;
                            t[]->stdErr.putline;
                            'Error:'->stdErr.putline;
                            parseErrorText[]->stdErr.putline;
                            'Internal parse error occured - should not happen!'
                              ->alertUser;
                            leave thisOp
                        if)
                    if)
                 else
                    (if associationNode <> none then
                        (associationNode).getAstNode->oldAssociationPattern[]
                    if)
                if);
                (((leftrole->lr[]).thePatternDiagramNode).getAstNode,leftCode)
                  ->
                    (((leftrole->lr[]).thePatternDiagramNode).theSifEditor).
                    parse->(parseOK,errorPos,parseErrorText[]);
                (if not parseOK then
                    'Internal parse error - should not happen(!):'
                      ->stdErr.putline;
                    'trying to parse: '->stdErr.putline;
                    leftCode[]->stdErr.putline;
                    'Error:'->stdErr.putline;
                    parseErrorText[]->stdErr.putline;
                    'Internal parse error occured - should not happen!'
                      ->alertUser;
                    leave thisOp
                if);
                (((rightrole->rr[]).thePatternDiagramNode).getAstNode,rightCode)
                  ->
                    (((rightrole->rr[]).thePatternDiagramNode).theSifEditor).
                    parse->(parseOK,errorPos,parseErrorText[]);
                (if not parseOK then
                    'Internal parse error - should not happen(!):'
                      ->stdErr.putline;
                    'trying to parse: '->stdErr.putline;
                    rightCode[]->stdErr.putline;
                    'Error:'->stdErr.putline;
                    parseErrorText[]->stdErr.putline;
                    'Internal parse error occured - should not happen!'
                      ->alertUser;
                    leave thisOp
                if);
                (if not embed then
                    (oldLeft[],oldRight[],oldAssociationPattern[],
                     ((leftrole->lr[]).thePatternDiagramNode).getAstNode,
                     ((rightrole->rr[]).thePatternDiagramNode).getAstNode,
                     (associationNode).getAstNode,leftMulFrom,leftMulTo,
                     rightMulFrom,rightMulTo)
                      ->patterndiagrams.AssociationList.updateElement
                 else
                    (oldLeft[],oldRight[],oldAssociationPattern[],
                     ((leftrole->lr[]).thePatternDiagramNode).getAstNode,
                     ((rightrole->rr[]).thePatternDiagramNode).getAstNode,none ,
                     leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
                      ->patterndiagrams.AssociationList.updateElement;
                    (if oldAssociationPattern[] <> none then
                        (oldAssociationPattern[],1)
                          ->((associationNode).theSifEditor).changeFocus;
                        ((associationNode).theSifEditor).cut;
                        none ->associationNode
                    if)
                if)
            if)
         #)
   if);
   INNER redisplay;
   (leftRoleName[],leftMulFrom,leftMulTo,srolename,smul,srightside)
     ->(leftrole->lr[]).redisplay;
   (rightRoleName[],rightMulFrom,rightMulTo,drolename,dmul,drightside)
     ->(rightrole->rr[]).redisplay;
   private.isVisible->visible;
   true->repair;
   gppProp.noGlobalInteractiveMode->gppProp.globalInteractiveMode;
   (if codeChanged then autosave if);
   true->repair  

-- AssociationConnectorVisibleSet: DoPart --
do
   (if name <> none then
       (if v and (not private.vname) then  else v->(name).visible if)
   if);
   v->(leftrole->lr[]).visible;
   v->(rightrole->rr[]).visible;
   INNER set  

-- AssociationConnectorAttributesVisible: DoPart --
do
   INNER attributesVisible;
   (if v then
       ((leftrole->lr[]).thePatternDiagramNode).center->(px,py);
       (leftrole->lr[]).center->(x,y);
       (x,py)->(leftrole->lr[]).center;
       ((rightrole->rr[]).thePatternDiagramNode).center->(px,py);
       (rightrole->rr[]).center->(x,y);
       (x,py)->(rightrole->rr[]).center
    else
       (((leftrole->lr[]).thePatternDiagramNode).theDiagram).titleNode.center
         ->(px,py);
       (leftrole->lr[]).center->(x,y);
       (x,py)->(leftrole->lr[]).center;
       (((rightrole->rr[]).thePatternDiagramNode).theDiagram).titleNode.center
         ->(px,py);
       (rightrole->rr[]).center->(x,y);
       (x,py)->(rightrole->rr[]).center
   if)  

-- AssociationConnectorOnDelete: DoPart --
do
   false->repair;
   (if (leftRole <> none ) and (rightRole <> none ) then
       ((leftrole->lr[]).thePatternDiagramNode).getAstNode->anAST[];
       (if anAST[] <> none then
           (anAST[],1)
             ->
               (((leftrole->lr[]).thePatternDiagramNode).theSifEditor).
               changeFocus;
           (((leftrole->lr[]).thePatternDiagramNode).theSifEditor).cut
       if);
       (if not (THIS(AssociationConnector)## <= AggregationConnector##) then
           ((rightrole->rr[]).thePatternDiagramNode).getAstNode->anAST[];
           (if anAST[] <> none then
               (anAST[],1)
                 ->
                   (((rightrole->rr[]).thePatternDiagramNode).theSifEditor).
                   changeFocus;
               (((rightrole->rr[]).thePatternDiagramNode).theSifEditor).cut
           if);
           (if associationNode <> none then
               (associationNode).getAstNode->anAST[];
               (if anAST[] <> none then
                   (anAST[],1)->((associationNode).theSifEditor).changeFocus;
                   ((associationNode).theSifEditor).cut
               if)
           if)
       if)
    else
       'Connector is internally incomplete (due to recover?!)\ndelete connector by abstract/detail of involved classes'
         ->alertUser;
       'AssociationConnectorOnDelete: leftRole/RightRole is none?!'
         ->stdErr.putline
   if);
   INNER onDelete;
   true->repair  

-- AssociationConnectorOnReattach: DoPart --
do
   false->repair;
   (if not (THIS(AssociationConnector)## <= AggregationConnector##) then
       'Moving associations is not yet implemented'->alertUser; false->ok
   if);
   INNER onReattach;
   true->repair  

-- AssociationConnectorOnDoubleClick: DoPart --
do INNER onDoubleClick; edit  

-- AssociationConnectorOnRightMouseDown: DoPart --
do
   (if THIS(AssociationConnector)## <= AggregationConnector## then
       INNER onRightMouseDown
    else
       (if not private.thePopUp.opened then private.thePopUp.open if);
       (1,mousePos,inWindow[])->private.thePopUp.popUp
   if)  

-- AssociationConnectorOnInit: DoPart --
do
     (#
        object1,object2: ^DesignObject;
        node1,node2: ^node;
        succeded: @boolean;
        theRole: ^Role;
        lx,ly,rx,ry: @integer;
        l: ^UserDataLabelNode
     do
        (if switch[30] or switch[53] then
            'AssociationConnector onInit'->putline
        if);
        UDPrivate.UDAssociationConnector->UserDataInit;
        name.init;
        associationNode.init;
        leftRole.init;
        rightRole.init;
        embed.init;
        0->Orient;
        INNER onInit;
        (if not InitialisingSaved then
            false->repair;
            true->getEnds->(object1[],object2[]);
            (if (object1[] <> none ) and (object2[] <> none ) then
                (if (object1## <= node##) and (object2## <= node##) then
                    object1[]->node1[];
                    object2[]->node2[];
                    (if ((node1[]->BoxToNode->node1[]) <> none ) and
                    ((node2[]->BoxToNode->node2[]) <> none ) then
                        (if (node1## <= PatternDiagramNode##) and
                        (node2## <= PatternDiagramNode##) then
                            (node1[],node2[],private.name.copy,
                             private.implementation,private.leftRoleName[],
                             private.rightRoleName[],private.leftMulFrom,
                             private.leftMulTo,private.rightMulFrom,
                             private.rightMulTo,private.embed->embed)
                              ->generateCode->(succeded,left[],right[]);
                            (if not succeded then delete if);
                            
                         else
                            Delete;
                            'Source or destination is not part of a pattern diagram'
                              ->AlertUser
                        if)
                     else
                        Delete;
                        'Source or destination is not part of a pattern diagram'
                          ->AlertUser
                    if)
                 else
                    Delete;
                    'Source or destination is not part of a pattern diagram'
                      ->AlertUser
                if)
             else
                Delete
            if);
            (if succeded then
                &Role[]->theRole[];
                (private.leftRoleName[],private.leftMulFrom,private.leftMulTo,
                 left[],private.srolename,private.smul,private.srightside)
                  ->theRole.display;
                theRole[]->leftRole;
                &Role[]->theRole[];
                (private.rightRoleName[],private.rightMulFrom,
                 private.rightMulTo,right[],private.drolename,private.dmul,
                 private.drightside)->theRole.display;
                theRole[]->rightRole;
                ((leftrole->lr[]).getTopParent,leftRole,
                 (rightrole->rr[]).getTopParent,rightrole->rr[])->setEnds;
                (if not
                (THIS(AssociationConnector)## <= AggregationConnector##) then
                    (if (private.name[] <> none ) and
                    (not ('<<NameDecl>>'->private.name.equal)) then
                        (leftrole->lr[]).center->(lx,ly);
                        (rightrole->rr[]).center->(rx,ry);
                        &UserDataLabelNode[]->l[];
                        (lx+((rx-lx) div 2),ly+((ry-ly) div 2),10,10,
                         private.name)->l.new;
                        textStyle.italic->l.theText.style;
                        l.fitToText;
                        (lx+((rx-lx) div 2),ly+((ry-ly) div 2)-10)->l.center;
                        THIS(AssociationConnector)[]->l.createRegion;
                        l[]->name;
                        private.vname->(name).visible
                    if);
                    private.isVisible->visible
                 else
                    (if (not gppProp.references) or
                    (left.theDiagram = right.theDiagram) then
                        false->visible
                    if)
                if);
                (if not gppProp.showAttributes then
                    false->attributesVisible
                if)
            if);
            true->repair;
            gppProp.noGlobalInteractiveMode->gppProp.globalInteractiveMode;
            statusbar.reset;
            autosave
        if)
     #)  

-- AssocConnectorDump: DoPart --
do
   '****name****'->putline;
   (if name <> none then
       (name).theText.get->t; t[]->putline
    else
       ' is NONE!'->putline
   if);
   '****embed****\n%s\n'
     ->putformat (# t: @text do embed->t.putBoolean; t[]->s #);
   '****associationNode****'->putline;
   (if associationNode <> none then
       (associationNode).id->putint; newline
   if);
   '****leftRole****'->putline;
   (if leftRole <> none then
       (leftrole->lr[]).dump
    else
       ' is NONE!'->putline
   if);
   '****rightRole****'->putline;
   (if rightRole <> none then
       (rightrole->rr[]).dump
    else
       ' is NONE!'->putline
   if);
   INNER dump  

-- AssociationConnectorPrivate: Descriptor --
(#
   name,description,leftRoleName,rightRoleName: ^text;
   implementation,leftMulFrom,leftMulTo,rightMulFrom,rightMulTo,kind: @integer;
   embed,isVisible,vname,SRoleName,SMul,SRightSide,DRoleName,DMul,DRightSide:
     @boolean;
   makeQualName:
     (#
        theDecl: ^betaGram.AttributeDecl;
        t: ^text;
        theNames: ^betaGram.Names;
        theNameDcl: ^betaGram.NameDcl;
        anAST: ^mps.ast
     enter theDecl[]
     do
        theDecl.getSon1->theNames[];
        theNames.getSon1->theNameDcl[];
        theNameDcl.getNameDecl->anAST[];
        (if anAST.kind = mps.kinds.unExpanded then
            '<<NameAppl>>'->t[]
         else
            theNameDcl.getText->t[]
        if)
     exit t[]
     #);
   isManyToMany:
     (# 
     exit ((leftMulTo = - 1) or (leftMulTo > 1)) and
     ((rightMulTo = - 1) or (rightMulTo > 1))
     #);
   isOneToMany:
     (# 
     exit ((leftMulTo = 0) or (leftMulTo = 1)) and
     ((rightMulTo = - 1) or (rightMulTo > 1))
     #);
   isManyToOne:
     (# 
     exit ((leftMulTo = - 1) or (leftMulTo > 1)) and
     ((rightMulTo = 0) or (rightMulTo = 1))
     #);
   isOneToOne:
     (# 
     exit ((leftMulTo = 0) or (leftMulTo = 1)) and
     ((rightMulTo = 0) or (rightMulTo = 1))
     #);
   parseAfter:
     (#
        theListDiagram: ^ListDiagram;
        parseText: ^text;
        theNonTerminalNode: ^theListDiagram.NonTerminalNode;
        theSlotNode: ^theListDiagram.slotNode;
        anAST: ^mps.ast;
        ok: @boolean;
        errorPos: @integer;
        parseErrorText: ^Text
     enter (theListDiagram[],parseText[])
     do
        currentFocus[]->oldFocus[];
        (theListDiagram.LocalNodes.last).elm[]->currentFocus[]->currentObject;
        currentFocus.getASTNode->anAST[];
        (if anAST[] <> none then
            (anAST[],1)->(currentFocus.theSifEditor).changeFocus;
            (currentFocus.theSifEditor).after
         else
            (if currentFocus## <= theListDiagram.nonterminalNode## then
                currentFocus[]->theNonTerminalNode[];
                (theNonTerminalNode.unExp[],1)
                  ->(currentFocus.theSifEditor).changeFocus
             else
                (if currentFocus## <= theListDiagram.slotNode## then
                    currentFocus[]->theSlotNode[];
                    (theSlotNode.unExp[],1)
                      ->(currentFocus.theSifEditor).changeFocus;
                    (currentFocus.theSifEditor).after
                if)
            if)
        if);
        (if currentFocus## <= theListDiagram.NonTerminalNode## then
            currentFocus[]->theNonTerminalNode[];
            (theNonTerminalNode.unExp[],parseText)
              ->(theNonTerminalNode.theSifEditor).parse
              ->(ok,errorPos,parseErrorText[]);
            (if not ok then
                'Internal parse error - should not happen(!):'->stdErr.putline;
                'trying to parse: '->stdErr.putline;
                parseText[]->stdErr.putline;
                'Error:'->stdErr.putline;
                parseErrorText[]->stdErr.putline
            if)
         else
            'unexpected last node in diagram %s\n'
              ->stdErr.putformat (#  do theListDiagram.titletext[]->s #)
        if)
     exit ok
     #);
   getLastAST:
     (#
        lastNode: ^PatternDiagramNode;
        lastAST: ^mps.ast;
        theListDiagram: ^ListDiagram;
        theNonTerminalNode: ^theListDiagram.NonTerminalNode
     enter lastNode[]
     do
        lastNode.getAstNode->lastAST[];
        (if lastAST[] = none then
            lastNode.theDiagram->theListDiagram[];
            (if lastNode## <= theListDiagram.NonterminalNode## then
                lastNode[]->theNonTerminalNode[];
                theNonTerminalNode.unexp[]->lastAST[]
             else
                'No AST for last node??'->stdErr.putline
            if)
        if)
     exit lastAST[]
     #);
   getTextForCode:
     (#
        leftRoleName,rightRoleName,theLeftName,theRightName,leftQualName,
          rightQualName,dummyQual,t,leftCode,rightCode: ^Text;
        index: @integer
     enter
     (leftRoleName[],rightRoleName[],theLeftName[],theRightName[],
      leftQualName[],rightQualName[],dummyQual[])
     do
        (if not embed then
            (if (name[] <> none ) and (not ('<<NameDecl>>'->name.equal)) then
                name.copy->t[]
             else
                theLeftName.copy->t[]; theRightName[]->t.puttext
            if)
        if);
        (if rightRoleName[] <> none then
            rightRoleName.copy->leftCode[]
         else
            'the'->(theRightName.copy).prepend->leftCode[]
        if);
        (if leftRoleName[] <> none then
            leftRoleName.copy->rightCode[]
         else
            'the'->(theLeftName.copy).prepend->rightCode[]
        if);
        impl:
        (if implementation
         // gppProp.noimplementation then
            (if not embed then
                ':OneToOneAssociation(# leftType::< '->t.puttext;
                leftQualName[]->t.puttext;
                '; rightType::< '->t.puttext;
                rightQualName[]->t.puttext;
                ' #) '->t.puttext
             else
                ':@AssociationOne(# element:: '->leftCode.puttext;
                ':@AssociationOne(# element:: '->rightCode.puttext
            if)
         // gppProp.list then
            (if true
             // private.isManyToMany then
                (if not embed then
                    ':ManyToManyAssociation(# leftType::< '->t.puttext;
                    leftQualName[]->t.puttext;
                    '; rightType::< '->t.puttext;
                    rightQualName[]->t.puttext;
                    ' #) '->t.puttext
                 else
                    ':@AssociationMany(# element:: '->leftCode.puttext;
                    ':@AssociationMany(# element:: '->rightCode.puttext
                if)
             // private.isOneToMany then
                (if not embed then
                    ':OneToManyAssociation(# oneType::< '->t.puttext;
                    leftQualName[]->t.puttext;
                    '; ManyElmType::< '->t.puttext;
                    rightQualName[]->t.puttext;
                    ' #) '->t.puttext
                 else
                    ':@AssociationMany(# element:: '->leftCode.puttext;
                    ':@AssociationOne(# element:: '->rightCode.puttext
                if)
             // private.isManyToOne then
                (if not embed then
                    ':OneToManyAssociation(# oneType::< '->t.puttext;
                    rightQualName[]->t.puttext;
                    '; ManyElmType::< '->t.puttext;
                    leftQualName[]->t.puttext;
                    ' #) '->t.puttext
                 else
                    ':@AssociationOne(# element:: '->leftCode.puttext;
                    ':@AssociationMany(# element:: '->rightCode.puttext
                if)
             // private.isOneToOne then
                (if not embed then
                    ':OneToOneAssociation(# leftType::< '->t.puttext;
                    leftQualName[]->t.puttext;
                    '; rightType::< '->t.puttext;
                    rightQualName[]->t.puttext;
                    ' #) '->t.puttext
                 else
                    ':@AssociationOne(# element:: '->leftCode.puttext;
                    ':@AssociationOne(# element:: '->rightCode.puttext
                if)
            if)
         else
            gppProp.list->implementation;
            'unknown value for implementation: %i - choosing default\n'
              ->stderr.putformat (#  do implementation->i #);
            restart impl
        if);
        (if not embed then
            ':^'->leftCode.puttext;
            (if (name[] <> none ) and (not ('<<NameDecl>>'->name.equal)) then
                name[]->leftCode.puttext
             else
                theLeftName[]->leftCode.puttext;
                theRightName[]->leftCode.puttext
            if);
            ':^'->rightCode.puttext;
            '.'->dummyQual.findAll (#  do inx->index #);
            (index+1,dummyQual.length)->dummyQual.delete;
            dummyQual[]->rightCode.puttext;
            (if (name[] <> none ) and (not ('<<NameDecl>>'->name.equal)) then
                name[]->rightCode.puttext
             else
                theLeftName[]->rightCode.puttext;
                theRightName[]->rightCode.puttext
            if)
         else
            rightQualName[]->leftCode.puttext;
            ' #)'->leftCode.puttext;
            leftQualName[]->rightCode.puttext;
            ' #)'->rightCode.puttext
        if)
     exit (t[],leftCode[],rightCode[])
     #);
   thePopUp: @theUI.menu
     (#
        opened: @boolean;
        editItem: @menuItem
          (# eventHandler::  (# onSelect::  (#  do edit #);  #); 
          #);
        sep1: @separator;
        hideItem: @menuItem
          (#
             eventHandler:: 
               (#
                  onSelect:: 
                    (# 
                    do
                       (false,THIS(AssociationConnector).private.name[],
                        implementation,leftRoleName[],rightRoleName[],
                        leftMulFrom,leftMulTo,rightMulFrom,rightMulTo,embed,
                        description[],false->isVisible,vname,srolename,smul,
                        srightside,drolename,dmul,drightside)->Redisplay
                    #);
                  
               #);
             
          #);
        nameItem: @menuItem
          (#
             eventHandler:: 
               (#
                  onStatus:: 
                    (# 
                    do
                       vname->checked;
                       (THIS(AssociationConnector).name <> none )->value
                    #);
                  onSelect:: 
                    (# 
                    do
                       (false,THIS(AssociationConnector).private.name[],
                        implementation,leftRoleName[],rightRoleName[],
                        leftMulFrom,leftMulTo,rightMulFrom,rightMulTo,embed,
                        description[],true,not checked->vname,srolename,smul,
                        srightside,drolename,dmul,drightside)->Redisplay
                    #);
                  
               #);
             
          #);
        leftRoleNameItem: @menuItem
          (#
             eventHandler:: 
               (#
                  onStatus:: 
                    (# t: ^text
                    do
                       (((leftRole->lr[]).thePatternDiagramNode).theDiagram).
                       titletext.copy->t[];
                       ' Role'->t.append;
                       t[]->name;
                       srolename->checked;
                       (rightRole->rr[]).name <> none ->value
                    #);
                  onSelect:: 
                    (# 
                    do
                       (false,THIS(AssociationConnector).private.name[],
                        implementation,leftRoleName[],rightRoleName[],
                        leftMulFrom,leftMulTo,rightMulFrom,rightMulTo,embed,
                        description[],true,vname,not checked->srolename,smul,
                        srightside,drolename,dmul,drightside)->Redisplay
                    #);
                  
               #);
             
          #);
        rightRoleNameItem: @menuItem
          (#
             eventHandler:: 
               (#
                  onStatus:: 
                    (# t: ^text
                    do
                       (((rightRole->rr[]).thePatternDiagramNode).theDiagram).
                       titletext.copy->t[];
                       ' Role'->t.append;
                       t[]->name;
                       drolename->checked;
                       (rightRole->rr[]).name <> none ->value
                    #);
                  onSelect:: 
                    (# 
                    do
                       (false,THIS(AssociationConnector).private.name[],
                        implementation,leftRoleName[],rightRoleName[],
                        leftMulFrom,leftMulTo,rightMulFrom,rightMulTo,embed,
                        description[],true,vname,srolename,smul,srightside,
                        not checked->drolename,dmul,drightside)->Redisplay
                    #);
                  
               #);
             
          #);
        leftMulItem: @menuItem
          (#
             eventHandler:: 
               (#
                  onStatus:: 
                    (# t: ^text
                    do
                       (((leftRole->lr[]).thePatternDiagramNode).theDiagram).
                       titletext.copy->t[];
                       ' Role Multiplicity'->t.append;
                       t[]->name;
                       smul->checked
                    #);
                  onSelect:: 
                    (# 
                    do
                       (false,THIS(AssociationConnector).private.name[],
                        implementation,leftRoleName[],rightRoleName[],
                        leftMulFrom,leftMulTo,rightMulFrom,rightMulTo,embed,
                        description[],true,vname,srolename,not checked->smul,
                        srightside,drolename,dmul,drightside)->Redisplay
                    #);
                  
               #);
             
          #);
        rightMulItem: @menuItem
          (#
             eventHandler:: 
               (#
                  onStatus:: 
                    (# t: ^text
                    do
                       (((rightRole->rr[]).thePatternDiagramNode).theDiagram).
                       titletext.copy->t[];
                       ' Role Multiplicity'->t.append;
                       t[]->name;
                       dmul->checked
                    #);
                  onSelect:: 
                    (# 
                    do
                       (false,THIS(AssociationConnector).private.name[],
                        implementation,leftRoleName[],rightRoleName[],
                        leftMulFrom,leftMulTo,rightMulFrom,rightMulTo,embed,
                        description[],true,vname,srolename,smul,srightside,
                        drolename,not checked->dmul,drightside)->Redisplay
                    #);
                  
               #);
             
          #);
        sep2: @separator;
        leftAttachItem: @menuItem
          (#
             eventHandler:: 
               (#
                  onStatus:: 
                    (# t: ^text
                    do
                       'Attach '->t[];
                       (((leftRole->lr[]).thePatternDiagramNode).theDiagram).
                       titletext[]->t.append;
                       ' Role Right'->t.append;
                       t[]->name;
                       srightside->checked
                    #);
                  onSelect:: 
                    (# 
                    do
                       (false,THIS(AssociationConnector).private.name[],
                        implementation,leftRoleName[],rightRoleName[],
                        leftMulFrom,leftMulTo,rightMulFrom,rightMulTo,embed,
                        description[],true,vname,srolename,smul,
                        not checked->srightside,drolename,dmul,drightside)
                         ->Redisplay
                    #);
                  
               #);
             
          #);
        rightAttachItem: @menuItem
          (#
             eventHandler:: 
               (#
                  onStatus:: 
                    (# t: ^text
                    do
                       'Attach '->t[];
                       (((rightRole->rr[]).thePatternDiagramNode).theDiagram).
                       titletext[]->t.append;
                       ' Role Left'->t.append;
                       t[]->name;
                       not drightside->checked
                    #);
                  onSelect:: 
                    (# 
                    do
                       (false,THIS(AssociationConnector).private.name[],
                        implementation,leftRoleName[],rightRoleName[],
                        leftMulFrom,leftMulTo,rightMulFrom,rightMulTo,embed,
                        description[],true,vname,srolename,smul,srightside,
                        drolename,dmul,checked->drightside)->Redisplay
                    #);
                  
               #);
             
          #);
        eventHandler::  (# onSelect::  (#  do  #) #);
        open::< 
          (# 
          do
             true->opened;
             editItem.open;
             'Edit...'->editItem.name;
             editItem[]->append;
             sep1.open;
             sep1[]->append;
             hideitem.open;
             'Hide'->hideItem.name;
             hideItem[]->append;
             nameItem.open;
             'Name'->nameItem.name;
             nameItem[]->append;
             leftRoleNameItem.open;
             leftRoleNameItem[]->append;
             rightRoleNameItem.open;
             rightRoleNameItem[]->append;
             leftMulItem.open;
             leftMulItem[]->append;
             rightMulItem.open;
             rightMulItem[]->append;
             sep2.open;
             sep2[]->append;
             leftAttachItem.open;
             leftAttachItem[]->append;
             rightAttachItem.open;
             rightAttachItem[]->append;
             patterndiagrams.AssociationList.find
               (#
                  predicate:: 
                    (# anAST: ^mps.ast
                    do
                       ((rightrole->rr[]).thePatternDiagramNode).getASTNode
                         ->anAST[];
                       (current.left =
                        (((leftrole->lr[]).thePatternDiagramNode).getASTNode).
                        index) and
                       ((((leftrole->lr[]).thePatternDiagramNode).getASTNode).
                        frag.fullname->current.leftFrag.equal) and
                       (current.right = anAST.index) and
                       (anAST.frag.fullname->current.rightFrag.equal)->value;
                       (if associationNode <> none then
                           (current.associationPattern =
                            ((associationNode).getAstNode).index) and
                           (((associationNode).getAstNode).frag.fullname
                              ->current.associationFrag.equal) and value->value
                       if)
                    #);
                  notFound:: 
                    (#
                       ok: @integer;
                       anAST: ^mps.ast;
                       leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer;
                       tryGetMultiplicities:
                         (#
                            anAST: ^mps.ast;
                            leftMulFrom,leftMulTo,rightMulFrom,rightMulTo:
                              @integer;
                            theAssociationPattern: ^betaGram.PatternDecl;
                            theObjectDescriptor: ^betaGram.ObjectDescriptor;
                            thePrefix: ^betaGram.prefix;
                            theNameApl: ^betaGram.NameApl;
                            prefixName: ^text
                         enter anAST[]
                         do
                            (1,1,1,1)
                              ->(leftMulFrom,leftMulTo,rightMulFrom,rightMulTo);
                            (if anAST.symbol = betaGram.PatternDecl then
                                anAST[]->theAssociationPattern[];
                                theAssociationPattern.getObjectDescriptor
                                  ->theObjectDescriptor[];
                                theObjectDescriptor.getPrefixOpt->anAST[];
                                (if anAST.kind = mps.kinds.interior then
                                    anAST[]->thePrefix[];
                                    thePrefix.getAttributeDenotation->anAST[];
                                    (if anAST.symbol = betaGram.NameApl then
                                        anAST[]->theNameApl[];
                                        theNameApl.getNameAppl->anAST[];
                                        (if anAST.kind <> mps.kinds.unExpanded
                                         then
                                            theNameApl.getText->prefixName[];
                                            (if true
                                             //
                                             ('OneToOneAssociation'
                                                ->prefixName.equalNCS) then
                                                (1,1,1,1)
                                                  ->
                                                    (leftMulFrom,leftMulTo,
                                                     rightMulFrom,rightMulTo)
                                             //
                                             ('OneToManyAssociation'
                                                ->prefixName.equalNCS) then
                                                (1,1,- 1,- 1)
                                                  ->
                                                    (leftMulFrom,leftMulTo,
                                                     rightMulFrom,rightMulTo)
                                             //
                                             ('ManyToManyAssociation'
                                                ->prefixName.equalNCS) then
                                                (- 1,- 1,- 1,- 1)
                                                  ->
                                                    (leftMulFrom,leftMulTo,
                                                     rightMulFrom,rightMulTo)
                                            if)
                                        if);
                                        
                                    if)
                                if)
                            if)
                         exit (leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
                         #)
                    do
                       ('Association Edit',
                        'The association code has been edited in Sif,\nCheck the program to insure consistency?\n- "No" will launch the association dialog\nwith settings that are as consistent as\npossible with the code.\n')
                         ->promptForBoolean->ok;
                       (if ok
                        // yes then
                           ((leftrole->lr[]).thePatternDiagramNode).getAstNode
                             ->anAST[];
                           (if anAST[] <> none then
                               anAST.frag.father->callChecker
                           if)
                        // no then
                           getValuesFromCode
                             ->
                               (THIS(AssociationConnector).private.name[],
                                leftRoleName[],rightRoleName[],implementation,
                                embed);
                           (if associationNode <> none then
                               (associationNode).getAstNode
                                 ->tryGetMultiplicities
                                 ->
                                   (leftMulFrom,leftMulTo,rightMulFrom,
                                    rightMulTo)
                            else
                               (1,1,1,1)
                                 ->
                                   (leftMulFrom,leftMulTo,rightMulFrom,
                                    rightMulTo)
                           if)
                        // cancel then
                           
                       if)
                    #)
               do
                  getValuesFromCode
                    ->
                      (THIS(AssociationConnector).private.name[],leftRoleName[],
                       rightRoleName[],implementation,embed);
                  current.leftmulfrom->leftmulfrom;
                  current.leftmulto->leftmulto;
                  current.rightmulfrom->rightmulfrom;
                  current.rightmulto->rightmulto
               #);
             (if THIS(AssociationConnector).name <> none then
                 (THIS(AssociationConnector).name).visible->vname
             if);
             (if (leftRole->lr[]).name <> none then
                 (lr.name).visible->srolename
             if);
             (lr.multiplicity).visible->smul;
             lr.attachRight->srightside;
             (if (rightRole->rr[]).name <> none then
                 (rr.name).visible->drolename
             if);
             (rr.multiplicity).visible->dmul;
             rr.attachRight->drightside
          #)
     #)
#)  

