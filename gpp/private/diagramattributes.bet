ORIGIN '../gppinterface';
INCLUDE '~beta/containers/list'
        '~beta/containers/sets'
        '~beta/containers/arrayContainer'
        '~beta/guienv/guienv'
        '../prettyprintersetup'
        '../propertydiagrams'
        'userdataprivate';
BODY 'gppinterfacebody'
     'diagrambody'
     'patterndiagrambody'
     'abstractnodebody'
     'fragmentnodebody'
     'marknodebody'
     'simplenodebody'
     'nonterminalnodebody'
     'patterndiagramsbody'
     'slotnodebody';
(* This fragment group defines patterns visible to all bodies,
 * but not visible in the interface
 *)
(* This fragment group defines patterns visible to all bodies,
 * but not visible in the interface
 *)
(* This fragment group defines patterns visible to all bodies,
 * but not visible in the interface
 *)
(* This fragment group defines patterns visible to all bodies,
 * but not visible in the interface
 *)
-- OADPageLib: Attributes --
scrollIntoView:
  (# theObject: ^designObject; 
  enter theObject[]
  do
     (if doScrollIntoView then
         theObject[]->currentObject (#  do true->autoPan #); 
     if);
     
  #);
GetPrefix:
  (#
     theDescriptor: ^betaGram.ObjectDescriptor;
     tempAst: ^mps.ast;
     pref: ^betaGram.prefix;
     ad: ^betaGram.attributeDenotation;
     thisPrefix: ^betaGram.ObjectDescriptor;
     
  enter theDescriptor[]
  do
     (if switch[50] then
         'GetPrefix: theDescriptor=%i\n'
           ->putformat (#  do theDescriptor.index->i #)
     if);
     theDescriptor.getPrefixOpt->tempAst[];
     (if tempAst.kind
      // mps.kinds.interior then
         tempAst[]->pref[];
         pref.getAttributeDenotation->tempAst[];
         (if tempAst.kind
          // mps.kinds.interior then
             tempAst[]->ad[]; ad.findDescriptor->thisPrefix[]; 
         if);
         
     if);
     
  exit thisPrefix[]
  #);
DiagramList: ContainerList (* list of diagrams on a page *)
  (#
     element::<  (# index: @Integer; frag: ^text; e: ^Diagram #);
     myFind: find
       (#
          i: @Integer;
          f: ^text;
          predicate::< 
            (# 
            do
               (if f[] <> none then
                   (if current.frag[] <> none then
                       (i = current.index) and (current.frag[]->f.equal)->value
                   if)
                else
                   (i = current.index)->value
               if)
            #);
          
       enter (i,f[])
       #);
     findPD:
       (# aPD: ^Element; aDiagram: ^Diagram; 
       enter myFind->aPD[]
       do (if aPD[] <> none then aPD.e[]->aDiagram[];  if); 
       exit aDiagram[]
       #);
     insertPD:
       (# aPD: ^Element; index: @Integer; frag: ^text; e: ^Diagram; 
       enter (index,frag[],e[])
       do
          &Element[]->aPD[];
          (index,frag[],e[])->(aPD.index,aPD.frag[],aPD.e[]);
          aPD[]->append;
          
       #);
     deletePD: (#  enter myFind->at->delete #);
     deleteProp:
       (#
          findProp:
            (# p: ^Diagram; aPD: ^Element; 
            enter p[]
            do
               scanner: scan
                 (# 
                 do
                    (if current.e[] = p[] then
                        current[]->aPD[]; leave scanner
                    if);
                    
                 #);
               
            exit aPD[]
            #);
          
       enter findProp->at->delete
       #);
     GetSubPatternDiagrams:
       (#
          theDiagram,aPatternDiagram: ^PatternDeclDiagram;
          aList: ^DiagramList;
          
       enter theDiagram[]
       do
          &DiagramList[]->aLIst[];
          scan
            (# 
            do
               (if current.e## <= PatternDeclDiagram##
                // true then
                   current.e[]->aPatternDiagram[];
                   (if aPatternDiagram.thePrefix <> none
                    // true then
                       (if
                       aPatternDiagram.thePrefix
                         ->(theDiagram.theDescriptor).equal
                        // true then current[]->aList.append; 
                       if)
                   if)
               if)
            #);
          
       exit aList[]
       #);
     GetSortableSubPatternDiagrams:
       (#
          theDiagram,aPatternDiagram: ^PatternDeclDiagram;
          aList: ^SortableDiagramList;
          
       enter theDiagram[]
       do
          &SortableDiagramList[]->aList[];
          scan
            (# 
            do
               (if current.e## <= PatternDeclDiagram## then
                   current.e[]->aPatternDiagram[];
                   (if aPatternDiagram.thePrefix <> none then
                       (if
                       aPatternDiagram.thePrefix
                         ->(theDiagram.theDescriptor).equal then
                           current.e[]->aList.insert; 
                       if)
                   if)
               if)
            #);
          
       exit aList[]
       #);
     scanPatternDiagrams: scan
       (# thisDiagram: ^PatternDeclDiagram; 
       do
          (if current.e## <= PatternDeclDiagram##
           // true then current.e[]->thisDiagram[]; INNER ; 
          if)
       #);
     scanFragmentDiagrams: scan
       (# thisDiagram: ^fragmentDiagram; 
       do
          (if current.e## <= FragmentDiagram##
           // true then current.e[]->thisDiagram[]; INNER ; 
          if)
       #);
     scanPropertyDiagrams: scan
       (# thisDiagram: ^SimplePropertyDiagram; 
       do
          (if current.e## <= SimplePropertyDiagram##
           // true then current.e[]->thisDiagram[]; INNER ; 
          if)
       #);
     dump:
       (# 
       do
          'Diagram list:'->putline;
          scan
            (# 
            do
               ' ('->puttext;
               current.index->putint;
               ', '->puttext;
               (if current.frag[] <> none then
                   current.frag[]->puttext
                else
                   'none'->puttext
               if);
               ', '->puttext;
               current.e.titleText[]->puttext;
               ')'->puttext
            #);
          newline;
          newline
       #);
     
  #);
(* LIST HANDLING *)
SortableDiagramList: ArrayContainer
  (#
     currentInx: @integer;
     element::< Diagram;
     less::< 
       (# lx,ly,rx,ry: @integer
       do
          left.titleNode.center->(lx,ly);
          right.titleNode.center->(rx,ry);
          lx < rx->value
       #);
     insert:
       (# elm: ^element
       enter elm[]
       do
          currentInx+1->currentInx;
          (if currentInx > capacity then capacityExtend if);
          (elm[],currentInx)->put
       #);
     sort: (#  do (if currentInx > 0 then currentInx->quickSort if) #)
  #);
  

-- DiagramLib: Attributes --
DisplayAst:
  (# anAST: ^MPS.AST; pos: @Point; 
  enter (anAST[],pos)
  do <<SLOT DisplayAST:Descriptor>>; 
  exit pos
  #);
scanAttributeDecls:
  (#
     theAtt: ^betaGram.Attributes;
     anAst: ^mps.ast;
     ndl: ^betaGram.names;
     unExp: ^mps.unExpanded;
     thisAttribute:<
       (# nd: ^betaGram.nameDcl
       enter nd[]
       do INNER
       #);
     thisUnExp:<
       (# unExp: ^mps.unExpanded
       enter unExp[]
       do INNER
       #);
     thisOptional:<
       (# opt: ^mps.Optional
       enter opt[]
       do INNER
       #);
     thisSlot:<
       (# theSlot: ^mps.SlotDesc
       enter theSlot[]
       do INNER
       #);
     
  enter theAtt[]
  do
     (if switch[70]
      // true then
         'scanAttributeDecls'->screen.putline; 
     if);
     theAtt.scan
       (# att: ^betaGram.attributeDecl
       do
          (if switch[70]
           // true then '*'->screen.put
          if);
          (if current.kind
           // mps.kinds.interior then
              current[]->att[];
              att.getSon1->anAst[];
              (if switch[70]
               // true then
                  'interior: '->screen.puttext;
                  anAst.symbol->screen.putint;
                  screen.newline;
                  
              if);
              (if anAst.symbol
               // betaGram.names then
                  anAst[]->ndl[];
                  ndl.scan
                    (# 
                    do current[]->thisAttribute
                    #)
              if)
           // mps.kinds.unExpanded then
              (if switch[70]
               // true then
                  'unExpanded: '->screen.puttext; 
              if);
              current[]->unExp[];
              (if unExp.isSlot
               // true then
                  (if switch[70] // true then 'Slot'->screen.putline;  if);
                  unExp.theSlot->thisSlot;
                  
               else
                  (if switch[70] // true then screen.newline;  if);
                  unExp[]->thisUnExp;
                  
              if)
           // mps.kinds.optional then
              (if switch[70] // true then 'optional'->screen.putline;  if);
              current[]->thisOptional;
              
          if)
       #);
     (if switch[70] // true then 'DONE'->screen.putline if);
     
  #);
CountAttributes:
  (#
     obj: ^betaGram.ObjectDescriptor;
     main: ^betaGram.MainPart;
     a: ^MPS.AST;
     i: @Integer;
     
  enter obj[]
  do
     (if switch[70] // true then 'CountAttributes '->screen.puttext if);
     (if obj[] <> none
      // true then
         obj.getMainPart->main[];
         main.getAttributes->a[];
         (if a[]
          // none then
             'Attribute error: cannot get attributes from descriptor: '
               ->puttext;
             
          else
             (if a.kind
              // mps.kinds.interior then
                 (if switch[70]
                  // true then 'scanning '->screen.puttext
                 if);
                 a[]
                   ->scanAttributeDecls
                     (#
                        thisAttribute::<  (#  do i+1->i #);
                        thisOptional::<  (#  do i+1->i #);
                        thisUnExp::<  (#  do i+1->i #);
                        
                     #);
                 
             if)
         if)
     if);
     (if switch[70] // true then screen.newline if);
     
  exit i
  #);
CheckKeyWord:
  (#
     node: ^mps.ast;
     keyword: ^text;
     found: @boolean;
     theCom: ^mps.comment;
     theComText,nextWord: ^text;
     
  enter (node[],keyword[])
  do
     (if node.hasComment
      // true then
         node.getComment->theCom[];
         theCom.getText->theComText[];
         theComText.reset;
         search:
           (# 
           do
              theComText.getAtom->nextWord[];
              (if true
               // keyWord[]->nextWord.equal then true->found; 
               else
                  (if theComText.eos // false then restart search if); 
              if);
              
           #);
         
     if);
     
  exit found
  #);
isDescriptorDiagram:
  (#
     theOADDiagram: ^OADDiagram;
     desc: ^betaGram.ObjectDescriptor;
     anAST: ^MPS.AST;
     value: @Boolean
  enter theOADDiagram[]
  do
     theOADDiagram.theDescriptor->desc[];
     (if desc[] <> none then
         desc.father->anAST[]; (if anAST.father = none then true->value if)
     if)
  exit value
  #);
makeNonTerminalSymbol:
  (# symbolName: ^Text
  enter symbolName[]
  do '<<'->symbolName.prepend; '>>'->symbolName.append
  exit symbolName[]
  #);
makeRemote:
  (#
     anAST: ^MPS.AST;
     rem: ^betaGram.remote;
     unExp: ^mps.unexpanded;
     na: ^betaGram.nameApl;
     t: ^text
  enter anAST[]
  do
     &Text[]->t[];
     anAST[]->rem[];
     rem.getAttributeDenotation->anAST[];
     (if anAST.kind = mps.kinds.unExpanded then
         anAST[]->unExp[];
         unExp.NonTerminalSymbol->betaGram.symbolToName->makeNonTerminalSymbol
           ->t.append;
         '.'->t.append
      else
         (if anAST.symbol
          // betaGram.NameApl then
             anAST[]->na[];
             na.getNameAppl->anAST[];
             (if anAST.kind = mps.kinds.unExpanded then
                 '<NameAppl>.'->t.append
              else
                 na.gettext->t.append; '.'->t.append
             if)
          // betaGram.Remote then
             anAST[]->makeRemote->t.append; '.'->t.append
         if)
     if);
     rem.getNameApl->na[];
     na.getNameAppl->anAST[];
     (if anAST.kind = mps.kinds.unExpanded then
         '<NameAppl>'->t.append
      else
         na.gettext->t.append
     if)
  exit t[]
  #);
(****************** DIAGRAM NODES ************************)
AbstractNode: PatternDiagramNode
  (#
     theName: @ReferenceUserData (# Type::< Text #);
     currentDecomposDiagram: @DiagramReferenceUserData
       (# Type::< PatternDiagram #);
     decomposDiagrams: @containerlist (# element::< PatternDiagram #);
     PatternDiagReference: LocalNodesReferenceUserData
       (# Type::< PatternDiagram #);
     onSelect::<  (#  <<SLOT AbstractNodeOnSelect:DoPart>> #);
     onRemove::<
     (* called when THIS(DiagramNode) is deleted *) 
       (#  do <<SLOT AbstractNodeRemove:Descriptor>>;  #);
     Display::< 
       (# t: @Text; pos: @Point; 
       enter pos
       do
          <<SLOT AbstractNodeDisplay:Descriptor>>;
          
       #);
     Redisplay::< 
       (# t: @Text;  do <<SLOT AbstractNodeRedisplay:Descriptor>>;  #);
     ConcludeDisplay::< 
       (# 
       do
          INNER ;
          <<SLOT AbstractNodeConcludeDisplay:Descriptor>>;
          
       #);
     detail::< 
       (# theAST: ^MPS.AST (* the AST to be detailed *)
       do <<SLOT AbstractNodeDetail:Descriptor>>; 
       #);
     detailRecursively::< 
       (# 
       <<SLOT AbstractNodeDetailRecursively:DoPart>>
       #);
     overview::<  (#  <<SLOT AbstractNodeOverview:DoPart>> #);
     abstract::<
     (* if detailed then abstract the decompos diagram *) 
       (#  do <<SLOT AbstractNodeAbstract:Descriptor>>;  #);
     abstractRecursively::< 
       (# 
       <<SLOT AbstractNodeAbstractRecursively:DoPart>>
       #);
     abstractedFromDiagramBelow::<
     (* when THIS(DiagramNode) has been abstrated from a diagram below *) 
       (# 
       do <<SLOT AbstractNodeAbstractedFromDiagramBelow:Descriptor>>; 
       #);
     hasAttributes:
       @BooleanUserData;
     CheckForAttributes:< (#  do INNER exit hasAttributes #);
     onInit::<  (#  <<SLOT AbstractNodeOnInit:DoPart>> #);
     dump::< 
       (# 
       do
          <<SLOT AbstractNodeDump:Descriptor>>;
          INNER
       #)
  #);
(******************** For FragmentDiagrams *********************)
FragmentNode: AbstractNode
  (#
     theFragment: @FragReferenceUserData (# Type::< mps.FragmentForm #);
     theRoot: @ASTReferenceUserData (# type::< mps.ast #);
     sifEditorInstance: ^SifEditor;
     display::< 
       (# 
       enter theFragment
       do <<SLOT FragmentNodeDisplay:Descriptor>>; 
       #);
     redisplay::< 
       (# 
       enter theFragment
       do
          <<SLOT FragmentNodeRedisplay:Descriptor>>;
          
       #);
     ConcludeDisplay::<  (#  do INNER #);
     onDoubleClick::< 
       (# doneInInner: @Boolean
       do
          INNER ;
          (if not doneInInner then false->IndicateSelection; detail if)
       #);
     detail::<  (#  do INNER ; <<SLOT FragmentNodeDetail:Descriptor>> #);
     GetGroup::< 
       (# fd: ^FragmentDiagram; 
       do
          theDiagram->fd[];
          fd.theGroup->fg[];
          
       #);
     GetFragment::< 
       (#  do theFragment->f[];  #);
     theSifEditor::< 
       (# 
       do
          (if se[] = none then
              sifEditorInstance[]->se[]
           else
              se[]->sifEditorInstance[]
          if)
       #);
     CheckForAttributes::<  (#  do true->hasAttributes #);
     onInit::< 
       (# 
       do
          UDPrivate.UDFragmentNode->UserDataInit;
          theRoot.Init;
          theFragment.Init;
          INNER
       #);
     dump::<  (#  do <<SLOT FragmentNodeDump:Descriptor>>;  #);
     
  #);
DoPartNode: FragmentNode
  (#
     display::< 
       (#  do ': DoPart'->t.append;  #);
     onDoubleClick::< 
       (#  do true->doneInInner #);
     onInit::< 
       (# 
       do
          UDPrivate.UDDoPartNode
            ->UserDataInit;
          INNER
       #)
  #);
AttributesNode: FragmentNode
  (#
     display::< 
       (# 
       do ': Attributes'->t.append; 
       #);
     redisplay::< 
       (# 
       do ': Attributes'->t.append; 
       #);
     detail::< 
       (# 
       do
          <<SLOT AttributesNodeDetail:Descriptor>>
       #);
     onInit::<  (#  do UDPrivate.UDAttributesNode->UserDataInit; INNER #);
     
  #);
DescriptorNode: FragmentNode
  (#
     display::<  (#  do ': Descriptor'->t.append;  #);
     redisplay::<  (#  do ': Descriptor'->t.append;  #);
     detail::<  (#  do <<SLOT DescriptorNodeDetail:Descriptor>> #);
     onInit::< 
       (# 
       do
          UDPrivate.UDDescriptorNode
            ->UserDataInit;
          INNER
       #);
     
  #);
DiagramNode: AbstractNode
  (#
     theDeclaration:
       @ASTReferenceUserData (# Type::< betaGram.AttributeDecl #);
     theObjectDescriptor: @ASTReferenceUserData
       (# Type::< betaGram.ObjectDescriptor #);
     thePrefix: @ASTReferenceUserData
       (# Type::< betaGram.ObjectDescriptor #);
     onSelect::<  (#  do enableEditName; INNER onSelect #);
     CheckForAttributes::< 
       (# 
       do (theObjectDescriptor->CountAttributes) > 0->hasAttributes; 
       #);
     Display::< 
       (# anAST: ^MPS.AST; (* either theName or an unExp *) 
       enter (theDeclaration,anAST[])
       do <<SLOT DiagramNodeDisplay:Descriptor>>; 
       #);
     Redisplay::< 
       (#
          anAST: ^MPS.AST;
          (* either theName or an unExp *)
          
       enter (theDeclaration,anAST[])
       do <<SLOT DiagramNodeReDisplay:Descriptor>>
       #);
     ConcludeDisplay::< 
       (# 
       do
          <<SLOT DiagramNodeConcludeDisplay:Descriptor>>;
          INNER
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# help: ^text; ok: @Boolean; indexText: @Text
            <<SLOT DiagramNodeModeOn:DoPart>>
            #);
          ModeOff::< 
            (# t: @Text; noChange: @boolean
            <<SLOT DiagramNodeModeOff:DoPart>>
            #);
          
       #);
     EqualDescriptor:<
       (# aDesc: ^betaGram.ObjectDescriptor; b: @Boolean; 
       enter aDesc[]
       do INNER
       exit b
       #);
     detail::<  (#  do <<SLOT DiagramNodeDetail:Descriptor>> #);
     getASTNode::<
     (* return the AST node THIS(title) is generated from *) 
       (#  do theDeclaration->anAST[]; INNER #);
     GetGroup::<  (#  do <<SLOT DiagramNodeGetGroup:Descriptor>> #);
     GetFragment::< 
       (# 
       do
          <<SLOT DiagramNodeGetFragment:Descriptor>>
       #);
     theSifEditor::<  (# fn: ^FragmentNode <<SLOT theSifEditor:DoPart>> #);
     onInit::<  (#  <<SLOT DiagramNodeOnInit:DoPart>> #);
     dump::< 
       (# 
       do
          <<SLOT DiagramNodeDump:Descriptor>>;
          INNER
       #);
     
  #);
SimpleAttributeDecl: DiagramNode (* SimpleDecl or RepetitionDecl *)
  (#
     declTypeNode: @ReferenceUserData (# Type::< PatternDiagramNode #);
     theReferenceSpec: @ASTReferenceUserData
       (# Type::< betaGram.referenceSpecification #);
     theUnExpRefSpec: @ASTReferenceUserData (# Type::< mps.unExpanded #);
     theQualification: @ASTReferenceUserData
       (# Type::< betaGram.AttributeDecl #);
     theAggregationConnector: @ReferenceUserData
       (# Type:: AggregationConnector #);
     theAssociationConnector: @ReferenceUserData
       (# Type:: AssociationConnector #);
     Display::< 
       (# theObjectSpec: ^MPS.AST
       do
          INNER ;
          (* make theObjectSpec and theReferenceSpec *)
          <<SLOT SimpleAttrDeclDisplay:Descriptor>>;
          
       #);
     Redisplay::< 
       (# theObjectSpec: ^MPS.AST
       do
          INNER ;
          (* make theObjectSpec and theReferenceSpec *)
          <<SLOT SimpleAttrDeclReDisplay:Descriptor>>;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[80] then
                   'Text mode on in SimpleAttributeDeclNode'->putLine; 
               if);
               ' @'->parseableText.putText;
               INNER
            #);
          ModeOff::< 
            (# 
            do
               (if switch[80] then
                   'Text mode off in SimpleAttributeDeclNode '->putLine; 
               if);
               INNER ;
               
            #);
          
       #);
     DisplayReference:< (#  do INNER #);
     displayAggregation:
       (#  <<SLOT SimpleAttrDeclDisplayAggregation:DoPart>> #);
     setUpRelations:
       (#
          theObjectSpec:
            ^mps.ast
       enter theObjectSpec[]
       <<SLOT SimpleAttrDeclSetUpRelations:DoPart>>
       #);
     onInit::<  (#  <<SLOT SimpleAttributeDeclOnInit:DoPart>> #);
     dump::< 
       (# 
       do
          <<SLOT SimpleAttributeDecldump:Descriptor>>;
          INNER
       #);
     private: @<<SLOT SimpleAttibuteDeclPrivate:Descriptor>>
  #);
SimpleNode: SimpleAttributeDecl
  (#
     onDoubleClick::< 
       (# 
       do
          <<SLOT SimpleNodeDoubleClick:Descriptor>>
       #);
     Display::<  (#  do <<SLOT SimpleNodeDisplay:Descriptor>> #);
     Redisplay::< 
       (# 
       do
          <<SLOT SimpleNodeRedisplay:Descriptor>>
       #);
     DisplayReference::< 
       (#  do <<SLOT SimpleNodeDisplayReference:Descriptor>>;  #);
     onInit::< 
       (# 
       do
          UDPrivate.UDSimpleNode
            ->UserDataInit;
          INNER
       #);
     dump::< 
       (# 
       do
          <<SLOT SimpleNodeDump:Descriptor>>;
          INNER
       #);
     
  #);
RepetitionNode: SimpleAttributeDecl
  (#
     onDoubleClick::< 
       (#  do <<SLOT RepetitionNodeDoubleClick:Descriptor>> #);
     Display::< 
       (# 
       do
          <<SLOT RepetitionNodeDisplay:Descriptor>>
       #);
     Redisplay::<  (#  do <<SLOT RepetitionNodeRedisplay:Descriptor>> #);
     DisplayReference::< 
       (# 
       <<SLOT RepetitionNodeDisplayReference:DoPart>>
       #);
     onInit::<  (#  do UDPrivate.UDRepetitionNode->UserDataInit; INNER #);
     
  #);
PatternNode: DiagramNode
  (#
     Display::< 
       (# pd: ^betaGram.PatternDecl; anAST: ^MPS.AST; 
       do
          (if (theDeclaration)._struc <= betaGram.PatternDecl##
           // true then
              theDeclaration->pd[];
              pd.getObjectDescriptor->anAST[];
              (if anAST.kind
               // mps.kinds.interior then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      ': ...'->t.puttext; 
                  if);
                  
              if);
              pd->SetRegionType;
              
          if);
          DisplayReferences;
          INNER ;
          setupAssociation;
          
       #);
     Redisplay::< 
       (# pd: ^betaGram.PatternDecl; anAST: ^MPS.AST; 
       do
          (if switch[70] then
              (if theDeclaration <> none then
                  '*** patternNode'->putLine;
                  'theDeclaration: '->putText;
                  (theDeclaration).index->putInt;
                  newLine;
                  
              if);
              (if theObjectDescriptor <> none then
                  'theObjectDescriptor: '->putText;
                  (theObjectDescriptor).index->putInt;
                  newLine;
                  
              if);
              
          if);
          (if (theDeclaration)._struc <= betaGram.PatternDecl##
           // true then
              theDeclaration->pd[];
              pd.getObjectDescriptor->anAST[];
              (if anAST.kind
               // mps.kinds.interior then
                  anAST[]->theObjectDescriptor;
                  (if currentDecomposDiagram <> none then
                      anAST[]->(currentDecomposDiagram).theDescriptor
                  if);
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      ': ...'->t.puttext; 
                  if);
                  
              if);
              pd->SetRegionType;
              
          if);
          (if switch[70] then
              (if theDeclaration <> none then
                  'theDeclaration: '->putText;
                  (theDeclaration).index->putInt;
                  newLine;
                  
              if);
              (if theObjectDescriptor <> none then
                  'theObjectDescriptor: '->putText;
                  (theObjectDescriptor).index->putInt;
                  newLine;
                  
              if);
              
          if);
          INNER ;
          
       #);
     onDoubleClick::< 
       (# 
       do
          false->indicateSelection;
          (if switch[30]
           // true then
              'doubleClick PatternDeclaration ID: '->puttext;
              ID->putint;
              newline;
              
          if);
          (if hasAttributes
           // true then detail; 
           else
              (if switch[30] // true then 'no attributes'->putline if)
          if);
          INNER ;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[80] then
                   'Text mode on in PatternNode'->putLine; 
               if);
               ' '->parseableText.put;
               INNER
            #);
          ModeOff::< 
            (# 
            do
               (if switch[80] then
                   'Text mode off in PatternNode '->putLine; 
               if);
               INNER ;
               
            #);
          
       #);
     EqualDescriptor::< 
       (# 
       do
          (if theObjectDescriptor <> none
           // true then aDesc[]->(theObjectDescriptor).equal->b; 
          if);
          INNER ;
          
       #);
     detail::<  (#  do <<SLOT PatternNodeDetail:Descriptor>>;  #);
     DisplayReferences:
       (# 
       do
          <<SLOT PatternNodeDisplayReferences:Descriptor>>;
          
       #);
     setupAssociation:
       (#  do <<SLOT PatternNodeSetupAssociation:Descriptor>> #);
     onInit::< 
       (# 
       <<SLOT PatternNodeOnInit:DoPart>>
       #);
     dump::<  (#  <<SLOT PatternNodeDump:DoPart>> #);
     
  #);
VirtualNode: PatternNode
  (#
     onDoubleClick::<  (#  do INNER ;  #);
     Display::< 
       (#
          vd: ^betaGram.VirtualDecl;
          anAST,a: ^MPS.AST;
          theUnExpObjSpec: ^mps.unexpanded;
          aName: ^betaGram.NameApl;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration)._struc <=
          betaGram.VirtualDecl##
           // true then
              theDeclaration->vd[];
              vd->SetRegionType;
              ':< '->t.append;
              vd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      ' ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // mps.kinds.unExpanded then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          ' <<NameAppl>>'->t.append
                       // gppProp.asType then
                          t.clear; ':< <<NameAppl>>'->t.append; 
                      if);
                      
                   else
                  (* is a real name *)
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          a[]->theAppl[]; theAppl.getText->t.append
                       // gppProp.asType then
                          t.clear;
                          ':< '->t.append;
                          a[]->theAppl[];
                          theAppl.getText->t.append;
                          
                      if);
                      
                  if)
               // betaGram.Remote then
                  (if gppProp.SimpleDeclDisplay
                   // gppProp.AsNameAndType then
                      anAST[]->MakeRemote->t.append
                   // gppProp.asType then
                      t.clear; ':< '->t.append; anAST[]->MakeRemote->t.append; 
                  if)
               else
                  (if anAST.kind = mps.kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append
                       // gppProp.asType then
                          t.clear;
                          ':< '->t.append;
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append;
                          
                      if)
                  if)
              if);
              
          if);
          betaGram.VirtualDecl->SetRegionType;
          INNER ;
          
       #);
     Redisplay::< 
       (#
          vd: ^betaGram.VirtualDecl;
          anAST,a: ^MPS.AST;
          theUnExpObjSpec: ^mps.unexpanded;
          aName: ^betaGram.NameApl;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration)._struc <= betaGram.VirtualDecl##
           // true then
              theDeclaration->vd[];
              vd->SetRegionType;
              ':< '->t.append;
              vd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      ' ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // mps.kinds.unExpanded then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          ' <<NameAppl>>'->t.append
                       // gppProp.asType then
                          t.clear; ':< <<NameAppl>>'->t.append; 
                      if);
                      
                   else
                  (* is a real name *)
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          a[]->theAppl[]; theAppl.getText->t.append
                       // gppProp.asType then
                          t.clear;
                          ':< '->t.append;
                          a[]->theAppl[];
                          theAppl.getText->t.append;
                          
                      if);
                      
                  if)
               // betaGram.Remote then
                  (if gppProp.SimpleDeclDisplay
                   // gppProp.AsNameAndType then
                      anAST[]->MakeRemote->t.append
                   // gppProp.asType then
                      t.clear; ':< '->t.append; anAST[]->MakeRemote->t.append; 
                  if)
               else
                  (if anAST.kind = mps.kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append
                       // gppProp.asType then
                          t.clear;
                          ':< '->t.append;
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append;
                          
                      if)
                  if)
              if);
              
          if);
          betaGram.VirtualDecl->SetRegionType;
          INNER ;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[80] then
                   'Text mode on in VirtualNode'->putLine; 
               if);
               '< '->parseableText.putText;
               INNER
            #);
          ModeOff::< 
            (# t: @Text
            do
               (if switch[80] then
                   'Text mode off in VirtualNode '->putLine; 
               if);
               INNER ;
               
            #);
          
       #);
     onInit::<  (#  do UDPrivate.UDVirtualNode->UserDataInit; INNER #);
     
  #);
BindingNode: PatternNode
  (#
     onDoubleClick::<  (#  do INNER ;  #);
     Display::< 
       (#
          bd: ^betaGram.BindingDecl;
          anAST,a: ^MPS.AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^mps.unexpanded;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration)._struc <= betaGram.BindingDecl##
           // true then
              theDeclaration->bd[];
              bd->SetRegionType;
              '::< '->t.append;
              bd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      ' ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // mps.kinds.unExpanded then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          ' <<NameAppl>>'->t.append
                       // gppProp.asType then
                          t.clear; '::< <<NameAppl>>'->t.append; 
                      if);
                      
                   else
                  (* is a real name *)
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          a[]->theAppl[]; theAppl.getText->t.append
                       // gppProp.asType then
                          t.clear;
                          '::< '->t.append;
                          a[]->theAppl[];
                          theAppl.getText->t.append;
                          
                      if);
                      
                  if)
               // betaGram.Remote then
                  (if gppProp.SimpleDeclDisplay
                   // gppProp.AsNameAndType then
                      anAST[]->MakeRemote->t.append
                   // gppProp.asType then
                      t.clear; '::< '->t.append; anAST[]->MakeRemote->t.append; 
                  if)
               else
                  (if anAST.kind = mps.kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append
                       // gppProp.asType then
                          t.clear;
                          '::< '->t.append;
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append;
                          
                      if)
                  if)
              if);
              
          if);
          betaGram.BindingDecl->SetRegionType;
          INNER ;
          
       #);
     Redisplay::< 
       (#
          bd: ^betaGram.BindingDecl;
          anAST,a: ^MPS.AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^mps.unexpanded;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration)._struc <= betaGram.BindingDecl##
           // true then
              theDeclaration->bd[];
              bd->SetRegionType;
              '::< '->t.append;
              bd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      ' ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // mps.kinds.unExpanded then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          ' <<NameAppl>>'->t.append
                       // gppProp.asType then
                          t.clear; '::< <<NameAppl>>'->t.append; 
                      if);
                      
                   else
                  (* is a real name *)
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          a[]->theAppl[]; theAppl.getText->t.append
                       // gppProp.asType then
                          t.clear;
                          '::< '->t.append;
                          a[]->theAppl[];
                          theAppl.getText->t.append;
                          
                      if);
                      
                  if)
               // betaGram.Remote then
                  (if gppProp.SimpleDeclDisplay
                   // gppProp.AsNameAndType then
                      anAST[]->MakeRemote->t.append
                   // gppProp.asType then
                      t.clear; '::< '->t.append; anAST[]->MakeRemote->t.append; 
                  if)
               else
                  (if anAST.kind = mps.kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append
                       // gppProp.asType then
                          t.clear;
                          '::< '->t.append;
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append;
                          
                      if)
                  if)
              if);
              
          if);
          betaGram.BindingDecl->SetRegionType;
          INNER ;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[80] then
                   'Text mode on in BindingNode'->putLine; 
               if);
               ':< '->parseableText.putText;
               INNER
            #);
          ModeOff::< 
            (# t: @Text
            do
               (if switch[80] then
                   'Text mode off in BindingNode '->putLine; 
               if);
               INNER ;
               
            #);
          
       #);
     onInit::<  (#  do UDPrivate.UDBindingNode->UserDataInit; INNER #);
     
  #);
FinalNode: PatternNode
  (#
     onDoubleClick::<  (#  do INNER ;  #);
     Display::< 
       (#
          fd: ^betaGram.FinalDecl;
          anAST,a: ^MPS.AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^mps.unexpanded;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration)._struc <= betaGram.FinalDecl##
           // true then
              theDeclaration->fd[];
              fd->SetRegionType;
              ':: '->t.append;
              fd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      ' ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // mps.kinds.unExpanded then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          ' <<NameAppl>>'->t.append
                       // gppProp.asType then
                          t.clear; ':: <<NameAppl>>'->t.append; 
                      if);
                      
                   else
                  (* is a real name *)
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          a[]->theAppl[]; theAppl.getText->t.append
                       // gppProp.asType then
                          t.clear;
                          ':: '->t.append;
                          a[]->theAppl[];
                          theAppl.getText->t.append;
                          
                      if);
                      
                  if)
               // betaGram.Remote then
                  (if gppProp.SimpleDeclDisplay
                   // gppProp.AsNameAndType then
                      anAST[]->MakeRemote->t.append
                   // gppProp.asType then
                      t.clear; ':: '->t.append; anAST[]->MakeRemote->t.append; 
                  if)
               else
                  (if anAST.kind = mps.kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append
                       // gppProp.asType then
                          t.clear;
                          ':: '->t.append;
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append;
                          
                      if)
                  if)
              if);
              
          if);
          betaGram.FinalDecl->SetRegionType;
          INNER ;
          
       #);
     Redisplay::< 
       (#
          fd: ^betaGram.FinalDecl;
          anAST,a: ^MPS.AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^mps.unexpanded;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration)._struc <= betaGram.FinalDecl##
           // true then
              theDeclaration->fd[];
              fd->SetRegionType;
              ':: '->t.append;
              fd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      ' ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // mps.kinds.unExpanded then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          ' <<NameAppl>>'->t.append
                       // gppProp.asType then
                          t.clear; ':: <<NameAppl>>'->t.append; 
                      if);
                      
                   else
                  (* is a real name *)
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          a[]->theAppl[]; theAppl.getText->t.append
                       // gppProp.asType then
                          t.clear;
                          ':: '->t.append;
                          a[]->theAppl[];
                          theAppl.getText->t.append;
                          
                      if);
                      
                  if)
               // betaGram.Remote then
                  (if gppProp.SimpleDeclDisplay
                   // gppProp.AsNameAndType then
                      anAST[]->MakeRemote->t.append
                   // gppProp.asType then
                      t.clear; ':: '->t.append; anAST[]->MakeRemote->t.append; 
                  if)
               else
                  (if anAST.kind = mps.kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append
                       // gppProp.asType then
                          t.clear;
                          ':: '->t.append;
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append;
                          
                      if)
                  if)
              if);
              
          if);
          betaGram.FinalDecl->SetRegionType;
          INNER ;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[80] then 'Text mode on in FinalNode'->putLine;  if);
               ': '->parseableText.putText;
               INNER
            #);
          ModeOff::< 
            (# t: @Text
            do
               (if switch[80] then
                   'Text mode off in FinalNode '->putLine; 
               if);
               INNER ;
               
            #);
          
       #);
     onInit::<  (#  do UDPrivate.UDFinalNode->UserDataInit; INNER #);
     
  #);
NonTerminalNode: AbstractNode
  (#
     unExp: @ASTReferenceUserData (# Type::< mps.unexpanded #);
     synCatName: @ReferenceUserData (# Type::< Text #);
     synCatNo: @IntegerUserData;
     onSelect::<  (#  do disableEditName #);
     onInit::<  (#  do <<SLOT NonTerminalNodeInit:Descriptor>> #);
     display::< 
       (# 
       enter unexp
       do
          <<SLOT NonTerminalNodeDisplay:Descriptor>>
       #);
     redisplay::< 
       (#  enter unexp do <<SLOT NonTerminalNodeRedisplay:Descriptor>>;  #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[80] then
                   'Text mode on NonTerminalNode'->putLine; 
               if);
               (if not ongoingTextediting then
                   true->wrap;
                   theText.get->theTextBefore;
                   true->ongoingTextediting;
                   THIS(NonTerminalNode).size->(oldWidth,oldHeight);
                   (2*GppProp.width,6*GppProp.height)
                     ->THIS(NonTerminalNode).size
               if);
               (* 'Textediting of nonterminal nodes is currently disabled'->gppAlert;
                false->OKtoEnter;*)
               (* THIS(nonterminalNode).size->(oldWidth,oldHeight);
                (oldWidth,oldHeight)->THIS(nonterminalNode).size;
                THIS(nonterminalNode).size->(newWidth,newHeight);*)
               INNER
            #);
          ModeOff::< 
            (# t: @Text
            do
               (if switch[80] then
                   'Text mode off NonterminalNode'->putLine; 
               if);
               (if ongoingTextediting then
                   theText.get->t;
                   (if unExp
                    // none then 'unExp is none!! '->putLine
                    else
                       (if not (theTextBefore[]->t.equal) then
                           (THIS(NonTerminalNode)[],unExp,t[])
                             ->declarationTextChanged;
                           (if parseErrorOccurred then false->OKToExit if)
                        else
                           (oldWidth,oldHeight)->THIS(NonTerminalNode).size;
                           false->ongoingTextediting;
                           false->parseErrorOccurred
                       if)
                   if);
                   (* (oldWidth,oldHeight)->THIS(nonterminalNode).size;*)
                   INNER
               if);
               false->wrap;
               
            #);
          
       #);
     onDoubleClick::<  (#  do <<SLOT NonTerminalDoubleClick:Descriptor>> #);
     detail::<  (#  do 'Detail the nonterminal'->putline #);
     abstract::<  (#  do 'Abstract the nonterminal'->putline #);
     GetGroup::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none
           // true then
                (#
                   fd: ^FragmentDiagram; theDummyFragNode: ^PatternDiagramNode
                do
                   (theDiagram).theFragmentNode->theDummyFragNode[];
                   theDummyFragNode.theDiagram->fd[];
                   fd.theGroup->fg[];
                   
                #);
              
           else
              'DiagramNode: GetGroup: no FragmentNode'->screen.putline
          if);
          
       #);
     GetFragment::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none
           // true then
                (# fn: ^FragmentNode; 
                do (theDiagram).theFragmentNode->fn[]; fn.theFragment->f[]; 
                #);
              
           else
              'DiagramNode: GetFragment: no FragmentNode'->screen.putline
          if);
          
       #);
     theSifEditor::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none then
              (if se[] = none then
                    (# fn: ^FragmentNode; 
                    do
                       (theDiagram).theFragmentNode->fn[];
                       fn.SifEditorInstance[]->se[];
                       
                    #);
                  
               else
                    (# fn: ^FragmentNode; 
                    do
                       (theDiagram).theFragmentNode->fn[];
                       se[]->fn.SifEditorInstance[];
                       
                    #);
                  
              if);
              
           else
              'DiagramNode: theSifEditor: no FragmentNode'->screen.putline
          if);
          
       #);
     dump::<  (#  do <<SLOT NonTerminalNodeDump:Descriptor>>; INNER #);
     
  #);
SlotNode: PatternDiagramNode
  (#
     unExp: @ASTReferenceUserData
       (# Type::< mps.unexpanded #);
     display::< 
       (# pos: @Point; 
       enter (pos,unExp)
       do
          <<SLOT SlotNodeDisplay:Descriptor>>;
          
       #);
     onDoubleClick::<  (#  <<SLOT SlotNodeOnDoubleClick:DoPart>> #);
     abstract::< 
       (# 
       <<SLOT SlotNodeAbstract:DoPart>>
       #);
     detail::<  (#  <<SLOT SlotNodeDetail:DoPart>> #);
     onSelect::< 
       (#  <<SLOT SlotNodeOnSelect:DoPart>> #);
     GetGroup::<  (#  <<SLOT SlotNodeGetGroup:DoPart>> #);
     GetFragment::< 
       (# 
       <<SLOT SlotNodeGetFragment:DoPart>>
       #);
     theSifEditor::<  (#  <<SLOT SlotNodeTheSifEditor:DoPart>> #);
     dump::< 
       (# 
       <<SLOT SlotNodeDump:DoPart>>
       #);
     onInit::< 
       (# 
       <<SLOT SlotNodeOnInit:DoPart>>
       #);
     
  #);
(* Mark nodes: for comments and Dexter anchors *)
(* Mark nodes: for comments and Dexter anchors *)
MyCommentNode: CommentNode (* to display the comment *)
  (#
     theMarkNode: @ReferenceUserData (# Type::< CommentMark #);
     onInit::<  (#  do <<SLOT MyCommentNodeOnInit:Descriptor>> #);
     onRemove::< 
       (# 
       do
          <<SLOT CommentNodeOnRemove:Descriptor>>
       #);
     deactivate::<  (#  do <<SLOT CommentNodeDeactivate:Descriptor>> #);
     
  #);
CommentMark: MarkNode
  (#
     open: @BooleanUserData;
     theComment: @ASTReferenceUserData
       (# Type::< mps.LexemText
       #);
     theCommentNode:
       @ReferenceUserData (# Type::< MyCommentNode #);
     theConn: @ReferenceUserData (# Type::< Connector #);
     display::< 
       (# theCom: ^mps.lexemtext
       enter theComment
       do <<SLOT CommentNodeDisplay:Descriptor>>; 
       #);
     activate::< 
       (# 
       do
          <<SLOT CommentMarkActivate:Descriptor>>
       #);
     deactivate::<  (#  do <<SLOT CommentMarkDeactivate:Descriptor>> #);
     onInit::< 
       (# 
       do
          <<SLOT CommentMarkOnInit:Descriptor>>
       #);
     onRemove::<  (#  do <<SLOT CommentMarkOnRemove:Descriptor>> #);
     onDoubleClick::< 
       (# 
       do
          <<SLOT CommentMarkDoubleClick:Descriptor>>
       #);
     onSelect::<  (#  do <<SLOT CommentMarkSelect:Descriptor>> #);
     
  #);
AnchorMark: MarkNode
  (#
     display::< 
       (# 
       do
          <<SLOT AnchorMarkDisplay:Descriptor>>
       #);
     onInit::<  (#  do <<SLOT AnchorMarkOnInit:Descriptor>> #);
     onDoubleClick::< 
       (# 
       do
          <<SLOT AnchorMarkDoubleClick:Descriptor>>
       #);
     activate::<  (#  do <<SLOT AnchorMarkActivate:Descriptor>> #);
     deactivate::< 
       (# 
       do
          <<SLOT AnchorMarkDeactivate:Descriptor>>
       #);
     
  #);
(* CONNECTORS *)
  

-- PatternDiagrams: Descriptor --
(#
   theList: @DiagramList; private: @<<SLOT patternDiagramsPrivate:Descriptor>>
#)  

-- OADPageMakeDesignObject: Descriptor --
(#
   theDiag: ^Diagram;
   NodeType: @Integer;
   theListDiagram: ^ListDiagram;
   theSimplePropertyDiagram: ^SimplePropertyDiagram;
   theNodeID: @integer
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDFragmentDiagram then
       &FragmentDiagram[]->theDiag[];
       (0,none ,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created FragmentDiagram!'->putline
       if)
    // UDPrivate.UDPatternAttDiagram then
       &PatternAttDiagram[]->theDiag[];
       (0,none ,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternAttDiagram!'->putline
       if);
       theDiag[]->theListDiagram[];
       theListDiagram.titleNode.UDtheSurroundBox.getID->theNodeID;
       (if theNodeID <> 0 then
           (theListDiagram[],theNodeID)->makeSurroundBox
       if)
    // UDPrivate.UDPatternDeclDiagram then
       &PatternDeclDiagram[]->theDiag[];
       (0,none ,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternDeclDiagram!'->putline
       if)
    // UDPrivate.UDPatternClassificationDiagram then
       &PatternClassificationDiagram[]->theDiag[];
       (0,none ,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternClassificationDiagram!'->putline
       if)
    // UDPrivate.UDPatternNonTerminalDiagram then
       &PatternNonTerminalDiagram[]->theDiag[];
       (0,none ,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternNonTerminalDiagram!'->putline
       if)
    // UDPrivate.UDSimplePropertyDiagram then
       &SimplePropertyDiagram[]->theDiag[];
       (0,none ,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created SimplePropertyDiagram!'->putline
       if);
       theDiag[]->theSimplePropertyDiagram[];
       theSimplePropertyDiagram.titleNode.UDSurroundBox.getID->theNodeID;
       (if theNodeID <> 0 then
           (theSimplePropertyDiagram[],theNodeID)->makeSurroundBox
       if)
    // UDPrivate.UDPropertyDiagram then
       &PropertyDiagram[]->theDiag[];
       (0,none ,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PropertyDiagram!'->putline
       if)
   if)
#)  

-- MakeLocalNodes: Descriptor --
(#
   rangeStart: @integer;
   rangeEnd: @integer;
   count: @integer;
   localNodeID: @integer;
   NodeType: @integer;
   thePatternDiagNode: ^PatternDiagramNode;
   theSimpleNode: ^theListDiagram.SimpleAttributeDecl;
   thePatternNode: ^theListDiagram.PatternNode;
   theObject: ^DesignObject;
   theNode: ^Node;
   thePropertyDiagram: ^SimplePropertyDiagram;
   regions: [0] @Integer;
   titleID,theNodeID,theConnID: @integer
do
   LocalNodesUserDataStart->rangeStart;
   LocalNodesUserDataEnd->rangeEnd;
   theListDiagram.titleNode.ID->titleID;
   (* &integerRef[]->rangeH[];
    &shortRef[]->count[];
    (titleID,rangeStart,rangeEnd,count[],rangeH[])->UDFindRange->ok;*)
   theListDiagram.titleNode.oldLocalNodesUDAttributes-LocalNodesUserDataStart
     ->count;
   &theListDiagram.LocalNodesDesc[]->theListDiagram.localNodes[];
   (for i: count repeat
     (if userDataVerbose then
         'For titleID: '->puttext;
         titleID->putint;
         ' and attributesID: '->puttext;
         LocalNodesUserDataStart+i->putint;
         ' localNodeID was: '->puttext;
         
     if);
     (titleID,LocalNodesUserDataStart+i)->readIntegerUserData->localNodeID;
     (if localNodeID <> 0 then
         (if userDataVerbose then localNodeID->putint; newline;  if);
         localNodeID->getNodeType->NodeType;
         (if NodeType = UDPrivate.UDPatternDiagramNode then
             &PatternDiagramNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created PatternDiagramNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDAbstractNode then
             &theListDiagram.AbstractNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created AbstractNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDSlotNode then
             &theListDiagram.SlotNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created SlotNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDPropertyNode then
             theListDiagram[]->thePropertyDiagram[];
             &thePropertyDiagram.PropertyNode[]->thePatternDiagNode[]
               ->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeDesignObject: Created PropertyNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDFragmentNode then
             &theListDiagram.FragmentNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created FragmentNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDDiagramNode then
             &theListDiagram.DiagramNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created DiagramNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDNonTerminalNode then
             &theListDiagram.NonTerminalNode[]->thePatternDiagNode[]
               ->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created NonTerminalNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDDoPartNode then
             &theListDiagram.DoPartNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created DoPartNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDAttributesNode then
             &theListDiagram.AttributesNode[]->thePatternDiagNode[]
               ->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created AttributesNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDDescriptorNode then
             &theListDiagram.DescriptorNode[]->thePatternDiagNode[]
               ->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created DescriptorNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDSimpleAttributeDecl then
             &theListDiagram.SimpleAttributeDecl[]->thePatternDiagNode[]
               ->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created SimpleAttributeDecl!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDPatternNode then
             &theListDiagram.PatternNode[]->thePatternDiagNode[]
               ->thePatternNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created PatternNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDSimpleNode then
             &theListDiagram.SimpleNode[]->thePatternDiagNode[]->theSimpleNode[]
               ->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created SimpleNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDRepetitionNode then
             &theListDiagram.RepetitionNode[]->thePatternDiagNode[]
               ->theSimpleNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created RepetitionNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDVirtualNode then
             &theListDiagram.VirtualNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created VirtualNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDBindingNode then
             &theListDiagram.BindingNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: BindingNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDFinalNode then
             &theListDiagram.FinalNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: FinalNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDActivePropertyNode then
             (if theListDiagram## <= SimplePropertyDiagram## then
                 theListDiagram[]->thePropertyDiagram[];
                 &thePropertyDiagram.ActivePropertyNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeDesignObject: Created ActivePropertyNode!'->putline
                 if)
             if)
         if);
         (if NodeType = UDPrivate.UDPassivePropertyNode then
             (if theListDiagram## <= SimplePropertyDiagram## then
                 theListDiagram[]->thePropertyDiagram[];
                 &thePropertyDiagram.PassivePropertyNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeDesignObject: Created PassivePropertyNode!'->putline
                 if)
             if)
         if);
         (if NodeType = UDPrivate.UDOriginPropertyNode then
             (if theListDiagram## <= SimplePropertyDiagram## then
                 theListDiagram[]->thePropertyDiagram[];
                 &thePropertyDiagram.OriginPropertyNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeDesignObject: Created OriginPropertyNode!'->putline
                 if)
             if)
         if);
         (if NodeType = UDPrivate.UDIncludePropertyNode then
             (if theListDiagram## <= SimplePropertyDiagram## then
                 theListDiagram[]->thePropertyDiagram[];
                 &thePropertyDiagram.IncludePropertyNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeDesignObject: Created IncludePropertyNode!'->putline
                 if)
             if)
         if);
         (if NodeType = UDPrivate.UDBodyPropertyNode then
             (if theListDiagram## <= SimplePropertyDiagram## then
                 theListDiagram[]->thePropertyDiagram[];
                 &thePropertyDiagram.BodyPropertyNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeDesignObject: Created BodyPropertyNode!'->putline
                 if)
             if)
         if);
         (if theObject[] <> none then
             theObject[]->theListDiagram.LocalNodes.append;
             localNodeID->theObject.onInit;
             theObject.getRegionIDs->regions;
             (if regions.range > 0 then
                 theObject.onInitRegion; regions->MakeObjectsFromList
             if);
             (if theObject## <= node## then
                 theObject[]->theNode[];
                 false->theNode.moveable;
                 false->theNode.sizeable
             if);
             (if thePatternDiagNode[] <> none then
                 thePatternDiagNode.theMarkNode.getID
                   ->theNodeID
                   (*theMarkNode currently refers to EllipseNode.
                    getID works around qua error.*) ;
                 (if theNodeID <> 0 then
                     (theListDiagram[],theNodeID)->MakeMarkNode
                 if)
             if)
         if)
     if)
   for);
   
#)  

-- MakeMarkNode: Descriptor --
(#
   NodeType,theNodeId,theConnID: @integer;
   theObject: ^DesignObject;
   theCommentMark: ^theListDiagram.CommentMark;
   regions: [0] @Integer
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDCommentMark then
       &theListDiagram.CommentMark[]->theCommentMark[]->theObject[];
       true->theCommentMark.initialisingSaved;
       (if userDataVerbose then
           'MakeMarkNode: Created CommentMark!'->putline
       if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       theObject.getRegionIDs->regions;
       (if regions.range > 0 then
           theObject.onInitRegion; regions->MakeObjectsFromList
       if);
       theCommentMark.theCommentNode.getID
         ->theNodeID
         (*theCommentNode currently refers to RectNode.
          getId works around qua error*) ;
       (if theNodeID <> 0 then
           (theListDiagram[],theNodeID)->MakeCommentNode
       if);
       theCommentMark.theConn.getID->theConnID;
       (if theConnID <> 0 then theConnID->MakeConn if)
   if)
#)  

-- MakeCommentNode: Descriptor --
(#
   NodeType: @integer;
   theObject: ^DesignObject;
   theCommentNode: ^theListDiagram.MyCommentNode;
   regions: [0] @Integer
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDMyCommentNode then
       &theListDiagram.MyCommentNode[]->theCommentNode[]->theObject[];
       true->theCommentNode.initialisingSaved;
       (if userDataVerbose then
           'MakeCommentNode: Created MyCommentNode!'->putline
       if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       theObject.getRegionIDs->regions;
       (if regions.range > 0 then
           theObject.onInitRegion; regions->MakeObjectsFromList
       if)
   if)
#)  

-- MakeUserDataLabelNode: DoPart --
do
     (# NodeType: @integer; theObject: ^DesignObject; regions: [0] @Integer
     do
        ID->getNodeType->NodeType;
        (if NodeType = UDPrivate.UDLabelNode then
            &UserDataLabelNode[]->theObject[];
            (if theObject[] <> none then
                ID->theObject.onInit;
                (if userdataVerbose then
                    'MakeUserDataLabelNode: Created UserDataLabelNode!'->putline
                if);
                theObject.getRegionIDs->regions;
                (if regions.range > 0 then
                    theObject.onInitRegion; regions->MakeObjectsFromList
                if)
            if)
        if)
     #)  

-- MakeConn: Descriptor --
(#
   NodeType,theNodeID: @integer;
   theObject: ^DesignObject;
   regions: [0] @Integer;
   theDeletableConn: ^DeletableConnector;
   theAssociationConnector: ^AssociationConnector
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDPrefixConnector then
       &PrefixConnector[]->theDeletableConn[]->theObject[];
       true->theDeletableConn.initialisingSaved;
       (if userDataVerbose then
           'MakeConn: Created PrefixConnector!'->putline
       if)
    // UDPrivate.UDAssociationConnector then
       &AssociationConnector[]->theDeletableConn[]->theAssociationConnector[]
         ->theObject[];
       true->theDeletableConn.initialisingSaved;
       (if userDataVerbose or switch[53] then
           'MakeConn: Created AssociationConnector!'->putline
       if)
    // UDPrivate.UDAggregationConnector then
       &AggregationConnector[]->theDeletableConn[]->theAssociationConnector[]
         ->theObject[];
       true->theDeletableConn.initialisingSaved;
       (if userDataVerbose or switch[54] then
           'MakeConn: Created AggregationConnector!'->putline
       if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       theObject.getRegionIDs->regions;
       (if regions.range > 0 then
           theObject.onInitRegion; regions->MakeObjectsFromList
       if);
       (if theAssociationConnector[] <> none then
           theAssociationConnector.leftRole.getID->theNodeID;
           (if theNodeID <> 0 then
               (theAssociationConnector[],theNodeID)->MakeRole
           if);
           theAssociationConnector.rightRole.getID->theNodeID;
           (if theNodeID <> 0 then
               (theAssociationConnector[],theNodeID)->MakeRole
           if);
           theAssociationConnector.name.getID->theNodeID;
           (if theNodeID <> 0 then theNodeID->MakeUserDataLabelNode if)
       if)
   if)
#)  

-- MakeRole: DoPart --
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDRole then
       &theAssociationConnector.Role[]->theRole[]->theObject[];
       (if userDataVerbose or switch[53] or switch[54] then
           'MakeRole: Created Role!'->putline
       if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       theObject.getRegionIDs->regions;
       (if regions.range > 0 then
           theObject.onInitRegion; regions->MakeObjectsFromList
       if);
       theRole.name.getID->theNodeID;
       (if theNodeID <> 0 then theNodeID->MakeUserDataLabelNode if);
       theRole.multiplicity.getID->theNodeID;
       (if theNodeID <> 0 then theNodeID->MakeUserDataLabelNode if)
   if)  

-- makeSurroundBox: DoPart --
do
     (#
        NodeType: @integer;
        theListDiagram: ^ListDiagram;
        thePropertyDiagram: ^PropertyDiagram;
        theObject: ^DesignObject;
        regions: [0] @Integer
     do
        ID->getNodeType->NodeType;
        (if NodeType = UDPrivate.UDSurroundBox then
            (if theDiag## <= PropertyDiagram## then
                theDiag[]->thePropertyDiagram[];
                &thePropertyDiagram.surroundBox[]->theObject[]
             else
                &SurroundBox[]->theObject[]
            if);
            (if theObject[] <> none then
                ID->theObject.onInit;
                (if userdataVerbose then
                    'MakeSurroundBox: Created SurroundBox!'->putline
                if);
                theObject.getRegionIDs->regions;
                (if regions.range > 0 then
                    theObject.onInitRegion; regions->MakeObjectsFromList
                if)
            if)
        if)
     #)  

-- onReadDiagram: Descriptor --
(# 
do
(*  THIS(OADPage).PatternDiagrams.theList.scan
 (#
 theListDiagram: ^ListDiagram;
 thisOADDiagram: ^OADDiagram;
 thisFragmentDiagram: ^FragmentDiagram;
 theDummyDesc: ^betaGram.ObjectDescriptor;
 thisPatternAttDiagram: ^PatternAttDiagram;
 theDummyAST: ^MPS.AST
 do
 current.e[]->theListDiagram[];
 (if current.e## <= OADDiagram##
 // true then
 current.e[]->thisOADDiagram[];
 thisOADDiagram.titlenode.theText.get->thisOADDiagram.titleText;
 (if thisOADDiagram.theDescriptor <> none then
 thisOADDiagram.theDescriptor->theDummyDesc[];
 theDummyDesc.index->current.index;
 (if thisOADDiagram## <= PatternAttDiagram## then
 thisOADDiagram[]->thisPatternAttDiagram[];
 thisPatternAttDiagram.theAST->theDummyAST[];
 theDummyAST.index->current.index
 if)
 if);
 if);
 (if current.e## <= FragmentDiagram## then
 current.e[]->thisFragmentDiagram[];
 thisFragmentDiagram.titlenode.theText.get
 ->thisFragmentDiagram.titleText
 if)
 #) *) 
#)  

-- gppOADPagePrivate: Descriptor --
(#  do  #)  

-- designInterfacePrivate: Descriptor --
(# UI: ^guienv #)  

