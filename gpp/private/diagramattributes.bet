ORIGIN '../gppinterface';
INCLUDE '~beta/containers/v1.6/list'
        '~beta/containers/v1.6/sets'
        '~beta/containers/v1.6/arrayContainer'
        '../prettyprintersetup'
        '../propertydiagrams'
        'userdataprivate';
BODY 'gppinterfacebody'
     'diagrambody'
     'patterndiagrambody'
     'abstractnodebody'
     'fragmentnodebody'
     'marknodebody'
     'simplenodebody'
     'nonterminalnodebody';
(* This fragment group defines patterns visible to all bodies,
 * but not visible in the interface
 *)
(* This fragment group defines patterns visible to all bodies,
 * but not visible in the interface
 *)
(* This fragment group defines patterns visible to all bodies,
 * but not visible in the interface
 *)
(* This fragment group defines patterns visible to all bodies,
 * but not visible in the interface
 *)
-- OADPageLib: Attributes --
scrollIntoView:
  (# theObject: ^designObject; 
  enter theObject[]
  do
     (if doScrollIntoView then
         theObject[]->currentObject (#  do true->autoPan #); 
     if);
     
  #);
GetPrefix:
  (#
     theDescriptor: ^betaGram.ObjectDescriptor;
     tempAst: ^mps.ast;
     pref: ^betaGram.prefix;
     ad: ^betaGram.attributeDenotation;
     thisPrefix: ^betaGram.ObjectDescriptor;
     
  enter theDescriptor[]
  do
     (if switch[50] then
         'GetPrefix: theDescriptor=%i\n'
           ->putformat (#  do theDescriptor.index->i #)
     if);
     theDescriptor.getPrefixOpt->tempAst[];
     (if tempAst.kind
      // mps.kinds.interior then
         tempAst[]->pref[];
         pref.getAttributeDenotation->tempAst[];
         (if tempAst.kind
          // mps.kinds.interior then
             tempAst[]->ad[]; ad.findDescriptor->thisPrefix[]; 
         if);
         
     if);
     
  exit thisPrefix[]
  #);
DiagramList: ContainerList (* list of diagrams on a page *)
  (#
     element::<  (# index: @Integer; frag: ^text; e: ^Diagram #);
     myFind: find
       (#
          i: @Integer;
          f: ^text;
          predicate::< 
            (# 
            do
               (if f[] <> none then
                   (if current.frag[] <> none then
                       (i = current.index) and (current.frag[]->f.equal)->value
                   if)
                else
                   (i = current.index)->value
               if)
            #);
          
       enter (i,f[])
       #);
     findPD:
       (# aPD: ^Element; aDiagram: ^Diagram; 
       enter myFind->aPD[]
       do (if aPD[] <> none then aPD.e[]->aDiagram[];  if); 
       exit aDiagram[]
       #);
     insertPD:
       (# aPD: ^Element; index: @Integer; frag: ^text; e: ^Diagram; 
       enter (index,frag[],e[])
       do
          &Element[]->aPD[];
          (index,frag[],e[])->(aPD.index,aPD.frag[],aPD.e[]);
          aPD[]->append;
          
       #);
     deletePD: (#  enter myFind->at->delete #);
     deleteProp:
       (#
          findProp:
            (# p: ^Diagram; aPD: ^Element; 
            enter p[]
            do
               scanner: scan
                 (# 
                 do
                    (if current.e[] = p[] then
                        current[]->aPD[]; leave scanner
                    if);
                    
                 #);
               
            exit aPD[]
            #);
          
       enter findProp->at->delete
       #);
     GetSubPatternDiagrams:
       (#
          theDiagram,aPatternDiagram: ^PatternDeclDiagram;
          aList: ^DiagramList;
          
       enter theDiagram[]
       do
          &DiagramList[]->aLIst[];
          scan
            (# 
            do
               (if current.e## <= PatternDeclDiagram##
                // true then
                   current.e[]->aPatternDiagram[];
                   (if aPatternDiagram.thePrefix <> none
                    // true then
                       (if
                       aPatternDiagram.thePrefix
                         ->(theDiagram.theDescriptor).equal
                        // true then current[]->aList.append; 
                       if)
                   if)
               if)
            #);
          
       exit aList[]
       #);
     GetSortableSubPatternDiagrams:
       (#
          theDiagram,aPatternDiagram: ^PatternDeclDiagram;
          aList: ^SortableDiagramList;
          
       enter theDiagram[]
       do
          &SortableDiagramList[]->aList[];
          scan
            (# 
            do
               (if current.e## <= PatternDeclDiagram## then
                   current.e[]->aPatternDiagram[];
                   (if aPatternDiagram.thePrefix <> none then
                       (if
                       aPatternDiagram.thePrefix
                         ->(theDiagram.theDescriptor).equal then
                           current.e[]->aList.insert; 
                       if)
                   if)
               if)
            #);
          
       exit aList[]
       #);
     scanPatternDiagrams: scan
       (# thisDiagram: ^PatternDeclDiagram; 
       do
          (if current.e## <= PatternDeclDiagram##
           // true then current.e[]->thisDiagram[]; INNER ; 
          if)
       #);
     scanFragmentDiagrams: scan
       (# thisDiagram: ^fragmentDiagram; 
       do
          (if current.e## <= FragmentDiagram##
           // true then current.e[]->thisDiagram[]; INNER ; 
          if)
       #);
     scanPropertyDiagrams: scan
       (# thisDiagram: ^SimplePropertyDiagram; 
       do
          (if current.e## <= SimplePropertyDiagram##
           // true then current.e[]->thisDiagram[]; INNER ; 
          if)
       #);
     dump:
       (# 
       do
          'Diagram list:'->putline;
          scan
            (# 
            do
               ' ('->puttext;
               current.index->putint;
               ', '->puttext;
               (if current.frag[] <> none then
                   current.frag[]->puttext
                else
                   'none'->puttext
               if);
               ', '->puttext;
               current.e.titleText[]->puttext;
               ')'->puttext
            #);
          newline;
          newline
       #);
     
  #);
(* LIST HANDLING *)
SortableDiagramList: ArrayContainer
  (#
     currentInx: @integer;
     element::< Diagram;
     less::< 
       (# lx,ly,rx,ry: @integer
       do
          left.titleNode.center->(lx,ly);
          right.titleNode.center->(rx,ry);
          lx < rx->value
       #);
     insert:
       (# elm: ^element
       enter elm[]
       do
          currentInx+1->currentInx;
          (if currentInx > capacity then capacityExtend if);
          (elm[],currentInx)->put
       #);
     sort: (#  do (if currentInx > 0 then currentInx->quickSort if) #)
  #);
  

-- DiagramLib: Attributes --
DisplayAst:
  (# anAST: ^MPS.AST; pos: @Point; 
  enter (anAST[],pos)
  do <<SLOT DisplayAST:Descriptor>>; 
  exit pos
  #);
scanAttributeDecls:
  (#
     theAtt: ^betaGram.Attributes;
     anAst: ^mps.ast;
     ndl: ^betaGram.names;
     unExp: ^mps.unExpanded;
     thisAttribute:<
       (# nd: ^betaGram.nameDcl
       enter nd[]
       do INNER
       #);
     thisUnExp:<
       (# unExp: ^mps.unExpanded
       enter unExp[]
       do INNER
       #);
     thisOptional:<
       (# opt: ^mps.Optional
       enter opt[]
       do INNER
       #);
     thisSlot:<
       (# theSlot: ^mps.SlotDesc
       enter theSlot[]
       do INNER
       #);
     
  enter theAtt[]
  do
     (if switch[70]
      // true then
         'scanAttributeDecls'->screen.putline; 
     if);
     theAtt.scan
       (# att: ^betaGram.attributeDecl
       do
          (if switch[70]
           // true then '*'->screen.put
          if);
          (if current.kind
           // mps.kinds.interior then
              current[]->att[];
              att.getSon1->anAst[];
              (if switch[70]
               // true then
                  'interior: '->screen.puttext;
                  anAst.symbol->screen.putint;
                  screen.newline;
                  
              if);
              (if anAst.symbol
               // betaGram.names then
                  anAst[]->ndl[];
                  ndl.scan
                    (# 
                    do current[]->thisAttribute
                    #)
              if)
           // mps.kinds.unExpanded then
              (if switch[70]
               // true then
                  'unExpanded: '->screen.puttext; 
              if);
              current[]->unExp[];
              (if unExp.isSlot
               // true then
                  (if switch[70] // true then 'Slot'->screen.putline;  if);
                  unExp.theSlot->thisSlot;
                  
               else
                  (if switch[70] // true then screen.newline;  if);
                  unExp[]->thisUnExp;
                  
              if)
           // mps.kinds.optional then
              (if switch[70] // true then 'optional'->screen.putline;  if);
              current[]->thisOptional;
              
          if)
       #);
     (if switch[70] // true then 'DONE'->screen.putline if);
     
  #);
CountAttributes:
  (#
     obj: ^betaGram.ObjectDescriptor;
     main: ^betaGram.MainPart;
     a: ^MPS.AST;
     i: @Integer;
     
  enter obj[]
  do
     (if switch[70] // true then 'CountAttributes '->screen.puttext if);
     (if obj[] <> none
      // true then
         obj.getMainPart->main[];
         main.getAttributes->a[];
         (if a[]
          // none then
             'Attribute error: cannot get attributes from descriptor: '
               ->puttext;
             
          else
             (if a.kind
              // mps.kinds.interior then
                 (if switch[70]
                  // true then 'scanning '->screen.puttext
                 if);
                 a[]
                   ->scanAttributeDecls
                     (#
                        thisAttribute::<  (#  do i+1->i #);
                        thisOptional::<  (#  do i+1->i #);
                        thisUnExp::<  (#  do i+1->i #);
                        
                     #);
                 
             if)
         if)
     if);
     (if switch[70] // true then screen.newline if);
     
  exit i
  #);
CheckKeyWord:
  (#
     node: ^mps.ast;
     keyword: ^text;
     found: @boolean;
     theCom: ^mps.comment;
     theComText,nextWord: ^text;
     
  enter (node[],keyword[])
  do
     (if node.hasComment
      // true then
         node.getComment->theCom[];
         theCom.getText->theComText[];
         theComText.reset;
         search:
           (# 
           do
              theComText.getAtom->nextWord[];
              (if true
               // keyWord[]->nextWord.equal then true->found; 
               else
                  (if theComText.eos // false then restart search if); 
              if);
              
           #);
         
     if);
     
  exit found
  #);
isDescriptorDiagram:
  (#
     theOADDiagram: ^OADDiagram;
     desc: ^betaGram.ObjectDescriptor;
     anAST: ^MPS.AST;
     value: @Boolean
  enter theOADDiagram[]
  do
     theOADDiagram.theDescriptor->desc[];
     (if desc[] <> none then
         desc.father->anAST[]; (if anAST.father = none then true->value if)
     if)
  exit value
  #);
makeNonTerminalSymbol:
  (# symbolName: ^Text
  enter symbolName[]
  do '<<'->symbolName.prepend; '>>'->symbolName.append
  exit symbolName[]
  #);
makeRemote:
  (#
     anAST: ^MPS.AST;
     rem: ^betaGram.remote;
     unExp: ^mps.unexpanded;
     na: ^betaGram.nameApl;
     t: ^text
  enter anAST[]
  do
     &Text[]->t[];
     anAST[]->rem[];
     rem.getAttributeDenotation->anAST[];
     (if anAST.kind = mps.kinds.unExpanded then
         anAST[]->unExp[];
         unExp.NonTerminalSymbol->betaGram.symbolToName->makeNonTerminalSymbol
           ->t.append;
         '.'->t.append
      else
         (if anAST.symbol
          // betaGram.NameApl then
             anAST[]->na[];
             na.getNameAppl->anAST[];
             (if anAST.kind = mps.kinds.unExpanded then
                 '<NameAppl>.'->t.append
              else
                 na.gettext->t.append; '.'->t.append
             if)
          // betaGram.Remote then
             anAST[]->makeRemote->t.append; '.'->t.append
         if)
     if);
     rem.getNameApl->na[];
     na.getNameAppl->anAST[];
     (if anAST.kind = mps.kinds.unExpanded then
         '<NameAppl>'->t.append
      else
         na.gettext->t.append
     if)
  exit t[]
  #);
(****************** DIAGRAM NODES ************************)
AbstractNode: PatternDiagramNode
  (#
     theName: @ReferenceUserData (# Type::< Text #);
     currentDecomposDiagram: @DiagramReferenceUserData
       (# Type::< PatternDiagram #);
     decomposDiagrams: @containerlist (# element::< PatternDiagram #);
     PatternDiagReference: LocalNodesReferenceUserData
       (# Type::< PatternDiagram #);
     onSelect::< 
       (# 
       do
          (PatternDiagrams.oldSelection[],THIS(AbstractNode)[])->changedFocus;
          THIS(AbstractNode)[]->PatternDiagrams.oldSelection[];
          INNER onSelect;
          
       #);
     onRemove::< (* called when THIS(DiagramNode) is deleted *) 
       (#  do <<SLOT AbstractNodeRemove:Descriptor>>;  #);
     Display::< 
       (# t: @Text; pos: @Point; 
       enter pos
       do
          <<SLOT AbstractNodeDisplay:Descriptor>>;
          
       #);
     Redisplay::< 
       (# t: @Text;  do <<SLOT AbstractNodeRedisplay:Descriptor>>;  #);
     ConcludeDisplay::< 
       (# 
       do
          INNER ;
          <<SLOT AbstractNodeConcludeDisplay:Descriptor>>;
          
       #);
     detail::< 
       (# theAST: ^MPS.AST (* the AST to be detailed *)
       do <<SLOT AbstractNodeDetail:Descriptor>>; 
       #);
     detailRecursively::< 
       (# 
       <<SLOT AbstractNodeDetailRecursively:DoPart>>
       #);
     overview::<  (#  <<SLOT AbstractNodeOverview:DoPart>> #);
     abstract::<
     (* if detailed then abstract the decompos diagram *) 
       (#  do <<SLOT AbstractNodeAbstract:Descriptor>>;  #);
     abstractRecursively::< 
       (# 
       <<SLOT AbstractNodeAbstractRecursively:DoPart>>
       #);
     abstractedFromDiagramBelow::<
     (* when THIS(DiagramNode) has been abstrated from a diagram below *) 
       (# 
       do <<SLOT AbstractNodeAbstractedFromDiagramBelow:Descriptor>>; 
       #);
     hasAttributes:
       @BooleanUserData;
     CheckForAttributes:< (#  do INNER exit hasAttributes #);
     onInit::<  (#  <<SLOT AbstractNodeOnInit:DoPart>> #);
     dump::< 
       (# 
       do
          <<SLOT AbstractNodeDump:Descriptor>>;
          INNER
       #)
  #);
(******************** For FragmentDiagrams *********************)
FragmentNode: AbstractNode
  (#
     theFragment: @FragReferenceUserData (# Type::< mps.FragmentForm #);
     theRoot: @ASTReferenceUserData (# type::< mps.ast #);
     sifEditorInstance: ^SifEditor;
     display::< 
       (# 
       enter theFragment
       do <<SLOT FragmentNodeDisplay:Descriptor>>; 
       #);
     redisplay::< 
       (# 
       enter theFragment
       do
          <<SLOT FragmentNodeRedisplay:Descriptor>>;
          
       #);
     ConcludeDisplay::<  (#  do INNER #);
     onDoubleClick::< 
       (# doneInInner: @Boolean
       do
          INNER ;
          (if not doneInInner then false->IndicateSelection; detail if)
       #);
     detail::<  (#  do INNER ; <<SLOT FragmentNodeDetail:Descriptor>> #);
     GetGroup::< 
       (# fd: ^FragmentDiagram; 
       do
          theDiagram->fd[];
          fd.theGroup->fg[];
          
       #);
     GetFragment::< 
       (#  do theFragment->f[];  #);
     theSifEditor::< 
       (# 
       do
          (if se[] = none then
              sifEditorInstance[]->se[]
           else
              se[]->sifEditorInstance[]
          if)
       #);
     CheckForAttributes::<  (#  do true->hasAttributes #);
     onInit::< 
       (# 
       do
          UDPrivate.UDFragmentNode->UserDataInit;
          theRoot.Init;
          theFragment.Init;
          INNER
       #);
     dump::<  (#  do <<SLOT FragmentNodeDump:Descriptor>>;  #);
     
  #);
DoPartNode: FragmentNode
  (#
     display::< 
       (#  do ': DoPart'->t.append;  #);
     onDoubleClick::< 
       (#  do true->doneInInner #);
     onInit::< 
       (# 
       do
          UDPrivate.UDDoPartNode
            ->UserDataInit;
          INNER
       #)
  #);
AttributesNode: FragmentNode
  (#
     display::< 
       (# 
       do ': Attributes'->t.append; 
       #);
     redisplay::< 
       (# 
       do ': Attributes'->t.append; 
       #);
     detail::< 
       (# 
       do
          <<SLOT AttributesNodeDetail:Descriptor>>
       #);
     onInit::<  (#  do UDPrivate.UDAttributesNode->UserDataInit; INNER #);
     
  #);
DescriptorNode: FragmentNode
  (#
     display::<  (#  do ': Descriptor'->t.append;  #);
     redisplay::<  (#  do ': Descriptor'->t.append;  #);
     detail::<  (#  do <<SLOT DescriptorNodeDetail:Descriptor>> #);
     onInit::< 
       (# 
       do
          UDPrivate.UDDescriptorNode
            ->UserDataInit;
          INNER
       #);
     
  #);
DiagramNode: AbstractNode
  (#
     theDeclaration:
       @ASTReferenceUserData (# Type::< betaGram.AttributeDecl #);
     theObjectDescriptor: @ASTReferenceUserData
       (# Type::< betaGram.ObjectDescriptor #);
     thePrefix: @ASTReferenceUserData
       (# Type::< betaGram.ObjectDescriptor #);
     onSelect::<  (#  do enableEditName; INNER onSelect #);
     CheckForAttributes::< 
       (# 
       do (theObjectDescriptor->CountAttributes) > 0->hasAttributes; 
       #);
     Display::< 
       (# anAST: ^MPS.AST; (* either theName or an unExp *) 
       enter (theDeclaration,anAST[])
       do <<SLOT DiagramNodeDisplay:Descriptor>>; 
       #);
     Redisplay::< 
       (#
          anAST: ^MPS.AST;
          (* either theName or an unExp *)
          
       enter (theDeclaration,anAST[])
       do <<SLOT DiagramNodeReDisplay:Descriptor>>
       #);
     ConcludeDisplay::< 
       (# 
       do
          <<SLOT DiagramNodeConcludeDisplay:Descriptor>>;
          INNER
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# help: ^text; ok: @Boolean; indexText: @Text
            <<SLOT DiagramNodeModeOn:DoPart>>
            #);
          ModeOff::< 
            (# t: @Text; noChange: @boolean
            <<SLOT DiagramNodeModeOff:DoPart>>
            #);
          
       #);
     EqualDescriptor:<
       (# aDesc: ^betaGram.ObjectDescriptor; b: @Boolean; 
       enter aDesc[]
       do INNER
       exit b
       #);
     detail::<  (#  do <<SLOT DiagramNodeDetail:Descriptor>> #);
     getASTNode::<
     (* return the AST node THIS(title) is generated from *) 
       (#  do theDeclaration->anAST[]; INNER #);
     GetGroup::<  (#  do <<SLOT DiagramNodeGetGroup:Descriptor>> #);
     GetFragment::< 
       (# 
       do
          <<SLOT DiagramNodeGetFragment:Descriptor>>
       #);
     theSifEditor::<  (# fn: ^FragmentNode <<SLOT theSifEditor:DoPart>> #);
     onInit::<  (#  <<SLOT DiagramNodeOnInit:DoPart>> #);
     dump::< 
       (# 
       do
          <<SLOT DiagramNodeDump:Descriptor>>;
          INNER
       #);
     
  #);
SimpleAttributeDecl: DiagramNode (* SimpleDecl or RepetitionDecl *)
  (#
     declTypeNode: @ReferenceUserData (# Type::< PatternDiagramNode #);
     theReferenceSpec: @ASTReferenceUserData
       (# Type::< betaGram.referenceSpecification #);
     theUnExpRefSpec: @ASTReferenceUserData (# Type::< mps.unExpanded #);
     theQualification: @ASTReferenceUserData
       (# Type::< betaGram.AttributeDecl #);
     theAggregationConnector: @ReferenceUserData
       (# Type:: AggregationConnector #);
     theAssociationConnector: @ReferenceUserData
       (# Type:: AssociationConnector #);
     Display::< 
       (# theObjectSpec: ^MPS.AST
       do
          INNER ;
          (* make theObjectSpec and theReferenceSpec *)
          <<SLOT SimpleAttrDeclDisplay:Descriptor>>;
          
       #);
     Redisplay::< 
       (# theObjectSpec: ^MPS.AST
       do
          INNER ;
          (* make theObjectSpec and theReferenceSpec *)
          <<SLOT SimpleAttrDeclReDisplay:Descriptor>>;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[80] then
                   'Text mode on in SimpleAttributeDeclNode'->putLine; 
               if);
               ' @'->parseableText.putText;
               INNER
            #);
          ModeOff::< 
            (# 
            do
               (if switch[80] then
                   'Text mode off in SimpleAttributeDeclNode '->putLine; 
               if);
               INNER ;
               
            #);
          
       #);
     DisplayReference:< (#  do INNER #);
     displayAggregation:
       (#  <<SLOT SimpleAttrDeclDisplayAggregation:DoPart>> #);
     onInit::< 
       (# 
       do
          UDPrivate.
            UDSimpleAttributeDecl->UserDataInit;
          declTypeNode.Init;
          theReferenceSpec.Init;
          theUnExpRefSpec.Init;
          theQualification.init;
          theAggregationConnector.init;
          theAssociationConnector.init;
          INNER
       #);
     dump::< 
       (#  do <<SLOT SimpleAttributeDecldump:Descriptor>>; INNER #);
     
  #);
SimpleNode: SimpleAttributeDecl
  (#
     onDoubleClick::< 
       (# 
       do
          <<SLOT SimpleNodeDoubleClick:Descriptor>>
       #);
     Display::<  (#  do <<SLOT SimpleNodeDisplay:Descriptor>> #);
     Redisplay::< 
       (# 
       do
          <<SLOT SimpleNodeRedisplay:Descriptor>>
       #);
     DisplayReference::< 
       (#  do <<SLOT SimpleNodeDisplayReference:Descriptor>>;  #);
     onInit::< 
       (# 
       do
          UDPrivate.UDSimpleNode
            ->UserDataInit;
          INNER
       #);
     dump::< 
       (# 
       do
          <<SLOT SimpleNodeDump:Descriptor>>;
          INNER
       #);
     
  #);
RepetitionNode: SimpleAttributeDecl
  (#
     onDoubleClick::< 
       (#  do <<SLOT RepetitionNodeDoubleClick:Descriptor>> #);
     Display::< 
       (# 
       do
          <<SLOT RepetitionNodeDisplay:Descriptor>>
       #);
     Redisplay::<  (#  do <<SLOT RepetitionNodeRedisplay:Descriptor>> #);
     DisplayReference::< 
       (# 
       <<SLOT RepetitionNodeDisplayReference:DoPart>>
       #);
     onInit::<  (#  do UDPrivate.UDRepetitionNode->UserDataInit; INNER #);
     
  #);
PatternNode: DiagramNode
  (#
     Display::< 
       (# pd: ^betaGram.PatternDecl; anAST: ^MPS.AST; 
       do
          (if (theDeclaration)._struc <= betaGram.PatternDecl##
           // true then
              theDeclaration->pd[];
              pd.getObjectDescriptor->anAST[];
              (if anAST.kind
               // mps.kinds.interior then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      ': ...'->t.puttext; 
                  if);
                  
              if);
              pd->SetRegionType;
              
          if);
          DisplayReferences;
          INNER ;
          setupAssociation;
          
       #);
     Redisplay::< 
       (# pd: ^betaGram.PatternDecl; anAST: ^MPS.AST; 
       do
          (if switch[70] then
              (if theDeclaration <> none then
                  '*** patternNode'->putLine;
                  'theDeclaration: '->putText;
                  (theDeclaration).index->putInt;
                  newLine;
                  
              if);
              (if theObjectDescriptor <> none then
                  'theObjectDescriptor: '->putText;
                  (theObjectDescriptor).index->putInt;
                  newLine;
                  
              if);
              
          if);
          (if (theDeclaration)._struc <= betaGram.PatternDecl##
           // true then
              theDeclaration->pd[];
              pd.getObjectDescriptor->anAST[];
              (if anAST.kind
               // mps.kinds.interior then
                  anAST[]->theObjectDescriptor;
                  (if currentDecomposDiagram <> none then
                      anAST[]->(currentDecomposDiagram).theDescriptor
                  if);
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      ': ...'->t.puttext; 
                  if);
                  
              if);
              pd->SetRegionType;
              
          if);
          (if switch[70] then
              (if theDeclaration <> none then
                  'theDeclaration: '->putText;
                  (theDeclaration).index->putInt;
                  newLine;
                  
              if);
              (if theObjectDescriptor <> none then
                  'theObjectDescriptor: '->putText;
                  (theObjectDescriptor).index->putInt;
                  newLine;
                  
              if);
              
          if);
          INNER ;
          
       #);
     onDoubleClick::< 
       (# 
       do
          false->indicateSelection;
          (if switch[30]
           // true then
              'doubleClick PatternDeclaration ID: '->puttext;
              ID->putint;
              newline;
              
          if);
          (if hasAttributes
           // true then detail; 
           else
              (if switch[30] // true then 'no attributes'->putline if)
          if);
          INNER ;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[80] then
                   'Text mode on in PatternNode'->putLine; 
               if);
               ' '->parseableText.put;
               INNER
            #);
          ModeOff::< 
            (# 
            do
               (if switch[80] then
                   'Text mode off in PatternNode '->putLine; 
               if);
               INNER ;
               
            #);
          
       #);
     EqualDescriptor::< 
       (# 
       do
          (if theObjectDescriptor <> none
           // true then aDesc[]->(theObjectDescriptor).equal->b; 
          if);
          INNER ;
          
       #);
     detail::<  (#  do <<SLOT PatternNodeDetail:Descriptor>>;  #);
     DisplayReferences:
       (# 
       do
          <<SLOT PatternNodeDisplayReferences:Descriptor>>;
          
       #);
     DisplayAssociations:
       (#  do <<SLOT DisplayAssociations:Descriptor>>;  #);
     setupAssociation:
       (# 
       do
          <<SLOT PatternNodeSetupAssociation:Descriptor>>
       #);
     onInit::<  (#  <<SLOT PatternNodeOnInit:DoPart>> #);
     dump::< 
       (# 
       <<SLOT PatternNodeDump:DoPart>>
       #);
     
  #);
VirtualNode:
 PatternNode
  (#
     onDoubleClick::<  (#  do INNER ;  #);
     Display::< 
       (#
          vd: ^betaGram.VirtualDecl;
          anAST,a: ^MPS.AST;
          theUnExpObjSpec: ^mps.unexpanded;
          aName: ^betaGram.NameApl;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration)._struc <= betaGram.VirtualDecl##
           // true then
              theDeclaration->vd[];
              vd->SetRegionType;
              ':< '->t.append;
              vd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      ' ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // mps.kinds.unExpanded then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          ' <<NameAppl>>'->t.append
                       // gppProp.asType then
                          t.clear; ':< <<NameAppl>>'->t.append; 
                      if);
                      
                   else
                  (* is a real name *)
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          a[]->theAppl[]; theAppl.getText->t.append
                       // gppProp.asType then
                          t.clear;
                          ':< '->t.append;
                          a[]->theAppl[];
                          theAppl.getText->t.append;
                          
                      if);
                      
                  if)
               // betaGram.Remote then
                  (if gppProp.SimpleDeclDisplay
                   // gppProp.AsNameAndType then
                      anAST[]->MakeRemote->t.append
                   // gppProp.asType then
                      t.clear; ':< '->t.append; anAST[]->MakeRemote->t.append; 
                  if)
               else
                  (if anAST.kind = mps.kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append
                       // gppProp.asType then
                          t.clear;
                          ':< '->t.append;
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append;
                          
                      if)
                  if)
              if);
              
          if);
          betaGram.VirtualDecl->SetRegionType;
          INNER ;
          
       #);
     Redisplay::< 
       (#
          vd: ^betaGram.VirtualDecl;
          anAST,a: ^MPS.AST;
          theUnExpObjSpec: ^mps.unexpanded;
          aName: ^betaGram.NameApl;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration)._struc <= betaGram.VirtualDecl##
           // true then
              theDeclaration->vd[];
              vd->SetRegionType;
              ':< '->t.append;
              vd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      ' ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // mps.kinds.unExpanded then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          ' <<NameAppl>>'->t.append
                       // gppProp.asType then
                          t.clear; ':< <<NameAppl>>'->t.append; 
                      if);
                      
                   else
                  (* is a real name *)
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          a[]->theAppl[]; theAppl.getText->t.append
                       // gppProp.asType then
                          t.clear;
                          ':< '->t.append;
                          a[]->theAppl[];
                          theAppl.getText->t.append;
                          
                      if);
                      
                  if)
               // betaGram.Remote then
                  (if gppProp.SimpleDeclDisplay
                   // gppProp.AsNameAndType then
                      anAST[]->MakeRemote->t.append
                   // gppProp.asType then
                      t.clear; ':< '->t.append; anAST[]->MakeRemote->t.append; 
                  if)
               else
                  (if anAST.kind = mps.kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append
                       // gppProp.asType then
                          t.clear;
                          ':< '->t.append;
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append;
                          
                      if)
                  if)
              if);
              
          if);
          betaGram.VirtualDecl->SetRegionType;
          INNER ;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[80] then
                   'Text mode on in VirtualNode'->putLine; 
               if);
               '< '->parseableText.putText;
               INNER
            #);
          ModeOff::< 
            (# t: @Text
            do
               (if switch[80] then
                   'Text mode off in VirtualNode '->putLine; 
               if);
               INNER ;
               
            #);
          
       #);
     onInit::<  (#  do UDPrivate.UDVirtualNode->UserDataInit; INNER #);
     
  #);
BindingNode: PatternNode
  (#
     onDoubleClick::<  (#  do INNER ;  #);
     Display::< 
       (#
          bd: ^betaGram.BindingDecl;
          anAST,a: ^MPS.AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^mps.unexpanded;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration)._struc <= betaGram.BindingDecl##
           // true then
              theDeclaration->bd[];
              bd->SetRegionType;
              '::< '->t.append;
              bd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      ' ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // mps.kinds.unExpanded then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          ' <<NameAppl>>'->t.append
                       // gppProp.asType then
                          t.clear; '::< <<NameAppl>>'->t.append; 
                      if);
                      
                   else
                  (* is a real name *)
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          a[]->theAppl[]; theAppl.getText->t.append
                       // gppProp.asType then
                          t.clear;
                          '::< '->t.append;
                          a[]->theAppl[];
                          theAppl.getText->t.append;
                          
                      if);
                      
                  if)
               // betaGram.Remote then
                  (if gppProp.SimpleDeclDisplay
                   // gppProp.AsNameAndType then
                      anAST[]->MakeRemote->t.append
                   // gppProp.asType then
                      t.clear; '::< '->t.append; anAST[]->MakeRemote->t.append; 
                  if)
               else
                  (if anAST.kind = mps.kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append
                       // gppProp.asType then
                          t.clear;
                          '::< '->t.append;
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append;
                          
                      if)
                  if)
              if);
              
          if);
          betaGram.BindingDecl->SetRegionType;
          INNER ;
          
       #);
     Redisplay::< 
       (#
          bd: ^betaGram.BindingDecl;
          anAST,a: ^MPS.AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^mps.unexpanded;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration)._struc <= betaGram.BindingDecl##
           // true then
              theDeclaration->bd[];
              bd->SetRegionType;
              '::< '->t.append;
              bd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      ' ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // mps.kinds.unExpanded then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          ' <<NameAppl>>'->t.append
                       // gppProp.asType then
                          t.clear; '::< <<NameAppl>>'->t.append; 
                      if);
                      
                   else
                  (* is a real name *)
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          a[]->theAppl[]; theAppl.getText->t.append
                       // gppProp.asType then
                          t.clear;
                          '::< '->t.append;
                          a[]->theAppl[];
                          theAppl.getText->t.append;
                          
                      if);
                      
                  if)
               // betaGram.Remote then
                  (if gppProp.SimpleDeclDisplay
                   // gppProp.AsNameAndType then
                      anAST[]->MakeRemote->t.append
                   // gppProp.asType then
                      t.clear; '::< '->t.append; anAST[]->MakeRemote->t.append; 
                  if)
               else
                  (if anAST.kind = mps.kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append
                       // gppProp.asType then
                          t.clear;
                          '::< '->t.append;
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append;
                          
                      if)
                  if)
              if);
              
          if);
          betaGram.BindingDecl->SetRegionType;
          INNER ;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[80] then
                   'Text mode on in BindingNode'->putLine; 
               if);
               ':< '->parseableText.putText;
               INNER
            #);
          ModeOff::< 
            (# t: @Text
            do
               (if switch[80] then
                   'Text mode off in BindingNode '->putLine; 
               if);
               INNER ;
               
            #);
          
       #);
     onInit::<  (#  do UDPrivate.UDBindingNode->UserDataInit; INNER #);
     
  #);
FinalNode: PatternNode
  (#
     onDoubleClick::<  (#  do INNER ;  #);
     Display::< 
       (#
          fd: ^betaGram.FinalDecl;
          anAST,a: ^MPS.AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^mps.unexpanded;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration)._struc <= betaGram.FinalDecl##
           // true then
              theDeclaration->fd[];
              fd->SetRegionType;
              ':: '->t.append;
              fd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      ' ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // mps.kinds.unExpanded then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          ' <<NameAppl>>'->t.append
                       // gppProp.asType then
                          t.clear; ':: <<NameAppl>>'->t.append; 
                      if);
                      
                   else
                  (* is a real name *)
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          a[]->theAppl[]; theAppl.getText->t.append
                       // gppProp.asType then
                          t.clear;
                          ':: '->t.append;
                          a[]->theAppl[];
                          theAppl.getText->t.append;
                          
                      if);
                      
                  if)
               // betaGram.Remote then
                  (if gppProp.SimpleDeclDisplay
                   // gppProp.AsNameAndType then
                      anAST[]->MakeRemote->t.append
                   // gppProp.asType then
                      t.clear; ':: '->t.append; anAST[]->MakeRemote->t.append; 
                  if)
               else
                  (if anAST.kind = mps.kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append
                       // gppProp.asType then
                          t.clear;
                          ':: '->t.append;
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append;
                          
                      if)
                  if)
              if);
              
          if);
          betaGram.FinalDecl->SetRegionType;
          INNER ;
          
       #);
     Redisplay::< 
       (#
          fd: ^betaGram.FinalDecl;
          anAST,a: ^MPS.AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^mps.unexpanded;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration)._struc <= betaGram.FinalDecl##
           // true then
              theDeclaration->fd[];
              fd->SetRegionType;
              ':: '->t.append;
              fd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      ' ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // mps.kinds.unExpanded then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          ' <<NameAppl>>'->t.append
                       // gppProp.asType then
                          t.clear; ':: <<NameAppl>>'->t.append; 
                      if);
                      
                   else
                  (* is a real name *)
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          a[]->theAppl[]; theAppl.getText->t.append
                       // gppProp.asType then
                          t.clear;
                          ':: '->t.append;
                          a[]->theAppl[];
                          theAppl.getText->t.append;
                          
                      if);
                      
                  if)
               // betaGram.Remote then
                  (if gppProp.SimpleDeclDisplay
                   // gppProp.AsNameAndType then
                      anAST[]->MakeRemote->t.append
                   // gppProp.asType then
                      t.clear; ':: '->t.append; anAST[]->MakeRemote->t.append; 
                  if)
               else
                  (if anAST.kind = mps.kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append
                       // gppProp.asType then
                          t.clear;
                          ':: '->t.append;
                          theUnExpObjSpec.nonTerminalSymbol
                            ->betaGram.symbolToName->makeNonTerminalSymbol
                            ->t.append;
                          
                      if)
                  if)
              if);
              
          if);
          betaGram.FinalDecl->SetRegionType;
          INNER ;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[80] then 'Text mode on in FinalNode'->putLine;  if);
               ': '->parseableText.putText;
               INNER
            #);
          ModeOff::< 
            (# t: @Text
            do
               (if switch[80] then
                   'Text mode off in FinalNode '->putLine; 
               if);
               INNER ;
               
            #);
          
       #);
     onInit::<  (#  do UDPrivate.UDFinalNode->UserDataInit; INNER #);
     
  #);
NonTerminalNode: AbstractNode
  (#
     unExp: @ASTReferenceUserData (# Type::< mps.unexpanded #);
     synCatName: @ReferenceUserData (# Type::< Text #);
     synCatNo: @IntegerUserData;
     onSelect::<  (#  do disableEditName #);
     onInit::<  (#  do <<SLOT NonTerminalNodeInit:Descriptor>> #);
     display::< 
       (# 
       enter unexp
       do
          <<SLOT NonTerminalNodeDisplay:Descriptor>>
       #);
     redisplay::< 
       (#  enter unexp do <<SLOT NonTerminalNodeRedisplay:Descriptor>>;  #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[80] then
                   'Text mode on NonTerminalNode'->putLine; 
               if);
               (if not ongoingTextediting then
                   true->wrap;
                   theText.get->theTextBefore;
                   true->ongoingTextediting;
                   THIS(NonTerminalNode).size->(oldWidth,oldHeight);
                   (2*GppProp.width,6*GppProp.height)
                     ->THIS(NonTerminalNode).size
               if);
               (* 'Textediting of nonterminal nodes is currently disabled'->gppAlert;
                false->OKtoEnter;*)
               (* THIS(nonterminalNode).size->(oldWidth,oldHeight);
                (oldWidth,oldHeight)->THIS(nonterminalNode).size;
                THIS(nonterminalNode).size->(newWidth,newHeight);*)
               INNER
            #);
          ModeOff::< 
            (# t: @Text
            do
               (if switch[80] then
                   'Text mode off NonterminalNode'->putLine; 
               if);
               (if ongoingTextediting then
                   theText.get->t;
                   (if unExp
                    // none then 'unExp is none!! '->putLine
                    else
                       (if not (theTextBefore[]->t.equal) then
                           (THIS(NonTerminalNode)[],unExp,t[])
                             ->declarationTextChanged;
                           (if parseErrorOccurred then false->OKToExit if)
                        else
                           (oldWidth,oldHeight)->THIS(NonTerminalNode).size;
                           false->ongoingTextediting;
                           false->parseErrorOccurred
                       if)
                   if);
                   (* (oldWidth,oldHeight)->THIS(nonterminalNode).size;*)
                   INNER
               if);
               false->wrap;
               
            #);
          
       #);
     onDoubleClick::<  (#  do <<SLOT NonTerminalDoubleClick:Descriptor>> #);
     detail::<  (#  do 'Detail the nonterminal'->putline #);
     abstract::<  (#  do 'Abstract the nonterminal'->putline #);
     GetGroup::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none
           // true then
                (#
                   fd: ^FragmentDiagram; theDummyFragNode: ^PatternDiagramNode
                do
                   (theDiagram).theFragmentNode->theDummyFragNode[];
                   theDummyFragNode.theDiagram->fd[];
                   fd.theGroup->fg[];
                   
                #);
              
           else
              'DiagramNode: GetGroup: no FragmentNode'->screen.putline
          if);
          
       #);
     GetFragment::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none
           // true then
                (# fn: ^FragmentNode; 
                do (theDiagram).theFragmentNode->fn[]; fn.theFragment->f[]; 
                #);
              
           else
              'DiagramNode: GetFragment: no FragmentNode'->screen.putline
          if);
          
       #);
     theSifEditor::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none then
              (if se[] = none then
                    (# fn: ^FragmentNode; 
                    do
                       (theDiagram).theFragmentNode->fn[];
                       fn.SifEditorInstance[]->se[];
                       
                    #);
                  
               else
                    (# fn: ^FragmentNode; 
                    do
                       (theDiagram).theFragmentNode->fn[];
                       se[]->fn.SifEditorInstance[];
                       
                    #);
                  
              if);
              
           else
              'DiagramNode: theSifEditor: no FragmentNode'->screen.putline
          if);
          
       #);
     dump::<  (#  do <<SLOT NonTerminalNodeDump:Descriptor>>; INNER #);
     
  #);
SlotNode: PatternDiagramNode
  (#
     unExp: @ASTReferenceUserData
       (# Type::< mps.unexpanded #);
     display::< 
       (# pos: @Point; 
       enter (pos,unExp)
       do
          <<SLOT SlotNodeDisplay:Descriptor>>;
          
       #);
     onDoubleClick::<  (#  do INNER ;  #);
     abstract::<  (#  do INNER ;  #);
     detail::<  (#  do INNER ;  #);
     onSelect::< 
       (# 
       do
          (PatternDiagrams.oldSelection[],THIS(SlotNode)[])->changedFocus;
          THIS(SlotNode)[]->PatternDiagrams.oldSelection[];
          disableEditName
       #);
     GetGroup::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none
           // true then
                (#
                   fd: ^FragmentDiagram; theDummyFragNode: ^PatternDiagramNode
                do
                   (theDiagram).theFragmentNode->theDummyFragNode[];
                   theDummyFragNode.theDiagram->fd[];
                   fd.theGroup->fg[];
                   
                #);
              
           else
              'DiagramNode: GetGroup: no FragmentNode'->screen.putline
          if);
          
       #);
     GetFragment::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none
           // true then
                (# fn: ^FragmentNode; 
                do (theDiagram).theFragmentNode->fn[]; fn.theFragment->f[]; 
                #);
              
           else
              'DiagramNode: GetFragment: no FragmentNode'->screen.putline
          if);
          
       #);
     theSifEditor::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none then
              (if se[] = none then
                    (# fn: ^FragmentNode; 
                    do
                       (theDiagram).theFragmentNode->fn[];
                       fn.SifEditorInstance[]->se[];
                       
                    #);
                  
               else
                    (# fn: ^FragmentNode; 
                    do
                       (theDiagram).theFragmentNode->fn[];
                       se[]->fn.SifEditorInstance[];
                       
                    #);
                  
              if);
              
           else
              'DiagramNode: theSifEditor: no FragmentNode'->screen.putline
          if);
          
       #);
     dump::< 
       (# 
       do
          '********unExp********'->putline;
          (if unExp <> none then
              (unExp).dump; newline
           else
              'is NONE!'->putline
          if)
       #);
     onInit::< 
       (# 
       do
          UDPrivate.UDSlotNode->UserDataInit;
          unExp.init;
          (if initialisingSaved then
              textJust.leftJustification->theText.just
          if);
          INNER
       #);
     
  #);
(* Mark nodes: for comments and Dexter anchors *)
(* Mark nodes: for comments and Dexter anchors *)
MyCommentNode: CommentNode (* to display the comment *)
  (#
     theMarkNode: @ReferenceUserData (# Type::< CommentMark #);
     onInit::<  (#  do <<SLOT MyCommentNodeOnInit:Descriptor>> #);
     onRemove::< 
       (# 
       do
          <<SLOT CommentNodeOnRemove:Descriptor>>
       #);
     deactivate::<  (#  do <<SLOT CommentNodeDeactivate:Descriptor>> #);
     
  #);
CommentMark: MarkNode
  (#
     open: @BooleanUserData;
     theComment: @ASTReferenceUserData
       (# Type::< mps.LexemText
       #);
     theCommentNode:
       @ReferenceUserData (# Type::< MyCommentNode #);
     theConn: @ReferenceUserData (# Type::< Connector #);
     display::< 
       (# theCom: ^mps.lexemtext
       enter theComment
       do <<SLOT CommentNodeDisplay:Descriptor>>; 
       #);
     activate::< 
       (# 
       do
          <<SLOT CommentMarkActivate:Descriptor>>
       #);
     deactivate::<  (#  do <<SLOT CommentMarkDeactivate:Descriptor>> #);
     onInit::< 
       (# 
       do
          <<SLOT CommentMarkOnInit:Descriptor>>
       #);
     onRemove::<  (#  do <<SLOT CommentMarkOnRemove:Descriptor>> #);
     onDoubleClick::< 
       (# 
       do
          <<SLOT CommentMarkDoubleClick:Descriptor>>
       #);
     onSelect::<  (#  do <<SLOT CommentMarkSelect:Descriptor>> #);
     
  #);
AnchorMark: MarkNode
  (#
     display::< 
       (# 
       do
          <<SLOT AnchorMarkDisplay:Descriptor>>
       #);
     onInit::<  (#  do <<SLOT AnchorMarkOnInit:Descriptor>> #);
     onDoubleClick::< 
       (# 
       do
          <<SLOT AnchorMarkDoubleClick:Descriptor>>
       #);
     activate::<  (#  do <<SLOT AnchorMarkActivate:Descriptor>> #);
     deactivate::< 
       (# 
       do
          <<SLOT AnchorMarkDeactivate:Descriptor>>
       #);
     
  #);
(* CONNECTORS *)
  

-- PatternDiagrams: Descriptor --
(#
   oldSelection: ^PatternDiagramNode;
   astUtils: @
     (#
        getEnclosingDecl:
          (# anAST,tmpAST: ^mps.ast; enclosingDecl: ^betaGram.AttributeDecl
          enter anAST[]
          do
             (if anAST.father <> none then
                 anAST.father->tmpAST[];
                 (if not (tmpAST## <= betaGram.AttributeDecl##) then
                     tmpAST[]->getEnclosingDecl->enclosingDecl[]
                  else
                     tmpAST[]->enclosingDecl[]
                 if)
              else
                 none ->enclosingDecl[]
             if)
          exit enclosingDecl[]
          #);
        getPrefixName:
          (#
             od: ^betaGram.ObjectDescriptor;
             prefixName: ^text;
             anAST: ^mps.ast;
             thePrefix: ^betaGram.prefix;
             theNameApl: ^betaGram.NameApl
          enter od[]
          do
             od.getPrefixOpt->anAST[];
             (if anAST.kind = mps.kinds.interior then
                 anAST[]->thePrefix[];
                 thePrefix.getAttributeDenotation->anAST[];
                 (if anAST.symbol = betaGram.NameApl then
                     anAST[]->theNameApl[];
                     theNameApl.getNameAppl->anAST[];
                     (if anAST.kind <> mps.kinds.unExpanded then
                         theNameApl.getText->prefixName[]
                     if)
                 if)
             if)
          exit prefixName[]
          #)
     #);
   utils: @
     (#
        isAssociationName:
          (# theName: ^text
          enter theName[]
          exit ('OneToOneAssociation'->theName.equalNCS) or
          ('OneToManyAssociation'->theName.equalNCS) or
          ('ManyToManyAssociation'->theName.equalNCS)
          #);
        isEmbedAssociationName:
          (# theName: ^text
          enter theName[]
          exit ('AssociationOne'->theName.equalNCS) or
          ('AssociationMany'->theName.equalNCS)
          #);
        isContainerName:
          (# theName: ^text
          enter theName[]
          exit ('arrayContainer'->theName.equalNCS) or
          ('hashTable'->theName.equalNCS) or
          ('extensibleHashTable'->theName.equalNCS) or
          ('List'->theName.equalNCS) or ('Set'->theName.equalNCS) or
          ('MultiSet'->theName.equalNCS) or ('Stack'->theName.equalNCS) or
          ('Queue'->theName.equalNCS) or ('PriorutyQueue'->theName.equalNCS)
          #);
        getEmbedAssMul:
          (#
             leftName,rightName: ^text;
             leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer
          enter (leftName[],rightName[])
          do
             (if true
              // 'AssociationOne'->leftName.equalNCS then
                 (1,1)->(leftMulFrom,leftMulTo)
              // 'AssociationMany'->leftName.equalNCS then
                 (- 1,- 1)->(leftMulFrom,leftMulTo)
             if);
             (if true
              // 'AssociationOne'->rightName.equalNCS then
                 (1,1)->(rightMulFrom,rightMulTo)
              // 'AssociationMany'->rightName.equalNCS then
                 (- 1,- 1)->(rightMulFrom,rightMulTo)
             if)
          exit (leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
          #)
     #);
   theList: @DiagramList;
   redisplayRelations:
     (# connectorList: ^ObjectList
     do
        AssociationList.clear;
        InheritanceList.clear;
        AggregationList.clear;
        theList.scan
          (#
             thePatternDeclDiagram: ^PatternDeclDiagram;
             theFather: ^MPS.AST;
             parentListDiag,theListDiagram: ^ListDiagram;
             theDiagramNode: ^parentListDiag.DiagramNode;
             theNode: ^PatternDiagramNode;
             theSuperNode: ^theListDiagram.AbstractNode;
             node1,node2: ^DesignObject;
             foundInheritance: @boolean;
             con: ^DeletableConnector
          do
             (if current.e## <= FragmentDiagram##
              // true then 
              else
                 (if current.e## <= PatternDeclDiagram## then
                     current.e[]->thePatternDeclDiagram[];
                     (if
                     (thePatternDeclDiagram.theDescriptor).frag.father
                       ->isChecked then
                         thePatternDeclDiagram.theDescriptor->getPrefix
                           ->thePatternDeclDiagram.thePrefix;
                         (if thePatternDeclDiagram.thePrefix <> none then
                             (thePatternDeclDiagram.theDescriptor).father
                               ->theFather[];
                             (if theFather## <= betaGram.AttributeDecl## then
                                 (theFather[],
                                  (thePatternDeclDiagram.thePrefix).father)
                                   ->InheritanceList.insert;
                                 true->foundInheritance
                              else
                             (*could be a singular*)
                                 theFather.father->theFather[];
                                 (if theFather[] <> none then
                                     (if theFather## <= betaGram.AttributeDecl##
                                      then
                                         ((
                                          (thePatternDeclDiagram.theDescriptor).
                                          father).father,
                                          (thePatternDeclDiagram.thePrefix).
                                          father)->InheritanceList.insert;
                                         true->foundInheritance
                                     if)
                                 if)
                             if);
                             (if foundInheritance then
                                 (thePatternDeclDiagram.thePrefix).father
                                   ->AstToNode->theNode[];
                                 (if theNode[] <> none then
                                     theNode.theDiagram->theListDiagram[];
                                     theNode[]->theSuperNode[];
                                     (if theSuperNode.currentDecomposDiagram <>
                                     none then
                                         (if
                                         thePatternDeclDiagram.titleNode.
                                           thePrefixConn <> none then
                                             (
                                             thePatternDeclDiagram.titleNode.
                                               thePrefixConn).getEnds
                                               ->(node1[],node2[]);
                                             node2[]->boxToNode->node2[];
                                             (if node2[] <>
                                             (
                                             theSuperNode.currentDecomposDiagram
                                             ).titleNode[] then
                                                 (thePatternDeclDiagram.
                                                    titleNode.getTopParent,
                                                  thePatternDeclDiagram.
                                                    titleNode[],
                                                  (
                                                  (
                                                  theSuperNode.
                                                    currentDecomposDiagram).
                                                  theSurroundBox).getTopParent,
                                                  (
                                                  theSuperNode.
                                                    currentDecomposDiagram).
                                                  theSurroundBox)
                                                   ->
                                                     (
                                                     thePatternDeclDiagram.
                                                       titleNode.thePrefixConn).
                                                     setEnds
                                             if)
                                          else
                                             &PrefixConnector[]->con[];
                                             (* to prevent onInit from generating code *)
                                             true->con.initialisingSaved;
                                             (thePatternDeclDiagram.titleNode[],
                                              (
                                              theSuperNode.
                                                currentDecomposDiagram).
                                              theSurroundBox)->con.new;
                                             con[]
                                               ->
                                                 thePatternDeclDiagram.titleNode
                                                 .thePrefixConn;
                                             (if not gppProp.specializations
                                              then
                                                 false->con.borderVisible;
                                                 false->con.selectable
                                             if)
                                         if)
                                      else
                                         (if
                                         thePatternDeclDiagram.titleNode.
                                           thePrefixConn <> none then
                                             (
                                             thePatternDeclDiagram.titleNode.
                                               thePrefixConn).delete
                                         if)
                                     if)
                                  else
                                     (if
                                     thePatternDeclDiagram.titleNode.
                                       thePrefixConn <> none then
                                         (
                                         thePatternDeclDiagram.titleNode.
                                           thePrefixConn).delete
                                     if)
                                 if)
                             if)
                         if)
                      else
                         (if thePatternDeclDiagram.theParentNode <> none then
                             (thePatternDeclDiagram.theParentNode).theDiagram
                               ->parentListDiag[];
                             thePatternDeclDiagram.theParentNode
                               ->theDiagramNode[];
                             (if theDiagramNode.thePrefix <> none then
                                 theDiagramNode.thePrefix
                                   ->thePatternDeclDiagram.thePrefix
                             if)
                         if)
                     if)
                 if);
                 current.e[]->theListDiagram[];
                 theListDiagram.localNodes.scan
                   (#
                      thePatternNode: ^theListDiagram.PatternNode;
                      theSimpleNode: ^theListDiagram.SimpleAttributeDecl;
                      anAST: ^mps.ast;
                      theObjectSpec: ^MPS.AST;
                      na: ^betaGram.nameApl;
                      nd: ^betaGram.nameDcl;
                      rem: ^betaGram.remote;
                      thePrefix: ^betaGram.prefix;
                      attDen: ^betaGram.AttributeDenotation;
                      prefixName: ^text;
                      theMainPart: ^betaGram.MainPart;
                      theAttributes: ^betaGram.Attributes;
                      foundAggregation: @Boolean;
                      leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer
                   do
                      false->foundAggregation;
                      (if current## <= theListDiagram.PatternNode## then
                          current[]->thePatternNode[];
                          thePatternNode.setupAssociation
                       else
                          (if current## <= theListDiagram.SimpleAttributeDecl##
                           then
                              current[]->theSimpleNode[];
                              (if theSimpleNode.theReferenceSpec <> none then
                                  (theSimpleNode.theReferenceSpec).getson1
                                    ->theObjectSpec[];
                                  (if theObjectSpec.symbol
                                   // betaGram.ObjectDescriptor then
                                      (if theObjectSpec.frag.father->ischecked
                                       then
                                          none ->theSimpleNode.theQualification;
                                          (theSimpleNode.theObjectDescriptor).
                                          getPrefixOpt->anAST[];
                                          (if anAST.kind = mps.kinds.interior
                                           then
                                              anAST[]->thePrefix[];
                                              thePrefix.getAttributeDenotation
                                                ->attDen[];
                                              (if attDen.symbol =
                                              betaGram.NameApl then
                                                  attDen[]->na[];
                                                  na.getText->prefixName[];
                                                  (if
                                                  ('arrayContainer'
                                                     ->prefixName.equalNCS) or
                                                  ('hashTable'
                                                     ->prefixName.equalNCS) or
                                                  ('extensibleHashTable'
                                                     ->prefixName.equalNCS) or
                                                  ('List'->prefixName.equalNCS)
                                                  or
                                                  ('Set'->prefixName.equalNCS)
                                                  or
                                                  ('MultiSet'
                                                     ->prefixName.equalNCS) or
                                                  ('Stack'->prefixName.equalNCS)
                                                  or
                                                  ('Queue'->prefixName.equalNCS)
                                                  or
                                                  ('PriorityQueue'
                                                     ->prefixName.equalNCS) then
                                                      (
                                                      theSimpleNode.
                                                        theObjectDescriptor).
                                                      getMainPart
                                                        ->theMainPart[];
                                                      theMainPart.getAttributes
                                                        ->theAttributes[];
                                                      theAttributes.newScan
                                                        (#
                                                           theFinalDecl:
                                                             ^betaGram.
                                                                FinalDecl;
                                                           os:
                                                             ^betaGram.
                                                                ObjectSpecification;
                                                           na:
                                                             ^betaGram.NameApl;
                                                           theRemote:
                                                             ^betaGram.remote;
                                                           theNames:
                                                             ^betaGram.Names;
                                                           theNameDcl:
                                                             ^betaGram.NameDcl;
                                                           t: ^text
                                                        do
                                                           (if current.symbol =
                                                           betaGram.FinalDecl
                                                            then
                                                               current[]
                                                                 ->
                                                                   theFinalDecl[];
                                                               theFinalDecl.
                                                                 getNames
                                                                 ->theNames[];
                                                               theNames.getSon1
                                                                 ->theNameDcl[];
                                                               theNameDcl.
                                                                 getText->t[];
                                                               (if
                                                               'element'
                                                                 ->t.equalNCS
                                                                then
                                                                   theFinalDecl.
                                                                     getObjectSpecification
                                                                     ->os[];
                                                                   (if
                                                                   os.symbol
                                                                    //
                                                                    betaGram.
                                                                      NameApl
                                                                    then
                                                                       os[]
                                                                         ->na[];
                                                                       (
                                                                       (
                                                                       na.dclRef
                                                                       ).father)
                                                                         .father
                                                                         ->
                                                                           theSimpleNode
                                                                           .
                                                                             theQualification;
                                                                       
                                                                    //
                                                                    betaGram.
                                                                      Remote
                                                                    then
                                                                       os[]
                                                                         ->
                                                                           theRemote[];
                                                                       theRemote
                                                                       .
                                                                         getNameApl
                                                                         ->na[];
                                                                       (
                                                                       (
                                                                       na.dclRef
                                                                       ).father)
                                                                         .father
                                                                         ->
                                                                           theSimpleNode
                                                                           .
                                                                             theQualification
                                                                   if)
                                                               if)
                                                           if)
                                                        #);
                                                      (if
                                                      theSimpleNode.
                                                        theQualification <> none
                                                      then
                                                          true
                                                            ->foundAggregation;
                                                          (1,1,- 1,- 1)
                                                            ->
                                                              (leftMulFrom,
                                                               leftMulTo,
                                                               rightMulFrom,
                                                               rightMulTo)
                                                      if)
                                                  if);
                                                  
                                              if)
                                          if)
                                      if)
                                   // betaGram.NameApl then
                                      (if theObjectSpec.frag.father->ischecked
                                       // true then
                                          theObjectSpec[]->na[];
                                          (if
                                          ((theSimpleNode.theReferenceSpec).
                                           symbol = betaGram.DynamicItem) or
                                          ((theSimpleNode.theReferenceSpec).
                                           symbol = betaGram.StaticItem) then
                                              na.dclRef->nd[];
                                              (nd.father).father
                                                ->
                                                  theSimpleNode.
                                                    theQualification;
                                              (if
                                              (theSimpleNode.theDeclaration).
                                              symbol = betaGram.RepetitionDecl
                                               then
                                                  true->foundAggregation;
                                                  (1,1,- 1,- 1)
                                                    ->
                                                      (leftMulFrom,leftMulTo,
                                                       rightMulFrom,rightMulTo)
                                               else
                                                  true->foundAggregation;
                                                  (1,1,1,1)
                                                    ->
                                                      (leftMulFrom,leftMulTo,
                                                       rightMulFrom,rightMulTo)
                                              if)
                                          if)
                                      if);
                                      
                                   // betaGram.remote then
                                      (if theObjectSpec.frag.father->ischecked
                                       // true then
                                          theObjectSpec[]->rem[];
                                          rem.getnameApl->na[];
                                          (if
                                          ((theSimpleNode.theReferenceSpec).
                                           symbol = betaGram.DynamicItem) or
                                          ((theSimpleNode.theReferenceSpec).
                                           symbol = betaGram.StaticItem) then
                                              na.dclRef->nd[];
                                              (nd.father).father
                                                ->
                                                  theSimpleNode.
                                                    theQualification;
                                              (if
                                              (theSimpleNode.theDeclaration).
                                              symbol = betaGram.RepetitionDecl
                                               then
                                                  true->foundAggregation;
                                                  (1,1,- 1,- 1)
                                                    ->
                                                      (leftMulFrom,leftMulTo,
                                                       rightMulFrom,rightMulTo)
                                               else
                                                  true->foundAggregation;
                                                  (1,1,1,1)
                                                    ->
                                                      (leftMulFrom,leftMulTo,
                                                       rightMulFrom,rightMulTo)
                                              if);
                                              (*  (theDeclaration,theQualification)
                                               ->patternDiagrams.DynReferenceList.insert*)
                                              
                                          if)
                                      if);
                                      
                                  if);
                                  (if foundAggregation then
                                      (theSimpleNode.theDeclaration,
                                       theSimpleNode.theQualification,
                                       leftMulFrom,leftMulTo,rightMulFrom,
                                       rightMulTo)
                                        ->patternDiagrams.AggregationList.insert
                                  if)
                              if)
                          if)
                      if)
                   #)
             if)
          #);
        theList.scan
          (#
             thePatternDeclDiagram: ^PatternDeclDiagram;
             theListDiagram: ^ListDiagram
          do
             (if current.e## <= FragmentDiagram## then
                 
              else
                 current.e[]->theListDiagram[];
                 theListDiagram.localNodes.scan
                   (# theSimpleNode: ^theListDiagram.SimpleAttributeDecl
                   do
                      (if current## <= theListDiagram.SimpleAttributeDecl## then
                          current[]->theSimpleNode[];
                          theSimpleNode.displayReference
                      if)
                   #)
             if)
          #)
     #);
   AssociationList: @Set
     (#
        element::< Ends;
        equal:: 
          (# 
          do
             (left.left = right.left) and (left.right = right.right) and
             (left.leftFrag[]->right.leftFrag.equal) and
             (left.rightFrag[]->right.rightFrag.equal)->value;
             (if (left.associationFrag[] = none ) or
             (right.associationFrag[] = none ) then
                 (left.associationFrag[] = none ) and
                 (right.associationFrag[] = none ) and value->value
              else
                 (left.associationPattern = right.associationPattern) and
                 (left.associationFrag[]->right.associationFrag.equal) and value
                   ->value
             if)
          #);
        Ends:
          (#
             left,right,leftMulFrom,leftMulTo,rightMulFrom,rightMulTo,
               associationPattern: @integer;
             leftFrag,rightFrag,associationFrag: ^text;
             save:
               (# 
               do
                  1+attributeID->attributeID;
                  (id,attributeID,left)->writeIntegerUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,right)->writeIntegerUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,leftMulFrom)->writeIntegerUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,leftMulTo)->writeIntegerUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,rightMulFrom)->writeIntegerUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,rightMulTo)->writeIntegerUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,associationPattern)->writeIntegerUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,leftFrag[])->writeTextUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,rightFrag[])->writeTextUserData;
                  1+attributeID->attributeID;
                  (if associationFrag[] <> none then
                      (id,attributeID,associationFrag[])->writeTextUserData
                   else
                      (id,attributeID,' ')->writeTextUserData
                  if)
               #);
             dump:
               (# 
               do
                  newline;
                  'leftFrag: '->puttext;
                  leftFrag[]->putline;
                  'left: '->puttext;
                  left->putint;
                  'Multiplicities: '->puttext;
                  leftMulFrom->putint;
                  '..'->puttext;
                  leftMulTo->putint;
                  newline;
                  'rightFrag: '->puttext;
                  rightFrag[]->putline;
                  'right: '->puttext;
                  right->putint;
                  ' Multiplicities: '->puttext;
                  rightMulFrom->putint;
                  '..'->puttext;
                  rightMulTo->putint;
                  newline;
                  'associationFrag: '->puttext;
                  (if associationFrag[] <> none then
                      associationFrag[]->putline;
                      'associationPattern: '->puttext;
                      associationPattern->putint;
                      newline
                   else
                      'is NONE'->putline
                  if);
                  newline
               #)
          #);
        insert:
          (#
             left,right,associationPattern: ^betaGram.AttributeDecl;
             leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer;
             theElm: ^Ends
          enter
          (left[],right[],leftMulFrom,leftMulTo,rightMulFrom,rightMulTo,
           associationPattern[])
          do
             &Ends[]->theElm[];
             left.index->theElm.left;
             left.frag.fullname->theElm.leftFrag[];
             right.index->theElm.right;
             right.frag.fullname->theElm.rightFrag[];
             leftMulFrom->theElm.leftMulFrom;
             leftMulTo->theElm.leftMulTo;
             rightMulFrom->theElm.rightMulFrom;
             rightMulTo->theElm.rightMulTo;
             (if associationPattern[] <> none then
                 associationPattern.frag.fullname->theElm.associationFrag[];
                 associationPattern.index->theElm.associationPattern
             if);
             theElm[]->THIS(Set).insert
          #);
        remove:
          (# anAST: ^MPS.AST
          enter anAST[]
          do
             (if anAST.kind = mps.kinds.interior then
                 (if anAST## <= betaGram.AttributeDecl## then
                     scan
                       (# 
                       do
                          (if
                          ((current.left = anAST.index) and
                           (anAST.frag.fullname->current.leftFrag.equal)) or
                          ((current.right = anAST.index) and
                           (anAST.frag.fullname->current.rightFrag.equal)) or
                          ((current.associationPattern = anAST.index) and
                           (current.associationFrag[]
                              ->(anAST.frag.fullname).equal)) then
                              current[]->delete
                          if)
                       #)
                 if)
             if)
          #);
        update:
          (#
             anAST,enclosingDecl,tmpAst: ^MPS.AST;
             theNameDcl: ^betaGram.NameDcl;
             theNames: ^betaGram.Names;
             theAttributeDecl: ^betaGram.AttributeDecl;
             theObjectDescriptor: ^betaGram.ObjectDescriptor;
             theMainPart: ^betaGram.MainPart;
             theAttributes: ^betaGram.Attributes;
             oldPrefix: ^betaGram.Prefix;
             getPossibleAssociationDecl:
               (#
                  anAST,NameDeclAst,enclosingDecl,tmpAst: ^mps.ast;
                  theNameDcl: ^betaGram.NameDcl;
                  theNameApl: ^betaGram.NameApl;
                  thePatternDecl: ^betaGram.PatternDecl;
                  theRefSpec: ^betaGram.ReferenceSpecification;
                  theObjectDescriptor: ^betaGram.ObjectDescriptor;
                  pref: ^betaGram.Prefix;
                  theName: ^text;
                  checkPrefix:
                    (# thePrefix: ^betaGram.Prefix
                    enter thePrefix[]
                    do
                       thePrefix.getAttributeDenotation->tmpAst[];
                       (if tmpAst.symbol = betaGram.NameApl then
                           tmpAst[]->theNameApl[];
                           theNameApl.getNameAppl->tmpAst[];
                           (if tmpAst.kind <> mps.kinds.unExpanded then
                               theNameApl.getText->theName[];
                               (if switch[53] then
                                   'getPossibleAssociationDecl - theName: '
                                     ->puttext;
                                   theName[]->putline
                               if);
                               (if theName[]->utils.isAssociationName then
                                   enclosingDecl[]->anAST[]
                               if)
                           if);
                           
                       if)
                    #)
               enter anAST[]
               do
                  (if switch[53] then
                      'AssociationList getPossibleAssociationDecl: '->puttext;
                      (if anAST[] <> none then
                          anAST.index->putint; newline
                       else
                          'anAST is NONE!'->putline
                      if)
                  if);
                  anAST[]->theNameDcl[];
                  theNameDcl.getNameDecl->NameDeclAst[];
                  (if NameDeclAst.kind <> mps.kinds.unExpanded then
                      theNameDcl.getText->theName[];
                      (if ('leftType'->theName.equalNCS) or
                      ('rightType'->theName.equalNCS) or
                      ('oneType'->theName.equalNCS) or
                      ('ManyElmType'->theName.equalNCS) then
                          (if switch[53] then
                              'getPossibleAssociationDecl: recognized bindingDecl in association pattern'
                                ->putLine
                          if);
                          anAST[]->astUtils.getEnclosingDecl->enclosingDecl[];
                          (if enclosingDecl[] <> none then
                              (if switch[53] then
                                  'getPossibleAssociationDecl - enclosingDecl: '
                                    ->puttext;
                                  enclosingDecl.index->putint;
                                  newline
                              if);
                              (if enclosingDecl.symbol = betaGram.BindingDecl
                               then
                                  (if switch[53] then
                                      'getPossibleAssociationDecl: recognized BindingDecl'
                                        ->putLine
                                  if);
                                  enclosingDecl[]->astUtils.getEnclosingDecl
                                    ->enclosingDecl[];
                                  (if enclosingDecl[] <> none then
                                      (if switch[53] then
                                          'getPossibleAssociationDecl - enclosingDecl: '
                                            ->puttext;
                                          enclosingDecl.index->putint;
                                          newline
                                      if);
                                      (if enclosingDecl.symbol =
                                      betaGram.PatternDecl then
                                          (if switch[53] then
                                              'getPossibleAssociationDecl: recognized SimpleDecl'
                                                ->putLine
                                          if);
                                          (if oldPrefix[] = none
                                          (* Avoids:
                                           If prefix was changed we
                                           get new prefix because using
                                           father ref. navigates into AST
                                           containing newAST *) then
                                              enclosingDecl[]->thePatternDecl[];
                                              thePatternDecl.getObjectDescriptor
                                                ->theObjectDescriptor[];
                                              theObjectDescriptor.getPrefixOpt
                                                ->tmpAst[];
                                              (if tmpAst.kind =
                                              mps.kinds.interior then
                                                  tmpAst[]->checkPrefix
                                              if)
                                           else
                                              oldPrefix[]->checkPrefix
                                          if)
                                      if)
                                  if)
                              if)
                          if)
                      if)
                  if)
               exit anAST[]
               #);
             doUpdate:
               (# anAST: ^mps.ast; anExp: ^mps.expanded
               enter anAST[]
               do
                  (if anAST.kind = mps.kinds.interior then
                      (if anAST## <= betaGram.AttributeDecl## then
                          scan
                            (# 
                            do
                               (if (current.left = anAST.index) and
                               (anAST.frag.fullname->current.leftFrag.equal)
                                then
                                   current[]->delete
                                else
                                   (if (current.right = anAST.index) and
                                   (anAST.frag.fullname
                                      ->current.rightFrag.equal) then
                                       current[]->delete
                                    else
                                       (if
                                       (current.associationPattern =
                                        anAST.index) and
                                       (anAST.frag.fullname
                                          ->current.associationFrag.equal) then
                                           current[]->delete
                                       if)
                                   if)
                               if)
                            #)
                      if);
                      anAST[]->anExp[];
                      anExp.scan
                        (#  do current[]->doUpdate #)
                  if)
               #)
          enter anAST[]
          do
             (if gppProp.globalInteractiveMode <> gppProp.creatingAssociation
              then
                 (if switch[53] then
                     'AssociationList update: '->puttext;
                     (if anAST[] <> none then
                         anAST.index->putint; newline
                      else
                         'anAST is NONE!'->putline
                     if)
                 if);
                 (if anAST.symbol
                  // betaGram.NameDcl then
                     anAST[]->getPossibleAssociationDecl->anAST[]
                  // betaGram.NameApl then
                     anAST[]->astUtils.getEnclosingDecl->enclosingDecl[];
                     (if enclosingDecl[] <> none then
                         (if enclosingDecl.symbol
                          // betaGram.BindingDecl then
                             enclosingDecl[]->theAttributeDecl[];
                             theAttributeDecl.getSon1->theNames[];
                             scanner: theNames.newScan
                               (# tmpAST: ^mps.ast
                               do
                                  current[]->getPossibleAssociationDecl
                                    ->tmpAST[];
                                  (if not (tmpAST[]->current.equal) then
                                      tmpAST[]->anAST[]; leave scanner
                                  if)
                               #)
                          // betaGram.SimpleDecl then
                             enclosingDecl[]->anAST[]
                         if)
                     if)
                  // betaGram.Names then
                     anAST[]->theNames[];
                     scanner: theNames.newScan
                       (# tmpAST: ^mps.ast
                       do
                          current[]->getPossibleAssociationDecl->tmpAST[];
                          (if not (tmpAST[]->current.equal) then
                              tmpAST[]->anAST[]; leave scanner
                          if)
                       #)
                  // betaGram.Attributes then
                     anAST[]->theAttributes[];
                     scanner: theAttributes.newScan
                       (# 
                       do
                          (if current.symbol
                           // betaGram.BindingDecl then
                              current.getSon1->theNames[];
                              theNames.newScan
                                (# tmpAST: ^mps.ast
                                do
                                   current[]->getPossibleAssociationDecl
                                     ->tmpAST[];
                                   (if not (tmpAST[]->current.equal) then
                                       tmpAST[]->anAST[]; leave scanner
                                   if)
                                #)
                          if)
                       #)
                  // betaGram.BindingDecl then
                     anAST[]->theAttributeDecl[];
                     theAttributeDecl.getSon1->theNames[];
                     scanner: theNames.newScan
                       (# tmpAST: ^mps.ast
                       do
                          current[]->getPossibleAssociationDecl->tmpAST[];
                          (if not (tmpAST[]->current.equal) then
                              tmpAST[]->anAST[]; leave scanner
                          if)
                       #)
                  // betaGram.MainPart then
                     anAST[]->theMainPart[];
                     theMainPart.getAttributes->theAttributes[];
                     scanner: theAttributes.newScan
                       (# 
                       do
                          (if current.symbol
                           // betaGram.BindingDecl then
                              current.getSon1->theNames[];
                              theNames.newScan
                                (# tmpAST: ^mps.ast
                                do
                                   current[]->getPossibleAssociationDecl
                                     ->tmpAST[];
                                   (if not (tmpAST[]->current.equal) then
                                       tmpAST[]->anAST[]; leave scanner
                                   if)
                                #)
                          if)
                       #)
                  // betaGram.Prefix then
                     anAST[]->oldPrefix[];
                     (if anAST.father <> none then
                         anAST.father->tmpAst[];
                         (if tmpAst.symbol = betaGram.ObjectDescriptor then
                             tmpAST[]->theObjectDescriptor[];
                             theObjectDescriptor.getMainPart->theMainPart[];
                             theMainPart.getAttributes->theAttributes[];
                             scanner: theAttributes.newScan
                               (# 
                               do
                                  (if current.symbol
                                   // betaGram.BindingDecl then
                                      current.getSon1->theNames[];
                                      theNames.newScan
                                        (# tmpAST: ^mps.ast
                                        do
                                           current[]->getPossibleAssociationDecl
                                             ->tmpAST[];
                                           (if not (tmpAST[]->current.equal)
                                            then
                                               tmpAST[]->anAST[]; leave scanner
                                           if)
                                        #)
                                  if)
                               #)
                         if)
                     if)
                  // betaGram.ObjectDescriptor then
                     anAST[]->theObjectDescriptor[];
                     theObjectDescriptor.getPrefixOpt->tmpAST[];
                     (if tmpAST.kind = mps.kinds.interior then
                         tmpAST[]->oldPrefix[];
                         theObjectDescriptor.getMainPart->theMainPart[];
                         theMainPart.getAttributes->theAttributes[];
                         scanner: theAttributes.newScan
                           (# 
                           do
                              (if current.symbol
                               // betaGram.BindingDecl then
                                  current.getSon1->theNames[];
                                  theNames.newScan
                                    (# tmpAST: ^mps.ast
                                    do
                                       current[]->getPossibleAssociationDecl
                                         ->tmpAST[];
                                       (if not (tmpAST[]->current.equal) then
                                           tmpAST[]->anAST[]; leave scanner
                                       if)
                                    #)
                              if)
                           #)
                     if)
                  // betaGram.DynamicItem then
                     anAST[]->astUtils.getEnclosingDecl->enclosingDecl[];
                     (if enclosingDecl[] <> none then
                         enclosingDecl[]->anAST[]
                     if)
                 if);
                 (if switch[53] then
                     'AssociationList doUpdate: '->puttext;
                     (if anAST[] <> none then
                         anAST.index->putint; newline
                      else
                         'anAST is NONE!'->putline
                     if)
                 if);
                 anAST[]->doUpdate
             if)
          #);
        updateElement:
          (#
             left,right,associationPattern,newLeft,newRight,
               newAssociationPattern: ^betaGram.AttributeDecl;
             leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer
          enter
          (left[],right[],associationPattern[],newLeft[],newRight[],
           newAssociationPattern[],leftMulFrom,leftMulTo,rightMulFrom,
           rightMulTo)
          do
             (if switch[53] then
                 'AssociationList - update element '->putline
             if);
             find
               (#
                  predicate:: 
                    (# anAST: ^mps.ast
                    do
                       (if associationPattern[] <> none then
                           (current.left = left.index) and
                           (left.frag.fullname->current.leftFrag.equal) and
                           (current.right = right.index) and
                           (right.frag.fullname->current.rightFrag.equal) and
                           (current.associationPattern =
                            associationPattern.index) and
                           (associationPattern.frag.fullname
                              ->current.associationFrag.equal)->value
                        else
                           (current.left = left.index) and
                           (left.frag.fullname->current.leftFrag.equal) and
                           (current.right = right.index) and
                           (right.frag.fullname->current.rightFrag.equal) and
                           (current.associationPattern = 0)->value
                       if)
                    #);
                  notFound:: 
                    (# 
                    do
                       (newLeft[],newRight[],leftMulFrom,leftMulTo,rightMulFrom,
                        rightMulTo,newAssociationPattern[])->insert
                    #)
               do
                  newLeft.index->current.left;
                  newLeft.frag.fullname->current.leftFrag[];
                  newRight.index->current.right;
                  newRight.frag.fullname->current.rightFrag[];
                  leftMulFrom->current.leftMulFrom;
                  leftMulTo->current.leftMulTo;
                  rightMulFrom->current.rightMulFrom;
                  rightMulTo->current.rightMulTo;
                  (if newAssociationPattern[] <> none then
                      newAssociationPattern.index->current.associationPattern;
                      newAssociationPattern.frag.fullname
                        ->current.associationFrag[]
                   else
                      0->current.associationPattern;
                      none ->current.associationFrag[]
                  if)
               #)
          #);
        attributeID: @integer;
        UDStart: (#  exit 14999 #);
        save:
          (# noOfAttr: @integer; ok: @boolean
          do
             resetSaved;
             size*10->noOfAttr;
             (ID,UDStart,noOfAttr)->writeIntegerUserData;
             UDStart->attributeID;
             scan
               (#  do current.save #)
          #);
        resetSaved:
          (# noOfAttr: @integer; ok: @boolean
          do
             (ID,UDStart)->readIntegerUserData->noOfAttr;
             (for i: noOfAttr repeat (ID,UDStart+i)->deleteUserDataType for)
          #);
        load:
          (#
             noOfAttr: @integer; i: @integer; ok: @boolean; theElm: ^element
          do
             (ID,UDStart)->readIntegerUserData->noOfAttr;
             UDStart->i;
             loop:
             (if i < UDStart+noOfAttr then
                 &element[]->theElm[];
                 (id,i+1->i)->readIntegerUserData->theElm.left;
                 (id,i+1->i)->readIntegerUserData->theElm.right;
                 (id,i+1->i)->readIntegerUserData->theElm.leftMulFrom;
                 (id,i+1->i)->readIntegerUserData->theElm.leftMulTo;
                 (id,i+1->i)->readIntegerUserData->theElm.rightMulFrom;
                 (id,i+1->i)->readIntegerUserData->theElm.rightMulTo;
                 (id,i+1->i)->readIntegerUserData->theElm.associationPattern;
                 (id,i+1->i)->readTextUserData->theElm.leftFrag[];
                 (id,i+1->i)->readTextUserData->theElm.rightFrag[];
                 (id,i+1->i)->readTextUserData->theElm.associationFrag[];
                 theElm[]->THIS(Set).insert;
                 restart loop
             if)
          #);
        dump:
          (# 
          do
             newline;
             'AssociationList: '->putline;
             scan
               (#  do current.dump #);
             'AssociationList END '->putline
          #)
     #);
   InheritanceList: @Set
     (#
        element::< Ends;
        Ends:
          (#
             subFrag,superFrag: ^text;
             sub,super: @integer;
             save:
               (# 
               do
                  1+attributeID->attributeID;
                  (id,attributeID,subFrag[])->writeTextUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,superFrag[])->writeTextUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,sub)->writeIntegerUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,super)->writeIntegerUserData
               #)
          #);
        equal::< 
          (# 
          do
             (left.sub = right.sub) and (left.subFrag[]->right.subFrag.equal)
             and (left.super = right.super) and
             (left.superFrag[]->right.superFrag.equal)->value
          #);
        insert:
          (# subpattern,superpattern: ^betaGram.AttributeDecl; theElm: ^Ends
          enter (subpattern[],superpattern[])
          do
             &Ends[]->theElm[];
             subpattern.frag.fullname->theElm.subFrag[];
             subpattern.index->theElm.sub;
             superpattern.frag.fullname->theElm.superFrag[];
             superpattern.index->theElm.super;
             theElm[]->THIS(Set).insert
          #);
        remove:
          (# anAST: ^MPS.AST
          enter anAST[]
          do
             (if anAST.kind = mps.kinds.interior then
                 (if anAST## <= betaGram.AttributeDecl## then
                     scan
                       (# 
                       do
                          (if (current.sub = anAST.index) and
                          (anAST.frag.fullname->current.subFrag.equal) then
                              current[]->delete
                          if)
                       #)
                 if)
             if)
          #);
        update:
          (#
             anAST: ^MPS.AST;
             doUpdate:
               (# anAST: ^mps.ast; anExp: ^mps.expanded
               enter anAST[]
               do
                  (if anAST.kind = mps.kinds.interior then
                      (if anAST## <= betaGram.AttributeDecl## then
                          scan
                            (# 
                            do
                               (if (current.sub = anAST.index) and
                               (anAST.frag.fullname->current.subFrag.equal) then
                                   current[]->delete
                                else
                                   (if (current.super = anAST.index) and
                                   (anAST.frag.fullname
                                      ->current.superFrag.equal) then
                                       current[]->delete
                                   if)
                               if)
                            #)
                      if);
                      anAST[]->anExp[];
                      anExp.scan
                        (#  do current[]->doUpdate #)
                  if)
               #)
          enter anAST[]
          do
             (if anAST.symbol
              // betaGram.ObjectDescriptor then
                 (if anAST.father <> none then anAST.father->anAST[] if)
              // betaGram.prefix then
                 (if anAST.father <> none then
                     (if (anAST.father).father <> none then
                         (anAST.father).father->anAST[]
                     if)
                 if)
             if);
             anAST[]->doUpdate;
             
          #);
        attributeID: @integer;
        UDStart: (#  exit 15999 #);
        save:
          (# noOfAttr: @integer; ok: @boolean
          do
             resetSaved;
             size*4->noOfAttr;
             (ID,UDStart,noOfAttr)->writeIntegerUserData;
             UDStart->attributeID;
             scan
               (#  do current.save #)
          #);
        resetSaved:
          (# noOfAttr: @integer; ok: @boolean
          do
             (ID,UDStart)->readIntegerUserData->noOfAttr;
             (for i: noOfAttr repeat (ID,UDStart+i)->deleteUserDataType for)
          #);
        load:
          (#
             noOfAttr: @integer; i: @integer; ok: @boolean; theElm: ^element
          do
             (ID,UDStart)->readIntegerUserData->noOfAttr;
             UDStart->i;
             loop:
             (if i < UDStart+noOfAttr then
                 &element[]->theElm[];
                 (id,i+1->i)->readTextUserData->theElm.subFrag[];
                 (id,i+1->i)->readTextUserData->theElm.superFrag[];
                 (id,i+1->i)->readIntegerUserData->theElm.sub;
                 (id,i+1->i)->readIntegerUserData->theElm.super;
                 theElm[]->THIS(Set).insert;
                 restart loop
             if)
          #);
        getSubPatternDiagrams:
          (#
             theDiagram: ^Diagram;
             theParentListDiagram: ^ListDiagram;
             theDiagramNode: ^theParentListDiagram.DiagramNode;
             superIndex: @integer;
             superFrag: ^text;
             aList: ^DiagramList;
             ff: ^mps.fragmentForm;
             theDecl: ^betaGram.AttributeDecl;
             anExp: ^mps.expanded
          enter theDiagram[]
          do
             &DiagramList[]->aList[];
             (if theDiagram.theParentNode <> none then
                 (theDiagram.theParentNode).theDiagram->theParentListDiagram[];
                 theDiagram.theParentNode->theDiagramNode[];
                 (theDiagramNode.theDeclaration).index->superIndex;
                 (theDiagramNode.theDeclaration).frag.fullname->superFrag[];
                 scan
                   (# 
                   do
                      (if (current.super = superIndex) and
                      (current.superFrag[]->superFrag.equal) then
                          current.subFrag[]->topDotOpen->ff[];
                          current.sub->ff.indexToNode->theDecl[];
                          theDecl.getSon2->anExp[];
                          (if anExp## <= betaGram.StaticItem## then
                              anExp.getson1->anExp[]
                          if);
                          (anExp.index,current.subFrag[])->theList.findPD
                            ->theDiagram[];
                          (if theDiagram[] <> none then
                              (current.sub,current.subFrag[],theDiagram[])
                                ->aList.insertPD
                          if)
                      if)
                   #)
             if)
          exit aList[]
          #);
        getSortableSubPatternDiagrams:
          (#
             theDiagram: ^Diagram;
             theParentListDiagram: ^ListDiagram;
             theDiagramNode: ^theParentListDiagram.DiagramNode;
             superIndex: @integer;
             superFrag: ^text;
             aList: ^SortableDiagramList;
             ff: ^mps.fragmentForm;
             theDecl: ^betaGram.AttributeDecl;
             anExp: ^mps.expanded
          enter theDiagram[]
          do
             &SortableDiagramList[]->aList[];
             aList.init;
             (if theDiagram.theParentNode <> none then
                 (theDiagram.theParentNode).theDiagram->theParentListDiagram[];
                 theDiagram.theParentNode->theDiagramNode[];
                 (theDiagramNode.theDeclaration).index->superIndex;
                 (theDiagramNode.theDeclaration).frag.fullname->superFrag[];
                 scan
                   (# 
                   do
                      (if (current.super = superIndex) and
                      (current.superFrag[]->superFrag.equal) then
                          current.subFrag[]->topDotOpen->ff[];
                          current.sub->ff.indexToNode->theDecl[];
                          theDecl.getSon2->anExp[];
                          (if anExp## <= betaGram.StaticItem## then
                              anExp.getson1->anExp[]
                          if);
                          (anExp.index,current.subFrag[])->theList.findPD
                            ->theDiagram[];
                          (if theDiagram[] <> none then
                              theDiagram[]->aList.insert
                          if)
                      if)
                   #)
             if)
          exit aList[]
          #);
        getSuperPatternDiagram:
          (#
             theDiagram,superDiagram: ^Diagram;
             theParentListDiagram: ^ListDiagram;
             theDiagramNode: ^theParentListDiagram.DiagramNode;
             subIndex: @integer;
             subFrag: ^text;
             ff: ^mps.fragmentForm;
             theDecl: ^betaGram.AttributeDecl;
             anExp: ^mps.expanded
          enter theDiagram[]
          do
             (if theDiagram.theParentNode <> none then
                 (theDiagram.theParentNode).theDiagram->theParentListDiagram[];
                 theDiagram.theParentNode->theDiagramNode[];
                 (theDiagramNode.theDeclaration).index->subIndex;
                 (theDiagramNode.theDeclaration).frag.fullname->subFrag[];
                 scan
                   (# 
                   do
                      (if (current.sub = subIndex) and
                      (current.subFrag[]->subFrag.equal) then
                          current.superFrag[]->topDotOpen->ff[];
                          current.super->ff.indexToNode->theDecl[];
                          theDecl.getSon2->anExp[];
                          (if anExp## <= betaGram.StaticItem## then
                              anExp.getson1->anExp[]
                          if);
                          (anExp.index,current.superFrag[])->theList.findPD
                            ->superDiagram[]
                      if)
                   #)
             if)
          exit superDiagram[]
          #);
        dump:
          (# 
          do
             newline;
             'InheritanceList: '->putline;
             scan
               (# 
               do
                  'subFrag: '->puttext;
                  current.subFrag[]->putline;
                  'sub: '->puttext;
                  current.sub->putint;
                  newline;
                  'superFrag: '->puttext;
                  current.superFrag[]->putline;
                  'super: '->puttext;
                  current.super->putint;
                  newline
               #)
          #)
     #);
   AggregationList: @Set
     (#
        element:: Ends;
        equal:: 
          (# 
          do
             (left.left = right.left) and (left.right = right.right) and
             (left.leftFrag[]->right.leftFrag.equal) and
             (left.rightFrag[]->right.rightFrag.equal)->value
          #);
        Ends:
          (#
             left,right,leftMulFrom,leftMulTo,rightMulFrom,rightMulTo:
               @integer;
             leftFrag,rightFrag: ^text;
             save:
               (# 
               do
                  1+attributeID->attributeID;
                  (id,attributeID,left)->writeIntegerUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,right)->writeIntegerUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,leftMulFrom)->writeIntegerUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,leftMulTo)->writeIntegerUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,rightMulFrom)->writeIntegerUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,rightMulTo)->writeIntegerUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,leftFrag[])->writeTextUserData;
                  1+attributeID->attributeID;
                  (id,attributeID,rightFrag[])->writeTextUserData
               #);
             dump:
               (# 
               do
                  newline;
                  'leftFrag: '->puttext;
                  leftFrag[]->putline;
                  'left: '->puttext;
                  left->putint;
                  'Multiplicities: '->puttext;
                  leftMulFrom->putint;
                  '..'->puttext;
                  leftMulTo->putint;
                  newline;
                  'rightFrag: '->puttext;
                  rightFrag[]->putline;
                  'right: '->puttext;
                  right->putint;
                  ' Multiplicities: '->puttext;
                  rightMulFrom->putint;
                  '..'->puttext;
                  rightMulTo->putint;
                  newline;
                  newline
               #)
          #);
        insert:
          (#
             left,right: ^betaGram.AttributeDecl;
             leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer;
             theElm: ^Ends
          enter (left[],right[],leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
          do
             &Ends[]->theElm[];
             left.index->theElm.left;
             left.frag.fullname->theElm.leftFrag[];
             right.index->theElm.right;
             right.frag.fullname->theElm.rightFrag[];
             leftMulFrom->theElm.leftMulFrom;
             leftMulTo->theElm.leftMulTo;
             rightMulFrom->theElm.rightMulFrom;
             rightMulTo->theElm.rightMulTo;
             theElm[]->THIS(Set).insert
          #);
        remove:
          (# anAST: ^MPS.AST
          enter anAST[]
          do
             (if anAST.kind = mps.kinds.interior then
                 (if anAST## <= betaGram.AttributeDecl## then
                     scan
                       (# 
                       do
                          (if
                          ((current.left = anAST.index) and
                           (anAST.frag.fullname->current.leftFrag.equal)) or
                          ((current.right = anAST.index) and
                           (anAST.frag.fullname->current.rightFrag.equal)) then
                              current[]->delete
                          if)
                       #)
                 if)
             if)
          #);
        update:
          (#
             anAST,enclosingDecl,tmpAst: ^MPS.AST;
             theNameDcl: ^betaGram.NameDcl;
             theNames: ^betaGram.Names;
             theAttributeDecl: ^betaGram.AttributeDecl;
             theObjectDescriptor: ^betaGram.ObjectDescriptor;
             theMainPart: ^betaGram.MainPart;
             theAttributes: ^betaGram.Attributes;
             oldPrefix: ^betaGram.Prefix;
             getPossibleContainerDecl:
               (#
                  anAST,NameDeclAst,enclosingDecl,tmpAst: ^mps.ast;
                  theNameDcl: ^betaGram.NameDcl;
                  theNameApl: ^betaGram.NameApl;
                  theSimpleDecl: ^betaGram.SimpleDecl;
                  theRefSpec: ^betaGram.ReferenceSpecification;
                  theObjectDescriptor: ^betaGram.ObjectDescriptor;
                  pref: ^betaGram.Prefix;
                  theName: ^text;
                  checkPrefix:
                    (# thePrefix: ^betaGram.Prefix
                    enter thePrefix[]
                    do
                       thePrefix.getAttributeDenotation->tmpAst[];
                       (if tmpAst.symbol = betaGram.NameApl then
                           tmpAst[]->theNameApl[];
                           theNameApl.getNameAppl->tmpAst[];
                           (if tmpAst.kind <> mps.kinds.unExpanded then
                               theNameApl.getText->theName[];
                               (if switch[54] then
                                   'getPossibleContainerDecl - theName: '
                                     ->puttext;
                                   theName[]->putline
                               if);
                               (if theName[]->utils.isContainerName then
                                   enclosingDecl[]->anAST[]
                               if)
                           if);
                           
                       if)
                    #)
               enter anAST[]
               do
                  (if switch[54] then
                      'AggregationList getPossibleContainerDecl: '->puttext;
                      (if anAST[] <> none then
                          anAST.index->putint; newline
                       else
                          'anAST is NONE!'->putline
                      if)
                  if);
                  anAST[]->theNameDcl[];
                  theNameDcl.getNameDecl->NameDeclAst[];
                  (if NameDeclAst.kind <> mps.kinds.unExpanded then
                      theNameDcl.getText->theName[];
                      (if 'element'->theName.equalNCS then
                          (if switch[54] then
                              'getPossibleContainerDecl: recognized element'
                                ->putLine
                          if);
                          anAST[]->astUtils.getEnclosingDecl->enclosingDecl[];
                          (if enclosingDecl[] <> none then
                              (if switch[54] then
                                  'getPossibleContainerDecl - enclosingDecl: '
                                    ->puttext;
                                  enclosingDecl.index->putint;
                                  newline
                              if);
                              (if enclosingDecl.symbol = betaGram.FinalDecl then
                                  (if switch[54] then
                                      'getPossibleContainerDecl: recognized FinalDecl'
                                        ->putLine
                                  if);
                                  enclosingDecl[]->astUtils.getEnclosingDecl
                                    ->enclosingDecl[];
                                  (if enclosingDecl[] <> none then
                                      (if switch[54] then
                                          'getPossibleContainerDecl - enclosingDecl: '
                                            ->puttext;
                                          enclosingDecl.index->putint;
                                          newline
                                      if);
                                      (if enclosingDecl.symbol =
                                      betaGram.SimpleDecl then
                                          (if switch[54] then
                                              'getPossibleContainerDecl: recognized SimpleDecl'
                                                ->putLine
                                          if);
                                          (if oldPrefix[] = none
                                          (* Avoids:
                                           If prefix was changed we
                                           get new prefix because using
                                           father ref. navigates into AST
                                           containing newAST *) then
                                              enclosingDecl[]->theSimpleDecl[];
                                              theSimpleDecl.
                                                getReferenceSpecification
                                                ->theRefSpec[];
                                              theRefSpec.getSon1
                                                ->theObjectDescriptor[];
                                              theObjectDescriptor.getPrefixOpt
                                                ->tmpAst[];
                                              (if tmpAst.kind =
                                              mps.kinds.interior then
                                                  tmpAst[]->checkPrefix
                                              if)
                                           else
                                              oldPrefix[]->checkPrefix
                                          if)
                                      if)
                                  if)
                              if)
                          if)
                      if)
                  if)
               exit anAST[]
               #);
             doUpdate:
               (# anAST: ^mps.ast; anExp: ^mps.expanded
               enter anAST[]
               do
                  (if anAST.kind = mps.kinds.interior then
                      (if anAST## <= betaGram.AttributeDecl## then
                          scan
                            (# 
                            do
                               (if (current.left = anAST.index) and
                               (anAST.frag.fullname->current.leftFrag.equal)
                                then
                                   current[]->delete
                                else
                                   (if (current.right = anAST.index) and
                                   (anAST.frag.fullname
                                      ->current.rightFrag.equal) then
                                       current[]->delete
                                   if)
                               if)
                            #)
                      if);
                      anAST[]->anExp[];
                      anExp.scan
                        (#  do current[]->doUpdate #)
                  if)
               #)
          enter anAST[]
          do
             (if gppProp.globalInteractiveMode <> gppProp.creatingAggregation
              then
                 (if switch[54] then
                     'AggregationList update: '->puttext;
                     (if anAST[] <> none then
                         anAST.index->putint; newline
                      else
                         'anAST is NONE!'->putline
                     if)
                 if);
                 (if anAST.symbol
                  // betaGram.NameDcl then
                     anAST[]->getPossibleContainerDecl->anAST[]
                  // betaGram.NameApl then
                     anAST[]->astUtils.getEnclosingDecl->enclosingDecl[];
                     (if enclosingDecl[] <> none then
                         (if enclosingDecl.symbol
                          // betaGram.FinalDecl then
                             enclosingDecl[]->theAttributeDecl[];
                             theAttributeDecl.getSon1->theNames[];
                             scanner: theNames.newScan
                               (# tmpAST: ^mps.ast
                               do
                                  current[]->getPossibleContainerDecl->tmpAST[];
                                  (if not (tmpAST[]->current.equal) then
                                      tmpAST[]->anAST[]; leave scanner
                                  if)
                               #)
                          // betaGram.SimpleDecl then
                             enclosingDecl[]->anAST[]
                          // betaGram.RepetitionDecl then
                             enclosingDecl[]->anAST[]
                         if)
                     if)
                  // betaGram.Names then
                     anAST[]->theNames[];
                     scanner: theNames.newScan
                       (# tmpAST: ^mps.ast
                       do
                          current[]->getPossibleContainerDecl->tmpAST[];
                          (if not (tmpAST[]->current.equal) then
                              tmpAST[]->anAST[]; leave scanner
                          if)
                       #)
                  // betaGram.Attributes then
                     anAST[]->theAttributes[];
                     scanner: theAttributes.newScan
                       (# 
                       do
                          (if current.symbol
                           // betaGram.FinalDecl then
                              current.getSon1->theNames[];
                              theNames.newScan
                                (# tmpAST: ^mps.ast
                                do
                                   current[]->getPossibleContainerDecl
                                     ->tmpAST[];
                                   (if not (tmpAST[]->current.equal) then
                                       tmpAST[]->anAST[]; leave scanner
                                   if)
                                #)
                          if)
                       #)
                  // betaGram.FinalDecl then
                     anAST[]->theAttributeDecl[];
                     theAttributeDecl.getSon1->theNames[];
                     scanner: theNames.newScan
                       (# tmpAST: ^mps.ast
                       do
                          current[]->getPossibleContainerDecl->tmpAST[];
                          (if not (tmpAST[]->current.equal) then
                              tmpAST[]->anAST[]; leave scanner
                          if)
                       #)
                  // betaGram.MainPart then
                     anAST[]->theMainPart[];
                     theMainPart.getAttributes->theAttributes[];
                     scanner: theAttributes.newScan
                       (# 
                       do
                          (if current.symbol
                           // betaGram.FinalDecl then
                              current.getSon1->theNames[];
                              theNames.newScan
                                (# tmpAST: ^mps.ast
                                do
                                   current[]->getPossibleContainerDecl
                                     ->tmpAST[];
                                   (if not (tmpAST[]->current.equal) then
                                       tmpAST[]->anAST[]; leave scanner
                                   if)
                                #)
                          if)
                       #)
                  // betaGram.Prefix then
                     anAST[]->oldPrefix[];
                     (if anAST.father <> none then
                         anAST.father->tmpAst[];
                         (if tmpAst.symbol = betaGram.ObjectDescriptor then
                             tmpAST[]->theObjectDescriptor[];
                             theObjectDescriptor.getMainPart->theMainPart[];
                             theMainPart.getAttributes->theAttributes[];
                             scanner: theAttributes.newScan
                               (# 
                               do
                                  (if current.symbol
                                   // betaGram.FinalDecl then
                                      current.getSon1->theNames[];
                                      theNames.newScan
                                        (# tmpAST: ^mps.ast
                                        do
                                           current[]->getPossibleContainerDecl
                                             ->tmpAST[];
                                           (if not (tmpAST[]->current.equal)
                                            then
                                               tmpAST[]->anAST[]; leave scanner
                                           if)
                                        #)
                                  if)
                               #)
                         if)
                     if)
                  // betaGram.ObjectDescriptor then
                     anAST[]->theObjectDescriptor[];
                     theObjectDescriptor.getPrefixOpt->tmpAST[];
                     (if tmpAST.kind = mps.kinds.interior then
                         tmpAST[]->oldPrefix[];
                         theObjectDescriptor.getMainPart->theMainPart[];
                         theMainPart.getAttributes->theAttributes[];
                         scanner: theAttributes.newScan
                           (# 
                           do
                              (if current.symbol
                               // betaGram.FinalDecl then
                                  current.getSon1->theNames[];
                                  theNames.newScan
                                    (# tmpAST: ^mps.ast
                                    do
                                       current[]->getPossibleContainerDecl
                                         ->tmpAST[];
                                       (if not (tmpAST[]->current.equal) then
                                           tmpAST[]->anAST[]; leave scanner
                                       if)
                                    #)
                              if)
                           #)
                     if)
                  // betaGram.StaticItem // betaGram.DynamicItem then
                     anAST[]->astUtils.getEnclosingDecl->enclosingDecl[];
                     (if enclosingDecl[] <> none then
                         enclosingDecl[]->anAST[]
                     if)
                 if);
                 (if switch[54] then
                     'AggregationList doUpdate: '->puttext;
                     (if anAST[] <> none then
                         anAST.index->putint; newline
                      else
                         'anAST is NONE!'->putline
                     if)
                 if);
                 anAST[]->doUpdate
             if);
             
          #);
        updateElement:
          (#
             left,right,newLeft: ^betaGram.AttributeDecl;
             leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer
          enter
          (left[],right[],newLeft[],leftMulFrom,leftMulTo,rightMulFrom,
           rightMulTo)
          do
             (if switch[54] then
                 'AggregationList - update element: '->puttext;
                 left.index->putint;
                 '  '->puttext;
                 right.index->putint;
                 '  '->puttext;
                 newLeft.index->putint;
                 newline
             if);
             find
               (#
                  predicate:: 
                    (# anAST: ^mps.ast
                    do
                       (current.left = left.index) and
                       (left.frag.fullname->current.leftFrag.equal) and
                       (current.right = right.index) and
                       (right.frag.fullname->current.rightFrag.equal)->value
                    #);
                  notFound:: 
                    (# 
                    do
                       (newLeft[],right[],leftMulFrom,leftMulTo,rightMulFrom,
                        rightMulTo)->insert
                    #)
               do
                  newLeft.index->current.left;
                  newLeft.frag.fullname->current.leftFrag[];
                  right.index->current.right;
                  right.frag.fullname->current.rightFrag[];
                  leftMulFrom->current.leftMulFrom;
                  leftMulTo->current.leftMulTo;
                  rightMulFrom->current.rightMulFrom;
                  rightMulTo->current.rightMulTo
               #)
          #);
        attributeID: @integer;
        UDStart: (#  exit 17999 #);
        save:
          (# noOfAttr: @integer; ok: @boolean
          do
             resetSaved;
             size*8->noOfAttr;
             (ID,UDStart,noOfAttr)->writeIntegerUserData;
             UDStart->attributeID;
             scan
               (#  do current.save #)
          #);
        resetSaved:
          (# noOfAttr: @integer; ok: @boolean
          do
             (ID,UDStart)->readIntegerUserData->noOfAttr;
             (for i: noOfAttr repeat (ID,UDStart+i)->deleteUserDataType for)
          #);
        load:
          (#
             noOfAttr: @integer; i: @integer; ok: @boolean; theElm: ^element
          do
             (ID,UDStart)->readIntegerUserData->noOfAttr;
             UDStart->i;
             loop:
             (if i < UDStart+noOfAttr then
                 &element[]->theElm[];
                 (id,i+1->i)->readIntegerUserData->theElm.left;
                 (id,i+1->i)->readIntegerUserData->theElm.right;
                 (id,i+1->i)->readIntegerUserData->theElm.leftMulFrom;
                 (id,i+1->i)->readIntegerUserData->theElm.leftMulTo;
                 (id,i+1->i)->readIntegerUserData->theElm.rightMulFrom;
                 (id,i+1->i)->readIntegerUserData->theElm.rightMulTo;
                 (id,i+1->i)->readTextUserData->theElm.leftFrag[];
                 (id,i+1->i)->readTextUserData->theElm.rightFrag[];
                 theElm[]->THIS(Set).insert;
                 restart loop
             if)
          #);
        dump:
          (# 
          do
             newline;
             'AggregationList: '->putline;
             scan
               (#  do current.dump #);
             'AggregationList END '->putline
          #)
     #);
   NextFreeLine: @Integer;
   (* indicates where the next PatternDiagram can
    be placed to avoid obscuring another diagrams *)
   NextFreeColumn: @Integer;
   SecondFreeLine: @Integer;
   (* Indicates where to put the next diagram when
    * we ran into the bottom of the page *)
   SecondFreeColumn: @Integer;
   Detailer: ^PatternDiagramNode;
   (* if not NONE then we are currently
    * creating a subdiagram by detailing
    * another node
    *)
   addAfterNode: ^PatternDiagramNode;
   newNode: ^PatternDiagramNode;
   interactiveNewDiagram: ^Diagram;
   (* add newnode to list after addAfterNode when done *)
   
#)  

-- OADPageMakeDesignObject: Descriptor --
(#
   theDiag: ^Diagram;
   NodeType: @Integer;
   theListDiagram: ^ListDiagram;
   theSimplePropertyDiagram: ^SimplePropertyDiagram;
   theNodeID: @integer
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDFragmentDiagram then
       &FragmentDiagram[]->theDiag[];
       (0,none ,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created FragmentDiagram!'->putline
       if)
    // UDPrivate.UDPatternAttDiagram then
       &PatternAttDiagram[]->theDiag[];
       (0,none ,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternAttDiagram!'->putline
       if);
       theDiag[]->theListDiagram[];
       theListDiagram.titleNode.UDtheSurroundBox.getID->theNodeID;
       (if theNodeID <> 0 then
           (theListDiagram[],theNodeID)->makeSurroundBox
       if)
    // UDPrivate.UDPatternDeclDiagram then
       &PatternDeclDiagram[]->theDiag[];
       (0,none ,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternDeclDiagram!'->putline
       if)
    // UDPrivate.UDPatternClassificationDiagram then
       &PatternClassificationDiagram[]->theDiag[];
       (0,none ,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternClassificationDiagram!'->putline
       if)
    // UDPrivate.UDPatternNonTerminalDiagram then
       &PatternNonTerminalDiagram[]->theDiag[];
       (0,none ,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternNonTerminalDiagram!'->putline
       if)
    // UDPrivate.UDSimplePropertyDiagram then
       &SimplePropertyDiagram[]->theDiag[];
       (0,none ,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created SimplePropertyDiagram!'->putline
       if);
       theDiag[]->theSimplePropertyDiagram[];
       theSimplePropertyDiagram.titleNode.UDSurroundBox.getID->theNodeID;
       (if theNodeID <> 0 then
           (theSimplePropertyDiagram[],theNodeID)->makeSurroundBox
       if)
    // UDPrivate.UDPropertyDiagram then
       &PropertyDiagram[]->theDiag[];
       (0,none ,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PropertyDiagram!'->putline
       if)
   if)
#)  

-- MakeLocalNodes: Descriptor --
(#
   rangeStart: @integer;
   rangeEnd: @integer;
   count: @integer;
   localNodeID: @integer;
   NodeType: @integer;
   thePatternDiagNode: ^PatternDiagramNode;
   theSimpleNode: ^theListDiagram.SimpleAttributeDecl;
   thePatternNode: ^theListDiagram.PatternNode;
   theObject: ^DesignObject;
   theNode: ^Node;
   thePropertyDiagram: ^SimplePropertyDiagram;
   regions: [0] @Integer;
   titleID,theNodeID,theConnID: @integer
do
   LocalNodesUserDataStart->rangeStart;
   LocalNodesUserDataEnd->rangeEnd;
   theListDiagram.titleNode.ID->titleID;
   (* &integerRef[]->rangeH[];
    &shortRef[]->count[];
    (titleID,rangeStart,rangeEnd,count[],rangeH[])->UDFindRange->ok;*)
   theListDiagram.titleNode.oldLocalNodesUDAttributes-LocalNodesUserDataStart
     ->count;
   &theListDiagram.LocalNodesDesc[]->theListDiagram.localNodes[];
   (for i: count repeat
     (if userDataVerbose then
         'For titleID: '->puttext;
         titleID->putint;
         ' and attributesID: '->puttext;
         LocalNodesUserDataStart+i->putint;
         ' localNodeID was: '->puttext;
         
     if);
     (titleID,LocalNodesUserDataStart+i)->readIntegerUserData->localNodeID;
     (if localNodeID <> 0 then
         (if userDataVerbose then localNodeID->putint; newline;  if);
         localNodeID->getNodeType->NodeType;
         (if NodeType = UDPrivate.UDPatternDiagramNode then
             &PatternDiagramNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created PatternDiagramNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDAbstractNode then
             &theListDiagram.AbstractNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created AbstractNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDSlotNode then
             &theListDiagram.SlotNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created SlotNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDPropertyNode then
             theListDiagram[]->thePropertyDiagram[];
             &thePropertyDiagram.PropertyNode[]->thePatternDiagNode[]
               ->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeDesignObject: Created PropertyNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDFragmentNode then
             &theListDiagram.FragmentNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created FragmentNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDDiagramNode then
             &theListDiagram.DiagramNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created DiagramNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDNonTerminalNode then
             &theListDiagram.NonTerminalNode[]->thePatternDiagNode[]
               ->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created NonTerminalNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDDoPartNode then
             &theListDiagram.DoPartNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created DoPartNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDAttributesNode then
             &theListDiagram.AttributesNode[]->thePatternDiagNode[]
               ->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created AttributesNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDDescriptorNode then
             &theListDiagram.DescriptorNode[]->thePatternDiagNode[]
               ->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created DescriptorNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDSimpleAttributeDecl then
             &theListDiagram.SimpleAttributeDecl[]->thePatternDiagNode[]
               ->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created SimpleAttributeDecl!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDPatternNode then
             &theListDiagram.PatternNode[]->thePatternDiagNode[]
               ->thePatternNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created PatternNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDSimpleNode then
             &theListDiagram.SimpleNode[]->thePatternDiagNode[]->theSimpleNode[]
               ->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created SimpleNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDRepetitionNode then
             &theListDiagram.RepetitionNode[]->thePatternDiagNode[]
               ->theSimpleNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created RepetitionNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDVirtualNode then
             &theListDiagram.VirtualNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: Created VirtualNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDBindingNode then
             &theListDiagram.BindingNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: BindingNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDFinalNode then
             &theListDiagram.FinalNode[]->thePatternDiagNode[]->theObject[];
             true->thePatternDiagNode.initialisingSaved;
             (if userDataVerbose then
                 'MakeLocalNodes: FinalNode!'->putline
             if)
         if);
         (if NodeType = UDPrivate.UDActivePropertyNode then
             (if theListDiagram## <= SimplePropertyDiagram## then
                 theListDiagram[]->thePropertyDiagram[];
                 &thePropertyDiagram.ActivePropertyNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeDesignObject: Created ActivePropertyNode!'->putline
                 if)
             if)
         if);
         (if NodeType = UDPrivate.UDPassivePropertyNode then
             (if theListDiagram## <= SimplePropertyDiagram## then
                 theListDiagram[]->thePropertyDiagram[];
                 &thePropertyDiagram.PassivePropertyNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeDesignObject: Created PassivePropertyNode!'->putline
                 if)
             if)
         if);
         (if NodeType = UDPrivate.UDOriginPropertyNode then
             (if theListDiagram## <= SimplePropertyDiagram## then
                 theListDiagram[]->thePropertyDiagram[];
                 &thePropertyDiagram.OriginPropertyNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeDesignObject: Created OriginPropertyNode!'->putline
                 if)
             if)
         if);
         (if NodeType = UDPrivate.UDIncludePropertyNode then
             (if theListDiagram## <= SimplePropertyDiagram## then
                 theListDiagram[]->thePropertyDiagram[];
                 &thePropertyDiagram.IncludePropertyNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeDesignObject: Created IncludePropertyNode!'->putline
                 if)
             if)
         if);
         (if NodeType = UDPrivate.UDBodyPropertyNode then
             (if theListDiagram## <= SimplePropertyDiagram## then
                 theListDiagram[]->thePropertyDiagram[];
                 &thePropertyDiagram.BodyPropertyNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeDesignObject: Created BodyPropertyNode!'->putline
                 if)
             if)
         if);
         (if theObject[] <> none then
             theObject[]->theListDiagram.LocalNodes.append;
             localNodeID->theObject.onInit;
             theObject.getRegionIDs->regions;
             (if regions.range > 0 then
                 theObject.onInitRegion; regions->MakeObjectsFromList
             if);
             (if theObject## <= node## then
                 theObject[]->theNode[];
                 false->theNode.moveable;
                 false->theNode.sizeable
             if);
             (if thePatternDiagNode[] <> none then
                 thePatternDiagNode.theMarkNode.getID
                   ->theNodeID
                   (*theMarkNode currently refers to EllipseNode.
                    getID works around qua error.*) ;
                 (if theNodeID <> 0 then
                     (theListDiagram[],theNodeID)->MakeMarkNode
                 if)
             if)
         if)
     if)
   for);
   
#)  

-- MakeMarkNode: Descriptor --
(#
   NodeType,theNodeId,theConnID: @integer;
   theObject: ^DesignObject;
   theCommentMark: ^theListDiagram.CommentMark;
   regions: [0] @Integer
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDCommentMark then
       &theListDiagram.CommentMark[]->theCommentMark[]->theObject[];
       true->theCommentMark.initialisingSaved;
       (if userDataVerbose then
           'MakeMarkNode: Created CommentMark!'->putline
       if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       theObject.getRegionIDs->regions;
       (if regions.range > 0 then
           theObject.onInitRegion; regions->MakeObjectsFromList
       if);
       theCommentMark.theCommentNode.getID
         ->theNodeID
         (*theCommentNode currently refers to RectNode.
          getId works around qua error*) ;
       (if theNodeID <> 0 then
           (theListDiagram[],theNodeID)->MakeCommentNode
       if);
       theCommentMark.theConn.getID->theConnID;
       (if theConnID <> 0 then theConnID->MakeConn if)
   if)
#)  

-- MakeCommentNode: Descriptor --
(#
   NodeType: @integer;
   theObject: ^DesignObject;
   theCommentNode: ^theListDiagram.MyCommentNode;
   regions: [0] @Integer
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDMyCommentNode then
       &theListDiagram.MyCommentNode[]->theCommentNode[]->theObject[];
       true->theCommentNode.initialisingSaved;
       (if userDataVerbose then
           'MakeCommentNode: Created MyCommentNode!'->putline
       if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       theObject.getRegionIDs->regions;
       (if regions.range > 0 then
           theObject.onInitRegion; regions->MakeObjectsFromList
       if)
   if)
#)  

-- MakeUserDataLabelNode: DoPart --
do
     (# NodeType: @integer; theObject: ^DesignObject; regions: [0] @Integer
     do
        ID->getNodeType->NodeType;
        (if NodeType = UDPrivate.UDLabelNode then
            &UserDataLabelNode[]->theObject[];
            (if theObject[] <> none then
                ID->theObject.onInit;
                (if userdataVerbose then
                    'MakeUserDataLabelNode: Created UserDataLabelNode!'->putline
                if);
                theObject.getRegionIDs->regions;
                (if regions.range > 0 then
                    theObject.onInitRegion; regions->MakeObjectsFromList
                if)
            if)
        if)
     #)  

-- MakeConn: Descriptor --
(#
   NodeType,theNodeID: @integer;
   theObject: ^DesignObject;
   regions: [0] @Integer;
   theDeletableConn: ^DeletableConnector;
   theAssociationConnector: ^AssociationConnector
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDPrefixConnector then
       &PrefixConnector[]->theDeletableConn[]->theObject[];
       true->theDeletableConn.initialisingSaved;
       (if userDataVerbose then
           'MakeConn: Created PrefixConnector!'->putline
       if)
    // UDPrivate.UDAssociationConnector then
       &AssociationConnector[]->theDeletableConn[]->theAssociationConnector[]
         ->theObject[];
       true->theDeletableConn.initialisingSaved;
       (if userDataVerbose or switch[53] then
           'MakeConn: Created AssociationConnector!'->putline
       if)
    // UDPrivate.UDAggregationConnector then
       &AggregationConnector[]->theDeletableConn[]->theAssociationConnector[]
         ->theObject[];
       true->theDeletableConn.initialisingSaved;
       (if userDataVerbose or switch[54] then
           'MakeConn: Created AggregationConnector!'->putline
       if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       theObject.getRegionIDs->regions;
       (if regions.range > 0 then
           theObject.onInitRegion; regions->MakeObjectsFromList
       if);
       (if theAssociationConnector[] <> none then
           theAssociationConnector.leftRole.getID->theNodeID;
           (if theNodeID <> 0 then
               (theAssociationConnector[],theNodeID)->MakeRole
           if);
           theAssociationConnector.rightRole.getID->theNodeID;
           (if theNodeID <> 0 then
               (theAssociationConnector[],theNodeID)->MakeRole
           if);
           theAssociationConnector.name.getID->theNodeID;
           (if theNodeID <> 0 then theNodeID->MakeUserDataLabelNode if)
       if)
   if)
#)  

-- MakeRole: DoPart --
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDRole then
       &theAssociationConnector.Role[]->theRole[]->theObject[];
       (if userDataVerbose or switch[53] or switch[54] then
           'MakeRole: Created Role!'->putline
       if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       theObject.getRegionIDs->regions;
       (if regions.range > 0 then
           theObject.onInitRegion; regions->MakeObjectsFromList
       if);
       theRole.name.getID->theNodeID;
       (if theNodeID <> 0 then theNodeID->MakeUserDataLabelNode if);
       theRole.multiplicity.getID->theNodeID;
       (if theNodeID <> 0 then theNodeID->MakeUserDataLabelNode if)
   if)  

-- makeSurroundBox: DoPart --
do
     (#
        NodeType: @integer;
        theListDiagram: ^ListDiagram;
        thePropertyDiagram: ^PropertyDiagram;
        theObject: ^DesignObject;
        regions: [0] @Integer
     do
        ID->getNodeType->NodeType;
        (if NodeType = UDPrivate.UDSurroundBox then
            (if theDiag## <= PropertyDiagram## then
                theDiag[]->thePropertyDiagram[];
                &thePropertyDiagram.surroundBox[]->theObject[]
             else
                &SurroundBox[]->theObject[]
            if);
            (if theObject[] <> none then
                ID->theObject.onInit;
                (if userdataVerbose then
                    'MakeSurroundBox: Created SurroundBox!'->putline
                if);
                theObject.getRegionIDs->regions;
                (if regions.range > 0 then
                    theObject.onInitRegion; regions->MakeObjectsFromList
                if)
            if)
        if)
     #)  

-- onReadDiagram: Descriptor --
(# 
do
(*  THIS(OADPage).PatternDiagrams.theList.scan
 (#
 theListDiagram: ^ListDiagram;
 thisOADDiagram: ^OADDiagram;
 thisFragmentDiagram: ^FragmentDiagram;
 theDummyDesc: ^betaGram.ObjectDescriptor;
 thisPatternAttDiagram: ^PatternAttDiagram;
 theDummyAST: ^MPS.AST
 do
 current.e[]->theListDiagram[];
 (if current.e## <= OADDiagram##
 // true then
 current.e[]->thisOADDiagram[];
 thisOADDiagram.titlenode.theText.get->thisOADDiagram.titleText;
 (if thisOADDiagram.theDescriptor <> none then
 thisOADDiagram.theDescriptor->theDummyDesc[];
 theDummyDesc.index->current.index;
 (if thisOADDiagram## <= PatternAttDiagram## then
 thisOADDiagram[]->thisPatternAttDiagram[];
 thisPatternAttDiagram.theAST->theDummyAST[];
 theDummyAST.index->current.index
 if)
 if);
 if);
 (if current.e## <= FragmentDiagram## then
 current.e[]->thisFragmentDiagram[];
 thisFragmentDiagram.titlenode.theText.get
 ->thisFragmentDiagram.titleText
 if)
 #) *) 
#)  

