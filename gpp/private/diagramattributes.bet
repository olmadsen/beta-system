ORIGIN '../gppinterface';
BODY 'gppinterfacebody'
     'diagrambody'
     'patterndiagrambody'
     'abstractnodebody'
     'fragmentnodebody'
     'marknodebody'
     'simplenodebody'
     'nonterminalnodebody';
INCLUDE '~beta/containers/v1.4/list'
        '../prettyprintersetup'
        '../propertydiagrams'
        'userdataprivate';
(* This fragment group defines patterns visible to all bodies,
 * but not visible in the interface
 *)
-- OADPageLib: Attributes --
scrollIntoView:
  (# theObject: ^designObject; 
  enter theObject[]
  do
     (if doScrollIntoView then
         theObject[]->currentObject (#  do true->autoPan #); 
     if);
     
  #);
GetPrefix:
  (#
     theDescriptor: ^betaGram.ObjectDescriptor;
     tempAst: ^ast;
     pref: ^betaGram.prefix;
     ad: ^betaGram.attributeDenotation;
     thisPrefix: ^betaGram.ObjectDescriptor;
     
  enter theDescriptor[]
  do
     theDescriptor.getPrefixOpt->tempAst[];
     (if tempAst.kind
      // kinds.interior then
         tempAst[]->pref[];
         pref.getAttributeDenotation->tempAst[];
         (if tempAst.kind
          // kinds.interior then
             tempAst[]->ad[]; ad.findDescriptor->thisPrefix[]; 
         if);
         
     if);
     
  exit thisPrefix[]
  #);
(* LIST HANDLING *)
DiagramList: ContainerList (* list of diagrams on a page *)
  (#
     element::<  (# index: @Integer; e: ^Diagram #);
     myFind: find
       (#
          i: @Integer;
          predicate::<  (#  do (i = current.index)->value #);
          
       enter i
       #);
     findPD:
       (# aPD: ^Element; aDiagram: ^Diagram; 
       enter myFind->aPD[]
       do (if aPD[] <> none // true then aPD.e[]->aDiagram[];  if); 
       exit aDiagram[]
       #);
     insertPD:
       (# aPD: ^Element; index: @Integer; e: ^Diagram; 
       enter (index,e[])
       do &Element[]->aPD[]; (index,e[])->(aPD.index,aPD.e[]); aPD[]->append; 
       #);
     deletePD: (#  enter myFind->at->delete #);
     deleteProp:
       (#
          findProp:
            (# p: ^Diagram; aPD: ^Element; 
            enter p[]
            do
               scanner: scan
                 (# 
                 do
                    (if current.e[]
                     // p[] then current[]->aPD[]; leave scanner
                    if);
                    
                 #);
               
            exit aPD[]
            #);
          
       enter findProp->at->delete
       #);
     GetSubPatternDiagrams:
       (#
          theDiagram,aPatternDiagram: ^PatternDeclDiagram;
          aList: ^DiagramList;
          
       enter theDiagram[]
       do
          &DiagramList[]->aLIst[];
          scan
            (# 
            do
               (if current.e.struc <= PatternDeclDiagram##
                // true then
                   current.e[]->aPatternDiagram[];
                   (if aPatternDiagram.thePrefix <> none
                    // true then
                       (if
                       aPatternDiagram.thePrefix
                         ->(theDiagram.theDescriptor).equal
                        // true then current[]->aList.append; 
                       if)
                   if)
               if)
            #);
          
       exit aList[]
       #);
     scanPatternDiagrams: scan
       (# thisDiagram: ^PatternDeclDiagram; 
       do
          (if current.e.struc <= PatternDeclDiagram##
           // true then current.e[]->thisDiagram[]; INNER ; 
          if)
       #);
     scanFragmentDiagrams: scan
       (# thisDiagram: ^fragmentDiagram; 
       do
          (if current.e## <= FragmentDiagram##
           // true then current.e[]->thisDiagram[]; INNER ; 
          if)
       #);
     scanPropertyDiagrams: scan
       (# thisDiagram: ^SimplePropertyDiagram; 
       do
          (if current.e.struc <= SimplePropertyDiagram##
           // true then current.e[]->thisDiagram[]; INNER ; 
          if)
       #);
     
  #);
  

-- DiagramLib: Attributes --
DisplayAst:
  (# anAST: ^AST; pos: @Point; 
  enter (anAST[],pos)
  do <<SLOT DisplayAST:Descriptor>>; 
  exit pos
  #);
scanAttributeDecls:
  (#
     theAtt: ^betaGram.Attributes;
     anAst: ^ast;
     ndl: ^betaGram.names;
     unExp: ^unExpanded;
     thisAttribute:<
       (# nd: ^betaGram.nameDcl
       enter nd[]
       do INNER
       #);
     thisUnExp:<
       (# unExp: ^unExpanded
       enter unExp[]
       do INNER
       #);
     thisOptional:<
       (# opt: ^Optional
       enter opt[]
       do INNER
       #);
     thisSlot:<
       (# theSlot: ^SlotDesc
       enter theSlot[]
       do INNER
       #);
     
  enter theAtt[]
  do
     (if switch[1]
      // true then
         'scanAttributeDecls'->screen.putline; 
     if);
     theAtt.scan
       (# att: ^betaGram.attributeDecl
       do
          (if switch[1]
           // true then '*'->screen.put
          if);
          (if current.kind
           // kinds.interior then
              current[]->att[];
              att.getSon1->anAst[];
              (if switch[1]
               // true then
                  'interior: '->screen.puttext;
                  anAst.symbol->screen.putint;
                  screen.newline;
                  
              if);
              (if anAst.symbol
               // betaGram.names then
                  anAst[]->ndl[];
                  ndl.scan
                    (# 
                    do current[]->thisAttribute
                    #)
              if)
           // kinds.unExpanded then
              (if switch[1]
               // true then
                  'unExpanded: '->screen.puttext; 
              if);
              current[]->unExp[];
              (if unExp.isSlot
               // true then
                  (if switch[1] // true then 'Slot'->screen.putline;  if);
                  unExp.theSlot->thisSlot;
                  
               else
                  (if switch[1] // true then screen.newline;  if);
                  unExp[]->thisUnExp;
                  
              if)
           // kinds.optional then
              (if switch[1] // true then 'optional'->screen.putline;  if);
              current[]->thisOptional;
              
          if)
       #);
     (if switch[1] // true then 'DONE'->screen.putline if);
     
  #);
CountAttributes:
  (#
     obj: ^betaGram.ObjectDescriptor;
     main: ^betaGram.MainPart;
     a: ^AST;
     i: @Integer;
     
  enter obj[]
  do
     (if switch[1] // true then 'CountAttributes '->screen.puttext if);
     (if obj[] <> none
      // true then
         obj.getMainPart->main[];
         main.getAttributes->a[];
         (if a[]
          // none then
             'Attribute error: cannot get attributes from descriptor: '
               ->puttext;
             
          else
             (if a.kind
              // kinds.interior then
                 (if switch[1] // true then 'scanning '->screen.puttext if);
                 a[]
                   ->scanAttributeDecls
                     (#
                        thisAttribute::<  (#  do i+1->i #);
                        thisOptional::<  (#  do i+1->i #);
                        thisUnExp::<  (#  do i+1->i #);
                        
                     #);
                 
             if)
         if)
     if);
     (if switch[1] // true then screen.newline if);
     
  exit i
  #);
CheckKeyWord:
  (#
     node: ^ast;
     keyword: ^text;
     found: @boolean;
     theCom: ^comment;
     theComText,nextWord: ^text;
     
  enter (node[],keyword[])
  do
     (if node.hasComment
      // true then
         node.getComment->theCom[];
         theCom.getText->theComText[];
         theComText.reset;
         search:
           (# 
           do
              theComText.getAtom->nextWord[];
              (if true
               // keyWord[]->nextWord.equal then true->found; 
               else
                  (if theComText.eos // false then restart search if); 
              if);
              
           #);
         
     if);
     
  exit found
  #);
isDescriptorDiagram:
  (#
     theOADDiagram: ^OADDiagram;
     desc: ^betaGram.ObjectDescriptor;
     anAST: ^AST;
     value: @Boolean
  enter theOADDiagram[]
  do
     theOADDiagram.theDescriptor->desc[];
     (if desc[] <> none then
         desc.father->anAST[]; (if anAST.father = none then true->value if)
     if)
  exit value
  #);
makeNonTerminalSymbol:
  (# symbolName: ^Text
  enter symbolName[]
  do '<<'->symbolName.prepend; '>>'->symbolName.append
  exit symbolName[]
  #);
makeRemote:
  (#
     anAST: ^AST;
     rem: ^betaGram.remote;
     unExp: ^unExpanded;
     na: ^betaGram.nameApl;
     t: ^text
  enter anAST[]
  do
     &Text[]->t[];
     anAST[]->rem[];
     rem.getAttributeDenotation->anAST[];
     (if anAST.kind = kinds.unExpanded then
         anAST[]->unExp[];
         unExp.NonTerminalSymbol->betaGram.symbolToName->makeNonTerminalSymbol
           ->t.append;
         '.'->t.append
      else
         (if anAST.symbol
          // betaGram.NameApl then
             anAST[]->na[];
             na.getNameAppl->anAST[];
             (if anAST.kind = kinds.unExpanded then
                 '<NameAppl>.'->t.append
              else
                 na.gettext->t.append; '.'->t.append
             if)
          // betaGram.Remote then
             anAST[]->makeRemote->t.append; '.'->t.append
         if)
     if);
     rem.getNameApl->na[];
     na.getNameAppl->anAST[];
     (if anAST.kind = kinds.unExpanded then
         '<NameAppl>'->t.append
      else
         na.gettext->t.append
     if)
  exit t[]
  #);
(****************** DIAGRAM NODES ************************)
AbstractNode: PatternDiagramNode
  (#
     theName: @ReferenceUserData (# Type::< Text #);
     currentDecomposDiagram: @DiagramReferenceUserData
       (# Type::< PatternDiagram #);
     decomposDiagrams: @containerlist (# element::< PatternDiagram #);
     PatternDiagReference: LocalNodesReferenceUserData
       (# Type::< PatternDiagram #);
     theTreeConn: ^TreeConnector;
     theDexterAnchor: ^AnchorMark;
     onSelect::< 
       (# 
       do
          (PatternDiagrams.oldSelection[],THIS(AbstractNode)[])->changedFocus;
          THIS(AbstractNode)[]->PatternDiagrams.oldSelection[];
          
       #);
     onRemove::< (* called when THIS(DiagramNode) is deleted *) 
       (#  do <<SLOT AbstractNodeRemove:Descriptor>>;  #);
     Display::< 
       (# t: @Text; pos: @Point; 
       enter pos
       do
          <<SLOT AbstractNodeDisplay:Descriptor>>;
          
       #);
     Redisplay::< 
       (# t: @Text;  do <<SLOT AbstractNodeRedisplay:Descriptor>>;  #);
     ConcludeDisplay::< 
       (# 
       do
          INNER ;
          <<SLOT AbstractNodeConcludeDisplay:Descriptor>>;
          
       #);
     MakeAnchor::< 
       (#  do INNER ; <<SLOT AbstractNodeMakeAnchor:Descriptor>> #);
     detail::< 
       (#
          theAST: ^AST
          (* the AST to be detailed *)
       do <<SLOT AbstractNodeDetail:Descriptor>>; 
       #);
     abstract::<
     (* if detailed then abstract the decompos diagram *) 
       (#  do <<SLOT AbstractNodeAbstract:Descriptor>>;  #);
     abstractedFromDiagramBelow::<
     (* when THIS(DiagramNode) has been abstrated from a diagram below *) 
       (# 
       do <<SLOT AbstractNodeAbstractedFromDiagramBelow:Descriptor>>; 
       #);
     hasAttributes:
       @BooleanUserData;
     CheckForAttributes:< (#  do INNER exit hasAttributes #);
     onInit::< 
       (# 
       do
          UDPrivate.UDAbstractNode->UserDataInit;
          theName.Init;
          currentDecomposDiagram.Init;
          hasAttributes.Init;
          (if initialisingSaved then gppProp.fontSize->theText.size if);
          INNER
       #);
     dump::<  (#  do <<SLOT AbstractNodeDump:Descriptor>>; INNER #)
  #);
(******************** For FragmentDiagrams *********************)
FragmentNode: AbstractNode
  (#
     theFragment: @FragReferenceUserData (# Type::< FragmentForm #);
     theForm: @ASTReferenceUserData (# Type::< betaGram.BetaForm #);
     sifEditorInstance: @Integer;
     display::< 
       (# 
       enter theFragment
       do <<SLOT FragmentNodeDisplay:Descriptor>>; 
       #);
     ConcludeDisplay::< 
       (#  do INNER #);
     onDoubleClick::< 
       (# 
       do
          false->IndicateSelection;
          detail
       #);
     detail::<  (#  do INNER ; <<SLOT FragmentNodeDetail:Descriptor>> #);
     GetGroup::< 
       (# fd: ^FragmentDiagram; 
       do
          theDiagram->fd[];
          fd.theGroup->fg[];
          
       #);
     GetFragment::< 
       (#  do theFragment->f[];  #);
     SifEditorInstanceNo::< 
       (# 
       do
          (if no
           // 0 then
              SifEditorInstance->no; 
           else
              no->SifEditorInstance; 
          if);
          
       #);
     CheckForAttributes::< 
       (#  do true->hasAttributes #);
     ReReadAST:<
       (#
          oldFF,newFF: ^fragmentForm;
          oldObject: ^AbstractNode;
          
       enter (oldFF[],oldObject[])
       do
          <<SLOT FragmentReReadAST:Descriptor>>;
          
       exit newFF[]
       #);
     onInit::< 
       (# 
       do
          UDPrivate.UDFragmentNode->UserDataInit;
          theForm.Init;
          theFragment.Init;
          INNER
       #);
     dump::<  (#  do <<SLOT FragmentNodeDump:Descriptor>>;  #);
     
  #);
AttributesNode: FragmentNode
  (#
     display::< 
       (# 
       do ': Attributes'->t.append; 
       #);
     detail::< 
       (# 
       do
          <<SLOT AttributesNodeDetail:Descriptor>>
       #);
     onInit::<  (#  do UDPrivate.UDAttributesNode->UserDataInit; INNER #);
     
  #);
DescriptorNode: FragmentNode
  (#
     display::<  (#  do ': Descriptor'->t.append;  #);
     detail::<  (#  do <<SLOT DescriptorNodeDetail:Descriptor>> #);
     onInit::< 
       (# 
       do
          UDPrivate.UDDescriptorNode
            ->UserDataInit;
          INNER
       #);
     
  #);
DiagramNode: AbstractNode
  (#
     theDeclaration:
       @ASTReferenceUserData (# Type::< betaGram.AttributeDecl #);
     theObjectDescriptor: @ASTReferenceUserData
       (# Type::< betaGram.ObjectDescriptor #);
     thePrefix: @ASTReferenceUserData
       (# Type::< betaGram.ObjectDescriptor #);
     CheckForAttributes::< 
       (# 
       do (theObjectDescriptor->CountAttributes) > 0->hasAttributes; 
       #);
     Display::< 
       (# anAST: ^AST; (* either theName or an unExp *) 
       enter (theDeclaration,anAST[])
       do <<SLOT DiagramNodeDisplay:Descriptor>>; 
       #);
     Redisplay::< 
       (#
          anAST: ^AST;
          (* either theName or an unExp *)
          
       enter (theDeclaration,anAST[])
       do <<SLOT DiagramNodeReDisplay:Descriptor>>
       #);
     ConcludeDisplay::< 
       (# 
       do
          <<SLOT DiagramNodeConcludeDisplay:Descriptor>>;
          INNER
       #);
     DesignText::< 
       (#
          oldWidth,oldHeight,newWidth,newHeight: @integer;
          ModeOn::< 
            (# help: ^text; ok: @Boolean
            do
               (if switch[1] then 'Text mode on DiagramNode'->putLine;  if);
               (if not ongoingTextediting then
                   (if currentDecomposDiagram <> none then
                       'The diagrams detailed from this node will be abstracted after text editing. Do you wish to continue?'
                         ->DSUIGetUserYesOrNo->ok
                    else
                       true->ok
                   if);
                   (if ok then
                       true->wrap;
                       theText.get->theTextBefore;
                       true->ongoingTextediting;
                       (if theObjectDescriptor <> none then
                           (if switch[1] then
                               'theName: '->putText; theName->putLine; 
                           if);
                           theName->help[];
                           help->parseableText;
                           ':'->parseableText.put;
                           INNER ;
                           '<<@'->parseableText.putText;
                           (theObjectDescriptor).index->parseableText.putInt;
                           ':ObjectDescriptor>>'->parseableText.putText;
                           parseableText->set;
                           
                       if)
                    else
                       false->OKToEnter; ModeOff
                   if)
               if);
               
            #);
          ModeOff::< 
            (# t: @Text; noChange: @boolean
            do
               (if switch[1] then 'Text mode off DiagramNode'->putLine;  if);
               (if ongoingTextediting then
                   theText.get->t;
                   (if theObjectDescriptor <> none then
                       parseableText[]->t.equal->noChange
                    else
                       theTextBefore[]->t.equal->noChange
                   if);
                   (if not noChange then
                       (if theDeclaration
                        // none then 'theDeclaration is none!! '->putLine
                        else
                           (THIS(DiagramNode)[],(theDeclaration).index,t[])
                             ->declarationTextChanged
                       if)
                    else
                       theTextBefore->theText.set; false->ongoingTextediting
                   if);
                   INNER
               if);
               false->wrap;
               
            #);
          
       #);
     EqualDescriptor:<
       (# aDesc: ^betaGram.ObjectDescriptor; b: @Boolean; 
       enter aDesc[]
       do INNER
       exit b
       #);
     detail::<  (#  do <<SLOT DiagramNodeDetail:Descriptor>> #);
     getASTNode::<
     (* return the AST node THIS(title) is generated from *) 
       (#  do theDeclaration->anAST[]; INNER #);
     GetGroup::<  (#  do <<SLOT DiagramNodeGetGroup:Descriptor>> #);
     GetFragment::< 
       (# 
       do
          <<SLOT DiagramNodeGetFragment:Descriptor>>
       #);
     SifEditorInstanceNo::< 
       (#  do <<SLOT SifEditorInstanceNo:Descriptor>> #);
     onInit::< 
       (# 
       do
          theDeclaration.Init;
          theObjectDescriptor.Init;
          thePrefix.init;
          INNER
       #);
     dump::< 
       (# 
       do
          <<SLOT DiagramNodeDump:Descriptor>>;
          INNER
       #);
     
  #);
SimpleAttributeDecl: DiagramNode (* SimpleDecl or RepetitionDecl *)
  (#
     declTypeNode: @ReferenceUserData (# Type::< PatternDiagramNode #);
     theReferenceSpec: @ASTReferenceUserData
       (# Type::< betaGram.referenceSpecification #);
     theUnExpRefSpec: @ASTReferenceUserData (# Type::< unExpanded #);
     theQualification: @ASTReferenceUserData
       (# Type::< betaGram.AttributeDecl #);
     Display::< 
       (# theObjectSpec: ^AST
       do
          INNER ;
          (* make theObjectSpec and theReferenceSpec *)
          <<SLOT SimpleAttrDeclDisplay:Descriptor>>;
          
       #);
     Redisplay::< 
       (# theObjectSpec: ^AST
       do
          INNER ;
          (* make theObjectSpec and theReferenceSpec *)
          <<SLOT SimpleAttrDeclReDisplay:Descriptor>>;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# help: ^text
            do
               (if switch[1] then
                   'Text mode on in SimpleAttributeDeclNode'->putLine; 
               if);
               ' @'->parseableText.putText;
               INNER
            #);
          ModeOff::< 
            (# t: @Text
            do
               (if switch[1] then
                   'Text mode off in SimpleAttributeDeclNode '->putLine; 
               if);
               INNER ;
               
            #);
          
       #);
     DisplayReference:< (#  do INNER #);
     onInit::< 
       (# 
       do
          UDPrivate.UDSimpleAttributeDecl->UserDataInit;
          declTypeNode.Init;
          theReferenceSpec.Init;
          theUnExpRefSpec.Init;
          theQualification.init;
          INNER
       #);
     dump::< 
       (#  do <<SLOT SimpleAttributeDecldump:Descriptor>>; INNER #);
     
  #);
SimpleNode: SimpleAttributeDecl
  (#
     theReferenceConnector:
       @ReferenceUserData (# Type::< Connector #);
     onDoubleClick::<  (#  do <<SLOT SimpleNodeDoubleClick:Descriptor>> #);
     Display::<  (#  do <<SLOT SimpleNodeDisplay:Descriptor>> #);
     Redisplay::< 
       (# 
       do
          <<SLOT SimpleNodeRedisplay:Descriptor>>
       #);
     DisplayReference::< 
       (#  do <<SLOT SimpleNodeDisplayReference:Descriptor>>;  #);
     onInit::< 
       (# 
       do
          UDPrivate.UDSimpleNode
            ->UserDataInit;
          theReferenceConnector.
            init;
          INNER
       #);
     dump::<  (#  do <<SLOT SimpleNodeDump:Descriptor>>; INNER #);
     
  #);
RepetitionNode: SimpleAttributeDecl
  (#
     onDoubleClick::< 
       (# 
       do
          <<SLOT RepetitionNodeDoubleClick:Descriptor>>
       #);
     Display::<  (#  do <<SLOT RepetitionNodeDisplay:Descriptor>> #);
     Redisplay::<  (#  do <<SLOT RepetitionNodeRedisplay:Descriptor>> #);
     onInit::< 
       (# 
       do
          UDPrivate.UDRepetitionNode
            ->UserDataInit;
          INNER
       #);
     
  #);
PatternNode: DiagramNode
  (#
     Display::< 
       (#
          pd: ^betaGram.PatternDecl;
          anAST: ^AST;
          
       do
          (if (theDeclaration).struc
          <= betaGram.PatternDecl##
           // true then
              theDeclaration->pd[];
              pd.getObjectDescriptor->anAST[];
              (if anAST.kind
               // kinds.interior then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      '  ...'->t.puttext; 
                  if);
                  
              if);
              pd->SetRegionType;
              
          if);
          DisplayReferences;
          INNER ;
          
       #);
     Redisplay::< 
       (# pd: ^betaGram.PatternDecl; anAST: ^AST; 
       do
          (if switch[1] then
              (if theDeclaration <> none then
                  '*** patternNode'->putLine;
                  'theDeclaration: '->putText;
                  (theDeclaration).index->putInt;
                  newLine;
                  
              if);
              (if theObjectDescriptor <> none then
                  'theObjectDescriptor: '->putText;
                  (theObjectDescriptor).index->putInt;
                  newLine;
                  
              if);
              
          if);
          (if (theDeclaration).struc <= betaGram.PatternDecl##
           // true then
              theDeclaration->pd[];
              pd.getObjectDescriptor->anAST[];
              (if anAST.kind
               // kinds.interior then
                  anAST[]->theObjectDescriptor;
                  (if currentDecomposDiagram <> none then
                      anAST[]->(currentDecomposDiagram).theDescriptor
                  if);
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      '  ...'->t.puttext; 
                  if);
                  
              if);
              pd->SetRegionType;
              
          if);
          (if switch[1] then
              (if theDeclaration <> none then
                  'theDeclaration: '->putText;
                  (theDeclaration).index->putInt;
                  newLine;
                  
              if);
              (if theObjectDescriptor <> none then
                  'theObjectDescriptor: '->putText;
                  (theObjectDescriptor).index->putInt;
                  newLine;
                  
              if);
              
          if);
          INNER ;
          
       #);
     onDoubleClick::< 
       (# 
       do
          false->indicateSelection;
          (if switch[1]
           // true then
              'doubleClick PatternDeclaration ID: '->puttext;
              ID->putint;
              newline;
              
          if);
          (if hasAttributes
           // true then detail; 
           else
              (if switch[1] // true then 'no attributes'->putline if)
          if);
          INNER ;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[1] then
                   'Text mode on in PatternNode'->putLine; 
               if);
               ' '->parseableText.put;
               INNER
            #);
          ModeOff::< 
            (# 
            do
               (if switch[1] then
                   'Text mode off in PatternNode '->putLine; 
               if);
               INNER ;
               
            #);
          
       #);
     EqualDescriptor::< 
       (# 
       do
          (if theObjectDescriptor <> none
           // true then aDesc[]->(theObjectDescriptor).equal->b; 
          if);
          INNER ;
          
       #);
     detail::<  (#  do <<SLOT PatternNodeDetail:Descriptor>>;  #);
     DisplayReferences:
       (# 
       do
          <<SLOT PatternNodeDisplayReferences:Descriptor>>;
          
       #);
     onInit::<  (#  do UDPrivate.UDPatternNode->UserDataInit; INNER #);
     
  #);
VirtualNode: PatternNode
  (#
     onDoubleClick::<  (#  do INNER ;  #);
     Display::< 
       (#
          vd: ^betaGram.VirtualDecl;
          anAST,a: ^AST;
          theUnExpObjSpec: ^unExpanded;
          aName: ^betaGram.NameApl;
          theAppl: ^NameAppl
       do
          (if (theDeclaration).struc <= betaGram.VirtualDecl##
           // true then
              theDeclaration->vd[];
              vd->SetRegionType;
              (if gppProp.SimpleDeclDisplay = gppProp.AsBetaSyntax then
                  ':< '->t.append
               else
                  (if (vd[],'(#Class#)')->checkKeyword
                   // true then ':  Virtual Class'->t.append; 
                   else
                      ':  Virtual'->t.append; 
                  if)
              if);
              vd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      '  ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // kinds.unExpanded then ' <<NameAppl>>'->t.append; 
                   else
                  (* is a real name *)
                      a[]->theAppl[]; theAppl.getText->t.append; 
                  if)
               // betaGram.Remote then
                  anAST[]->MakeRemote->t.append
               else
                  (if anAST.kind = kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                        ->makeNonTerminalSymbol->t.append
                  if)
              if);
              
          if);
          betaGram.VirtualDecl->SetRegionType;
          INNER ;
          
       #);
     Redisplay::< 
       (#
          vd: ^betaGram.VirtualDecl;
          anAST,a: ^AST;
          theUnExpObjSpec: ^unExpanded;
          aName: ^betaGram.NameApl;
          theAppl: ^NameAppl
       do
          (if (theDeclaration).struc <= betaGram.VirtualDecl##
           // true then
              theDeclaration->vd[];
              vd->SetRegionType;
              (if gppProp.SimpleDeclDisplay = gppProp.AsBetaSyntax then
                  ':< '->t.append
               else
                  (if (vd[],'(#Class#)')->checkKeyword
                   // true then ':  Virtual Class'->t.append; 
                   else
                      ':  Virtual'->t.append; 
                  if)
              if);
              vd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if currentDecomposDiagram <> none then
                      anAST[]->(currentDecomposDiagram).theDescriptor
                  if);
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      '  ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // kinds.unExpanded then ' <<NameAppl>>'->t.append; 
                   else
                  (* is a real name *)
                      a[]->theAppl[]; theAppl.getText->t.append; 
                  if)
               // betaGram.Remote then
                  anAST[]->MakeRemote->t.append
               else
                  (if anAST.kind = kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                        ->makeNonTerminalSymbol->t.append
                  if)
              if);
              
          if);
          betaGram.VirtualDecl->SetRegionType;
          INNER ;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[1] then
                   'Text mode on in VirtualNode'->putLine; 
               if);
               '< '->parseableText.putText;
               INNER
            #);
          ModeOff::< 
            (# t: @Text
            do
               (if switch[1] then
                   'Text mode off in VirtualNode '->putLine; 
               if);
               INNER ;
               
            #);
          
       #);
     onInit::<  (#  do UDPrivate.UDVirtualNode->UserDataInit; INNER #);
     
  #);
BindingNode: PatternNode
  (#
     onDoubleClick::<  (#  do INNER ;  #);
     Display::< 
       (#
          bd: ^betaGram.BindingDecl;
          anAST,a: ^AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^unExpanded;
          theAppl: ^NameAppl
       do
          (if (theDeclaration).struc <= betaGram.BindingDecl##
           // true then
              theDeclaration->bd[];
              bd->SetRegionType;
              (if gppProp.SimpleDeclDisplay = gppProp.AsBetaSyntax then
                  '::< '->t.append
               else
                  (if (bd[],'(#Class#)')->checkKeyword
                   // true then ':  Bind Class'->t.append; 
                   else
                      ':  Bind'->t.append; 
                  if)
              if);
              bd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      '  ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // kinds.unExpanded then ' <<NameAppl>>'->t.append; 
                   else
                  (* is a real name *)
                      a[]->theAppl[]; theAppl.getText->t.append; 
                  if)
               // betaGram.Remote then
                  anAST[]->MakeRemote->t.append
               else
                  (if anAST.kind = kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                        ->makeNonTerminalSymbol->t.append
                  if)
              if);
              
          if);
          betaGram.BindingDecl->SetRegionType;
          INNER ;
          
       #);
     Redisplay::< 
       (#
          bd: ^betaGram.BindingDecl;
          anAST,a: ^AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^unExpanded;
          theAppl: ^NameAppl
       do
          (if (theDeclaration).struc <= betaGram.BindingDecl##
           // true then
              theDeclaration->bd[];
              bd->SetRegionType;
              (if gppProp.SimpleDeclDisplay = gppProp.AsBetaSyntax then
                  '::< '->t.append
               else
                  (if (bd[],'(#Class#)')->checkKeyword
                   // true then ':  Bind Class'->t.append; 
                   else
                      ':  Bind'->t.append; 
                  if)
              if);
              bd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if currentDecomposDiagram <> none then
                      anAST[]->(currentDecomposDiagram).theDescriptor
                  if);
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      '  ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // kinds.unExpanded then ' <<NameAppl>>'->t.append; 
                   else
                  (* is a real name *)
                      a[]->theAppl[]; theAppl.getText->t.append; 
                  if)
               // betaGram.Remote then
                  anAST[]->MakeRemote->t.append
               else
                  (if anAST.kind = kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                        ->makeNonTerminalSymbol->t.append
                  if)
              if);
              
          if);
          betaGram.BindingDecl->SetRegionType;
          INNER ;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[1] then
                   'Text mode on in BindingNode'->putLine; 
               if);
               ':< '->parseableText.putText;
               INNER
            #);
          ModeOff::< 
            (# t: @Text
            do
               (if switch[1] then
                   'Text mode off in BindingNode '->putLine; 
               if);
               INNER ;
               
            #);
          
       #);
     onInit::<  (#  do UDPrivate.UDBindingNode->UserDataInit; INNER #);
     
  #);
FinalNode: PatternNode
  (#
     onDoubleClick::<  (#  do INNER ;  #);
     Display::< 
       (#
          fd: ^betaGram.FinalDecl;
          anAST,a: ^AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^unExpanded;
          theAppl: ^NameAppl
       do
          (if (theDeclaration).struc <= betaGram.FinalDecl##
           // true then
              theDeclaration->fd[];
              fd->SetRegionType;
              (if gppProp.SimpleDeclDisplay = gppProp.AsBetaSyntax then
                  ':: '->t.append
               else
                  (if (fd[],'(#Class#)')->checkKeyword
                   // true then ':  Final Bind Class'->t.append; 
                   else
                      ': Final Bind'->t.append; 
                  if)
              if);
              fd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      '  ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // kinds.unExpanded then ' <<NameAppl>>'->t.append; 
                   else
                  (* is a real name *)
                      a[]->theAppl[]; theAppl.getText->t.append; 
                  if)
               // betaGram.Remote then
                  anAST[]->MakeRemote->t.append
               else
                  (if anAST.kind = kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                        ->makeNonTerminalSymbol->t.append
                  if)
              if);
              
          if);
          betaGram.FinalDecl->SetRegionType;
          INNER ;
          
       #);
     Redisplay::< 
       (#
          fd: ^betaGram.FinalDecl;
          anAST,a: ^AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^unExpanded;
          theAppl: ^NameAppl
       do
          (if (theDeclaration).struc <= betaGram.FinalDecl##
           // true then
              theDeclaration->fd[];
              fd->SetRegionType;
              (if gppProp.SimpleDeclDisplay = gppProp.AsBetaSyntax then
                  ':: '->t.append
               else
                  (if (fd[],'(#Class#)')->checkKeyword
                   // true then ':  Bind Class'->t.append; 
                   else
                      ':  Bind'->t.append; 
                  if)
              if);
              fd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if currentDecomposDiagram <> none then
                      anAST[]->(currentDecomposDiagram).theDescriptor
                  if);
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      '  ...'->t.puttext; 
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // kinds.unExpanded then ' <<NameAppl>>'->t.append; 
                   else
                  (* is a real name *)
                      a[]->theAppl[]; theAppl.getText->t.append; 
                  if)
               // betaGram.Remote then
                  anAST[]->MakeRemote->t.append
               else
                  (if anAST.kind = kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                        ->makeNonTerminalSymbol->t.append
                  if)
              if);
              
          if);
          betaGram.FinalDecl->SetRegionType;
          INNER ;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[1] then 'Text mode on in FinalNode'->putLine;  if);
               ': '->parseableText.putText;
               INNER
            #);
          ModeOff::< 
            (# t: @Text
            do
               (if switch[1] then
                   'Text mode off in FinalNode '->putLine; 
               if);
               INNER ;
               
            #);
          
       #);
     onInit::<  (#  do UDPrivate.UDFinalNode->UserDataInit; INNER #);
     
  #);
NonTerminalNode: AbstractNode
  (#
     unExp: @ASTReferenceUserData (# Type::< unexpanded #);
     synCatName: @ReferenceUserData (# Type::< Text #);
     synCatNo: @IntegerUserData;
     onInit::<  (#  do <<SLOT NonTerminalNodeInit:Descriptor>> #);
     display::< 
       (# 
       enter unexp
       do
          <<SLOT NonTerminalNodeDisplay:Descriptor>>
       #);
     DesignText::< 
       (#
          oldWidth,oldHeight,newWidth,newHeight: @integer;
          ModeOn::< 
            (# 
            do
               (if switch[1] then
                   'Text mode on NonTerminalNode'->putLine; 
               if);
               (if not ongoingTextediting then
                   true->wrap;
                   theText.get->theTextBefore;
                   true->ongoingTextediting
               if);
               (* 'Textediting of nonterminal nodes is currently disabled'->gppAlert;
                false->OKtoEnter;*)
               (* THIS(nonterminalNode).size->(oldWidth,oldHeight);
                (oldWidth,oldHeight)->THIS(nonterminalNode).size;
                THIS(nonterminalNode).size->(newWidth,newHeight);*)
               INNER
            #);
          ModeOff::< 
            (# t: @Text
            do
               (if switch[1] then
                   'Text mode off NonterminalNode'->putLine; 
               if);
               (if ongoingTextediting then
                   theText.get->t;
                   (if unExp
                    // none then 'unExp is none!! '->putLine
                    else
                       (if not (theTextBefore[]->t.equal) then
                           (THIS(NonTerminalNode)[],(unExp).index,t[])
                             ->declarationTextChanged
                       if)
                   if);
                   (* (oldWidth,oldHeight)->THIS(nonterminalNode).size;*)
                   INNER
               if);
               false->wrap;
               
            #);
          
       #);
     onDoubleClick::<  (#  do <<SLOT NonTerminalDoubleClick:Descriptor>> #);
     detail::<  (#  do 'Detail the nonterminal'->putline #);
     abstract::<  (#  do 'Abstract the nonterminal'->putline #);
     GetGroup::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none
           // true then
                (#
                   fd: ^FragmentDiagram; theDummyFragNode: ^PatternDiagramNode
                do
                   (theDiagram).theFragmentNode->theDummyFragNode[];
                   theDummyFragNode.theDiagram->fd[];
                   fd.theGroup->fg[];
                   
                #);
              
           else
              'DiagramNode: GetGroup: no FragmentNode'->screen.putline
          if);
          
       #);
     GetFragment::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none
           // true then
                (# fn: ^FragmentNode; 
                do (theDiagram).theFragmentNode->fn[]; fn.theFragment->f[]; 
                #);
              
           else
              'DiagramNode: GetFragment: no FragmentNode'->screen.putline
          if);
          
       #);
     SifEditorInstanceNo::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none
           // true then
              (if no
               // 0 then
                    (# fn: ^FragmentNode; 
                    do
                       (theDiagram).theFragmentNode->fn[];
                       fn.SifEditorInstance->no;
                       
                    #);
                  
               else
                    (# fn: ^FragmentNode; 
                    do
                       (theDiagram).theFragmentNode->fn[];
                       no->fn.SifEditorInstance;
                       
                    #);
                  
              if);
              
           else
              'DiagramNode: SifEditorInstanceNo: no FragmentNode'
                ->screen.putline
          if);
          
       #);
     dump::<  (#  do <<SLOT NonTerminalNodeDump:Descriptor>>; INNER #);
     
  #);
SlotNode: PatternDiagramNode
  (#
     display::< 
       (#
          aSlotDesc: ^SlotDesc;
          pos: @Point;
          
       enter (pos,aSlotDesc[])
       do
          <<SLOT SlotNodeDisplay:Descriptor>>;
          
       #);
     onDoubleClick::<  (#  do INNER ;  #);
     abstract::<  (#  do INNER ;  #);
     detail::<  (#  do INNER ;  #);
     onInit::<  (#  do UDPrivate.UDSlotNode->UserDataInit; INNER #);
     
  #);
(* Mark nodes: for comments and Dexter anchors *)
(* Mark nodes: for comments and Dexter anchors *)
MyCommentNode: CommentNode (* to display the comment *)
  (#
     theMarkNode: @ReferenceUserData (# Type::< CommentMark #);
     onInit::<  (#  do <<SLOT MyCommentNodeOnInit:Descriptor>> #);
     onRemove::< 
       (# 
       do
          <<SLOT CommentNodeOnRemove:Descriptor>>
       #);
     deactivate::<  (#  do <<SLOT CommentNodeDeactivate:Descriptor>> #);
     
  #);
CommentMark: MarkNode
  (#
     open: @BooleanUserData;
     theComment: @ASTReferenceUserData
       (# Type::< LexemText #);
     theCommentNode:
       @ReferenceUserData (# Type::< MyCommentNode #);
     theConn: @ReferenceUserData (# Type::< Connector #);
     display::< 
       (# theCom: ^LexemText
       enter theComment
       do <<SLOT CommentNodeDisplay:Descriptor>>; 
       #);
     activate::< 
       (# 
       do
          <<SLOT CommentMarkActivate:Descriptor>>
       #);
     deactivate::<  (#  do <<SLOT CommentMarkDeactivate:Descriptor>> #);
     onInit::< 
       (# 
       do
          <<SLOT CommentMarkOnInit:Descriptor>>
       #);
     onRemove::<  (#  do <<SLOT CommentMarkOnRemove:Descriptor>> #);
     onDoubleClick::< 
       (# 
       do
          <<SLOT CommentMarkDoubleClick:Descriptor>>
       #);
     onSelect::<  (#  do <<SLOT CommentMarkSelect:Descriptor>> #);
     
  #);
AnchorMark: MarkNode
  (#
     display::< 
       (# 
       do
          <<SLOT AnchorMarkDisplay:Descriptor>>
       #);
     onInit::<  (#  do <<SLOT AnchorMarkOnInit:Descriptor>> #);
     onDoubleClick::< 
       (# 
       do
          <<SLOT AnchorMarkDoubleClick:Descriptor>>
       #);
     activate::<  (#  do <<SLOT AnchorMarkActivate:Descriptor>> #);
     deactivate::< 
       (# 
       do
          <<SLOT AnchorMarkDeactivate:Descriptor>>
       #);
     
  #);
(* CONNECTORS *)
CommonConnector: DeletableConnector
  (#
     treeNew: (* a try *)
       (# node1,node2: ^Node; 
       enter (node1[],node2[])
       do <<SLOT treeNew:Descriptor>>; 
       #);
     onInit::< 
       (# 
       do 0->Orient; (* no heads *) INNER
       #)
  #);
PrefixConnector: CommonConnector
(* a straight connector without arrowheads *)
  (#
     pnode1,pnode2: @ReferenceUserData (# Type::< Node #);
     getEnds::<  (#  do pnode1->node1[]; pnode2->node2[] #);
     prefixNew: (* a try *)
       (#  enter (pnode1,pnode2) do <<SLOT prefixNew:Descriptor>>;  #);
     onInit::< 
       (# 
       do
          UDPrivate.UDPrefixConnector
            ->UserDataInit;
          pnode1.init;
          pnode2.init;
          INNER
       #);
     onDelete::< 
       (# t: ^text
       do
          <<SLOT PrefixConnectorOnDelete:Descriptor>>;
          INNER
       #);
     onReattach::< 
       (#  do <<SLOT PrefixConnectorOnReattach:Descriptor>>;  #);
     
  #);
TreeConnector: PrefixConnector
(* a straight connector without arrowheads *)
  (# onInit::<  (#  do UDPrivate.UDTreeConnector->UserDataInit; INNER #)
  #);
ReferenceConnector: CommonConnector
  (#
     onInit::< 
       (# p: [8] @Integer; n1,n2: ^Node; x,y,w,h: @Integer; 
       do
          true->GetEnds->(n1[],n2[]);
          n1.geometry->(x,y,w,h);
          (x-(gppProp.width+1) div 2)-gppProp.RefConnectorLeftFromNode-
          (NoOfRefConnectors*gppProp.RefConnectorOffset)->p[3];
          y->p[4];
          n2.geometry->(x,y,w,h);
          (x-(gppProp.width+1) div 2)-gppProp.RefConnectorLeftFromNode-
          (NoOfRefConnectors*gppProp.RefConnectorOffset)->p[5];
          y->p[6];
          p->Points;
          NoOfRefConnectors+1->NoOfRefConnectors;
          
       #);
     
  #);
  

-- PatternDiagrams: Descriptor --
(#
   oldSelection: ^PatternDiagramNode;
   theList: @DiagramList;
   NextFreeLine: @Integer;
   (* indicates where the next PatternDiagram can
    be placed to avoid obscuring another diagrams *)
   NextFreeColumn: @Integer;
   SecondFreeLine: @Integer;
   (* Indicates where to put the next diagram when
    * we ran into the bottom of the page *)
   SecondFreeColumn: @Integer;
   Detailer: ^PatternDiagramNode;
   (* if not NONE then we are currently
    * creating a subdiagram by detailing
    * another node
    *)
   addAfterNode: ^PatternDiagramNode;
   newNode: ^PatternDiagramNode;
   (* add newnode to list after addAfterNode when done *)
   
#)  

-- OADPageMakeDesignObject: Descriptor --
(# theDiag: ^Diagram; NodeType: @Integer
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDFragmentDiagram then
       &FragmentDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created FragmentDiagram!'->putline
       if)
    // UDPrivate.UDPatternAttDiagram then
       &PatternAttDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternAttDiagram!'->putline
       if)
    // UDPrivate.UDPatternDeclDiagram then
       &PatternDeclDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternDeclDiagram!'->putline
       if)
    // UDPrivate.UDPatternClassificationDiagram then
       &PatternClassificationDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternClassificationDiagram!'->putline
       if)
    // UDPrivate.UDPatternNonTerminalDiagram then
       &PatternNonTerminalDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternNonTerminalDiagram!'->putline
       if)
    // UDPrivate.UDSimplePropertyDiagram then
       &SimplePropertyDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created SimplePropertyDiagram!'->putline
       if)
    // UDPrivate.UDPropertyDiagram then
       &PropertyDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PropertyDiagram!'->putline
       if)
   if)
#)  

-- MakeLocalNodes: Descriptor --
(#
   rangeStart: @integer;
   rangeEnd: @integer;
   rangeH: ^integerRef;
   count: ^shortRef;
   ok: @boolean;
   localNodeID: @integer;
   NodeType: @integer;
   thePatternDiagNode: ^PatternDiagramNode;
   theSimpleNode: ^theListDiagram.SimpleNode;
   theObject: ^DesignObject;
   theNode: ^Node;
   thePropertyDiagram: ^SimplePropertyDiagram;
   regions: [0] @Integer;
   count2: @ShortRef;
   list: @IntegerRef;
   titleID,theNodeID,theConnID: @integer
do
   LocalNodesUserDataStart->rangeStart;
   LocalNodesUserDataEnd->rangeEnd;
   theListDiagram.titleNode.ID->titleID;
   &integerRef[]->rangeH[];
   &shortRef[]->count[];
   (titleID,rangeStart,rangeEnd,count[],rangeH[])->UDFindRange->ok;
   (if userDataVerbose then
       'MakeLocalNodes - count: '->puttext; count->putint; newline; 
   if);
   (if ok then
       &theListDiagram.LocalNodesDesc[]->theListDiagram.localNodes[];
       (for i: count repeat
         (if userDataVerbose then
             'For titleID: '->puttext;
             titleID->putint;
             ' and attributesID: '->puttext;
             LocalNodesUserDataStart+i->putint;
             ' localNodeID was: '->puttext;
             
         if);
         (titleID,LocalNodesUserDataStart+i,@@ localNodeID)->UDReadType->ok;
         (if ok then
             (if userDataVerbose then localNodeID->putint; newline;  if);
             localNodeID->getNodeType->NodeType;
             (if NodeType = UDPrivate.UDPatternDiagramNode then
                 &PatternDiagramNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created PatternDiagramNode!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDAbstractNode then
                 &theListDiagram.AbstractNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created AbstractNode!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDSlotNode then
                 &theListDiagram.SlotNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created SlotNode!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDPropertyNode then
                 theListDiagram[]->thePropertyDiagram[];
                 &thePropertyDiagram.PropertyNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeDesignObject: Created PropertyNode!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDFragmentNode then
                 &theListDiagram.FragmentNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created FragmentNode!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDDiagramNode then
                 &theListDiagram.DiagramNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created DiagramNode!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDNonTerminalNode then
                 &theListDiagram.NonTerminalNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created NonTerminalNode!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDAttributesNode then
                 &theListDiagram.AttributesNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created AttributesNode!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDDescriptorNode then
                 &theListDiagram.DescriptorNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created DescriptorNode!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDSimpleAttributeDecl then
                 &theListDiagram.SimpleAttributeDecl[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created SimpleAttributeDecl!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDPatternNode then
                 &theListDiagram.PatternNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created PatternNode!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDSimpleNode then
                 &theListDiagram.SimpleNode[]->thePatternDiagNode[]
                   ->theSimpleNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created SimpleNode!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDRepetitionNode then
                 &theListDiagram.RepetitionNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created RepetitionNode!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDVirtualNode then
                 &theListDiagram.VirtualNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created VirtualNode!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDBindingNode then
                 &theListDiagram.BindingNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: BindingNode!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDFinalNode then
                 &theListDiagram.FinalNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: FinalNode!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDActivePropertyNode then
                 (if theListDiagram## <= SimplePropertyDiagram## then
                     theListDiagram[]->thePropertyDiagram[];
                     &thePropertyDiagram.ActivePropertyNode[]
                       ->thePatternDiagNode[]->theObject[];
                     true->thePatternDiagNode.initialisingSaved;
                     (if userDataVerbose then
                         'MakeDesignObject: Created ActivePropertyNode!'
                           ->putline
                     if)
                 if)
             if);
             (if NodeType = UDPrivate.UDPassivePropertyNode then
                 (if theListDiagram## <= SimplePropertyDiagram## then
                     theListDiagram[]->thePropertyDiagram[];
                     &thePropertyDiagram.PassivePropertyNode[]
                       ->thePatternDiagNode[]->theObject[];
                     true->thePatternDiagNode.initialisingSaved;
                     (if userDataVerbose then
                         'MakeDesignObject: Created PassivePropertyNode!'
                           ->putline
                     if)
                 if)
             if);
             (if NodeType = UDPrivate.UDOriginPropertyNode then
                 (if theListDiagram## <= SimplePropertyDiagram## then
                     theListDiagram[]->thePropertyDiagram[];
                     &thePropertyDiagram.OriginPropertyNode[]
                       ->thePatternDiagNode[]->theObject[];
                     true->thePatternDiagNode.initialisingSaved;
                     (if userDataVerbose then
                         'MakeDesignObject: Created OriginPropertyNode!'
                           ->putline
                     if)
                 if)
             if);
             (if NodeType = UDPrivate.UDIncludePropertyNode then
                 (if theListDiagram## <= SimplePropertyDiagram## then
                     theListDiagram[]->thePropertyDiagram[];
                     &thePropertyDiagram.IncludePropertyNode[]
                       ->thePatternDiagNode[]->theObject[];
                     true->thePatternDiagNode.initialisingSaved;
                     (if userDataVerbose then
                         'MakeDesignObject: Created IncludePropertyNode!'
                           ->putline
                     if)
                 if)
             if);
             (if NodeType = UDPrivate.UDBodyPropertyNode then
                 (if theListDiagram## <= SimplePropertyDiagram## then
                     theListDiagram[]->thePropertyDiagram[];
                     &thePropertyDiagram.BodyPropertyNode[]
                       ->thePatternDiagNode[]->theObject[];
                     true->thePatternDiagNode.initialisingSaved;
                     (if userDataVerbose then
                         'MakeDesignObject: Created BodyPropertyNode!'->putline
                     if)
                 if)
             if);
             (if theObject[] <> none then
                 theObject[]->theListDiagram.LocalNodes.append;
                 localNodeID->theObject.onInit;
                 (if localNodeID->DSRdAttrGetObjectType
                  // RegionType then theObject.onInitRegion; 
                 if);
                 (if (localNodeID,count2[],list[])->DSStrGetObjectRegionList
                  // true then
                     (if count2 > 0
                      // true then
                         (count2,list)->GetIntList->regions;
                         (if verbose
                          // true then
                             'NoOfRegions: '->puttext;
                             regions.range->putint;
                             newline;
                             
                         if);
                         regions->MakeObjectsFromList;
                         
                     if)
                 if);
                 (if theObject## <= node## then
                     theObject[]->theNode[]; false->theNode.moveable
                 if);
                 (if thePatternDiagNode[] <> none then
                     thePatternDiagNode.theMarkNode.getID
                       ->theNodeID
                       (*theMarkNode currently refers to EllipseNode.
                        getID works around qua error.*) ;
                     (if theNodeID <> 0 then
                         (theListDiagram[],theNodeID)->MakeMarkNode
                     if)
                 if);
                 (if theSimpleNode[] <> none then
                     theSimpleNode.theReferenceConnector.getID->theConnID;
                     (if theConnID <> 0 then
                         (theListDiagram[],theConnID)->MakeConn
                     if)
                 if)
             if)
          else
             
         if)
       for)
    else
       (if userDataVerbose then
           'ID: '->puttext;
           theListDiagram.titleNode.ID->putint;
           ' User data FindRange fail'->putline
       if)
   if);
   
#)  

-- MakeMarkNode: Descriptor --
(#
   NodeType,theNodeId,theConnID: @integer;
   theObject: ^DesignObject;
   theCommentMark: ^theListDiagram.CommentMark;
   regions: [0] @Integer;
   count2: @ShortRef;
   list: @IntegerRef
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDCommentMark then
       &theListDiagram.CommentMark[]->theCommentMark[]->theObject[];
       true->theCommentMark.initialisingSaved;
       (if userDataVerbose then
           'MakeMarkNode: Created CommentMark!'->putline
       if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       (if ID->DSRdAttrGetObjectType
        // RegionType then theObject.onInitRegion; 
       if);
       (if (ID,count2[],list[])->DSStrGetObjectRegionList
        // true then
           (if count2 > 0
            // true then
               (count2,list)->GetIntList->regions;
               (if verbose
                // true then
                   'NoOfRegions: '->puttext; regions.range->putint; newline; 
               if);
               regions->MakeObjectsFromList;
               
           if)
       if);
       theCommentMark.theCommentNode.getID
         ->theNodeID
         (*theCommentNode currently refers to RectNode.
          getId works around qua error*) ;
       (if theNodeID <> 0 then
           (theListDiagram[],theNodeID)->MakeCommentNode
       if);
       theCommentMark.theConn.getID->theConnID;
       (if theConnID <> 0 then (theListDiagram[],theConnID)->MakeConn if)
   if)
#)  

-- MakeCommentNode: Descriptor --
(#
   NodeType: @integer;
   theObject: ^DesignObject;
   theCommentNode: ^theListDiagram.MyCommentNode;
   regions: [0] @Integer;
   count2: @ShortRef;
   list: @IntegerRef
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDMyCommentNode then
       &theListDiagram.MyCommentNode[]->theCommentNode[]->theObject[];
       true->theCommentNode.initialisingSaved;
       (if userDataVerbose then
           'MakeCommentNode: Created MyCommentNode!'->putline
       if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       (if ID->DSRdAttrGetObjectType
        // RegionType then theObject.onInitRegion; 
       if);
       (if (ID,count2[],list[])->DSStrGetObjectRegionList
        // true then
           (if count2 > 0
            // true then
               (count2,list)->GetIntList->regions;
               (if verbose
                // true then
                   'NoOfRegions: '->puttext; regions.range->putint; newline; 
               if);
               regions->MakeObjectsFromList;
               
           if)
       if)
   if)
#)  

-- MakeConn: Descriptor --
(#
   NodeType: @integer;
   theObject: ^DesignObject;
   theConnector: ^theListDiagram.CommonConnector;
   theDeletableConn: ^DeletableConnector;
   regions: [0] @Integer;
   count2: @ShortRef;
   list: @IntegerRef
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDPrefixConnector then
       &theListDiagram.PrefixConnector[]->theConnector[]->theObject[];
       true->theConnector.initialisingSaved;
       (if userDataVerbose then
           'MakeConn: Created PrefixConnector!'->putline
       if)
    // UDPrivate.UDDynamicItemConnector then
       &DynamicItemConnector[]->theDeletableConn[]->theObject[];
       true->theDeletableConn.initialisingSaved;
       (if userDataVerbose then
           'MakeConn: Created DynamicItemConnector!'->putline
       if)
    // UDPrivate.UDDynamicComponentConnector then
       &DynamicComponentConnector[]->theDeletableConn[]->theObject[];
       true->theDeletableConn.initialisingSaved;
       (if userDataVerbose then
           'MakeConn: Created DynamicComponentConnector!'->putline
       if)
    // UDPrivate.UDTreeConnector then
       &theListDiagram.TreeConnector[]->theConnector[]->theObject[];
       true->theConnector.initialisingSaved;
       (if userDataVerbose then
           'MakeConn: Created TreeConnector!'->putline
       if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       (if ID->DSRdAttrGetObjectType
        // RegionType then theObject.onInitRegion; 
       if);
       (if (ID,count2[],list[])->DSStrGetObjectRegionList
        // true then
           (if count2 > 0
            // true then
               (count2,list)->GetIntList->regions;
               (if verbose
                // true then
                   'NoOfRegions: '->puttext; regions.range->putint; newline; 
               if);
               regions->MakeObjectsFromList;
               
           if)
       if)
   if)
#)  

-- onReadDiagram: Descriptor --
(# 
do
(*  THIS(OADPage).PatternDiagrams.theList.scan
 (#
 theListDiagram: ^ListDiagram;
 thisOADDiagram: ^OADDiagram;
 thisFragmentDiagram: ^FragmentDiagram;
 theDummyDesc: ^betaGram.ObjectDescriptor;
 thisPatternAttDiagram: ^PatternAttDiagram;
 theDummyAST: ^AST
 do
 current.e[]->theListDiagram[];
 (if current.e.struc <= OADDiagram##
 // true then
 current.e[]->thisOADDiagram[];
 thisOADDiagram.titlenode.theText.get->thisOADDiagram.titleText;
 (if thisOADDiagram.theDescriptor <> none then
 thisOADDiagram.theDescriptor->theDummyDesc[];
 theDummyDesc.index->current.index;
 (if thisOADDiagram## <= PatternAttDiagram## then
 thisOADDiagram[]->thisPatternAttDiagram[];
 thisPatternAttDiagram.theAST->theDummyAST[];
 theDummyAST.index->current.index
 if)
 if);
 if);
 (if current.e.struc <= FragmentDiagram## then
 current.e[]->thisFragmentDiagram[];
 thisFragmentDiagram.titlenode.theText.get
 ->thisFragmentDiagram.titleText
 if)
 #) *) 
#)  

