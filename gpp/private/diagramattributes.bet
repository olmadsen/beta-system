ORIGIN '../gppinterface';
BODY 'gppinterfacebody'
     'diagrambody'
     'patterndiagrambody'
     'abstractnodebody'
     'fragmentnodebody'
     'marknodebody'
     'simplenodebody'
     'nonterminalnodebody';
INCLUDE '~beta/containers/v1.4/list'
        '../prettyprintersetup'
        '../propertydiagrams'
        'userdataprivate';
(* This fragment group defines patterns visible to all bodies,
 * but not visible in the interface
 *)
-- OADPageLib: Attributes --
scrollIntoView:
  (# theObject: ^designObject; 
  enter theObject[]
  do (if doScrollIntoView then theObject[]->currentObject (#  do true->autoPan #);  if); 
  #);
GetPrefix:
  (#
     theDescriptor: ^betaGram.ObjectDescriptor;
     tempAst: ^mps.ast;
     pref: ^betaGram.prefix;
     ad: ^betaGram.attributeDenotation;
     thisPrefix: ^betaGram.ObjectDescriptor;
     
  enter theDescriptor[]
  do
     theDescriptor.getPrefixOpt->tempAst[];
     (if tempAst.kind
      // mps.kinds.interior then
         tempAst[]->pref[];
         pref.getAttributeDenotation->tempAst[];
         (if tempAst.kind
          // mps.kinds.interior then tempAst[]->ad[]; ad.findDescriptor->thisPrefix[]; 
         if);
         
     if);
     
  exit thisPrefix[]
  #);
(* LIST HANDLING *)
DiagramList: ContainerList (* list of diagrams on a page *)
  (#
     element::<  (# index: @Integer; e: ^Diagram #);
     myFind: find
       (# i: @Integer; predicate::<  (#  do (i = current.index)->value #);  enter i #);
     findPD:
       (# aPD: ^Element; aDiagram: ^Diagram; 
       enter myFind->aPD[]
       do (if aPD[] <> none // true then aPD.e[]->aDiagram[];  if); 
       exit aDiagram[]
       #);
     insertPD:
       (# aPD: ^Element; index: @Integer; e: ^Diagram; 
       enter (index,e[])
       do &Element[]->aPD[]; (index,e[])->(aPD.index,aPD.e[]); aPD[]->append; 
       #);
     deletePD: (#  enter myFind->at->delete #);
     deleteProp:
       (#
          findProp:
            (# p: ^Diagram; aPD: ^Element; 
            enter p[]
            do
               scanner: scan
                 (# 
                 do (if current.e[] // p[] then current[]->aPD[]; leave scanner if); 
                 #);
               
            exit aPD[]
            #);
          
       enter findProp->at->delete
       #);
     GetSubPatternDiagrams:
       (# theDiagram,aPatternDiagram: ^PatternDeclDiagram; aList: ^DiagramList; 
       enter theDiagram[]
       do
          &DiagramList[]->aLIst[];
          scan
            (# 
            do
               (if current.e.struc <= PatternDeclDiagram##
                // true then
                   current.e[]->aPatternDiagram[];
                   (if aPatternDiagram.thePrefix <> none
                    // true then
                       (if aPatternDiagram.thePrefix->(theDiagram.theDescriptor).equal
                        // true then current[]->aList.append; 
                       if)
                   if)
               if)
            #);
          
       exit aList[]
       #);
     scanPatternDiagrams: scan
       (# thisDiagram: ^PatternDeclDiagram; 
       do
          (if current.e.struc <= PatternDeclDiagram##
           // true then current.e[]->thisDiagram[]; INNER ; 
          if)
       #);
     scanFragmentDiagrams: scan
       (# thisDiagram: ^fragmentDiagram; 
       do
          (if current.e## <= FragmentDiagram##
           // true then current.e[]->thisDiagram[]; INNER ; 
          if)
       #);
     scanPropertyDiagrams: scan
       (# thisDiagram: ^SimplePropertyDiagram; 
       do
          (if current.e.struc <= SimplePropertyDiagram##
           // true then current.e[]->thisDiagram[]; INNER ; 
          if)
       #);
     
  #);
  

-- DiagramLib: Attributes --
DisplayAst:
  (# anAST: ^MPS.AST; pos: @Point; 
  enter (anAST[],pos)
  do <<SLOT DisplayAST:Descriptor>>; 
  exit pos
  #);
scanAttributeDecls:
  (#
     theAtt: ^betaGram.Attributes;
     anAst: ^mps.ast;
     ndl: ^betaGram.names;
     unExp: ^mps.unExpanded;
     thisAttribute:<
       (# nd: ^betaGram.nameDcl enter nd[] do INNER #);
     thisUnExp:<
       (# unExp: ^mps.unExpanded enter unExp[] do INNER #);
     thisOptional:<
       (# opt: ^mps.Optional enter opt[] do INNER #);
     thisSlot:<
       (# theSlot: ^mps.SlotDesc enter theSlot[] do INNER #);
     
  enter theAtt[]
  do
     (if switch[1]
      // true then 'scanAttributeDecls'->screen.putline; 
     if);
     theAtt.scan
       (# att: ^betaGram.attributeDecl
       do
          (if switch[1] // true then '*'->screen.put if);
          (if current.kind
           // mps.kinds.interior then
              current[]->att[];
              att.getSon1->anAst[];
              (if switch[1]
               // true then
                  'interior: '->screen.puttext;
                  anAst.symbol->screen.putint;
                  screen.newline;
                  
              if);
              (if anAst.symbol
               // betaGram.names then
                  anAst[]->ndl[];
                  ndl.scan
                    (#  do current[]->thisAttribute #)
              if)
           // mps.kinds.unExpanded then
              (if switch[1]
               // true then 'unExpanded: '->screen.puttext; 
              if);
              current[]->unExp[];
              (if unExp.isSlot
               // true then
                  (if switch[1]
                   // true then 'Slot'->screen.putline; 
                  if);
                  unExp.theSlot->thisSlot;
                  
               else
                  (if switch[1] // true then screen.newline;  if);
                  unExp[]->thisUnExp;
                  
              if)
           // mps.kinds.optional then
              (if switch[1]
               // true then 'optional'->screen.putline; 
              if);
              current[]->thisOptional;
              
          if)
       #);
     (if switch[1] // true then 'DONE'->screen.putline if);
     
  #);
CountAttributes:
  (#
     obj: ^betaGram.ObjectDescriptor;
     main: ^betaGram.MainPart;
     a: ^MPS.AST;
     i: @Integer;
     
  enter obj[]
  do
     (if switch[1]
      // true then 'CountAttributes '->screen.puttext
     if);
     (if obj[] <> none
      // true then
         obj.getMainPart->main[];
         main.getAttributes->a[];
         (if a[]
          // none then
             'Attribute error: cannot get attributes from descriptor: '->puttext;
             
          else
             (if a.kind
              // mps.kinds.interior then
                 (if switch[1] // true then 'scanning '->screen.puttext if);
                 a[]
                   ->scanAttributeDecls
                     (#
                        thisAttribute::<  (#  do i+1->i #);
                        thisOptional::<  (#  do i+1->i #);
                        thisUnExp::<  (#  do i+1->i #);
                        
                     #);
                 
             if)
         if)
     if);
     (if switch[1] // true then screen.newline if);
     
  exit i
  #);
CheckKeyWord:
  (#
     node: ^mps.ast;
     keyword: ^text;
     found: @boolean;
     theCom: ^mps.comment;
     theComText,nextWord: ^text;
     
  enter (node[],keyword[])
  do
     (if node.hasComment
      // true then
         node.getComment->theCom[];
         theCom.getText->theComText[];
         theComText.reset;
         search:
           (# 
           do
              theComText.getAtom->nextWord[];
              (if true
               // keyWord[]->nextWord.equal then true->found; 
               else
                  (if theComText.eos // false then restart search if); 
              if);
              
           #);
         
     if);
     
  exit found
  #);
isDescriptorDiagram:
  (#
     theOADDiagram: ^OADDiagram;
     desc: ^betaGram.ObjectDescriptor;
     anAST: ^MPS.AST;
     value: @Boolean
  enter theOADDiagram[]
  do
     theOADDiagram.theDescriptor->desc[];
     (if desc[] <> none then
         desc.father->anAST[]; (if anAST.father = none then true->value if)
     if)
  exit value
  #);
makeNonTerminalSymbol:
  (# symbolName: ^Text
  enter symbolName[]
  do '<<'->symbolName.prepend; '>>'->symbolName.append
  exit symbolName[]
  #);
makeRemote:
  (#
     anAST: ^MPS.AST;
     rem: ^betaGram.remote;
     unExp: ^mps.unexpanded;
     na: ^betaGram.nameApl;
     t: ^text
  enter anAST[]
  do
     &Text[]->t[];
     anAST[]->rem[];
     rem.getAttributeDenotation->anAST[];
     (if anAST.kind = mps.kinds.unExpanded then
         anAST[]->unExp[];
         unExp.NonTerminalSymbol->betaGram.symbolToName->makeNonTerminalSymbol->t.append;
         '.'->t.append
      else
         (if anAST.symbol
          // betaGram.NameApl then
             anAST[]->na[];
             na.getNameAppl->anAST[];
             (if anAST.kind = mps.kinds.unExpanded then
                 '<NameAppl>.'->t.append
              else
                 na.gettext->t.append; '.'->t.append
             if)
          // betaGram.Remote then
             anAST[]->makeRemote->t.append; '.'->t.append
         if)
     if);
     rem.getNameApl->na[];
     na.getNameAppl->anAST[];
     (if anAST.kind = mps.kinds.unExpanded then
         '<NameAppl>'->t.append
      else
         na.gettext->t.append
     if)
  exit t[]
  #);
(****************** DIAGRAM NODES ************************)
AbstractNode: PatternDiagramNode
  (#
     theName: @ReferenceUserData (# Type::< Text #);
     currentDecomposDiagram: @DiagramReferenceUserData (# Type::< PatternDiagram #);
     decomposDiagrams: @containerlist (# element::< PatternDiagram #);
     PatternDiagReference: LocalNodesReferenceUserData (# Type::< PatternDiagram #);
     theTreeConn: ^TreeConnector;
     theDexterAnchor: ^AnchorMark;
     onSelect::< 
       (# 
       do
          (PatternDiagrams.oldSelection[],THIS(AbstractNode)[])->changedFocus;
          THIS(AbstractNode)[]->PatternDiagrams.oldSelection[];
          INNER onSelect;
          
       #);
     onRemove::< (* called when THIS(DiagramNode) is deleted *) 
       (#  do <<SLOT AbstractNodeRemove:Descriptor>>;  #);
     Display::< 
       (# t: @Text; pos: @Point; 
       enter pos
       do <<SLOT AbstractNodeDisplay:Descriptor>>; 
       #);
     Redisplay::<  (# t: @Text;  do <<SLOT AbstractNodeRedisplay:Descriptor>>;  #);
     ConcludeDisplay::< 
       (# 
       do
          INNER ;
          <<SLOT AbstractNodeConcludeDisplay:Descriptor>>;
          
       #);
     MakeAnchor::<  (#  do INNER ; <<SLOT AbstractNodeMakeAnchor:Descriptor>> #);
     detail::< 
       (# theAST: ^MPS.AST (* the AST to be detailed *)
       do <<SLOT AbstractNodeDetail:Descriptor>>; 
       #);
     abstract::<
     (* if detailed then abstract the decompos diagram *) 
       (#  do <<SLOT AbstractNodeAbstract:Descriptor>>;  #);
     abstractedFromDiagramBelow::<
     (* when THIS(DiagramNode) has been abstrated from a diagram below *) 
       (#  do <<SLOT AbstractNodeAbstractedFromDiagramBelow:Descriptor>>;  #);
     hasAttributes: @BooleanUserData;
     CheckForAttributes:<
       (# 
       do INNER
       exit hasAttributes
       #);
     onInit::< 
       (# 
       do
          UDPrivate.UDAbstractNode
            ->UserDataInit;
          theName.Init;
          currentDecomposDiagram.Init;
          hasAttributes.Init;
          (if initialisingSaved then
              gppProp.fontSize
                ->theText.size
          if);
          INNER
       #);
     dump::< 
       (# 
       do
          <<SLOT AbstractNodeDump:Descriptor>>;
          INNER
       #)
  #);
(******************** For FragmentDiagrams *********************)
FragmentNode: AbstractNode
  (#
     theFragment: @FragReferenceUserData (# Type::< mps.FragmentForm #);
     theRoot: @ASTReferenceUserData (# type::< mps.ast #);
     sifEditorInstance: ^SifEditor;
     display::<  (#  enter theFragment do <<SLOT FragmentNodeDisplay:Descriptor>>;  #);
     redisplay::< 
       (# 
       enter theFragment
       do <<SLOT FragmentNodeRedisplay:Descriptor>>; 
       #);
     ConcludeDisplay::<  (#  do INNER #);
     onDoubleClick::< 
       (# doneInInner: @Boolean
       do INNER ; (if not doneInInner then false->IndicateSelection; detail if)
       #);
     detail::<  (#  do INNER ; <<SLOT FragmentNodeDetail:Descriptor>> #);
     GetGroup::< 
       (# fd: ^FragmentDiagram; 
       do theDiagram->fd[]; fd.theGroup->fg[]; 
       #);
     GetFragment::<  (#  do theFragment->f[];  #);
     theSifEditor::< 
       (# 
       do
          (if se[] = none then
              sifEditorInstance[]->se[]
           else
              se[]->sifEditorInstance[]
          if)
       #);
     CheckForAttributes::<  (#  do true->hasAttributes #);
     onInit::< 
       (# 
       do
          UDPrivate.UDFragmentNode->UserDataInit;
          theRoot.Init;
          theFragment.Init;
          INNER
       #);
     dump::< 
       (#  do <<SLOT FragmentNodeDump:Descriptor>>;  #);
     
  #);
DoPartNode: FragmentNode
  (#
     display::< 
       (# 
       do
          ': DoPart'
            ->t.append;
          
       #);
     onDoubleClick::< 
       (# 
       do
          true
            ->doneInInner
       #);
     onInit::< 
       (# 
       do
          UDPrivate.
            UDDoPartNode->UserDataInit;
          INNER
       #)
  #);
AttributesNode: FragmentNode
  (#
     display::<  (#  do ': Attributes'->t.append;  #);
     redisplay::<  (#  do ': Attributes'->t.append;  #);
     detail::<  (#  do <<SLOT AttributesNodeDetail:Descriptor>> #);
     onInit::< 
       (# 
       do UDPrivate.UDAttributesNode->UserDataInit; INNER
       #);
     
  #);
DescriptorNode: FragmentNode
  (#
     display::<  (#  do ': Descriptor'->t.append;  #);
     redisplay::<  (#  do ': Descriptor'->t.append;  #);
     detail::< 
       (# 
       do <<SLOT DescriptorNodeDetail:Descriptor>>
       #);
     onInit::< 
       (# 
       do
          UDPrivate.
            UDDescriptorNode->UserDataInit;
          INNER
       #);
     
  #);
DiagramNode: AbstractNode
  (#
     theDeclaration: @ASTReferenceUserData (# Type::< betaGram.AttributeDecl #);
     theObjectDescriptor: @ASTReferenceUserData (# Type::< betaGram.ObjectDescriptor #);
     thePrefix: @ASTReferenceUserData (# Type::< betaGram.ObjectDescriptor #);
     onSelect::<  (#  do enableEditName; INNER onSelect #);
     CheckForAttributes::< 
       (#  do (theObjectDescriptor->CountAttributes) > 0->hasAttributes;  #);
     Display::< 
       (# anAST: ^MPS.AST; (* either theName or an unExp *) 
       enter (theDeclaration,anAST[])
       do <<SLOT DiagramNodeDisplay:Descriptor>>; 
       #);
     Redisplay::< 
       (#
          anAST: ^MPS.AST; (* either theName or an unExp *) 
       enter (theDeclaration,anAST[])
       do <<SLOT DiagramNodeReDisplay:Descriptor>>
       #);
     ConcludeDisplay::<  (#  do <<SLOT DiagramNodeConcludeDisplay:Descriptor>>; INNER #);
     DesignText::< 
       (#
          ModeOn::< 
            (#
               help: ^text;
               ok: @Boolean;
               indexText: @Text
            <<SLOT DiagramNodeModeOn:DoPart>>
            #);
          ModeOff::<
            (# t: @Text; noChange: @boolean <<SLOT DiagramNodeModeOff:DoPart>> #);
          
       #);
     EqualDescriptor:<
       (# aDesc: ^betaGram.ObjectDescriptor; b: @Boolean; 
       enter aDesc[]
       do INNER
       exit b
       #);
     detail::< 
       (#  do <<SLOT DiagramNodeDetail:Descriptor>> #);
     getASTNode::<
     (* return the AST node THIS(title) is generated from *) 
       (#  do theDeclaration->anAST[]; INNER #);
     GetGroup::<  (#  do <<SLOT DiagramNodeGetGroup:Descriptor>> #);
     GetFragment::< 
       (# 
       do <<SLOT DiagramNodeGetFragment:Descriptor>>
       #);
     theSifEditor::<  (# fn: ^FragmentNode <<SLOT theSifEditor:DoPart>> #);
     onInit::< 
       (# 
       do
          theDeclaration.Init;
          theObjectDescriptor.Init;
          thePrefix.init;
          INNER
       #);
     dump::< 
       (#  do <<SLOT DiagramNodeDump:Descriptor>>; INNER #);
     
  #);
SimpleAttributeDecl: DiagramNode
(* SimpleDecl or RepetitionDecl *)
  (#
     declTypeNode: @ReferenceUserData (# Type::< PatternDiagramNode #);
     theReferenceSpec: @ASTReferenceUserData (# Type::< betaGram.referenceSpecification #);
     theUnExpRefSpec: @ASTReferenceUserData (# Type::< mps.unExpanded #);
     theQualification: @ASTReferenceUserData (# Type::< betaGram.AttributeDecl #);
     Display::< 
       (# theObjectSpec: ^MPS.AST
       do
          INNER ;
          (* make theObjectSpec and theReferenceSpec *)
          <<SLOT SimpleAttrDeclDisplay:Descriptor>>;
          
       #);
     Redisplay::< 
       (# theObjectSpec: ^MPS.AST
       do
          INNER ;
          (* make theObjectSpec and theReferenceSpec *)
          <<SLOT SimpleAttrDeclReDisplay:Descriptor>>;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[1] then 'Text mode on in SimpleAttributeDeclNode'->putLine;  if);
               ' @'->parseableText.putText;
               INNER
            #);
          ModeOff::< 
            (# 
            do
               (if switch[1] then 'Text mode off in SimpleAttributeDeclNode '->putLine;  if);
               INNER ;
               
            #);
          
       #);
     DisplayReference:< (#  do INNER #);
     onInit::< 
       (# 
       do
          UDPrivate.UDSimpleAttributeDecl->UserDataInit;
          declTypeNode.Init;
          theReferenceSpec.Init;
          theUnExpRefSpec.Init;
          theQualification.init;
          INNER
       #);
     dump::<  (#  do <<SLOT SimpleAttributeDecldump:Descriptor>>; INNER #);
     
  #);
SimpleNode: SimpleAttributeDecl
  (#
     theReferenceConnector: @ReferenceUserData
       (# Type::< Connector #);
     onDoubleClick::< 
       (# 
       do <<SLOT SimpleNodeDoubleClick:Descriptor>>
       #);
     Display::<
       (#  do <<SLOT SimpleNodeDisplay:Descriptor>> #);
     Redisplay::< 
       (#  do <<SLOT SimpleNodeRedisplay:Descriptor>> #);
     DisplayReference::<
       (#  do <<SLOT SimpleNodeDisplayReference:Descriptor>>;  #);
     onInit::< 
       (# 
       do
          UDPrivate.UDSimpleNode->UserDataInit;
          theReferenceConnector.init;
          INNER
       #);
     dump::< 
       (# 
       do <<SLOT SimpleNodeDump:Descriptor>>; INNER
       #);
     
  #);
RepetitionNode: SimpleAttributeDecl
  (#
     onDoubleClick::<  (#  do <<SLOT RepetitionNodeDoubleClick:Descriptor>> #);
     Display::< 
       (# 
       do <<SLOT RepetitionNodeDisplay:Descriptor>>
       #);
     Redisplay::<  (#  do <<SLOT RepetitionNodeRedisplay:Descriptor>> #);
     onInit::< 
       (# 
       do
          UDPrivate.UDRepetitionNode->UserDataInit;
          INNER
       #);
     
  #);
PatternNode: DiagramNode
  (#
     theAssociationNode: @ReferenceUserData
       (# Type::< AssociationNode #);
     Display::< 
       (# pd: ^betaGram.PatternDecl; anAST: ^MPS.AST; 
       do
          (if (theDeclaration).struc <=
          betaGram.PatternDecl##
           // true then
              theDeclaration->pd[];
              pd.getObjectDescriptor->anAST[];
              (if anAST.kind
               // mps.kinds.interior then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then
                   (*gppProp.AbstractedStyle -> theText.style*)
                      ': ...'->t.puttext; 
                  if);
                  
              if);
              pd->SetRegionType;
              
          if);
          DisplayReferences;
          INNER ;
          setupAssociation;
          
       #);
     Redisplay::< 
       (# pd: ^betaGram.PatternDecl; anAST: ^MPS.AST; 
       do
          (if switch[1] then
              (if theDeclaration <> none then
                  '*** patternNode'->putLine;
                  'theDeclaration: '->putText;
                  (theDeclaration).index->putInt;
                  newLine;
                  
              if);
              (if theObjectDescriptor <> none then
                  'theObjectDescriptor: '->putText; (theObjectDescriptor).index->putInt; newLine; 
              if);
              
          if);
          (if (theDeclaration).struc <= betaGram.PatternDecl##
           // true then
              theDeclaration->pd[];
              pd.getObjectDescriptor->anAST[];
              (if anAST.kind
               // mps.kinds.interior then
                  anAST[]->theObjectDescriptor;
                  (if currentDecomposDiagram <> none then
                      anAST[]->(currentDecomposDiagram).theDescriptor
                  if);
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*) ': ...'->t.puttext; 
                  if);
                  
              if);
              pd->SetRegionType;
              
          if);
          (if switch[1] then
              (if theDeclaration <> none then
                  'theDeclaration: '->putText; (theDeclaration).index->putInt; newLine; 
              if);
              (if theObjectDescriptor <> none then
                  'theObjectDescriptor: '->putText; (theObjectDescriptor).index->putInt; newLine; 
              if);
              
          if);
          INNER ;
          
       #);
     onDoubleClick::< 
       (# 
       do
          false->indicateSelection;
          (if switch[1]
           // true then 'doubleClick PatternDeclaration ID: '->puttext; ID->putint; newline; 
          if);
          (if hasAttributes
           // true then detail; 
           else
              (if switch[1] // true then 'no attributes'->putline if)
          if);
          INNER ;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[1] then 'Text mode on in PatternNode'->putLine;  if);
               ' '->parseableText.put;
               INNER
            #);
          ModeOff::< 
            (# 
            do (if switch[1] then 'Text mode off in PatternNode '->putLine;  if); INNER ; 
            #);
          
       #);
     EqualDescriptor::< 
       (# 
       do
          (if theObjectDescriptor <> none
           // true then aDesc[]->(theObjectDescriptor).equal->b; 
          if);
          INNER ;
          
       #);
     detail::<  (#  do <<SLOT PatternNodeDetail:Descriptor>>;  #);
     DisplayReferences:
       (# 
       do <<SLOT PatternNodeDisplayReferences:Descriptor>>; 
       #);
     DisplayAssociations: (#  do <<SLOT DisplayAssociations:Descriptor>>;  #);
     setupAssociation:
       (# 
       do <<SLOT PatternNodeSetupAssociation:Descriptor>>; 
       #);
     onInit::< 
       (#  do UDPrivate.UDPatternNode->UserDataInit; theAssociationNode.init; INNER #);
     dump::< 
       (# 
       do
          '****theAssociationNode****'->putline;
          (if theAssociationNode <> none then
              (theAssociationNode).ID->putint; newline
           else
              'is NONE!'->putline
          if)
       #);
     
  #);
VirtualNode: PatternNode
  (#
     onDoubleClick::<  (#  do INNER ;  #);
     Display::< 
       (#
          vd: ^betaGram.VirtualDecl;
          anAST,a: ^MPS.AST;
          theUnExpObjSpec: ^mps.unexpanded;
          aName: ^betaGram.NameApl;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration).struc <= betaGram.VirtualDecl##
           // true then
              theDeclaration->vd[];
              vd->SetRegionType;
              (if not (gppProp.SimpleDeclDisplay = gppProp.AsName) then
                  ':< '->t.append;
                  vd.getObjectSpecification->anAST[];
                  (if anAST.symbol
                   // betaGram.ObjectDescriptor then
                      anAST[]->theObjectDescriptor;
                      (if CheckForAttributes
                       // true then (*gppProp.AbstractedStyle -> theText.style*)
                          ' ...'->t.puttext; 
                      if)
                   // betaGram.NameApl then
                      anAst[]->aName[];
                      aName.getNameAppl->a[];
                      (if a.kind
                       // mps.kinds.unExpanded then
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              ' <<NameAppl>>'->t.append
                           // gppProp.asType then
                              t.clear; ':< <<NameAppl>>'->t.append; 
                          if);
                          
                       else
                      (* is a real name *)
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              a[]->theAppl[]; theAppl.getText->t.append
                           // gppProp.asType then
                              t.clear; ':< '->t.append; a[]->theAppl[]; theAppl.getText->t.append; 
                          if);
                          
                      if)
                   // betaGram.Remote then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          anAST[]->MakeRemote->t.append
                       // gppProp.asType then
                          t.clear; ':< '->t.append; anAST[]->MakeRemote->t.append; 
                      if)
                   else
                      (if anAST.kind = mps.kinds.unExpanded then
                          anAST[]->theUnExpObjSpec[];
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                                ->makeNonTerminalSymbol->t.append
                           // gppProp.asType then
                              t.clear;
                              ':< '->t.append;
                              theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                                ->makeNonTerminalSymbol->t.append;
                              
                          if)
                      if)
                  if)
              if);
              
          if);
          betaGram.VirtualDecl->SetRegionType;
          INNER ;
          
       #);
     Redisplay::< 
       (#
          vd: ^betaGram.VirtualDecl;
          anAST,a: ^MPS.AST;
          theUnExpObjSpec: ^mps.unexpanded;
          aName: ^betaGram.NameApl;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration).struc <= betaGram.VirtualDecl##
           // true then
              theDeclaration->vd[];
              vd->SetRegionType;
              (if not (gppProp.SimpleDeclDisplay = gppProp.AsName) then
                  ':< '->t.append;
                  vd.getObjectSpecification->anAST[];
                  (if anAST.symbol
                   // betaGram.ObjectDescriptor then
                      anAST[]->theObjectDescriptor;
                      (if CheckForAttributes
                       // true then (*gppProp.AbstractedStyle -> theText.style*)
                          ' ...'->t.puttext; 
                      if)
                   // betaGram.NameApl then
                      anAst[]->aName[];
                      aName.getNameAppl->a[];
                      (if a.kind
                       // mps.kinds.unExpanded then
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              ' <<NameAppl>>'->t.append
                           // gppProp.asType then
                              t.clear; ':< <<NameAppl>>'->t.append; 
                          if);
                          
                       else
                      (* is a real name *)
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              a[]->theAppl[]; theAppl.getText->t.append
                           // gppProp.asType then
                              t.clear; ':< '->t.append; a[]->theAppl[]; theAppl.getText->t.append; 
                          if);
                          
                      if)
                   // betaGram.Remote then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          anAST[]->MakeRemote->t.append
                       // gppProp.asType then
                          t.clear; ':< '->t.append; anAST[]->MakeRemote->t.append; 
                      if)
                   else
                      (if anAST.kind = mps.kinds.unExpanded then
                          anAST[]->theUnExpObjSpec[];
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                                ->makeNonTerminalSymbol->t.append
                           // gppProp.asType then
                              t.clear;
                              ':< '->t.append;
                              theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                                ->makeNonTerminalSymbol->t.append;
                              
                          if)
                      if)
                  if)
              if);
              
          if);
          betaGram.VirtualDecl->SetRegionType;
          INNER ;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[1] then 'Text mode on in VirtualNode'->putLine;  if);
               '< '->parseableText.putText;
               INNER
            #);
          ModeOff::< 
            (# t: @Text
            do (if switch[1] then 'Text mode off in VirtualNode '->putLine;  if); INNER ; 
            #);
          
       #);
     onInit::<  (#  do UDPrivate.UDVirtualNode->UserDataInit; INNER #);
     
  #);
BindingNode: PatternNode
  (#
     onDoubleClick::<  (#  do INNER ;  #);
     Display::< 
       (#
          bd: ^betaGram.BindingDecl;
          anAST,a: ^MPS.AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^mps.unexpanded;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration).struc <= betaGram.BindingDecl##
           // true then
              theDeclaration->bd[];
              bd->SetRegionType;
              (if not (gppProp.SimpleDeclDisplay = gppProp.AsName) then
                  '::< '->t.append;
                  bd.getObjectSpecification->anAST[];
                  (if anAST.symbol
                   // betaGram.ObjectDescriptor then
                      anAST[]->theObjectDescriptor;
                      (if CheckForAttributes
                       // true then (*gppProp.AbstractedStyle -> theText.style*)
                          ' ...'->t.puttext; 
                      if)
                   // betaGram.NameApl then
                      anAst[]->aName[];
                      aName.getNameAppl->a[];
                      (if a.kind
                       // mps.kinds.unExpanded then
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              ' <<NameAppl>>'->t.append
                           // gppProp.asType then
                              t.clear; '::< <<NameAppl>>'->t.append; 
                          if);
                          
                       else
                      (* is a real name *)
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              a[]->theAppl[]; theAppl.getText->t.append
                           // gppProp.asType then
                              t.clear; '::< '->t.append; a[]->theAppl[]; theAppl.getText->t.append; 
                          if);
                          
                      if)
                   // betaGram.Remote then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          anAST[]->MakeRemote->t.append
                       // gppProp.asType then
                          t.clear; '::< '->t.append; anAST[]->MakeRemote->t.append; 
                      if)
                   else
                      (if anAST.kind = mps.kinds.unExpanded then
                          anAST[]->theUnExpObjSpec[];
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                                ->makeNonTerminalSymbol->t.append
                           // gppProp.asType then
                              t.clear;
                              '::< '->t.append;
                              theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                                ->makeNonTerminalSymbol->t.append;
                              
                          if)
                      if)
                  if)
              if);
              
          if);
          betaGram.BindingDecl->SetRegionType;
          INNER ;
          
       #);
     Redisplay::< 
       (#
          bd: ^betaGram.BindingDecl;
          anAST,a: ^MPS.AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^mps.unexpanded;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration).struc <= betaGram.BindingDecl##
           // true then
              theDeclaration->bd[];
              bd->SetRegionType;
              (if not (gppProp.SimpleDeclDisplay = gppProp.AsName) then
                  '::< '->t.append;
                  bd.getObjectSpecification->anAST[];
                  (if anAST.symbol
                   // betaGram.ObjectDescriptor then
                      anAST[]->theObjectDescriptor;
                      (if CheckForAttributes
                       // true then (*gppProp.AbstractedStyle -> theText.style*)
                          ' ...'->t.puttext; 
                      if)
                   // betaGram.NameApl then
                      anAst[]->aName[];
                      aName.getNameAppl->a[];
                      (if a.kind
                       // mps.kinds.unExpanded then
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              ' <<NameAppl>>'->t.append
                           // gppProp.asType then
                              t.clear; '::< <<NameAppl>>'->t.append; 
                          if);
                          
                       else
                      (* is a real name *)
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              a[]->theAppl[]; theAppl.getText->t.append
                           // gppProp.asType then
                              t.clear; '::< '->t.append; a[]->theAppl[]; theAppl.getText->t.append; 
                          if);
                          
                      if)
                   // betaGram.Remote then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          anAST[]->MakeRemote->t.append
                       // gppProp.asType then
                          t.clear; '::< '->t.append; anAST[]->MakeRemote->t.append; 
                      if)
                   else
                      (if anAST.kind = mps.kinds.unExpanded then
                          anAST[]->theUnExpObjSpec[];
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                                ->makeNonTerminalSymbol->t.append
                           // gppProp.asType then
                              t.clear;
                              '::< '->t.append;
                              theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                                ->makeNonTerminalSymbol->t.append;
                              
                          if)
                      if)
                  if)
              if);
              
          if);
          betaGram.BindingDecl->SetRegionType;
          INNER ;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[1] then 'Text mode on in BindingNode'->putLine;  if);
               ':< '->parseableText.putText;
               INNER
            #);
          ModeOff::< 
            (# t: @Text
            do (if switch[1] then 'Text mode off in BindingNode '->putLine;  if); INNER ; 
            #);
          
       #);
     onInit::<  (#  do UDPrivate.UDBindingNode->UserDataInit; INNER #);
     
  #);
FinalNode: PatternNode
  (#
     onDoubleClick::<  (#  do INNER ;  #);
     Display::< 
       (#
          fd: ^betaGram.FinalDecl;
          anAST,a: ^MPS.AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^mps.unexpanded;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration).struc <= betaGram.FinalDecl##
           // true then
              theDeclaration->fd[];
              fd->SetRegionType;
              (if not (gppProp.SimpleDeclDisplay = gppProp.AsName) then
                  ':: '->t.append;
                  fd.getObjectSpecification->anAST[];
                  (if anAST.symbol
                   // betaGram.ObjectDescriptor then
                      anAST[]->theObjectDescriptor;
                      (if CheckForAttributes
                       // true then (*gppProp.AbstractedStyle -> theText.style*)
                          ' ...'->t.puttext; 
                      if)
                   // betaGram.NameApl then
                      anAst[]->aName[];
                      aName.getNameAppl->a[];
                      (if a.kind
                       // mps.kinds.unExpanded then
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              ' <<NameAppl>>'->t.append
                           // gppProp.asType then
                              t.clear; ':: <<NameAppl>>'->t.append; 
                          if);
                          
                       else
                      (* is a real name *)
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              a[]->theAppl[]; theAppl.getText->t.append
                           // gppProp.asType then
                              t.clear; ':: '->t.append; a[]->theAppl[]; theAppl.getText->t.append; 
                          if);
                          
                      if)
                   // betaGram.Remote then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          anAST[]->MakeRemote->t.append
                       // gppProp.asType then
                          t.clear; ':: '->t.append; anAST[]->MakeRemote->t.append; 
                      if)
                   else
                      (if anAST.kind = mps.kinds.unExpanded then
                          anAST[]->theUnExpObjSpec[];
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                                ->makeNonTerminalSymbol->t.append
                           // gppProp.asType then
                              t.clear;
                              ':: '->t.append;
                              theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                                ->makeNonTerminalSymbol->t.append;
                              
                          if)
                      if)
                  if)
              if);
              
          if);
          betaGram.FinalDecl->SetRegionType;
          INNER ;
          
       #);
     Redisplay::< 
       (#
          fd: ^betaGram.FinalDecl;
          anAST,a: ^MPS.AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^mps.unexpanded;
          theAppl: ^mps.nameappl
       do
          (if (theDeclaration).struc <= betaGram.FinalDecl##
           // true then
              theDeclaration->fd[];
              fd->SetRegionType;
              (if not (gppProp.SimpleDeclDisplay = gppProp.AsName) then
                  ':: '->t.append;
                  fd.getObjectSpecification->anAST[];
                  (if anAST.symbol
                   // betaGram.ObjectDescriptor then
                      anAST[]->theObjectDescriptor;
                      (if CheckForAttributes
                       // true then (*gppProp.AbstractedStyle -> theText.style*)
                          ' ...'->t.puttext; 
                      if)
                   // betaGram.NameApl then
                      anAst[]->aName[];
                      aName.getNameAppl->a[];
                      (if a.kind
                       // mps.kinds.unExpanded then
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              ' <<NameAppl>>'->t.append
                           // gppProp.asType then
                              t.clear; ':: <<NameAppl>>'->t.append; 
                          if);
                          
                       else
                      (* is a real name *)
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              a[]->theAppl[]; theAppl.getText->t.append
                           // gppProp.asType then
                              t.clear; ':: '->t.append; a[]->theAppl[]; theAppl.getText->t.append; 
                          if);
                          
                      if)
                   // betaGram.Remote then
                      (if gppProp.SimpleDeclDisplay
                       // gppProp.AsNameAndType then
                          anAST[]->MakeRemote->t.append
                       // gppProp.asType then
                          t.clear; ':: '->t.append; anAST[]->MakeRemote->t.append; 
                      if)
                   else
                      (if anAST.kind = mps.kinds.unExpanded then
                          anAST[]->theUnExpObjSpec[];
                          (if gppProp.SimpleDeclDisplay
                           // gppProp.AsNameAndType then
                              theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                                ->makeNonTerminalSymbol->t.append
                           // gppProp.asType then
                              t.clear;
                              ':: '->t.append;
                              theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                                ->makeNonTerminalSymbol->t.append;
                              
                          if)
                      if)
                  if)
              if);
              
          if);
          betaGram.FinalDecl->SetRegionType;
          INNER ;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[1] then 'Text mode on in FinalNode'->putLine;  if);
               ': '->parseableText.putText;
               INNER
            #);
          ModeOff::< 
            (# t: @Text
            do (if switch[1] then 'Text mode off in FinalNode '->putLine;  if); INNER ; 
            #);
          
       #);
     onInit::<  (#  do UDPrivate.UDFinalNode->UserDataInit; INNER #);
     
  #);
NonTerminalNode: AbstractNode
  (#
     unExp: @ASTReferenceUserData (# Type::< mps.unexpanded #);
     synCatName: @ReferenceUserData (# Type::< Text #);
     synCatNo: @IntegerUserData;
     onSelect::<  (#  do disableEditName #);
     onInit::<  (#  do <<SLOT NonTerminalNodeInit:Descriptor>> #);
     display::< 
       (# 
       enter unexp
       do <<SLOT NonTerminalNodeDisplay:Descriptor>>
       #);
     redisplay::<
       (# 
       enter unexp
       do
          <<SLOT NonTerminalNodeRedisplay:Descriptor>>;
          
       #);
     DesignText::< 
       (#
          ModeOn::< 
            (# 
            do
               (if switch[1] then 'Text mode on NonTerminalNode'->putLine;  if);
               (if not ongoingTextediting then
                   true->wrap;
                   theText.get->theTextBefore;
                   true->ongoingTextediting;
                   THIS(NonTerminalNode).size->(oldWidth,oldHeight);
                   (2*GppProp.width,6*GppProp.height)->THIS(NonTerminalNode).size
               if);
               (* 'Textediting of nonterminal nodes is currently disabled'->gppAlert;
                false->OKtoEnter;*)
               (* THIS(nonterminalNode).size->(oldWidth,oldHeight);
                (oldWidth,oldHeight)->THIS(nonterminalNode).size;
                THIS(nonterminalNode).size->(newWidth,newHeight);*)
               INNER
            #);
          ModeOff::< 
            (# t: @Text
            do
               (if switch[1] then 'Text mode off NonterminalNode'->putLine;  if);
               (if ongoingTextediting then
                   theText.get->t;
                   (if unExp
                    // none then 'unExp is none!! '->putLine
                    else
                       (if not (theTextBefore[]->t.equal) then
                           (THIS(NonTerminalNode)[],unExp,t[])->declarationTextChanged;
                           (if parseErrorOccurred then false->OKToExit if)
                        else
                           (oldWidth,oldHeight)->THIS(NonTerminalNode).size;
                           false->ongoingTextediting;
                           false->parseErrorOccurred
                       if)
                   if);
                   (* (oldWidth,oldHeight)->THIS(nonterminalNode).size;*)
                   INNER
               if);
               false->wrap;
               
            #);
          
       #);
     onDoubleClick::<  (#  do <<SLOT NonTerminalDoubleClick:Descriptor>> #);
     detail::< 
       (#  do 'Detail the nonterminal'->putline #);
     abstract::< 
       (#  do 'Abstract the nonterminal'->putline #);
     GetGroup::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none
           // true then
                (#
                   fd: ^FragmentDiagram;
                   theDummyFragNode: ^PatternDiagramNode
                do
                   (theDiagram).theFragmentNode
                     ->theDummyFragNode[];
                   theDummyFragNode.theDiagram->fd[];
                   fd.theGroup->fg[];
                   
                #);
              
           else
              'DiagramNode: GetGroup: no FragmentNode'
                ->screen.putline
          if);
          
       #);
     GetFragment::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none
           // true then
                (# fn: ^FragmentNode; 
                do
                   (theDiagram).theFragmentNode->fn[];
                   fn.theFragment->f[];
                   
                #);
              
           else
              'DiagramNode: GetFragment: no FragmentNode'
                ->screen.putline
          if);
          
       #);
     theSifEditor::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none then
              (if se[] = none then
                    (# fn: ^FragmentNode; 
                    do
                       (theDiagram).theFragmentNode->fn[];
                       fn.SifEditorInstance[]->se[];
                       
                    #);
                  
               else
                    (# fn: ^FragmentNode; 
                    do (theDiagram).theFragmentNode->fn[]; se[]->fn.SifEditorInstance[]; 
                    #);
                  
              if);
              
           else
              'DiagramNode: theSifEditor: no FragmentNode'->screen.putline
          if);
          
       #);
     dump::<  (#  do <<SLOT NonTerminalNodeDump:Descriptor>>; INNER #);
     
  #);
SlotNode: PatternDiagramNode
  (#
     display::< 
       (# aSlotDesc: ^mps.slotdesc; pos: @Point; 
       enter (pos,aSlotDesc[])
       do <<SLOT SlotNodeDisplay:Descriptor>>; 
       #);
     onDoubleClick::< 
       (# 
       do INNER ; 
       #);
     abstract::< 
       (# 
       do INNER ; 
       #);
     detail::< 
       (# 
       do INNER ; 
       #);
     onInit::< 
       (# 
       do
          UDPrivate.
            UDSlotNode->UserDataInit;
          INNER
       #);
     
  #);
(* Mark nodes: for comments and Dexter anchors *)
(* Mark nodes: for comments and Dexter anchors *)
MyCommentNode: CommentNode (* to display the comment *)
  (#
     theMarkNode: @ReferenceUserData (# Type::< CommentMark #);
     onInit::<  (#  do <<SLOT MyCommentNodeOnInit:Descriptor>> #);
     onRemove::< 
       (#  do <<SLOT CommentNodeOnRemove:Descriptor>> #);
     deactivate::<  (#  do <<SLOT CommentNodeDeactivate:Descriptor>> #);
     
  #);
CommentMark: MarkNode
  (#
     open: @BooleanUserData;
     theComment: @ASTReferenceUserData
       (# Type::< mps.LexemText #);
     theCommentNode: @ReferenceUserData
       (# Type::< MyCommentNode #);
     theConn: @ReferenceUserData
       (# Type::< Connector #);
     display::< 
       (# theCom: ^mps.lexemtext
       enter theComment
       do <<SLOT CommentNodeDisplay:Descriptor>>; 
       #);
     activate::< 
       (# 
       do
          <<SLOT CommentMarkActivate:Descriptor>>
       #);
     deactivate::<  (#  do <<SLOT CommentMarkDeactivate:Descriptor>> #);
     onInit::< 
       (#  do <<SLOT CommentMarkOnInit:Descriptor>> #);
     onRemove::<  (#  do <<SLOT CommentMarkOnRemove:Descriptor>> #);
     onDoubleClick::< 
       (# 
       do <<SLOT CommentMarkDoubleClick:Descriptor>>
       #);
     onSelect::< 
       (# 
       do
          <<SLOT CommentMarkSelect:Descriptor>>
       #);
     
  #);
AnchorMark: MarkNode
  (#
     display::<  (#  do <<SLOT AnchorMarkDisplay:Descriptor>> #);
     onInit::< 
       (#  do <<SLOT AnchorMarkOnInit:Descriptor>> #);
     onDoubleClick::< 
       (# 
       do
          <<SLOT AnchorMarkDoubleClick:Descriptor>>
       #);
     activate::<  (#  do <<SLOT AnchorMarkActivate:Descriptor>> #);
     deactivate::< 
       (#  do <<SLOT AnchorMarkDeactivate:Descriptor>> #);
     
  #);
(* CONNECTORS *)
CommonConnector: DeletableConnector
  (#
     treeNew: (* a try *)
       (# node1,node2: ^Node;  enter (node1[],node2[]) do <<SLOT treeNew:Descriptor>>;  #);
     onInit::<  (#  do 0->Orient; (* no heads *) INNER #)
  #);
PrefixConnector: CommonConnector
(* a straight connector without arrowheads *)
  (#
     pnode1,pnode2: @ReferenceUserData (# Type::< Node #);
     wedge: ^WedgeNode;
     getEnds::<  (#  do pnode1->node1[]; pnode2->node2[] #);
     prefixNew: (#  enter (pnode1,pnode2) do <<SLOT prefixNew:Descriptor>>;  #);
     onInit::< 
       (# 
       do
          UDPrivate.UDPrefixConnector->UserDataInit;
          pnode1.init;
          pnode2.init;
          INNER
       #);
     delete::< 
       (#  do <<SLOT PrefixConnectorDelete:Descriptor>>;  #);
     onDelete::< 
       (# t: ^text
       do
          <<SLOT PrefixConnectorOnDelete:Descriptor>>;
          INNER
       #);
     onReattach::<  (#  do <<SLOT PrefixConnectorOnReattach:Descriptor>>;  #);
     
  #);
SimplePrefixConnector: CommonConnector
  (#
     pnode1,pnode2: @ReferenceUserData
       (# Type::< Node #);
     wedge: ^WedgeNode;
     getEnds::< 
       (#  do pnode1->node1[]; pnode2->node2[] #);
     prefixNew:
       (# 
       enter (pnode1,pnode2)
       <<SLOT SimplePrefixConnectorPrefixNew:DoPart>>
       #);
     onInit::< 
       (# 
       do UDPrivate.UDSimplePrefixConnector->UserDataInit; pnode1.init; pnode2.init; INNER
       #);
     delete::<  (#  <<SLOT SimplePrefixConnectorDelete:DoPart>> #);
     onDelete::< 
       (# 
       <<SLOT SimplePrefixConnectorOnDelete:DoPart>>
       #);
     onReattach::<  (#  <<SLOT SimplePrefixConnectorOnReattach:DoPart>> #)
  #);
TreeConnector: PrefixConnector
(* a straight connector without arrowheads *)
  (# onInit::<  (#  do UDPrivate.UDTreeConnector->UserDataInit; INNER #) #);
ReferenceConnector: CommonConnector
  (#
     onInit::< 
       (# p: [8] @Integer; n1,n2: ^Node; x,y,w,h: @Integer; 
       do
          true->GetEnds->(n1[],n2[]);
          n1.geometry->(x,y,w,h);
          (x-(gppProp.width+1) div 2)-gppProp.RefConnectorLeftFromNode-
          (NoOfRefConnectors*gppProp.RefConnectorOffset)->p[3];
          y->p[4];
          n2.geometry->(x,y,w,h);
          (x-(gppProp.width+1) div 2)-gppProp.RefConnectorLeftFromNode-
          (NoOfRefConnectors*gppProp.RefConnectorOffset)->p[5];
          y->p[6];
          p->Points;
          NoOfRefConnectors+1->NoOfRefConnectors;
          
       #);
     
  #);
  

-- PatternDiagrams: Descriptor --
(#
   oldSelection: ^PatternDiagramNode;
   theList: @DiagramList;
   redisplayRelations:
     (# connectorList: ^ObjectList
     do
        getConnectors->connectorList[];
        (if connectorList[] <> none then
            connectorList.scan
              (#
                 theConn: ^deletableConnector;
                 n1,n2: ^UserDataNode;
                 node1,node2: ^PatternDiagramNode;
                 theAssociationNode: ^AssociationNode;
                 theListDiagram: ^ListDiagram;
                 theSimpleNode: ^theListDiagram.SimpleNode;
                 regionList: ^ObjectList;
                 nd1,nd2: @integerRef;
                 object1,object2: ^designObject;
                 wed: ^WedgeNode
              do
                 (if current.ID <> 0 then
                     (if current## <= deletableConnector## then
                         current[]->theConn[];
                         true->theConn.getEnds->(n1[],n2[]);
                         (if (n1[] <> none ) and (n2[] <> none ) then
                             (if n1## <= AssociationNode## then
                             (* n1.getRegionList->regionList[];
                              (if regionList[] <> none then
                              regionList.scan
                              (# theObject: ^DesignObject
                              do current[]->theObject[]; theObject.unmakeRegion
                              #)
                              if);*) (*n1.delete*)
                                 n1[]->theAssociationNode[];
                                 true->theAssociationNode.redisplayDoDelete
                              else
                                 n1[]->node1[];
                                 n2[]->node2[];
                                 node1.theDiagram->theListDiagram[];
                                 (if current## <= theListDiagram.prefixConnector## then
                                     none ->theListDiagram.titleNode.thePrefixConn;
                                     (if (current.ID,true,nd1[],nd2[])->DSRdAttrGetConnEnds then
                                         nd1->theObjectList.Find->object1[];
                                         (if object1[] <> none then
                                             (if object1## <= wedgeNode## then
                                                 object1[]->wed[]
                                              else
                                                 nd2->theObjectList.Find->object2[];
                                                 (if object2[] <> none then
                                                     (if object2## <= wedgeNode## then
                                                         object2[]->wed[]
                                                     if)
                                                 if)
                                             if)
                                         if)
                                      else
                                         'GetEnds failed connector ID: '->puttext;
                                         current.ID->putint;
                                         newline
                                     if);
                                     (if wed[] <> none then wed.delete if)
                                 if);
                                 (if current## <= theListDiagram.SimplePrefixConnector## then
                                     none ->theListDiagram.titleNode.theSimplePrefixConn;
                                     (if (current.ID,true,nd1[],nd2[])->DSRdAttrGetConnEnds then
                                         nd1->theObjectList.Find->object1[];
                                         (if object1[] <> none then
                                             (if object1## <= wedgeNode## then
                                                 object1[]->wed[]
                                              else
                                                 nd2->theObjectList.Find->object2[];
                                                 (if object2[] <> none then
                                                     (if object2## <= wedgeNode## then
                                                         object2[]->wed[]
                                                     if)
                                                 if)
                                             if)
                                         if)
                                      else
                                         'GetEnds failed connector ID: '->puttext;
                                         current.ID->putint;
                                         newline
                                     if);
                                     (if wed[] <> none then wed.delete if)
                                 if);
                                 (if (current## <= DynamicItemConnector##) or
                                 (current## <= DynamicComponentConnector##) then
                                     (if node1## <= theListDiagram.SimpleNode## then
                                         node1[]->theSimpleNode[];
                                         none ->theSimpleNode.theReferenceConnector
                                      else
                                         (if node2## <= theListDiagram.SimpleNode## then
                                             node2[]->theSimpleNode[];
                                             none ->theSimpleNode.theReferenceConnector
                                         if)
                                     if)
                                 if);
                                 theConn.delete
                             if)
                         if)
                     if)
                 if)
              #)
        if);
        AssociationList.clear;
        InheritanceList.clear;
        DynReferenceList.clear;
        theList.scan
          (#
             thePatternDeclDiagram: ^PatternDeclDiagram;
             theFather: ^MPS.AST;
             parentListDiag,theListDiagram: ^ListDiagram;
             theDiagramNode: ^parentListDiag.DiagramNode
          do
             (if current.e## <= FragmentDiagram##
              // true then 
              else
                 (if current.e## <= PatternDeclDiagram## then
                     current.e[]->thePatternDeclDiagram[];
                     (if (thePatternDeclDiagram.theDescriptor).frag.father->isChecked then
                         thePatternDeclDiagram.theDescriptor->getPrefix
                           ->thePatternDeclDiagram.thePrefix;
                         (if thePatternDeclDiagram.thePrefix <> none then
                             (thePatternDeclDiagram.theDescriptor).father->theFather[];
                             (if theFather## <= betaGram.AttributeDecl## then
                                 (theFather[],(thePatternDeclDiagram.thePrefix).father)
                                   ->InheritanceList.insert
                              else
                             (*could be a singular*)
                                 theFather.father->theFather[];
                                 (if theFather[] <> none then
                                     (if theFather## <= betaGram.AttributeDecl## then
                                         (((thePatternDeclDiagram.theDescriptor).father).father,
                                          (thePatternDeclDiagram.thePrefix).father)
                                           ->InheritanceList.insert
                                     if)
                                 if)
                             if)
                         if)
                      else
                         (if thePatternDeclDiagram.theParentNode <> none then
                             (thePatternDeclDiagram.theParentNode).theDiagram->parentListDiag[];
                             thePatternDeclDiagram.theParentNode->theDiagramNode[];
                             (if theDiagramNode.thePrefix <> none then
                                 theDiagramNode.thePrefix->thePatternDeclDiagram.thePrefix
                             if)
                         if)
                     if)
                 if);
                 current.e[]->theListDiagram[];
                 theListDiagram.localNodes.scan
                   (#
                      thePatternNode: ^theListDiagram.PatternNode;
                      theSimpleNode: ^theListDiagram.SimpleNode;
                      theObjectSpec: ^MPS.AST;
                      na: ^betaGram.nameApl;
                      nd: ^betaGram.nameDcl;
                      rem: ^betaGram.remote
                   do
                      (if current## <= theListDiagram.PatternNode## then
                          current[]->thePatternNode[]; thePatternNode.setupAssociation
                       else
                          (if current## <= theListDiagram.SimpleNode## then
                              current[]->theSimpleNode[];
                              (if theSimpleNode.theReferenceSpec <> none then
                                  (theSimpleNode.theReferenceSpec).getson1->theObjectSpec[];
                                  (if theObjectSpec.symbol
                                   // betaGram.NameApl then
                                      (if theObjectSpec.frag.father->ischecked
                                       // true then
                                          theObjectSpec[]->na[];
                                          (if
                                          ((theSimpleNode.theReferenceSpec).symbol =
                                           betaGram.DynamicItem) or
                                          ((theSimpleNode.theReferenceSpec).symbol =
                                           betaGram.DynamicComponent) then
                                              na.dclRef->nd[];
                                              (nd.father).father->theSimpleNode.theQualification;
                                              (theSimpleNode.theDeclaration,
                                               theSimpleNode.theQualification)
                                                ->DynReferenceList.insert
                                          if)
                                      if);
                                      
                                   // betaGram.remote then
                                      (if theObjectSpec.frag.father->ischecked
                                       // true then
                                          theObjectSpec[]->rem[];
                                          rem.getnameApl->na[];
                                          (if
                                          ((theSimpleNode.theReferenceSpec).symbol =
                                           betaGram.DynamicItem) or
                                          ((theSimpleNode.theReferenceSpec).symbol =
                                           betaGram.DynamicComponent) then
                                              na.dclRef->nd[];
                                              (nd.father).father->theSimpleNode.theQualification;
                                              (theSimpleNode.theDeclaration,
                                               theSimpleNode.theQualification)
                                                ->DynReferenceList.insert
                                          if)
                                      if);
                                      
                                  if)
                              if)
                          if)
                      if)
                   #)
             if)
          #);
        theList.scan
          (# thePatternDeclDiagram: ^PatternDeclDiagram; theListDiagram: ^ListDiagram
          do
             (if current.e## <= FragmentDiagram## then
                 
              else
                 (if current.e## <= PatternDeclDiagram## then
                     current.e[]->thePatternDeclDiagram[]; thePatternDeclDiagram.DisplayInheritance
                 if);
                 current.e[]->theListDiagram[];
                 theListDiagram.localNodes.scan
                   (#
                      thePatternNode: ^theListDiagram.PatternNode;
                      theSimpleAttrDecl: ^theListDiagram.SimpleAttributeDecl
                   do
                      (if current## <= theListDiagram.PatternNode## then
                          current[]->thePatternNode[]; thePatternNode.DisplayAssociations
                       else
                          (if current## <= theListDiagram.SimpleAttributeDecl## then
                              current[]->theSimpleAttrDecl[]; theSimpleAttrDecl.DisplayReference
                          if)
                      if)
                   #)
             if)
          #);
        getConnectors->connectorList[];
        (if connectorList[] <> none then
            connectorList.scan
              (#
                 theConn: ^deletableConnector;
                 theListDiagram: ^ListDiagram;
                 thePatternNode: ^theListDiagram.PatternNode;
                 n1,n2: ^UserDataNode;
                 theAssociationNode: ^AssociationNode;
                 regionList: ^ObjectList
              do
                 (if current.ID <> 0 then
                     (if current## <= deletableConnector## then
                         current[]->theConn[];
                         true->theConn.getEnds->(n1[],n2[]);
                         (if (n1[] <> none ) and (n2[] <> none ) then
                             (if n1## <= AssociationNode## then
                                 n1[]->theAssociationNode[];
                                 (if theAssociationNode.redisplayDoDelete then
                                     (if theAssociationNode.thePatternNode <> none then
                                         (theAssociationNode.thePatternNode).theDiagram
                                           ->theListDiagram[];
                                         theAssociationNode.thePatternNode->thePatternNode[];
                                         none ->thePatternNode.theAssociationNode
                                     if);
                                     n1.delete
                                 if)
                             if)
                         if)
                     if)
                 if)
              #)
        if)
     #);
   writeListTextData:
     (# attributeID,length: @integer; theText: ^text; ok: @boolean
     enter (attributeID,theText[])
     do
        theText.length->length;
        (Id,attributeId,@@ theText.T[1],length)->UDWriteType->ok;
        (if ok then
            (if userDataVerbose then
                'Write List text data succeed: '->puttext; theText[]->putline
            if)
         else
            (if userDataVerbose then 'Write list text data fail'->putline if)
        if)
     #);
   readListTextData:
     (#
        attributeID: @integer;
        theText: ^text;
        textSize: ^integerRef;
        TextData: [32] @char;
        ok: @boolean
     enter attributeID
     do
        &Text[]->theText[];
        &integerRef[]->textSize[];
        (id,attributeId,textSize[])->UDTypeSize->ok;
        (if ok then
            (if userDataVerbose then
                'Read list text data: get User data TypeSize succeed: '->puttext;
                textSize->putint;
                newline
            if);
            (if textSize > TextData.range then textSize+1->TextData.extend if);
            (Id,attributeId,@@ TextData[1])->UDReadType->ok;
            (if ok then
                (if userDataVerbose then 'Read list text data succeed: '->puttext if);
                (for i: textSize repeat TextData[i]->theText.put for);
                (if userDataVerbose then theText[]->putline if)
             else
                (if userDataVerbose then 'Read list text data fail'->putline if)
            if)
         else
            (if userDataVerbose then
                'Read list text data: get User data TypeSize fail!'->putline
            if)
        if)
     exit theText[]
     #);
   writeListIntegerData:
     (# attributeID,theIntData: @integer; ok: @boolean
     enter (attributeID,theIntData)
     do
        (Id,attributeId,@@ theIntData,4)->UDWriteType->ok;
        (if ok then
            (if userDataVerbose then
                'Write list integer data succeed: '->puttext; theIntData->putint; newline
            if)
         else
            (if userDataVerbose then 'Write list integer data fail'->putline if)
        if)
     #);
   readListIntegerData:
     (# attributeID,theIntData: @integer; ok: @boolean
     enter attributeID
     do
        (Id,attributeId,@@ theIntData)->UDReadType->ok;
        (if ok then
            (if userDataVerbose then
                'Read list integer data succeed: '->puttext; theIntData->putint; newline
            if);
            
         else
            (if userDataVerbose then 'Read list integer data fail'->putline if)
        if)
     exit theIntData
     #);
   AssociationList: @containerList
     (#
        element::< Ends;
        Ends:
          (#
             fragOne,fragTwo,associationFrag: ^text;
             endOne,endTwo,endOneType,endTwoType,associationPattern: @integer;
             save:
               (# 
               do
                  1+attributeID->attributeID;
                  (attributeID,fragOne[])->writeListTextData;
                  1+attributeID->attributeID;
                  (attributeID,fragTwo[])->writeListTextData;
                  1+attributeID->attributeID;
                  (if associationFrag[] <> none then
                      (attributeID,associationFrag[])->writeListTextData
                   else
                      (attributeID,' ')->writeListTextData
                  if);
                  1+attributeID->attributeID;
                  (attributeID,endOne)->writeListIntegerData;
                  1+attributeID->attributeID;
                  (attributeID,endTwo)->writeListIntegerData;
                  1+attributeID->attributeID;
                  (attributeID,endOneType)->writeListIntegerData;
                  1+attributeID->attributeID;
                  (attributeID,endTwoType)->writeListIntegerData;
                  1+attributeID->attributeID;
                  (attributeID,associationPattern)->writeListIntegerData
               #)
          #);
        insert:
          (# e1,e2,a: ^betaGram.AttributeDecl; e1Type,e2Type: @integer; theElm: ^Ends
          enter (e1[],e1Type,e2[],e2Type,a[])
          do
             &Ends[]->theElm[];
             e1.frag.fullname->theElm.fragOne[];
             e1.index->theElm.endOne;
             e1Type->theElm.endOneType;
             e2.frag.fullname->theElm.fragTwo[];
             e2.index->theElm.endTwo;
             e2Type->theElm.endTwoType;
             (if a[] <> none then
                 a.frag.fullname->theElm.associationFrag[]; a.index->theElm.associationPattern
             if);
             theElm[]->append
          #);
        updateAssociationPattern:
          (# ASTOne,ASTTwo,a: ^betaGram.AttributeDecl
          enter (ASTOne[],ASTTwo[],a[])
          do
             scan
               (# 
               do
                  (if
                  ((current.endOne = ASTOne.index) and (ASTOne.frag.fullname->current.fragOne.equal)
                   and (current.endTwo = ASTTwo.index) and
                   (ASTTwo.frag.fullname->current.fragTwo.equal)) or
                  ((current.endOne = ASTTwo.index) and (ASTTwo.frag.fullname->current.fragOne.equal)
                   and (current.endTwo = ASTOne.index) and
                   (ASTOne.frag.fullname->current.fragTwo.equal)) then
                      a.frag.fullname->current.associationFrag[];
                      a.index->current.associationPattern
                  if)
               #)
          #);
        remove:
          (# ASTOne,ASTTwo: ^MPS.AST
          enter (ASTOne[],ASTTwo[])
          do
             scan
               (# 
               do
                  (if
                  ((current.endOne = ASTOne.index) and (ASTOne.frag.fullname->current.fragOne.equal)
                   and (current.endTwo = ASTTwo.index) and
                   (ASTTwo.frag.fullname->current.fragTwo.equal)) or
                  ((current.endOne = ASTTwo.index) and (ASTTwo.frag.fullname->current.fragOne.equal)
                   and (current.endTwo = ASTOne.index) and
                   (ASTOne.frag.fullname->current.fragTwo.equal)) then
                      current[]->at->delete
                  if)
               #)
          #);
        update:
          (# anAST: ^MPS.AST; anExp: ^mps.expanded
          enter anAST[]
          do
             (if anAST.kind = mps.kinds.interior then
                 (if (anAST.symbol = betaGram.PatternDecl) or (anAST.symbol = betaGram.VirtualDecl)
                 or (anAST.symbol = betaGram.BindingDecl) or (anAST.symbol = betaGram.FinalDecl)
                  then
                     scan
                       (# 
                       do
                          (if (current.endOne = anAST.index) and
                          (anAST.frag.fullname->current.fragOne.equal) then
                              current[]->at->delete
                           else
                              (if (current.endTwo = anAST.index) and
                              (anAST.frag.fullname->current.fragTwo.equal) then
                                  current[]->at->delete
                               else
                                  (if (current.associationPattern = anAST.index) and
                                  (anAST.frag.fullname->current.associationFrag.equal) then
                                      current[]->at->delete
                                  if)
                              if)
                          if)
                       #)
                 if);
                 anAST[]->anExp[];
                 anExp.scan
                   (#  do current[]->update #)
             if)
          #);
        attributeID: @integer;
        UDStart: (#  exit 14999 #);
        save:
          (# noOfAttr: @integer; ok: @boolean
          do
             resetSaved;
             size*8->noOfAttr;
             (ID,UDStart,@@ noOfAttr,4)->UDWriteType->ok;
             (if ok then
                 (if userDataVerbose then
                     'Write AssociationList size succeed: '->puttext; noOfAttr->putint; newline
                 if);
                 UDStart->attributeID;
                 scan
                   (#  do current.save #)
              else
                 (if userDataVerbose then 'Write AssociationList size fail'->putLine if)
             if)
          #);
        resetSaved:
          (# noOfAttr: @integer; ok: @boolean
          do
             (ID,UDStart,@@ noOfAttr)->UDReadType->ok;
             (if ok then
                 (if userDataVerbose then
                     'Read AssociationList size succeed: '->puttext; noOfAttr->putint; newline
                 if);
                 (for i: noOfAttr repeat
                   (ID,UDStart+i)->UDDeleteType->ok;
                   (if ok then
                       (if userDataVerbose then
                           'For attributeID '->puttext;
                           UDStart+i->putint;
                           ' delete AssociationList userdata succeed'->putline
                       if)
                    else
                       (if userDataVerbose then
                           'For attributeID '->puttext;
                           UDStart+i->putint;
                           ' delete AssociationList userdata fail'->putline
                       if)
                   if)
                 for)
              else
                 (if userDataVerbose then 'Read AssociationList size fail'->putLine if)
             if)
          #);
        load:
          (# noOfAttr: @integer; i: @integer; ok: @boolean; theElm: ^element
          do
             (ID,UDStart,@@ noOfAttr)->UDReadType->ok;
             (if ok then
                 (if userDataVerbose then
                     'Read AssociationList size succeed: '->puttext; noOfAttr->putint; newline
                 if);
                 UDStart->i;
                 loop:
                 (if i < UDStart+noOfAttr then
                     &element[]->theElm[];
                     i+1->i->ReadListTextData->theElm.fragOne[];
                     i+1->i->ReadListTextData->theElm.fragTwo[];
                     i+1->i->ReadListTextData->theElm.associationFrag[];
                     i+1->i->ReadListIntegerData->theElm.endOne;
                     i+1->i->ReadListIntegerData->theElm.endTwo;
                     i+1->i->ReadListIntegerData->theElm.endOneType;
                     i+1->i->ReadListIntegerData->theElm.endTwoType;
                     i+1->i->ReadListIntegerData->theElm.associationPattern;
                     theElm[]->append;
                     restart loop
                 if)
              else
                 (if userDataVerbose then 'Read AssociationList size fail'->putLine if)
             if)
          #);
        dump:
          (# 
          do
             newline;
             'AssociationList: '->putline;
             scan
               (# 
               do
                  'fragOne: '->puttext;
                  current.fragOne[]->putline;
                  'endOne: '->puttext;
                  current.endOne->putint;
                  newline;
                  'fragTwo: '->puttext;
                  current.fragTwo[]->putline;
                  'endTwo: '->puttext;
                  current.endTwo->putint;
                  newline;
                  'associationFrag: '->puttext;
                  current.associationFrag[]->putline;
                  'associtionPattern: '->puttext;
                  current.associationPattern->putint;
                  newline
               #)
          #)
     #);
   InheritanceList: @containerList
     (#
        element::< Ends;
        Ends:
          (#
             subFrag,superFrag: ^text;
             sub,super: @integer;
             save:
               (# 
               do
                  1+attributeID->attributeID;
                  (attributeID,subFrag[])->writeListTextData;
                  1+attributeID->attributeID;
                  (attributeID,superFrag[])->writeListTextData;
                  1+attributeID->attributeID;
                  (attributeID,sub)->writeListIntegerData;
                  1+attributeID->attributeID;
                  (attributeID,super)->writeListIntegerData
               #)
          #);
        insert:
          (# subpattern,superpattern: ^betaGram.AttributeDecl; theElm: ^Ends
          enter (subpattern[],superpattern[])
          do
             &Ends[]->theElm[];
             subpattern.frag.fullname->theElm.subFrag[];
             subpattern.index->theElm.sub;
             superpattern.frag.fullname->theElm.superFrag[];
             superpattern.index->theElm.super;
             theElm[]->append
          #);
        remove:
          (# anAST: ^MPS.AST
          enter anAST[]
          do
             (if anAST.kind = mps.kinds.interior then
                 (if anAST## <= betaGram.AttributeDecl## then
                     scan
                       (# 
                       do
                          (if (current.sub = anAST.index) and
                          (anAST.frag.fullname->current.subFrag.equal) then
                              current[]->at->delete
                          if)
                       #)
                 if)
             if)
          #);
        update:
          (#
             anAST: ^MPS.AST;
             doUpdate:
               (# anAST: ^mps.ast; anExp: ^mps.expanded
               enter anAST[]
               do
                  (if anAST.kind = mps.kinds.interior then
                      (if anAST## <= betaGram.AttributeDecl## then
                          scan
                            (# 
                            do
                               (if (current.sub = anAST.index) and
                               (anAST.frag.fullname->current.subFrag.equal) then
                                   current[]->at->delete
                                else
                                   (if (current.super = anAST.index) and
                                   (anAST.frag.fullname->current.superFrag.equal) then
                                       current[]->at->delete
                                   if)
                               if)
                            #)
                      if);
                      anAST[]->anExp[];
                      anExp.scan
                        (#  do current[]->doUpdate #)
                  if)
               #)
          enter anAST[]
          do
             (if anAST.symbol
              // betaGram.ObjectDescriptor then
                 (if anAST.father <> none then anAST.father->anAST[] if)
              // betaGram.prefix then
                 (if anAST.father <> none then
                     (if (anAST.father).father <> none then (anAST.father).father->anAST[] if)
                 if)
             if);
             anAST[]->doUpdate;
             
          #);
        attributeID: @integer;
        UDStart: (#  exit 15999 #);
        save:
          (# noOfAttr: @integer; ok: @boolean
          do
             resetSaved;
             size*4->noOfAttr;
             (ID,UDStart,@@ noOfAttr,4)->UDWriteType->ok;
             (if ok then
                 (if userDataVerbose then
                     'Write InheritanceList size succeed: '->puttext; noOfAttr->putint; newline
                 if);
                 UDStart->attributeID;
                 scan
                   (#  do current.save #)
              else
                 (if userDataVerbose then 'Write InheritanceList size fail'->putLine if)
             if)
          #);
        resetSaved:
          (# noOfAttr: @integer; ok: @boolean
          do
             (ID,UDStart,@@ noOfAttr)->UDReadType->ok;
             (if ok then
                 (if userDataVerbose then
                     'Read InheritanceList size succeed: '->puttext; noOfAttr->putint; newline
                 if);
                 (for i: noOfAttr repeat
                   (ID,UDStart+i)->UDDeleteType->ok;
                   (if ok then
                       (if userDataVerbose then
                           'For attributeID '->puttext;
                           UDStart+i->putint;
                           ' delete InheritanceList userdata succeed'->putline
                       if)
                    else
                       (if userDataVerbose then
                           'For attributeID '->puttext;
                           UDStart+i->putint;
                           ' delete InheritanceList userdata fail'->putline
                       if)
                   if)
                 for)
              else
                 (if userDataVerbose then 'Read InheritanceList size fail'->putLine if)
             if)
          #);
        load:
          (# noOfAttr: @integer; i: @integer; ok: @boolean; theElm: ^element
          do
             (ID,UDStart,@@ noOfAttr)->UDReadType->ok;
             (if ok then
                 (if userDataVerbose then
                     'Read InheritanceList size succeed: '->puttext; noOfAttr->putint; newline
                 if);
                 UDStart->i;
                 loop:
                 (if i < UDStart+noOfAttr then
                     &element[]->theElm[];
                     i+1->i->ReadListTextData->theElm.subFrag[];
                     i+1->i->ReadListTextData->theElm.superFrag[];
                     i+1->i->ReadListIntegerData->theElm.sub;
                     i+1->i->ReadListIntegerData->theElm.super;
                     theElm[]->append;
                     restart loop
                 if)
              else
                 (if userDataVerbose then 'Read InheritanceList size fail'->putLine if)
             if)
          #);
        dump:
          (# 
          do
             newline;
             'InheritanceList: '->putline;
             scan
               (# 
               do
                  'subFrag: '->puttext;
                  current.subFrag[]->putline;
                  'sub: '->puttext;
                  current.sub->putint;
                  newline;
                  'superFrag: '->puttext;
                  current.superFrag[]->putline;
                  'super: '->puttext;
                  current.super->putint;
                  newline
               #)
          #)
     #);
   DynReferenceList: @containerList
     (#
        element::< Ends;
        Ends:
          (#
             refFrag,qualFrag: ^text;
             ref,qual: @integer;
             save:
               (# 
               do
                  1+attributeID->attributeID;
                  (attributeID,refFrag[])->writeListTextData;
                  1+attributeID->attributeID;
                  (attributeID,qualFrag[])->writeListTextData;
                  1+attributeID->attributeID;
                  (attributeID,ref)->writeListIntegerData;
                  1+attributeID->attributeID;
                  (attributeID,qual)->writeListIntegerData
               #)
          #);
        insert:
          (# reference,qualification: ^betaGram.AttributeDecl; theElm: ^Ends
          enter (reference[],qualification[])
          do
             &Ends[]->theElm[];
             reference.frag.fullname->theElm.refFrag[];
             reference.index->theElm.ref;
             qualification.frag.fullname->theElm.qualFrag[];
             qualification.index->theElm.qual;
             theElm[]->append
          #);
        remove:
          (# anAST: ^MPS.AST
          enter anAST[]
          do
             (if anAST.kind = mps.kinds.interior then
                 (if anAST## <= betaGram.AttributeDecl## then
                     scan
                       (# 
                       do
                          (if (current.ref = anAST.index) and
                          (anAST.frag.fullname->current.refFrag.equal) then
                              current[]->at->delete
                          if)
                       #)
                 if)
             if)
          #);
        update:
          (#
             anAST: ^MPS.AST;
             doUpdate:
               (# anAST: ^mps.ast; anExp: ^mps.expanded
               enter anAST[]
               do
                  (if anAST.kind = mps.kinds.interior then
                      (if anAST## <= betaGram.AttributeDecl## then
                          scan
                            (# 
                            do
                               (if (current.ref = anAST.index) and
                               (anAST.frag.fullname->current.refFrag.equal) then
                                   current[]->at->delete
                                else
                                   (if (current.qual = anAST.index) and
                                   (anAST.frag.fullname->current.qualFrag.equal) then
                                       current[]->at->delete
                                   if)
                               if)
                            #)
                      if);
                      anAST[]->anExp[];
                      anExp.scan
                        (#  do current[]->doUpdate #)
                  if)
               #)
          enter anAST[]
          do
             (if anAST.symbol
              // betaGram.DynamicItem then
                 (if anAST.father <> none then anAST.father->anAST[] if)
              // betaGram.NameApl then
                 (if anAST.father <> none then
                     (if (anAST.father).father <> none then (anAST.father).father->anAST[] if)
                 if)
             if);
             anAST[]->doUpdate;
             
          #);
        attributeID: @integer;
        UDStart: (#  exit 16999 #);
        save:
          (# noOfAttr: @integer; ok: @boolean
          do
             resetSaved;
             size*4->noOfAttr;
             (ID,UDStart,@@ noOfAttr,4)->UDWriteType->ok;
             (if ok then
                 (if userDataVerbose then
                     'Write DynReferenceList size succeed: '->puttext; noOfAttr->putint; newline
                 if);
                 UDStart->attributeID;
                 scan
                   (#  do current.save #)
              else
                 (if userDataVerbose then 'Write DynReferenceList size fail'->putLine if)
             if)
          #);
        resetSaved:
          (# noOfAttr: @integer; ok: @boolean
          do
             (ID,UDStart,@@ noOfAttr)->UDReadType->ok;
             (if ok then
                 (if userDataVerbose then
                     'Read DynReferenceList size succeed: '->puttext; noOfAttr->putint; newline
                 if);
                 (for i: noOfAttr repeat
                   (ID,UDStart+i)->UDDeleteType->ok;
                   (if ok then
                       (if userDataVerbose then
                           'For attributeID '->puttext;
                           UDStart+i->putint;
                           ' delete DynReferenceList userdata succeed'->putline
                       if)
                    else
                       (if userDataVerbose then
                           'For attributeID '->puttext;
                           UDStart+i->putint;
                           ' delete DynReferenceList userdata fail'->putline
                       if)
                   if)
                 for)
              else
                 (if userDataVerbose then 'Read DynReferenceList size fail'->putLine if)
             if)
          #);
        load:
          (# noOfAttr: @integer; i: @integer; ok: @boolean; theElm: ^element
          do
             (ID,UDStart,@@ noOfAttr)->UDReadType->ok;
             (if ok then
                 (if userDataVerbose then
                     'Read DynReferenceList size succeed: '->puttext; noOfAttr->putint; newline
                 if);
                 UDStart->i;
                 loop:
                 (if i < UDStart+noOfAttr then
                     &element[]->theElm[];
                     i+1->i->ReadListTextData->theElm.refFrag[];
                     i+1->i->ReadListTextData->theElm.qualFrag[];
                     i+1->i->ReadListIntegerData->theElm.ref;
                     i+1->i->ReadListIntegerData->theElm.qual;
                     theElm[]->append;
                     restart loop
                 if)
              else
                 (if userDataVerbose then 'Read DynReferenceList size fail'->putLine if)
             if)
          #);
        dump:
          (# 
          do
             newline;
             'DynReferenceList: '->putline;
             scan
               (# 
               do
                  'refFrag: '->puttext;
                  current.refFrag[]->putline;
                  'ref: '->puttext;
                  current.ref->putint;
                  newline;
                  'qualFrag: '->puttext;
                  current.qualFrag[]->putline;
                  'qual: '->puttext;
                  current.qual->putint;
                  newline
               #)
          #)
     #);
   NextFreeLine: @Integer;
   (* indicates where the next PatternDiagram can
    be placed to avoid obscuring another diagrams *)
   NextFreeColumn: @Integer;
   SecondFreeLine: @Integer;
   (* Indicates where to put the next diagram when
    * we ran into the bottom of the page *)
   SecondFreeColumn: @Integer;
   Detailer: ^PatternDiagramNode;
   (* if not NONE then we are currently
    * creating a subdiagram by detailing
    * another node
    *)
   addAfterNode: ^PatternDiagramNode;
   newNode: ^PatternDiagramNode;
   (* add newnode to list after addAfterNode when done *)
   
#)  

-- OADPageMakeDesignObject: Descriptor --
(#
   theDiag: ^Diagram;
   NodeType: @Integer;
   theSimplePropertyDiagram: ^SimplePropertyDiagram;
   theNodeID: @integer
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDFragmentDiagram then
       &FragmentDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then 'MakeDesignObject: Created FragmentDiagram!'->putline if)
    // UDPrivate.UDPatternAttDiagram then
       &PatternAttDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then 'MakeDesignObject: Created PatternAttDiagram!'->putline if)
    // UDPrivate.UDPatternDeclDiagram then
       &PatternDeclDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then 'MakeDesignObject: Created PatternDeclDiagram!'->putline if)
    // UDPrivate.UDPatternClassificationDiagram then
       &PatternClassificationDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternClassificationDiagram!'->putline
       if)
    // UDPrivate.UDPatternNonTerminalDiagram then
       &PatternNonTerminalDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternNonTerminalDiagram!'->putline
       if)
    // UDPrivate.UDSimplePropertyDiagram then
       &SimplePropertyDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then 'MakeDesignObject: Created SimplePropertyDiagram!'->putline if);
       theDiag[]->theSimplePropertyDiagram[];
       theSimplePropertyDiagram.titleNode.UDSurroundBox.getID->theNodeID;
       (if theNodeID <> 0 then (theSimplePropertyDiagram[],theNodeID)->makeSurroundBox if)
    // UDPrivate.UDPropertyDiagram then
       &PropertyDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then 'MakeDesignObject: Created PropertyDiagram!'->putline if)
   if)
#)  

-- MakeLocalNodes: Descriptor --
(#
   rangeStart: @integer;
   rangeEnd: @integer;
   rangeH: ^integerRef;
   count: @integer;
   ok: @boolean;
   localNodeID: @integer;
   NodeType: @integer;
   thePatternDiagNode: ^PatternDiagramNode;
   theSimpleNode: ^theListDiagram.SimpleNode;
   thePatternNode: ^theListDiagram.PatternNode;
   theObject: ^DesignObject;
   theNode: ^Node;
   thePropertyDiagram: ^SimplePropertyDiagram;
   regions: [0] @Integer;
   count2: @ShortRef;
   list: @IntegerRef;
   titleID,theNodeID,theConnID: @integer
do
   LocalNodesUserDataStart->rangeStart;
   LocalNodesUserDataEnd->rangeEnd;
   theListDiagram.titleNode.ID->titleID;
   (* &integerRef[]->rangeH[];
    &shortRef[]->count[];
    (titleID,rangeStart,rangeEnd,count[],rangeH[])->UDFindRange->ok;*)
   theListDiagram.titleNode.oldLocalNodesUDAttributes-LocalNodesUserDataStart->count;
   true->ok;
   (if userDataVerbose then 'MakeLocalNodes - count: '->puttext; count->putint; newline;  if);
   (if ok then
       &theListDiagram.LocalNodesDesc[]->theListDiagram.localNodes[];
       (for i: count repeat
         (if userDataVerbose then
             'For titleID: '->puttext;
             titleID->putint;
             ' and attributesID: '->puttext;
             LocalNodesUserDataStart+i->putint;
             ' localNodeID was: '->puttext;
             
         if);
         (titleID,LocalNodesUserDataStart+i,@@ localNodeID)->UDReadType->ok;
         (if ok then
             (if userDataVerbose then localNodeID->putint; newline;  if);
             localNodeID->getNodeType->NodeType;
             (if NodeType = UDPrivate.UDPatternDiagramNode then
                 &PatternDiagramNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created PatternDiagramNode!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDAbstractNode then
                 &theListDiagram.AbstractNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then 'MakeLocalNodes: Created AbstractNode!'->putline if)
             if);
             (if NodeType = UDPrivate.UDSlotNode then
                 &theListDiagram.SlotNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then 'MakeLocalNodes: Created SlotNode!'->putline if)
             if);
             (if NodeType = UDPrivate.UDPropertyNode then
                 theListDiagram[]->thePropertyDiagram[];
                 &thePropertyDiagram.PropertyNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then 'MakeDesignObject: Created PropertyNode!'->putline if)
             if);
             (if NodeType = UDPrivate.UDFragmentNode then
                 &theListDiagram.FragmentNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then 'MakeLocalNodes: Created FragmentNode!'->putline if)
             if);
             (if NodeType = UDPrivate.UDDiagramNode then
                 &theListDiagram.DiagramNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then 'MakeLocalNodes: Created DiagramNode!'->putline if)
             if);
             (if NodeType = UDPrivate.UDNonTerminalNode then
                 &theListDiagram.NonTerminalNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then 'MakeLocalNodes: Created NonTerminalNode!'->putline if)
             if);
             (if NodeType = UDPrivate.UDDoPartNode then
                 &theListDiagram.DoPartNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then 'MakeLocalNodes: Created DoPartNode!'->putline if)
             if);
             (if NodeType = UDPrivate.UDAttributesNode then
                 &theListDiagram.AttributesNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then 'MakeLocalNodes: Created AttributesNode!'->putline if)
             if);
             (if NodeType = UDPrivate.UDDescriptorNode then
                 &theListDiagram.DescriptorNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then 'MakeLocalNodes: Created DescriptorNode!'->putline if)
             if);
             (if NodeType = UDPrivate.UDSimpleAttributeDecl then
                 &theListDiagram.SimpleAttributeDecl[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created SimpleAttributeDecl!'->putline
                 if)
             if);
             (if NodeType = UDPrivate.UDPatternNode then
                 &theListDiagram.PatternNode[]->thePatternDiagNode[]->thePatternNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then 'MakeLocalNodes: Created PatternNode!'->putline if)
             if);
             (if NodeType = UDPrivate.UDSimpleNode then
                 &theListDiagram.SimpleNode[]->thePatternDiagNode[]->theSimpleNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then 'MakeLocalNodes: Created SimpleNode!'->putline if)
             if);
             (if NodeType = UDPrivate.UDRepetitionNode then
                 &theListDiagram.RepetitionNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then 'MakeLocalNodes: Created RepetitionNode!'->putline if)
             if);
             (if NodeType = UDPrivate.UDVirtualNode then
                 &theListDiagram.VirtualNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then 'MakeLocalNodes: Created VirtualNode!'->putline if)
             if);
             (if NodeType = UDPrivate.UDBindingNode then
                 &theListDiagram.BindingNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then 'MakeLocalNodes: BindingNode!'->putline if)
             if);
             (if NodeType = UDPrivate.UDFinalNode then
                 &theListDiagram.FinalNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then 'MakeLocalNodes: FinalNode!'->putline if)
             if);
             (if NodeType = UDPrivate.UDActivePropertyNode then
                 (if theListDiagram## <= SimplePropertyDiagram## then
                     theListDiagram[]->thePropertyDiagram[];
                     &thePropertyDiagram.ActivePropertyNode[]->thePatternDiagNode[]->theObject[];
                     true->thePatternDiagNode.initialisingSaved;
                     (if userDataVerbose then
                         'MakeDesignObject: Created ActivePropertyNode!'->putline
                     if)
                 if)
             if);
             (if NodeType = UDPrivate.UDPassivePropertyNode then
                 (if theListDiagram## <= SimplePropertyDiagram## then
                     theListDiagram[]->thePropertyDiagram[];
                     &thePropertyDiagram.PassivePropertyNode[]->thePatternDiagNode[]->theObject[];
                     true->thePatternDiagNode.initialisingSaved;
                     (if userDataVerbose then
                         'MakeDesignObject: Created PassivePropertyNode!'->putline
                     if)
                 if)
             if);
             (if NodeType = UDPrivate.UDOriginPropertyNode then
                 (if theListDiagram## <= SimplePropertyDiagram## then
                     theListDiagram[]->thePropertyDiagram[];
                     &thePropertyDiagram.OriginPropertyNode[]->thePatternDiagNode[]->theObject[];
                     true->thePatternDiagNode.initialisingSaved;
                     (if userDataVerbose then
                         'MakeDesignObject: Created OriginPropertyNode!'->putline
                     if)
                 if)
             if);
             (if NodeType = UDPrivate.UDIncludePropertyNode then
                 (if theListDiagram## <= SimplePropertyDiagram## then
                     theListDiagram[]->thePropertyDiagram[];
                     &thePropertyDiagram.IncludePropertyNode[]->thePatternDiagNode[]->theObject[];
                     true->thePatternDiagNode.initialisingSaved;
                     (if userDataVerbose then
                         'MakeDesignObject: Created IncludePropertyNode!'->putline
                     if)
                 if)
             if);
             (if NodeType = UDPrivate.UDBodyPropertyNode then
                 (if theListDiagram## <= SimplePropertyDiagram## then
                     theListDiagram[]->thePropertyDiagram[];
                     &thePropertyDiagram.BodyPropertyNode[]->thePatternDiagNode[]->theObject[];
                     true->thePatternDiagNode.initialisingSaved;
                     (if userDataVerbose then
                         'MakeDesignObject: Created BodyPropertyNode!'->putline
                     if)
                 if)
             if);
             (if theObject[] <> none then
                 theObject[]->theListDiagram.LocalNodes.append;
                 localNodeID->theObject.onInit;
                 (if localNodeID->DSRdAttrGetObjectType
                  // RegionType then theObject.onInitRegion; 
                 if);
                 (if (localNodeID,count2[],list[])->DSStrGetObjectRegionList
                  // true then
                     (if count2 > 0
                      // true then
                         (count2,list)->GetIntList->regions;
                         (if verbose
                          // true then 'NoOfRegions: '->puttext; regions.range->putint; newline; 
                         if);
                         regions->MakeObjectsFromList;
                         
                     if)
                 if);
                 (if theObject## <= node## then
                     theObject[]->theNode[]; false->theNode.moveable; false->theNode.sizeable
                 if);
                 (if thePatternDiagNode[] <> none then
                     thePatternDiagNode.theMarkNode.getID
                       ->theNodeID
                       (*theMarkNode currently refers to EllipseNode.
                        getID works around qua error.*) ;
                     (if theNodeID <> 0 then (theListDiagram[],theNodeID)->MakeMarkNode if)
                 if);
                 (if theSimpleNode[] <> none then
                     theSimpleNode.theReferenceConnector.getID->theConnID;
                     (if theConnID <> 0 then (theListDiagram[],theConnID)->MakeConn if)
                 if);
                 (if thePatternNode[] <> none then
                     thePatternNode.theAssociationNode.getID->theNodeID;
                     (if theNodeID <> 0 then theNodeID->makeAssociationNode if)
                 if)
             if)
          else
             
         if)
       for)
    else
       (if userDataVerbose then
           'ID: '->puttext;
           theListDiagram.titleNode.ID->putint;
           ' User data FindRange fail'->putline
       if)
   if);
   
#)  

-- MakeMarkNode: Descriptor --
(#
   NodeType,theNodeId,theConnID: @integer;
   theObject: ^DesignObject;
   theCommentMark: ^theListDiagram.CommentMark;
   regions: [0] @Integer;
   count2: @ShortRef;
   list: @IntegerRef
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDCommentMark then
       &theListDiagram.CommentMark[]->theCommentMark[]->theObject[];
       true->theCommentMark.initialisingSaved;
       (if userDataVerbose then 'MakeMarkNode: Created CommentMark!'->putline if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       (if ID->DSRdAttrGetObjectType // RegionType then theObject.onInitRegion;  if);
       (if (ID,count2[],list[])->DSStrGetObjectRegionList
        // true then
           (if count2 > 0
            // true then
               (count2,list)->GetIntList->regions;
               (if verbose
                // true then 'NoOfRegions: '->puttext; regions.range->putint; newline; 
               if);
               regions->MakeObjectsFromList;
               
           if)
       if);
       theCommentMark.theCommentNode.getID
         ->theNodeID
         (*theCommentNode currently refers to RectNode.
          getId works around qua error*) ;
       (if theNodeID <> 0 then (theListDiagram[],theNodeID)->MakeCommentNode if);
       theCommentMark.theConn.getID->theConnID;
       (if theConnID <> 0 then (theListDiagram[],theConnID)->MakeConn if)
   if)
#)  

-- MakeCommentNode: Descriptor --
(#
   NodeType: @integer;
   theObject: ^DesignObject;
   theCommentNode: ^theListDiagram.MyCommentNode;
   regions: [0] @Integer;
   count2: @ShortRef;
   list: @IntegerRef
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDMyCommentNode then
       &theListDiagram.MyCommentNode[]->theCommentNode[]->theObject[];
       true->theCommentNode.initialisingSaved;
       (if userDataVerbose then 'MakeCommentNode: Created MyCommentNode!'->putline if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       (if ID->DSRdAttrGetObjectType // RegionType then theObject.onInitRegion;  if);
       (if (ID,count2[],list[])->DSStrGetObjectRegionList
        // true then
           (if count2 > 0
            // true then
               (count2,list)->GetIntList->regions;
               (if verbose
                // true then 'NoOfRegions: '->puttext; regions.range->putint; newline; 
               if);
               regions->MakeObjectsFromList;
               
           if)
       if)
   if)
#)  

-- MakeAssociationNode: Descriptor --
(#
   NodeType: @integer;
   theObject: ^DesignObject;
   theAssociationNode: ^AssociationNode;
   theConnID: @integer;
   regions: [0] @Integer;
   count2: @ShortRef;
   list: @IntegerRef;
   
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDAssociationNode then
       &AssociationNode[]->theAssociationNode[]->theObject[];
       (if userDataVerbose then 'MakeAssociationNode: Created AssociationNode!'->putline if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       (if ID->DSRdAttrGetObjectType // RegionType then theObject.onInitRegion;  if);
       (if (ID,count2[],list[])->DSStrGetObjectRegionList
        // true then
           (if count2 > 0
            // true then
               (count2,list)->GetIntList->regions;
               (if verbose
                // true then 'NoOfRegions: '->puttext; regions.range->putint; newline; 
               if);
               regions->MakeObjectsFromList;
               
           if)
       if);
       theAssociationNode.c1.getID->theConnID;
       (if theConnID <> 0 then (theAssociationNode[],theConnID)->MakeAssociationConn if);
       theAssociationNode.c2.getID->theConnID;
       (if theConnID <> 0 then (theAssociationNode[],theConnID)->MakeAssociationConn if)
   if)
#)  

-- MakeAssociationConn: Descriptor --
(#
   NodeType,theNodeID: @integer;
   theObject: ^DesignObject;
   theAssociationConnector: ^theAssociationNode.AssociationConnector;
   regions: [0] @Integer;
   count2: @ShortRef;
   list: @IntegerRef
do
   ID->getNodeType->NodeType;
   (if NodeType = UDPrivate.UDAssociationConnector then
       &theAssociationNode.AssociationConnector[]->theAssociationConnector[]->theObject[];
       (if userDataVerbose then 'MakeConn: Created AssociationConnector!'->putline if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       (if ID->DSRdAttrGetObjectType // RegionType then theObject.onInitRegion;  if);
       (if (ID,count2[],list[])->DSStrGetObjectRegionList
        // true then
           (if count2 > 0
            // true then
               (count2,list)->GetIntList->regions;
               (if verbose
                // true then 'NoOfRegions: '->puttext; regions.range->putint; newline; 
               if);
               regions->MakeObjectsFromList;
               
           if)
       if);
       theAssociationConnector.theText.theLabel.getID->theNodeID;
       (if theNodeID <> 0 then (theAssociationConnector[],theNodeID)->MakeUserDataLabelNode if)
   if)
#)  

-- MakeUserDataLabelNode: DoPart --
do
     (#
        NodeType: @integer;
        theObject: ^DesignObject;
        regions: [0] @Integer;
        count2: @ShortRef;
        list: @IntegerRef
     do
        ID->getNodeType->NodeType;
        (if NodeType = UDPrivate.UDLabelNode then
            &theAssociationConn.theText.UserDataLabelNode[]->theObject[];
            (if theObject[] <> none then
                ID->theObject.onInit;
                (if true (*userdataVerbose*) then
                    'MakeUserDataLabelNode: Created UserDataLabelNode!'->putline
                if);
                (if ID->DSRdAttrGetObjectType // RegionType then theObject.onInitRegion;  if);
                (if (ID,count2[],list[])->DSStrGetObjectRegionList
                 // true then
                    (if count2 > 0
                     // true then
                        (count2,list)->GetIntList->regions;
                        (if verbose
                         // true then 'NoOfRegions: '->puttext; regions.range->putint; newline; 
                        if);
                        regions->MakeObjectsFromList;
                        
                    if)
                if)
            if)
        if)
     #)  

-- MakeConn: Descriptor --
(#
   NodeType: @integer;
   theObject: ^DesignObject;
   regions: [0] @Integer;
   count2: @ShortRef;
   list: @IntegerRef;
   theConnector: ^theListDiagram.commonConnector;
   theDeletableConn: ^DeletableConnector
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDPrefixConnector then
       &theListDiagram.PrefixConnector[]->theConnector[]->theObject[];
       true->theConnector.initialisingSaved;
       (if userDataVerbose then 'MakeConn: Created PrefixConnector!'->putline if)
    // UDPrivate.UDSimplePrefixConnector then
       &theListDiagram.SimplePrefixConnector[]->theConnector[]->theObject[];
       true->theConnector.initialisingSaved;
       (if userDataVerbose then 'MakeConn: Created PrefixConnector!'->putline if)
    // UDPrivate.UDDynamicItemConnector then
       &DynamicItemConnector[]->theDeletableConn[]->theObject[];
       true->theDeletableConn.initialisingSaved;
       (if userDataVerbose then 'MakeConn: Created DynamicItemConnector!'->putline if)
    // UDPrivate.UDDynamicComponentConnector then
       &DynamicComponentConnector[]->theDeletableConn[]->theObject[];
       true->theDeletableConn.initialisingSaved;
       (if userDataVerbose then 'MakeConn: Created DynamicComponentConnector!'->putline if)
    // UDPrivate.UDTreeConnector then
       &theListDiagram.TreeConnector[]->theConnector[]->theObject[];
       true->theConnector.initialisingSaved;
       (if userDataVerbose then 'MakeConn: Created TreeConnector!'->putline if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       (if ID->DSRdAttrGetObjectType // RegionType then theObject.onInitRegion;  if);
       (if (ID,count2[],list[])->DSStrGetObjectRegionList
        // true then
           (if count2 > 0
            // true then
               (count2,list)->GetIntList->regions;
               (if verbose
                // true then 'NoOfRegions: '->puttext; regions.range->putint; newline; 
               if);
               regions->MakeObjectsFromList;
               
           if)
       if)
   if)
#)  

-- makeSurroundBox: DoPart --
do
     (#
        NodeType: @integer;
        thePropertyDiagram: ^PropertyDiagram;
        theObject: ^DesignObject;
        regions: [0] @Integer;
        count2: @ShortRef;
        list: @IntegerRef
     do
        ID->getNodeType->NodeType;
        (if NodeType = UDPrivate.UDSurroundBox then
            theDiag[]->thePropertyDiagram[];
            &thePropertyDiagram.surroundBox[]->theObject[];
            (if theObject[] <> none then
                ID->theObject.onInit;
                (if userdataVerbose then 'MakeSurroundBox: Created SurroundBox!'->putline if);
                (if ID->DSRdAttrGetObjectType // RegionType then theObject.onInitRegion;  if);
                (if (ID,count2[],list[])->DSStrGetObjectRegionList
                 // true then
                    (if count2 > 0
                     // true then
                        (count2,list)->GetIntList->regions;
                        (if verbose
                         // true then 'NoOfRegions: '->puttext; regions.range->putint; newline; 
                        if);
                        regions->MakeObjectsFromList;
                        
                    if)
                if)
            if)
        if)
     #)  

-- onReadDiagram: Descriptor --
(# 
do
(*  THIS(OADPage).PatternDiagrams.theList.scan
 (#
 theListDiagram: ^ListDiagram;
 thisOADDiagram: ^OADDiagram;
 thisFragmentDiagram: ^FragmentDiagram;
 theDummyDesc: ^betaGram.ObjectDescriptor;
 thisPatternAttDiagram: ^PatternAttDiagram;
 theDummyAST: ^MPS.AST
 do
 current.e[]->theListDiagram[];
 (if current.e.struc <= OADDiagram##
 // true then
 current.e[]->thisOADDiagram[];
 thisOADDiagram.titlenode.theText.get->thisOADDiagram.titleText;
 (if thisOADDiagram.theDescriptor <> none then
 thisOADDiagram.theDescriptor->theDummyDesc[];
 theDummyDesc.index->current.index;
 (if thisOADDiagram## <= PatternAttDiagram## then
 thisOADDiagram[]->thisPatternAttDiagram[];
 thisPatternAttDiagram.theAST->theDummyAST[];
 theDummyAST.index->current.index
 if)
 if);
 if);
 (if current.e.struc <= FragmentDiagram## then
 current.e[]->thisFragmentDiagram[];
 thisFragmentDiagram.titlenode.theText.get
 ->thisFragmentDiagram.titleText
 if)
 #) *) 
#)  

