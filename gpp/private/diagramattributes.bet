ORIGIN '../gppinterface';
LIB_ITEM 'gpp';
INCLUDE '~beta/containers/list'
        '~beta/containers/sets'
        '~beta/containers/arrayContainer'
        '../prettyprintersetup'
        '../propertydiagrams'
        'userdataprivate';
BODY 'gppinterfacebody'
     'oadpagebody'
     'pagecallbackbody'
     'associationconnbody'
     'aggregationconnbody'
     'diagrambody'
     'patterndiagrambody'
     'abstractnodebody'
     'fragmentnodebody'
     'marknodebody'
     'simplenodebody'
     'nonterminalnodebody'
     'patternnodebody'
     'virtualnodebody'
     'bindingnodebody'
     'finalnodebody'
     'slotnodebody'
     'patterndiagramsbody';
(*
-- PageLib: Attributes --
scrollIntoView:
  (# theObject: ^designObject; 
  enter theObject[]
  do
     (if doScrollIntoView then
         theObject[]->currentObject (#  do true->autoPan #); 
     if);
     
 #);
*)
-- OADPageLib: Attributes --
GetPrefix:
  (#
     theDescriptor: ^betaGram.ObjectDescriptor;
     tempAst: ^mps.ast;
     pref: ^betaGram.prefix;
     ad: ^betaGram.attributeDenotation;
     thisPrefix: ^betaGram.ObjectDescriptor;
     
  enter theDescriptor[]
  do
     (if switch[50] then
         'GetPrefix: theDescriptor=%i\n'
           ->putformat (#  do theDescriptor.index->i #)
     if);
     theDescriptor.getPrefixOpt->tempAst[];
     (if tempAst.kind = mps.kinds.interior then
         tempAst[]->pref[];
         pref.getAttributeDenotation->tempAst[];
         (if tempAst.kind = mps.kinds.interior then
             tempAst[]->ad[]; ad.findDescriptor->thisPrefix[]; 
         if);
         
     if);
     
  exit thisPrefix[]
  #);
DiagramList: ContainerList (* list of diagrams on a page *)
  (#
     element::<  (# index: @Integer; frag: ^text; e: ^Diagram #);
     myFind: find
       (#
          i: @Integer;
          f: ^text;
          predicate::< 
            (# 
            do
               (if f[] <> none then
                   (if current.frag[] <> none then
                       (i = current.index) and (current.frag[]->f.equal)->value
                   if)
                else
                   (i = current.index)->value
               if)
            #);
          
       enter (i,f[])
       #);
     findPD:
       (# aPD: ^Element; aDiagram: ^Diagram; 
       enter myFind->aPD[]
       do (if aPD[] <> none then aPD.e[]->aDiagram[];  if); 
       exit aDiagram[]
       #);
     insertPD:
       (# aPD: ^Element; index: @Integer; frag: ^text; e: ^Diagram; 
       enter (index,frag[],e[])
       do
          &Element[]->aPD[];
          (index,frag[],e[])->(aPD.index,aPD.frag[],aPD.e[]);
          aPD[]->append;
          
       #);
     deletePD: (#  enter myFind->at->delete #);
     updateIndex: find
       (#
          predicate:: 
            (# 
            do
               71
                 ->trace
                   (# 
                   do
                      'DiagramList-updateIndex: theDiagram=%s current.e=%s\n'
                        ->t.putformat
                          (# 
                          do
                             theDiagram.titletext[]->s; current.e.titletext[]->s
                          #)
                   #);
               theDiagram[] = current.e[]->value
            #);
          theDiagram: ^Diagram;
          index: @integer;
          f: ^text
       enter (theDiagram[],index,f[])
       do
          index->current.index;
          f[]->current.frag[];
          71
            ->trace
              (# 
              do
                 'DiagramList-updateIndex: updating %s with index=%i frag=%s\n'
                   ->t.putformat
                     (# 
                     do
                        theDiagram.titletext[]->s;
                        current.index->i;
                        current.frag[]->s
                     #)
              #)
       #);
     deleteProp:
       (#
          findProp:
            (# p: ^Diagram; aPD: ^Element; 
            enter p[]
            do
               scanner: scan
                 (# 
                 do
                    (if current.e[] = p[] then
                        current[]->aPD[]; leave scanner
                    if);
                    
                 #);
               
            exit aPD[]
            #);
          
       enter findProp->at->delete
       #);
     GetSubPatternDiagrams:
       (#
          theDiagram,aPatternDiagram: ^PatternDeclDiagram;
          aList: ^DiagramList;
          
       enter theDiagram[]
       do
          &DiagramList[]->aLIst[];
          scan
            (# 
            do
               (if current.e## <= PatternDeclDiagram##
                // true then
                   current.e[]->aPatternDiagram[];
                   (if aPatternDiagram.thePrefix[] <> none
                    // true then
                       (if
                       aPatternDiagram.thePrefix[]
                         ->theDiagram.theDescriptor.equal then
                           current[]->aList.append; 
                       if)
                   if)
               if)
            #);
          
       exit aList[]
       #);
     GetSortableSubPatternDiagrams:
       (#
          theDiagram,aPatternDiagram: ^PatternDeclDiagram;
          aList: ^SortableDiagramList;
          
       enter theDiagram[]
       do
          &SortableDiagramList[]->aList[];
          scan
            (# 
            do
               (if current.e## <= PatternDeclDiagram## then
                   current.e[]->aPatternDiagram[];
                   (if aPatternDiagram.thePrefix[] <> none then
                       (if
                       aPatternDiagram.thePrefix[]
                         ->theDiagram.theDescriptor.equal then
                           current.e[]->aList.insert; 
                       if)
                   if)
               if)
            #);
          
       exit aList[]
       #);
     scanPatternDiagrams: scan
       (# thisDiagram: ^PatternDeclDiagram; 
       do
          (if current.e## <= PatternDeclDiagram##
           // true then current.e[]->thisDiagram[]; INNER ; 
          if)
       #);
     scanFragmentDiagrams: scan
       (# thisDiagram: ^fragmentDiagram; 
       do
          (if current.e## <= FragmentDiagram##
           // true then current.e[]->thisDiagram[]; INNER ; 
          if)
       #);
     scanPropertyDiagrams: scan
       (# thisDiagram: ^SimplePropertyDiagram; 
       do
          (if current.e## <= SimplePropertyDiagram##
           // true then current.e[]->thisDiagram[]; INNER ; 
          if)
       #);
     dump:
       (# 
       do
          'Diagram list:'->putline;
          scan
            (# 
            do
               ' ('->puttext;
               current.index->putint;
               ', '->puttext;
               (if current.frag[] <> none then
                   current.frag[]->puttext
                else
                   'none'->puttext
               if);
               ', '->puttext;
               current.e.titleText[]->puttext;
               ')'->puttext
            #);
          newline;
          newline
       #);
     
  #);
(* LIST HANDLING *)
SortableDiagramList: ArrayContainer
  (#
     currentInx: @integer;
     element::< Diagram;
     less::< 
       (# lx,ly,rx,ry: @integer
       do
          left.titleNode.center->(lx,ly);
          right.titleNode.center->(rx,ry);
          lx < rx->value
       #);
     insert:
       (# elm: ^element
       enter elm[]
       do
          currentInx+1->currentInx;
          (if currentInx > capacity then capacityExtend if);
          (elm[],currentInx)->put
       #);
     sort: (#  do (if currentInx > 0 then currentInx->quickSort if) #)
  #);
  

-- DiagramLib: Attributes --
DisplayAst:
  (# anAST: ^MPS.AST; pos: @Point; 
  enter (anAST[],pos)
  do <<SLOT DisplayAST:Descriptor>>; 
  exit pos
  #);
scanAttributeDecls:
  (#
     theAtt: ^betaGram.Attributes;
     anAst: ^mps.ast;
     ndl: ^betaGram.names;
     unExp: ^mps.unExpanded;
     thisAttribute:<
       (# nd: ^betaGram.nameDcl
       enter nd[]
       do INNER
       #);
     thisUnExp:<
       (# unExp: ^mps.unExpanded
       enter unExp[]
       do INNER
       #);
     thisOptional:<
       (# opt: ^mps.Optional
       enter opt[]
       do INNER
       #);
     thisSlot:<
       (# theSlot: ^mps.SlotDesc
       enter theSlot[]
       do INNER
       #);
     
  enter theAtt[]
  do
     (if switch[70]
      // true then
         'scanAttributeDecls'->screen.putline; 
     if);
     theAtt.scan
       (# att: ^betaGram.attributeDecl
       do
          (if switch[70]
           // true then '*'->screen.put
          if);
          (if current.kind
           // mps.kinds.interior then
              current[]->att[];
              att.getSon1->anAst[];
              (if switch[70]
               // true then
                  'interior: '->screen.puttext;
                  anAst.symbol->screen.putint;
                  screen.newline;
                  
              if);
              (if anAst.symbol
               // betaGram.names then
                  anAst[]->ndl[];
                  ndl.scan
                    (# 
                    do current[]->thisAttribute
                    #)
              if)
           // mps.kinds.unExpanded then
              (if switch[70]
               // true then
                  'unExpanded: '->screen.puttext; 
              if);
              current[]->unExp[];
              (if unExp.isSlot
               // true then
                  (if switch[70] // true then 'Slot'->screen.putline;  if);
                  unExp.theSlot->thisSlot;
                  
               else
                  (if switch[70] // true then screen.newline;  if);
                  unExp[]->thisUnExp;
                  
              if)
           // mps.kinds.optional then
              (if switch[70] // true then 'optional'->screen.putline;  if);
              current[]->thisOptional;
              
          if)
       #);
     (if switch[70] // true then 'DONE'->screen.putline if);
     
  #);
CountAttributes:
  (#
     obj: ^betaGram.ObjectDescriptor;
     main: ^betaGram.MainPart;
     a: ^MPS.AST;
     i: @Integer;
     
  enter obj[]
  do
     (if switch[70] // true then 'CountAttributes '->screen.puttext if);
     (if obj[] <> none
      // true then
         obj.getMainPart->main[];
         main.getAttributes->a[];
         (if a[]
          // none then
             'Attribute error: cannot get attributes from descriptor: '
               ->puttext;
             
          else
             (if a.kind
              // mps.kinds.interior then
                 (if switch[70]
                  // true then 'scanning '->screen.puttext
                 if);
                 a[]
                   ->scanAttributeDecls
                     (#
                        thisAttribute::<  (#  do i+1->i #);
                        thisOptional::<  (#  do i+1->i #);
                        thisUnExp::<  (#  do i+1->i #);
                        
                     #);
                 
             if)
         if)
     if);
     (if switch[70] // true then screen.newline if);
     
  exit i
  #);
CheckKeyWord:
  (#
     node: ^mps.ast;
     keyword: ^text;
     found: @boolean;
     theCom: ^mps.comment;
     theComText,nextWord: ^text;
     
  enter (node[],keyword[])
  do
     (if node.hasComment
      // true then
         (node[]->patternDiagrams.astUtils.getCommentPos,1)->node.getSubcomment
           ->theComText[];
         theComText.reset;
         search:
           (# 
           do
              theComText.getAtom->nextWord[];
              (if true
               // keyWord[]->nextWord.equal then true->found; 
               else
                  (if theComText.eos // false then restart search if); 
              if);
              
           #);
         
     if);
     
  exit found
  #);
isDescriptorDiagram:
  (#
     theOADDiagram: ^OADDiagram;
     desc: ^betaGram.ObjectDescriptor;
     anAST: ^MPS.AST;
     value: @Boolean
  enter theOADDiagram[]
  do
     theOADDiagram.theDescriptor[]->desc[];
     (if desc[] <> none then
         desc.father->anAST[]; (if anAST.father = none then true->value if)
     if)
  exit value
  #);
makeNonTerminalSymbol:
  (# symbolName: ^Text
  enter symbolName[]
  do '<<'->symbolName.prepend; '>>'->symbolName.append
  exit symbolName[]
  #);
makeRemote:
  (#
     anAST: ^MPS.AST;
     rem: ^betaGram.remote;
     unExp: ^mps.unexpanded;
     na: ^betaGram.nameApl;
     t: ^text
  enter anAST[]
  do
     &Text[]->t[];
     anAST[]->rem[];
     rem.getAttributeDenotation->anAST[];
     (if anAST.kind = mps.kinds.unExpanded then
         anAST[]->unExp[];
         unExp.NonTerminalSymbol->betaGram.symbolToName->makeNonTerminalSymbol
           ->t.append;
         '.'->t.append
      else
         (if anAST.symbol
          // betaGram.NameApl then
             anAST[]->na[];
             na.getNameAppl->anAST[];
             (if anAST.kind = mps.kinds.unExpanded then
                 '<NameAppl>.'->t.append
              else
                 na.gettext->t.append; '.'->t.append
             if)
          // betaGram.Remote then
             anAST[]->makeRemote->t.append; '.'->t.append
         if)
     if);
     rem.getNameApl->na[];
     na.getNameAppl->anAST[];
     (if anAST.kind = mps.kinds.unExpanded then
         '<NameAppl>'->t.append
      else
         na.gettext->t.append
     if)
  exit t[]
  #);
nameToNode:
  (# name: ^text; occurrenceNo,no: @integer; theNode: ^AbstractNode
  enter (name[],occurrenceNo)
  do
     localNodes.scan
       (#
          where:: 
            (# an: ^AbstractNode
            do
               (if current## <= AbstractNode## then
                   current[]->an[]; (an.theName->name.equal)->value
                else
                   false->value
               if)
            #)
       do no+1->no; (if no = occurrenceNo then current[]->theNode[] if)
       #)
  exit theNode[]
  #);
slotNameToNode:
  (# name: ^text; occurrenceNo,no: @integer; theNode: ^SlotNode
  enter (name[],occurrenceNo)
  do
     localNodes.scan
       (#
          where:: 
            (# t: @text
            do
               current.theText.get->t;
               ((t[]->name.equal) and (current## <= SlotNode##))->value
            #)
       do no+1->no; (if no = occurrenceNo then current[]->theNode[] if)
       #)
  exit theNode[]
  #);
noToNonTerminal:
  (# occurrenceNo,no: @integer; theNode: ^nonTerminalNode
  enter occurrenceNo
  do
     localNodes.scan
       (# where::  (#  do current## <= nonTerminalNode##->value #)
       do no+1->no; (if no = occurrenceNo then current[]->theNode[] if)
       #)
  exit theNode[]
  #);
(****************** DIAGRAM NODES ************************)
AbstractNode: PatternDiagramNode
  (#
     theName: @ReferenceUserData (# Type::< Text #);
     currentDecomposDiagram: @DiagramReferenceUserData
       (# Type::< PatternDiagram #);
     hasAttributes: @BooleanUserData;
     decomposDiagrams: @containerlist (# element::< PatternDiagram #);
     thePopup: @popupDesc;
     popupDesc:< theUI.menu
       (#
          opened: @boolean;
          editItem: @menuItem
            (#
               eventHandler:: 
                 (#
                    onStatus:: 
                      (# 
                      do
                         ((THIS(AbstractNode)## <= SimpleNode##) or
                          (THIS(AbstractNode)## <= PatternNode##)) and
                         (not (theSifEditor).sifisEditingMode and not (theSifEditor).isReadOnly)->value
                      #);
                    onSelect::  (#  do edit #)
                 #)
            #);
          sep1: @separator;
          NewItem: @menuItem
            (#
               eventhandler:: 
                 (#
                    onStatus:: 
                      (# 
                      do (not (theSifEditor).sifisEditingMode and not (theSifEditor).isReadOnly)->value
                      #)
                 #);
               newSubMenu: @theUI.menu
                 (#
                    attributeItem: @menuItem
                      (#
                         eventHandler:: 
                           (# onSelect::  (#  do newAttribute #) #)
                      #);
                    operationItem: @menuItem
                      (#
                         eventHandler:: 
                           (# onSelect::  (#  do newOperation #) #)
                      #);
                    localClassItem: @menuItem
                      (#
                         eventHandler:: 
                           (# onSelect::  (#  do newLocalClass #) #)
                      #);
                    open::< 
                      (# 
                      do
                         attributeItem.open;
                         'Attribute...'->attributeItem.name;
                         ('a',true,true,false)->attributeItem.specialKey;
                         attributeItem[]->append;
                         operationItem.open;
                         'Operation...'->operationItem.name;
                         ('o',true,true,false)->operationItem.specialKey;
                         operationItem[]->append;
                         localClassItem.open;
                         'Local Class...'->localClassItem.name;
                         ('l',true,true,false)->localClassItem.specialKey;
                         localClassItem[]->append
                      #)
                 #);
               open::<  (#  do newSubMenu.open; newSubMenu[]->subMenu #)
            #);
          moveItem: @menuItem
            (#
               eventhandler:: 
                 (#
                    onStatus:: 
                      (# 
                      do (not (theSifEditor).sifisEditingMode and not (theSifEditor).isReadOnly)->value
                      #)
                 #);
               moveSubMenu: @theUI.menu
                 (#
                    moveUpItem: @menuItem
                      (#
                         eventHandler:: 
                           (#
                              onStatus:: 
                                (# 
                                do
                                   (if attributeType
                                    // gppProp.SimpleAttribute then
                                       (not
                                        (THIS(AbstractNode)[] =
                                         (attributes.head).elm[])) and
                                       (not
                                        (THIS(AbstractNode)## <=
                                         FragmentNode##))->value
                                    // gppProp.Operation then
                                       (not
                                        (THIS(AbstractNode)[] =
                                         (operations.head).elm[])) and
                                       (not
                                        (THIS(AbstractNode)## <=
                                         FragmentNode##))->value
                                    // gppProp.LocalClass then
                                       (not
                                        (THIS(AbstractNode)[] =
                                         (localClasses.head).elm[])) and
                                       (not
                                        (THIS(AbstractNode)## <=
                                         FragmentNode##))->value
                                   if)
                                #);
                              onSelect::  (#  do moveUpNode #)
                           #)
                      #);
                    moveDownItem: @menuItem
                      (#
                         eventHandler:: 
                           (#
                              onStatus:: 
                                (# 
                                do
                                   (if attributeType
                                    // gppProp.SimpleAttribute then
                                       (not
                                        (THIS(AbstractNode)[] =
                                         (attributes.last).elm[])) and
                                       (not
                                        (THIS(AbstractNode)## <=
                                         FragmentNode##))->value
                                    // gppProp.Operation then
                                       (not
                                        (THIS(AbstractNode)[] =
                                         (operations.last).elm[])) and
                                       (not
                                        (THIS(AbstractNode)## <=
                                         FragmentNode##))->value
                                    // gppProp.LocalClass then
                                       (not
                                        (THIS(AbstractNode)[] =
                                         (localClasses.last).elm[])) and
                                       (not
                                        (THIS(AbstractNode)## <=
                                         FragmentNode##))->value
                                   if)
                                #);
                              onSelect::  (#  do moveDownNode #)
                           #)
                      #);
                    sep1: @separator;
                    toAttributesItem: @menuItem
                      (#
                         eventHandler:: 
                           (#
                              onStatus:: 
                                (# 
                                do
                                   not
                                   (attributeType = gppProp.SimpleAttribute)
                                     ->value
                                #);
                              onSelect::  (#  do moveNodeToAttributes #)
                           #)
                      #);
                    toOperationsItem: @menuItem
                      (#
                         eventHandler:: 
                           (#
                              onStatus:: 
                                (# 
                                do
                                   not (attributeType = gppProp.Operation)
                                     ->value
                                #);
                              onSelect::  (#  do moveNodeToOperations #)
                           #)
                      #);
                    toLocalClassesItem: @menuItem
                      (#
                         eventHandler:: 
                           (#
                              onStatus:: 
                                (# 
                                do
                                   not (attributeType = gppProp.LocalClass)
                                     ->value
                                #);
                              onSelect::  (#  do moveNodeToLocalClasses #)
                           #)
                      #);
                    open:: 
                      (# 
                      do
                         moveUpItem.open;
                         'Up'->moveUpItem.name;
                         moveUpItem[]->append;
                         moveDownItem.open;
                         'Down'->moveDownItem.name;
                         moveDownItem[]->append;
                         sep1.open;
                         sep1[]->append;
                         toAttributesItem.open;
                         'To Attributes Compartment'->toAttributesItem.name;
                         toAttributesItem[]->append;
                         toOperationsItem.open;
                         'To Operations Compartment'->toOperationsItem.name;
                         toOperationsItem[]->append;
                         toLocalClassesItem.open;
                         'To Local Classes Compartment'
                           ->toLocalClassesItem.name;
                         toLocalClassesItem[]->append
                      #)
                 #);
               open::  (#  do moveSubMenu.open; moveSubMenu[]->subMenu #)
            #);
          sep2: @separator;
          cutItem: @menuItem
            (#
               eventHandler:: 
                 (#
                    onStatus:: 
                      (# 
                      do (not (theSifEditor).sifisEditingMode and not (theSifEditor).isReadOnly)->value
                      #);
                    onSelect:: 
                      (# anAST: ^mps.ast; nt: ^NonTerminalNode
                      do
                         getASTNode->anAST[];
                         (if anAST[] <> none then
                             (anAST[],1)->(theSifEditor).changeFocus;
                             true->doOADPaste;
                             false->doObjectPaste;
                             false->pasteGroupWithOAD;
                             enablePaste;
                             (theSifEditor).cut
                          else
                             (if THIS(AbstractNode)## <= NonTerminalNode## then
                                 THIS(AbstractNode)[]->nt[];
                                 (nt.unexp[],1)->(theSifEditor).changeFocus;
                                 (theSifEditor).cut
                             if)
                         if)
                      #)
                 #)
            #);
          copyItem: @menuItem
            (#
               eventHandler:: 
                 (#
                    onSelect:: 
                      (# anAST: ^mps.ast; nt: ^NonTerminalNode
                      do
                         getASTNode->anAST[];
                         (if anAST[] <> none then
                             (anAST[],1)->(theSifEditor).changeFocus;
                             true->doOADPaste;
                             false->doObjectPaste;
                             false->pasteGroupWithOAD;
                             enablePaste;
                             (theSifEditor).copy
                          else
                             (if THIS(AbstractNode)## <= NonTerminalNode## then
                                 THIS(AbstractNode)[]->nt[];
                                 (nt.unexp[],1)->(theSifEditor).changeFocus;
                                 (theSifEditor).copy
                             if)
                         if)
                      #)
                 #)
            #);
          pasteItem: @menuItem
            (#
               eventHandler:: 
                 (#
                    onStatus:: 
                      (# 
                      do
                         getCanPaste and (not (theSifEditor).sifisEditingMode and not (theSifEditor).isReadOnly)
                           ->value
                      #);
                    onSelect:: 
                      (# anAST: ^mps.ast; nt: ^NonTerminalNode
                      do
                         getASTNode->anAST[];
                         (if anAST[] <> none then
                             (anAST[],1)->(theSifEditor).changeFocus;
                             (theSifEditor).paste
                          else
                             (if THIS(AbstractNode)## <= NonTerminalNode## then
                                 THIS(AbstractNode)[]->nt[];
                                 (nt.unexp[],1)->(theSifEditor).changeFocus;
                                 (theSifEditor).paste
                             if)
                         if)
                      #)
                 #)
            #);
          sep3: @separator;
          openSubEditorItem: @menuItem
            (#
               eventHandler:: 
                 (#
                    onStatus:: 
                      (# 
                      do (not (theSifEditor).sifisEditingMode)->value
                      #);
                    onSelect:: 
                      (#  do getASTNode->(theSifEditor).openSubeditor #)
                 #)
            #);
          open::<  (#  <<SLOT AbstractNodePopUpDescOpen:DoPart>> #)
       #);
     PatternDiagReference:
      LocalNodesReferenceUserData (# Type::< PatternDiagram #);
     onSelect::<  (#  <<SLOT AbstractNodeOnSelect:DoPart>> #);
     onRightMouseDown::< 
       (# 
       <<SLOT AbstractNodeOnRightMouseDown:DoPart>>
       #);
     onRemove::< (* called when THIS(DiagramNode) is deleted *) 
       (#  do <<SLOT AbstractNodeRemove:Descriptor>>;  #);
     Display::< 
       (# t: @Text; pos: @Point; 
       enter pos
       do
          <<SLOT AbstractNodeDisplay:Descriptor>>;
          
       #);
     Redisplay::< 
       (# t: @Text;  do <<SLOT AbstractNodeRedisplay:Descriptor>>;  #);
     changeDisplay:<
       (# 
       <<SLOT AbstractNodeChangeDisplay:DoPart>>
       #);
     ConcludeDisplay::< 
       (#  do INNER ; <<SLOT AbstractNodeConcludeDisplay:Descriptor>>;  #);
     updateComment:< (#  do INNER updateComment #);
     insertDiagramNode::< 
       (#  do <<SLOT AbstractNodeInsertDiagramNode:Descriptor>> #);
     detail::< 
       (#
          theAST:
            ^MPS.AST
             (* the AST to be detailed *)
       do <<SLOT AbstractNodeDetail:Descriptor>>; 
       #);
     detailRecursively::< 
       (# 
       <<SLOT AbstractNodeDetailRecursively:DoPart>>
       #);
     overview::<  (#  <<SLOT AbstractNodeOverview:DoPart>> #);
     abstract::<
     (* if detailed then abstract the decompos diagram *) 
       (#  do <<SLOT AbstractNodeAbstract:Descriptor>>;  #);
     abstractRecursively::< 
       (# 
       <<SLOT AbstractNodeAbstractRecursively:DoPart>>
       #);
     abstractedFromDiagramBelow::<
     (* when THIS(DiagramNode) has been abstrated from a diagram below *) 
       (# 
       do <<SLOT AbstractNodeAbstractedFromDiagramBelow:Descriptor>>; 
       #);
     CheckForAttributes:< (#  do INNER exit hasAttributes #);
     moveUpNode:<
       (# pos,pred: ^localNodes.theCellType; x,y,px,py: @integer
       <<SLOT AbstractNodeMoveUpNode:DoPart>>
       #);
     moveDownNode:<
       (#
          pos,succ:
            ^localNodes.theCellType;
          x,y,sx,sy: @integer
       <<SLOT AbstractNodemoveDownNode:DoPart>>
       #);
     moveNodeToAttributes:<
       (# px,py: @integer
       <<SLOT AbstractNodeMoveNodeToAttributes:DoPart>>
       #);
     moveNodeToOperations:<
       (# px,py: @integer
       <<SLOT AbstractNodeMoveNodeToOperations:DoPart>>
       #);
     moveNodeToLocalClasses:<
       (# px,py: @integer
       <<SLOT AbstractNodeMoveNodeToLocalClasses:DoPart>>
       #);
     onInit::< 
       (# 
       <<SLOT AbstractNodeOnInit:DoPart>>
       #);
     dump::<  (#  do <<SLOT AbstractNodeDump:Descriptor>>; INNER #)
  #);
(******************** For FragmentDiagrams *********************)
FragmentNode: AbstractNode
  (#
     theFragment: @FragReferenceUserData (# Type::< mps.FragmentForm #);
     theRoot: ^mps.ast;
     sifEditorInstance: ^SifEditor;
     display::< 
       (# 
       enter theFragment
       do <<SLOT FragmentNodeDisplay:Descriptor>>; 
       #);
     redisplay::< 
       (# 
       enter theFragment
       do
          <<SLOT FragmentNodeRedisplay:Descriptor>>;
          
       #);
     ConcludeDisplay::<  (#  do INNER #);
     onDoubleClick::< 
       (# doneInInner: @Boolean
       do
          INNER ;
          (if not doneInInner then false->IndicateSelection; detail if)
       #);
     detail::<  (#  do INNER ; <<SLOT FragmentNodeDetail:Descriptor>> #);
     GetGroup::< 
       (# fd: ^FragmentDiagram; 
       do
          theDiagram->fd[];
          fd.theGroup->fg[];
          
       #);
     GetFragment::< 
       (#  do theFragment->f[];  #);
     theSifEditor::< 
       (# 
       do
          (if se[] = none then
              sifEditorInstance[]->se[]
           else
              se[]->sifEditorInstance[]
          if)
       #);
     CheckForAttributes::<  (#  do true->hasAttributes #);
     onInit::< 
       (# 
       do UDPrivate.UDFragmentNode->UserDataInit; theFragment.Init; INNER
       #);
     dump::<  (#  do <<SLOT FragmentNodeDump:Descriptor>>;  #);
     
  #);
DoPartNode: FragmentNode
  (#
     display::< 
       (#  do ': DoPart'->t.append;  #);
     onDoubleClick::< 
       (#  do true->doneInInner #);
     onInit::< 
       (# 
       do
          UDPrivate.UDDoPartNode
            ->UserDataInit;
          INNER
       #);
     dump::< 
       (# 
       do 'DoPartNode'->nodetype[]
       #)
  #);
AttributesNode: FragmentNode
  (#
     display::< 
       (# 
       do ': Attributes'->t.append; 
       #);
     redisplay::< 
       (# 
       do ': Attributes'->t.append; 
       #);
     detail::< 
       (# 
       do
          <<SLOT AttributesNodeDetail:Descriptor>>
       #);
     onInit::<  (#  do UDPrivate.UDAttributesNode->UserDataInit; INNER #);
     dump::<  (#  do 'AttributesNode'->nodetype[] #);
     
  #);
DescriptorNode: FragmentNode
  (#
     display::<  (#  do ': Descriptor'->t.append;  #);
     redisplay::<  (#  do ': Descriptor'->t.append;  #);
     detail::<  (#  do <<SLOT DescriptorNodeDetail:Descriptor>> #);
     onInit::< 
       (# 
       do
          UDPrivate.UDDescriptorNode
            ->UserDataInit;
          INNER
       #);
     dump::< 
       (# 
       do 'DescriptorNode'->nodetype[]
       #);
     
  #);
DiagramNode: AbstractNode
  (#
     theDeclaration:
       ^betaGram.AttributeDecl;
     theObjectDescriptor:
       ^betaGram.ObjectDescriptor;
     thePrefix:
       ^betaGram.ObjectDescriptor;
     onSelect::< 
       (# 
       do
          enableEditName;
          INNER onSelect
       #);
     CheckForAttributes::< 
       (#
          od:
            ^betaGram.ObjectDescriptor
       enter od[]
       do
          (if theObjectDescriptor[] =
          none then
              (od[]->CountAttributes) > 0->hasAttributes
           else
              (theObjectDescriptor[]->CountAttributes) > 0->hasAttributes
          if);
          
       #);
     Display::< 
       (# anAST: ^MPS.AST; (* either theName or an unExp *) 
       enter (theDeclaration[],anAST[])
       do <<SLOT DiagramNodeDisplay:Descriptor>>; 
       #);
     Redisplay::< 
       (#
          anAST: ^MPS.AST;
          (* either theName or an unExp *)
          
       enter (theDeclaration[],anAST[])
       do <<SLOT DiagramNodeReDisplay:Descriptor>>
       #);
     ppAST:<
       (#
          anAST: ^mps.ast;
          theDeclaration:
            ^betaGram.AttributeDecl;
          t: @text;
          theName: ^text;
          theObjectDescriptor:
            ^betaGram.ObjectDescriptor;
          propertyString: ^text
       enter (anAST[],theDeclaration[])
       <<SLOT diagramNodePPAST:DoPart>>
       exit (t,theName[],theObjectDescriptor[],propertyString[])
       #);
     ConcludeDisplay::< 
       (#  do <<SLOT DiagramNodeConcludeDisplay:Descriptor>>; INNER #);
     updateComment::< 
       (#
          cm: ^CommentMark;
          nodeText: @text;
          commentText: ^text;
          theCom: ^mps.comment;
          commentPos: @integer
       <<SLOT DiagramNodeUpdateComment:DoPart>>
       #);
     EqualDescriptor:<
       (# aDesc: ^betaGram.ObjectDescriptor; b: @Boolean; 
       enter aDesc[]
       do INNER
       exit b
       #);
     detail::<  (#  do <<SLOT DiagramNodeDetail:Descriptor>> #);
     getASTNode::<
     (* return the AST node THIS(title) is generated from *) 
       (#  do theDeclaration[]->anAST[]; INNER #);
     GetGroup::<  (#  do <<SLOT DiagramNodeGetGroup:Descriptor>> #);
     GetFragment::< 
       (# 
       do
          <<SLOT DiagramNodeGetFragment:Descriptor>>
       #);
     theSifEditor::<  (# fn: ^FragmentNode <<SLOT theSifEditor:DoPart>> #);
     onInit::<  (#  <<SLOT DiagramNodeOnInit:DoPart>> #);
     dump::< 
       (# 
       do
          <<SLOT DiagramNodeDump:Descriptor>>;
          INNER
       #);
     private: @<<SLOT DiagramNodePrivate:Descriptor>>;
     
  #);
SimpleAttributeDecl: DiagramNode
(* SimpleDecl or RepetitionDecl *)
  (#
     declTypeNode: @ReferenceUserData (# Type::< PatternDiagramNode #);
     theReferenceSpec: ^betaGram.referenceSpecification;
     theUnExpRefSpec: ^mps.unExpanded;
     theAggregationConnector: @ReferenceUserData
       (# Type:: AggregationConnector #);
     theAssociationConnector: @ReferenceUserData
       (# Type:: AssociationConnector #);
     popupDesc::< 
       (#
          ShowItem: @menuItem
            (#
               showSubMenu: @theUI.menu
                 (#
                    NameAndTypeItem: @menuItem
                      (#
                         eventHandler:: 
                           (#
                              onStatus:: 
                                (# 
                                <<SLOT SimpleAttributeDeclPopupDescOnStatus:DoPart>>
                                #);
                              onSelect:: 
                                (# 
                                <<SLOT SimpleAttributeDeclPopupDescOnSelect:DoPart>>
                                #)
                           #)
                      #);
                    NameItem: @menuItem
                      (#
                         eventHandler:: 
                           (#
                              onStatus:: 
                                (# 
                                <<SLOT SimpleAttributeDeclPopupDescNameOnStatus:DoPart>>
                                #);
                              onSelect:: 
                                (# 
                                <<SLOT SimpleAttributeDeclPopupDescNameOnSelect:DoPart>>
                                #)
                           #)
                      #);
                    TypeItem: @menuItem
                      (#
                         eventHandler:: 
                           (#
                              onStatus:: 
                                (# 
                                <<SLOT SimpleAttributeDeclPopupDescTypeOnStatus:DoPart>>
                                #);
                              onSelect:: 
                                (# 
                                <<SLOT SimpleAttributeDeclPopupDescTypeOnSelect:DoPart>>
                                #)
                           #)
                      #);
                    NameAndKindItem: @menuItem
                      (#
                         eventHandler:: 
                           (#
                              onStatus:: 
                                (# 
                                <<SLOT SimpleAttributeDeclPopupDescNameAndKingOnStatus:DoPart>>
                                #);
                              onSelect:: 
                                (# 
                                <<SLOT SimpleAttributeDeclPopupDescNameAndKingOnSelect:DoPart>>
                                #)
                           #)
                      #);
                    open::< 
                      (#  <<SLOT SimpleAttributeDeclPopupDescOpen:DoPart>> #)
                 #);
               open::<  (#  do showSubMenu.open; showSubMenu[]->subMenu #)
            #);
          open::< 
            (# 
            do showItem.open; 'Show'->ShowItem.name; showItem[]->append
            #)
       #);
     Display::< 
       (# theObjectSpec: ^MPS.AST
       do
          INNER ;
          (* make theObjectSpec and theReferenceSpec *)
          <<SLOT SimpleAttrDeclDisplay:Descriptor>>;
          
       #);
     Redisplay::< 
       (# theObjectSpec: ^MPS.AST
       do
          INNER ;
          (* make theObjectSpec and theReferenceSpec *)
          <<SLOT SimpleAttrDeclReDisplay:Descriptor>>;
          
       #);
     ppAST::< 
       (#
          theObjectSpec: ^mps.ast;
          theReferenceSpec: ^betaGram.ReferenceSpecification;
          theUnExpRefSpec: ^mps.unExpanded
       <<SLOT simpleAttributeDeclPPAST:DoPart>>
       exit
       (theReferenceSpec[],
        theUnExpRefSpec[],theObjectSpec[])
       #);
     ChangeDisplay::< 
       (# SimpleDeclDisplay: @integer; theNames: ^betaGram.Names
       enter SimpleDeclDisplay
       <<SLOT SimpleAttributeDeclChangeDisplay:DoPart>>
       #);
     DisplayReference:< (#  do INNER #);
     displayAggregation:
       (#  <<SLOT SimpleAttrDeclDisplayAggregation:DoPart>> #);
     setUpRelations:
       (#
          theObjectSpec:
            ^mps.ast
       enter theObjectSpec[]
       <<SLOT SimpleAttrDeclSetUpRelations:DoPart>>
       #);
     onInit::<  (#  <<SLOT SimpleAttributeDeclOnInit:DoPart>> #);
     dump::< 
       (# 
       do
          <<SLOT SimpleAttributeDecldump:Descriptor>>;
          INNER
       #);
     private: @<<SLOT SimpleAttibuteDeclPrivate:Descriptor>>
  #);
SimpleNode: SimpleAttributeDecl
  (#
     onDoubleClick::< 
       (# 
       do
          <<SLOT SimpleNodeDoubleClick:Descriptor>>
       #);
     detail::<  (#  <<SLOT SimpleNodeDetail:DoPart>> #);
     Display::< 
       (# 
       do <<SLOT SimpleNodeDisplay:Descriptor>>
       #);
     Redisplay::<  (#  do <<SLOT SimpleNodeRedisplay:Descriptor>> #);
     ppAST::<  (#  <<SLOT simpleNodePPAST:DoPart>> #);
     DisplayReference::< 
       (# 
       do
          <<SLOT SimpleNodeDisplayReference:Descriptor>>;
          
       #);
     edit::<  (#  <<SLOT SimpleNodeEdit:DoPart>> #);
     onInit::< 
       (# 
       do
          UDPrivate.UDSimpleNode->UserDataInit;
          INNER
       #);
     dump::< 
       (# 
       do
          <<SLOT SimpleNodeDump:Descriptor>>;
          INNER
       #);
     
  #);
RepetitionNode:
 SimpleAttributeDecl
  (#
     onDoubleClick::< 
       (#  do <<SLOT RepetitionNodeDoubleClick:Descriptor>> #);
     Display::< 
       (# 
       do
          <<SLOT RepetitionNodeDisplay:Descriptor>>
       #);
     Redisplay::<  (#  do <<SLOT RepetitionNodeRedisplay:Descriptor>> #);
     ppAST::< 
       (# 
       <<SLOT repetitionNodePPAST:DoPart>>
       #);
     DisplayReference::< 
       (#  <<SLOT RepetitionNodeDisplayReference:DoPart>> #);
     onInit::< 
       (# 
       do
          UDPrivate.
            UDRepetitionNode->UserDataInit;
          INNER
       #);
     dump::<  (#  do 'RepetitionNode'->nodetype[] #);
     
  #);
PatternNode: DiagramNode
  (#
     Display::<  (#  <<SLOT patternNodeDisplay:DoPart>> #);
     Redisplay::< 
       (# pd: ^betaGram.PatternDecl
       <<SLOT patternNodeRedisplay:DoPart>>
       #);
     ppAST::< 
       (# pd: ^betaGram.PatternDecl; anAST: ^MPS.AST; tmpText: ^text
       <<SLOT patternNodeDoDisplay:DoPart>>
       #);
     onDoubleClick::< 
       (# 
       <<SLOT patternNodeOnDoubleClick:DoPart>>
       #);
     EqualDescriptor::<  (#  <<SLOT patternNodeEqualDescriptor:DoPart>> #);
     detail::< 
       (# 
       do
          <<SLOT PatternNodeDetail:Descriptor>>;
          
       #);
     DisplayReferences:
       (#  do <<SLOT PatternNodeDisplayReferences:Descriptor>>;  #);
     setupAssociation:
       (# 
       do
          <<SLOT PatternNodeSetupAssociation:Descriptor>>
       #);
     edit::<  (#  <<SLOT PatternNodeEdit:DoPart>> #);
     onInit::< 
       (# 
       <<SLOT PatternNodeOnInit:DoPart>>
       #);
     dump::< 
       (# 
       <<SLOT PatternNodeDump:DoPart>>
       #);
     
  #);
VirtualNode: PatternNode
  (#
     ppAST::< 
       (#
          vd: ^betaGram.VirtualDecl;
          a: ^MPS.AST;
          theUnExpObjSpec: ^mps.unexpanded;
          aName: ^betaGram.NameApl;
          theAppl: ^mps.nameappl
       <<SLOT virtualNodeDoDisplay:DoPart>>
       #);
     onInit::< 
       (# 
       <<SLOT virtualNodeOnInit:DoPart>>
       #);
     dump::<  (#  <<SLOT virtualNodeDump:DoPart>> #)
  #);
BindingNode: VirtualNode
  (#
     ppAST::< 
       (# bd: ^betaGram.BindingDecl
       <<SLOT bindingNodeDoDisplay:DoPart>>
       #);
     onInit::<  (#  <<SLOT bindingNodeOnInit:DoPart>> #);
     dump::< 
       (# 
       <<SLOT BindingNodedump:DoPart>>
       #)
  #);
FinalNode:
 VirtualNode
  (#
     ppAST::< 
       (# fd: ^betaGram.FinalDecl <<SLOT finalNodeDoDisplay:DoPart>> #);
     onInit::< 
       (# 
       <<SLOT finalNodeOnInit:DoPart>>
       #);
     dump::< 
       (# 
       <<SLOT FinalNodeDump:DoPart>>
       #)
  #);
NonTerminalNode: AbstractNode
  (#
     unExp: ^mps.unexpanded;
     synCatName: @ReferenceUserData (# Type::< Text #);
     synCatNo: @IntegerUserData;
     onSelect::<  (#  do disableEditName #);
     onInit::<  (#  do <<SLOT NonTerminalNodeInit:Descriptor>> #);
     display::< 
       (# 
       enter unexp[]
       do
          <<SLOT NonTerminalNodeDisplay:Descriptor>>
       #);
     redisplay::< 
       (# 
       enter unexp[]
       do <<SLOT NonTerminalNodeRedisplay:Descriptor>>; 
       #);
     onDoubleClick::< 
       (# 
       do
          <<SLOT NonTerminalDoubleClick:Descriptor>>
       #);
     detail::<  (#  do 'Detail the nonterminal'->putline #);
     abstract::<  (#  do 'Abstract the nonterminal'->putline #);
     GetGroup::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none
           // true then
                (#
                   fd: ^FragmentDiagram; theDummyFragNode: ^PatternDiagramNode
                do
                   (theDiagram).theFragmentNode->theDummyFragNode[];
                   theDummyFragNode.theDiagram->fd[];
                   fd.theGroup->fg[];
                   
                #);
              
           else
              'DiagramNode: GetGroup: no FragmentNode'->screen.putline
          if);
          
       #);
     GetFragment::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none
           // true then
                (# fn: ^FragmentNode; 
                do (theDiagram).theFragmentNode->fn[]; fn.theFragment->f[]; 
                #);
              
           else
              'DiagramNode: GetFragment: no FragmentNode'->screen.putline
          if);
          
       #);
     theSifEditor::< 
       (# 
       do
          (if (theDiagram).theFragmentNode <> none then
              (if se[] = none then
                    (# fn: ^FragmentNode; 
                    do
                       (theDiagram).theFragmentNode->fn[];
                       fn.SifEditorInstance[]->se[];
                       
                    #);
                  
               else
                    (# fn: ^FragmentNode; 
                    do
                       (theDiagram).theFragmentNode->fn[];
                       se[]->fn.SifEditorInstance[];
                       
                    #);
                  
              if);
              
           else
              'DiagramNode: theSifEditor: no FragmentNode'->screen.putline
          if);
          
       #);
     dump::<  (#  do <<SLOT NonTerminalNodeDump:Descriptor>>; INNER #);
     
  #);
SlotNode: PatternDiagramNode
  (#
     unExp: ^mps.unexpanded;
     display::< 
       (# pos: @Point; 
       enter (pos,unExp[])
       do
          <<SLOT SlotNodeDisplay:Descriptor>>;
          
       #);
     onDoubleClick::<  (#  <<SLOT SlotNodeOnDoubleClick:DoPart>> #);
     abstract::< 
       (# 
       <<SLOT SlotNodeAbstract:DoPart>>
       #);
     detail::<  (#  <<SLOT SlotNodeDetail:DoPart>> #);
     onRemove::< 
       (#  <<SLOT SlotNodeOnRemove:DoPart>> #);
     onSelect::<  (#  <<SLOT SlotNodeOnSelect:DoPart>> #);
     GetGroup::< 
       (# 
       <<SLOT SlotNodeGetGroup:DoPart>>
       #);
     GetFragment::<  (#  <<SLOT SlotNodeGetFragment:DoPart>> #);
     theSifEditor::< 
       (# 
       <<SLOT SlotNodeTheSifEditor:DoPart>>
       #);
     dump::<  (#  <<SLOT SlotNodeDump:DoPart>> #);
     onInit::< 
       (#  <<SLOT SlotNodeOnInit:DoPart>> #);
     
  #);
(* Mark nodes: for comments and Dexter anchors *)
(* Mark nodes: for comments and Dexter anchors *)
MyCommentNode: CommentNode (* to display the comment *)
  (#
     theMarkNode: @ReferenceUserData (# Type::< CommentMark #);
     onInit::<  (#  do <<SLOT MyCommentNodeOnInit:Descriptor>> #);
     onRemove::< 
       (# 
       do
          <<SLOT CommentNodeOnRemove:Descriptor>>
       #);
     deactivate::<  (#  do <<SLOT CommentNodeDeactivate:Descriptor>> #);
     
  #);
CommentMark: MarkNode
  (#
     open: @BooleanUserData;
     theComment: ^mps.LexemText;
     theCommentNode:
       @ReferenceUserData (# Type::< MyCommentNode #);
     theConn: @ReferenceUserData (# Type::< Connector #);
     display::< 
       (# theCom: ^mps.lexemtext
       enter theComment[]
       do <<SLOT CommentNodeDisplay:Descriptor>>; 
       #);
     activate::< 
       (# 
       do
          <<SLOT CommentMarkActivate:Descriptor>>
       #);
     deactivate::<  (#  do <<SLOT CommentMarkDeactivate:Descriptor>> #);
     onInit::< 
       (# 
       do
          <<SLOT CommentMarkOnInit:Descriptor>>
       #);
     onRemove::<  (#  do <<SLOT CommentMarkOnRemove:Descriptor>> #);
     onDoubleClick::< 
       (# 
       do
          <<SLOT CommentMarkDoubleClick:Descriptor>>
       #);
     onSelect::<  (#  do <<SLOT CommentMarkSelect:Descriptor>> #);
     
  #);
AnchorMark: MarkNode
  (#
     display::< 
       (# 
       do
          <<SLOT AnchorMarkDisplay:Descriptor>>
       #);
     onInit::<  (#  do <<SLOT AnchorMarkOnInit:Descriptor>> #);
     onDoubleClick::< 
       (# 
       do
          <<SLOT AnchorMarkDoubleClick:Descriptor>>
       #);
     activate::<  (#  do <<SLOT AnchorMarkActivate:Descriptor>> #);
     deactivate::< 
       (# 
       do
          <<SLOT AnchorMarkDeactivate:Descriptor>>
       #);
     
  #);
(* CONNECTORS *)
  

-- PatternDiagrams: Descriptor --
(#
   theList: @DiagramList;
   AssociationList: @Set
     (#
        element::< Ends;
        equal::  (#  <<SLOT AssociationListEqual:DoPart>> #);
        Ends:
          (#
             left,right,leftMulFrom,
               leftMulTo,rightMulFrom,rightMulTo,associationPattern: @integer;
             leftFrag,rightFrag,associationFrag: ^text;
             save: (#  <<SLOT AssociationListSaveEnds:DoPart>> #);
             dump:
               (# 
               <<SLOT AssociationListDumpEnds:DoPart>>
               #)
          #);
        insert:
          (#
             left,right,associationPattern: ^betaGram.AttributeDecl;
             leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer;
             theElm: ^Ends
          enter
          (left[],right[],leftMulFrom,leftMulTo,rightMulFrom,rightMulTo,
           associationPattern[])
          <<SLOT AssociationListInsert:DoPart>>
          #);
        remove:
          (# anAST: ^MPS.AST
          enter anAST[]
          <<SLOT AssociationListRemove:DoPart>>
          #);
        update:
          (# anAST: ^MPS.AST
          enter anAST[]
          <<SLOT AssociationListUpdate:DoPart>>
          #);
        updateElement:
          (#
             left,right,associationPattern,
               newLeft,newRight,newAssociationPattern: ^betaGram.AttributeDecl;
             leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer
          enter
          (left[],right[],associationPattern[],newLeft[],newRight[],
           newAssociationPattern[],leftMulFrom,leftMulTo,rightMulFrom,
           rightMulTo)
          <<SLOT AssociationListUpdateElement:DoPart>>
          #);
        attributeID: @integer;
        UDStart:
          (#  exit 14999 #);
        save:
          (#
             noOfAttr: @integer;
             ok: @boolean
          <<SLOT AssociationListSave:DoPart>>
          #);
        resetSaved:
          (# noOfAttr: @integer; ok: @boolean
          <<SLOT AssociationListResetSaved:DoPart>>
          #);
        load:
          (#
             noOfAttr: @integer;
             i: @integer;
             ok: @boolean;
             theElm: ^element
          <<SLOT AssociationListLoad:DoPart>>
          #);
        dump: (#  <<SLOT AssociationListDump:DoPart>> #)
     #);
   InheritanceList: @Set
     (#
        element::< Ends;
        Ends:
          (#
             subFrag,superFrag: ^text;
             sub,super: @integer;
             save:
               (# 
               <<SLOT InheritanceListSaveEnds:DoPart>>
               #)
          #);
        equal::<  (#  <<SLOT InheritanceListEqual:DoPart>> #);
        insert:
          (#
             subpattern,superpattern:
               ^betaGram.AttributeDecl;
             theElm: ^Ends
          enter
          (subpattern[],superpattern[])
          <<SLOT InheritanceListInsert:DoPart>>
          #);
        remove:
          (# anAST: ^MPS.AST
          enter anAST[]
          <<SLOT InheritanceListRemove:DoPart>>
          #);
        update:
          (# anAST: ^MPS.AST
          enter anAST[]
          <<SLOT InheritanceListUpdate:DoPart>>
          #);
        attributeID: @integer;
        UDStart: (#  exit 15999 #);
        save:
          (# noOfAttr: @integer; ok: @boolean
          <<SLOT InheritanceListSave:DoPart>>
          #);
        resetSaved:
          (#
             noOfAttr: @integer;
             ok: @boolean
          <<SLOT InheritanceListResetSaved:DoPart>>
          #);
        load:
          (#
             noOfAttr: @integer; i: @integer; ok: @boolean; theElm: ^element
          <<SLOT InheritanceListLoad:DoPart>>
          #);
        getSubPatternDiagrams:
          (#
             theDiagram: ^Diagram;
             theParentListDiagram:
               ^ListDiagram;
             theDiagramNode: ^theParentListDiagram.DiagramNode;
             superIndex: @integer;
             superFrag: ^text;
             aList: ^DiagramList;
             ff: ^mps.fragmentForm;
             theDecl: ^betaGram.AttributeDecl;
             anExp: ^mps.expanded
          enter theDiagram[]
          <<SLOT InheritanceListGetSubPatternDiagrams:DoPart>>
          exit aList[]
          #);
        getSortableSubPatternDiagrams:
          (#
             theDiagram: ^Diagram;
             theParentListDiagram: ^ListDiagram;
             theDiagramNode: ^theParentListDiagram.DiagramNode;
             superIndex: @integer;
             superFrag: ^text;
             aList: ^SortableDiagramList;
             ff: ^mps.fragmentForm;
             theDecl: ^betaGram.AttributeDecl;
             anExp: ^mps.expanded
          enter theDiagram[]
          <<SLOT InheritanceListGetSortableSubPatternDiagrams:DoPart>>
          exit aList[]
          #);
        getSuperPatternDiagram:
          (#
             theDiagram,superDiagram: ^Diagram;
             theParentListDiagram: ^ListDiagram;
             theDiagramNode: ^theParentListDiagram.DiagramNode;
             subIndex: @integer;
             subFrag: ^text;
             ff: ^mps.fragmentForm;
             theDecl: ^betaGram.AttributeDecl;
             anExp: ^mps.expanded
          enter theDiagram[]
          <<SLOT InheritanceListGetSuperPatternDiagram:DoPart>>
          exit superDiagram[]
          #);
        dump: (#  <<SLOT InheritanceListDump:DoPart>> #)
     #);
   AggregationList: @Set
     (#
        element:: Ends;
        equal:: 
          (# 
          <<SLOT AggregationListEqual:DoPart>>
          #);
        Ends:
          (#
             left,right,leftMulFrom,leftMulTo,rightMulFrom,rightMulTo:
               @integer;
             leftFrag,rightFrag: ^text;
             save: (#  <<SLOT AggregationListSaveEnds:DoPart>> #);
             dump:
               (# 
               <<SLOT AggregationListDumpEnds:DoPart>>
               #)
          #);
        insert:
          (#
             left,right: ^betaGram.AttributeDecl;
             leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer;
             theElm: ^Ends
          enter (left[],right[],leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
          <<SLOT AggregationListInsert:DoPart>>
          #);
        remove:
          (# anAST: ^MPS.AST
          enter anAST[]
          <<SLOT AggregationListRemove:DoPart>>
          #);
        update:
          (# anAST: ^MPS.AST
          enter anAST[]
          <<SLOT AggregationListUpdate:DoPart>>
          #);
        updateElement:
          (#
             left,right,newLeft: ^betaGram.AttributeDecl;
             leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer
          enter
          (left[],right[],newLeft[],leftMulFrom,leftMulTo,rightMulFrom,
           rightMulTo)
          <<SLOT AggregationListUpdateElement:DoPart>>
          #);
        attributeID: @integer;
        UDStart:
          (#  exit 17999 #);
        save:
          (#
             noOfAttr: @integer;
             ok: @boolean
          <<SLOT AggregationListSave:DoPart>>
          #);
        resetSaved:
          (# noOfAttr: @integer; ok: @boolean
          <<SLOT AggregationListResetSaved:DoPart>>
          #);
        load:
          (#
             noOfAttr: @integer;
             i: @integer;
             ok: @boolean;
             theElm: ^element
          <<SLOT AggregationListLoad:DoPart>>
          #);
        dump: (#  <<SLOT AggregationListDump:DoPart>> #)
     #);
   oldSelection: ^PatternDiagramNode;
   astUtils: @
     (#
        getEnclosingDecl:
          (#
             anAST,tmpAST: ^mps.ast;
             enclosingDecl:
               ^betaGram.AttributeDecl
          enter anAST[]
          <<SLOT astUtilsGetEnclosingDecl:DoPart>>
          exit enclosingDecl[]
          #);
        getPrefixName:
          (#
             od: ^betaGram.ObjectDescriptor;
             prefixName: ^text;
             anAST: ^mps.ast;
             thePrefix: ^betaGram.prefix;
             theNameApl: ^betaGram.NameApl
          enter od[]
          <<SLOT astUtilsGetPrefixName:DoPart>>
          exit prefixName[]
          #);
        getPrefixNameOnDecl:
          (#
             theDeclaration:
               ^betaGram.AttributeDecl;
             name: ^text;
             anAST: ^mps.ast;
             exp: ^mps.expanded
          enter theDeclaration[]
          <<SLOT astUtilsGetPrefixNameOnDecl:DoPart>>
          exit name[]
          #);
        getDoPart:
        (* if do-part exists returns ref. to do-part
         or if SLOT returns ref. to the unexp that
         corresponds to SLOT def. *)
          (#
             od: ^betaGram.ObjectDescriptor;
             dp: ^mps.ast;
             mp: ^betaGram.MainPart;
             ap: ^betaGram.ActionPart;
             anAST: ^mps.ast;
             unexp: ^mps.unexpanded
          enter od[]
          <<SLOT astUtilsGetDoPart:DoPart>>
          exit dp[]
          #);
        getCommentPos:
          (#
             theDeclaration:
               ^betaGram.AttributeDecl;
             pos: @integer
          enter theDeclaration[]
          <<SLOT astUtilsGetCommentPos:DoPart>>
          exit pos
          #);
        skipLeadingBlanks:
          (# commentText: ^text; newText: @text; skipLeadingBlanks: @boolean
          enter commentText[]
          <<SLOT astUtilsSkipLeadingBlanks:DoPart>>
          exit newText
          #)
     #);
   utils: @
     (#
        isAssociationName:
          (# theName: ^text
          enter theName[]
          exit
          ('OneToOneAssociation'
             ->theName.equalNCS) or
          ('OneToManyAssociation'
             ->theName.equalNCS) or
          ('ManyToManyAssociation'
             ->theName.equalNCS)
          #);
        isEmbedAssociationName:
          (# theName: ^text
          enter theName[]
          exit
          ('AssociationOne'
             ->theName.equalNCS) or
          ('AssociationMany'
             ->theName.equalNCS)
          #);
        isContainerName:
          (# theName: ^text
          enter theName[]
          exit
          ('arrayContainer'
             ->theName.equalNCS) or
          ('hashTable'
             ->theName.equalNCS) or
          ('extensibleHashTable'
             ->theName.equalNCS) or
          ('List'->theName.equalNCS) or
          ('Set'->theName.equalNCS) or ('MultiSet'->theName.equalNCS) or
          ('Stack'->theName.equalNCS) or ('Queue'->theName.equalNCS) or
          ('PriorutyQueue'->theName.equalNCS)
          #);
        getAssMul:
          (#
             name: ^text;
             leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer
          enter name[]
          do
             (if true
              // ('OneToOneAssociation'->name.equalNCS) then
                 (1,1,1,1)->(leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
              // ('OneToManyAssociation'->name.equalNCS) then
                 (1,1,- 1,- 1)->(leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
              // ('ManyToManyAssociation'->name.equalNCS) then
                 (- 1,- 1,- 1,- 1)
                   ->(leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
             if)
          exit (leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
          #);
        getEmbedAssMul:
          (#
             leftName,rightName: ^text;
             leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer
          enter (leftName[],rightName[])
          do
             (if true
              // 'AssociationOne'->leftName.equalNCS then
                 (1,1)->(leftMulFrom,leftMulTo)
              // 'AssociationMany'->leftName.equalNCS then
                 (- 1,- 1)->(leftMulFrom,leftMulTo)
             if);
             (if true
              // 'AssociationOne'->rightName.equalNCS then
                 (1,1)->(rightMulFrom,rightMulTo)
              // 'AssociationMany'->rightName.equalNCS then
                 (- 1,- 1)->(rightMulFrom,rightMulTo)
             if)
          exit (leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
          #)
     #);
   NextFreeLine: @Integer;
   NextFreeColumn: @Integer;
   SecondFreeLine: @Integer;
   SecondFreeColumn: @Integer;
   Detailer: ^PatternDiagramNode;
   addAfterNode: ^PatternDiagramNode;
   newNode: ^PatternDiagramNode;
   interactiveNewDiagram: ^Diagram;
   redisplayRelations:
     (#  <<SLOT patternDiagramsRedisplayRelations:DoPart>> #);
   parseDiagram:
     (# 
     <<SLOT patternDiagramsParseDiagram:DoPart>>
     #);
   private: @<<SLOT patternDiagramsPrivate:Descriptor>>
#)  

-- designInterfacePrivate: Descriptor --
(#  #)  

