ORIGIN '../gppinterface';
BODY 'gppinterfacebody'
     'diagrambody'
     'patterndiagrambody'
     'abstractnodebody'
     'fragmentnodebody'
     'marknodebody'
     'simplenodebody'
     'nonterminalnodebody';
INCLUDE '~beta/containers/v1.4/list'
        '../prettyprintersetup'
        '../propertydiagrams'
        'userdataprivate';
(* This fragment group defines patterns visible to all bodies,
 * but not visible in the interface
 *)
-- OADPageLib: Attributes --
scrollIntoView:
  (# theObject: ^designObject;
  enter theObject[]
  do
     (if doScrollIntoView then
         theObject[]->currentObject (# do true->autoPan #);
     if);
  #);
GetPrefix:
  (#
     theDescriptor: ^betaGram.ObjectDescriptor;
     tempAst: ^ast;
     pref: ^betaGram.prefix;
     ad: ^betaGram.attributeDenotation;
     thisPrefix: ^betaGram.ObjectDescriptor;
  enter theDescriptor[]
  do
     theDescriptor.getPrefixOpt->tempAst[];
     (if tempAst.kind
      // kinds.interior then
         tempAst[]->pref[];
         pref.getAttributeDenotation->tempAst[];
         (if tempAst.kind
          // kinds.interior then
             tempAst[]->ad[]; ad.findDescriptor->thisPrefix[];
         if);
     if);
  exit thisPrefix[]
  #);
(* LIST HANDLING *)
DiagramList: ContainerList (* list of diagrams on a page *)
  (#
     element::<  (# index: @Integer; e: ^Diagram #);
     myFind: find
       (#
          i: @Integer;
          predicate::<  (# do (i = current.index)->value #);
       enter i
       #);
     findPD:
       (# aPD: ^Element; aDiagram: ^Diagram;
       enter myFind->aPD[]
       do (if aPD[] <> none // true then aPD.e[]->aDiagram[]; if);
       exit aDiagram[]
       #);
     insertPD:
       (# aPD: ^Element; index: @Integer; e: ^Diagram;
       enter (index,e[])
       do &Element[]->aPD[]; (index,e[])->(aPD.index,aPD.e[]); aPD[]->append;
       #);
     deletePD: (# enter myFind->at->delete #);
     deleteProp:
       (#
          findProp:
            (# p: ^Diagram; aPD: ^Element;
            enter p[]
            do
               scanner: scan
                 (#
                 do
                    (if current.e[]
                     // p[] then current[]->aPD[]; leave scanner
                    if);
                 #);
            exit aPD[]
            #);
       enter findProp->at->delete
       #);
     GetSubPatternDiagrams:
       (#
          theDiagram,aPatternDiagram: ^PatternDeclDiagram;
          aList: ^DiagramList;
       enter theDiagram[]
       do
          &DiagramList[]->aLIst[];
          scan
            (#
            do
               (if current.e.struc <= PatternDeclDiagram##
                // true then
                   current.e[]->aPatternDiagram[];
                   (if aPatternDiagram.thePrefix <> none
                    // true then
                       (if
                       aPatternDiagram.thePrefix
                         ->(theDiagram.theDescriptor).equal
                        // true then current[]->aList.append;
                       if)
                   if)
               if)
            #);
       exit aList[]
       #);
     scanPatternDiagrams: scan
       (# thisDiagram: ^PatternDeclDiagram;
       do
          (if current.e.struc <= PatternDeclDiagram##
           // true then current.e[]->thisDiagram[]; INNER ;
          if)
       #);
     scanPropertyDiagrams: scan
       (# thisDiagram: ^SimplePropertyDiagram;
       do
          (if current.e.struc <= SimplePropertyDiagram##
           // true then current.e[]->thisDiagram[]; INNER ;
          if)
       #);
  #);  

-- DiagramLib: Attributes --
DisplayAst:
  (# anAST: ^AST; pos: @Point;
  enter (anAST[],pos)
  do <<SLOT DisplayAST:ObjectDescriptor>>;
  exit pos
  #);
scanAttributeDecls:
  (#
     theAtt: ^betaGram.Attributes;
     anAst: ^ast;
     ndl: ^betaGram.names;
     unExp: ^unExpanded;
     thisAttribute:<
       (# nd: ^betaGram.nameDcl
       enter nd[]
       do INNER
       #);
     thisUnExp:<
       (# unExp: ^unExpanded
       enter unExp[]
       do INNER
       #);
     thisOptional:<
       (# opt: ^Optional
       enter opt[]
       do INNER
       #);
     thisSlot:<
       (# theSlot: ^SlotDesc
       enter theSlot[]
       do INNER
       #);
  enter theAtt[]
  do
     (if switch[1]
      // true then
         'scanAttributeDecls'
           ->screen.putline;
     if);
     theAtt.scan
       (# att: ^betaGram.attributeDecl
       do
          (if switch[1]
           // true then '*'->screen.put
          if);
          (if current.kind
           // kinds.interior then
              current[]->att[];
              att.getSon1->anAst[];
              (if switch[1]
               // true then
                  'interior: '
                    ->screen.puttext;
                  anAst.symbol
                    ->screen.putint;
                  screen.newline;
              if);
              (if anAst.symbol
               // betaGram.names then
                  anAst[]->ndl[];
                  ndl.scan
                    (#
                    do
                       current[]
                         ->thisAttribute
                    #)
              if)
           // kinds.unExpanded then
              (if switch[1]
               // true then
                  'unExpanded: '
                    ->screen.puttext;
              if);
              current[]->unExp[];
              (if unExp.isSlot
               // true then
                  (if switch[1]
                   // true then
                      'Slot'
                        ->screen.putline;
                  if);
                  unExp.theSlot->thisSlot;
               else
                  (if switch[1]
                   // true then
                      screen.newline;
                  if);
                  unExp[]->thisUnExp;
              if)
           // kinds.optional then
              (if switch[1]
               // true then
                  'optional'
                    ->screen.putline;
              if);
              current[]->thisOptional;
          if)
       #);
     (if switch[1]
      // true then 'DONE'->screen.putline
     if);
  #);
CountAttributes:
  (#
     obj: ^betaGram.ObjectDescriptor;
     main: ^betaGram.MainPart;
     a: ^AST;
     i: @Integer;
  enter obj[]
  do
     (if switch[1]
      // true then
         'CountAttributes '->screen.puttext
     if);
     (if obj[] <> none
      // true then
         obj.getMainPart->main[];
         main.getAttributes->a[];
         (if a[]
          // none then
             'Attribute error: cannot get attributes from descriptor: '
               ->puttext;
          else
             (if a.kind
              // kinds.interior then
                 (if switch[1] // true then 'scanning '->screen.puttext if);
                 a[]
                   ->scanAttributeDecls
                     (#
                        thisAttribute::<  (# do i+1->i #);
                        thisOptional::<  (# do i+1->i #);
                        thisUnExp::<  (# do i+1->i #);
                     #);
             if)
         if)
     if);
     (if switch[1] // true then screen.newline if);
  exit i
  #);
CheckKeyWord:
  (#
     node: ^ast;
     keyword: ^text;
     found: @boolean;
     theCom: ^comment;
     theComText,nextWord: ^text;
  enter (node[],keyword[])
  do
     (if node.hasComment
      // true then
         node.getComment->theCom[];
         theCom.getText->theComText[];
         theComText.reset;
         search:
           (#
           do
              theComText.getAtom->nextWord[];
              (if true
               // keyWord[]->nextWord.equal then true->found;
               else
                  (if theComText.eos // false then restart search if);
              if);
           #);
     if);
  exit found
  #);
makeNonTerminalSymbol:
  (# symbolName: ^Text
  enter symbolName[]
  do '<'->symbolName.prepend; '>'->symbolName.append
  exit symbolName[]
  #);
(****************** DIAGRAM NODES ************************)
AbstractNode: PatternDiagramNode
  (#
     theName: @ReferenceUserData (# Type::< Text #);
     (* the name of THIS(AbstractNode) (Fragment or Declaration) *)
     currentDecomposDiagram: @DiagramReferenceUserData
       (# Type::< PatternDiagram #);
     (* if exists => theNode is detailed *)
     decomposDiagrams: @containerlist (# element::< PatternDiagram #);
     PatternDiagReference: LocalNodesReferenceUserData
       (# Type::< PatternDiagram #);
     theTreeConn: ^TreeConnector;
     (* the connector to parent if any *)
     theDexterAnchor: ^AnchorMark;
     onSelect::< 
       (#
       do
          (PatternDiagrams.oldSelection[],THIS(AbstractNode)[])->changedFocus;
          THIS(AbstractNode)[]->PatternDiagrams.oldSelection[];
       #);
     onRemove::< (* called when THIS(DiagramNode) is deleted *) 
       (# do <<SLOT AbstractNodeRemove:ObjectDescriptor>>; #);
     Display::< 
       (# t: @Text; pos: @Point;
       enter pos
       do
          <<SLOT AbstractNodeDisplay:ObjectDescriptor>>;
       #);
     Redisplay::< 
       (# t: @Text;
       do <<SLOT AbstractNodeRedisplay:ObjectDescriptor>>;
       #);
     ConcludeDisplay::< 
       (#
       do
          INNER ;
          <<SLOT AbstractNodeConcludeDisplay:ObjectDescriptor>>;
       #);
     MakeAnchor::< 
       (# do INNER ; <<SLOT AbstractNodeMakeAnchor:ObjectDescriptor>> #);
     detail::< 
       (#
          theAST: ^AST
          (* the AST to be detailed *)
       do <<SLOT AbstractNodeDetail:ObjectDescriptor>>;
       #);
     abstract::<
     (* if detailed then abstract the decompos diagram *) 
       (# do <<SLOT AbstractNodeAbstract:ObjectDescriptor>>; #);
     abstractedFromDiagramBelow::<
     (* when THIS(DiagramNode) has been abstrated from a diagram below *) 
       (#
       do <<SLOT AbstractNodeAbstractedFromDiagramBelow:ObjectDescriptor>>;
       #);
     hasAttributes: @BooleanUserData;
     CheckForAttributes:< (# do INNER exit hasAttributes #);
     onInit::< 
       (#
       do
          UDPrivate.UDAbstractNode->UserDataInit;
          theName.Init;
          currentDecomposDiagram.Init;
          hasAttributes.Init;
          (if initialisingSaved then gppProp.fontSize->theText.size if);
          INNER
       #)
  #);
(******************** For FragmentDiagrams *********************)
FragmentNode: AbstractNode
  (#
     theFragment: @FragReferenceUserData (# Type::< FragmentForm #);
     theForm: @ASTReferenceUserData (# Type::< betaGram.BetaForm #);
     sifEditorInstance: @Integer;
     (* if sif is open refers to the sif editor of
      * THIS(FragmentNode)
      *)
     display::< 
       (#
       enter theFragment
       do <<SLOT FragmentNodeDisplay:ObjectDescriptor>>;
       #);
     ConcludeDisplay::< 
       (# do INNER #);
     onDoubleClick::< 
       (#
       do
          false->IndicateSelection;
          detail
       #);
     detail::<  (# do INNER #);
     GetGroup::< 
       (# fd: ^FragmentDiagram;
       do theDiagram->fd[]; fd.theGroup->fg[];
       #);
     GetFragment::<  (# do theFragment->f[]; #);
     SifEditorInstanceNo::< 
       (#
       do
          (if no
           // 0 then SifEditorInstance->no;
           else
              no->SifEditorInstance;
          if);
       #);
     CheckForAttributes::<  (# do true->hasAttributes #);
     ReReadAST:<
       (# oldFF,newFF: ^fragmentForm; oldObject: ^AbstractNode;
       enter (oldFF[],oldObject[])
       do <<SLOT FragmentReReadAST:ObjectDescriptor>>;
       exit newFF[]
       #);
     onInit::< 
       (#
       do
          UDPrivate.UDFragmentNode
            ->UserDataInit;
          theForm.Init;
          theFragment.Init;
          INNER
       #);
  #);
AttributesNode: FragmentNode
  (#
     display::< 
       (#
       do ': Attributes'->t.append;
       #);
     detail::< 
       (#
       do
          <<SLOT AttributesNodeDetail:ObjectDescriptor>>
       #);
     onInit::<  (# do UDPrivate.UDAttributesNode->UserDataInit; INNER #);
  #);
DescriptorNode: FragmentNode
  (#
     display::<  (# do ': Descriptor'->t.append; #);
     detail::<  (# do <<SLOT DescriptorNodeDetail:ObjectDescriptor>> #);
     onInit::< 
       (#
       do
          UDPrivate.
            UDDescriptorNode->UserDataInit;
          INNER
       #);
  #);
DiagramNode: AbstractNode
  (#
     theDeclaration: @ASTReferenceUserData
       (# Type::< betaGram.AttributeDecl #);
     theObjectDescriptor: @ASTReferenceUserData
       (# Type::< betaGram.ObjectDescriptor #);
     lexemIndex: @IntegerUserData;
     (* > 0 if the astnode is a lexemtext and can be modified *)
     CheckForAttributes::< 
       (#
       do (theObjectDescriptor->CountAttributes) > 0->hasAttributes;
       #);
     DesignText::< 
       (#
          ModeOn::<  (# #);
          ModeOff::< 
            (# t: ^Text
            do
               theText.get->t;
               t[]->theName;
               (THIS(DiagramNode)[],lexemindex,theName)->LexemExpand;
               INNER ;
            #);
       #);
     Display::< 
       (# anAST: ^AST; (* either theName or an unExp *)
       enter (theDeclaration,anAST[])
       do <<SLOT DiagramNodeDisplay:ObjectDescriptor>>;
       #);
     Redisplay::< 
       (#
          anAST: ^AST;
          (* either theName or an unExp *)
       enter (theDeclaration,anAST[])
       do <<SLOT DiagramNodeReDisplay:ObjectDescriptor>>
       #);
     ConcludeDisplay::< 
       (#
       do
          <<SLOT DiagramNodeConcludeDisplay:ObjectDescriptor>>;
          INNER
       #);
     EqualDescriptor:<
       (# aDesc: ^betaGram.ObjectDescriptor; b: @Boolean;
       enter aDesc[]
       do INNER
       exit b
       #);
     detail::<  (# do <<SLOT DiagramNodeDetail:ObjectDescriptor>> #);
     getASTNode::<
     (* return the AST node THIS(title) is generated from *) 
       (# do theDeclaration->anAST[]; INNER #);
     GetGroup::<  (# do <<SLOT DiagramNodeGetGroup:ObjectDescriptor>> #);
     GetFragment::< 
       (#
       do
          <<SLOT DiagramNodeGetFragment:ObjectDescriptor>>
       #);
     SifEditorInstanceNo::< 
       (# do <<SLOT SifEditorInstanceNo:ObjectDescriptor>> #);
     onInit::< 
       (#
       do
          theDeclaration.Init;
          theObjectDescriptor.Init;
          lexemIndex.Init;
          INNER
       #);
  #);
SimpleAttributeDecl: DiagramNode (* SimpleDecl or RepetitionDecl *)
  (#
     declTypeNode: @ReferenceUserData (# Type::< PatternDiagramNode #);
     (* the node displaying the type of this simple attribute declaration *)
     theReferenceSpec: @ASTReferenceUserData
       (# Type::< betaGram.referenceSpecification #);
     Display::< 
       (#
          theObjectSpec: ^AST;
          theUnExpRefSpec: ^unExpanded
          (* if ReferenceSpecification part of theDeclaration not yet expanded *)
       do
          INNER ;
          (* make theObjectSpec and theReferenceSpec *)
          <<SLOT SimpleAttrDeclDisplay:ObjectDescriptor>>;
       #);
     Redisplay::< 
       (#
          theObjectSpec: ^AST;
          theUnExpRefSpec: ^unExpanded
          (* if ReferenceSpecification part of theDeclaration not yet expanded *)
       do
          INNER ;
          (* make theObjectSpec and theReferenceSpec *)
          <<SLOT SimpleAttrDeclReDisplay:ObjectDescriptor>>;
       #);
     onInit::< 
       (#
       do
          UDPrivate.UDSimpleAttributeDecl->UserDataInit;
          declTypeNode.Init;
          theReferenceSpec.Init;
          INNER
       #);
  #);
SimpleNode: SimpleAttributeDecl
  (#
     onDoubleClick::< 
       (# do <<SLOT SimpleNodeDoubleClick:ObjectDescriptor>> #);
     Display::< 
       (#
       do
          <<SLOT SimpleNodeDisplay:ObjectDescriptor>>
       #);
     Redisplay::<  (# do <<SLOT SimpleNodeRedisplay:ObjectDescriptor>> #);
     onInit::<  (# do UDPrivate.UDSimpleNode->UserDataInit; INNER #);
  #);
RepetitionNode: SimpleAttributeDecl
  (#
     onDoubleClick::< 
       (# do <<SLOT RepetitionNodeDoubleClick:ObjectDescriptor>> #);
     Display::< 
       (#
       do
          <<SLOT RepetitionNodeDisplay:ObjectDescriptor>>
       #);
     onInit::<  (# do UDPrivate.UDRepetitionNode->UserDataInit; INNER #);
  #);
PatternNode: DiagramNode
  (#
     Display::< 
       (# pd: ^betaGram.PatternDecl; anAST: ^AST;
       do
          (if (theDeclaration).struc <= betaGram.PatternDecl##
           // true then
              theDeclaration->pd[];
              (*(if (pd[],'(#Class#)')->checkKeyword //true then 
               ':  Class'->t.append;
               else
               ':  Proc'->t.append;
               if);
               * *)
              pd.getObjectDescriptor->anAST[];
              (if anAST.kind
               // kinds.interior then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      '  ...'->t.puttext;
                  if);
              if);
              pd->SetRegionType;
          if);
          INNER ;
       #);
     Redisplay::< 
       (# pd: ^betaGram.PatternDecl; anAST: ^AST;
       do
          (if (theDeclaration).struc <= betaGram.PatternDecl##
           // true then
              theDeclaration->pd[];
              (*(if (pd[],'(#Class#)')->checkKeyword //true then 
               ':  Class'->t.append;
               else
               ':  Proc'->t.append;
               if);
               * *)
              pd.getObjectDescriptor->anAST[];
              (if anAST.kind
               // kinds.interior then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      '  ...'->t.puttext;
                  if);
              if);
              pd->SetRegionType;
          if);
          INNER ;
       #);
     onDoubleClick::< 
       (#
       do
          false->indicateSelection;
          (if switch[1]
           // true then
              'doubleClick PatternDeclaration ID: '->puttext;
              ID->putint;
              newline;
          if);
          (if hasAttributes
           // true then detail;
           else
              (if switch[1] // true then 'no attributes'->putline if)
          if);
          INNER ;
       #);
     EqualDescriptor::< 
       (#
       do
          (if theObjectDescriptor <> none
           // true then aDesc[]->(theObjectDescriptor).equal->b;
          if);
          INNER ;
       #);
     onInit::<  (# do UDPrivate.UDPatternNode->UserDataInit; INNER #);
  #);
VirtualNode: PatternNode
  (#
     onDoubleClick::<  (# do INNER ; #);
     Display::< 
       (#
          vd: ^betaGram.VirtualDecl;
          anAST,a: ^AST;
          theUnExpObjSpec: ^unExpanded;
          aName: ^betaGram.NameApl;
          theAppl: ^NameAppl
       do
          (if (theDeclaration).struc <= betaGram.VirtualDecl##
           // true then
              theDeclaration->vd[];
              vd->SetRegionType;
              (if gppProp.SimpleDeclDisplay = gppProp.AsBetaSyntax then
                  ':< '->t.append
               else
                  (if (vd[],'(#Class#)')->checkKeyword
                   // true then ':  Virtual Class'->t.append;
                   else
                      ':  Virtual'->t.append;
                  if)
              if);
              vd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      '  ...'->t.puttext;
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // kinds.unExpanded then ': <NameAppl>'->t.append;
                   else
                  (* is a real name *)
                      a[]->theAppl[]; theAppl.getText->t.append;
                  if)
               else
                  (if anAST.kind = kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                        ->makeNonTerminalSymbol->t.append
                  if)
              if);
              (* possibly show prefix if exists *)
          if);
          (*(if theTreeConn[]//NONE then 22 -> FillType if);  make gray *)
          betaGram.VirtualDecl->SetRegionType;
          INNER ;
       #);
     Redisplay::< 
       (#
          vd: ^betaGram.VirtualDecl;
          anAST,a: ^AST;
          theUnExpObjSpec: ^unExpanded;
          aName: ^betaGram.NameApl;
          theAppl: ^NameAppl
       do
          (if (theDeclaration).struc <= betaGram.VirtualDecl##
           // true then
              theDeclaration->vd[];
              vd->SetRegionType;
              (if gppProp.SimpleDeclDisplay = gppProp.AsBetaSyntax then
                  ':< '->t.append
               else
                  (if (vd[],'(#Class#)')->checkKeyword
                   // true then ':  Virtual Class'->t.append;
                   else
                      ':  Virtual'->t.append;
                  if)
              if);
              vd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      '  ...'->t.puttext;
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // kinds.unExpanded then ': <NameAppl>'->t.append;
                   else
                  (* is a real name *)
                      a[]->theAppl[]; theAppl.getText->t.append;
                  if)
               else
                  (if anAST.kind = kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                        ->makeNonTerminalSymbol->t.append
                  if)
              if);
              (* possibly show prefix if exists *)
          if);
          (*(if theTreeConn[]//NONE then 22 -> FillType if);  make gray *)
          betaGram.VirtualDecl->SetRegionType;
          INNER ;
       #);
     onInit::<  (# do UDPrivate.UDVirtualNode->UserDataInit; INNER #);
  #);
BindingNode: PatternNode
  (#
     onDoubleClick::<  (# do INNER ; #);
     Display::< 
       (#
          bd: ^betaGram.BindingDecl;
          anAST,a: ^AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^unExpanded;
          theAppl: ^NameAppl
       do
          (if (theDeclaration).struc <= betaGram.BindingDecl##
           // true then
              theDeclaration->bd[];
              bd->SetRegionType;
              (if gppProp.SimpleDeclDisplay = gppProp.AsBetaSyntax then
                  '::< '->t.append
               else
                  (if (bd[],'(#Class#)')->checkKeyword
                   // true then ':  Bind Class'->t.append;
                   else
                      ':  Bind'->t.append;
                  if)
              if);
              bd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      '  ...'->t.puttext;
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // kinds.unExpanded then ': <NameAppl>'->t.append;
                   else
                  (* is a real name *)
                      a[]->theAppl[]; theAppl.getText->t.append;
                  if)
               else
                  (if anAST.kind = kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                        ->makeNonTerminalSymbol->t.append
                  if)
              if);
              (* possibly show prefix if exists *)
          if);
          (*if theTreeConn[]//NONE then 23 -> FillType if);   make lighter gray *)
          betaGram.BindingDecl->SetRegionType;
          INNER ;
       #);
     Redisplay::< 
       (#
          bd: ^betaGram.BindingDecl;
          anAST,a: ^AST;
          aName: ^betaGram.NameApl;
          theUnExpObjSpec: ^unExpanded;
          theAppl: ^NameAppl
       do
          (if (theDeclaration).struc <= betaGram.BindingDecl##
           // true then
              theDeclaration->bd[];
              bd->SetRegionType;
              (if gppProp.SimpleDeclDisplay = gppProp.AsBetaSyntax then
                  '::< '->t.append
               else
                  (if (bd[],'(#Class#)')->checkKeyword
                   // true then ':  Bind Class'->t.append;
                   else
                      ':  Bind'->t.append;
                  if)
              if);
              bd.getObjectSpecification->anAST[];
              (if anAST.symbol
               // betaGram.ObjectDescriptor then
                  anAST[]->theObjectDescriptor;
                  (if CheckForAttributes
                   // true then (*gppProp.AbstractedStyle -> theText.style*)
                      '  ...'->t.puttext;
                  if)
               // betaGram.NameApl then
                  anAst[]->aName[];
                  aName.getNameAppl->a[];
                  (if a.kind
                   // kinds.unExpanded then ': <NameAppl>'->t.append;
                   else
                  (* is a real name *)
                      a[]->theAppl[]; theAppl.getText->t.append;
                  if)
               else
                  (if anAST.kind = kinds.unExpanded then
                      anAST[]->theUnExpObjSpec[];
                      theUnExpObjSpec.nonTerminalSymbol->betaGram.symbolToName
                        ->makeNonTerminalSymbol->t.append
                  if)
              if);
              (* possibly show prefix if exists *)
          if);
          (*if theTreeConn[]//NONE then 23 -> FillType if);   make lighter gray *)
          betaGram.BindingDecl->SetRegionType;
          INNER ;
       #);
     onInit::<  (# do UDPrivate.UDBindingNode->UserDataInit; INNER #);
  #);
NonTerminalNode: AbstractNode
  (#
     unExp: @ASTReferenceUserData (# Type::< unexpanded #);
     synCatName: @ReferenceUserData (# Type::< Text #);
     synCatNo: @IntegerUserData;
     onInit::<  (# do <<SLOT NonTerminalNodeInit:ObjectDescriptor>> #);
     display::< 
       (#
       enter unexp
       do
          <<SLOT NonTerminalNodeDisplay:ObjectDescriptor>>
       #);
     onDoubleClick::< 
       (# do <<SLOT NonTerminalDoubleClick:ObjectDescriptor>> #);
     detail::< 
       (#
       do
          'Detail the nonterminal'->putline
       #);
     abstract::<  (# do 'Abstract the nonterminal'->putline #);
     GetGroup::< 
       (#
       do
          (if (theDiagram).theFragmentNode <> none
           // true then
                (#
                   fd: ^FragmentDiagram; theDummyFragNode: ^PatternDiagramNode
                do
                   (theDiagram).theFragmentNode->theDummyFragNode[];
                   theDummyFragNode.theDiagram->fd[];
                   fd.theGroup->fg[];
                #);
           else
              'DiagramNode: GetGroup: no FragmentNode'->screen.putline
          if);
       #);
     GetFragment::< 
       (#
       do
          (if (theDiagram).theFragmentNode <> none
           // true then
                (# fn: ^FragmentNode;
                do (theDiagram).theFragmentNode->fn[]; fn.theFragment->f[];
                #);
           else
              'DiagramNode: GetFragment: no FragmentNode'->screen.putline
          if);
       #);
     SifEditorInstanceNo::< 
       (#
       do
          (if (theDiagram).theFragmentNode <> none
           // true then
              (if no
               // 0 then
                    (# fn: ^FragmentNode;
                    do
                       (theDiagram).theFragmentNode->fn[];
                       fn.SifEditorInstance->no;
                    #);
               else
                    (# fn: ^FragmentNode;
                    do
                       (theDiagram).theFragmentNode->fn[];
                       no->fn.SifEditorInstance;
                    #);
              if);
           else
              'DiagramNode: SifEditorInstanceNo: no FragmentNode'
                ->screen.putline
          if);
       #);
  #);
SlotNode: PatternDiagramNode
  (#
     display::< 
       (# aSlotDesc: ^SlotDesc; pos: @Point;
       enter (pos,aSlotDesc[])
       do <<SLOT SlotNodeDisplay:ObjectDescriptor>>;
       #);
     onDoubleClick::< 
       (# do INNER ; #);
     abstract::< 
       (# do INNER ; #);
     detail::< 
       (# do INNER ; #);
     onInit::< 
       (#
       do
          UDPrivate.UDSlotNode
            ->UserDataInit;
          INNER
       #);
  #);
(* Mark nodes: for comments and Dexter anchors *)
(* Mark nodes: for comments and Dexter anchors *)
MyCommentNode: CommentNode (* to display the comment *)
  (#
     theMarkNode: @ReferenceUserData (# Type::< CommentMark #);
     onInit::<  (# do <<SLOT MyCommentNodeOnInit:ObjectDescriptor>> #);
     onRemove::< 
       (#
       do
          <<SLOT CommentNodeOnRemove:ObjectDescriptor>>
       #);
     deactivate::< 
       (# do <<SLOT CommentNodeDeactivate:ObjectDescriptor>> #);
  #);
CommentMark: MarkNode
  (#
     open: @BooleanUserData;
     theComment:
       @ASTReferenceUserData (# Type::< LexemText #);
     theCommentNode: @ReferenceUserData (# Type::< MyCommentNode #);
     theConn: @ReferenceUserData
       (# Type::< Connector
       #)
       (*toby: the connector to the comment node*)
       ;
     display::< 
       (# theCom: ^LexemText
       enter theComment
       do <<SLOT CommentNodeDisplay:ObjectDescriptor>>;
       #);
     activate::< 
       (#
       do
          <<SLOT CommentMarkActivate:ObjectDescriptor>>
       #);
     deactivate::< 
       (# do <<SLOT CommentMarkDeactivate:ObjectDescriptor>> #);
     onInit::< 
       (#
       do
          <<SLOT CommentMarkOnInit:ObjectDescriptor>>
       #);
     onRemove::<  (# do <<SLOT CommentMarkOnRemove:ObjectDescriptor>> #);
     onDoubleClick::< 
       (#
       do
          <<SLOT CommentMarkDoubleClick:ObjectDescriptor>>
       #);
     onSelect::<  (# do <<SLOT CommentMarkSelect:ObjectDescriptor>> #);
  #);
AnchorMark: MarkNode
  (#
     display::< 
       (#
       do
          <<SLOT AnchorMarkDisplay:ObjectDescriptor>>
       #);
     onInit::<  (# do <<SLOT AnchorMarkOnInit:ObjectDescriptor>> #);
     onDoubleClick::< 
       (# do <<SLOT AnchorMarkDoubleClick:ObjectDescriptor>> #);
     activate::< 
       (#
       do
          <<SLOT AnchorMarkActivate:ObjectDescriptor>>
       #);
     deactivate::< 
       (# do <<SLOT AnchorMarkDeactivate:ObjectDescriptor>> #);
  #);
(* CONNECTORS *)
CommonConnector: Connector
  (#
     initialisingSaved: @Boolean;
     treeNew: (* a try *)
       (# node1,node2: ^Node;
       enter (node1[],node2[])
       do
          <<SLOT treeNew:ObjectDescriptor>>;
       #);
     onInit::<  (# do 0->Orient; (* no heads *) INNER #)
  #);
PrefixConnector: CommonConnector (* a straight connector without arrowheads *)
  (#
     prefixNew: (* a try *)
       (# node1,node2: ^Node;
       enter (node1[],node2[])
       do <<SLOT prefixNew:ObjectDescriptor>>;
       #);
     onInit::< 
       (#
       do
          UDPrivate.UDPrefixConnector
            ->UserDataInit;
          INNER
       #);
  #);
TreeConnector: PrefixConnector
(* a straight connector without arrowheads *)
  (# onInit::<  (# do UDPrivate.UDTreeConnector->UserDataInit; INNER #)
  #);
ReferenceConnector: CommonConnector
  (# (* make two corners on the connector *)
     onInit::< 
       (# p: [8] @Integer; n1,n2: ^Node; x,y,w,h: @Integer;
       do
          true->GetEnds->(n1[],n2[]);
          (* get my region attachment nodes *)
          n1.geometry->(x,y,w,h);
          (x-(gppProp.width+1) div 2)-gppProp.RefConnectorLeftFromNode-
          (NoOfRefConnectors*gppProp.RefConnectorOffset)->p[3];
          y->p[4];
          n2.geometry->(x,y,w,h);
          (x-(gppProp.width+1) div 2)-gppProp.RefConnectorLeftFromNode-
          (NoOfRefConnectors*gppProp.RefConnectorOffset)->p[5];
          y->p[6];
          p->Points;
          (* set two corners in THIS(Connector) *)
          NoOfRefConnectors+1->NoOfRefConnectors;
       #);
  #);  

-- PatternDiagrams: DescriptorForm --
(#
   oldSelection: ^PatternDiagramNode;
   theList: @DiagramList;
   NextFreeLine: @Integer;
   (* indicates where the next PatternDiagram can
    be placed to avoid obscuring another diagrams *)
   NextFreeColumn: @Integer;
   SecondFreeLine: @Integer;
   (* Indicates where to put the next diagram when
    * we ran into the bottom of the page *)
   SecondFreeColumn: @Integer;
   Detailer: ^PatternDiagramNode;
   (* if not NONE then we are currently
    * creating a subdiagram by detailing
    * another node
    *)
   addAfterNode: ^PatternDiagramNode;
   newNode: ^PatternDiagramNode;
   (* add newnode to list after addAfterNode when done *)
#)  

-- OADPageMakeDesignObject: DescriptorForm --
(# theDiag: ^Diagram; NodeType: @Integer
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDFragmentDiagram then
       &FragmentDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created FragmentDiagram!'->putline
       if)
    // UDPrivate.UDPatternAttDiagram then
       &PatternAttDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternAttDiagram!'->putline
       if)
    // UDPrivate.UDPatternDeclDiagram then
       &PatternDeclDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternDeclDiagram!'->putline
       if)
    // UDPrivate.UDPatternClassificationDiagram then
       &PatternClassificationDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternClassificationDiagram!'->putline
       if)
    // UDPrivate.UDPatternNonTerminalDiagram then
       &PatternNonTerminalDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PatternNonTerminalDiagram!'->putline
       if)
    // UDPrivate.UDSimplePropertyDiagram then
       &SimplePropertyDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created SimplePropertyDiagram!'->putline
       if)
    // UDPrivate.UDPropertyDiagram then
       &PropertyDiagram[]->theDiag[];
       (0,theDiag[])->THIS(OADPage).PatternDiagrams.theList.insertPD;
       theDiag.titleNode[]->theObject[];
       true->theDiag.titleNode.initialisingSaved;
       (if userDataVerbose then
           'MakeDesignObject: Created PropertyDiagram!'->putline
       if)
   if)
#)  

-- MakeLocalNodes: DescriptorForm --
(#
   rangeStart: @integer;
   rangeEnd: @integer;
   rangeH: ^integerRef;
   count: ^shortRef;
   ok: @boolean;
   localNodeID: @integer;
   NodeType: @integer;
   thePatternDiagNode: ^PatternDiagramNode;
   theObject: ^DesignObject;
   thePropertyDiagram: ^SimplePropertyDiagram;
   regions: [0] @Integer;
   count2: @ShortRef;
   list: @IntegerRef;
   titleID,theNodeID: @integer
do
   LocalNodesUserDataStart->rangeStart;
   LocalNodesUserDataEnd->rangeEnd;
   theListDiagram.titleNode.ID->titleID;
   &integerRef[]->rangeH[];
   &shortRef[]->count[];
   (titleID,rangeStart,rangeEnd,count[],rangeH[])->UDFindRange->ok;
   (if userDataVerbose then
       'MakeLocalNodes - count: '->puttext; count->putint; newline;
   if);
   (if ok then
       &theListDiagram.LocalNodesDesc[]->theListDiagram.localNodes[];
       (for i: count repeat
         (if userDataVerbose then
             'For titleID: '->puttext;
             titleID->putint;
             ' and attributesID: '->puttext;
             LocalNodesUserDataStart+i->putint;
             ' localNodeID was: '->puttext;
         if);
         (titleID,LocalNodesUserDataStart+i,@@ localNodeID)->UDReadType->ok;
         (if ok then
             (if userDataVerbose then localNodeID->putint; newline; if);
             localNodeID->getNodeType->NodeType;
             (if NodeType
              // UDPrivate.UDPatternDiagramNode then
                 &PatternDiagramNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created PatternDiagramNode!'->putline
                 if)
              // UDPrivate.UDAbstractNode then
                 &theListDiagram.AbstractNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created AbstractNode!'->putline
                 if)
              // UDPrivate.UDSlotNode then
                 &theListDiagram.SlotNode[]->thePatternDiagNode[]->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created SlotNode!'->putline
                 if)
              // UDPrivate.UDPropertyNode then
                 theListDiagram[]->thePropertyDiagram[];
                 &thePropertyDiagram.PropertyNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeDesignObject: Created PropertyNode!'->putline
                 if)
              // UDPrivate.UDFragmentNode then
                 &theListDiagram.FragmentNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created FragmentNode!'->putline
                 if)
              // UDPrivate.UDDiagramNode then
                 &theListDiagram.DiagramNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created DiagramNode!'->putline
                 if)
              // UDPrivate.UDNonTerminalNode then
                 &theListDiagram.NonTerminalNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created NonTerminalNode!'->putline
                 if)
              // UDPrivate.UDAttributesNode then
                 &theListDiagram.AttributesNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created AttributesNode!'->putline
                 if)
              // UDPrivate.UDDescriptorNode then
                 &theListDiagram.DescriptorNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created DescriptorNode!'->putline
                 if)
              // UDPrivate.UDSimpleAttributeDecl then
                 &theListDiagram.SimpleAttributeDecl[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created SimpleAttributeDecl!'->putline
                 if)
              // UDPrivate.UDPatternNode then
                 &theListDiagram.PatternNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created PatternNode!'->putline
                 if)
              // UDPrivate.UDSimpleNode then
                 &theListDiagram.SimpleNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created SimpleNode!'->putline
                 if)
              // UDPrivate.UDRepetitionNode then
                 &theListDiagram.RepetitionNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created RepetitionNode!'->putline
                 if)
              // UDPrivate.UDVirtualNode then
                 &theListDiagram.VirtualNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: Created VirtualNode!'->putline
                 if)
              // UDPrivate.UDBindingNode then
                 &theListDiagram.BindingNode[]->thePatternDiagNode[]
                   ->theObject[];
                 true->thePatternDiagNode.initialisingSaved;
                 (if userDataVerbose then
                     'MakeLocalNodes: BindingNode!'->putline
                 if)
              // UDPrivate.UDActivePropertyNode then
                 (if theListDiagram## <= SimplePropertyDiagram## then
                     theListDiagram[]->thePropertyDiagram[];
                     &thePropertyDiagram.ActivePropertyNode[]
                       ->thePatternDiagNode[]->theObject[];
                     true->thePatternDiagNode.initialisingSaved;
                     (if userDataVerbose then
                         'MakeDesignObject: Created ActivePropertyNode!'
                           ->putline
                     if)
                 if)
              // UDPrivate.UDPassivePropertyNode then
                 (if theListDiagram## <= SimplePropertyDiagram## then
                     theListDiagram[]->thePropertyDiagram[];
                     &thePropertyDiagram.PassivePropertyNode[]
                       ->thePatternDiagNode[]->theObject[];
                     true->thePatternDiagNode.initialisingSaved;
                     (if userDataVerbose then
                         'MakeDesignObject: Created PassivePropertyNode!'
                           ->putline
                     if)
                 if)
              // UDPrivate.UDOriginPropertyNode then
                 (if theListDiagram## <= SimplePropertyDiagram## then
                     theListDiagram[]->thePropertyDiagram[];
                     &thePropertyDiagram.OriginPropertyNode[]
                       ->thePatternDiagNode[]->theObject[];
                     true->thePatternDiagNode.initialisingSaved;
                     (if userDataVerbose then
                         'MakeDesignObject: Created OriginPropertyNode!'
                           ->putline
                     if)
                 if)
              // UDPrivate.UDIncludePropertyNode then
                 (if theListDiagram## <= SimplePropertyDiagram## then
                     theListDiagram[]->thePropertyDiagram[];
                     &thePropertyDiagram.IncludePropertyNode[]
                       ->thePatternDiagNode[]->theObject[];
                     true->thePatternDiagNode.initialisingSaved;
                     (if userDataVerbose then
                         'MakeDesignObject: Created IncludePropertyNode!'
                           ->putline
                     if)
                 if)
              // UDPrivate.UDBodyPropertyNode then
                 (if theListDiagram## <= SimplePropertyDiagram## then
                     theListDiagram[]->thePropertyDiagram[];
                     &thePropertyDiagram.BodyPropertyNode[]
                       ->thePatternDiagNode[]->theObject[];
                     true->thePatternDiagNode.initialisingSaved;
                     (if userDataVerbose then
                         'MakeDesignObject: Created BodyPropertyNode!'->putline
                     if)
                 if)
             if);
             (if theObject[] <> none then
                 theObject[]->theListDiagram.LocalNodes.append;
                 localNodeID->theObject.onInit;
                 (if localNodeID->DSRdAttrGetObjectType
                  // RegionType then theObject.onInitRegion;
                 if);
                 (if (localNodeID,count2[],list[])->DSStrGetObjectRegionList
                  // true then
                     (if count2 > 0
                      // true then
                         (count2,list)->GetIntList->regions;
                         (if verbose
                          // true then
                             'NoOfRegions: '->puttext;
                             regions.range->putint;
                             newline;
                         if);
                         regions->MakeObjectsFromList;
                     if)
                 if);
                 (if thePatternDiagNode[] <> none then
                     thePatternDiagNode.theMarkNode.getID
                       ->theNodeID
                       (*theMarkNode currently refers to EllipseNode.
                        getID works around qua error.*) ;
                     (if theNodeID <> 0 then
                         (theListDiagram[],theNodeID)->MakeMarkNode
                     if)
                 if)
             if)
          else
         if)
       for)
    else
       (if userDataVerbose then
           'ID: '->puttext;
           theListDiagram.titleNode.ID->putint;
           ' User data FindRange fail'->putline
       if)
   if)
#)  

-- MakeMarkNode: DescriptorForm --
(#
   NodeType,theNodeId,theConnID: @integer;
   theObject: ^DesignObject;
   theCommentMark: ^theListDiagram.CommentMark;
   regions: [0] @Integer;
   count2: @ShortRef;
   list: @IntegerRef
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDCommentMark then
       &theListDiagram.CommentMark[]->theCommentMark[]->theObject[];
       true->theCommentMark.initialisingSaved;
       (if userDataVerbose then
           'MakeMarkNode: Created CommentMark!'->putline
       if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       (if ID->DSRdAttrGetObjectType
        // RegionType then theObject.onInitRegion;
       if);
       (if (ID,count2[],list[])->DSStrGetObjectRegionList
        // true then
           (if count2 > 0
            // true then
               (count2,list)->GetIntList->regions;
               (if verbose
                // true then
                   'NoOfRegions: '->puttext; regions.range->putint; newline;
               if);
               regions->MakeObjectsFromList;
           if)
       if);
       theCommentMark.theCommentNode.getID
         ->theNodeID
         (*theCommentNode currently refers to RectNode.
          getId works around qua error*) ;
       (if theNodeID <> 0 then
           (theListDiagram[],theNodeID)->MakeCommentNode
       if);
       theCommentMark.theConn.getID->theConnID;
       (if theConnID <> 0 then (theListDiagram[],theConnID)->MakeConn if)
   if)
#)  

-- MakeCommentNode: DescriptorForm --
(#
   NodeType: @integer;
   theObject: ^DesignObject;
   theCommentNode: ^theListDiagram.MyCommentNode;
   regions: [0] @Integer;
   count2: @ShortRef;
   list: @IntegerRef
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDMyCommentNode then
       &theListDiagram.MyCommentNode[]->theCommentNode[]->theObject[];
       true->theCommentNode.initialisingSaved;
       (if userDataVerbose then
           'MakeCommentNode: Created MyCommentNode!'->putline
       if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       (if ID->DSRdAttrGetObjectType
        // RegionType then theObject.onInitRegion;
       if);
       (if (ID,count2[],list[])->DSStrGetObjectRegionList
        // true then
           (if count2 > 0
            // true then
               (count2,list)->GetIntList->regions;
               (if verbose
                // true then
                   'NoOfRegions: '->puttext; regions.range->putint; newline;
               if);
               regions->MakeObjectsFromList;
           if)
       if)
   if)
#)  

-- MakeConn: DescriptorForm --
(#
   NodeType: @integer;
   theObject: ^DesignObject;
   theConnector: ^theListDiagram.CommonConnector;
   regions: [0] @Integer;
   count2: @ShortRef;
   list: @IntegerRef
do
   ID->getNodeType->NodeType;
   (if NodeType
    // UDPrivate.UDPrefixConnector then
       &theListDiagram.PrefixConnector[]->theConnector[]->theObject[];
       true->theConnector.initialisingSaved;
       (if userDataVerbose then
           'MakeConn: Created PrefixConnector!'->putline
       if)
    // UDPrivate.UDTreeConnector then
       &theListDiagram.TreeConnector[]->theConnector[]->theObject[];
       true->theConnector.initialisingSaved;
       (if userDataVerbose then
           'MakeConn: Created TreeConnector!'->putline
       if)
   if);
   (if theObject[] <> none then
       ID->theObject.onInit;
       (if ID->DSRdAttrGetObjectType
        // RegionType then theObject.onInitRegion;
       if);
       (if (ID,count2[],list[])->DSStrGetObjectRegionList
        // true then
           (if count2 > 0
            // true then
               (count2,list)->GetIntList->regions;
               (if verbose
                // true then
                   'NoOfRegions: '->puttext; regions.range->putint; newline;
               if);
               regions->MakeObjectsFromList;
           if)
       if)
   if)
#)  

-- onReadDiagram: DescriptorForm --
(#
do
   THIS(OADPage).PatternDiagrams.theList.scan
     (#
        theListDiagram: ^ListDiagram;
        thisOADDiagram: ^OADDiagram;
        thisFragmentDiagram: ^FragmentDiagram;
        theDummyDesc: ^betaGram.ObjectDescriptor;
        thisPatternAttDiagram: ^PatternAttDiagram;
        theDummyAST: ^AST
     do
        current.e[]->theListDiagram[];
        (if current.e.struc <= OADDiagram##
         // true then
            current.e[]->thisOADDiagram[];
            thisOADDiagram.titlenode.theText.get->thisOADDiagram.titleText;
            (if thisOADDiagram.theDescriptor <> none then
                thisOADDiagram.theDescriptor->theDummyDesc[];
                theDummyDesc.index->current.index;
                (if thisOADDiagram## <= PatternAttDiagram## then
                    thisOADDiagram[]->thisPatternAttDiagram[];
                    thisPatternAttDiagram.theAST->theDummyAST[];
                    theDummyAST.index->current.index
                if)
            if);
        if);
        (if current.e.struc <= FragmentDiagram## then
            current.e[]->thisFragmentDiagram[];
            thisFragmentDiagram.titlenode.theText.get
              ->thisFragmentDiagram.titleText
        if)
     #)
#)  

