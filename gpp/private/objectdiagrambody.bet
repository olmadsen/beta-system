ORIGIN '../gppinterface';
INCLUDE '../prettyprintersetup'
        'objectgppproperties'
        'objectprivate'
        '~beta/unixlib/v1.5/unixinterface';
-- onInit: DescriptorForm --
(#
do
   true->showDynamicCreations->ObjectMenu.ToggleDynamicCreations.check;
   true->showProcedureCalls->ObjectMenu.ToggleProcedureCalls.check
#)  

-- Activate: DescriptorForm --
(#
do
   THIS(ObjectPage)[]->theObjectPage[];
   theObjectPage.showDynamicCreations->ObjectMenu.ToggleDynamicCreations.check;
   theObjectPage.showProcedureCalls->ObjectMenu.ToggleProcedureCalls.check
#)  

-- ObjectDiagramNodeDisplay: DescriptorForm --
(# do INNER display #)  

-- ObjectDiagramNodeOverview: DescriptorForm --
(# detailnode: ^detailedObjectNode
do
   (if parentnode[] <> none then
       parentnode.ODNodes.scan
         (#
         do
            (if current## <= DetailedObjectNode## then
                current[]->detailnode[];
                (if current.ID <> ID then detailnode.abstractRecursive if)
            if);
            parentnode.overview
         #)
   if)
#)  

-- ObjectdiagramNodeOnSelect: DescriptorForm --
(# anAST: ^MPS.AST
do theDecl.father->anAST[]; anAST.father->changedFocus; center->oldposition;
#)  

-- ObjectdiagramNodeOnDrag: DescriptorForm --
(#
   x,y,w,h,parX,parY,parW,parH,myLeft,myRight,myUp,myDown,left,right,up,down:
     @Integer
do
   (if ParentNode[] <> none then
       (if CurrentObject = THIS(ObjectdiagramNode)[] then
           geometry->(x,y,w,h);
           x-(w div 2)->myLeft;
           x+(w div 2)->myRight;
           y-(h div 2)->myDown;
           y+(h div 2)->myUp;
           ParentNode.geometry->(parX,parY,parW,parH);
           parX-(parW div 2)->left;
           parX+(parW div 2)->right;
           parY-(parH div 2)->down;
           parY+(parH div 2)->up;
           (if (myLeft < left) or (myRight > right) or (myUp > up) or
           (myDown < down) then
               oldPosition->Move
            else
               Center->oldPosition
           if)
        else
           Center->oldPosition
       if)
   if)
#)  

-- AbstractedObjectNodeDisplay: DescriptorForm --
(# t: ^Text; kind: @Integer
do
   theObjectPage[]->CurrentPage;
   (if drawOnly then
       (if parentnode[] = none then
           (0,0,OGppProp.abstrWidth,OGppProp.abstrHeight,RndRect)->new
        else
           (if THIS(AbstractedObjectNode)##
            // AbstrOperationObjectNode## then
               (Parentnode.nextX,Parentnode.nextY,OGppProp.ProcAbstrWidth,
                OGppProp.ProcAbstrHeight,Ellipse)->new
            else
               (Parentnode.nextX,Parentnode.nextY,OGppProp.abstrWidth,
                OGppProp.abstrHeight,RndRect)->new
           if)
       if);
       OGppProp.fontSize->theText.size;
       bold->theText.style;
       titletext->theText.set;
       1->LineThickness;
       FitTotext;
    else
       statusbar.msg[]->t[];
       '.'->t.append;
       t->statusbar.set;
       (if ParentNode[]
        // none then
           (if (*Vi oensker kun at konstruere listen een gang for fragmentet*)
           ObjectPrivate.DynamicGenerations.empty and
           ObjectPrivate.ProcedureCalls.empty
            // true then
               'Scanning AST...'->statusbar.set;
               cursor.wait->cursor.set;
               ObjectPrivate.NameDclAttr.init;
               theObjectDescriptor.frag.root[]
                 ->ObjectPrivate.setupDynamicGenerations;
               (* skipper lokale procedurer, udkommenteret d. 7.9.94 
                ObjectPrivate.DynamicGenerations.setupCreatingPatterns;*)
               statusbar.reset;
               cursor.reset;
           if);
           (0,0,OGppProp.abstrWidth,OGppProp.abstrHeight,RndRect)->new;
           OGppProp.fontSize->theText.size;
           bold->theText.style;
           (if theDecl[]
            // none then
               'Name declaration is none - should not happen!'->putline
           if);
           theDecl.gettext->t[];
           t->titletext;
           titletext->theText.set;
           1->LineThickness
        else
           (OGppProp.distX+OGppProp.abstrWidth)*Parentnode.column+
           Parentnode.startX->Parentnode.nextX;
           (* (if true
            // ParentNode.column > ParentNode.row then
            ParentNode.row+1->ParentNode.row;
            ParentNode.column->ParentNode.oldColumn;
            (if ParentNode.oldColumn <= ParentNode.row then
            0->ParentNode.column
            if)
            // ParentNode.column = ParentNode.oldColumn then
            0->ParentNode.row; ParentNode.oldColumn+1->ParentNode.column
            else
            ParentNode.column+1->ParentNode.column
            if);*)
           (OGppProp.distY+OGppProp.abstrHeight)*Parentnode.row+
           Parentnode.startY->Parentnode.nextY;
           (if true
            // ParentNode.row > ParentNode.column then
               ParentNode.column+1->ParentNode.column;
               ParentNode.row->ParentNode.oldRow;
               (if ParentNode.oldRow <= ParentNode.column then
                   0->ParentNode.row
               if)
            // ParentNode.row = ParentNode.oldRow then
               0->ParentNode.column; ParentNode.oldRow+1->ParentNode.row
            else
               ParentNode.row+1->ParentNode.row
           if);
           (if THIS(AbstractedObjectNode)##
            // AbstrOperationObjectNode## then
               (Parentnode.nextX,Parentnode.nextY,OGppProp.ProcAbstrWidth,
                OGppProp.ProcAbstrHeight,Ellipse)->new
            else
               (Parentnode.nextX,Parentnode.nextY,OGppProp.abstrWidth,
                OGppProp.abstrHeight,RndRect)->new
           if);
           OGppProp.fontSize->theText.size;
           bold->theText.style;
           titletext->theText.set;
           1->LineThickness;
           FitToText
       if)
   if);
   INNER display
#)  

-- AbstractedObjectNodeOnDoubleclick: DescriptorForm --
(#
do
   (if pagelink[] = none then detail else pagelink[]->CurrentPage if);
   INNER onDoubleclick
#)  

-- AbstractedObjectNodeDetail: DescriptorForm --
(# x,y,w,h: @Integer; conList: ^ObjectList; t: ^Text
do
   'Detailing '->t[];
   titleText[]->t.append;
   t->statusbar.set;
   cursor.wait->cursor.set;
   (if theObjectDescriptor[]
    // none then 'Objectdescriptor is none!'->putline
    else
       INNER detail;
       &genericnode[]->detailnode.regionObject[];
       Parentnode[]->detailnode.Parentnode[];
       geometry->(x,y,w,h);
       x+OGppProp.abstrWidth-w+(OGppProp.distX div 2)->detailnode.startX;
       y+(OGppProp.distY div 2)+15->detailnode.startY;
       titletext->detailnode.titletext;
       (if Parentnode[]
        // none then
           (theDecl[],theObjectDescriptor[],false)->detailnode.display;
           (2,ID,detailnode.ID,theDecl[],theObjectDescriptor[])
             ->ObjectPrivate.removeID
        else
           THIS(AbstractedObjectNode)[]->Parentnode.ODNodes.at
             ->Parentnode.ODNodes.delete;
           detailnode[]->Parentnode.ODNodes.append;
           (theDecl[],theObjectDescriptor[],false)->detailnode.display;
           (2,ID,detailnode.ID,theDecl[],theObjectDescriptor[])
             ->ObjectPrivate.removeID;
           getConnectors->conList[];
           (if conList[] <> none then
               conList.scan
                 (# node1,node2: ^ObjectDiagramNode; con: ^Connector
                 do
                    current[]->con[];
                    true->con.getends->(node1[],node2[]);
                    (if (node1.ID <> ID) and (node2.ID = ID) then
                        (if detailNode## <= DetailOperationObjectNode## then
                            (node1[],detailnode[])->newConnector
                         else
                            (node1[],detailnode[])->newDynConnector
                        if)
                    if)
                 #)
           if);
           detailnode[]->Parentnode.redisplay
       if);
       delete
   if);
   statusbar.reset;
   cursor.reset
#)  

-- AbstractedObjectNodeDetailRecursive: DescriptorForm --
(# abstrNode: ^AbstractedObjectNode
do
   (if theObjectDescriptor[]
    // none then 'Objectdescriptor is none!'->putline
    else
       detail->detailnode[];
       detailnode.ODNodes.scan
         (#
         do
            (if current## <= AbstractedObjectNode## then
                current[]->abstrnode[]; abstrnode.detailRecursive
            if)
         #)
   if)
#)  

-- DetailedObjectNodeCalculateBox: DescriptorForm --
(# maxX,minX,maxY,minY: @Integer
do
   MinInt->maxX->maxY;
   MaxInt->minX->minY;
   ODNodes.scan
     (#
     do
        current.geometry->(x,y,w,h);
        (maxX,x+(w div 2))->Max->maxX;
        (minX,x-(w div 2))->Min->minX;
        (maxY,y+(h div 2))->Max->maxY;
        (minY,y-(h div 2))->Min->minY
     #);
   maxY-minY+OGppProp.distY->h;
   maxX-minX+OGppProp.distX->w;
   minX+(w div 2)-(OGppProp.distX div 2)->x;
   minY+(h div 2)-(OGppProp.distY div 2)->y
#)  

-- DetailedObjectNodeDisplay: DescriptorForm --
(#
   x,y,w,h,dummy: @Integer;
   drawnDynamics: @containerList
     (#
        element::< 
          (# theDcl: ^betaGram.NameDcl; node: ^AbstractedObjectNode #);
        emptyContainerError::<  (# do true->Continue #);
        myappend:
          (#
             theDecl: ^betaGram.NameDcl;
             node: ^AbstractedObjectNode;
             theNew: ^element
          enter (theDecl[],node[])
          do
             &element[]->theNew[];
             theDecl[]->theNew.theDcl[];
             node[]->theNew.node[];
             theNew[]->append
          #)
     #);
   myScanDecls:
     (#
        theObjectDescriptor: ^betaGram.ObjectDescriptor;
        nd,theNd: ^betaGram.NameDcl
     enter (theNd[],theObjectDescriptor[])
     do
        theObjectDescriptor.scanDecls
          (#
             thisSlot::< 
               (# father: @integer; ff: ^mps.fragmentform; unexp: ^mps.unexpanded
               do
                  theSlot.node->(father,ff[]);
                  (ff[],theSlot.father)
                    ->ObjectPrivate.searchSlotBinding
                      (#
                         bindingFound::< 
                           (#
                              attForm: ^betaGram.AttributesForm;
                              attr: ^betaGram.Attributes;
                              names: ^betaGram.Names;
                              nd: ^betaGram.NameDcl
                           do
                              ff.root[]->anAST[];
                              (if anAST.symbol = betaGram.AttributesForm then
                                  anAST[]->attForm[];
                                  attForm.getAttributes->attr[];
                                  attr.newScan
                                    (#
                                    do
                                       (if current[] <> none then
                                           (if current.symbol
                                            // betaGram.PatternDecl
                                            // betaGram.VirtualDecl
                                            // betaGram.BindingDecl
                                            // betaGram.FinalDecl
                                            // betaGram.SimpleDecl then
                                               current.getson1->names[];
                                               names.newScan
                                                 (# do current[]->nd[] #);
                                               nd[]->thisAttribute
                                           if)
                                       if)
                                    #)
                               else
                                  'Binding of attributes slot not an attributesForm - should not happen?'
                                    ->putline
                              if)
                           #)
                      #)
               #);
             thisAttribute::< 
               (#
                  anAST: ^MPS.AST;
                  SimpleDecl: ^betaGram.SimpleDecl;
                  RepDecl: ^betaGram.RepetitionDecl;
                  PatternDecl: ^betaGram.PatternDecl;
                  refSpec: ^betaGram.ReferenceSpecification;
                  StaticItem: ^betaGram.StaticItem;
                  os: ^betaGram.Objectspecification;
                  NameApl: ^betaGram.NameApl;
                  theNames: ^betaGram.Names;
                  DescForm: ^betaGram.DescriptorForm;
                  ad: ^betaGram.AttributeDenotation;
                  R: ^betaGram.Remote;
                  firstNd,calledNd: ^betaGram.NameDcl;
                  node,tmpNode: ^AbstractedObjectNode;
                  dynNode,CreatingNode: ^ObjectDiagramNode;
                  dynNodeIDs: @ObjectPrivate.RemIDList;
                  nodeIDObject: @IntegerObject;
                  con: ^connector;
                  t: ^text;
                  simple: @boolean;
                  doit: @Boolean;
                  findCalledVirtual:
                    (# nd,calledNd: ^betaGram.NameDcl
                    enter nd[]
                    do
                       (if nd[]->ObjectPrivate.NameDclAttr.theDclElmsEmpty then
                           nd[]->ObjectPrivate.myVirtDcl->nd[];
                           (if nd[] <> none then
                               nd[]->findCalledVirtual->calledNd[]
                           if)
                        else
                           nd[]->calledNd[]
                       if)
                    exit calledNd[]
                    #);
                  findVirtualDecl:
                    (# nd: ^betaGram.NameDcl
                    enter nd[]
                    do
                       (if ((nd.father).father).symbol <> betaGram.VirtualDecl
                        then
                           nd[]->ObjectPrivate.myVirtDcl->nd[];
                           (if nd[] <> none then
                               nd[]->findCalledVirtual->nd[]
                           if)
                       if)
                    exit nd[]
                    #)
               do
                  nd.father->anAST[];
                  anAST.father->anAST[];
                  (if anAST.symbol
                   // betaGram.SimpleDecl then
                      anAST[]->SimpleDecl[];
                      SimpleDecl.getReferenceSpecification->refSpec[];
                      (if refSpec.symbol
                       // betaGram.StaticItem // betaGram.StaticComponent then
                          nd[]->ObjectPrivate.isSimple->(simple,t[]);
                          (if simple = false then
                              (if refSpec.symbol
                               // betaGram.StaticItem then
                                  &AbstrPartObjectNode[]->node[]
                               else
                                  &AbstrPartComponentNode[]->node[]
                              if);
                              THIS(DetailedObjectNode)[]->node.Parentnode[];
                              nd.getText->t[];
                              t->node.titletext;
                              refSpec.getSon1->anAst[];
                              (if anAST## <= betaGram.ObjectSpecification##
                               // true then
                                  anAST[]->os[];
                                  (if os.symbol
                                   // betaGram.NameApl then
                                      os[]->NameApl[];
                                      NameApl.gettext->t[];
                                      ':'->node.titletext.append;
                                      t[]->node.titletext.append
                                   // betaGram.Remote then
                                      os[]->R[];
                                      R.getNameApl->NameApl[];
                                      NameApl.gettext->t[];
                                      ':'->node.titletext.append;
                                      R.getAttributeDenotation->ad[];
                                      (if ad.symbol
                                       // betaGram.remote then
                                          ad[]->R[];
                                          findRemoteHead:
                                            (#
                                            do
                                               R.getNameApl->NameApl[];
                                               '.'->t.prepend;
                                               NameApl.gettext->t.prepend;
                                               R.getAttributeDenotation->ad[];
                                               (if ad.symbol
                                                // betaGram.remote then
                                                   ad[]->R[];
                                                   restart findRemoteHead
                                                // betaGram.NameApl then
                                                   ad[]->NameApl[];
                                                   '.'->t.prepend;
                                                   NameApl.gettext->t.prepend
                                               if)
                                            #)
                                       // betaGram.NameApl then
                                          ad[]->NameApl[];
                                          '.'->t.prepend;
                                          NameApl.gettext->t.prepend
                                      if);
                                      t[]->node.titletext.append
                                  if);
                                  node[]->ODNodes.append;
                                  (nd[],nd.findDescriptor,false)->node.display
                               else
                              (*Objectspecification'en er et slot - goer noget passende!*)
                                  (if anAST.kind
                                   // mps.kinds.unExpanded then
                                      (anAST.frag[],anAST[])
                                        ->ObjectPrivate.searchSlotBinding
                                          (#
                                             bindingFound::< 
                                               (#
                                               do
                                                  ff.root[]->anAST[];
                                                  anAST[]->descForm[];
                                                  descForm.getObjectDescriptor
                                                    ->os[];
                                                  node[]->ODNodes.append;
                                                  (nd[],os[],false)
                                                    ->node.display
                                               #)
                                          #)
                                   else
                                      'Neither slot nor ordinary?'->putline
                                  if)
                              if);
                              (if node.theObjectDescriptor[] <> none then
                                  node[]->objectPrivate.drawConnectors
                              if)
                          if)
                      if)
                   // betaGram.RepetitionDecl then
                      anAST[]->RepDecl[];
                      RepDecl.getReferenceSpecification->refSpec[];
                      (if refSpec.symbol
                       // betaGram.StaticItem then
                          (if refSpec.symbol
                           // betaGram.StaticItem then
                              &AbstrRepPartObjectNode[]->node[]
                           else
                          if);
                          THIS(DetailedObjectNode)[]->node.Parentnode[];
                          nd.getText->t[];
                          t->node.titletext;
                          refSpec.getSon1->anAst[];
                          (if anAST## <= betaGram.ObjectSpecification##
                           // true then
                              anAST[]->os[];
                              (if os.symbol
                               // betaGram.NameApl then
                                  os[]->NameApl[];
                                  NameApl.gettext->t[];
                                  ':'->node.titletext.append;
                                  t[]->node.titletext.append
                               // betaGram.Remote then
                                  os[]->R[];
                                  R.getNameApl->NameApl[];
                                  NameApl.gettext->t[];
                                  ':'->node.titletext.append;
                                  R.getAttributeDenotation->ad[];
                                  (if ad.symbol
                                   // betaGram.remote then
                                      ad[]->R[];
                                      findRemoteHead:
                                        (#
                                        do
                                           R.getNameApl->NameApl[];
                                           '.'->t.prepend;
                                           NameApl.gettext->t.prepend;
                                           R.getAttributeDenotation->ad[];
                                           (if ad.symbol
                                            // betaGram.remote then
                                               ad[]->R[]; restart findRemoteHead
                                            // betaGram.NameApl then
                                               ad[]->NameApl[];
                                               '.'->t.prepend;
                                               NameApl.gettext->t.prepend
                                           if)
                                        #)
                                   // betaGram.NameApl then
                                      ad[]->NameApl[];
                                      '.'->t.prepend;
                                      NameApl.gettext->t.prepend
                                  if);
                                  t[]->node.titletext.append
                              if);
                              node[]->ODNodes.append;
                              (nd[],nd.findDescriptor,false)->node.display
                           else
                          (*Objectspecification'en er et slot - goer noget passende!*)
                              (if anAST.kind
                               // mps.kinds.unExpanded then
                                  (anAST.frag[],anAST[])
                                    ->ObjectPrivate.searchSlotBinding
                                      (#
                                         bindingFound::< 
                                           (#
                                           do
                                              ff.root[]->anAST[];
                                              anAST[]->descForm[];
                                              descForm.getObjectDescriptor
                                                ->os[];
                                              node[]->ODNodes.append;
                                              (nd[],os[],false)->node.display
                                           #)
                                      #)
                               else
                                  'Neither slot nor ordinary?'->putline
                              if)
                          if);
                          (if node.theObjectDescriptor[] <> none then
                              node[]->objectPrivate.drawConnectors
                          if)
                      if)
                   // betaGram.PatternDecl // betaGram.VirtualDecl
                   // betaGram.BindingDecl // betaGram.FinalDecl then
                      (if
                      ((anAST.symbol = betaGram.BindingDecl) or
                       (anAST.symbol = betaGram.FinalDecl)) and
                      ((THIS(DetailedObjectNode)## <=
                        DetailDynamicObjectNode##) or
                       (THIS(DetailedObjectNode)## <=
                        DetailOperationObjectNode##)) then
                          nd[]->firstNd[];
                          nd[]->findCalledVirtual->calledNd[];
                          showVirtual:
                          (if calledNd[] <> none then
                              calledNd[]
                                ->ObjectPrivate.NameDclAttr.scanTheDclelms
                                  (#
                                     thedynElm:
                                       ^ObjectPrivate.DynamicGenerations.
                                          element;
                                     theDrawnDyn: ^drawnDynamics.element
                                  do
                                     myCurrent[]->theDynElm[];
                                     (if myCurrent.EnclosingPartDecl[]
                                      // none then true->doit
                                     if);
                                     (if doit then
                                         drawnDynamics.find
                                           (#
                                              predicate::< 
                                                (#
                                                do
                                                   calledNd[]->findVirtualDecl
                                                     ->current.theDcl.equal
                                                     ->value
                                                #);
                                              notFound::< 
                                                (#
                                                   theDescriptor:
                                                     ^betaGram.ObjectDescriptor
                                                do
                                                   calledNd.father->anAST[];
                                                   anAST.father->anAST[];
                                                   (if
                                                   (anAST[],'(#Class#)')
                                                     ->
                                                       ObjectPrivate.
                                                         checkKeyWord then
                                                       (if
                                                       theDynElm.isComponent
                                                        // true then
                                                           &
                                                              AbstrDynamicComponentNode[]
                                                             ->node[]
                                                        else
                                                           &
                                                              AbstrDynamicObjectNode[]
                                                             ->node[]
                                                       if)
                                                    else
                                                       &
                                                          AbstrOperationObjectNode[]
                                                         ->node[]
                                                   if);
                                                   THIS(DetailedObjectNode)[]
                                                     ->node.Parentnode[];
                                                   calledNd.getText->t[];
                                                   t->node.titletext;
                                                   node[]->ODNodes.append;
                                                   firstNd[]
                                                     ->
                                                       ObjectPrivate.
                                                         myFindDescriptor
                                                     ->theDescriptor[];
                                                   (firstNd[],theDescriptor[],
                                                    false)->node.display;
                                                   calledNd[]->findVirtualDecl
                                                     ->nd[];
                                                   (nd[],node[])
                                                     ->drawnDynamics.myappend
                                                #)
                                           #)->theDrawnDyn[];
                                         (if theDrawnDyn[] <> none
                                          // true then
                                             theDrawnDyn.node[]->tmpNode[]
                                          else
                                             node[]->tmpNode[]
                                         if);
                                         tmpNode.ID->nodeIDObject;
                                         nodeIDObject[]
                                           ->
                                             myCurrent.DynamicObjectIDs.
                                               myappend;
                                         myCurrent.CreatingObjectIDs.scan
                                           (#
                                           do
                                              current
                                                ->
                                                  ObjectPrivate.
                                                    theObjectListmyFind
                                                ->CreatingNode[];
                                              (if
                                              (CreatingNode[],tmpNode[],
                                               theDynElm.theRemote[])
                                                ->
                                                  objectPrivate.
                                                    drawConnectorTest
                                               // true then
                                                  (if tmpNode##
                                                   //
                                                   AbstrOperationObjectNode##
                                                   //
                                                   DetailOperationObjectNode##
                                                   then
                                                      (if
                                                      OGppProp.
                                                        ShowOperationCalls then
                                                          (CreatingNode[],
                                                           tmpNode[])
                                                            ->newConnector
                                                      if)
                                                   else
                                                      (if
                                                      OGppProp.
                                                        ShowDynamicCreations
                                                       then
                                                          (CreatingNode[],
                                                           tmpNode[])
                                                            ->newDynConnector
                                                      if)
                                                  if)
                                              if)
                                           #)
                                     if)
                                  #);
                              (if doit = false then
                                  calledNd[]->ObjectPrivate.myVirtDcl->nd[];
                                  (if nd[] <> none then
                                      nd[]->findCalledVirtual->calledNd[];
                                      restart showVirtual
                                  if)
                              if)
                          if)
                       else
                          nd[]
                            ->ObjectPrivate.NameDclAttr.scanTheDclelms
                              (#
                                 thedynElm:
                                   ^ObjectPrivate.DynamicGenerations.element;
                                 theDrawnDyn: ^drawnDynamics.element;
                                 doit: @Boolean
                              do
                                 myCurrent[]->theDynElm[];
                                 (if myCurrent.EnclosingPartDecl[]
                                  // none then true->doit
                                  else
                                     (if
                                     (*Hvis theDecl er none, er vi ved at detaljere det foerste "objekt"*)
                                     theDecl[] <> none
                                      // true then
                                         (if
                                         myCurrent.EnclosingPartDecl[]
                                           ->theDecl.equal
                                          // true then true->doit
                                         if)
                                     if)
                                 if);
                                 (if doit then
                                     drawnDynamics.find
                                       (#
                                          predicate::< 
                                            (#
                                            do
                                               nd[]->current.theDcl.equal->value
                                            #);
                                          notFound::< 
                                            (#
                                               theDescriptor:
                                                 ^betaGram.ObjectDescriptor
                                            do
                                               nd.father->anAST[];
                                               anAST.father->anAST[];
                                               (if
                                               (anAST[],'(#Class#)')
                                                 ->ObjectPrivate.checkKeyWord
                                                then
                                                   (if theDynElm.isComponent
                                                    // true then
                                                       &
                                                          AbstrDynamicComponentNode[]
                                                         ->node[]
                                                    else
                                                       &AbstrDynamicObjectNode[]
                                                         ->node[]
                                                   if)
                                                else
                                                   &AbstrOperationObjectNode[]
                                                     ->node[]
                                               if);
                                               THIS(DetailedObjectNode)[]
                                                 ->node.Parentnode[];
                                               nd.getText->t[];
                                               t->node.titletext;
                                               node[]->ODNodes.append;
                                               nd[]
                                                 ->
                                                   ObjectPrivate.
                                                     myFindDescriptor
                                                 ->theDescriptor[];
                                               (nd[],theDescriptor[],false)
                                                 ->node.display;
                                               (nd[],node[])
                                                 ->drawnDynamics.myappend
                                            #)
                                       #)->theDrawnDyn[];
                                     (if theDrawnDyn[] <> none
                                      // true then
                                         theDrawnDyn.node[]->tmpNode[]
                                      else
                                         node[]->tmpNode[]
                                     if);
                                     tmpNode.ID->nodeIDObject;
                                     nodeIDObject[]
                                       ->myCurrent.DynamicObjectIDs.myappend;
                                     myCurrent.CreatingObjectIDs.scan
                                       (#
                                       do
                                          current
                                            ->ObjectPrivate.theObjectListmyFind
                                            ->CreatingNode[];
                                          (if
                                          (CreatingNode[],tmpNode[],
                                           theDynElm.theRemote[])
                                            ->objectPrivate.drawConnectorTest
                                           // true then
                                              (if tmpNode##
                                               // AbstrOperationObjectNode##
                                               // DetailOperationObjectNode##
                                               then
                                                  (if
                                                  OGppProp.ShowOperationCalls
                                                   then
                                                      (CreatingNode[],tmpNode[])
                                                        ->newConnector
                                                  if)
                                               else
                                                  (if
                                                  OGppProp.ShowDynamicCreations
                                                   then
                                                      (CreatingNode[],tmpNode[])
                                                        ->newDynConnector
                                                  if)
                                              if)
                                          if)
                                       #)
                                 if)
                              #)
                      if);
                      (if node[] <> none then
                          (if node.theObjectDescriptor[] <> none then
                              node[]->objectPrivate.drawConnectors
                          if)
                      if)
                  if)
               #)
          #);
        theNd[]->ObjectPrivate.isPatternDefined->nd[];
        (if nd[] = none then theNd[]->nd[] if);
        (if ((nd.father).father).symbol
         // betaGram.BindingDecl // betaGram.FinalDecl then
            nd[]->ObjectPrivate.myVirtDcl->nd[];
            nd[]->ObjectPrivate.myFindDescriptor->theObjectDescriptor[]
         else
            theObjectDescriptor[]->ObjectPrivate.myGetPrefix
              ->(theObjectDescriptor[],nd[])
        if);
        (if theObjectDescriptor[] <> none
         // true then (nd[],theObjectDescriptor[])->myScanDecls
        if)
     #);
   dynNodeIDs,procNodeIDs: @ObjectPrivate.RemIDList;
   dynNode,procNode: ^ObjectDiagramNode;
   tmptext: @text
do
   (startX,StartY,OGppProp.emptySizeW,OGppProp.emptySizeH,RndRect)->new;
   (startX,StartY,5,5,RndRect)->regionObject.new;
   false->regionObject.selectable;
   false->regionObject.BorderVisible;
   THIS(DetailedObjectNode)[]->regionObject.CreateRegion;
   (theDecl[],theObjectDescriptor[])->myScanDecls;
   (if ODnodes.empty
    // false then
       calculateBox->(x,y,w,h,dummy);
       regionObject.UnmakeRegion;
       (x,y,w,h)->geometry;
       THIS(DetailedObjectNode)[]->regionObject.CreateRegion
   if);
   (if theObjectDescriptor[] <> none then
       (ID,theObjectDescriptor[],theDecl[])->ObjectPrivate.updateDoPartCreating
         ->dynNodeIDs
   if);
   (if false
    // dynNodeIDs.empty then
       dynNodeIDs.scan
         (#
         do
            current.ID->ObjectPrivate.theObjectListmyFind->dynNode[];
            (if
            (THIS(DetailedObjectNode)[],dynNode[],current.remote[])
              ->objectPrivate.drawConnectorTest
             // true then
                (if dynNode##
                 // AbstrOperationObjectNode## // DetailOperationObjectNode##
                 then
                    (if OGppProp.ShowOperationCalls then
                        (THIS(DetailedObjectNode)[],dynNode[])->newConnector
                    if)
                 else
                    (if OGppProp.ShowDynamicCreations then
                        (THIS(DetailedObjectNode)[],dynNode[])->newDynConnector
                    if)
                if)
            if)
         #)
   if);
   2->LineThickness;
   titletext->tmptext;
   (if THIS(DetailedObjectNode)## <= DetailOperationObjectNode## then
       ' (PROC)'->tmptext.append
   if);
   tmptext->theText.set;
   LeftJustification->theText.Just;
   OGppProp.fontsize->theText.size;
   ODNodes.scan
     (# do regionObject[]->current.CreateRegion #);
   (if Parentnode[] = none
    // false then Parentnode.regionObject[]->CreateRegion
   if);
   INNER display
#)  

-- DetailedObjectNodeRedisplay: DescriptorForm --
(#
   r,detX,detY,detW,detH,dummy,wDist,hDist,Ymove,Xmove,maxY,maxX,up,down,left,
     right,myX,myY,myW,myH,myUp,myRight: @Integer;
   YpartElms,XpartElms: @containerList (# element::< ObjectdiagramNode #);
   t: ^text
do
   'Prettyprinting '->t[];
   titleText[]->t.append;
   '...'->t.append;
   t->statusbar.set;
   theDetailed.geometry->(detX,detY,detW,detH);
   detW div 2->wDist;
   detH div 2->hDist;
   detY+Hdist->up;
   detY-Hdist->down;
   detX-wDist->left;
   detX+wDist->right;
   ODNodes.scan
     (#
        curX,curY,curW,curH,curWdist,curHdist,N,curYmove,curXmove,curUp,curDown,
          curLeft,curRight: @Integer
     do
        (if current[] <> theDetailed[] then
            current.geometry->(curX,curY,curW,curH);
            curW div 2->curWdist;
            curH div 2->curHdist;
            curY+curHdist->curUp;
            curY-curHdist->curDown;
            curX-curWdist->curLeft;
            curX+curWdist->curRight;
            detW*(curY-detY)-detH*(curX-detX)->N;
            (if (N > 0) and
            (((curLeft <= right) and (curLeft >= left)) or
             ((curRight >= left) and (curRight <= right)) or
             ((curLeft <= left) and (curRight >= right))) then
                up-curDown->curYmove;
                (curYmove,Ymove)->max->Ymove;
                current[]->YpartElms.append
             else
                (if (N < 0) and
                (((curDown <= up) and (curDown >= down)) or
                 ((curUp >= down) and (curUp <= up)) or
                 ((curUp >= up) and (curDown <= down))) then
                    right-curLeft->curXmove;
                    (curXmove,Xmove)->max->Xmove;
                    current[]->XpartElms.append
                if)
            if)
        if)
     #);
   geometry->(myX,myY,myW,myH);
   myY+(myH div 2)->myUp;
   myX+(myW div 2)->myRight;
   (if Ymove > 0 then
       YpartElms.scan
         (# Y,curX,curY,curW,curH: @Integer
         do
            current.geometry->(curX,curY,curW,curH);
            curY+Ymove+OGppProp.distY->Y;
            (curX,Y)->current.move;
            (Y+(curH div 2),maxY)->max->maxY
         #)
   if);
   (maxY,up)->max->maxY;
   (if maxY > myUp then
       (maxY+(OGppProp.distY div 2)-myUp)+myH->myH;
       ((maxY+(OGppProp.distY div 2)-myUp) div 2)+myY->myY
   if);
   (if Xmove > 0 then
       XpartElms.scan
         (# X,curX,curY,curW,curH: @Integer
         do
            current.geometry->(curX,curY,curW,curH);
            curX+Xmove+OGppProp.distX->X;
            (X,curY)->current.move;
            (X+(curW div 2),maxX)->max->maxX
         #)
   if);
   (maxX,right)->max->maxX;
   (if maxX > myRight then
       (maxX+(OGppProp.distX div 2)-myRight)+myW->myW;
       ((maxX+(OGppProp.distX div 2)-myRight) div 2)+myX->myX
   if);
   regionObject.UnmakeRegion;
   (myX,myY,myW,myH)->geometry;
   THIS(DetailedObjectNode)[]->regionObject.CreateRegion;
   (if (Parentnode[] <> none ) and ((maxY > myUp) or (maxX > myRight)) then
       THIS(DetailedObjectNode)[]->Parentnode.redisplay
   if);
   statusbar.reset
#)  

-- DetailedObjectNodeOnDoubleClick: DescriptorForm --
(# do abstract; INNER onDoubleClick #)  

-- DetailedObjectNodeAbstract: DescriptorForm --
(# cantdoit: @boolean; dynNode,CreatingNode: ^ObjectDiagramNode; t: ^text
do
   'Abstracting '->t[];
   titleText[]->t.append;
   '...'->t.append;
   t->statusbar.set;
   ODNodes.scan
     (# detailnode: ^detailedObjectNode
     do (if current## <= DetailedObjectNode## then true->cantdoit if)
     #);
   (if cantdoit then
       'Abstracting objects with detailed objects:'->putline;
       'Use Abstract Recursively'->putline
    else
       INNER abstract;
       Parentnode[]->node.Parentnode[];
       titletext->node.titletext;
       theObjectDescriptor[]->node.theObjectDescriptor[];
       theDecl[]->node.theDecl[];
       (if node.parentnode[] <> none then
           center->(node.parentnode.nextX,node.Parentnode.nextY)
       if);
       (TheDecl[],theObjectDescriptor[],true)->node.display;
       (if node.Parentnode[] <> none then
           node[]->Parentnode.ODNodes.prepend;
           THIS(DetailedObjectNode)[]->parentNode.ODNodes.at
             ->parentnode.ODNodes.delete
       if);
       ODNodes.scan
         (#
         do
            (if current## <= AbstractedObjectNode## then
                (1,current.ID,node.ID,current.theDecl[],
                 current.theObjectDescriptor[])->ObjectPrivate.removeID;
                current.delete
            if)
         #);
       (3,ID,node.ID,theDecl[],theObjectDescriptor[])->ObjectPrivate.removeID;
       delete;
       (if (THIS(DetailedObjectNode)## <= DetailDynamicObjectNode##) or
       (THIS(DetailedObjectNode)## <= DetailOperationObjectNode##) then
           theDecl[]
             ->ObjectPrivate.NameDclAttr.scanTheDclElms
               (#
               do
                  myCurrent.CreatingObjectIDs.scan
                    (#
                    do
                       current->ObjectPrivate.theObjectListmyFind
                         ->CreatingNode[];
                       (if
                       (CreatingNode[],Node[],myCurrent.theRemote[])
                         ->objectPrivate.drawConnectorTest
                        // true then
                           (if THIS(DetailedObjectNode)## <=
                           DetailDynamicObjectNode## then
                               (CreatingNode[],Node[])->newDynConnector
                            else
                               (CreatingNode[],Node[])->newConnector
                           if)
                       if)
                    #)
               #)
       if);
       (if node.theObjectDescriptor[] <> none then
           node[]->objectPrivate.drawConnectors
       if);
       (if parentnode[] <> none then
           parentnode.regionObject[]->node.createRegion; parentnode.compact
       if)
   if);
   statusbar.reset
#)  

-- DetailedObjectNodeAbstractRecursive: DescriptorForm --
(# dynNode,CreatingNode: ^ObjectDiagramNode
do
   ODNodes.scan
     (# detailnode: ^detailedObjectNode
     do
        (if current## <= DetailedObjectNode## then
            current[]->detailnode[]; detailnode.abstractRecursive
        if)
     #);
   abstract
#)  

-- DetailedObjectNodeShowSimple: DescriptorForm --
(#
   x,y,w,h,dummy,startX,startY,ColumnsNo,col,row: @Integer;
   myScanDecls:
     (#
        theObjectDescriptor: ^betaGram.ObjectDescriptor; nd: ^betaGram.NameDcl
     enter theObjectDescriptor[]
     do
        theObjectDescriptor.scanDecls
          (#
             thisSlot::< 
               (# father: @integer; ff: ^mps.fragmentform; unexp: ^mps.unexpanded
               do
                  theSlot.node->(father,ff[]);
                  (ff[],theSlot.father)
                    ->ObjectPrivate.searchSlotBinding
                      (#
                         bindingFound::< 
                           (#
                              attForm: ^betaGram.AttributesForm;
                              attr: ^betaGram.Attributes;
                              names: ^betaGram.Names;
                              nd: ^betaGram.NameDcl
                           do
                              ff.root[]->anAST[];
                              (if anAST.symbol = betaGram.AttributesForm then
                                  anAST[]->attForm[];
                                  attForm.getAttributes->attr[];
                                  attr.newScan
                                    (#
                                    do
                                       (if current.symbol
                                        // betaGram.PatternDecl
                                        // betaGram.VirtualDecl
                                        // betaGram.BindingDecl
                                        // betaGram.FinalDecl
                                        // betaGram.SimpleDecl then
                                           current.getson1->names[];
                                           names.newScan
                                             (# do current[]->nd[] #);
                                           nd[]->thisAttribute
                                       if)
                                    #)
                               else
                                  'Binding of attributes slot not an attributesForm - should not happen?'
                                    ->putline
                              if)
                           #)
                      #)
               #);
             thisAttribute::< 
               (#
                  node: ^AbstractedObjectNode; t1,t2: ^text; simple: @boolean
               do
                  nd[]->ObjectPrivate.isSimple->(simple,t2[]);
                  (if simple then
                      &AbstrPartObjectNode[]->node[];
                      THIS(DetailedObjectNode)[]->node.Parentnode[];
                      nd.getText->t1[];
                      t1->node.titletext;
                      ':'->node.titletext.append;
                      t2[]->node.titletext.append;
                      node[]->ODNodes.append;
                      nd[]->node.theDecl[];
                      nd.findDescriptor->node.theObjectDescriptor[];
                      (startX+col*(OGppProp.AbstrWidth+OGppProp.distX),startY+
                       row*(OGppProp.AbstrHeight+OGppProp.distY),
                       OGppProp.abstrWidth,OGppProp.abstrHeight,RndRect)
                        ->node.new;
                      regionObject[]->node.CreateRegion;
                      OGppProp.fontSize->node.theText.size;
                      bold->node.theText.style;
                      1->node.LineThickness;
                      node.titletext->node.theText.set;
                      node.FitToText;
                      (if col < ColumnsNo then
                          col+1->col
                       else
                          0->col; row+1->row
                      if)
                  if)
               #)
          #);
        theObjectDescriptor[]->ObjectPrivate.myGetPrefix
          ->(theObjectDescriptor[],nd[]);
        (if theObjectDescriptor[] <> none
         // true then theObjectDescriptor[]->myScanDecls
        if)
     #)
do
   'Displaying simple objects...'->statusbar.set;
   geometry->(x,y,w,h);
   x-(w div 2)+((OGppProp.distX+OGppProp.AbstrWidth) div 2)->startX;
   y+((h+OgppProp.distY+OgppProp.AbstrHeight) div 2)->startY;
   w div (OGppProp.distX+OGppProp.AbstrWidth)->ColumnsNo;
   theObjectDescriptor[]->myScanDecls;
   (if ODnodes.empty
    // false then
       calculateBox->(x,y,w,h,dummy);
       regionObject.UnmakeRegion;
       (x,y,w,h)->geometry;
       THIS(DetailedObjectNode)[]->regionObject.CreateRegion
   if);
   (if parentnode[] <> none then
       THIS(DetailedObjectNode)[]->parentnode.redisplay
   if);
   INNER showSimple;
   statusbar.reset
#)  

-- DetailedObjectNodeHideSimple: DescriptorForm --
(# Simple: @Boolean; t: ^text; x,y,w,h,dummy: @integer
do
   'Hiding simple objects...'->statusbar.set;
   ODNodes.scan
     (#
     do
        current.theDecl[]->ObjectPrivate.isSimple->(simple,t[]);
        (if simple then
            current.delete; current[]->ODNodes.at->ODNodes.delete
        if)
     #);
   (if ODnodes.empty
    // false then
       calculateBox->(x,y,w,h,dummy);
       regionObject.UnmakeRegion;
       (x,y,w,h)->geometry;
       THIS(DetailedObjectNode)[]->regionObject.CreateRegion
   if);
   (if parentnode[] <> none then
       THIS(DetailedObjectNode)[]->parentnode.redisplay
   if);
   INNER ;
   statusbar.reset
#)  

-- DetailedObjectNodeCompact: DescriptorForm --
(# detailnode: ^DetailedObjectNode; x,y,w,h,dummy: @Integer
do
   'Compacting...'->statusbar.set;
   THIS(DetailedObjectNode)[]->detailnode[];
   loop:
     (#
     do
        detailnode.regionObject.UnmakeRegion;
        detailnode.calculateBox->(x,y,w,h,dummy);
        (x,y,w,h)->detailnode.geometry;
        detailnode[]->detailnode.regionObject.CreateRegion;
        (if detailnode.parentnode[] <> none then
            detailnode.parentnode[]->detailnode[]; restart loop
        if)
     #);
   statusbar.reset
#)  

-- DetailedObjectNodeBlowup: DescriptorForm --
(# x,y,w,h,dummy: @Integer; newX,newY,newW,newH: @Integer
do
   geometry->(x,y,w,h);
   H*110 div 100->newH;
   W*110 div 100->newW;
   x+((newW-w) div 2)->newX;
   y+((newH-h) div 2)->newY;
   regionObject.UnMakeRegion;
   (newX,newY,newW,newH)->geometry;
   THIS(DetailedObjectNode)[]->regionObject.CreateRegion;
   (if parentnode[] <> none then
       THIS(DetailedObjectNode)[]->parentnode.redisplay
   if)
#)  

-- AbstrOperationObjectNodeDisplay: DescriptorForm --
(# do OGppProp.dashed->LineType; INNER display #)  

-- AbstrOperationObjectNodeDetail: DescriptorForm --
(# do &DetailOperationObjectNode[]->detailnode[]; INNER detail #)  

-- AbstrPartObjectNodeDisplay: DescriptorForm --
(# do INNER display #)  

-- AbstrPartObjectNodeDetail: DescriptorForm --
(# do &DetailPartObjectNode[]->detailnode[]; INNER detail #)  

-- AbstrRepPartObjectNodeDisplay: DescriptorForm --
(# x,y,w,h: @Integer; node: ^RndRectNode
do
   geometry->(x,y,w,h);
   20->filltype;
   &RndRectNode[]->node[];
   (x+1,y+1,w+2,h+2)->node.new;
   LineThickness->node.LineThickness;
   false->node.selectable;
   THIS(AbstrRepPartObjectNode)[]->node.CreateRegion;
   &RndRectNode[]->node[];
   (x+2,y+2,w+4,h+4)->node.new;
   LineThickness->node.LineThickness;
   false->node.selectable;
   THIS(AbstrRepPartObjectNode)[]->node.CreateRegion;
   INNER display
#)  

-- AbstrRepPartObjectNodeDetail: DescriptorForm --
(# do &DetailRepPartObjectNode[]->detailnode[]; INNER detail #)  

-- DetailPartObjectNodeDisplay: DescriptorForm --
(# do INNER display #)  

-- DetailPartObjectNodeAbstract: DescriptorForm --
(#
do &AbstrPartObjectNode[]->node[]; RndRect->node.shape; INNER abstract
#)  

-- DetailRepPartObjectNodeDisplay: DescriptorForm --
(# x,y,w,h: @Integer; node: ^RndRectNode
do
   geometry->(x,y,w,h);
   20->filltype;
   &RndRectNode[]->node[];
   (x+1,y+1,w+2,h+2)->node.new;
   LineThickness->node.LineThickness;
   false->node.selectable;
   THIS(DetailRepPartObjectNode)[]->node.CreateRegion;
   &RndRectNode[]->node[];
   (x+2,y+2,w+4,h+4)->node.new;
   LineThickness->node.LineThickness;
   false->node.selectable;
   THIS(DetailRepPartObjectNode)[]->node.CreateRegion;
   INNER display
#)  

-- DetailRepPartObjectNodeAbstract: DescriptorForm --
(#
do &AbstrRepPartObjectNode[]->node[]; RndRect->node.shape; INNER abstract
#)  

-- AbstrDynamicObjectNodeDisplay: DescriptorForm --
(# do OGppProp.dashed->LineType; INNER display #)  

-- AbstrDynamicObjectNodeDetail: DescriptorForm --
(# do &DetailDynamicObjectNode[]->detailnode[]; INNER detail #)  

-- DetailDynamicObjectNodeDisplay: DescriptorForm --
(# do OGppProp.dashed->LineType; INNER display #)  

-- DetailDynamicObjectNodeAbstract: DescriptorForm --
(#
do &AbstrDynamicObjectNode[]->node[]; RndRect->node.shape; INNER abstract
#)  

-- DetailOperationObjectNodeDisplay: DescriptorForm --
(# do OGppProp.dashed->LineType; INNER display #)  

-- DetailOperationObjectNodeAbstract: DescriptorForm --
(#
do &AbstrOperationObjectNode[]->node[]; ellipse->node.shape; INNER abstract
#)  

-- AbstrPartComponentNodeDisplay: DescriptorForm --
(# x,y,w,h: @Integer; node: ^RndRectNode
do
   geometry->(x,y,w,h);
   &RndRectNode[]->node[];
   (x,y,w+7,h)->node.new;
   LineThickness->node.LineThickness;
   THIS(AbstrPartComponentNode)[]->node.CreateRegion;
   false->node.selectable
#)  

-- AbstrPartComponentNodeDetail: DescriptorForm --
(#
do
   &DetailPartComponentNode[]
     -> (*Overskriver eksisterende detailnode!*) detailnode[];
   INNER detail
#)  

-- AbstrDynamicComponentNodeDisplay: DescriptorForm --
(# x,y,w,h: @Integer; node: ^RndRectNode
do
   geometry->(x,y,w,h);
   &RndRectNode[]->node[];
   (x,y,w+7,h)->node.new;
   LineThickness->node.LineThickness;
   LineType->node.LineType;
   THIS(AbstrDynamicComponentNode)[]->node.CreateRegion;
   false->node.selectable
#)  

-- AbstrDynamicComponentNodeDetail: DescriptorForm --
(#
do
   &DetailDynamicComponentNode[]
     -> (*Overskriver eksisterende detailnode!*) detailnode[];
   INNER detail
#)  

-- DetailPartComponentNodeDisplay: DescriptorForm --
(# x,y,w,h: @Integer; node: ^RndRectNode
do
   geometry->(x,y,w,h);
   &RndRectNode[]->node[];
   (x,y,w+7,h)->node.new;
   LineThickness->node.LineThickness;
   THIS(DetailPartComponentNode)[]->node.CreateRegion;
   false->node.selectable
#)  

-- DetailPartComponentNodeAbstract: DescriptorForm --
(#
do
   &AbstrPartComponentNode[]-> (*Overskriver eksisterende node[]!*) node[];
   RndRect->node.shape;
   INNER abstract
#)  

-- DetailDynamicComponentNodeDisplay: DescriptorForm --
(# x,y,w,h: @Integer; node: ^RndRectNode
do
   geometry->(x,y,w,h);
   &RndRectNode[]->node[];
   (x,y,w+7,h)->node.new;
   LineThickness->node.LineThickness;
   LineType->node.LineType;
   THIS(DetailDynamicComponentNode)[]->node.CreateRegion;
   false->node.selectable
#)  

-- DetailDynamicComponentNodeAbstract: DescriptorForm --
(#
do
   &AbstrDynamicComponentNode[]-> (*Overskriver eksisterende node[]!*) node[];
   RndRect->node.shape;
   INNER abstract
#)  

-- newConnector: DescriptorForm --
(# con: ^Connector; thePage: ^ObjectPage
do
   (if ShowProcedureCalls then
       (if node1.getPage
        // node2.getPage then
           node2.getpage->thePage[];
           &thePage.connector[]->con[];
           (node1[],node2[])->con.new
       if)
   if)
#)  

-- newDynConnector: DescriptorForm --
(# con: ^Connector; thePage: ^ObjectPage
do
   (if showDynamicCreations then
       (if node1.getPage
        // node2.getPage then
           node2.getpage->thePage[];
           &thePage.connector[]->con[];
           (node1[],node2[])->con.new;
           OGppProp.dashed->con.LineType
       if)
   if)
#)  

