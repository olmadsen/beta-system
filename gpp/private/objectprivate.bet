ORIGIN '../gppinterface';
INCLUDE '~beta/containers/v1.4/sets'
        'objectgppproperties'
        '~beta/sysutils/v1.4.2/envstring';
-- ObjectPrivate: Descriptor --
(#
   IntegerList: Containerlist
     (#
        emptyContainerError::<  (#  do true->Continue #);
        element::< IntegerObject;
        myappend:
          (# elm: ^element
          enter elm[]
          do
             locate
               (#
                  predicate::<  (#  do (current.elm = elm)->value #);
                  NotFound::<  (#  do elm[]->append #)
               #)
          #)
     #);
   remIDList: containerList
     (#
        emptyContainerError::<  (#  do true->Continue #);
        element::<  (# remote: ^betaGram.remote; ID: @integer #);
        myappend:
          (# remote: ^betaGram.remote; ID: @Integer; theNew: ^element
          enter (remote[],ID)
          do
             &element[]->theNew[];
             remote[]->theNew.remote[];
             ID->theNew.ID;
             theNew[]->append
          #)
     #);
   ShowCreations: @Boolean;
   DynamicListElm:
     (#
        CreatingPatterns: @set
          (#
             element::< betaGram.AttributeDecl;
             equal::<  (#  do left[]->right.equal->value #);
             dump: scan (#  do current.index->putint; ','->puttext #)
          #);
        theDcl: ^betaGram.NameDcl;
        EnclosingPartDecl: ^betaGram.NameDcl;
        CreatingObjectIDs: @IntegerList;
        DynamicObjectIDs: @IntegerList;
        isComponent: @Boolean;
        theRemote: ^betaGram.remote;
        dump:
          (# 
          do
             '('->puttext;
             CreatingPatterns.dump;
             '),'->puttext;
             theDcl.index->putint;
             ','->puttext;
             (if EnclosingPartDecl[] <> none
              // true then EnclosingPartDecl.index->putint
              else
                 'none'->puttext
             if);
             ',('->puttext;
             CreatingObjectIDs.scan
               (#  do current->putint; ','->puttext #);
             '),('->puttext;
             DynamicObjectIDs.scan
               (#  do current->putint; ','->puttext #);
             '),'->puttext;
             isComponent->putint;
             ','->puttext;
             (if theRemote[] <> none
              // true then theRemote.index->putint
              else
                 'none'->puttext
             if)
          #)
     #);
   DynamicSet: set
     (#
        element::< DynamicListElm;
        equal::< 
          (# test: @boolean
          do
             left.theDcl[]->right.theDcl.equal->value;
             (if true
              // (left.theRemote[] <> none ) and (right.theRemote[] <> none )
              then
                 (left.theRemote[],right.theRemote[])->remoteEqual->test
              // (left.theRemote[] = none ) and (right.theRemote[] = none ) then
                 true->test
             if);
             (value and test)->value
          #);
        myInsert:
          (#
             CreatingPattern: ^betaGram.AttributeDecl;
             nd,theDcl: ^betaGram.NameDcl;
             nameList: ^betaGram.names;
             EnclosingPartDecl: ^betaGram.NameDcl;
             isComponent: @Boolean;
             theRemote: ^betaGram.remote;
             theElement: ^element
          enter
          (CreatingPattern[],theDcl[],EnclosingPartDecl[],isComponent,
           theRemote[])
          do
             (if CreatingPattern[] <> none then
                 find
                   (#
                      predicate::< 
                        (# test: @boolean
                        do
                           current.theDcl[]->theDcl.equal->value;
                           (if true
                            //
                            (current.theRemote[] <> none )
                            and
                            (theRemote[] <> none ) then
                               (current.theRemote[],theRemote[])->remoteEqual
                                 ->test
                            //
                            (current.theremote[] = none )
                            and
                            (theRemote[] = none ) then
                               true->test
                           if);
                           (value and test)->value
                        #)
                   #)->theElement[];
                 (if theElement[] <> none
                  // true then
                     CreatingPattern[]->theElement.CreatingPatterns.insert
                  else
                     &element[]->theElement[];
                     CreatingPattern[]->theElement.CreatingPatterns.insert;
                     theDcl[]->theElement.theDcl[];
                     EnclosingPartDecl[]->theElement.EnclosingPartDecl[];
                     isComponent->theElement.isComponent;
                     theRemote[]->theElement.theRemote[];
                     theElement[]->insert
                 if);
                 (theDcl[],theElement[])->NameDclAttr.insertDclElm;
                 CreatingPattern.getson1->nameList[];
                 nameList.scan
                   (#  do current[]->nd[] #);
                 (nd[],theElement[])->NameDclAttr.insertCreatingElm
             if);
             
          #);
        setupCreatingPatterns: scan
          (# theElm: ^element
          do
             current[]->theElm[];
             theElm.CreatingPatterns.scan
               (# 
               do
                  current[]->theElm.CreatingPatterns.delete;
                  current[]->getEnclosingProc->theElm.CreatingPatterns.insert
               #)
          #);
        dump:<
          (# 
          do
             INNER ;
             scan
               (#  do '('->puttext; current.dump; ')'->putline #)
          #)
     #);
   NameDclAttr: @
     (#
        A: [OGppProp.MaxNo] ^ArrayElm;
        Last: @Integer;
        ArrayElm:
          (#
             theDclElms: @Containerlist
               (#
                  element::< DynamicListElm;
                  emptyContainerError::<  (#  do true->continue #)
               #);
             CreatingElms: @Containerlist
               (#
                  element::< DynamicListElm;
                  emptyContainerError::<  (#  do true->continue #)
               #);
             init: (#  do theDclElms.init; CreatingElms.init #)
          #);
        scanTheDclElms:
          (#
             myCurrent: ^DynamicListElm;
             nd: ^betagram.NameDcl;
             index: @integer
          enter nd[]
          do
             (- 1*(1->nd.getAttribute))->index;
             (if index > 0 then
                 A[index].TheDclelms.scan
                   (#  do current[]->myCurrent[]; INNER scanTheDclElms #)
             if)
          #);
        theDclElmsEmpty:
          (# index: @Integer; nd: ^betagram.NameDcl; empty: @Boolean
          enter nd[]
          do
             (- 1*(1->nd.getAttribute))->index;
             (if index > 0 then A[index].theDclElms.empty->empty if)
          exit empty
          #);
        insertDclElm:
          (# nd: ^betaGram.NameDcl; elm: ^DynamicListElm; theNew: ^ArrayElm
          enter (nd[],elm[])
          do
             (if (1->nd.getAttribute) >= 0 then
                 &ArrayElm[]->theNew[];
                 theNew.init;
                 elm[]->theNew.TheDclElms.append;
                 theNew[]->A[Last][];
                 (- 1*Last,1)->nd.putAttribute;
                 Last+1->Last;
                 (if Last > A.range then A.range->A.extend if);
                 
              else
                 elm[]->A[- 1*(1->nd.getAttribute)].theDclElms.append
             if)
          #);
        scanCreatingElms:
          (#
             myCurrent: ^DynamicListElm;
             nd: ^betagram.NameDcl;
             index: @integer
          enter nd[]
          do
             (- 1*(1->nd.getAttribute))->index;
             (if index > 0 then
                 A[index].CreatingElms.scan
                   (#  do current[]->myCurrent[]; INNER scanCreatingElms #)
             if)
          #);
        insertCreatingElm:
          (# nd: ^betaGram.NameDcl; elm: ^DynamicListElm; theNew: ^ArrayElm
          enter (nd[],elm[])
          do
             (if (1->nd.getAttribute) >= 0 then
                 &ArrayElm[]->theNew[];
                 theNew.init;
                 elm[]->theNew.CreatingElms.append;
                 theNew[]->A[Last][];
                 (- 1*Last,1)->nd.putAttribute;
                 Last+1->Last;
                 (if Last > A.range then A.range->A.extend if);
                 
              else
                 elm[]->A[- 1*(1->nd.getAttribute)].CreatingElms.append
             if)
          #);
        init: (#  do 1->Last #)
     #);
   DynamicGenerations: @DynamicSet
     (# dump::<  (#  do 'Dynamic Generations:'->Putline #) #);
   ProcedureCalls: @DynamicSet
     (# dump::<  (#  do 'Procedurecalls:'->Putline #) #);
   removeID:
     (#
        realyRemoveID:
          (#
             theID: @Integer;
             newID: @IntegerObject;
             mode: @Integer;
             theDcl,myNd,PatternNd: ^betaGram.NameDcl;
             anAST: ^MPS.AST;
             theObjectDescriptor: ^betaGram.ObjectDescriptor
          enter (mode,theID,newID,theDcl[],theObjectDescriptor[])
          do
             theDcl[]->myNd[];
             theDcl.father->anAST[];
             anAST.father->anAST[];
             anAST[]->isPatterndefined->patternNd[];
             (if patternNd[] <> none // true then PatternNd[]->myNd[] if);
             myNd[]
               ->NameDclAttr.scanCreatingElms
                 (# position: ^myCurrent.CreatingObjectIDs.theCellType
                 do
                    myCurrent.CreatingObjectIDs.locate
                      (#
                         predicate::< 
                           (#  do (current.elm = theID)->value #)
                      #)->position[];
                    (if position[] <> none then
                        position[]->myCurrent.CreatingObjectIDs.delete;
                        (if (mode = 1) or (mode = 3) then
                            newID[]->myCurrent.CreatingObjectIDs.myappend
                        if)
                    if)
                 #);
             (if ((theDcl.father).father).symbol
              // betaGram.BindingDecl // betaGram.FinalDecl then
                 theDcl[]->myVirtDcl->theDcl[];
                 theDcl[]->myFindDescriptor->theObjectDescriptor[]
              else
                 theObjectDescriptor[]->ObjectPrivate.myGetPrefix
                   ->(theObjectDescriptor[],theDcl[])
             if);
             (if theObjectDescriptor[] <> none
              // true then
                 (mode,theID,newID,theDcl[],theObjectDescriptor[])
                   ->realyremoveID
             if)
          #);
        theID: @Integer;
        newID: @IntegerObject;
        mode: @Integer;
        theDcl,theDclPrefix: ^betaGram.NameDcl;
        anAST: ^MPS.AST;
        theObjectDescriptor,theObjectDescriptorPrefix:
          ^betaGram.ObjectDescriptor
     enter (mode,theID,newID,theDcl[],theObjectDescriptor[])
     do
        (mode,theID,newID,theDcl[],theObjectDescriptor[])->realyremoveID;
        theObjectDescriptor.scanDecls
          (#
             thisAttribute::< 
               (# theObjectDesc: ^betaGram.Objectdescriptor
               do
                  nd[]->myFindDescriptor->theObjectDesc[];
                  (if theObjectDesc[] <> none then
                      (0,theID,newID,nd[],theObjectDesc[])->realyremoveID
                  if)
               #)
          #);
        theDcl[]
          ->NameDclAttr.scanTheDclElms
            (# position: ^myCurrent.DynamicObjectIDs.theCellType
            do
               myCurrent.DynamicObjectIDs.locate
                 (# predicate::<  (#  do (current.elm = theID)->value #)
                 #)->position[];
               (if position[] <> none then
                   position[]->myCurrent.DynamicObjectIDs.delete;
                   (if (mode = 2) or (mode = 3) then
                       newID[]->myCurrent.DynamicObjectIDs.myappend
                   if)
               if)
            #);
        loop:
          (# 
          do
             (if ((theDcl.father).father).symbol
              // betaGram.BindingDecl // betaGram.FinalDecl then
                 theDcl[]->myVirtDcl->theDcl[];
                 theDcl[]->myFindDescriptor->theObjectDescriptor[]
              else
                 theObjectDescriptor[]->ObjectPrivate.myGetPrefix
                   ->(theObjectDescriptor[],theDcl[])
             if);
             (if theObjectdescriptor[] <> none then
                 theObjectDescriptor.scanDecls
                   (#
                      thisAttribute::< 
                        (# theObjectDesc: ^betaGram.Objectdescriptor
                        do
                           nd[]->myFindDescriptor->theObjectDesc[];
                           (if theObjectDesc[] <> none then
                               (0,theID,newID,nd[],theObjectDesc[])
                                 ->realyremoveID
                           if)
                        #)
                   #);
                 theDcl[]
                   ->NameDclAttr.scanTheDclElms
                     (# position: ^myCurrent.DynamicObjectIDs.theCellType
                     do
                        myCurrent.DynamicObjectIDs.locate
                          (#
                             predicate::< 
                               (#  do (current.elm = theID)->value #)
                          #)->position[];
                        (if position[] <> none then
                            position[]->myCurrent.DynamicObjectIDs.delete;
                            (if (mode = 2) or (mode = 3) then
                                newID[]->myCurrent.DynamicObjectIDs.myappend
                            if)
                        if)
                     #);
                 restart loop
             if)
          #)
     #);
   updateDoPartCreating:
     (#
        realyUpdate:
          (#
             theObjectDescriptor: ^betaGram.ObjectDescriptor;
             nd: ^betaGram.NameDcl;
             anAST: ^MPS.AST;
             NodeIDObject: @IntegerObject
          enter (theObjectDescriptor[],nd[])
          do
             nd[]
               ->NameDclAttr.scanCreatingElms
                 (# 
                 do
                    nodeID->nodeIDObject;
                    nodeIDObject[]->myCurrent.CreatingObjectIDs.myappend;
                    (if myCurrent.DynamicObjectIDs.empty
                     // false then
                        myCurrent.DynamicObjectIDs.scan
                          (# 
                          do
                             (myCurrent.theRemote[],current)
                               ->dynNodeIDs.myappend
                          #)
                    if);
                    
                 #);
             (if ((nd.father).father).symbol
              // betaGram.BindingDecl // betaGram.FinalDecl then
                 nd[]->myVirtDcl->nd[];
                 nd[]->myFindDescriptor->theObjectDescriptor[]
              else
                 theObjectDescriptor[]->ObjectPrivate.myGetPrefix
                   ->(theObjectDescriptor[],nd[])
             if);
             (if theObjectDescriptor[] <> none
              // true then (theObjectDescriptor[],nd[])->realyUpdate
             if)
          #);
        NodeID: @Integer;
        nd,patternNd: ^betaGram.NameDcl;
        dynNodeIDs: @remIDList;
        anAST: ^MPS.AST;
        theObjectDescriptor: ^betaGram.ObjectDescriptor
     enter (nodeID,theObjectDescriptor[],nd[])
     do
        nd.father->anAST[];
        anAST.father->anAST[];
        anAST[]->isPatterndefined->patternNd[];
        (if patternNd[] <> none // true then PatternNd[]->nd[] if);
        (theObjectDescriptor[],nd[])->realyUpdate
     exit dynNodeIDs
     #);
   updateCreating:
     (#
        realyUpdate:
          (#
             theObjectDescriptor: ^betaGram.ObjectDescriptor;
             nd: ^betaGram.NameDcl;
             anAST: ^MPS.AST;
             NodeIDObject: @IntegerObject
          enter (theObjectDescriptor[],nd[])
          do
             (nodeID,theObjectDescriptor[],nd[])->updateDopartCreating
               ->dynNodeIDs;
             theObjectDescriptor.scanDecls
               (#
                  thisAttribute::< 
                    (# 
                    do
                       nd[]->myFindDescriptor->theObjectDescriptor[];
                       (if theObjectDescriptor[] <> none then
                           (nodeID,theObjectDescriptor[],nd[])
                             ->updateDopartCreating->tmpIDs;
                           tmpIds.scan
                             (# 
                             do
                                (current.remote[],current.ID)
                                  ->dynNodeIDs.myappend
                             #)
                       if)
                    #)
               #)
          #);
        nodeID: @integer;
        theObjectDescriptor: ^betaGram.ObjectDescriptor;
        nd,patternNd: ^betaGram.NameDcl;
        dynNodeIDs,tmpIds: @remIDList;
        anAST: ^MPS.AST
     enter (nodeID,theObjectDescriptor[],nd[])
     do (theObjectDescriptor[],nd[])->realyUpdate
     exit dynNodeIDs
     #);
   drawConnectorTest:
     (#
        findRemID:
          (#
             ParentNode: ^theObjectPage.DetailedObjectNode;
             nd: ^betaGram.NameDcl;
             anAST: ^MPS.AST;
             ID: @Integer
          enter ParentNode[]
          do
             remNd.father->anAST[];
             anAST.father->anAST[];
             (if anAST.symbol
              //
              betaGram.PatternDecl
              (*Dette tilfaelde er vist overfloedigt!Dette tilfaelde er vist overfloedigt!*)
              then
                 'findRemId called with a patternDecl!'->putline;
                 ParentNode.theDecl[]->ObjectPrivate.realyGetStaticNd->nd[];
                 (if (nd[],remNd[])->ObjectPrivate.recursiveEqual
                  // true then ParentNode.ID->ID
                  else
                     (if ParentNode.ParentNode[] <> none
                      // true then ParentNode.ParentNode[]->findRemID->ID
                     if)
                 if)
              // betaGram.SimpleDecl then
                 ParentNode.theDecl[]->nd[];
                 (if nd[]->remNd.equal
                  // true then ParentNode.ID->ID
                  else
                     (if ParentNode.ParentNode[] <> none
                      // true then ParentNode.ParentNode[]->findRemID->ID
                     if)
                 if)
             if)
          exit ID
          #);
        isRemID:
          (#
             ParentNode: ^theObjectPage.DetailedObjectNode;
             result: @Boolean;
             anAST: ^MPS.AST;
             SimpleDecl: ^betaGram.SimpleDecl;
             refSpec: ^betaGram.referenceSpecification;
             nd: ^betaGram.NameDcl
          enter ParentNode[]
          do
             remNd.father->anAST[];
             anAST.father->anAST[];
             ParentNode.ODNodes.find
               (#
                  predicate::< 
                    (# 
                    do
                       (if anAST.symbol
                        // betaGram.PatternDecl then
                           current.theDecl[]->ObjectPrivate.realyGetStaticNd
                             ->nd[];
                           ((nd[],remNd[])->ObjectPrivate.recursiveEqual) and
                           (remID = current.ID)->value->result
                        // betaGram.SimpleDecl then
                           (current.theDecl[]->remNd.equal) and
                           (remID = current.ID)->value->result
                       if)
                    #);
                  notFound::< 
                    (# 
                    do
                       (if ParentNode.ParentNode[] <> none
                        // true then ParentNode.ParentNode[]->isRemID->result
                       if)
                    #)
               #)
          exit result
          #);
        dynNode,tmpnode: ^theObjectPage.ObjectDiagramNode;
        CreatingNode: ^theObjectPage.ObjectDiagramNode;
        aDetailNode: ^theObjectPage.DetailedObjectNode;
        remote,R: ^betaGram.remote;
        ad: ^betaGram.AttributeDenotation;
        thisobj: ^betaGram.ThisObject;
        remNd,thePatternNd,thePrefixNd,nd: ^betaGram.NameDcl;
        thePrefix: ^betaGram.prefix;
        na: ^betaGram.NameApl;
        remID: @Integer;
        draw: @boolean;
        anAST: ^MPS.AST;
        SimpleDecl: ^betaGRam.SimpleDecl;
        thePattern: ^betaGram.AttributeDecl;
        refSpec: ^betaGram.ReferenceSpecification;
        ObjDesc: ^betaGram.ObjectDescriptor
     enter (CreatingNode[],dynNode[],remote[])
     do
        (if remote[] <> none
         // true then
            (if true
             // OGppProp.NoRefCheck then
                true->draw
             // OGppProp.StaticRefCheck then
                remote[]->ObjectPrivate.remoteHeadDcl->remNd[];
                (if remNd[] <> none
                (*Dette test er indfoert iforb. med tilpasning til
                 THIS(P) konstruktioner.Dette test er indfoert iforb. med tilpasning til
                 THIS(P) konstruktioner.*) then
                    remNd.father->anAST[];
                    anAST.father->anAST[];
                    (if anAST.symbol
                     // betaGram.SimpleDecl then
                        anAST[]->SimpleDecl[];
                        SimpleDecl.getReferenceSpecification->refSpec[];
                        (if refSpec.symbol
                         // betaGram.StaticItem // betaGram.StaticComponent then
                            dynNode.ParentNode[]->findRemID->remID;
                            (if creatingNode.struc <=
                            theObjectPage.DetailedObjectNode## then
                                CreatingNode[]->isRemID->draw
                             else
                                (if CreatingNode.ParentNode[] <> none
                                 // true then
                                    CreatingNode.ParentNode[]->isRemID->draw
                                 else
                                    true->draw
                                if)
                            if)
                         else
                            true->draw
                        if)
                    if)
                 else
                    remote[]->R[];
                    findRemoteHead:
                      (# 
                      do
                         R.getAttributeDenotation->ad[];
                         (if ad.symbol = betaGram.remote then
                             ad[]->R[]; restart findRemoteHead
                         if)
                      #);
                    (if ad.symbol = betaGram.thisObject then
                        ad[]->thisobj[];
                        thisobj.getNameApl->na[];
                        na.dclRef->thePatternNd[];
                        dynnode[]->tmpnode[];
                        findIDforTHISP:
                          (# 
                          do
                             tmpnode.theDecl[]->nd[];
                             nd.father->anAST[];
                             anAST.father->anAST[];
                             (if anAST.symbol
                              // betaGram.PatternDecl // betaGram.VirtualDecl
                              // betaGram.bindingDecl // betaGram.finalDecl then
                                 (if nd[]->thePatternNd.equal then
                                     tmpnode.ID->remID
                                  else
                                     prefixSearch:
                                       (# 
                                       do
                                          nd[]->myFindDescriptor->ObjDesc[];
                                          (if ObjDesc[] <> none then
                                              ObjDesc[]->myGetPrefix
                                                ->(anAST[],theprefixNd[]);
                                              (if theprefixNd[] <> none then
                                                  (if
                                                  theprefixNd[]
                                                    ->thePatternNd.equal then
                                                      tmpnode.ID->remID
                                                   else
                                                      theprefixNd[]->nd[];
                                                      restart prefixSearch
                                                  if)
                                               else
                                                  (if tmpnode.parentnode[] <>
                                                  none then
                                                      tmpnode.parentnode[]
                                                        ->tmpnode[];
                                                      restart findIDforTHISP
                                                  if)
                                              if)
                                          if)
                                       #)
                                 if)
                              // betaGram.SimpleDecl then
                                 nd[]->RealyGetStaticNd->nd[];
                                 (if nd[]->thePatternNd.equal then
                                     tmpnode.ID->remID
                                  else
                                     prefixSearch:
                                       (# 
                                       do
                                          nd[]->myFindDescriptor->ObjDesc[];
                                          (if ObjDesc[] <> none then
                                              ObjDesc[]->myGetPrefix
                                                ->(anAST[],theprefixNd[]);
                                              (if theprefixNd[] <> none then
                                                  (if
                                                  theprefixNd[]
                                                    ->thePatternNd.equal then
                                                      tmpnode.ID->remID
                                                   else
                                                      theprefixNd[]->nd[];
                                                      restart prefixSearch
                                                  if)
                                               else
                                                  (if tmpnode.parentnode[] <>
                                                  none then
                                                      tmpnode.parentnode[]
                                                        ->tmpnode[];
                                                      restart findIDforTHISP
                                                  if)
                                              if)
                                          if)
                                       #)
                                 if)
                             if)
                          #);
                        creatingnode[]->tmpNode[];
                        checkIDs:
                          (# 
                          do
                             (if tmpNode.ID <> remID then
                                 (if tmpNode.parentnode[] <> none then
                                     tmpNode.parentnode[]->tmpnode[];
                                     restart checkIDs
                                 if)
                              else
                                 true->draw
                             if)
                          #);
                        
                    if);
                    
                if)
                (*Dette test er indfoert iforb. med tilpasning
                 til THIS(P) konstruktioner i remote'sDette test er indfoert iforb. med tilpasning
                 til THIS(P) konstruktioner i remote's*)
             // OGppProp.StrongRefCheck then
                remote[]->ObjectPrivate.remoteHeadDcl->remNd[];
                remNd[]->ObjectPrivate.realyGetNd->remNd[];
                dynNode.ParentNode[]->findRemID->remID;
                (if CreatingNode.ParentNode[] <> none
                 // true then CreatingNode.ParentNode[]->isRemID->draw
                 else
                    true->draw
                if)
            if)
         else
            true->draw;
            (if CreatingNode.struc <= theObjectPage.DetailedObjectNode## then
                CreatingNode[]->aDetailNode[];
                aDetailNode.ODNodes.find
                  (#
                     predicate::< 
                       (# 
                       do
                          (current.theDecl[]->dynNode.theDecl.equal) and
                          (dynNode.ID = current.ID)->value
                       #);
                     notFound::< 
                       (# 
                       do
                          (if aDetailNode.ParentNode[] <> none
                           // true then
                              (aDetailNode.ParentNode[],dynNode[],remote[])
                                ->drawConnectorTest->draw
                           else
                              false->draw
                          if)
                       #)
                  #);
                
             else
                (if CreatingNode.ParentNode[] <> none
                 // true then
                    (CreatingNode.ParentNode[],dynNode[],remote[])
                      ->drawConnectorTest->draw
                 else
                    false->draw
                if)
            if)
        if)
     exit draw
     #);
   drawConnectors:
     (#
        dynNodeIDs: @RemIDList; dynNode,node: ^theObjectPage.ObjectDiagramNode
     enter node[]
     do
        (node.ID,node.theObjectDescriptor[],node.theDecl[])
          ->ObjectPrivate.updateCreating->dynNodeIDs;
        (if false
         // dynNodeIDs.empty then
            dynNodeIDs.scan
              (# 
              do
                 current.ID->theObjectListmyFind->dynNode[];
                 (if (node[],dynNode[],current.remote[])->drawConnectorTest
                  // true then
                     (if
                     (dynNode.struc = theObjectpage.AbstrOperationObjectNode##)
                     or
                     (dynNode.struc = theObjectPage.DetailOperationObjectNode##)
                      then
                         (if OGppProp.ShowOperationCalls then
                             (node[],dynNode[])->theObjectPage.newConnector
                         if)
                      else
                         (if OGppProp.ShowDynamicCreations then
                             (node[],dynNode[])->theObjectPage.newDynConnector
                         if)
                     if)
                 if)
              #)
        if)
     #);
   searchedFragments: @Containerlist
     (#
        emptyContainerError::<  (#  do true->Continue #);
        element::< mps.fragmentForm;
        myappend:
          (# elm: ^element; didAppend: @Boolean
          enter elm[]
          do
             locate
               (#
                  predicate::<  (#  do (current.elm[] = elm[])->value #);
                  NotFound::<  (#  do elm[]->append; true->didAppend #)
               #)
          exit didAppend
          #)
     #);
   setupDynamicGenerations:
     (#
        realySetup:
          (#
             markSuperClass:
               (#
                  AstRef: ^MPS.AST;
                  Names: ^betaGram.Names;
                  NameApl: ^betaGram.NameApl;
                  NameDcl: ^betaGram.NameDcl
               enter NameApl[]
               do
                  NameApl.dclRef->NameDcl[];
                  NameDcl.father->Names[];
                  Names.father->AstRef[];
                  (if AstRef.symbol
                   // betaGram.PatternDecl // betaGram.VirtualDecl
                   // betaGram.BindingDecl // betaGram.FinalDecl then
                      (if (AstRef[],'(#Class#)')->checkKeyWord
                       // false then
                          (AstRef[],'(#Class#) ')->prependComment;
                          NameDcl.findDescriptor->getPrefixNameApl
                            ->(NameApl[],AstRef[]);
                          (if NameApl[] <> none
                           // true then NameApl[]->markSuperClass
                          if)
                      if)
                  if)
               #);
             isStatic:
               (#
                  na: ^betaGram.NameApl;
                  nd: ^betaGram.nameDcl;
                  AstRef: ^MPS.AST;
                  sd: ^betaGram.SimpleDecl;
                  rs: ^betaGram.ReferenceSpecification
               enter na[]
               do
                  na.dclRef->nd[];
                  nd.father->AstRef[];
                  AstRef.father->AstRef[];
                  (if AstRef.symbol
                   // betaGram.SimpleDecl then
                      AstRef[]->sd[];
                      sd.getReferenceSpecification->rs[];
                      (if rs.symbol
                       // betaGram.DynamicItem // betaGram.DynamicComponent then
                          none ->nd[]
                      if)
                  if)
               exit nd[]
               #);
             AstRef,ObjectSpecification: ^MPS.AST;
             Reference: ^betaGram.Reference;
             ObjectReference: ^betaGram.ObjectReference;
             DynamicItemGeneration: ^betaGram.DynamicItemGeneration;
             NameApl,remNameApl: ^betaGram.NameApl;
             Exp: ^mps.expanded;
             theRemote,remote: ^betaGram.remote;
             attDenotation: ^betaGram.AttributeDenotation;
             StaticItem: ^betaGram.StaticItem;
             DescriptorForm: ^betaGram.DescriptorForm;
             ObjectDenotation: ^betaGram.ObjectDenotation;
             theDcl,remNameDcl: ^betaGram.NameDcl;
             refSpec: ^betaGram.ReferenceSpecification;
             SimpleDecl: ^betaGram.SimpleDecl;
             isComponent: @Boolean
          enter AstRef[]
          do
             (if AstRef.Symbol
              // betaGram.Objectreference then
                 AstRef[]->ObjectReference[];
                 ObjectReference.getReference->Reference[];
                 (if Reference.symbol
                  // betaGram.DynamicItemGeneration
                  // betaGram.DynamicComponentGeneration then
                     (if Reference.symbol
                      // betaGram.DynamicComponentGeneration then
                         true->isComponent
                     if);
                     reference.getSon1->ObjectSpecification[];
                     (if ObjectSpecification.symbol
                      // betaGram.NameApl then
                         ObjectSpecification[]->NameApl[];
                         NameApl[]->markSuperClass;
                         (NameApl[]->getEnclosingPattern,NameApl.dclRef,none ,
                          isComponent,none )->DynamicGenerations.myinsert
                      // betaGram.remote then
                         ObjectSpecification[]->theRemote[];
                         theRemote.getNameApl->NameApl[];
                         NameApl[]->markSuperClass;
                         theRemote.getAttributeDenotation->attDenotation[];
                         (if attDenotation.symbol
                          // betaGram.remote then
                             attDenotation[]->remote[];
                             remote.getNameApl->remNameApl[];
                             (NameApl[]->getEnclosingPattern,NameApl.dclRef,
                              remNameApl[]->isStatic,isComponent,theRemote[])
                               ->DynamicGenerations.myinsert
                          // betaGram.NameApl then
                             attDenotation[]->remNameApl[];
                             (NameApl[]->getEnclosingPattern,NameApl.dclRef,
                              remNameApl[]->isStatic,isComponent,theRemote[])
                               ->DynamicGenerations.myinsert
                          // betaGram.ThisObject then
                             (NameApl[]->getEnclosingPattern,NameApl.dclRef,none
                              ,isComponent,theRemote[])
                               ->DynamicGenerations.myinsert
                          else
                         (*Not an ordinary remote construction*)
                             
                         if)
                     if)
                 if)
              // betaGram.ObjectDenotation then
                 AstRef[]->ObjectDenotation[];
                 ObjectDenotation.getAttributeDenotation->attDenotation[];
                 (if attDenotation.symbol
                  // betaGram.NameApl then
                     attDenotation[]->NameApl[];
                     NameApl.dclRef->theDcl[];
                     theDcl.father->AstRef[];
                     AstRef.father->AstRef[];
                     (if AstRef.symbol
                      // betaGram.PatternDecl // betaGram.VirtualDecl
                      // betaGram.BindingDecl // betaGram.FinalDecl then
                         (NameApl[]->getEnclosingPattern,theDcl[],none ,
                          isComponent,none )->ProcedureCalls.myinsert
                     if)
                  // betaGram.remote then
                     attDenotation[]->theRemote[];
                     theRemote.getNameApl->NameApl[];
                     NameApl.dclRef->theDcl[];
                     theDcl.father->AstRef[];
                     AstRef.father->AstRef[];
                     (if AstRef.symbol
                      // betaGram.PatternDecl // betaGram.VirtualDecl
                      // betaGram.BindingDecl // betaGram.FinalDecl then
                         theRemote.getAttributeDenotation->attDenotation[];
                         (if attDenotation.symbol
                          // betaGram.remote then
                             attDenotation[]->remote[];
                             remote.getNameApl->remNameApl[];
                             (NameApl[]->getEnclosingPattern,NameApl.dclRef,
                              remNameApl[]->isStatic,isComponent,theRemote[])
                               ->ProcedureCalls.myinsert
                          // betaGram.NameApl then
                             attDenotation[]->remNameApl[];
                             (NameApl[]->getEnclosingPattern,NameApl.dclRef,
                              remNameApl[]->isStatic,isComponent,theRemote[])
                               ->ProcedureCalls.myinsert
                          // betaGram.ThisObject then
                             (NameApl[]->getEnclosingPattern,NameApl.dclRef,none
                              ,isComponent,theRemote[])->ProcedureCalls.myinsert
                          else
                         (*Not an ordinary remote construction*)
                             
                         if)
                     if)
                 if)
              // betaGram.StaticItem // betaGram.StaticComponent then
                 AstRef[]->refSpec[];
                 refSpec.getSon1->ObjectSpecification[];
                 (if ObjectSpecification.symbol
                  // betaGram.NameApl then
                     ObjectSpecification[]->NameApl[]; NameApl[]->markSuperClass
                  // betaGram.remote then
                     ObjectSpecification[]->remote[];
                     remote.getNameApl->NameApl[];
                     NameApl[]->markSuperClass
                  else
                     ObjectSpecification[]->getPrefixNameApl
                       ->(NameApl[],AstRef[]);
                     (if NameApl[] <> none
                      // true then NameApl[]->markSuperClass
                     if);
                     (if AstRef[] <> none
                      // true then AstRef[]->realySetup
                     if)
                 if)
              else
                 (if Astref.kind
                  // mps.kinds.interior then
                     AstRef[]->Exp[];
                     Exp.scan
                       (#  do current[]->realySetup #)
                  // mps.kinds.unExpanded then
                     (Astref.frag[],Astref[])
                       ->searchSlotBinding
                         (#
                            bindingFound::< 
                              (#  do ff.root[]->setupDynamicGenerations #)
                         #)
                 if)
             if)
          #);
        AstRef: ^MPS.AST;
        frag: ^mps.fragmentform;
        f: ^mps.fragment;
        fg: ^mps.fragmentgroup;
        ff: ^mps.fragmentform;
        help,ytext,ntext: ^text;
        de,de2: @diskentry;
        startPath,importPath: ^text;
        isSubpath:
          (# startPath,importPath: ^text; value: @Boolean; de: @diskentry
          enter (startPath[],importPath[])
          do
             (if startPath[]->importPath.equal then
                 true->value
              else
                 importPath[]->de.path.set;
                 de.path.head->importPath[];
                 (if importPath.empty = false then
                     (startPath[],importPath[])->isSubpath->value
                 if)
             if)
          exit value
          #);
        searchInclude:
          (# frag: ^mps.fragmentform; dummy: ^text
          enter frag[]
          do
             &text[]->ytext[];
             &text[]->ntext[];
             'y'->ytext.put;
             'n'->ntext.put;
             (for i: frag.import.impL.noOfElements repeat
               (if frag.import.impL.l[i][] <> none then
                   (if frag.import.impL.l[i].f[] <> none then
                       frag.import.impL.l[i].f.fullName->de2.path;
                       de2.path.head->importPath[];
                       (if true
                        // OGppProp.LocalIncludeScan then
                           (if (startPath[],importPath[])->isSubpath then
                               (if frag.import.impL.l[i].f[] <> frag[] then
                                   (if
                                   frag.import.impL.l[i].f[]
                                     ->searchedFragments.myappend then
                                       'Scanning included: '->puttext;
                                       frag.import.impL.l[i].f.fullName
                                         ->putline;
                                       frag.import.impL.l[i].f.root[]
                                         ->realySetup;
                                       frag.import.impL.l[i].f[]->searchInclude
                                   if)
                               if)
                           if)
                        // OGppProp.GlobalIncludeScan then
                           (if frag.import.impL.l[i].f[] <> frag[] then
                               (if
                               frag.import.impL.l[i].f[]
                                 ->searchedFragments.myappend then
                                   'Scanning included: '->puttext;
                                   frag.import.impL.l[i].f.fullName->putline;
                                   frag.import.impL.l[i].f.root[]->realySetup;
                                   frag.import.impL.l[i].f[]->searchInclude
                               if)
                           if)
                        // OGppProp.GlobalConfirmedScan then
                           (if frag.import.impL.l[i].f[] <> frag[] then
                               (if
                               frag.import.impL.l[i].f[]
                                 ->searchedFragments.myappend then
                                   'Scan included? : '->puttext;
                                   frag.import.impL.l[i].f.fullName->putline;
                                   answer:
                                     (# 
                                     do
                                        '(answer y or n):'->puttext;
                                        (if GetLine->dummy[]->ytext.equal then
                                            'Scanning included: '->puttext;
                                            frag.import.impL.l[i].f.fullName
                                              ->putline;
                                            frag.import.impL.l[i].f.root[]
                                              ->realySetup;
                                            frag.import.impL.l[i].f[]
                                              ->searchInclude
                                         else
                                            (if not (dummy[]->ntext.equal) then
                                                restart answer
                                            if)
                                        if)
                                     #)
                               if)
                           if)
                       if)
                    else
                       frag.fullName->de.path;
                       (frag.import.impL.l[i].n[],de.path.head)
                         ->mps.thePathHandler.convertFilePath->topDotOpen->ff[];
                       ff.fullname->de2.path;
                       de2.path.head->importPath[];
                       (if true
                        // OGppProp.LocalIncludeScan then
                           (if (startPath[],importPath[])->isSubpath then
                               (if ff[]->searchedFragments.myappend then
                                   'Scanning ORIGIN: '->puttext;
                                   ff.fullname->putline;
                                   ff.root[]->realySetup;
                                   ff[]->searchInclude
                               if)
                           if)
                        // OGppProp.GlobalIncludeScan then
                           (if ff[]->searchedFragments.myappend then
                               'Scanning ORIGIN: '->puttext;
                               ff.fullname->putline;
                               ff.root[]->realySetup;
                               ff[]->searchInclude
                           if)
                        // OGppProp.GlobalConfirmedScan then
                           (if ff[]->searchedFragments.myappend then
                               'Scan ORIGIN? : '->puttext;
                               ff.fullName->putline;
                               answer:
                                 (# 
                                 do
                                    '(answer y or n):'->puttext;
                                    (if GetLine->dummy[]->ytext.equal then
                                        'Scanning ORIGIN: '->puttext;
                                        ff.fullname->putline;
                                        ff.root[]->realySetup;
                                        ff[]->searchInclude
                                     else
                                        (if not (dummy[]->ntext.equal) then
                                            restart answer
                                        if)
                                    if)
                                 #)
                           if)
                       if)
                   if)
               if)
             for)
          #)
     enter AstRef[]
     do
        (if AstRef.frag[]->searchedFragments.myappend then
            'Scanning: '->puttext;
            AstRef.frag.fullName->putline;
            AstRef[]->realySetup;
            AstRef.frag[]->frag[];
            frag.fullName->de.path;
            de.path.head->startPath[];
            frag[]->searchInclude
        if)
     #);
   searchSlotBinding:
     (#
        theSlot: ^mps.slotdesc;
        slotName: ^text;
        found: @boolean;
        frag: ^mps.fragmentform;
        searchedUnexp: ^mps.unexpanded;
        bindingFound:< (# ff: ^mps.fragmentform enter ff[] do INNER #);
        bindingNotFound:<
          (# slotName: ^text enter slotName[] do INNER #);
        searchBinding:
          (#
             searchFrag,fg: ^mps.fragmentgroup;
             found: @boolean;
             ff: ^mps.fragmentform;
             help: ^text;
             de: @diskentry
          enter searchFrag[]
          do
             search: searchFrag.prop.scanProp
               (#
                  doProp::< 
                    (# 
                    do
                       (if true
                        // ('BODY'->prop.equalNCS) then
                           scanParameters
                             (#
                                doString::< 
                                  (# 
                                  do
                                     searchFrag.fullName->de.path;
                                     ((s[],de.path.head)
                                        ->mps.thePathHandler.convertFilePath,
                                      help[])->mps.top.Open->fg[];
                                     (if (* should test if open already *) fg[]
                                      // none then
                                         s[]->help[];
                                         ' not found'->help.putText;
                                         help[]-> (*UI.alert;*) putLine
                                      else
                                         fg.fragmentList.scan
                                           (# 
                                           do
                                              (if
                                              (current.name[]
                                                 ->slotName.equalNCS)
                                               // true then
                                                  (if current.type
                                                   // mps.formType then
                                                      true->found;
                                                      current.f[]->ff[]
                                                        ->bindingFound;
                                                      leave search
                                                   else
                                                      'Not a fragment form! '
                                                        ->putLine
                                                  if)
                                              if)
                                           #);
                                         fg[]->&searchBinding->found
                                     if)
                                  #)
                             #)
                        // ('MDBODY'->prop.equalNCS) then
                           searchMDbody: scanParameters
                             (#
                                t: ^text;
                                foundMachineType,isDefaultMachine: @boolean;
                                doName::< 
                                  (# 
                                  do
                                     '$(objdir)'->expandEnvVar->t[];
                                     (if t[]->n.equal then
                                         true->foundMachineType; 
                                      else
                                         (if 'default'->n.equal then
                                             true->isDefaultMachine
                                         if)
                                     if)
                                  #);
                                doString::< 
                                  (# 
                                  do
                                     searchFrag.fullName->de.path;
                                     (if foundMachineType or isDefaultMachine
                                      then
                                         'Choosing MDBODY '->putText;
                                         t[]->putLine;
                                         ((s[],de.path.head)
                                            ->
                                              mps.thePathHandler.
                                                convertFilePath,help[])
                                           ->mps.top.Open->fg[];
                                         (if (* should test if open already *)
                                         fg[]
                                          // none then
                                             s[]->help[];
                                             ' not found'->help.putText;
                                             help[]-> (*UI.alert;*) putLine
                                          else
                                             fg.fragmentList.scan
                                               (# 
                                               do
                                                  (if
                                                  (current.name[]
                                                     ->slotName.equalNCS)
                                                   // true then
                                                      (if current.type
                                                       // mps.formType then
                                                          true->found;
                                                          current.f[]->ff[]
                                                            ->bindingFound;
                                                          leave search
                                                       else
                                                          'Not a fragment form! '
                                                            ->putLine
                                                      if)
                                                  if)
                                               #);
                                             fg[]->&searchBinding->found
                                         if);
                                         leave searchMDbody
                                     if)
                                  #)
                             #)
                       if)
                    #)
               #)
          exit found
          #)
     enter (frag[],searchedUnexp[])
     do
        searchedUnexp.theSlot->theSlot[];
        theSlot.name->slotName[];
        frag.father->&searchBinding->found;
        (if found // false then slotName[]->bindingNotFound if)
     #);
   searchSLOT:
     (#
        slotName: ^text;
        g,searchFrag: ^mps.fragmentgroup;
        originName,help,path,name2: ^text;
        fg: ^mps.fragmentgroup;
        found: @boolean;
        slotFound:<
          (# anAST: ^MPS.AST enter anAST[] do INNER slotFound #);
        splitPath:
          (# e: @diskEntry enter e.path exit (e.path.head,e.path.name) #)
     enter (g[],slotName[])
     do
        g[]->searchFrag[];
        searchSlot: searchFrag.prop.scanProp
          (#
             doProp::< 
               (# 
               do
                  (if true
                   // ('ORIGIN'->prop.equalNCS) then
                      getString->originName[];
                      (if (originName.length > 0)
                       // true then
                          searchFrag.fullName->splitPath->(path[],name2[]);
                          ((originName[],path[])
                             ->mps.thePathHandler.convertFilePath,help[])
                            ->mps.top.Open->fg[];
                          (if fg[]
                           // none then ' not found'->putText
                           else
                              l: fg.scanSlots
                                (# 
                                do
                                   (if (current.Name->slotName.equalNCS)
                                    // true then
                                       true->found;
                                       current[]->slotFound;
                                       leave l
                                   if)
                                #);
                              (if found
                               // false then
                                  fg[]->searchFrag[];
                                  ''->originName[];
                                  restart searchSlot
                              if)
                          if)
                       else
                          'Could not find the SLOT '''->help[];
                          slotName[]->help.putText;
                          ''' on the ORIGIN chain'->help.putText;
                          help[]->puttext
                      if)
                  if)
               #)
          #)
     #);
   getEnclosingPattern:
     (#
        anAST: ^MPS.AST;
        attDecl: ^betaGram.AttributeDecl;
        fg: ^mps.fragmentgroup
     enter anAST[]
     do
        (if anAST.father
         // none then
            anAST.frag.father->fg[];
            (fg[],anAST.frag.name)
              ->searchSLOT
                (#
                   slotFound::< 
                     (#  do anAST[]->getEnclosingPattern->attDecl[] #)
                #)
         else
            anAst.father->anAST[];
            (if anAST.symbol
             // BetaGram.PatternDecl // betaGram.VirtualDecl
             // betaGram.BindingDecl // betaGram.FinalDecl
             // betaGram.SimpleDecl then
                anAST[]->attDecl[]
             else
                anAST[]->getEnclosingPattern->attDecl[]
            if)
        if)
     exit attDecl[]
     #);
   getEnclosingProc:
   (*Find den naermest omgivende procedure som er umiddelbart indeholdt i en
    klasse (eller klasse m. do-del ...).*)
     (#
        anAST: ^MPS.AST;
        attDecl: ^betaGram.AttributeDecl;
        fg: ^mps.fragmentgroup
     enter anAST[]
     do
        (if false
         // (anAST[],'(#Class#)')->checkKeyWord
         // anAST.symbol = betaGram.SimpleDecl then
            anAST[]->getEnclosingPattern->attDecl[];
            (if attDecl[]
             // none then anAST[]->attDecl[]
             else
                (if true
                 // (attDecl[],'(#Class#)')->checkKeyWord
                 // attDecl.symbol = betaGram.SimpleDecl then
                    anAST[]->attDecl[]
                 else
                    attDecl[]->getEnclosingProc->attDecl[]
                if)
            if)
         else
            anAST[]->attDecl[]
        if)
     exit attDecl[]
     #);
   prependComment:
     (#
        anAST: ^MPS.AST;
        commentText: @Text;
        CommentNode: ^mps.Comment;
        t: ^Text
     enter (anAST[],commentText)
     do
        (if anAST.hasComment
         // true then
            anAST.getComment->CommentNode[];
            CommentNode.gettext->t[];
            CommentText[]->t.prepend;
            t[]->CommentNode.putText
         else
            (mps.comment,1,anAST.frag[])->betaGram.newLexemText->CommentNode[];
            CommentText[]->CommentNode.putText;
            CommentNode[]->anAST.addComment;
            1
              -> (*1 ~ normalComment (hvad det saa end er?!)*)
                anAST.typeOfComment
        if)
     #);
   getPrefixNameApl:
     (#
        Objectspecification: ^MPS.AST;
        NameApl: ^betaGram.NameApl;
        anAST: ^MPS.AST;
        objectDesc: ^betaGram.Objectdescriptor;
        Prefix: ^betaGram.Prefix;
        attDenotation: ^betaGram.AttributeDenotation;
        remote: ^betaGram.remote;
        DescriptorForm: ^betaGram.DescriptorForm
     enter ObjectSpecification[]
     do
        (if Objectspecification.symbol
         // betaGram.ObjectDescriptor then
            ObjectSpecification[]->objectDesc[];
            objectDesc.getPrefixOpt->anAST[];
            (if anAST[] <> none
             // true then
                (if anAST.kind
                 // mps.kinds.interior then
                    anAST[]->Prefix[];
                    Prefix.getAttributeDenotation->attDenotation[];
                    (if attDenotation.symbol
                     // betagram.NameApl then
                        attDenotation[]->NameApl[]
                     // betaGram.remote then
                        attDenotation[]->remote[]; remote.getNameApl->NameApl[]
                    if)
                if)
            if);
            ObjectSpecification[]->anAST[]
         // mps.prodNo.unExpanded then
            (ObjectSpecification.frag[],ObjectSpecification[])
              ->searchSlotBinding
                (#
                   bindingFound::< 
                     (# 
                     do
                        ff.root[]->DescriptorForm[];
                        DescriptorForm.getObjectDescriptor->objectDesc[];
                        objectDesc.getPrefixOpt->anAST[];
                        (if anAST[] <> none
                         // true then
                            (if anAST.kind
                             // mps.kinds.interior then
                                anAST[]->Prefix[];
                                Prefix.getAttributeDenotation->attDenotation[];
                                (if attDenotation.symbol
                                 // betagram.NameApl then
                                    attDenotation[]->NameApl[]
                                 // betaGram.remote then
                                    attDenotation[]->remote[];
                                    remote.getNameApl->NameApl[]
                                if)
                            if)
                        if);
                        ff.root[]->anAST[]
                     #)
                #)
        if)
     exit (NameApl[],anAST[])
     #);
   myGetPrefix:
     (#
        theDescriptor: ^betaGram.ObjectDescriptor;
        tempAst: ^mps.ast;
        pref: ^betaGram.prefix;
        ad: ^betaGram.attributeDenotation;
        na: ^betaGram.NameApl;
        nd: ^betaGram.NameDcl;
        remote: ^betaGram.remote;
        thisPrefix: ^betaGram.ObjectDescriptor
     enter theDescriptor[]
     do
        theDescriptor.getPrefixOpt->tempAst[];
        (if tempAst[] <> none
         // true then
            (if tempAst.kind
             // mps.kinds.interior then
                tempAst[]->pref[];
                pref.getAttributeDenotation->tempAst[];
                (if tempAst.kind
                 // mps.kinds.interior then
                    tempAst[]->ad[];
                    ad.findDescriptor->thisPrefix[];
                    (if ad.symbol
                     // betaGram.NameApl then
                        ad[]->na[]
                     // betaGram.remote then
                        ad[]->remote[]; remote.getNameApl->na[]
                    if);
                    na.dclRef->nd[]
                if)
            if)
        if)
     exit (thisPrefix[],nd[])
     #);
   CheckKeyWord:
     (#
        node: ^mps.ast;
        keyword: ^text;
        found: @boolean;
        theCom: ^mps.comment;
        theComText,nextWord: ^text
     enter (node[],keyword[])
     do
        (if node.hasComment
         // true then
            node.getComment->theCom[];
            theCom.getText->theComText[];
            theComText.reset;
            search:
              (# 
              do
                 theComText.getAtom->nextWord[];
                 (if true
                  // keyWord[]->nextWord.equal then true->found
                  else
                     (if theComText.eos // false then restart search if)
                 if)
              #)
        if)
     exit found
     #);
   isPatternDefined:
     (#
        anAST: ^MPS.AST;
        nd: ^betaGram.NameDcl;
        refSpec: ^betaGram.referenceSpecification;
        Static: ^betaGram.StaticItem;
        na: ^betaGram.NameApl;
        sd: ^betaGram.SimpleDecl;
        remote: ^betaGram.remote
     enter anAST[]
     do
        (if anAST.symbol
         // betaGram.SimpleDecl then
            anAST[]->sd[];
            sd.getReferenceSpecification->refSpec[];
            (if refSpec.symbol
             // betaGram.StaticItem // betaGram.StaticComponent then
                refSpec.getSon1->anAST[];
                (if anAST.symbol
                 // betaGram.NameApl then
                    anAST[]->na[]
                 // betaGram.remote then
                    anAST[]->remote[]; remote.getNameApl->na[]
                if);
                (if na[] <> none // true then na.dclRef->nd[] if)
            if)
        if)
     exit nd[]
     #);
   realyGetNd:
     (#
        nd: ^betaGram.NameDcl;
        na: ^betaGram.NameApl;
        anAST: ^MPS.AST;
        ad: ^betaGram.AttributeDenotation;
        remote: ^betaGram.remote;
        simpleDecl: ^betaGram.SimpleDecl;
        refSpec: ^betaGram.ReferenceSpecification
     enter nd[]
     do
        nd.father->anAST[];
        anAST.father->anAST[];
        (if anAST.symbol
         // betaGram.SimpleDecl then
            anAST[]->simpleDecl[];
            simpleDecl.getReferenceSpecification->refSpec[];
            (if refSpec.symbol
             // betaGram.dynamicItem // betaGram.dynamicComponent then
                refSpec.getSon1->ad[];
                (if ad.symbol
                 // betaGram.NameApl then
                    ad[]->na[]; na.dclRef->nd[]
                 // betaGram.remote then
                    ad[]->remote[]; remote.getNameApl->na[]; na.dclRef->nd[]
                if)
            if)
        if)
     exit nd[]
     #);
   realyGetStaticNd:
     (#
        nd: ^betaGram.NameDcl;
        na: ^betaGram.NameApl;
        anAST: ^MPS.AST;
        remote: ^betaGram.remote;
        simpleDecl: ^betaGram.SimpleDecl;
        attDecl: ^betaGram.AttributeDecl;
        refSpec: ^betaGram.ReferenceSpecification
     enter nd[]
     do
        nd.father->anAST[];
        anAST.father->attDecl[];
        (if attDecl.symbol
         // betaGram.SimpleDecl then
            attDecl[]->SimpleDecl[];
            simpleDecl.getReferenceSpecification->refSpec[];
            (if refSpec.symbol
             // betaGram.StaticItem // betaGram.StaticComponent then
                refSpec.getSon1->anAST[];
                (if anAST.symbol
                 // betaGram.NameApl then
                    anAST[]->na[]; na.dclRef->nd[]
                 // betaGram.remote then
                    anAST[]->remote[]; remote.getNameApl->na[]; na.dclRef->nd[]
                 // betaGram.ObjectDescriptor then
                    anAST[]->getPrefixNameApl->(na[],anAST[]);
                    (if na[] <> none // true then na.dclRef->nd[] if)
                if)
            if)
        if)
     exit nd[]
     #);
   remoteEqual:
     (#
        r1,r2: ^betaGram.remote;
        na1,na2: ^betaGram.NameApl;
        nd1,nd2: ^betaGram.NameDcl;
        ad1,ad2: ^betaGram.AttributeDenotation;
        equal: @boolean
     enter (r1[],r2[])
     do
        r1.getNameapl->na1[];
        r2.getNameApl->na2[];
        na1.dclRef->nd1[];
        na2.dclRef->nd2[];
        (if nd1[]->nd2.equal
         // true then
            r1.getAttributeDenotation->ad1[];
            r2.getAttributeDenotation->ad2[];
            (if true
             //
             (ad1.symbol = betaGram.remote)
             and
             (ad2.symbol = betaGram.remote) then
                (ad1[],ad2[])->remoteEqual->equal
             //
             (ad1.symbol = betaGram.NameApl)
             and
             (ad2.symbol = betaGram.NameApl) then
                ad1[]->na1[];
                ad2[]->na2[];
                na1.dclRef->nd1[];
                na2.dclRef->nd2[];
                nd1[]->realyGetNd->nd1[];
                nd2[]->realyGetNd->nd2[];
                nd1[]->nd2.equal->equal
            if)
        if)
     exit equal
     #);
   remoteHeadDcl:
     (#
        R: ^betaGram.remote;
        nd: ^betaGram.NameDcl;
        na: ^betaGram.NameApl;
        ad: ^betaGram.attributeDenotation
     enter R[]
     do
        R.getAttributeDenotation->ad[];
        (if ad.symbol
         // betaGram.remote then
            ad[]->remoteHeadDcl->nd[]
         // betaGram.NameApl then
            ad[]->na[]; na.DclRef->nd[]
        if)
     exit nd[]
     #);
   recursiveEqual:
     (#
        nd,remNd: ^betaGram.NameDcl;
        anAST: ^MPS.AST;
        PatternDecl: ^betaGram.PatternDecl;
        desc: ^betaGram.ObjectDescriptor;
        equal: @Boolean
     enter (nd[],remNd[])
     do
        nd.father->anAST[];
        anAST.father->anAST[];
        (if anAST.symbol
         // betaGram.PatternDecl then
            (if nd[]->remNd.equal
             // true then true->equal
             else
                anAST[]->PatternDecl[];
                PatternDecl.getObjectDescriptor->myGetPrefix->(desc[],nd[]);
                (if nd[] <> none
                 // true then (nd[],remNd[])->recursiveEqual->equal
                if)
            if)
        if)
     exit equal
     #);
   myFindDescriptor:
     (#
        nd: ^betagram.NameDcl;
        ad: ^betaGram.AttributeDecl;
        sd: ^betaGram.SimpleDecl;
        refSpec: ^betaGram.referenceSpecification;
        anAST: ^MPS.AST;
        DescForm: ^betaGram.DescriptorForm;
        theDescriptor: ^betaGram.ObjectDescriptor;
        os: ^betaGram.ObjectSpecification
     enter nd[]
     do
        nd.father->anAST[];
        anAST.father->anAST[];
        (if anAST.symbol
         // betaGram.variablePattern // betaGram.bindingDecl
         // betaGram.virtualDecl // betaGram.FinalDecl then
            anAST[]->ad[];
            ad.getson2->anAST[];
            (if anAST.kind = mps.kinds.unExpanded then
                (anAST.frag[],anAST[])
                  ->searchSlotBinding
                    (#
                       bindingFound::< 
                         (# 
                         do
                            ff.root[]->anAST[];
                            anAST[]->descForm[];
                            descForm.getObjectDescriptor->theDescriptor[]
                         #)
                    #)
             else
                anAST[]->os[]; os.findDescriptor->theDescriptor[]
            if);
            
         // betaGram.patternDecl then
            anAST[]->ad[];
            ad.getson2->anAST[];
            (if anAST.kind = mps.kinds.unExpanded then
                (anAST.frag[],anAST[])
                  ->searchSlotBinding
                    (#
                       bindingFound::< 
                         (# 
                         do
                            ff.root[]->anAST[];
                            anAST[]->descForm[];
                            descForm.getObjectDescriptor->theDescriptor[]
                         #)
                    #)
             else
                anAST[]->theDescriptor[]
            if);
            
         // betaGram.SimpleDecl then
            anAST[]->sd[];
            sd.getReferenceSpecification->refSpec[];
            (if refSpec.symbol
             // betaGram.StaticItem // betaGram.StaticComponent then
                refSpec.getson1->anAST[];
                (if anAST.kind = mps.kinds.unExpanded then
                    (anAST.frag[],anAST[])
                      ->searchSlotBinding
                        (#
                           bindingFound::< 
                             (# 
                             do
                                ff.root[]->anAST[];
                                anAST[]->descForm[];
                                descForm.getObjectDescriptor->theDescriptor[]
                             #)
                        #)
                 else
                    anAST[]->os[]; os.findDescriptor->theDescriptor[]
                if)
            if)
        if)
     exit theDescriptor[]
     #);
   isSimple:
     (#
        value: @boolean;
        nd: ^betaGRam.NameDcl;
        anAST: ^MPS.AST;
        sd: ^betaGRam.SimpleDecl;
        refSpec: ^betaGram.Referencespecification;
        ad: ^betaGram.AttributeDenotation;
        na: ^betaGram.NameApl;
        t: ^text
     enter nd[]
     do
        nd.father->anAST[];
        anAST.father->anAST[];
        (if anAST.Symbol = betaGram.SimpleDecl then
            anAST[]->sd[];
            sd.getReferenceSpecification->refSpec[];
            (if refSpec.symbol = betaGram.StaticItem then
                refSpec.getson1->anAST[];
                (if anAST.struc <= betaGram.AttributeDenotation## then
                    anAST[]->ad[];
                    (if ad.symbol = betaGram.nameapl then
                        ad[]->na[];
                        na.gettext->t[];
                        (('integer'->t.equalNCS) or ('boolean'->t.equalNCS) or
                         ('char'->t.equalNCS))->value
                    if)
                if)
            if)
        if)
     exit (value,t[])
     #);
   toggleProc:
     (#
        showProcConn:
          (#
             realyShowProcConn:
               (#
                  node,creatingNode: ^theObjectPage.ObjectDiagramNode;
                  detailnode: ^theObjectPage.DetailedObjectNode
               enter node[]
               do
                  (if (node.struc <= theObjectPage.AbstrOperationObjectNode##)
                  or (node.struc <= theObjectPage.DetailOperationObjectNode##)
                   then
                      node.theDecl[]
                        ->NameDclAttr.scanTheDclElms
                          (# 
                          do
                             myCurrent.CreatingObjectIDs.scan
                               (# 
                               do
                                  current->theObjectlistmyFind->creatingNode[];
                                  (if
                                  ((creatingNode[],node[],myCurrent.theRemote[])
                                     ->drawConnectortest) then
                                      (creatingNode[],node[])
                                        ->theObjectPage.newConnector
                                  if)
                               #)
                          #)
                  if);
                  (if node.struc <= theObjectPage.DetailedObjectNode## then
                      node[]->detailnode[];
                      detailnode.ODNodes.scan
                        (#  do current[]->realyShowProcConn #)
                  if)
               #);
             node: ^theObjectPage.ObjectDiagramNode
          do
             theObjectPage.CurrentObject->node[];
             loop:
             (if node.parentnode[] <> none then
                 node.parentnode[]->node[]; restart loop
             if);
             node[]->realyShowProcConn
          #);
        removeProcConn:
          (# conlist: ^ObjectList; con: ^theObjectPage.Connector
          do
             theObjectPage.getconnectors->conlist[];
             (if conlist[] <> none then
                 conlist.scan
                   (# 
                   do
                      current[]->con[];
                      (if con.linetype = OgppProp.solid then con.delete if)
                   #)
             if)
          #)
     do
        (if currentPage = theObjectPage[] then
            (if theObjectPage.currentObject <> none then
                (if theObjectPage.showProcedureCalls then
                    false->theObjectPage.showProcedureCalls
                      ->objectMenu.toggleProcedureCalls.check;
                    removeProcConn
                 else
                    true->theObjectPage.showProcedureCalls
                      ->objectMenu.toggleProcedureCalls.check;
                    showProcConn
                if)
             else
                'No object selected !'->putline
            if)
         else
            'Not an objectpage !'->putline
        if)
     #);
   toggleDynamicCreations:
     (#
        showDynamicCreationConn:
          (#
             realyShowDynamicCreationConn:
               (#
                  node,creatingNode: ^theObjectPage.ObjectDiagramNode;
                  detailnode: ^theObjectPage.DetailedObjectNode
               enter node[]
               do
                  (if (node.struc <= theObjectPage.AbstrDynamicObjectNode##) or
                  (node.struc <= theObjectPage.DetailDynamicObjectNode##) then
                      node.theDecl[]
                        ->NameDclAttr.scanTheDclElms
                          (# 
                          do
                             myCurrent.CreatingObjectIDs.scan
                               (# 
                               do
                                  current->theObjectlistmyFind->creatingNode[];
                                  (if
                                  ((creatingNode[],node[],myCurrent.theRemote[])
                                     ->drawConnectortest) then
                                      (creatingNode[],node[])
                                        ->theObjectPage.newDynConnector
                                  if)
                               #)
                          #)
                  if);
                  (if node.struc <= theObjectPage.DetailedObjectNode## then
                      node[]->detailnode[];
                      detailnode.ODNodes.scan
                        (#  do current[]->realyShowDynamicCreationConn #)
                  if)
               #);
             node: ^theObjectPage.ObjectDiagramNode
          do
             theObjectPage.CurrentObject->node[];
             loop:
             (if node.parentnode[] <> none then
                 node.parentnode[]->node[]; restart loop
             if);
             node[]->realyShowDynamicCreationConn
          #);
        removeDynamicCreationConn:
          (# conlist: ^ObjectList; con: ^theObjectPage.Connector
          do
             theObjectPage.getconnectors->conlist[];
             (if conlist[] <> none then
                 conlist.scan
                   (# 
                   do
                      current[]->con[];
                      (if con.linetype = OgppProp.dashed then con.delete if)
                   #)
             if)
          #)
     do
        (if currentPage = theObjectPage[] then
            (if theObjectPage.currentObject <> none then
                (if theObjectPage.showDynamicCreations then
                    false->theObjectPage.showDynamicCreations
                      ->ObjectMenu.toggleDynamicCreations.check;
                    removeDynamicCreationConn
                 else
                    true->theObjectPage.showDynamicCreations
                      ->ObjectMenu.toggleDynamicCreations.check;
                    showDynamicCreationConn
                if)
             else
                'No object selected !'->putline
            if)
         else
            'Not an objectpage !'->putline
        if)
     #);
   theObjectListmyFind:
     (# ID: @Integer; node: ^theObjectPage.ObjectDiagramNode
     enter ID
     do
        ID->theObjectList.find->node[];
        (if node[] = none then
            'DesignObject not found in theObjectList'->putline
        if)
     exit node[]
     #);
   myVirtDcl:
     (# nd: ^betaGram.NameDcl
     enter nd[]
     do
        (if ((nd.father).father).symbol
         // betaGram.BindingDecl // betaGram.FinalDecl then nd.virtDcl->nd[]
         else
            none ->nd[]
        if)
     exit nd[]
     #)
#)  

