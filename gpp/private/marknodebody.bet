ORIGIN 'diagramattributes';
LIB_ITEM 'gpp';
-- CommentNodeDisplay: Descriptor --
(# x,y,w,h: @Integer; 
do
   theNode.geometry->(x,y,w,h);
   x+w div 2->pos.x;
   y->pos.y;
   (*(if gppProp.CompositionDType > gppProp.CompositionNested
    // false then
    y->pos.y; 
    // true then
    y-h div 2->pos.y; 
    if);*)
   
#)  

-- CommentMarkOnInit: Descriptor --
(# 
do
   UDPrivate.UDCommentMark->UserDataInit;
   open.Init;
   theCommentNode.Init;
   theConn.Init;
   gray22->FillType;
   (* make gray *)
   (*'c' -> theText.set;*)
   
#)  

-- CommentMarkOnRemove: Descriptor --
(# 
do (if open and (theCommentNode <> none ) // true then deactivate if); 
#)  

-- CommentMarkDoubleClick: Descriptor --
(# 
do
(*false->proceed;
 'CommentMarkDoubleClick'->screen.putLine; 
 (if open
 //false then activate;
 //true then deactivate;
 if);
 * *) 
#)  

-- CommentMarkSelect: Descriptor --
(#  do (if open then deactivate else activate if) #)  

-- CommentMarkActivate: Descriptor --
(# x,y,w,h: @Integer; theComment: ^MyCommentNode; 
do
   (if not open then
       &MyCommentNode[]->theComment[];
       THIS(CommentMark)[]->theComment.theMarkNode;
       geometry->(x,y,w,h);
       (x+(w div 2)+100+20,y+65,200,130)->theComment.New;
       theComment[]->theCommentNode;
       true->open
   if)
#)  

-- CommentMarkDeactivate: Descriptor --
(# 
do
   (if open
    // true then
       (theCommentNode).delete;
       none ->theCommentNode;
       none ->theConn;
       false->open;
       
   if);
   
#)  

-- MyCommentNodeOnInit: Descriptor --
(#
   x,y,w,h,a,b: @Integer;
   box: ^RectNode;
   con: ^connector;
   t: ^Text;
   polyNode1,polyNode2: ^PolygonNode;
   poly1,poly2: [4] @Integer
do
   UDPrivate.UDMyCommentNode->UserDataInit;
   theMarkNode.Init;
   1->LineThickNess;
   white->FillType;
   10->theText.size;
   font.Helvetica->theText.font;
   (if not initialisingSaved then
       (theMarkNode).theComment.gettext->t[];
       t[]->patternDiagrams.astUtils.skipLeadingBlanks->theText.set;
       textJust.leftJustification->theText.just;
       FitToText;
       theMarkNode->CreateRegion;
       &RectNode[]->box[];
       geometry->(x,y,w,h);
       x-(w div 2)->a;
       y-(h div 2)->b;
       (x-(w div 2)+1,y-(h div 2)+1,1,1)->box.new;
       false->box.BorderVisible;
       false->box.selectable;
       THIS(MyCommentNode)[]->box.CreateRegion;
       &connector[]->con[];
       (box[],theMarkNode)->con.new;
       con[]->(theMarkNode).theConn
   if)
#)  

-- CommentNodeOnRemove: Descriptor --
(# 
do
   false->(theMarkNode).open;
   none ->(theMarkNode).theCommentNode;
   none ->(theMarkNode).theConn
#)  

-- CommentNodeDeactivate: Descriptor --
(# 
do (if theMarkNode <> none // true then (theMarkNode).deactivate if); 
#)  

-- AnchorMarkDisplay: Descriptor --
(# x,y,w,h: @Integer; 
do (thePatternDiagramNode).geometry->(x,y,w,h); x-w div 2->pos.x; y->pos.y; 
#)  

-- AnchorMarkOnInit: Descriptor --
(# 
do
   UDPrivate.UDAnchorMark->UserDataInit;
   gray22->FillType;
   (* make gray *)
   (*'a' -> theText.set;*)
   
#)  

-- AnchorMarkDoubleClick: Descriptor --
(#  do 'AnchorMarkDoubleClick'->screen.putline;  #)  

-- AnchorMarkActivate: Descriptor --
(# x,y,w,h: @Integer; 
do (* hilite the achor in some way *)
   THIS(AnchorMark)[]->CurrentObject;
   (* select *)
   geometry->(x,y,w,h);
   (*(x,y,w*2,h*2) -> geometry; no no!! *)
   black->FillType;
   
#)  

-- AnchorMarkDeactivate: Descriptor --
(# x,y,w,h: @Integer; 
do (* unhilite the achor in some way *)
   geometry->(x,y,w,h);
   (*(x,y,w div 2,h div 2) -> geometry; no no!!*)
   gray22->FillType;
   (* make gray *)
   
#)  

