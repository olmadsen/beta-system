ORIGIN 'diagramattributes';
(* switches:
 * 20 = print info about each symbol displayed
 *)
-- DisplayAST: Descriptor --
(#
   theDecl: ^betaGram.AttributeDecl;
   theNames: ^betaGram.names;
   theNodeType: ##DiagramNode;
   unExp: ^mps.unexpanded;
   aSlotNode: ^SlotNode;
   aNode: ^DiagramNode;
   nt: ^NonTerminalNode;
   adjustPos: @
     (# x,y,w,h: @Integer; 
     enter (x,y,w,h)
     do
     (* (if gppProp.CompositionDType > gppProp.CompositionNested
      *          // true then
      *             (if w <> (gppProp.width*2)
      *              // true then {* box is not standard width; adjust x position *}
      *                 x-((gppProp.width*2-w) div 2)->x; (x,y)->aNode.Center; 
      *             if);
      *             x+(w div 2)+gppProp.width+10->pos.x;
      *             
      *          else
      *             pos.y+gppProp.height->pos.y; 
      *         if)
      *) pos.y+gppProp.height->pos.y
     #);
   
do
   (if anAST[]
    // none then
       'Freja[[ERROR: Display AST: anAST is NONE]]'->screen.putline; 
    else
       kindtest:
       (if anAST.kind
        // mps.kinds.interior then
           (if anAST.symbol
            // betaGram.PatternDecl then
               PatternNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: PatternNode'->T #);
               
            // betaGram.SimpleDecl then
               SimpleNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: SimpleNode'->T #);
               
            // betaGram.RepetitionDecl then
               RepetitionNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: RepetitionNode'->T #);
               
            // betaGram.VirtualDecl then
               VirtualNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: VirtualNode'->T #);
               
            // betaGram.BindingDecl then
               BindingNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: BindingNode'->T #);
               
            // betaGram.FinalDecl then
               FinalNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: FinalNode'->T #);
               
            else
               20->trace (#  do 'DisplayAst: unknown symbol'->T #);
               (if anAST.father <> none
                // true then
                   20->trace (#  do '\tTrying father recursively'->T #);
                   (anAST.father,pos)->&DisplayAST->pos;
                   
                else
                   20->trace (#  do '\tFather is NONE'->T #); 
               if);
               leave kindtest;
               
           if);
           anAST[]->theDecl[];
           theDecl.getson1->anAST[];
           (if anAST[]
            // none then 'Freja[[ERROR: son1 is NONE]]'->screen.putline; 
            else
               (if anAST.kind
                // mps.kinds.interior then
                   anAST[]->theNames[];
                   (if theNames[]
                    // none then
                       'Freja[[ERROR: DisplayAST theNames is NONE]]'
                         ->screen.putline;
                       
                    else
                       theNames.scan
                         (# 
                         do
                            &theNodeType[]->aNode[];
                            THIS(ListDiagram)[]->aNode.theDiagram;
                            (pos,theDecl[],current[])->aNode.display;
                            (if remakingDiagram
                             // true then
                                20
                                  ->trace
                                    (#  do 'Remake; calling conclude'->T #);
                                (0,0)->aNode.ConcludeDisplay;
                                
                            if);
                            aNode.geometry->adjustPos;
                            20->trace (#  do 'Names'->T #);
                            
                         #);
                       
                   if);
                   
                // mps.kinds.unExpanded then
                   &theNodeType[]->aNode[];
                   (pos,theDecl[],anAST[])->aNode.display;
                   (if remakingDiagram
                    // true then
                       20->trace (#  do 'Remake; calling conclude'->T #);
                       (0,0)->aNode.ConcludeDisplay;
                       
                   if);
                   THIS(ListDiagram)[]->aNode.theDiagram;
                   aNode.geometry->adjustPos;
                   20->trace (#  do 'Optional'->T #);
                   
                // mps.kinds.optional then
                   'DisplayAST: son1 is optional'->screen.putline; 
               if);
               
           if);
           
        // mps.kinds.unExpanded then
           20->trace (#  do ' DisplayAST: unexpanded'->T #);
           anAST[]->unExp[];
           (if unExp.isSlot
            // true then
               20->trace (#  do ' DisplayAST: SLOT'->T #);
               &SlotNode[]->aSlotNode[];
               THIS(ListDiagram)[]->aSlotNode.theDiagram;
               (pos,unExp.theSLOT)->aSlotNode.display;
               (if remakingDiagram
                // true then
                   20->trace (#  do 'Remake; calling conclude'->T #);
                   (0,0)->aSlotNode.ConcludeDisplay;
                   
               if);
               aSlotNode.geometry->adjustPos;
               20->trace (#  do 'UnExpanded'->T #);
               
            else
           (* it is a non-terminal *)
               &NonTerminalNode[]->nt[];
               THIS(ListDiagram)[]->nt.theDiagram;
               (pos,unExp[])->nt.display;
               (if remakingDiagram
                // true then
                   20->trace (#  do 'Remake; calling conclude'->T #);
                   (0,0)->nt.ConcludeDisplay;
                   
               if);
               nt.geometry->adjustPos;
               20->trace (#  do 'non-terminal'->T #);
               
           if);
           
        // mps.kinds.optional then
           20->trace (#  do 'mps.kinds.optional'->T #); 
        // mps.kinds.NameAppl // mps.kinds.String // mps.kinds.NameDecl then
           20->trace (#  do 'mps.kinds.NameAppl/NameDecl/String'->T #);
           (anAST.father,pos)->&DisplayAST->pos;
           
        else
           20
             ->trace
               (#  do 'mps.kinds.other: '->T; anAST.kind->T.putint;  #);
           'DisplayAST: mps.kinds.other'->screen.putline;
           
       if)
   if)
#)  

-- AbstractNodeRemove: Descriptor --
(# abstracted: @boolean; thePatternDiagram: ^PatternDiagram; 
do
   (if switch[1] // true then 'DiagramNode: remove callback'->putline if);
   (if currentDecomposDiagram <> none
    // true then (* this node is detailed *)
    (* mark THIS(DiagramNode) as no longer detailed *)
       currentDecomposDiagram->thePatternDiagram[];
       thePatternDiagram.titleNode.delete;
       (* remove the detailed diagram *)
       none ->currentDecomposDiagram;
       true->abstracted;
       
   if);
   decomposdiagrams.scan
     (#  do current[]->currentDecomposDiagram #);
   (if abstracted
    // false then
    (* remove THIS(AbstractNode) from the diagramlist and update the diagram *)
       (THIS(AbstractNode)[],false)->DeleteDiagramNode; 
   if);
   
#)  

-- AbstractNodeDisplay: Descriptor --
(# 
do
   INNER Display;
   gppProp.fontSize->theText.size;
   t->theText.set;
   FitToText;
   size->updateMaxWH;
   (* if this node is in a tree then adjust the size to o fit the text *)
   (if theTreeConn[] <> none // true then FitToText;  if);
   (if PatternDiagrams.addAfterNode[]
    // none then THIS(AbstractNode)[]->localNodes.append; 
    else
       THIS(AbstractNode)[]->PatternDiagrams.newNode[];
       (* save the new node so it can
        * be added later *)
       
   if);
   (if THIS(ListDiagram)## <= FragmentDiagram## then
       
    else
       (if not gppProp.showAttributes then
           theText.get->t;
           (if not (''->t.equal) then t[]->invisibleText if);
           theText.clear;
           false->BorderVisible;
           false->selectable
       if)
   if);
   
#)  

-- AbstractNodeReDisplay: Descriptor --
(# w,h: @integer
do
   INNER ReDisplay;
   t->theText.set;
   0->MaxWidth;
   0->MaxHeight;
   FitToText;
   size->updateMaxWH;
   localNodes.scan
     (#  do current.FitToText; current.size->updateMaxWH #);
   (if theTreeConn[] <> none // true then FitToText;  if);
   (if THIS(ListDiagram)## <= FragmentDiagram## then
       
    else
       THIS(ListDiagram).localNodes.scan
         (# 
         do
            (if not gppProp.showAttributes then
                theText.get->t;
                (if not (''->t.equal) then t[]->invisibleText if);
                theText.clear;
                false->BorderVisible;
                false->selectable
            if)
         #)
   if);
   
#)  

-- AbstractNodeConcludeDisplay: Descriptor --
(# 
do
   false->sizeable;
   (* dont resize this *)
   (if theTreeConn[]
    // none then
       false->moveable;
       (* we don't like these Nodes in simple patterndiagrams *)
       
   if);
   titleNode[]->CreateRegion;
   
#)  

-- AbstractNodeMakeAnchor: Descriptor --
(# 
do
   (if theDexterAnchor[]
    // none then
       &AnchorMark[]->theDexterAnchor[];
       THIS(AbstractNode)[]->theDexterAnchor.display;
       
   if)
#)  

-- AbstractNodeAbstractedFromDiagramBelow: Descriptor --
(# 
do
   (if switch[1]
    // true then 'PatternDiagram: abstractedFromDiagramBelow'->putline; 
   if);
   (if CheckForAttributes
    // true then
       none ->currentDecomposDiagram;
       decomposDiagrams.scan
         (#  do current[]->currentDecomposDiagram #);
       (* mark THIS(DiagramNode) as no longer detailed *)
       (* change the style of the text, so the user can see that 
        * it is no longer detailed *)
       (*gppProp.AbstractedStyle -> theText.style; not needed when dots are used*)
       
   if);
   
#)  

-- AbstractNodeDetail: Descriptor --
(# att: ^betaGram.attributes; t: @Text; dummyDetailPage: ^OADPage
do (*   'Detailing...'->statusbar.set;*)
   cursor.wait->cursor.set;
   (if CheckForAttributes
    // true then
       (if currentDecomposDiagram = none then
           (if detailPage
            // none then (* make the decompose page *)
               (if gppProp.DetailedOnSamePage
                // false then
                   &OADPage[]->dummyDetailPage[];
                   dummyDetailPage.new;
                   dummyDetailPage[]->detailPage;
                   (* changes page automatically *)
                   titleNode.theText.get->t;
                   
                else
                   (if theWorkPage[]
                    // none then
                       &OADPage[]->theWorkPage[];
                       theWorkPage.new;
                       'WorkSheet'->theWorkPage.PageTitle;
                       
                   if);
                   theWorkPage[]->detailPage;
                   (* make detailPage the same page as
                    * parentNode
                    *)
                   
               if)
            else
               detailPage->CurrentPage; (* just select the page *) 
           if);
           (if currentDecomposDiagram
            // none then 
            else
           (*   currentDecomposDiagram->decomposDiagrams.append; *)
               
           if);
           INNER Detail;
           (if currentDecomposDiagram
            // none then
               'Freja[[ERROR: abstractnodebody: no decomposition diagram created]]'
                 ->putline;
               
            else
               (currentDecomposDiagram).titleNode.onSelect
               (*Moved to DiagramNodeDetail:
                THIS(AbstractNode)[]->(currentDecomposDiagram).theParentNode *)
           if)
        else
           (currentDecomposDiagram).titleNode[]->currentObject;
           (currentDecomposDiagram).titleNode.onSelect
       if);
       (*gppProp.DetailedStyle -> theText.style;*)
       (* make the diagram *)
       
   if);
   (*   statusbar.reset;*)
   cursor.reset;
   (* if freja and sif is present then we can show
    * dexter anchors in the detailed diagrams *)
   
#)  

-- AbstractNodeAbstract: Descriptor --
(# abstracted: @boolean; thePatternDiagram: ^PatternDiagram; 
do
   (if currentDecomposDiagram <> none
    // true then
       currentDecomposDiagram->thePatternDiagram[];
       thePatternDiagram.titleNode.abstract;
       true->abstracted;
       
   if);
   none ->currentDecomposDiagram;
   decomposDiagrams.scan
     (#  do current[]->currentDecomposDiagram #);
   (*  (if abstracted
    // false then
    [* remove THIS(AbstractNode) from the diagramlist and update the diagram *]
    (THIS(AbstractNode)[],false)->DeleteDiagramNode;
    if);*)
   
#)
(********************************* DiagramNode *************************************)  

-- AbstractNodeDump: Descriptor --
(# 
do
   '********theName********'->putline;
   theName->putline;
   '********currentDecomposDiagram********'->putline;
   (if currentDecomposDiagram <> none then
       (currentDecomposDiagram).titletext[]->putline
    else
       'is NONE!'->putline
   if)
#)  

-- DiagramNodeDisplay: Descriptor --
(#
   aName: ^betaGram.NameDcl;
   theDecl: ^mps.namedecl;
   a: ^MPS.AST;
   dummy: ^Text
do
   (if THIS(DiagramNode).struc <= SimpleAttributeDecl##
    // true then (*RndRect*) Rectangle->DefaultShape; 
   if);
   (if switch[18] then
       '******** abstractnodebody-DiagramNodeDisplay 2 calling new with ********'
         ->putline;
       'x: '->putText;
       pos.x+(gppProp.width+1) div 2->putint;
       newLine;
       'y: '->putText;
       pos.y+(gppProp.height+1) div 2->putint;
       newLine;
       'w: '->putText;
       gppProp.width->putint;
       newLine;
       'h: '->putText;
       gppProp.height->putint;
       newLine;
       
   if);
   (pos.x+(gppProp.width+1) div 2,pos.y+(gppProp.height+1) div 2,gppProp.width,
    gppProp.height,defaultshape)->new;
   (theDeclaration).index->astIndex;
   (if switch[1] then
       'DiagramNodeDisplay: '->putText; astIndex->putInt; '->astIndex'->putLine
   if);
   (if anAST[]
    // none then '<<no name>>'->t; 
    else
       (if anAST.kind
        // mps.kinds.unExpanded then
           '<<NameDcl>>'->theName->dummy[]; dummy->t; 
        // mps.kinds.optional then
           '<<Optional>>'->theName->dummy[]; dummy->t; 
        else
           (if anAST.symbol
            // betaGram.NameDcl then
               anAst[]->aName[];
               aName.getNameDecl->a[];
               (if a.kind
                // mps.kinds.unExpanded then
                   '<<NameDecl>>'->theName->dummy[]; dummy->t; 
                // mps.kinds.optional then
                   '<<Optional>>'->theName->dummy[]; dummy->t; 
                else
               (* is a real name *)
                   a[]->theDecl[]; theDecl.getText->theName->dummy[]; dummy->t; 
               if);
               
            // mps.unExpanded then
               '<<unExp>>'->theName->dummy[]; dummy->t; 
            else
               'Freja[[DiagramNodeDisplay: anAST is unknown'->screen.putline; 
           if);
           
       if);
       
   if);
   INNER Display;
   
#)  

-- DiagramNodeRedisplay: Descriptor --
(#
   aName: ^betaGram.NameDcl;
   theDecl: ^mps.namedecl;
   a: ^MPS.AST;
   dummy: ^Text
do
   (if switch[1]
    // true then
       'PatternDiagram: DiagramNodeRedisplay, theDeclaration.index: '->putText;
       (theDeclaration).index->putInt;
       newLine;
       'PatternDiagram: DiagramNodeRedisplay, anAst.index: '->putText;
       anAst.Index->putInt;
       newLine;
       
   if);
   anAST.index->astIndex;
   (if switch[1] then
       'DiagramNodeReDisplay: '->putText;
       astIndex->putInt;
       '->astIndex'->putLine
   if);
   (if anAST[]
    // none then '<<no name>>'->t; 
    else
       (if anAST.kind
        // mps.kinds.unExpanded then
           '<<NameDcl>>'->theName->dummy[]; dummy->t; 
        // mps.kinds.optional then
           '<<Optional>>'->theName->dummy[]; dummy->t; 
        else
           (if anAST.symbol
            // betaGram.NameDcl then
               anAst[]->aName[];
               aName.getNameDecl->a[];
               (if a.kind
                // mps.kinds.unExpanded then
                   '<<NameDecl>>'->theName->dummy[]; dummy->t; 
                // mps.kinds.optional then
                   '<<Optional>>'->theName->dummy[]; dummy->t; 
                else
               (* is a real name *)
                   a[]->theDecl[]; theDecl.getText->theName->dummy[]; dummy->t; 
               if);
               
            // mps.unExpanded then
               '<<unExp>>'->theName->dummy[]; dummy->t; 
            else
               'Freja[[DiagramNodeReDisplay: anAST is unknown'->screen.putline; 
           if);
           
       if);
       
   if);
   INNER Redisplay;
   
#)  

-- DiagramNodeConcludeDisplay: Descriptor --
(#
   x,y,w,h: @Integer;
   m: ^CommentMark;
   pd: ^betaGram.PatternDecl;
   sd: ^betaGram.SimpleDecl;
   rd: ^betaGram.RepetitionDecl;
   vd: ^betaGram.VirtualDecl;
   bd: ^betaGram.BindingDecl;
   fd: ^betaGram.FinalDecl;
   (*vpd: ^betaGram.VariablePatternDecl;*)
   theCom: ^mps.comment;
   comPrefix: ^text;
   
do
(* Check for comments on this node 
 * should be done on tree level but I have only 5 minutes...
 *)
   (if (theDeclaration).struc
    // betaGram.PatternDecl## then
       theDeclaration->pd[];
       (if pd.hasComment
        // true then
           pd.getComment->theCom[];
           theCom.getText->comPrefix[];
           (if true
            // '(#Proc#)'->comPrefix.equal // '(#Class#)'->comPrefix.equal then
               
            else
               &CommentMark[]->m[];
               (THIS(DiagramNode)[],pd.getComment)->m.display;
               
           if)
       if)
    // betaGram.SimpleDecl## then
       theDeclaration->sd[];
       (if sd.hasComment
        // true then
           sd.getComment->theCom[];
           theCom.getText->comPrefix[];
           (if true
            // '(#Proc#)'->comPrefix.equal // '(#Class#)'->comPrefix.equal then
               
            else
               &CommentMark[]->m[];
               (THIS(DiagramNode)[],sd.getComment)->m.display;
               
           if)
       if)
    // betaGram.RepetitionDecl## then
       theDeclaration->rd[];
       (if rd.hasComment
        // true then
           rd.getComment->theCom[];
           theCom.getText->comPrefix[];
           (if true
            // '(#Proc#)'->comPrefix.equal // '(#Class#)'->comPrefix.equal then
               
            else
               &CommentMark[]->m[];
               (THIS(DiagramNode)[],rd.getComment)->m.display;
               
           if);
           
       if)
    // betaGram.VirtualDecl## then
       theDeclaration->vd[];
       (if vd.hasComment
        // true then
           vd.getComment->theCom[];
           theCom.getText->comPrefix[];
           (if true
            // '(#Proc#)'->comPrefix.equal // '(#Class#)'->comPrefix.equal then
               
            else
               &CommentMark[]->m[];
               (THIS(DiagramNode)[],vd.getComment)->m.display;
               
           if)
       if)
    // betaGram.BindingDecl## then
       theDeclaration->bd[];
       (if bd.hasComment
        // true then
           bd.getComment->theCom[];
           theCom.getText->comPrefix[];
           (if true
            // '(#Proc#)'->comPrefix.equal // '(#Class#)'->comPrefix.equal then
               
            else
               &CommentMark[]->m[];
               (THIS(DiagramNode)[],bd.getComment)->m.display;
               
           if)
       if)
    // betaGram.FinalDecl## then
       theDeclaration->fd[];
       (if fd.hasComment
        // true then
           fd.getComment->theCom[];
           theCom.getText->comPrefix[];
           (if true
            // '(#Proc#)'->comPrefix.equal // '(#Class#)'->comPrefix.equal then
               
            else
               &CommentMark[]->m[];
               (THIS(DiagramNode)[],fd.getComment)->m.display;
               
           if)
       if)
       (*  //betaGram.VariablePatternDecl## then
        theDeclaration -> vpd[];
        (if vpd.hasComment //true then
        vpd.getComment->theCom[];
        theCom.getText->comPrefix[];
        (if true
        //'(#Proc#)'->comPrefix.equal 
        //'(#Class#)'->comPrefix.equal  then 
        else
        &CommentMark[] -> m[];
        (THIS(DiagramNode)[],vpd.getComment) -> m.display;
        if)
        if)
        *)
   if);
   (*(if theObjectDescriptor<>NONE//true then
    (if (theObjectDescriptor).hasComment//true then
    &CommentMark[] -> m[];
    (THIS(DiagramNode)[],(theObjectDescriptor).getComment) -> m.display;
    if)
    else
    (if (theDeclaration).hasComment//true then
    &CommentMark[] -> m[];
    (THIS(DiagramNode)[],(theDeclaration).getComment) -> m.display;
    else
    if)
    if);
    *)
   (* (if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
    (if switch[1]
    // true then
    'ConcludeDisplay: moving node: '->screen.puttext;
    dist.x->screen.putint;
    ' '->screen.put;
    dist.y->screen.putint;
    screen.newline;
    
    if);
    geometry->(x,y,w,h);
    x-dist.x->x;
    (x,y,w,h)->geometry;
    (if theTreeConn[] <> none
    // true then
    (# p: [8] @Integer; last: ^PatternDiagramNode; 
    do
    x->p[5];
    [* set two points on the connector *]
    y-(gppProp.DownOnPage)->p[6];
    [* a bit up *]
    y-(gppProp.DownOnPage)->p[4];
    [* a bit up *]
    titleNode[]->last[];
    localNodes.scan
    (# d: ^DiagramNode; 
    do
    (if Current.struc <= DiagramNode##
    // true then
    Current[]->d[];
    (if d.theTreeConn[]
    // none then Current[]->last[]; 
    if)
    if)
    #);
    last.geometry->(x,y,w,h);
    x->p[3];
    p->theTreeConn.Points;
    
    #);
    
    if);
    
    if);*)
   
#)  

-- DiagramNodeModeOn: DoPart --
do
   (if switch[1] then 'Text mode on DiagramNode'->putLine;  if);
   (if not ongoingTextediting then
       (if currentDecomposDiagram <> none then
           'The diagrams detailed from this node will be abstracted after text editing. Do you wish to continue?'
             ->DSUIGetUserYesOrNo->ok
        else
           true->ok
       if);
       (if ok then
           true->wrap;
           theText.get->theTextBefore;
           true->ongoingTextediting;
           THIS(DiagramNode).size->(oldWidth,oldHeight);
           (3*GppProp.width div 2,6*GppProp.height)->THIS(DiagramNode).size;
           (if theObjectDescriptor <> none then
               (if switch[1] then
                   'theName: '->putText; theName->putLine; 
               if);
               theName->help[];
               help->parseableText;
               ':'->parseableText.put;
               INNER ;
               '<<@'->parseableText.putText;
               (theObjectDescriptor).index->parseableText.putInt;
               ':ObjectDescriptor>>'->parseableText.putText;
               parseableText->set;
               
            else
               (if not (gppProp.SimpleDeclDisplay = gppProp.AsNameAndType) then
                   (mps[],(theDeclaration).frag[],theDeclaration,indextext[],
                    none (*streamName[]*) ,80,0,false (*abstractPresentation*) ,
                    false (*showSemanticErrors*) ,false (*includeComments*) ,
                    false,false,false,false,'',false (*onlyProperties*) ,false
                    (*
                     test*) )->ppFragment;
                   indexText->parseableText->set
               if)
           if)
        else
           false->OKToEnter; checkEditMenuTextEdit; ModeOff
       if)
   if);
     

-- DiagramNodeModeOff: DoPart --
do
   (if switch[1] then 'Text mode off DiagramNode'->putLine;  if);
   (if ongoingTextediting then
       theText.get->t;
       (if theObjectDescriptor <> none then
           parseableText[]->t.equal->noChange
        else
           theTextBefore[]->t.equal->noChange
       if);
       (if not noChange then
           (if theDeclaration
            // none then 'theDeclaration is none!! '->putLine
            else
               (THIS(DiagramNode)[],theDeclaration,t[])->declarationTextChanged;
               (if parseErrorOccurred then (*false->OKToExit *)  if)
           if)
        else
           (oldWidth,oldHeight)->THIS(DiagramNode).size;
           theTextBefore->theText.set;
           false->ongoingTextediting;
           (*if a parse error occurred and the text was changed back to original*)
           false->parseErrorOccurred
       if);
       INNER
   if);
   (if not parseErrorOccurred then false->wrap if);
     

-- DiagramNodeDetail: Descriptor --
(#
   dummyDetailPage: ^OADPage;
   DD: ^dummyDetailPage.PatternDiagram;
   newName,t: ^Text;
   shape: @Integer;
   
do
   (if gppProp.ShowLocals
    // false then
       detailPage->dummyDetailPage[];
       &dummyDetailPage.PatternClassificationDiagram[]->DD[];
       
    else
       detailPage->dummyDetailPage[];
       &dummyDetailPage.PatternDeclDiagram[]->DD[];
       
   if);
   theFragmentNode->DD.theFragmentNode;
   THIS(DiagramNode)[]->PatternDiagrams.detailer[];
   (* set the detailer *)
   (if THIS(DiagramNode).struc <= SimpleAttributeDecl##
    // true then RndRect->shape; 
    else
       Rectangle->shape; 
   if);
   theName->t[];
   DD[]->currentDecomposDiagram;
   THIS(AbstractNode)[]->DD.theParentNode;
   (theObjectDescriptor,t,shape)->DD.new;
   DD[]->currentDecomposDiagram;
   INNER detail;
   none ->PatternDiagrams.detailer[];
   (* clear the detailer *)
   
#)  

-- DiagramNodeGetGroup: Descriptor --
(# fd: ^FragmentDiagram; theDummyFragNode: ^PatternDiagramNode
do
   (if (theDiagram).theFragmentNode <> none
    // true then
       (theDiagram).theFragmentNode->theDummyFragNode[];
       theDummyFragNode.theDiagram->fd[];
       fd.theGroup->fg[];
       
    else
       'DiagramNode: GetGroup: no FragmentNode'->screen.putline
   if)
#)  

-- DiagramNodeGetFragment: Descriptor --
(# fn: ^FragmentNode; 
do
   (if (theDiagram).theFragmentNode <> none
    // true then (theDiagram).theFragmentNode->fn[]; fn.theFragment->f[]; 
    else
       'DiagramNode: GetFragment: no FragmentNode'->screen.putline
   if)
#)  

-- DiagramNodeDump: Descriptor --
(# 
do
   '********theDeclaration********'->putline;
   (if theDeclaration <> none then
       (theDeclaration).dump; newline
    else
       'is NONE!'->putline
   if);
   '********theObjectDescriptor********'->putline;
   (if theObjectDescriptor <> none then
       (theObjectDescriptor).dump; newline
    else
       'is NONE!'->putline
   if);
   '********thePrefix********'->putline;
   (if thePrefix <> none then
       (thePrefix).dump; newline
    else
       'is NONE!'->putline
   if)
#)  

-- theSifEditor: DoPart --
do
   (if theDiagram = none then
       'theSifEditor: theDiagram is none!!'->putLine
   if);
   (if (theDiagram).theFragmentNode <> none then
       (if se[] = none then
           (theDiagram).theFragmentNode->fn[]; fn.SifEditorInstance[]->se[]; 
        else
           (theDiagram).theFragmentNode->fn[]; se[]->fn.SifEditorInstance[]; 
       if);
       
    else
       'DiagramNode: thrSifEditor: no FragmentNode'->screen.putline
   if);
     

-- SlotNodeDisplay: Descriptor --
(# t: ^Text; 
do
(* pos is bottom left of previous box:
 *  calculate center of this box
 *)
   (pos.x+(gppProp.width+1) div 2,pos.y+(gppProp.height+1) div 2,gppProp.width,
    gppProp.height,defaultshape)->new;
   false->moveable;
   (* wo don't like these Nodes to be moved alone *)
   false->sizeable;
   titleNode[]->CreateRegion;
   (if aSlotDesc[]
    // none then '<<no name>>'->t[]; 
    else
       aSlotDesc.name->t[]; 
   if);
   (if aSlotDesc.category
    // betaGram.AttributesForm then
       
    // betaGram.Attributes then
       ': AttributeDecl'->t.puttext; 
    // betaGram.ObjectDescriptor then
       ': ObjectDescriptor'->t.puttext; 
    else
       ': Other category: '->t.puttext; aSlotDesc.category->t.putint; 
   if);
   THIS(SlotNode)[]->localNodes.append;
   INNER display;
   t->theText.set;
   (if theText.MaxLineLength > gppProp.propertywidth
    // true then (theText.MaxLineLength,gppProp.height)->size; 
   if);
   
#)  

-- PatternNodeDetail: Descriptor --
(# connectorList: ^ObjectList; thisListDiagram: ^ListDiagram
do
   getConnectors->connectorList[];
   (if connectorList[] <> none then
       connectorList.scan
         (# theConn: ^DeletableConnector; OtherEnd: ^SimpleNode
         do
            (if current## <= DynamicItemConnector## then
                current[]->theConn[];
                THIS(PatternNode)[]->theConn.getOtherEnd->OtherEnd[];
                none ->OtherEnd.theReferenceConnector;
                theConn.delete;
                &DynamicItemConnector[]->theConn[];
                true->theConn.initialisingSaved;
                (if OtherEnd.theDiagram <> currentDecomposDiagram then
                    (OtherEnd[],(currentDecomposDiagram).titleNode[])
                      ->theConn.new;
                    (if (not gppProp.references) or
                    (not gppProp.showAttributes) then
                        false->theConn.BorderVisible; false->theConn.selectable
                    if);
                    theConn[]->OtherEnd.theReferenceConnector
                if)
            if);
            (if current## <= DynamicComponentConnector## then
                current[]->theConn[];
                THIS(PatternNode)[]->theConn.getOtherEnd->OtherEnd[];
                none ->OtherEnd.theReferenceConnector;
                theConn.delete;
                &DynamicComponentConnector[]->theConn[];
                true->theConn.initialisingSaved;
                (if OtherEnd.theDiagram <> currentDecomposDiagram then
                    (OtherEnd[],(currentDecomposDiagram).titleNode[])
                      ->theConn.new;
                    (if (not gppProp.references) or
                    (not gppProp.showAttributes) then
                        false->theConn.BorderVisible; false->theConn.selectable
                    if);
                    theConn[]->OtherEnd.theReferenceConnector
                if)
            if)
         #)
   if);
   theDiagram->thisListDiagram[];
   thisListDiagram.localNodes.scan
     (#
        theConn: ^DeletableConnector;
        thisSimpleNode: ^SimpleNode;
        theDecl: ^betaGram.SimpleDecl;
        anAST: ^MPS.AST
     do
        (if current## <= thisListDiagram.SimpleNode## then
            current[]->thisSimpleNode[];
            thisSimpleNode.DisplayReference;
            (* (if thisSimpleNode.theQualification <> none then
             (if theDeclaration->(thisSimpleNode.theQualification).equal then
             thisSimpleNode.theDeclaration->theDecl[];
             theDecl.getSon2->anAST[];
             (if anAST.symbol
             // betaGram.DynamicItem then
             &DynamicItemConnector[]->theConn[]
             // betaGram.DynamicComponent then
             &DynamicComponentConnector[]->theConn[]
             if);
             (if theConn[] <> none then
             true->theConn.initialisingSaved;
             (thisSimpleNode[],(currentDecomposDiagram).titleNode[])
             ->theConn.new;
             theConn[]->thisSimpleNode.theReferenceConnector
             else
             'DisplayReferences: theConn is none!?'->putline
             if)
             if)
             if)*)
            
        if)
     #);
   DisplayAssociations
#)  

-- PatternNodeDisplayReferences: Descriptor --
(#
   theObject: ^patternDiagramNode;
   theRefNode: ^simpleNode;
   theConn: ^DeletableConnector;
   anAST: ^MPS.AST;
   theDecl: ^betaGram.SimpleDecl
do
   (if switch[1] then 'PatternNodeDisplayReferences'->putline if);
   (if not patternDiagrams.DynReferenceList.empty then
       patternDiagrams.DynReferenceList.scan
         (# ff: ^mps.fragmentform; t: @Text
         do
            (if ((theDeclaration).index = current.qual) and
            ((theDeclaration).frag.fullname->current.qualFrag.equal) then
                current.refFrag[]->topDotOpen->ff[];
                current.ref->ff.indexToNode->AstToNode->theObject[];
                (if theObject[] <> none then
                    theObject[]->theRefNode[];
                    (if theRefNode.theReferenceConnector = none then
                        theRefNode.theDeclaration->theDecl[];
                        theDecl.getSon2->anAST[];
                        (if anAST.symbol
                         // betaGram.DynamicItem then
                            &DynamicItemConnector[]->theConn[]
                         // betaGram.DynamicComponent then
                            &DynamicComponentConnector[]->theConn[]
                        if);
                        (if theConn[] <> none then
                            true->theConn.initialisingSaved;
                            (if theDiagram <> theRefNode.theDiagram then
                                (theRefNode[],THIS(PatternNode)[])->theConn.new;
                                (if (not gppProp.references) or
                                (not gppProp.showAttributes) then
                                    false->theConn.BorderVisible;
                                    false->theConn.selectable
                                if);
                                theConn[]->theRefNode.theReferenceConnector
                            if)
                         else
                            'DisplayReferences: theConn is none!?'->putline
                        if)
                    if)
                 else
                    (if switch[1] then
                        'SimpleNodeDisplayReference: theObject is NONE'->putline
                    if)
                if)
            if)
         #)
   if);
   (*  patternDiagrams.theList.scan
    (# thisListDiagram: ^ListDiagram
    do
    current.e[]->thisListDiagram[];
    thisListDiagram.localNodes.scan
    (# thisSimpleNode: ^SimpleNode
    do
    (if current## <= thisListDiagram.SimpleNode## then
    current[]->thisSimpleNode[];
    (if thisSimpleNode.theQualification <> none then
    (if theDeclaration->(thisSimpleNode.theQualification).equal
    then
    thisSimpleNode.theDeclaration->theDecl[];
    theDecl.getSon2->anAST[];
    (if anAST.symbol
    // betaGram.DynamicItem then
    &DynamicItemConnector[]->theConn[]
    // betaGram.DynamicComponent then
    &DynamicComponentConnector[]->theConn[]
    if);
    (if theConn[] <> none then
    true->theConn.initialisingSaved;
    (if theDiagram <> thisSimpleNode.theDiagram then
    (thisSimpleNode[],THIS(PatternNode)[])
    ->theConn.new;
    theConn[]->thisSimpleNode.theReferenceConnector
    if)
    else
    'DisplayReferences: theConn is none!?'->putline
    if)
    if)
    if)
    if)
    #)
    #) *)
   
#)  

-- PatternNodeSetupAssociation: Descriptor --
(#
   pd: ^betaGram.PatternDecl;
   od: ^betaGram.ObjectDescriptor;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   na: ^betaGram.NameApl;
   theMainPart: ^betaGram.MainPart;
   theAttributes: ^betaGram.Attributes;
   theObjSpec: ^betaGram.ObjectSpecification;
   theNameApl: ^betaGram.NameApl;
   thePrefName,t,leftName,rightName,help,name: ^Text;
   endOne,endTwo: ^betaGram.AttributeDecl;
   endOneType,endTwoType: @integer
do
   (if theObjectDescriptor <> none then
       (if (theObjectDescriptor).frag.father->ischecked then
           theObjectDescriptor->getPrefix->od[];
           (if od[] <> none then
               (if (od.father).symbol = betaGram.PatternDecl then
                   od.father->pd[];
                   pd.getSon1->theNames[];
                   theNames.getSon1->theNameDcl[];
                   theNameDcl.getText->thePrefName[];
                   (if ('OneToOneAssociation'->thePrefName.equalNCS) or
                   ('OneToManyAssociation'->thePrefName.equalNCS) or
                   ('ManyToManyAssociation'->thePrefName.equalNCS) then
                       '~beta/freja/v2.1/associations'->mps.expandToFullPath
                         ->help[];
                       (od.frag.father).name->mps.expandToFullPath->name[];
                       (if help[]->name.equal then
                           (if true
                            // ('OneToOneAssociation'->thePrefName.equalNCS)
                            then
                               (one,one)->(endOneType,endTwoType);
                               'leftType'->leftName[];
                               'rightType'->rightName[]
                            // ('OneToManyAssociation'->thePrefName.equalNCS)
                            then
                               (one,many)->(endOneType,endTwoType);
                               'oneType'->leftName[];
                               'manyElmType'->rightName[]
                            // ('ManyToManyAssociation'->thePrefName.equalNCS)
                            then
                               (many,many)->(endOneType,endTwoType);
                               'leftType'->leftName[];
                               'rightType'->rightName[]
                           if);
                           (theObjectDescriptor).getSon2->theMainPart[];
                           theMainPart.getAttributes->theAttributes[];
                           theAttributes.newScan
                             (# nd: ^betaGram.NameDcl
                             do
                                (if current[] <> none then
                                    (if current.symbol = betaGram.BindingDecl
                                     then
                                        current.getSon1->theNames[];
                                        theNames.getSon1->theNameDcl[];
                                        theNameDcl.getText->t[];
                                        (if (leftName[]->t.equalNCS) or
                                        (rightName[]->t.equalNCS) then
                                            current.getSon2->theObjSpec[];
                                            (if theObjSpec.symbol
                                             // betaGram.NameApl then
                                                theObjSpec[]->na[]
                                             // betaGram.remote then
                                                theObjSpec.getSon2->na[]
                                            if);
                                            na.dclRef->theNameDcl[];
                                            (if true
                                             // (leftName[]->t.equalNCS) then
                                                (theNameDcl.father).father
                                                  ->endOne[]
                                             // (rightName[]->t.equalNCS) then
                                                (theNameDcl.father).father
                                                  ->endTwo[]
                                            if)
                                        if)
                                    if)
                                if)
                             #);
                           (if (endOne[] <> none ) and (endTwo[] <> none ) then
                               (endOne[],endOneType,endTwo[],endTwoType,
                                theDeclaration)
                                 ->patternDiagrams.AssociationList.insert
                           if)
                        else
                           'Invalid association library: '->puttext;
                           name[]->putline;
                           'Correct association library: '->puttext;
                           help[]->putline
                       if)
                   if)
               if)
           if)
       if)
   if)
#)  

-- DisplayAssociations: Descriptor --
(#
   od: ^betaGram.ObjectDescriptor;
   DiagramOne,DiagramTwo: ^Diagram;
   theListDiagram: ^ListDiagram;
   assocListDiagram: ^ListDiagram;
   theNode,theNode2: ^PatternDiagramNode;
   thePatternNode: ^theListDiagram.PatternNode;
   theAssociationPatternNode: ^assocListDiagram.PatternNode;
   theAssocNode: ^AssociationNode;
   x,y,w,h: @integer;
   connectorList: ^ObjectList;
   help: @text;
   alreadyDisplayed:
     (# d1,d2: ^Diagram; isDisplayed: @Boolean
     enter (d1[],d2[])
     do
        d1.titleNode.getConnectors->connectorList[];
        (if connectorList[] <> none then
            connectorList.scan
              (#
                 theConn: ^deletableConnector;
                 n1,n2: ^UserDataNode;
                 theAssociationNode: ^AssociationNode
              do
                 (if current## <= deletableConnector## then
                     current[]->theConn[];
                     true->theConn.getEnds->(n1[],n2[]);
                     (if n1## <= AssociationNode## then
                         n1[]->theAssociationNode[]
                      else
                         (if n2## <= AssociationNode## then
                             n2[]->theAssociationNode[]
                         if)
                     if);
                     (if theAssociationNode[] <> none then
                         (if ((theAssociationNode.c1).theDiagram = d2[]) or
                         ((theAssociationNode.c2).theDiagram = d2[]) then
                             false->theAssociationNode.redisplayDoDelete;
                             true->isDisplayed
                         if)
                     if)
                 if)
              #)
        if)
     exit isDisplayed
     #)
do
   (if not patternDiagrams.AssociationList.empty then
       patternDiagrams.AssociationList.scan
         (# ff: ^mps.fragmentform; t: @text
         do
            (if CurrentDecomposDiagram <> none then
                (if ((theDeclaration).frag.fullname->current.fragOne.equal) and
                ((theDeclaration).index = current.endOne) then
                    current.fragTwo[]->topDotOpen->ff[];
                    current.endTwo->ff.indexToNode->AstToNode->theNode[];
                    current.associationFrag[]->topDotOpen->ff[];
                    current.associationPattern->ff.indexToNode->AstToNode
                      ->theNode2[];
                    theNode2.theDiagram->assocListDiagram[];
                    theNode2[]->theAssociationPatternNode[];
                    (if theNode[] <> none then
                        theNode.theDiagram->theListDiagram[];
                        (if theNode## <= theListDiagram.patternNode## then
                            theNode[]->thePatternNode[];
                            (if thePatternNode.CurrentDecomposDiagram <> none
                             then
                                thePatternNode.CurrentDecomposDiagram
                                  ->DiagramTwo[];
                                (if not
                                ((CurrentDecomposDiagram,DiagramTwo[])
                                   ->alreadyDisplayed) then
                                    &AssociationNode[]->theAssocNode[];
                                    DiagramTwo.titleNode.geometry->(x,y,w,h);
                                    CurrentDecomposDiagram->DiagramOne[];
                                    (x-300,y)->DiagramOne.titleNode.move;
                                    (if (current.endOneType = one) and
                                    (current.endTwoType = one) then
                                        (one,CurrentDecomposDiagram,one,
                                         DiagramTwo[])->theAssocNode.display;
                                        theAssociationPatternNode[]
                                          ->theAssocNode.thePatternNode;
                                        theAssocNode[]
                                          ->
                                            theAssociationPatternNode.
                                              theAssociationNode;
                                        (if not gppProp.associations then
                                            false->theAssocNode.BorderVisible;
                                            (theAssocNode.c1).theText.get->help;
                                            help[]
                                              ->(theAssocNode.c1).invisibleText;
                                            (theAssocNode.c1).theText.clear;
                                            false
                                              ->(theAssocNode.c1).BorderVisible;
                                            (theAssocNode.c2).theText.get->help;
                                            help[]
                                              ->(theAssocNode.c2).invisibleText;
                                            (theAssocNode.c2).theText.clear;
                                            false
                                              ->(theAssocNode.c2).BorderVisible
                                        if);
                                        
                                     else
                                        (if (current.endOneType = one) and
                                        (current.endTwoType = many) then
                                            (one,CurrentDecomposDiagram,many,
                                             DiagramTwo[])
                                              ->theAssocNode.display;
                                            theAssociationPatternNode[]
                                              ->theAssocNode.thePatternNode;
                                            theAssocNode[]
                                              ->
                                                theAssociationPatternNode.
                                                  theAssociationNode;
                                            (if not gppProp.associations then
                                                false
                                                  ->theAssocNode.BorderVisible;
                                                (theAssocNode.c1).theText.get
                                                  ->help;
                                                help[]
                                                  ->
                                                    (theAssocNode.c1).
                                                    invisibleText;
                                                (theAssocNode.c1).theText.clear;
                                                false
                                                  ->
                                                    (theAssocNode.c1).
                                                    BorderVisible;
                                                (theAssocNode.c2).theText.get
                                                  ->help;
                                                help[]
                                                  ->
                                                    (theAssocNode.c2).
                                                    invisibleText;
                                                (theAssocNode.c2).theText.clear;
                                                false
                                                  ->
                                                    (theAssocNode.c2).
                                                    BorderVisible
                                            if);
                                            
                                         else
                                            (if (current.endOneType = many) and
                                            (current.endTwoType = many) then
                                                (many,CurrentDecomposDiagram,
                                                 many,DiagramTwo[])
                                                  ->theAssocNode.display;
                                                theAssociationPatternNode[]
                                                  ->theAssocNode.thePatternNode;
                                                theAssocNode[]
                                                  ->
                                                    theAssociationPatternNode.
                                                      theAssociationNode;
                                                (if not gppProp.associations
                                                 then
                                                    false
                                                      ->
                                                        theAssocNode.
                                                          BorderVisible;
                                                    (theAssocNode.c1).theText.
                                                      get->help;
                                                    help[]
                                                      ->
                                                        (theAssocNode.c1).
                                                        invisibleText;
                                                    (theAssocNode.c1).theText.
                                                      clear;
                                                    false
                                                      ->
                                                        (theAssocNode.c1).
                                                        BorderVisible;
                                                    (theAssocNode.c2).theText.
                                                      get->help;
                                                    help[]
                                                      ->
                                                        (theAssocNode.c2).
                                                        invisibleText;
                                                    (theAssocNode.c2).theText.
                                                      clear;
                                                    false
                                                      ->
                                                        (theAssocNode.c2).
                                                        BorderVisible
                                                if);
                                                
                                             else
                                                'DisplayAssociations: unknown type of association'
                                                  ->putline
                                            if)
                                        if)
                                    if)
                                if)
                            if)
                        if)
                    if)
                if);
                (if ((theDeclaration).frag.fullname->current.fragTwo.equal) and
                ((theDeclaration).index = current.endTwo) then
                    current.fragOne[]->topDotOpen->ff[];
                    current.endOne->ff.indexToNode->AstToNode->theNode[];
                    current.associationFrag[]->topDotOpen->ff[];
                    current.associationPattern->ff.indexToNode->AstToNode
                      ->theNode2[];
                    theNode2.theDiagram->assocListDiagram[];
                    theNode2[]->theAssociationPatternNode[];
                    (if theNode[] <> none then
                        theNode.theDiagram->theListDiagram[];
                        (if theNode## <= theListDiagram.patternNode## then
                            theNode[]->thePatternNode[];
                            (if thePatternNode.CurrentDecomposDiagram <> none
                             then
                                thePatternNode.CurrentDecomposDiagram
                                  ->DiagramOne[];
                                (if not
                                ((DiagramOne[],CurrentDecomposDiagram)
                                   ->alreadyDisplayed) then
                                    &AssociationNode[]->theAssocNode[];
                                    DiagramOne.titleNode.geometry->(x,y,w,h);
                                    CurrentDecomposDiagram->DiagramTwo[];
                                    (x+300,y)->DiagramTwo.titleNode.move;
                                    (if (current.endOneType = one) and
                                    (current.endTwoType = one) then
                                        (one,DiagramOne[],one,
                                         CurrentDecomposDiagram)
                                          ->theAssocNode.display;
                                        theAssociationPatternNode[]
                                          ->theAssocNode.thePatternNode;
                                        theAssocNode[]
                                          ->
                                            theAssociationPatternNode.
                                              theAssociationNode;
                                        (if not gppProp.associations then
                                            false->theAssocNode.BorderVisible;
                                            (theAssocNode.c1).theText.get->help;
                                            help[]
                                              ->(theAssocNode.c1).invisibleText;
                                            (theAssocNode.c1).theText.clear;
                                            false
                                              ->(theAssocNode.c1).BorderVisible;
                                            (theAssocNode.c2).theText.get->help;
                                            help[]
                                              ->(theAssocNode.c2).invisibleText;
                                            (theAssocNode.c2).theText.clear;
                                            false
                                              ->(theAssocNode.c2).BorderVisible
                                        if);
                                        
                                     else
                                        (if (current.endOneType = one) and
                                        (current.endTwoType = many) then
                                            (one,DiagramOne[],many,
                                             CurrentDecomposDiagram)
                                              ->theAssocNode.display;
                                            theAssociationPatternNode[]
                                              ->theAssocNode.thePatternNode;
                                            theAssocNode[]
                                              ->
                                                theAssociationPatternNode.
                                                  theAssociationNode;
                                            (if not gppProp.associations then
                                                false
                                                  ->theAssocNode.BorderVisible;
                                                (theAssocNode.c1).theText.get
                                                  ->help;
                                                help[]
                                                  ->
                                                    (theAssocNode.c1).
                                                    invisibleText;
                                                (theAssocNode.c1).theText.clear;
                                                false
                                                  ->
                                                    (theAssocNode.c1).
                                                    BorderVisible;
                                                (theAssocNode.c2).theText.get
                                                  ->help;
                                                help[]
                                                  ->
                                                    (theAssocNode.c2).
                                                    invisibleText;
                                                (theAssocNode.c2).theText.clear;
                                                false
                                                  ->
                                                    (theAssocNode.c2).
                                                    BorderVisible
                                            if);
                                            
                                         else
                                            (if (current.endOneType = many) and
                                            (current.endTwoType = many) then
                                                (many,DiagramOne[],many,
                                                 CurrentDecomposDiagram)
                                                  ->theAssocNode.display;
                                                theAssociationPatternNode[]
                                                  ->theAssocNode.thePatternNode;
                                                theAssocNode[]
                                                  ->
                                                    theAssociationPatternNode.
                                                      theAssociationNode;
                                                (if not gppProp.associations
                                                 then
                                                    false
                                                      ->
                                                        theAssocNode.
                                                          BorderVisible;
                                                    (theAssocNode.c1).theText.
                                                      get->help;
                                                    help[]
                                                      ->
                                                        (theAssocNode.c1).
                                                        invisibleText;
                                                    (theAssocNode.c1).theText.
                                                      clear;
                                                    false
                                                      ->
                                                        (theAssocNode.c1).
                                                        BorderVisible;
                                                    (theAssocNode.c2).theText.
                                                      get->help;
                                                    help[]
                                                      ->
                                                        (theAssocNode.c2).
                                                        invisibleText;
                                                    (theAssocNode.c2).theText.
                                                      clear;
                                                    false
                                                      ->
                                                        (theAssocNode.c2).
                                                        BorderVisible
                                                if);
                                                
                                             else
                                                'DisplayAssociations: unknown type of association'
                                                  ->putline
                                            if)
                                        if)
                                    if)
                                if)
                            if)
                        if)
                    if)
                if)
            if)
         #)
   if)
#)  

