ORIGIN 'diagramattributes';
INCLUDE 'gppinterfacebody';
-- DisplayAST: Descriptor --
(#
   theDecl: ^betaGram.AttributeDecl;
   theNames: ^betaGram.names;
   theNodeType: ##DiagramNode;
   unExp: ^mps.unexpanded;
   aSlotNode: ^SlotNode;
   aNode: ^DiagramNode;
   nt: ^NonTerminalNode;
   adjustPos: @
     (# x,y,w,h: @Integer; 
     enter (x,y,w,h)
     do
     (* (if gppProp.CompositionDType > gppProp.CompositionNested
      *          // true then
      *             (if w <> (gppProp.width*2)
      *              // true then {* box is not standard width; adjust x position *}
      *                 x-((gppProp.width*2-w) div 2)->x; (x,y)->aNode.Center; 
      *             if);
      *             x+(w div 2)+gppProp.width+10->pos.x;
      *             
      *          else
      *             pos.y+gppProp.height->pos.y; 
      *         if)
      *) pos.y+gppProp.height->pos.y
     #);
   
do
   (if anAST[]
    // none then
       'Freja[[ERROR: Display AST: anAST is NONE]]'->screen.putline; 
    else
       kindtest:
       (if anAST.kind
        // mps.kinds.interior then
           (if anAST.symbol
            // betaGram.PatternDecl then
               PatternNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: PatternNode'->T #);
               
            // betaGram.SimpleDecl then
               SimpleNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: SimpleNode'->T #);
               
            // betaGram.RepetitionDecl then
               RepetitionNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: RepetitionNode'->T #);
               
            // betaGram.VirtualDecl then
               VirtualNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: VirtualNode'->T #);
               
            // betaGram.BindingDecl then
               BindingNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: BindingNode'->T #);
               
            // betaGram.FinalDecl then
               FinalNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: FinalNode'->T #);
               
            else
               20->trace (#  do 'DisplayAst: unknown symbol'->T #);
               (if anAST.father <> none
                // true then
                   20->trace (#  do '\tTrying father recursively'->T #);
                   (anAST.father,pos)->&DisplayAST->pos;
                   
                else
                   20->trace (#  do '\tFather is NONE'->T #); 
               if);
               leave kindtest;
               
           if);
           anAST[]->theDecl[];
           theDecl.getson1->anAST[];
           (if anAST[]
            // none then 'Freja[[ERROR: son1 is NONE]]'->screen.putline; 
            else
               (if anAST.kind
                // mps.kinds.interior then
                   anAST[]->theNames[];
                   (if theNames[]
                    // none then
                       'Freja[[ERROR: DisplayAST theNames is NONE]]'
                         ->screen.putline;
                       
                    else
                       theNames.scan
                         (# 
                         do
                            &theNodeType[]->aNode[];
                            THIS(ListDiagram)[]->aNode.theDiagram;
                            (pos,theDecl[],current[])->aNode.display;
                            (if remakingDiagram
                             // true then
                                20
                                  ->trace
                                    (#  do 'Remake; calling conclude'->T #);
                                (0,0)->aNode.ConcludeDisplay;
                                
                            if);
                            aNode.geometry->adjustPos;
                            20->trace (#  do 'Names'->T #);
                            
                         #);
                       
                   if);
                   
                // mps.kinds.unExpanded then
                   &theNodeType[]->aNode[];
                   (pos,theDecl[],anAST[])->aNode.display;
                   (if remakingDiagram
                    // true then
                       20->trace (#  do 'Remake; calling conclude'->T #);
                       (0,0)->aNode.ConcludeDisplay;
                       
                   if);
                   THIS(ListDiagram)[]->aNode.theDiagram;
                   aNode.geometry->adjustPos;
                   20->trace (#  do 'Optional'->T #);
                   
                // mps.kinds.optional then
                   'DisplayAST: son1 is optional'->screen.putline; 
               if);
               
           if);
           
        // mps.kinds.unExpanded then
           20->trace (#  do ' DisplayAST: unexpanded'->T #);
           anAST[]->unExp[];
           (if unExp.isSlot
            // true then
               20->trace (#  do ' DisplayAST: SLOT'->T #);
               &SlotNode[]->aSlotNode[];
               THIS(ListDiagram)[]->aSlotNode.theDiagram;
               (pos,unExp[])->aSlotNode.display;
               (if remakingDiagram
                // true then
                   20->trace (#  do 'Remake; calling conclude'->T #);
                   (0,0)->aSlotNode.ConcludeDisplay;
                   
               if);
               aSlotNode.geometry->adjustPos;
               20->trace (#  do 'UnExpanded'->T #);
               
            else
           (* it is a non-terminal *)
               &NonTerminalNode[]->nt[];
               THIS(ListDiagram)[]->nt.theDiagram;
               (pos,unExp[])->nt.display;
               (if remakingDiagram
                // true then
                   20->trace (#  do 'Remake; calling conclude'->T #);
                   (0,0)->nt.ConcludeDisplay;
                   
               if);
               nt.geometry->adjustPos;
               20->trace (#  do 'non-terminal'->T #);
               
           if);
           
        // mps.kinds.optional then
           20->trace (#  do 'mps.kinds.optional'->T #); 
        // mps.kinds.NameAppl // mps.kinds.String // mps.kinds.NameDecl then
           20->trace (#  do 'mps.kinds.NameAppl/NameDecl/String'->T #);
           (anAST.father,pos)->&DisplayAST->pos;
           
        else
           20
             ->trace
               (#  do 'mps.kinds.other: '->T; anAST.kind->T.putint;  #);
           'DisplayAST: mps.kinds.other'->screen.putline;
           
       if)
   if)
#)  

-- AbstractNodePopUpDescOpen: DoPart --
do
   true->opened;
   editItem.open;
   'Edit...'->editItem.name;
   editItem[]->append;
   sep1.open;
   sep1[]->append;
   newItem.open;
   'New'->newItem.name;
   newItem[]->append;
   moveItem.open;
   'Move'->moveItem.name;
   moveItem[]->append;
   INNER open;
   sep2.open;
   sep2[]->append;
   cutItem.open;
   'Cut'->cutItem.name;
   cutItem[]->append;
   copyItem.open;
   'Copy'->copyItem.name;
   copyItem[]->append;
   pasteItem.open;
   'Paste'->pasteItem.name;
   pasteItem[]->append;
   sep3.open;
   sep3[]->append;
   openSubEditorItem.open;
   'Open Codeeditor'->openSubEditorItem.name;
   openSubEditorItem[]->append  

-- AbstractNodeOnSelect: DoPart --
do
   (patterndiagrams.oldSelection[],THIS(AbstractNode)[])->changedFocus;
   THIS(AbstractNode)[]->patterndiagrams.oldSelection[];
   INNER onSelect;
     

-- AbstractNodeOnRightMouseDown: DoPart --
do
   (if not (THIS(AbstractNode)## <= FragmentNode##) then
       (if not thePopup.opened then thePopup.open if);
       (1,mousePos,inWindow[])->thePopup.popup;
       INNER onRightMouseDown
   if)  

-- AbstractNodeRemove: Descriptor --
(#
   abstracted: @boolean;
   thePatternDiagram: ^PatternDiagram;
   regions: ^ObjectList;
   
do
   30
     ->trace
       (# 
       do 'DiagramNode: remove callback on %i'->t.putformat (#  do ID->i #)
       #);
   getRegionList->regions[];
   (if regions[] <> none then
       regions.scan
         (# theNode: ^UserDataNode; connectors: ^ObjectList
         do
            (if (not (current## <= PatternDiagramNode##)) and
            (current## <= UserDataNode##) then
                current[]->theNode[];
                theNode.getConnectors->connectors[];
                (if connectors[] <> none then
                    connectors.scan
                      (#
                         theAssociationConnector: ^AssociationConnector;
                         theListDiagram: ^ListDiagram;
                         theSimpleNode: ^theListDiagram.SimpleAttributeDecl;
                         right,left: ^theAssociationConnector.Role
                      do
                         (if current## <= AssociationConnector## then
                             current[]->theAssociationConnector[];
                             (if theNode## <= theAssociationConnector.Role##
                              then
                                 (
                                 (
                                 theAssociationConnector.leftrole
                                   ->theAssociationConnector.lr[]).
                                 thePatternDiagramNode).theDiagram
                                   ->theListDiagram[];
                                 (
                                 theAssociationConnector.leftrole
                                   ->theAssociationConnector.lr[]).
                                 thePatternDiagramNode->theSimpleNode[];
                                 none ->theSimpleNode.theAssociationConnector;
                                 theAssociationConnector.leftRole->left[];
                                 (if not
                                 (theAssociationConnector## <=
                                  AggregationConnector##) then
                                     (
                                     (
                                     theAssociationConnector.rightrole
                                       ->theAssociationConnector.rr[]).
                                     thePatternDiagramNode).theDiagram
                                       ->theListDiagram[];
                                     (
                                     theAssociationConnector.rightrole
                                       ->theAssociationConnector.rr[]).
                                     thePatternDiagramNode->theSimpleNode[];
                                     none
                                       ->theSimpleNode.theAssociationConnector
                                 if);
                                 theAssociationConnector.rightRole->right[];
                                 left.delete;
                                 right.delete
                              else
                                 'AssociationConnector '->stdErr.puttext;
                                 theAssociationConnector.id->stdErr.putint;
                                 ' with non-role end '->stdErr.puttext;
                                 theNode.id->stdErr.putint;
                                 stderr.newline
                             if)
                         if)
                      #)
                if)
            if)
         #)
   if);
   (if currentDecomposDiagram <> none
    // true then (* this node is detailed *)
    (* mark THIS(DiagramNode) as no longer detailed *)
       currentDecomposDiagram->thePatternDiagram[];
       thePatternDiagram.titleNode.delete;
       none ->currentDecomposDiagram;
       true->abstracted
   if);
   decomposdiagrams.scan
     (#  do current[]->currentDecomposDiagram #);
   (if abstracted
    // false then
    (* remove THIS(AbstractNode) from the diagramlist and update the diagram *)
       (THIS(AbstractNode)[],false)->DeleteDiagramNode; 
   if);
   
#)  

-- AbstractNodeDisplay: Descriptor --
(# 
do
   INNER Display;
   gppProp.fontSize->theText.size;
   t->theText.set;
   THIS(AbstractNode)[]->updateMaxWH;
   (if patterndiagrams.addAfterNode[] = none then
       THIS(AbstractNode)[]->localNodes.append; 
    else
       THIS(AbstractNode)[]->patterndiagrams.newNode[];
       (* save the new node so it can
        * be added later *)
       
   if);
   (if THIS(ListDiagram)## <= FragmentDiagram## then
       
    else
       (if not gppProp.showAttributes then
           theText.get->t;
           (if not (''->t.equal) then t[]->invisibleText if);
           theText.clear;
           false->BorderVisible;
           false->selectable
       if)
   if)
#)  

-- AbstractNodeReDisplay: Descriptor --
(# x,y,w,h: @integer
do
   INNER ReDisplay;
   t->theText.set;
   0->MaxWidth;
   0->MaxHeight;
   titleNode[]->updateMaxWH;
   THIS(AbstractNode)[]->updateMaxWH;
   localNodes.scan
     (#  do current[]->updateMaxWH #);
   (if THIS(ListDiagram)## <= FragmentDiagram## then
       
    else
       THIS(ListDiagram).localNodes.scan
         (# 
         do
            (if not gppProp.showAttributes then
                theText.get->t;
                (if not (''->t.equal) then t[]->invisibleText if);
                theText.clear;
                false->BorderVisible;
                false->selectable
            if)
         #)
   if);
   
#)  

-- AbstractNodeChangeDisplay: DoPart --
do INNER ChangeDisplay  

-- AbstractNodeConcludeDisplay: Descriptor --
(# 
do
   false->sizeable;
   (* dont resize this *)
   false->moveable;
   titleNode[]->CreateRegion;
   
#)  

-- AbstractNodeInsertDiagramNode: Descriptor --
(# addAfterNode: ^PatternDiagramNode; ld: ^ListDiagram; x,y: @integer
do
   (if localNodeOrder = gppProp.inCompartments then
       (if patterndiagrams.newNode.attributeType = attributeType then
           THIS(AbstractNode)[]->addAfterNode[]
        else
           (if patternDiagrams.newNode.attributeType
            // gppProp.SimpleAttribute then
               (if not attributes.empty then
                   (attributes.last).elm[]->addAfterNode[]
                else
                   titleNode[]->addAfterNode[]
               if)
            // gppProp.operation then
               (if not operations.empty then
                   (operations.last).elm[]->addAfterNode[]
                else
                   (if not attributes.empty then
                       (attributes.last).elm[]->addAfterNode[]
                    else
                       titleNode[]->addAfterNode[]
                   if)
               if)
            // gppProp.localClass then
               (if not localClasses.empty then
                   (localClasses.last).elm[]->addAfterNode[]
                else
                   (if not operations.empty then
                       (operations.last).elm[]->addAfterNode[]
                    else
                       (attributes.last).elm[]->addAfterNode[]
                   if)
               if)
           if)
       if);
       (if not (addAfterNode[] = titleNode[]) then
           (patterndiagrams.newNode[],addAfterNode[]->localNodes.at)
             ->localNodes.insertAfter
        else
           patterndiagrams.newNode[]->localNodes.prepend;
           titleNode.center->(x,y);
           (x,y+gppProp.height)->patterndiagrams.newNode.center
       if);
       theDiagram->ld[];
       ld.localnodes.scan
         (# moveDown: @boolean; x,y: @integer; 
         do
            (if moveDown or
            ((addAfterNode[] = ld.titleNode[]) and
             (not (current[] = patterndiagrams.newNode[]))) then
                current.center->(x,y); (x,y+gppProp.height)->current.center
             else
                (if current[] = addAfterNode[] then true->moveDown if)
            if)
         #)
    else
       (patterndiagrams.newNode[],THIS(AbstractNode)[]->localNodes.at)
         ->localNodes.insertAfter
   if)
#)  

-- AbstractNodeAbstractedFromDiagramBelow: Descriptor --
(# 
do
   70->trace (#  do 'PatternDiagram: abstractedFromDiagramBelow'->t #);
   none ->currentDecomposDiagram;
   decomposDiagrams.scan
     (#  do current[]->currentDecomposDiagram #)
#)  

-- AbstractNodeMoveUpNode: DoPart --
do
   THIS(AbstractNode)[]->localNodes.at->pos[];
   pos.pred[]->pred[];
   pos[]->localNodes.delete;
   (THIS(AbstractNode)[],pred[])->localNodes.insertBefore;
   pred.elm.center->(px,py);
   center->(x,y);
   (px,py)->center;
   (x,y)->pred.elm.center;
   (if localNodeOrder = gppProp.inCompartments then
       (if not (attributeType = pred.elm.attributeType) then
           (if attributeType
            // gppProp.operation then
               THIS(AbstractNode)[]->operations.at->operations.delete;
               (THIS(AbstractNode)[],attributes.last)->attributes.insertBefore
            // gppProp.localClass then
               THIS(AbstractNode)[]->localClasses.at->localClasses.delete;
               (THIS(AbstractNode)[],operations.last)->operations.insertBefore
           if);
           pred.elm.attributeType->attributeType;
           showCompartments
       if)
   if)  

-- AbstractNodemoveDownNode: DoPart --
do
   THIS(AbstractNode)[]->localNodes.at->pos[];
   pos.succ[]->succ[];
   pos[]->localNodes.delete;
   (THIS(AbstractNode)[],succ[])->localNodes.insertAfter;
   succ.elm.center->(sx,sy);
   center->(x,y);
   (sx,sy)->center;
   (x,y)->succ.elm.center;
   (if localNodeOrder = gppProp.inCompartments then
       (if not (attributeType = succ.elm.attributeType) then
           (if attributeType
            // gppProp.SimpleAttribute then
               THIS(AbstractNode)[]->attributes.at->attributes.delete;
               (THIS(AbstractNode)[],operations.head)->operations.insertAfter
            // gppProp.operation then
               THIS(AbstractNode)[]->operations.at->operations.delete;
               (THIS(AbstractNode)[],localClasses.head)
                 ->localClasses.insertAfter
           if);
           succ.elm.attributeType->attributeType;
           showCompartments
       if)
   if)  

-- AbstractNodeMoveNodeToAttributes: DoPart --
do
   THIS(AbstractNode)[]->localNodes.at->localNodes.delete;
   (if attributeType
    // gppProp.Operation then
       THIS(AbstractNode)[]->operations.at->operations.delete
    // gppProp.localClass then
       THIS(AbstractNode)[]->localClasses.at->localClasses.delete
   if);
   (if not attributes.empty then
       (THIS(AbstractNode)[],(attributes.last).elm[]->localNodes.at)
         ->localNodes.insertAfter;
       (THIS(AbstractNode)[],attributes.last)->attributes.insertAfter
    else
       THIS(AbstractNode)[]->localNodes.prepend;
       THIS(AbstractNode)[]->attributes.prepend
   if);
   titleNode.center->(px,py);
   localNodes.scan
     (# moveDownNodes: @boolean; x,y: @integer
     do (px,py+gppProp.height->py)->current.center
     #);
   (if attributeType
    // gppProp.operation then
       THIS(AbstractNode)[]->operations.at->operations.delete
    // gppProp.localClass then
       THIS(AbstractNode)[]->localClasses.at->localClasses.delete
   if);
   gppProp.SimpleAttribute->attributeType;
   showCompartments  

-- AbstractNodeMoveNodeToOperations: DoPart --
do
   THIS(AbstractNode)[]->localNodes.at->localNodes.delete;
   (if attributeType
    // gppProp.SimpleAttribute then
       THIS(AbstractNode)[]->attributes.at->attributes.delete
    // gppProp.localClass then
       THIS(AbstractNode)[]->localClasses.at->localClasses.delete
   if);
   (if not operations.empty then
       (THIS(AbstractNode)[],(operations.last).elm[]->localNodes.at)
         ->localNodes.insertAfter;
       (THIS(AbstractNode)[],operations.last)->operations.insertAfter
    else
       (if not attributes.empty then
           (THIS(AbstractNode)[],(attributes.last).elm[]->localNodes.at)
             ->localNodes.insertAfter
        else
           THIS(AbstractNode)[]->localNodes.prepend
       if);
       THIS(AbstractNode)[]->operations.prepend
   if);
   titleNode.center->(px,py);
   localNodes.scan
     (# moveDownNodes: @boolean; x,y: @integer
     do (px,py+gppProp.height->py)->current.center
     #);
   gppProp.Operation->attributeType;
   showCompartments  

-- AbstractNodeMoveNodeToLocalClasses: DoPart --
do
   THIS(AbstractNode)[]->localNodes.at->localNodes.delete;
   (if attributeType
    // gppProp.SimpleAttribute then
       THIS(AbstractNode)[]->attributes.at->attributes.delete
    // gppProp.Operation then
       THIS(AbstractNode)[]->operations.at->operations.delete
   if);
   (if not localClasses.empty then
       (THIS(AbstractNode)[],(localClasses.last).elm[]->localNodes.at)
         ->localNodes.insertAfter;
       (THIS(AbstractNode)[],localClasses.last)->localClasses.insertAfter
    else
       (if not operations.empty then
           (THIS(AbstractNode)[],(operations.last).elm[]->localNodes.at)
             ->localNodes.insertAfter
        else
           (if not attributes.empty then
               (THIS(AbstractNode)[],(attributes.last).elm[]->localNodes.at)
                 ->localNodes.insertAfter
            else
               THIS(AbstractNode)[]->localNodes.prepend
           if)
       if);
       THIS(AbstractNode)[]->localClasses.prepend
   if);
   titleNode.center->(px,py);
   localNodes.scan
     (# moveDownNodes: @boolean; x,y: @integer
     do (px,py+gppProp.height->py)->current.center
     #);
   gppProp.LocalClass->attributeType;
   showCompartments  

-- AbstractNodeOnInit: DoPart --
do
   UDPrivate.UDAbstractNode->UserDataInit;
   theName.Init;
   currentDecomposDiagram.Init;
   hasAttributes.Init;
   (if not initialisingSaved then
       textJust.leftJustification->theText.just; gppProp.fontSize->theText.size
   if);
   INNER  

-- AbstractNodeDetail: Descriptor --
(# att: ^betaGram.attributes; t: @Text; dummyDetailPage: ^OADPage
do (*   'Detailing...'->statusbar.set;*) (* cursor.wait->cursor.set; *)
   (if CheckForAttributes
    // true then
       (if currentDecomposDiagram = none then
           (if detailPage
            // none then (* make the decompose page *)
               (if gppProp.DetailedOnSamePage
                // false then
                   &OADPage[]->dummyDetailPage[];
                   dummyDetailPage.new;
                   dummyDetailPage[]->detailPage;
                   titleNode.theText.get->t;
                   
                else
                   (if theWorkPage[]
                    // none then
                       &OADPage[]->theWorkPage[];
                       theWorkPage.new;
                       'WorkSheet'->theWorkPage.PageTitle;
                       
                   if);
                   theWorkPage[]->detailPage;
                   (* make detailPage the same page as
                    * parentNode
                    *)
                   
               if)
            else
               detailPage->CurrentPage; (* just select the page *) 
           if);
           (if not (detailPage).visible then true->(detailPage).visible if);
           (if currentDecomposDiagram
            // none then 
            else
           (*   currentDecomposDiagram->decomposDiagrams.append; *)
               
           if);
           INNER Detail;
           (if currentDecomposDiagram
            // none then
               'Freja[[ERROR: abstractnodebody: no decomposition diagram created]]'
                 ->putline;
               
            else
               (currentDecomposDiagram).titleNode.onSelect
               (*Moved to DiagramNodeDetail:
                THIS(AbstractNode)[]->(currentDecomposDiagram).theParentNode *)
           if)
        else
           (currentDecomposDiagram).titleNode[]->currentObject;
           (currentDecomposDiagram).titleNode.onSelect
       if);
       (*gppProp.DetailedStyle -> theText.style;*)
       (* make the diagram *)
       
   if);
   (*   statusbar.reset;*)
   (* cursor.reset; *)
   (* if freja and sif is present then we can show
    * dexter anchors in the detailed diagrams *)
   
#)  

-- AbstractNodeDetailRecursively: DoPart --
do
   detail;
   (if currentDecomposDiagram <> none then
       (currentDecomposDiagram).titleNode.detailRecursively
   if);
   INNER detailRecursively  

-- AbstractNodeOverview: DoPart --
do
     (# theListDiagram: ^ListDiagram
     do
        theDiagram->theListDiagram[];
        theListDiagram.localNodes.scan
          (# 
          do (if current[] <> THIS(AbstractNode)[] then current.abstract if)
          #)
     #)  

-- AbstractNodeAbstract: Descriptor --
(# abstracted: @boolean; thePatternDiagram: ^PatternDiagram; 
do
   (if currentDecomposDiagram <> none
    // true then
       currentDecomposDiagram->thePatternDiagram[];
       thePatternDiagram.titleNode.abstract;
       true->abstracted;
       
   if);
   none ->currentDecomposDiagram;
   decomposDiagrams.scan
     (#  do current[]->currentDecomposDiagram #);
   (*  (if abstracted
    // false then
    [* remove THIS(AbstractNode) from the diagramlist and update the diagram *]
    (THIS(AbstractNode)[],false)->DeleteDiagramNode;
    if);*)
   
#)
(********************************* DiagramNode *************************************)  

-- AbstractNodeAbstractRecursively: DoPart --
do abstract; INNER abstractRecursively  

-- AbstractNodeDump: Descriptor --
(# 
do
   'AbstractNode'->nodetype[];
   '********theName********'->putline;
   theName->putline;
   '********currentDecomposDiagram********'->putline;
   (if currentDecomposDiagram <> none then
       (currentDecomposDiagram).titletext[]->putline
    else
       'is NONE!'->putline
   if)
#)  

-- DiagramNodeDisplay: Descriptor --
(#
   aName: ^betaGram.NameDcl;
   theDecl: ^mps.namedecl;
   a: ^MPS.AST;
   dummy: ^Text
do
   (if switch[70] then
       '******** abstractnodebody-DiagramNodeDisplay 2 calling new with ********'
         ->putline;
       'x: '->putText;
       pos.x+(gppProp.width+1) div 2->putint;
       newLine;
       'y: '->putText;
       pos.y+(gppProp.height+1) div 2->putint;
       newLine;
       'w: '->putText;
       gppProp.width->putint;
       newLine;
       'h: '->putText;
       gppProp.height->putint;
       newLine;
       
   if);
   (pos.x+(gppProp.width+1) div 2,pos.y+(gppProp.height+1) div 2,gppProp.width,
    gppProp.height,defaultshape)->new;
   theDeclaration.index->astIndex;
   (if switch[70] then
       'DiagramNodeDisplay: '->putText; astIndex->putInt; '->astIndex'->putLine
   if);
   INNER Display;
   
#)  

-- DiagramNodeRedisplay: Descriptor --
(#
   aName: ^betaGram.NameDcl;
   theDecl: ^mps.namedecl;
   a: ^MPS.AST;
   dummy: ^Text
do
   (if switch[70] then
       'PatternDiagram: DiagramNodeRedisplay, theDeclaration.index: '->putText;
       theDeclaration.index->putInt;
       newLine;
       'PatternDiagram: DiagramNodeRedisplay, anAst.index: '->putText;
       anAst.Index->putInt;
       newLine;
       
   if);
   anAST.index->astIndex;
   (if switch[70] then
       'DiagramNodeReDisplay: '->putText;
       astIndex->putInt;
       '->astIndex'->putLine
   if);
   INNER Redisplay
#)  

-- diagramNodePPAST: DoPart --
do
     (# aName: ^betaGram.NameDcl; theDecl: ^mps.namedecl; a: ^MPS.AST
     do
        (if anAST[] = none then
            '<<no name>>'->t; 
         else
            (if anAST.kind
             // mps.kinds.unExpanded then
                '<<NameDcl>>'->theName[]; theName->t; 
             // mps.kinds.optional then
                '<<Optional>>'->theName[]; theName->t; 
             else
                (if anAST.symbol
                 // betaGram.NameDcl then
                    anAst[]->aName[];
                    aName.getNameDecl->a[];
                    (if a.kind
                     // mps.kinds.unExpanded then
                        '<<NameDecl>>'->theName[]; theName->t; 
                     // mps.kinds.optional then
                        '<<Optional>>'->theName[]; theName->t; 
                     else
                    (* is a real name *)
                        a[]->theDecl[]; theDecl.getText->theName[]; theName->t
                    if)
                 // mps.unExpanded then
                    '<<unExp>>'->theName[]; theName->t; 
                 else
                    'Freja[[DiagramNode ppAST: anAST is unknown'->screen.putline
                if)
            if)
        if);
        
     #);
   INNER ppAST  

-- DiagramNodeConcludeDisplay: Descriptor --
(#
   x,y,w,h: @Integer;
   m: ^CommentMark;
   pd: ^betaGram.PatternDecl;
   sd: ^betaGram.SimpleDecl;
   rd: ^betaGram.RepetitionDecl;
   vd: ^betaGram.VirtualDecl;
   bd: ^betaGram.BindingDecl;
   fd: ^betaGram.FinalDecl;
   (*vpd: ^betaGram.VariablePatternDecl;*)
   theCom: ^mps.comment;
   comPrefix: ^text;
   
do
(* Check for comments on this node 
 * should be done on tree level but I have only 5 minutes...
 *)
   (if theDeclaration##
    // betaGram.PatternDecl## then
       theDeclaration[]->pd[];
       (if pd.hasComment then
           &CommentMark[]->m[]; (THIS(DiagramNode)[],pd.getComment)->m.display
       if)
    // betaGram.SimpleDecl## then
       theDeclaration[]->sd[];
       (if sd.hasComment then
           &CommentMark[]->m[]; (THIS(DiagramNode)[],sd.getComment)->m.display
       if)
    // betaGram.RepetitionDecl## then
       theDeclaration[]->rd[];
       (if rd.hasComment then
           &CommentMark[]->m[]; (THIS(DiagramNode)[],rd.getComment)->m.display
       if)
    // betaGram.VirtualDecl## then
       theDeclaration[]->vd[];
       (if vd.hasComment then
           &CommentMark[]->m[]; (THIS(DiagramNode)[],vd.getComment)->m.display
       if)
    // betaGram.BindingDecl## then
       theDeclaration[]->bd[];
       (if bd.hasComment then
           &CommentMark[]->m[]; (THIS(DiagramNode)[],bd.getComment)->m.display
       if)
    // betaGram.FinalDecl## then
       theDeclaration[]->fd[];
       (if fd.hasComment then
           &CommentMark[]->m[]; (THIS(DiagramNode)[],fd.getComment)->m.display
       if)
   if);
   (*(if theObjectDescriptor<>NONE//true then
    (if (theObjectDescriptor).hasComment//true then
    &CommentMark[] -> m[];
    (THIS(DiagramNode)[],(theObjectDescriptor).getComment) -> m.display;
    if)
    else
    (if (theDeclaration).hasComment//true then
    &CommentMark[] -> m[];
    (THIS(DiagramNode)[],(theDeclaration).getComment) -> m.display;
    else
    if)
    if);
    *)
   (* (if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
    (if switch[70]
    // true then
    'ConcludeDisplay: moving node: '->screen.puttext;
    dist.x->screen.putint;
    ' '->screen.put;
    dist.y->screen.putint;
    screen.newline;
    
    if);
    geometry->(x,y,w,h);
    x-dist.x->x;
    (x,y,w,h)->geometry;
    (if theTreeConn[] <> none
    // true then
    (# p: [8] @Integer; last: ^PatternDiagramNode; 
    do
    x->p[5];
    [* set two points on the connector *]
    y-(gppProp.DownOnPage)->p[6];
    [* a bit up *]
    y-(gppProp.DownOnPage)->p[4];
    [* a bit up *]
    titleNode[]->last[];
    localNodes.scan
    (# d: ^DiagramNode; 
    do
    (if Current## <= DiagramNode##
    // true then
    Current[]->d[];
    (if d.theTreeConn[]
    // none then Current[]->last[]; 
    if)
    if)
    #);
    last.geometry->(x,y,w,h);
    x->p[3];
    p->theTreeConn.Points;
    
    #);
    
    if);
    
    if);*)
   
#)  

-- DiagramNodeDetail: Descriptor --
(#
   dummyDetailPage: ^OADPage;
   DD: ^dummyDetailPage.PatternDiagram;
   newName,t: ^Text;
   shape: @Integer;
   
do
   (if gppProp.ShowLocals
    // false then
       detailPage->dummyDetailPage[];
       &dummyDetailPage.PatternClassificationDiagram[]->DD[];
       
    else
       detailPage->dummyDetailPage[];
       &dummyDetailPage.PatternDeclDiagram[]->DD[];
       
   if);
   theFragmentNode->DD.theFragmentNode;
   THIS(DiagramNode)[]->patterndiagrams.detailer[];
   (* set the detailer *)
   (if THIS(DiagramNode)## <= SimpleAttributeDecl##
    // true then THIS(OADDocument).shape.RndRect->shape; 
    else
       THIS(OADDocument).shape.Rectangle->shape; 
   if);
   theName->t[];
   DD[]->currentDecomposDiagram;
   THIS(AbstractNode)[]->DD.theParentNode;
   (theObjectDescriptor[],t,shape)->DD.new;
   DD[]->currentDecomposDiagram;
   INNER detail;
   none ->patterndiagrams.detailer[];
   (* clear the detailer *)
   
#)  

-- DiagramNodeGetGroup: Descriptor --
(# fd: ^FragmentDiagram; theDummyFragNode: ^PatternDiagramNode
do
   (if (theDiagram).theFragmentNode <> none
    // true then
       (theDiagram).theFragmentNode->theDummyFragNode[];
       theDummyFragNode.theDiagram->fd[];
       fd.theGroup->fg[];
       
    else
       'DiagramNode: GetGroup: no FragmentNode'->screen.putline
   if)
#)  

-- DiagramNodeGetFragment: Descriptor --
(# fn: ^FragmentNode; 
do
   (if (theDiagram).theFragmentNode <> none
    // true then (theDiagram).theFragmentNode->fn[]; fn.theFragment->f[]; 
    else
       'DiagramNode: GetFragment: no FragmentNode'->screen.putline
   if)
#)  

-- DiagramNodeDump: Descriptor --
(# 
do
   'DiagramNode'->nodetype[];
   '********theDeclaration********'->putline;
   (if theDeclaration[] <> none then
       theDeclaration.dump; newline
    else
       'is NONE!'->putline
   if);
   '********theObjectDescriptor********'->putline;
   (if theObjectDescriptor[] <> none then
       theObjectDescriptor.dump; newline
    else
       'is NONE!'->putline
   if);
   '********thePrefix********'->putline;
   (if thePrefix[] <> none then
       thePrefix.dump; newline
    else
       'is NONE!'->putline
   if)
#)  

-- DiagramNodeOnInit: DoPart --
do false->BorderVisible; INNER onInit  

-- theSifEditor: DoPart --
do
   (if theDiagram = none then
       'theSifEditor: theDiagram is none!!'->putLine
   if);
   (if (theDiagram).theFragmentNode <> none then
       (if se[] = none then
           (theDiagram).theFragmentNode->fn[]; fn.SifEditorInstance[]->se[]; 
        else
           (theDiagram).theFragmentNode->fn[]; se[]->fn.SifEditorInstance[]; 
       if);
       
    else
       'DiagramNode: thrSifEditor: no FragmentNode'->screen.putline
   if);
     

-- DiagramNodePrivate: Descriptor --
(#  #)  

