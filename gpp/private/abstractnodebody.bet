ORIGIN 'diagramattributes';
(* switches:
 * 20 = print info about each symbol displayed
 *)
-- DisplayAST: DescriptorForm --
(#
   theDecl: ^betaGram.AttributeDecl;
   theNames: ^betaGram.names;
   theNodeType: ##DiagramNode;
   unExp: ^unExpanded;
   aSlotNode: ^SlotNode;
   aNode: ^DiagramNode;
   nt: ^NonTerminalNode;
   adjustPos: @
     (# x,y,w,h: @Integer;
     enter (x,y,w,h)
     do
        (if gppProp.CompositionDType > gppProp.CompositionNested
         // true then
            (if w <> (gppProp.width*2)
             // true then (* box is not standard width; adjust x position *)
                x-((gppProp.width*2-w) div 2)->x; (x,y)->aNode.Center;
            if);
            x+(w div 2)+gppProp.width+10->pos.x;
         else
            pos.y+gppProp.height->pos.y;
        if)
     #);
do
   (if anAST[]
    // none then
       'Freja[[ERROR: Display AST: anAST is NONE]]'->screen.putline;
    else
       kindtest:
       (if anAST.kind
        // kinds.interior then
           (if anAST.symbol
            // betaGram.PatternDecl then
               PatternNode##->theNodeType##;
               20->trace (# do ' DisplayAST: PatternNode'->T #);
            // betaGram.SimpleDecl then
               SimpleNode##->theNodeType##;
               20->trace (# do ' DisplayAST: SimpleNode'->T #);
            // betaGram.RepetitionDecl then
               RepetitionNode##->theNodeType##;
               20->trace (# do ' DisplayAST: RepetitionNode'->T #);
            // betaGram.VirtualDecl then
               VirtualNode##->theNodeType##;
               20->trace (# do ' DisplayAST: VirtualNode'->T #);
            // betaGram.BindingDecl then
               BindingNode##->theNodeType##;
               20->trace (# do ' DisplayAST: BindingNode'->T #);
            else
               20->trace (# do 'DisplayAst: unknown symbol'->T #);
               (if anAST.father <> none
                // true then
                   20->trace (# do '\tTrying father recursively'->T #);
                   (anAST.father,pos)->&DisplayAST->pos;
                else
                   20->trace (# do '\tFather is NONE'->T #);
               if);
               leave kindtest;
           if);
           anAST[]->theDecl[];
           theDecl.getson1->anAST[];
           (if anAST[]
            // none then 'Freja[[ERROR: son1 is NONE]]'->screen.putline;
            else
               (if anAST.kind
                // kinds.interior then
                   anAST[]->theNames[];
                   (if theNames[]
                    // none then
                       'Freja[[ERROR: DisplayAST theNames is NONE]]'
                         ->screen.putline;
                    else
                       theNames.scan
                         (#
                         do
                            &theNodeType[]->aNode[];
                            THIS(ListDiagram)[]->aNode.theDiagram;
                            (pos,theDecl[],current[])->aNode.display;
                            (if remakingDiagram
                             // true then
                                20
                                  ->trace
                                    (# do 'Remake; calling conclude'->T #);
                                (0,0)->aNode.ConcludeDisplay;
                            if);
                            aNode.geometry->adjustPos;
                            20->trace (# do 'Names'->T #);
                         #);
                   if);
                // kinds.unExpanded then
                   &theNodeType[]->aNode[];
                   (pos,theDecl[],anAST[])->aNode.display;
                   (if remakingDiagram
                    // true then
                       20->trace (# do 'Remake; calling conclude'->T #);
                       (0,0)->aNode.ConcludeDisplay;
                   if);
                   THIS(ListDiagram)[]->aNode.theDiagram;
                   aNode.geometry->adjustPos;
                   20->trace (# do 'Optional'->T #);
                // kinds.optional then
                   'DisplayAST: son1 is optional'->screen.putline;
               if);
           if);
        // kinds.unExpanded then
           20->trace (# do ' DisplayAST: unexpanded'->T #);
           anAST[]->unExp[];
           (if unExp.isSlot
            // true then
               20->trace (# do ' DisplayAST: SLOT'->T #);
               &SlotNode[]->aSlotNode[];
               THIS(ListDiagram)[]->aSlotNode.theDiagram;
               (pos,unExp.theSLOT)->aSlotNode.display;
               (if remakingDiagram
                // true then
                   20->trace (# do 'Remake; calling conclude'->T #);
                   (0,0)->aSlotNode.ConcludeDisplay;
               if);
               aSlotNode.geometry->adjustPos;
               20->trace (# do 'UnExpanded'->T #);
            else
           (* it is a non-terminal *)
               &NonTerminalNode[]->nt[];
               THIS(ListDiagram)[]->nt.theDiagram;
               (pos,unExp[])->nt.display;
               (if remakingDiagram
                // true then
                   20->trace (# do 'Remake; calling conclude'->T #);
                   (0,0)->nt.ConcludeDisplay;
               if);
               nt.geometry->adjustPos;
               20->trace (# do 'non-terminal'->T #);
           if);
        // kinds.optional then
           20->trace (# do 'kinds.optional'->T #);
        // kinds.NameAppl // kinds.String // kinds.NameDecl then
           20->trace (# do 'kinds.NameAppl/NameDecl/String'->T #);
           (anAST.father,pos)->&DisplayAST->pos;
        else
           20->trace (# do 'kinds.other: '->T; anAST.kind->T.putint; #);
           'DisplayAST: kinds.other'->screen.putline;
       if)
   if)
#)  

-- AbstractNodeRemove: DescriptorForm --
(# abstracted: @boolean;
do
   (if switch[1] // true then 'DiagramNode: remove callback'->putline if);
   (if currentDecomposDiagram <> none
    // true then (* this node is detailed *)
    (* mark THIS(DiagramNode) as no longer detailed *)
       (currentDecomposDiagram).titleNode.delete;
       (* remove the detailed diagram *)
       none ->currentDecomposDiagram;
       true->abstracted;
   if);
   decomposdiagrams.scan
     (# do current[]->currentDecomposDiagram #);
   (if abstracted
    // false then
    (* remove THIS(AbstractNode) from the diagramlist and update the diagram *)
       (THIS(AbstractNode)[],false)->DeleteDiagramNode;
   if);
#)  

-- AbstractNodeDisplay: DescriptorForm --
(#
do
   INNER Display;
   gppProp.fontSize->theText.size;
   t->theText.set;
   (* if this node is in a tree then adjust the size to o fit the text *)
   (if theTreeConn[] <> none // true then FitToText; if);
   (if PatternDiagrams.addAfterNode[]
    // none then THIS(AbstractNode)[]->localNodes.append;
    else
       THIS(AbstractNode)[]->PatternDiagrams.newNode[];
       (* save the new node so it can
        * be added later *)
   if);
#)  

-- AbstractNodeReDisplay: DescriptorForm --
(#
do
   INNER ReDisplay;
   t->theText.set;
   (* if this node is in a tree then adjust the size to o fit the text *)
   (if theTreeConn[] <> none // true then FitToText; if);
#)  

-- AbstractNodeConcludeDisplay: DescriptorForm --
(#
do (*ESS false -> sizeable; *) (* dont resize this *)
   (if theTreeConn[]
    // none then
       false->moveable;
       (* we don't like these Nodes in simple patterndiagrams *)
   if);
   titleNode[]->CreateRegion;
#)  

-- AbstractNodeMakeAnchor: DescriptorForm --
(#
do
   (if theDexterAnchor[]
    // none then
       &AnchorMark[]->theDexterAnchor[];
       THIS(AbstractNode)[]->theDexterAnchor.display;
   if)
#)  

-- AbstractNodeAbstractedFromDiagramBelow: DescriptorForm --
(#
do
   (if switch[1]
    // true then 'PatternDiagram: abstractedFromDiagramBelow'->putline;
   if);
   (if CheckForAttributes
    // true then
       none ->currentDecomposDiagram;
       decomposDiagrams.scan
         (# do current[]->currentDecomposDiagram #);
       (* mark THIS(DiagramNode) as no longer detailed *)
       (* change the style of the text, so the user can see that 
        * it is no longer detailed *)
       (*gppProp.AbstractedStyle -> theText.style; not needed when dots are used*)
   if);
#)  

-- AbstractNodeDetail: DescriptorForm --
(# att: ^betaGram.attributes; t: @Text; dummyDetailPage: ^OADPage
do
   'Detailing...'->statusbar.set;
   cursor.wait->cursor.set;
   (if CheckForAttributes
    // true then
       (if detailPage
        // none then (* make the decompose page *)
           (if gppProp.DetailedOnSamePage
            // false then
               &OADPage[]->dummyDetailPage[];
               dummyDetailPage.new;
               dummyDetailPage[]->detailPage;
               (* changes page automatically *)
               titleNode.theText.get->t;
            else
               (if theWorkPage[]
                // none then
                   &OADPage[]->theWorkPage[];
                   theWorkPage.new;
                   'WorkSheet'->theWorkPage.PageTitle;
               if);
               theWorkPage[]->detailPage;
               (* make detailPage the same page as
                * parentNode
                *)
           if)
        else
           detailPage->CurrentPage; (* just select the page *)
       if);
       (if currentDecomposDiagram
        // none then
        else
           currentDecomposDiagram->decomposDiagrams.append;
       if);
       (*gppProp.DetailedStyle -> theText.style;*)
       (* make the diagram *)
       INNER Detail;
       (if currentDecomposDiagram
        // none then
           'Freja[[ERROR: abstractnodebody: no decomposition diagram created]]'
             ->putline;
        else
           THIS(AbstractNode)[]->(currentDecomposDiagram).theParentNode;
       if);
   if);
   statusbar.reset;
   cursor.reset;
   (* if freja and sif is present then we can show
    * dexter anchors in the detailed diagrams *)
   SifEditorInstanceNo->GetDexterAnchors;
#)  

-- AbstractNodeAbstract: DescriptorForm --
(# abstracted: @boolean;
do
   (if currentDecomposDiagram <> none
    // true then
       (currentDecomposDiagram).titleNode.abstract; true->abstracted;
   if);
   decomposDiagrams.scan
     (# do current[]->currentDecomposDiagram #);
   (if abstracted
    // false then
    (* remove THIS(AbstractNode) from the diagramlist and update the diagram *)
       (THIS(AbstractNode)[],false)->DeleteDiagramNode;
   if);
#)
(********************************* DiagramNode *************************************)  

-- DiagramNodeDisplay: DescriptorForm --
(# aName: ^betaGram.NameDcl; theDecl: ^NameDecl; a: ^AST; dummy: ^Text
do
   (if THIS(DiagramNode).struc <= SimpleAttributeDecl##
    // true then (*RndRect*) Rectangle->DefaultShape;
   if);
   (if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
       (pos.x,pos.y,gppProp.width*2,gppProp.height,defaultshape)->new;
       (* the width is adjusted when the text is calulated and inserted *)
    else
       (pos.x+(gppProp.width+1) div 2,pos.y+(gppProp.height+1) div 2,
        gppProp.width,gppProp.height,defaultshape)->new;
   if);
   (if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
         (# last: ^PatternDiagramNode;
         do
            titleNode[]->last[];
            localNodes.scan
              (# d: ^DiagramNode;
              do
                 (if Current.struc <= DiagramNode##
                  // true then
                     Current[]->d[];
                     (if d.theTreeConn[]
                      // none then Current[]->last[];
                     if)
                 if)
              #);
            &TreeConnector[]->theTreeConn[];
            (last[],THIS(DiagramNode)[])->theTreeConn.treeNew;
            (* was new *)
         #)
   if);
   (theDeclaration).index->astIndex;
   (if anAST[]
    // none then '<no name>'->t;
    else
       (if anAST.kind
        // kinds.unExpanded then
           '<NameDcl>'->theName->dummy[];
           dummy->t;
           (* we must save theDecl.index into this(DiagramNode) *)
           theDecl.index->lexemIndex;
        // kinds.optional then
           '<<Optional>>'->theName->dummy[]; dummy->t;
        else
           (if anAST.symbol
            // betaGram.NameDcl then
               anAst[]->aName[];
               aName.getNameDecl->a[];
               (if a.kind
                // kinds.unExpanded then
                   '<NameDecl>'->theName->dummy[];
                   dummy->t;
                   (* we must save theDecl.index into this(DiagramNode) *)
                   a.index->lexemIndex;
                // kinds.optional then
                   '<<Optional>>'->theName->dummy[]; dummy->t;
                else
               (* is a real name *)
                   a[]->theDecl[]; theDecl.getText->theName->dummy[]; dummy->t;
               if);
            // unExpanded then
               '<unExp>'->theName->dummy[]; dummy->t;
            else
               'Freja[[DiagramNodeDisplay: anAST is unknown'->screen.putline;
           if);
       if);
   if);
   INNER Display;
#)  

-- DiagramNodeRedisplay: DescriptorForm --
(# aName: ^betaGram.NameDcl; theDecl: ^NameDecl; a: ^AST; dummy: ^Text
do
   (if switch[1]
    // true then
       'PatternDiagram: DiagramNodeRedisplay, theDeclaration.index: '->putText;
       (theDeclaration).index->putInt;
       newLine;
       'PatternDiagram: DiagramNodeRedisplay, anAst.index: '->putText;
       anAst.Index->putInt;
       newLine;
   if);
   anAST.index->astIndex;
   (if anAST[]
    // none then '<no name>'->t;
    else
       (if anAST.kind
        // kinds.unExpanded then
           '<NameDcl>'->theName->dummy[];
           dummy->t;
           (* we must save theDecl.index into this(DiagramNode) *)
           theDecl.index->lexemIndex;
        // kinds.optional then
           '<<Optional>>'->theName->dummy[]; dummy->t;
        else
           (if anAST.symbol
            // betaGram.NameDcl then
               anAst[]->aName[];
               aName.getNameDecl->a[];
               (if a.kind
                // kinds.unExpanded then
                   '<NameDecl>'->theName->dummy[];
                   dummy->t;
                   (* we must save theDecl.index into this(DiagramNode) *)
                   a.index->lexemIndex;
                // kinds.optional then
                   '<<Optional>>'->theName->dummy[]; dummy->t;
                else
               (* is a real name *)
                   a[]->theDecl[]; theDecl.getText->theName->dummy[]; dummy->t;
               if);
            // unExpanded then
               '<unExp>'->theName->dummy[]; dummy->t;
            else
               'Freja[[DiagramNodeReDisplay: anAST is unknown'->screen.putline;
           if);
       if);
   if);
   INNER Redisplay;
#)  

-- DiagramNodeConcludeDisplay: DescriptorForm --
(#
   x,y,w,h: @Integer;
   m: ^CommentMark;
   pd: ^betaGram.PatternDecl;
   sd: ^betaGram.SimpleDecl;
   rd: ^betaGram.RepetitionDecl;
   vd: ^betaGram.VirtualDecl;
   bd: ^betaGram.BindingDecl;
   (*vpd: ^betaGram.VariablePatternDecl;*)
   theCom: ^comment;
   comPrefix: ^text;
do
(* Check for comments on this node 
 * should be done on tree level but I have only 5 minutes...
 *)
   (if (theDeclaration).struc
    // betaGram.PatternDecl## then
       theDeclaration->pd[];
       (if pd.hasComment
        // true then
           pd.getComment->theCom[];
           theCom.getText->comPrefix[];
           (if true
            // '(#Proc#)'->comPrefix.equal // '(#Class#)'->comPrefix.equal then
            else
               &CommentMark[]->m[];
               (THIS(DiagramNode)[],pd.getComment)->m.display;
           if)
       if)
    // betaGram.SimpleDecl## then
       theDeclaration->sd[];
       (if sd.hasComment
        // true then
           sd.getComment->theCom[];
           theCom.getText->comPrefix[];
           (if true
            // '(#Proc#)'->comPrefix.equal // '(#Class#)'->comPrefix.equal then
            else
               &CommentMark[]->m[];
               (THIS(DiagramNode)[],sd.getComment)->m.display;
           if)
       if)
    // betaGram.RepetitionDecl## then
       theDeclaration->rd[];
       (if rd.hasComment
        // true then
           rd.getComment->theCom[];
           theCom.getText->comPrefix[];
           (if true
            // '(#Proc#)'->comPrefix.equal // '(#Class#)'->comPrefix.equal then
            else
               &CommentMark[]->m[];
               (THIS(DiagramNode)[],rd.getComment)->m.display;
           if);
       if)
    // betaGram.VirtualDecl## then
       theDeclaration->vd[];
       (if vd.hasComment
        // true then
           vd.getComment->theCom[];
           theCom.getText->comPrefix[];
           (if true
            // '(#Proc#)'->comPrefix.equal // '(#Class#)'->comPrefix.equal then
            else
               &CommentMark[]->m[];
               (THIS(DiagramNode)[],vd.getComment)->m.display;
           if)
       if)
    // betaGram.BindingDecl## then
       theDeclaration->bd[];
       (if bd.hasComment
        // true then
           bd.getComment->theCom[];
           theCom.getText->comPrefix[];
           (if true
            // '(#Proc#)'->comPrefix.equal // '(#Class#)'->comPrefix.equal then
            else
               &CommentMark[]->m[];
               (THIS(DiagramNode)[],bd.getComment)->m.display;
           if)
       if)
       (*  //betaGram.VariablePatternDecl## then
        theDeclaration -> vpd[];
        (if vpd.hasComment //true then
        vpd.getComment->theCom[];
        theCom.getText->comPrefix[];
        (if true
        //'(#Proc#)'->comPrefix.equal 
        //'(#Class#)'->comPrefix.equal  then 
        else
        &CommentMark[] -> m[];
        (THIS(DiagramNode)[],vpd.getComment) -> m.display;
        if)
        if)
        *)
   if);
   (*(if theObjectDescriptor<>NONE//true then
    (if (theObjectDescriptor).hasComment//true then
    &CommentMark[] -> m[];
    (THIS(DiagramNode)[],(theObjectDescriptor).getComment) -> m.display;
    if)
    else
    (if (theDeclaration).hasComment//true then
    &CommentMark[] -> m[];
    (THIS(DiagramNode)[],(theDeclaration).getComment) -> m.display;
    else
    if)
    if);
    *)
   (if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
       (if switch[1]
        // true then
           'ConcludeDisplay: moving node: '->screen.puttext;
           dist.x->screen.putint;
           ' '->screen.put;
           dist.y->screen.putint;
           screen.newline;
       if);
       geometry->(x,y,w,h);
       x-dist.x->x;
       (x,y,w,h)->geometry;
       (if theTreeConn[] <> none
        // true then
             (# p: [8] @Integer; last: ^PatternDiagramNode;
             do
                x->p[5];
                (* set two points on the connector *)
                y-(gppProp.DownOnPage)->p[6];
                (* a bit up *)
                y-(gppProp.DownOnPage)->p[4];
                (* a bit up *)
                titleNode[]->last[];
                localNodes.scan
                  (# d: ^DiagramNode;
                  do
                     (if Current.struc <= DiagramNode##
                      // true then
                         Current[]->d[];
                         (if d.theTreeConn[]
                          // none then Current[]->last[];
                         if)
                     if)
                  #);
                last.geometry->(x,y,w,h);
                x->p[3];
                p->theTreeConn.Points;
             #);
       if);
   if);
#)  

-- DiagramNodeDetail: DescriptorForm --
(#
   dummyDetailPage: ^OADPage;
   DD: ^dummyDetailPage.PatternDiagram;
   newName,t: ^Text;
   shape: @Integer;
do
   (if lexemIndex > 0
    // true then
       (THIS(DiagramNode)[],lexemIndex,theName)->LexemExpand;
       detailPage->dummyDetailPage[];
       &dummyDetailPage.PatternNonterminalDiagram[]->DD[];
    else
       (if gppProp.ShowLocals
        // false then
           detailPage->dummyDetailPage[];
           &dummyDetailPage.PatternClassificationDiagram[]->DD[];
        else
           detailPage->dummyDetailPage[];
           &dummyDetailPage.PatternDeclDiagram[]->DD[];
       if)
   if);
   theFragmentNode->DD.theFragmentNode;
   THIS(DiagramNode)[]->PatternDiagrams.detailer[];
   (* set the detailer *)
   (if THIS(DiagramNode).struc <= SimpleAttributeDecl##
    // true then RndRect->shape;
    else
       Rectangle->shape;
   if);
   theName->t[];
   (theObjectDescriptor,t,shape)->DD.new;
   none ->PatternDiagrams.detailer[];
   (* clear the detailer *)
   DD[]->currentDecomposDiagram;
   0->lexemIndex;
#)  

-- DiagramNodeGetGroup: DescriptorForm --
(# fd: ^FragmentDiagram; theDummyFragNode: ^PatternDiagramNode
do
   (if (theDiagram).theFragmentNode <> none
    // true then
       (theDiagram).theFragmentNode->theDummyFragNode[];
       theDummyFragNode.theDiagram->fd[];
       fd.theGroup->fg[];
    else
       'DiagramNode: GetGroup: no FragmentNode'->screen.putline
   if)
#)  

-- DiagramNodeGetFragment: DescriptorForm --
(# fn: ^FragmentNode;
do
   (if (theDiagram).theFragmentNode <> none
    // true then (theDiagram).theFragmentNode->fn[]; fn.theFragment->f[];
    else
       'DiagramNode: GetFragment: no FragmentNode'->screen.putline
   if)
#)  

-- SifEditorInstanceNo: DescriptorForm --
(# fn: ^FragmentNode;
do
   (if (theDiagram).theFragmentNode <> none
    // true then
       (if no
        // 0 then
           (theDiagram).theFragmentNode->fn[]; fn.SifEditorInstance->no;
        else
           (theDiagram).theFragmentNode->fn[]; no->fn.SifEditorInstance;
       if);
    else
       'DiagramNode: SifEditorInstanceNo: no FragmentNode'->screen.putline
   if)
#)  

-- SlotNodeDisplay: DescriptorForm --
(# t: ^Text;
do
(* pos is bottom left of previous box:
 *  calculate center of this box
 *)
   (pos.x+(gppProp.width+1) div 2,pos.y+(gppProp.height+1) div 2,gppProp.width,
    gppProp.height,defaultshape)->new;
   false->moveable;
   (* wo don't like these Nodes to be moved alone *)
   (*ESS false -> sizeable;*)
   titleNode[]->CreateRegion;
   (if aSlotDesc[]
    // none then '<no name>'->t;
    else
       aSlotDesc.name->t[];
   if);
   (if aSlotDesc.category
    // betaGram.AttributesForm then
    // betaGram.Attributes then
       ': AttributeDecl'->t.puttext;
    // betaGram.ObjectDescriptor then
       ': ObjectDescriptor'->t.puttext;
    else
       ': Other category: '->t.puttext; aSlotDesc.category->t.putint;
   if);
   THIS(SlotNode)[]->localNodes.append;
   INNER ;
   t->theText.set;
   (if theText.MaxLineLength > gppProp.propertywidth
    // true then (theText.MaxLineLength,gppProp.height)->size;
   if);
#)  

