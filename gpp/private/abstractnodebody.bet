ORIGIN 'diagramattributes';
(* switches:
 * 20 = print info about each symbol displayed
 *)
-- DisplayAST: Descriptor --
(#
   theDecl: ^betaGram.AttributeDecl;
   theNames: ^betaGram.names;
   theNodeType: ##DiagramNode;
   unExp: ^unExpanded;
   aSlotNode: ^SlotNode;
   aNode: ^DiagramNode;
   nt: ^NonTerminalNode;
   adjustPos: @
     (# x,y,w,h: @Integer; 
     enter (x,y,w,h)
     do
        (if gppProp.CompositionDType > gppProp.CompositionNested
         // true then
            (if w <> (gppProp.width*2)
             // true then (* box is not standard width; adjust x position *)
                x-((gppProp.width*2-w) div 2)->x; (x,y)->aNode.Center; 
            if);
            x+(w div 2)+gppProp.width+10->pos.x;
            
         else
            pos.y+gppProp.height->pos.y; 
        if)
     #);
   
do
   (if anAST[]
    // none then
       'Freja[[ERROR: Display AST: anAST is NONE]]'->screen.putline; 
    else
       kindtest:
       (if anAST.kind
        // kinds.interior then
           (if anAST.symbol
            // betaGram.PatternDecl then
               PatternNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: PatternNode'->T #);
               
            // betaGram.SimpleDecl then
               SimpleNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: SimpleNode'->T #);
               
            // betaGram.RepetitionDecl then
               RepetitionNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: RepetitionNode'->T #);
               
            // betaGram.VirtualDecl then
               VirtualNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: VirtualNode'->T #);
               
            // betaGram.BindingDecl then
               BindingNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: BindingNode'->T #);
               
            // betaGram.FinalDecl then
               FinalNode##->theNodeType##;
               20->trace (#  do ' DisplayAST: FinalNode'->T #);
               
            else
               20->trace (#  do 'DisplayAst: unknown symbol'->T #);
               (if anAST.father <> none
                // true then
                   20->trace (#  do '\tTrying father recursively'->T #);
                   (anAST.father,pos)->&DisplayAST->pos;
                   
                else
                   20->trace (#  do '\tFather is NONE'->T #); 
               if);
               leave kindtest;
               
           if);
           anAST[]->theDecl[];
           theDecl.getson1->anAST[];
           (if anAST[]
            // none then 'Freja[[ERROR: son1 is NONE]]'->screen.putline; 
            else
               (if anAST.kind
                // kinds.interior then
                   anAST[]->theNames[];
                   (if theNames[]
                    // none then
                       'Freja[[ERROR: DisplayAST theNames is NONE]]'
                         ->screen.putline;
                       
                    else
                       theNames.scan
                         (# 
                         do
                            &theNodeType[]->aNode[];
                            THIS(ListDiagram)[]->aNode.theDiagram;
                            (pos,theDecl[],current[])->aNode.display;
                            (if remakingDiagram
                             // true then
                                20
                                  ->trace
                                    (#  do 'Remake; calling conclude'->T #);
                                (0,0)->aNode.ConcludeDisplay;
                                
                            if);
                            aNode.geometry->adjustPos;
                            20->trace (#  do 'Names'->T #);
                            
                         #);
                       
                   if);
                   
                // kinds.unExpanded then
                   &theNodeType[]->aNode[];
                   (pos,theDecl[],anAST[])->aNode.display;
                   (if remakingDiagram
                    // true then
                       20->trace (#  do 'Remake; calling conclude'->T #);
                       (0,0)->aNode.ConcludeDisplay;
                       
                   if);
                   THIS(ListDiagram)[]->aNode.theDiagram;
                   aNode.geometry->adjustPos;
                   20->trace (#  do 'Optional'->T #);
                   
                // kinds.optional then
                   'DisplayAST: son1 is optional'->screen.putline; 
               if);
               
           if);
           
        // kinds.unExpanded then
           20->trace (#  do ' DisplayAST: unexpanded'->T #);
           anAST[]->unExp[];
           (if unExp.isSlot
            // true then
               20->trace (#  do ' DisplayAST: SLOT'->T #);
               &SlotNode[]->aSlotNode[];
               THIS(ListDiagram)[]->aSlotNode.theDiagram;
               (pos,unExp.theSLOT)->aSlotNode.display;
               (if remakingDiagram
                // true then
                   20->trace (#  do 'Remake; calling conclude'->T #);
                   (0,0)->aSlotNode.ConcludeDisplay;
                   
               if);
               aSlotNode.geometry->adjustPos;
               20->trace (#  do 'UnExpanded'->T #);
               
            else
           (* it is a non-terminal *)
               &NonTerminalNode[]->nt[];
               THIS(ListDiagram)[]->nt.theDiagram;
               (pos,unExp[])->nt.display;
               (if remakingDiagram
                // true then
                   20->trace (#  do 'Remake; calling conclude'->T #);
                   (0,0)->nt.ConcludeDisplay;
                   
               if);
               nt.geometry->adjustPos;
               20->trace (#  do 'non-terminal'->T #);
               
           if);
           
        // kinds.optional then
           20->trace (#  do 'kinds.optional'->T #); 
        // kinds.NameAppl // kinds.String // kinds.NameDecl then
           20->trace (#  do 'kinds.NameAppl/NameDecl/String'->T #);
           (anAST.father,pos)->&DisplayAST->pos;
           
        else
           20->trace (#  do 'kinds.other: '->T; anAST.kind->T.putint;  #);
           'DisplayAST: kinds.other'->screen.putline;
           
       if)
   if)
#)  

-- AbstractNodeRemove: Descriptor --
(# abstracted: @boolean; thePatternDiagram: ^PatternDiagram; 
do
   (if switch[1] // true then 'DiagramNode: remove callback'->putline if);
   (if currentDecomposDiagram <> none
    // true then (* this node is detailed *)
    (* mark THIS(DiagramNode) as no longer detailed *)
       currentDecomposDiagram->thePatternDiagram[];
       thePatternDiagram.titleNode.delete;
       (* remove the detailed diagram *)
       none ->currentDecomposDiagram;
       true->abstracted;
       
   if);
   decomposdiagrams.scan
     (#  do current[]->currentDecomposDiagram #);
   (if abstracted
    // false then
    (* remove THIS(AbstractNode) from the diagramlist and update the diagram *)
       (THIS(AbstractNode)[],false)->DeleteDiagramNode; 
   if);
   
#)  

-- AbstractNodeDisplay: Descriptor --
(# 
do
   INNER Display;
   gppProp.fontSize->theText.size;
   t->theText.set;
   FitToText;
   size->updateMaxWH;
   (* if this node is in a tree then adjust the size to o fit the text *)
   (if theTreeConn[] <> none // true then FitToText;  if);
   (if PatternDiagrams.addAfterNode[]
    // none then THIS(AbstractNode)[]->localNodes.append; 
    else
       THIS(AbstractNode)[]->PatternDiagrams.newNode[];
       (* save the new node so it can
        * be added later *)
       
   if);
   
#)  

-- AbstractNodeReDisplay: Descriptor --
(# w,h: @integer
do
   INNER ReDisplay;
   t->theText.set;
   0->MaxWidth;
   0->MaxHeight;
   FitToText;
   size->updateMaxWH;
   localNodes.scan
     (#  do current.FitToText; current.size->updateMaxWH #);
   (* if this node is in a tree then adjust the size to o fit the text *)
   (if theTreeConn[] <> none // true then FitToText;  if);
   
#)  

-- AbstractNodeConcludeDisplay: Descriptor --
(# 
do (*ESS false -> sizeable; *) (* dont resize this *)
   (if theTreeConn[]
    // none then
       false->moveable;
       (* we don't like these Nodes in simple patterndiagrams *)
       
   if);
   titleNode[]->CreateRegion;
   
#)  

-- AbstractNodeMakeAnchor: Descriptor --
(# 
do
   (if theDexterAnchor[]
    // none then
       &AnchorMark[]->theDexterAnchor[];
       THIS(AbstractNode)[]->theDexterAnchor.display;
       
   if)
#)  

-- AbstractNodeAbstractedFromDiagramBelow: Descriptor --
(# 
do
   (if switch[1]
    // true then 'PatternDiagram: abstractedFromDiagramBelow'->putline; 
   if);
   (if CheckForAttributes
    // true then
       none ->currentDecomposDiagram;
       decomposDiagrams.scan
         (#  do current[]->currentDecomposDiagram #);
       (* mark THIS(DiagramNode) as no longer detailed *)
       (* change the style of the text, so the user can see that 
        * it is no longer detailed *)
       (*gppProp.AbstractedStyle -> theText.style; not needed when dots are used*)
       
   if);
   
#)  

-- AbstractNodeDetail: Descriptor --
(# att: ^betaGram.attributes; t: @Text; dummyDetailPage: ^OADPage
do (*   'Detailing...'->statusbar.set;*)
   cursor.wait->cursor.set;
   (if CheckForAttributes
    // true then
       (if currentDecomposDiagram = none then
           (if detailPage
            // none then (* make the decompose page *)
               (if gppProp.DetailedOnSamePage
                // false then
                   &OADPage[]->dummyDetailPage[];
                   dummyDetailPage.new;
                   dummyDetailPage[]->detailPage;
                   (* changes page automatically *)
                   titleNode.theText.get->t;
                   
                else
                   (if theWorkPage[]
                    // none then
                       &OADPage[]->theWorkPage[];
                       theWorkPage.new;
                       'WorkSheet'->theWorkPage.PageTitle;
                       
                   if);
                   theWorkPage[]->detailPage;
                   (* make detailPage the same page as
                    * parentNode
                    *)
                   
               if)
            else
               detailPage->CurrentPage; (* just select the page *) 
           if);
           (if currentDecomposDiagram
            // none then 
            else
           (*   currentDecomposDiagram->decomposDiagrams.append; *)
               
           if);
           INNER Detail;
           (if currentDecomposDiagram
            // none then
               'Freja[[ERROR: abstractnodebody: no decomposition diagram created]]'
                 ->putline;
               
            else
           (*Moved to DiagramNodeDetail:
            THIS(AbstractNode)[]->(currentDecomposDiagram).theParentNode *)
               
           if)
        else
           (currentDecomposDiagram).titleNode[]->currentFocus[]->currentObject
       if);
       (*gppProp.DetailedStyle -> theText.style;*)
       (* make the diagram *)
       
   if);
   (*   statusbar.reset;*)
   cursor.reset;
   (* if freja and sif is present then we can show
    * dexter anchors in the detailed diagrams *)
   SifEditorInstanceNo->GetDexterAnchors;
   
#)  

-- AbstractNodeAbstract: Descriptor --
(# abstracted: @boolean; thePatternDiagram: ^PatternDiagram; 
do
   (if currentDecomposDiagram <> none
    // true then
       currentDecomposDiagram->thePatternDiagram[];
       thePatternDiagram.titleNode.abstract;
       true->abstracted;
       
   if);
   none ->currentDecomposDiagram;
   decomposDiagrams.scan
     (#  do current[]->currentDecomposDiagram #);
   (*  (if abstracted
    // false then
    [* remove THIS(AbstractNode) from the diagramlist and update the diagram *]
    (THIS(AbstractNode)[],false)->DeleteDiagramNode;
    if);*)
   
#)
(********************************* DiagramNode *************************************)  

-- AbstractNodeDump: Descriptor --
(# 
do
   '********theName********'->putline;
   theName->putline;
   '********currentDecomposDiagram********'->putline;
   (if currentDecomposDiagram <> none then
       (currentDecomposDiagram).titletext[]->putline
    else
       'is NONE!'->putline
   if)
#)  

-- DiagramNodeDisplay: Descriptor --
(# aName: ^betaGram.NameDcl; theDecl: ^NameDecl; a: ^AST; dummy: ^Text
do
   (if THIS(DiagramNode).struc <= SimpleAttributeDecl##
    // true then (*RndRect*) Rectangle->DefaultShape; 
   if);
   (if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
       (if switch[18] then
           '******** abstractnodebody-DiagramNodeDisplay 1 calling new with ********'
             ->putline;
           'x: '->putText;
           pos.x->putint;
           newLine;
           'y: '->putText;
           pos.y->putint;
           newLine;
           'w: '->putText;
           gppProp.width*2->putint;
           newLine;
           'h: '->putText;
           gppProp.height->putint;
           newLine;
           
       if);
       (pos.x,pos.y,gppProp.width*2,gppProp.height,defaultshape)->new;
       (* the width is adjusted when the text is calulated and inserted *)
       
    else
       (if switch[18] then
           '******** abstractnodebody-DiagramNodeDisplay 2 calling new with ********'
             ->putline;
           'x: '->putText;
           pos.x+(gppProp.width+1) div 2->putint;
           newLine;
           'y: '->putText;
           pos.y+(gppProp.height+1) div 2->putint;
           newLine;
           'w: '->putText;
           gppProp.width->putint;
           newLine;
           'h: '->putText;
           gppProp.height->putint;
           newLine;
           
       if);
       (pos.x+(gppProp.width+1) div 2,pos.y+(gppProp.height+1) div 2,
        gppProp.width,gppProp.height,defaultshape)->new;
       
   if);
   (if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
         (# last: ^PatternDiagramNode; 
         do
            titleNode[]->last[];
            localNodes.scan
              (# d: ^DiagramNode; 
              do
                 (if Current.struc <= DiagramNode##
                  // true then
                     Current[]->d[];
                     (if d.theTreeConn[]
                      // none then Current[]->last[]; 
                     if)
                 if)
              #);
            &TreeConnector[]->theTreeConn[];
            (last[],THIS(DiagramNode)[])->theTreeConn.treeNew;
            
         #)
   if);
   (theDeclaration).index->astIndex;
   (if switch[1] then
       'DiagramNodeDisplay: '->putText; astIndex->putInt; '->astIndex'->putLine
   if);
   (if anAST[]
    // none then '<<no name>>'->t; 
    else
       (if anAST.kind
        // kinds.unExpanded then
           '<<NameDcl>>'->theName->dummy[]; dummy->t; 
        // kinds.optional then
           '<<Optional>>'->theName->dummy[]; dummy->t; 
        else
           (if anAST.symbol
            // betaGram.NameDcl then
               anAst[]->aName[];
               aName.getNameDecl->a[];
               (if a.kind
                // kinds.unExpanded then
                   '<<NameDecl>>'->theName->dummy[]; dummy->t; 
                // kinds.optional then
                   '<<Optional>>'->theName->dummy[]; dummy->t; 
                else
               (* is a real name *)
                   a[]->theDecl[]; theDecl.getText->theName->dummy[]; dummy->t; 
               if);
               
            // unExpanded then
               '<<unExp>>'->theName->dummy[]; dummy->t; 
            else
               'Freja[[DiagramNodeDisplay: anAST is unknown'->screen.putline; 
           if);
           
       if);
       
   if);
   INNER Display;
   
#)  

-- DiagramNodeRedisplay: Descriptor --
(# aName: ^betaGram.NameDcl; theDecl: ^NameDecl; a: ^AST; dummy: ^Text
do
   (if switch[1]
    // true then
       'PatternDiagram: DiagramNodeRedisplay, theDeclaration.index: '->putText;
       (theDeclaration).index->putInt;
       newLine;
       'PatternDiagram: DiagramNodeRedisplay, anAst.index: '->putText;
       anAst.Index->putInt;
       newLine;
       
   if);
   anAST.index->astIndex;
   (if switch[1] then
       'DiagramNodeReDisplay: '->putText;
       astIndex->putInt;
       '->astIndex'->putLine
   if);
   (if anAST[]
    // none then '<<no name>>'->t; 
    else
       (if anAST.kind
        // kinds.unExpanded then
           '<<NameDcl>>'->theName->dummy[]; dummy->t; 
        // kinds.optional then
           '<<Optional>>'->theName->dummy[]; dummy->t; 
        else
           (if anAST.symbol
            // betaGram.NameDcl then
               anAst[]->aName[];
               aName.getNameDecl->a[];
               (if a.kind
                // kinds.unExpanded then
                   '<<NameDecl>>'->theName->dummy[]; dummy->t; 
                // kinds.optional then
                   '<<Optional>>'->theName->dummy[]; dummy->t; 
                else
               (* is a real name *)
                   a[]->theDecl[]; theDecl.getText->theName->dummy[]; dummy->t; 
               if);
               
            // unExpanded then
               '<<unExp>>'->theName->dummy[]; dummy->t; 
            else
               'Freja[[DiagramNodeReDisplay: anAST is unknown'->screen.putline; 
           if);
           
       if);
       
   if);
   INNER Redisplay;
   
#)  

-- DiagramNodeConcludeDisplay: Descriptor --
(#
   x,y,w,h: @Integer;
   m: ^CommentMark;
   pd: ^betaGram.PatternDecl;
   sd: ^betaGram.SimpleDecl;
   rd: ^betaGram.RepetitionDecl;
   vd: ^betaGram.VirtualDecl;
   bd: ^betaGram.BindingDecl;
   fd: ^betaGram.FinalDecl;
   (*vpd: ^betaGram.VariablePatternDecl;*)
   theCom: ^comment;
   comPrefix: ^text;
   
do
(* Check for comments on this node 
 * should be done on tree level but I have only 5 minutes...
 *)
   (if (theDeclaration).struc
    // betaGram.PatternDecl## then
       theDeclaration->pd[];
       (if pd.hasComment
        // true then
           pd.getComment->theCom[];
           theCom.getText->comPrefix[];
           (if true
            // '(#Proc#)'->comPrefix.equal // '(#Class#)'->comPrefix.equal then
               
            else
               &CommentMark[]->m[];
               (THIS(DiagramNode)[],pd.getComment)->m.display;
               
           if)
       if)
    // betaGram.SimpleDecl## then
       theDeclaration->sd[];
       (if sd.hasComment
        // true then
           sd.getComment->theCom[];
           theCom.getText->comPrefix[];
           (if true
            // '(#Proc#)'->comPrefix.equal // '(#Class#)'->comPrefix.equal then
               
            else
               &CommentMark[]->m[];
               (THIS(DiagramNode)[],sd.getComment)->m.display;
               
           if)
       if)
    // betaGram.RepetitionDecl## then
       theDeclaration->rd[];
       (if rd.hasComment
        // true then
           rd.getComment->theCom[];
           theCom.getText->comPrefix[];
           (if true
            // '(#Proc#)'->comPrefix.equal // '(#Class#)'->comPrefix.equal then
               
            else
               &CommentMark[]->m[];
               (THIS(DiagramNode)[],rd.getComment)->m.display;
               
           if);
           
       if)
    // betaGram.VirtualDecl## then
       theDeclaration->vd[];
       (if vd.hasComment
        // true then
           vd.getComment->theCom[];
           theCom.getText->comPrefix[];
           (if true
            // '(#Proc#)'->comPrefix.equal // '(#Class#)'->comPrefix.equal then
               
            else
               &CommentMark[]->m[];
               (THIS(DiagramNode)[],vd.getComment)->m.display;
               
           if)
       if)
    // betaGram.BindingDecl## then
       theDeclaration->bd[];
       (if bd.hasComment
        // true then
           bd.getComment->theCom[];
           theCom.getText->comPrefix[];
           (if true
            // '(#Proc#)'->comPrefix.equal // '(#Class#)'->comPrefix.equal then
               
            else
               &CommentMark[]->m[];
               (THIS(DiagramNode)[],bd.getComment)->m.display;
               
           if)
       if)
    // betaGram.FinalDecl## then
       theDeclaration->fd[];
       (if fd.hasComment
        // true then
           fd.getComment->theCom[];
           theCom.getText->comPrefix[];
           (if true
            // '(#Proc#)'->comPrefix.equal // '(#Class#)'->comPrefix.equal then
               
            else
               &CommentMark[]->m[];
               (THIS(DiagramNode)[],fd.getComment)->m.display;
               
           if)
       if)
       (*  //betaGram.VariablePatternDecl## then
        theDeclaration -> vpd[];
        (if vpd.hasComment //true then
        vpd.getComment->theCom[];
        theCom.getText->comPrefix[];
        (if true
        //'(#Proc#)'->comPrefix.equal 
        //'(#Class#)'->comPrefix.equal  then 
        else
        &CommentMark[] -> m[];
        (THIS(DiagramNode)[],vpd.getComment) -> m.display;
        if)
        if)
        *)
   if);
   (*(if theObjectDescriptor<>NONE//true then
    (if (theObjectDescriptor).hasComment//true then
    &CommentMark[] -> m[];
    (THIS(DiagramNode)[],(theObjectDescriptor).getComment) -> m.display;
    if)
    else
    (if (theDeclaration).hasComment//true then
    &CommentMark[] -> m[];
    (THIS(DiagramNode)[],(theDeclaration).getComment) -> m.display;
    else
    if)
    if);
    *)
   (if gppProp.CompositionDType > gppProp.CompositionNested
    // true then
       (if switch[1]
        // true then
           'ConcludeDisplay: moving node: '->screen.puttext;
           dist.x->screen.putint;
           ' '->screen.put;
           dist.y->screen.putint;
           screen.newline;
           
       if);
       geometry->(x,y,w,h);
       x-dist.x->x;
       (x,y,w,h)->geometry;
       (if theTreeConn[] <> none
        // true then
             (# p: [8] @Integer; last: ^PatternDiagramNode; 
             do
                x->p[5];
                (* set two points on the connector *)
                y-(gppProp.DownOnPage)->p[6];
                (* a bit up *)
                y-(gppProp.DownOnPage)->p[4];
                (* a bit up *)
                titleNode[]->last[];
                localNodes.scan
                  (# d: ^DiagramNode; 
                  do
                     (if Current.struc <= DiagramNode##
                      // true then
                         Current[]->d[];
                         (if d.theTreeConn[]
                          // none then Current[]->last[]; 
                         if)
                     if)
                  #);
                last.geometry->(x,y,w,h);
                x->p[3];
                p->theTreeConn.Points;
                
             #);
           
       if);
       
   if);
   
#)  

-- DiagramNodeDetail: Descriptor --
(#
   dummyDetailPage: ^OADPage;
   DD: ^dummyDetailPage.PatternDiagram;
   newName,t: ^Text;
   shape: @Integer;
   
do
   (if gppProp.ShowLocals
    // false then
       detailPage->dummyDetailPage[];
       &dummyDetailPage.PatternClassificationDiagram[]->DD[];
       
    else
       detailPage->dummyDetailPage[];
       &dummyDetailPage.PatternDeclDiagram[]->DD[];
       
   if);
   theFragmentNode->DD.theFragmentNode;
   THIS(DiagramNode)[]->PatternDiagrams.detailer[];
   (* set the detailer *)
   (if THIS(DiagramNode).struc <= SimpleAttributeDecl##
    // true then RndRect->shape; 
    else
       Rectangle->shape; 
   if);
   theName->t[];
   DD[]->currentDecomposDiagram;
   THIS(AbstractNode)[]->DD.theParentNode;
   (theObjectDescriptor,t,shape)->DD.new;
   DD[]->currentDecomposDiagram;
   INNER detail;
   none ->PatternDiagrams.detailer[];
   (* clear the detailer *)
   
#)  

-- DiagramNodeGetGroup: Descriptor --
(# fd: ^FragmentDiagram; theDummyFragNode: ^PatternDiagramNode
do
   (if (theDiagram).theFragmentNode <> none
    // true then
       (theDiagram).theFragmentNode->theDummyFragNode[];
       theDummyFragNode.theDiagram->fd[];
       fd.theGroup->fg[];
       
    else
       'DiagramNode: GetGroup: no FragmentNode'->screen.putline
   if)
#)  

-- DiagramNodeGetFragment: Descriptor --
(# fn: ^FragmentNode; 
do
   (if (theDiagram).theFragmentNode <> none
    // true then (theDiagram).theFragmentNode->fn[]; fn.theFragment->f[]; 
    else
       'DiagramNode: GetFragment: no FragmentNode'->screen.putline
   if)
#)  

-- DiagramNodeDump: Descriptor --
(# 
do
   '********theDeclaration********'->putline;
   (if theDeclaration <> none then
       (theDeclaration).dump; newline
    else
       'is NONE!'->putline
   if);
   '********theObjectDescriptor********'->putline;
   (if theObjectDescriptor <> none then
       (theObjectDescriptor).dump; newline
    else
       'is NONE!'->putline
   if);
   '********thePrefix********'->putline;
   (if thePrefix <> none then
       (thePrefix).dump; newline
    else
       'is NONE!'->putline
   if)
#)  

-- SifEditorInstanceNo: Descriptor --
(# fn: ^FragmentNode; 
do
   (if theDiagram = none then
       'SifEditorInstanceNo: theDiagram is none!!'->putLine
   if);
   (if (theDiagram).theFragmentNode <> none
    // true then
       (if no
        // 0 then
           (theDiagram).theFragmentNode->fn[]; fn.SifEditorInstance->no; 
        else
           (theDiagram).theFragmentNode->fn[]; no->fn.SifEditorInstance; 
       if);
       
    else
       'DiagramNode: SifEditorInstanceNo: no FragmentNode'->screen.putline
   if);
   
#)  

-- SlotNodeDisplay: Descriptor --
(# t: ^Text; 
do (* pos is bottom left of previous box:
    *  calculate center of this box
    *)
   (pos.x+(gppProp.width+1) div 2,pos.y+(gppProp.height+1) div 2,gppProp.width,
    gppProp.height,defaultshape)->new;
   false->moveable;
   (* wo don't like these Nodes to be moved alone *)
   (*ESS false -> sizeable;*)
   titleNode[]->CreateRegion;
   (if aSlotDesc[]
    // none then '<<no name>>'->t[]; 
    else
       aSlotDesc.name->t[]; 
   if);
   (if aSlotDesc.category
    // betaGram.AttributesForm then
       
    // betaGram.Attributes then
       ': AttributeDecl'->t.puttext; 
    // betaGram.ObjectDescriptor then
       ': ObjectDescriptor'->t.puttext; 
    else
       ': Other category: '->t.puttext; aSlotDesc.category->t.putint; 
   if);
   THIS(SlotNode)[]->localNodes.append;
   INNER ;
   t->theText.set;
   (if theText.MaxLineLength > gppProp.propertywidth
    // true then (theText.MaxLineLength,gppProp.height)->size; 
   if);
   
#)  

-- PatternNodeDetail: Descriptor --
(# connectorList: ^ObjectList; thisListDiagram: ^ListDiagram
do
   getConnectors->connectorList[];
   (if connectorList[] <> none then
       connectorList.scan
         (# theConn: ^DeletableConnector; OtherEnd: ^SimpleNode
         do
            (if current## <= DynamicItemConnector## then
                current[]->theConn[];
                THIS(PatternNode)[]->theConn.getOtherEnd->OtherEnd[];
                none ->OtherEnd.theReferenceConnector;
                theConn.delete;
                &DynamicItemConnector[]->theConn[];
                true->theConn.initialisingSaved;
                (if OtherEnd.theDiagram <> currentDecomposDiagram then
                    (OtherEnd[],(currentDecomposDiagram).titleNode[])
                      ->theConn.new;
                    theConn[]->OtherEnd.theReferenceConnector
                if)
            if);
            (if current## <= DynamicComponentConnector## then
                current[]->theConn[];
                THIS(PatternNode)[]->theConn.getOtherEnd->OtherEnd[];
                none ->OtherEnd.theReferenceConnector;
                theConn.delete;
                &DynamicComponentConnector[]->theConn[];
                true->theConn.initialisingSaved;
                (if OtherEnd.theDiagram <> currentDecomposDiagram then
                    (OtherEnd[],(currentDecomposDiagram).titleNode[])
                      ->theConn.new;
                    theConn[]->OtherEnd.theReferenceConnector
                if)
            if)
         #)
   if);
   theDiagram->thisListDiagram[];
   thisListDiagram.localNodes.scan
     (#
        theConn: ^DeletableConnector;
        thisSimpleNode: ^SimpleNode;
        theDecl: ^betaGram.SimpleDecl;
        anAST: ^AST
     do
        (if current## <= thisListDiagram.SimpleNode## then
            current[]->thisSimpleNode[];
            (if thisSimpleNode.theQualification <> none then
                (if theDeclaration->(thisSimpleNode.theQualification).equal then
                    thisSimpleNode.theDeclaration->theDecl[];
                    theDecl.getSon2->anAST[];
                    (if anAST.symbol
                     // betaGram.DynamicItem then
                        &DynamicItemConnector[]->theConn[]
                     // betaGram.DynamicComponent then
                        &DynamicComponentConnector[]->theConn[]
                    if);
                    (if theConn[] <> none then
                        true->theConn.initialisingSaved;
                        (thisSimpleNode[],(currentDecomposDiagram).titleNode[])
                          ->theConn.new;
                        theConn[]->thisSimpleNode.theReferenceConnector
                     else
                        'DisplayReferences: theConn is none!?'->putline
                    if)
                if)
            if)
        if)
     #);
   DisplayAssociations
#)  

-- PatternNodeDisplayReferences: Descriptor --
(# theConn: ^DeletableConnector; anAST: ^AST; theDecl: ^betaGram.SimpleDecl
do
   patternDiagrams.theList.scan
     (# thisListDiagram: ^ListDiagram
     do
        current.e[]->thisListDiagram[];
        thisListDiagram.localNodes.scan
          (# thisSimpleNode: ^SimpleNode
          do
             (if current## <= thisListDiagram.SimpleNode## then
                 current[]->thisSimpleNode[];
                 (if thisSimpleNode.theQualification <> none then
                     (if
                     theDeclaration->(thisSimpleNode.theQualification).equal
                      then
                         thisSimpleNode.theDeclaration->theDecl[];
                         theDecl.getSon2->anAST[];
                         (if anAST.symbol
                          // betaGram.DynamicItem then
                             &DynamicItemConnector[]->theConn[]
                          // betaGram.DynamicComponent then
                             &DynamicComponentConnector[]->theConn[]
                         if);
                         (if theConn[] <> none then
                             true->theConn.initialisingSaved;
                             (if theDiagram <> thisSimpleNode.theDiagram then
                                 (thisSimpleNode[],THIS(PatternNode)[])
                                   ->theConn.new;
                                 theConn[]->thisSimpleNode.theReferenceConnector
                             if)
                          else
                             'DisplayReferences: theConn is none!?'->putline
                         if)
                     if)
                 if)
             if)
          #)
     #)
#)  

-- PatternNodeSetupAssociation: Descriptor --
(#
   od,od1,od2,virtOD: ^betaGram.ObjectDescriptor;
   theNames: ^betaGram.Names;
   theNameDcl,nd1,nd2: ^betaGram.NameDcl;
   theMainPart: ^betaGram.MainPart;
   theAttributes: ^betaGram.Attributes;
   theObjSpec: ^betaGram.ObjectSpecification;
   theNameApl: ^betaGram.NameApl;
   thePatternDecl: ^betaGram.PatternDecl;
   thePrefName,t: ^Text;
   endOne,endTwo: ^betaGram.AttributeDecl;
   pd: ^betaGram.patternDecl;
   theRefSpec: ^betaGram.ReferenceSpecification;
   endOneType,endTwoType: @integer
do
   (if theObjectDescriptor <> none then
       (if (theObjectDescriptor).frag.father->ischecked then
           theObjectDescriptor->getPrefix->od[];
           (if od[] <> none then
               (if (od.father).symbol = betaGram.PatternDecl then
                   od.father->pd[];
                   pd.getSon1->theNames[];
                   theNames.getSon1->theNameDcl[];
                   theNameDcl.getText->thePrefName[];
                   (if 'Association'->thePrefName.equal then
                       (if
                       '/users/beta/freja/v1.5/associations'
                         ->((od.frag.father).name).equal then
                           od.getSon2->theMainPart[];
                           theMainPart.getAttributes->theAttributes[];
                           theAttributes.getSon1->thePatternDecl[];
                           thePatternDecl.getObjectDescriptor->od1[];
                           theAttributes.getSon2->thePatternDecl[];
                           thePatternDecl.getObjectDescriptor->od2[];
                           (theObjectDescriptor).getSon2->theMainPart[];
                           theMainPart.getAttributes->theAttributes[];
                           theAttributes.newScan
                             (# nd: ^betaGram.NameDcl
                             do
                                (if current[] <> none then
                                    (if current.symbol = betaGram.SimpleDecl
                                     then
                                        current.getSon2->theRefSpec[];
                                        (if theRefSpec.symbol =
                                        betaGram.StaticItem then
                                            theRefSpec.getSon1->theObjSpec[];
                                            (if theObjSpec.symbol =
                                            betaGram.ObjectDescriptor then
                                                theObjSpec[]->getPrefix->od[];
                                                (if od[] <> none then
                                                    theObjSpec.getSon2
                                                      ->theMainPart[];
                                                    theMainPart.getAttributes
                                                      ->theAttributes[];
                                                    theAttributes.newScan
                                                      (# 
                                                      do
                                                         (if current[] <> none
                                                          then
                                                             (if current.symbol
                                                             =
                                                             betaGram.
                                                               BindingDecl then
                                                                 current.getSon2
                                                                   ->
                                                                     theNameApl[];
                                                                 theNameApl.
                                                                   dclRef->nd[];
                                                                 
                                                             if)
                                                         if)
                                                      #);
                                                    (if nd[] <> none then
                                                        (if od[]->od1.equal then
                                                            (if endOne[] = none
                                                             then
                                                                (nd.father).
                                                                father
                                                                  ->endOne[];
                                                                one->endOneType
                                                             else
                                                                (nd.father).
                                                                father
                                                                  ->endTwo[];
                                                                one->endTwoType
                                                            if)
                                                         else
                                                            (if od[]->od2.equal
                                                             then
                                                                (if endOne[] =
                                                                none then
                                                                    (nd.father).
                                                                    father
                                                                      ->
                                                                        endOne[];
                                                                    many
                                                                      ->
                                                                        endOneType
                                                                 else
                                                                    (nd.father).
                                                                    father
                                                                      ->
                                                                        endTwo[];
                                                                    many
                                                                      ->
                                                                        endTwoType
                                                                if)
                                                            if)
                                                        if)
                                                    if)
                                                if)
                                            if)
                                        if)
                                    if)
                                if)
                             #);
                           (if (endOne[] <> none ) and (endTwo[] <> none ) then
                               (endOne[],endOneType,endTwo[],endTwoType)
                                 ->patternDiagrams.AssociationList.insert
                           if)
                       if)
                   if)
               if)
           if)
       if)
   if)
#)  

-- DisplayAssociations: Descriptor --
(#
   od: ^betaGram.ObjectDescriptor;
   DiagramOne,DiagramTwo: ^Diagram;
   theListDiagram: ^ListDiagram;
   theNode: ^PatternDiagramNode;
   thePatternNode: ^theListDiagram.PatternNode;
   theAssocNode: ^AssociationNode;
   x,y,w,h: @integer
do
   (if not patternDiagrams.AssociationList.empty then
       patternDiagrams.AssociationList.scan
         (# 
         do
            (if CurrentDecomposDiagram <> none then
                (if ((theDeclaration).frag.fullname->current.fragOne.equal) and
                ((theDeclaration).index = current.endOne) then
                    current.endTwo->(theDeclaration).frag.indexToNode->AstToNode
                      ->theNode[];
                    (if theNode[] <> none then
                        theNode.theDiagram->theListDiagram[];
                        (if theNode## <= theListDiagram.patternNode## then
                            theNode[]->thePatternNode[];
                            (if thePatternNode.CurrentDecomposDiagram <> none
                             then
                                thePatternNode.CurrentDecomposDiagram
                                  ->DiagramTwo[];
                                &AssociationNode[]->theAssocNode[];
                                DiagramTwo.titleNode.geometry->(x,y,w,h);
                                CurrentDecomposDiagram->DiagramOne[];
                                (x-300,y)->DiagramOne.titleNode.move;
                                (if (current.endOneType = one) and
                                (current.endTwoType = one) then
                                    (one,CurrentDecomposDiagram,one,
                                     DiagramTwo[])->theAssocNode.display
                                 else
                                    (if (current.endOneType = one) and
                                    (current.endTwoType = many) then
                                        (one,CurrentDecomposDiagram,many,
                                         DiagramTwo[])->theAssocNode.display
                                     else
                                        (if (current.endOneType = many) and
                                        (current.endTwoType = many) then
                                            (many,CurrentDecomposDiagram,many,
                                             DiagramTwo[])->theAssocNode.display
                                         else
                                            'DisplayAssociations: unknown type of association'
                                              ->putline
                                        if)
                                    if)
                                if)
                            if)
                        if)
                    if)
                if);
                (if ((theDeclaration).frag.fullname->current.fragTwo.equal) and
                ((theDeclaration).index = current.endTwo) then
                    current.endOne->(theDeclaration).frag.indexToNode->AstToNode
                      ->theNode[];
                    (if theNode[] <> none then
                        theNode.theDiagram->theListDiagram[];
                        (if theNode## <= theListDiagram.patternNode## then
                            theNode[]->thePatternNode[];
                            (if thePatternNode.CurrentDecomposDiagram <> none
                             then
                                thePatternNode.CurrentDecomposDiagram
                                  ->DiagramOne[];
                                &AssociationNode[]->theAssocNode[];
                                DiagramOne.titleNode.geometry->(x,y,w,h);
                                CurrentDecomposDiagram->DiagramTwo[];
                                (x+300,y)->DiagramTwo.titleNode.move;
                                (if (current.endOneType = one) and
                                (current.endTwoType = one) then
                                    (one,DiagramOne[],one,
                                     CurrentDecomposDiagram)
                                      ->theAssocNode.display
                                 else
                                    (if (current.endOneType = one) and
                                    (current.endTwoType = many) then
                                        (one,DiagramOne[],many,
                                         CurrentDecomposDiagram)
                                          ->theAssocNode.display
                                     else
                                        (if (current.endOneType = many) and
                                        (current.endTwoType = many) then
                                            (many,DiagramOne[],many,
                                             CurrentDecomposDiagram)
                                              ->theAssocNode.display
                                         else
                                            'DisplayAssociations: unknown type of association'
                                              ->putline
                                        if)
                                    if)
                                if)
                            if)
                        if)
                    if)
                if)
            if)
         #)
   if)
#)  

