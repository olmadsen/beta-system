ORIGIN 'diagramattributes';
INCLUDE 'gppinterfacebody';
-- patternNodeDisplay: DoPart --
do
   (anAST[],theDeclaration[])->ppAST
     ->(t,theName,theObjectDescriptor[],propertyString);
   DisplayReferences;
   INNER ;
   setupAssociation  

-- patternNodeRedisplay: DoPart --
do
   (anAST[],theDeclaration[])->ppAST
     ->(t,theName,theObjectDescriptor[],propertyString);
   INNER  

-- patternNodeDoDisplay: DoPart --
do
   (if theDeclaration## <= betaGram.PatternDecl## then
       theDeclaration[]->pd[]; pd.getObjectDescriptor->anAST[]
   if);
   INNER ppAST;
   (if anAST.symbol = betaGram.ObjectDescriptor then
       anAST[]->theObjectDescriptor[]->patterndiagrams.astUtils.getPrefixName
         ->tmpText[];
       (if tmpText[] <> none then ':'->t.puttext; tmpText[]->t.puttext if);
       theObjectDescriptor[]->CheckForAttributes;
       (if attributeType = 0 then
           (if (theObjectDescriptor[]->patternDiagrams.astUtils.getDoPart) <>
           none then
               gppProp.operation->attributeType;
               THIS(PatternNode)[]->operations.append
            else
               gppProp.localClass->attributeType;
               THIS(PatternNode)[]->localClasses.append
           if)
       if);
       '()'->t.puttext
   if);
   (if propertyString[] <> none then
       ' '->t.append; propertyString[]->t.append
   if)  

-- patternNodeOnDoubleClick: DoPart --
do
   false->indicateSelection;
   (if switch[30]
    // true then
       'doubleClick PatternDeclaration ID: '->puttext; ID->putint; newline; 
   if);
   (if hasAttributes then
       detail
    else
       (if switch[30] // true then 'no attributes'->putline if)
   if);
   INNER ;
     

-- patternNodeEqualDescriptor: DoPart --
do
   (if theObjectDescriptor[] <> none then
       aDesc[]->theObjectDescriptor.equal->b; 
   if);
   INNER ;
     

-- PatternNodeDetail: Descriptor --
(# connectors: ^ObjectList; thisListDiagram: ^ListDiagram; x,y,w,h: @integer
do
   getConnectors->connectors[];
   (if connectors[] <> none then
       connectors.scan
         (# con: ^AggregationConnector; theRole: ^con.Role
         do
            (if current## <= AggregationConnector## then
                current[]->con[];
                (con.rightrole->con.rr[]).unmakeRegion;
                (currentDecomposDiagram).titleNode.geometry->(x,y,w,h);
                (x-w div 2,y)->(con.rightrole->con.rr[]).center;
                (currentDecomposDiagram).titleNode[]
                  ->(con.rightrole->con.rr[]).thePatternDiagramNode;
                (currentDecomposDiagram).titleNode[]
                  ->(con.rightrole->con.rr[]).createRegion;
                (if (not gppProp.showAttributes) or
                (theDiagram =
                 ((con.leftrole->con.lr[]).thePatternDiagramNode).theDiagram)
                 then
                    true->con.visible
                if)
            if)
         #)
   if)
#)  

-- PatternNodeDisplayReferences: Descriptor --
(#
   displayAggregation:
     (# 
     do
        patterndiagrams.AggregationList.find
          (#
             predicate:: 
               (# 
               do
                  (theDeclaration.index = current.right) and
                  (theDeclaration.frag.fullname->current.rightFrag.equal)->value
               #);
             ff: ^mps.fragmentForm;
             left: ^SimpleAttributeDecl;
             con: ^AggregationConnector;
             leftRole,rightRole: ^AggregationConnector.Role;
             anAST: ^mps.ast;
             theNames: ^betaGram.Names;
             theNameDcl: ^betaGram.NameDcl
          do
             current.leftFrag[]->topDotOpen->ff[];
             current.left->ff.indexToNode->AstToNode->left[];
             (if left[] <> none then
                 &AggregationConnector[]->con[];
                 true->con.initialisingSaved;
                 (if left.theObjectDescriptor[] = none then
                     left.theDeclaration.getSon2->anAST[];
                     (if anAST.symbol = betaGram.staticItem then
                         gppProp.byValue->con.private.kind
                     if)
                 if);
                 &con.Role[]->leftRole[];
                 (none ,current.leftMulFrom,current.leftMulTo,left[],
                  (*rolename*) true, (*mult*) true, (*rightside*) true)
                   ->leftRole.display;
                 leftRole[]->con.leftRole;
                 &con.Role[]->rightRole[];
                 (none ,current.rightMulFrom,current.rightMulTo,THIS(PatternNode
                  )[], (*rolename*) true, (*mult*) true, (*rightside*) false)
                   ->rightRole.display;
                 (leftRole[],rightRole[])->con.new;
                 leftRole[]->con.leftRole;
                 rightRole[]->con.rightRole;
                 con[]->left.theAggregationConnector;
                 (if (not gppProp.references) or (theDiagram = left.theDiagram)
                 or (not gppProp.showAttributes) then
                     false->con.visible
                 if)
             if)
          #)
     #)
do
   (if switch[53] or switch[54] then
       'PatternNode-DisplayReferences'->putline
   if);
   (* ensure it is not an associationPattern before generating aggregation *)
   patterndiagrams.AssociationList.find
     (#
        predicate:: 
          (# 
          do
             (if current.associationPattern <> 0 then
                 (theDeclaration.index = current.associationPattern) and
                 (theDeclaration.frag.fullname->current.associationFrag.equal)
                   ->value
             if)
          #);
        NotFound::  (#  do displayAggregation #)
     #)
#)  

-- PatternNodeSetupAssociation: Descriptor --
(#
   anAST: ^mps.ast;
   pd: ^betaGram.PatternDecl;
   od: ^betaGram.ObjectDescriptor;
   theNames: ^betaGram.Names;
   theNameDcl: ^betaGram.NameDcl;
   na: ^betaGram.NameApl;
   theMainPart: ^betaGram.MainPart;
   theAttributes: ^betaGram.Attributes;
   theObjSpec: ^betaGram.ObjectSpecification;
   theNameApl: ^betaGram.NameApl;
   left,right,leftPattern,rightPattern: ^betaGram.AttributeDecl;
   thePrefName,t,leftName,rightName,help,name: ^Text;
   leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer;
   getRefToAssociationPattern:
     (#
        anAST: ^mps.ast;
        theDecl: ^betaGram.AttributeDecl;
        theSimpleDecl: ^betaGram.SimpleDecl;
        theRefSpec: ^betaGram.ReferenceSpecification;
        ad: ^betaGram.AttributeDenotation;
        theRemote: ^betaGram.remote;
        theNameApl: ^betaGram.NameApl;
        theMainPart: ^betaGram.MainPart;
        theAttributes: ^betaGram.Attributes
     enter anAST[]
     do
        (if anAST.symbol = betaGram.ObjectDescriptor then
            anAST[]->od[];
            od.getMainPart->theMainPart[];
            theMainPart.getAttributes->theAttributes[];
            theAttributes.newScan
              (# 
              do
                 (if current.symbol = betaGram.SimpleDecl then
                     current[]->theSimpleDecl[];
                     theSimpleDecl.getReferenceSpecification->theRefSpec[];
                     (if theRefSpec.symbol = betaGram.DynamicItem then
                         theRefSpec.getSon1->ad[];
                         (if ad.symbol = betaGram.NameApl then
                             ad[]->theNameApl[]
                          else
                             ad[]->theRemote[];
                             theRemote.getNameApl->theNameApl[]
                         if);
                         (if
                         theObjectDescriptor.father
                           ->(((theNameApl.dclRef).father).father).equal then
                             theSimpleDecl[]->theDecl[]
                         if)
                     if)
                 if)
              #)
        if)
     exit theDecl[]
     #)
do
   (if theObjectDescriptor[] <> none then
       (if theObjectDescriptor.frag.father->ischecked then
           theObjectDescriptor[]->getPrefix->od[];
           findAssociationPrefix:
           (if od[] <> none then
               (if (od.father).symbol = betaGram.PatternDecl then
                   od.father->pd[];
                   pd.getSon1->theNames[];
                   theNames.getSon1->theNameDcl[];
                   theNameDcl.getText->thePrefName[];
                   (if thePrefName[]->patterndiagrams.utils.isAssociationName
                    then
                       frejaAssociationsInclude->mps.expandToFullPath->help[];
                       (od.frag.father).name->mps.expandToFullPath->name[];
                       (if help[]->name.equal then
                           (if true
                            // ('OneToOneAssociation'->thePrefName.equalNCS)
                            then
                               (1,1,1,1)
                                 ->
                                   (leftMulFrom,leftMulTo,rightMulFrom,
                                    rightMulTo);
                               'leftType'->leftName[];
                               'rightType'->rightName[]
                            // ('OneToManyAssociation'->thePrefName.equalNCS)
                            then
                               (1,1,- 1,- 1)
                                 ->
                                   (leftMulFrom,leftMulTo,rightMulFrom,
                                    rightMulTo);
                               'oneType'->leftName[];
                               'manyElmType'->rightName[]
                            // ('ManyToManyAssociation'->thePrefName.equalNCS)
                            then
                               (- 1,- 1,- 1,- 1)
                                 ->
                                   (leftMulFrom,leftMulTo,rightMulFrom,
                                    rightMulTo);
                               'leftType'->leftName[];
                               'rightType'->rightName[]
                           if);
                           theObjectDescriptor.getSon2->theMainPart[];
                           theMainPart.getAttributes->theAttributes[];
                           theAttributes.newScan
                             (# nd: ^betaGram.NameDcl
                             do
                                (if current[] <> none then
                                    (if current.symbol = betaGram.BindingDecl
                                     then
                                        current.getSon1->theNames[];
                                        theNames.getSon1->theNameDcl[];
                                        theNameDcl.getText->t[];
                                        (if (leftName[]->t.equalNCS) or
                                        (rightName[]->t.equalNCS) then
                                            current.getSon2->theObjSpec[];
                                            (if theObjSpec.symbol
                                             // betaGram.NameApl then
                                                theObjSpec[]->na[]
                                             // betaGram.remote then
                                                theObjSpec.getSon2->na[]
                                            if);
                                            na.dclRef->theNameDcl[];
                                            (if true
                                             // (leftName[]->t.equalNCS) then
                                                (theNameDcl.father).father
                                                  ->leftPattern[];
                                                leftPattern.getSon2
                                                  ->getRefToAssociationPattern
                                                  ->left[]
                                             // (rightName[]->t.equalNCS) then
                                                (theNameDcl.father).father
                                                  ->rightPattern[];
                                                rightPattern.getSon2
                                                  ->getRefToAssociationPattern
                                                  ->right[]
                                            if)
                                        if)
                                    if)
                                if)
                             #);
                           (if (left[] <> none ) and (right[] <> none ) then
                               (left[],right[],leftMulFrom,leftMulTo,
                                rightMulFrom,rightMulTo,theDeclaration[])
                                 ->patterndiagrams.AssociationList.insert
                           if)
                        else
                           'Invalid association library: '->puttext;
                           name[]->putline;
                           'Correct association library: '->puttext;
                           help[]->putline
                       if)
                    else
                       od[]->getPrefix->od[]; restart findAssociationPrefix
                   if)
               if)
           if)
       if)
   if)
#)  

-- PatternNodeOnInit: DoPart --
do UDPrivate.UDPatternNode->UserDataInit; INNER onInit  

-- PatternNodeDump: DoPart --
do 'PatternNode'->nodetype[]; INNER dump  

