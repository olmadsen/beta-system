ORIGIN 'diagramattributes';
LIB_ITEM 'gpp';
INCLUDE 'gppinterfacebody';
-- SimpleAttributeDeclPopupDescOnStatus: DoPart --
do
   (THIS(SimpleAttributeDecl).private.SimpleDeclDisplay = gppProp.AsNameAndType)
     ->checked  

-- SimpleAttributeDeclPopupDescOnSelect: DoPart --
do gppProp.AsNameAndType->changeDisplay  

-- SimpleAttributeDeclPopupDescNameOnStatus: DoPart --
do
   (THIS(SimpleAttributeDecl).private.SimpleDeclDisplay = gppProp.AsName)
     ->checked  

-- SimpleAttributeDeclPopupDescNameOnSelect: DoPart --
do gppProp.AsName->changeDisplay  

-- SimpleAttributeDeclPopupDescTypeOnStatus: DoPart --
do
   (THIS(SimpleAttributeDecl).private.SimpleDeclDisplay = gppProp.AsType)
     ->checked  

-- SimpleAttributeDeclPopupDescTypeOnSelect: DoPart --
do gppProp.AsType->changeDisplay  

-- SimpleAttributeDeclPopupDescNameAndKingOnStatus: DoPart --
do
   (THIS(SimpleAttributeDecl).private.SimpleDeclDisplay = gppProp.AsNameAndKind)
     ->checked  

-- SimpleAttributeDeclPopupDescNameAndKingOnSelect: DoPart --
do gppProp.AsNameAndKind->changeDisplay  

-- SimpleAttributeDeclPopupDescOpen: DoPart --
do
   NameAndTypeItem.open;
   'Name and Type'->NameAndTypeItem.name;
   NameAndTypeItem[]->append;
   NameItem.open;
   'Name'->NameItem.name;
   NameItem[]->append;
   TypeItem.open;
   'Type'->TypeItem.name;
   TypeItem[]->append;
   NameAndKindItem.open;
   'Name and Kind'->NameAndKindItem.name;
   NameAndKindItem[]->append;
   INNER open  

-- SimpleAttrDeclDisplay: Descriptor --
(# 
do
   (if theObjectSpec[] <> none then
       (if theObjectSpec.kind = mps.kinds.interior then
           theObjectSpec[]->setUpRelations
       if)
   if)
#)  

-- SimpleAttrDeclRedisplay: Descriptor --
(# 
do
   (if theObjectSpec[] <> none then
       (if theObjectSpec.kind = mps.kinds.interior then
           theObjectSpec[]->setUpRelations
       if)
   if)
#)  

-- simpleNodePPAST: DoPart --
do
     (# theSimpleDecl: ^betaGram.SimpleDecl; anAST: ^mps.ast
     do
        theDeclaration[]->theSimpleDecl[];
        theSimpleDecl.GetReferenceSpecification->anAST[];
        (if anAST## <= betaGram.referenceSpecification## then
            anAst[]->theReferenceSpec[];
            theReferenceSpec.getson1->theObjectSpec[]
         else
            (if anAST.kind = mps.kinds.unExpanded then
                anAST[]->theUnExpRefSpec[]
            if)
        if)
     #)  

-- SimpleNodeDisplayReference: Descriptor --
(# 
do
   (53,54)->trace2 (#  do 'SimpleNodeDisplayReference'->t #);
   patterndiagrams.AssociationList.find
     (#
        predicate:: 
          (# 
          do
             ((theDeclaration.index = current.left) and
              (theDeclaration.frag.fullname->current.leftFrag.equal)) or
             ((theDeclaration.index = current.right) and
              (theDeclaration.frag.fullname->current.rightFrag.equal))->value
          #);
        NotFound::  (#  do displayAggregation #);
        ff: ^mps.fragmentForm;
        con: ^AssociationConnector;
        leftRole,rightRole: ^AssociationConnector.Role;
        rightAggRole,leftAggRole: ^DesignObject;
        left,right: ^SimpleNode;
        associationNode: ^PatternNode;
        theNames: ^betaGram.Names;
        anAST: ^mps.ast;
        theNameDcl: ^betaGram.NameDcl;
        theName,leftName,rightName: ^Text;
        x,y,w,h,lx,ly,rx,ry: @integer;
        l: ^UserDataLabelNode;
        roleNameVisible: @boolean
     do
        (if theDeclaration.index = current.left then
            current.rightFrag[]->topDotOpen->ff[];
            current.right->ff.indexToNode->AstToNode->right[];
            THIS(SimpleNode)[]->left[]
         else
            current.leftFrag[]->topDotOpen->ff[];
            current.left->ff.indexToNode->AstToNode->left[];
            THIS(SimpleNode)[]->right[]
        if);
        (if (current.associationFrag[] <> none ) and
        (current.associationPattern <> 0) then
            current.associationFrag[]->topDotOpen->ff[];
            current.associationPattern->ff.indexToNode->AstToNode
              ->associationNode[]
        if);
        (if associationNode[] <> none then
            associationNode.theDeclaration.getSon1->theNames[];
            theNames.getSon1->anAST[];
            (if anAST.kind <> mps.kinds.unExpanded then
                anAST[]->theNameDcl[]; theNameDcl.getText->theName[]
            if)
        if);
        (if (left[] <> none ) and (right[] <> none ) then
            left.theDeclaration.getSon1->theNames[];
            theNames.getSon1->anAST[];
            (if anAST.kind <> mps.kinds.unExpanded then
                anAST[]->theNameDcl[]; theNameDcl.getText->leftName[]
            if);
            right.theDeclaration.getSon1->theNames[];
            theNames.getSon1->anAST[];
            (if anAST.kind <> mps.kinds.unExpanded then
                anAST[]->theNameDcl[]; theNameDcl.getText->rightName[]
            if);
            (* to prevent onInit from generating code *)
            (* make assignment here to make rightRole.display
             know it's the right role!
             make assignment again below after con.new so that
             it is persistent! *)
            (if theAssociationConnector = none then
                (if left.theAggregationConnector <> none then
                    (left.theAggregationConnector).leftRole->leftAggRole[];
                    (left.theAggregationConnector).rightRole->rightAggRole[];
                    leftAggRole.delete;
                    rightAggRole.delete;
                    none ->left.theAggregationConnector
                if);
                (if right.theAggregationConnector <> none then
                    (right.theAggregationConnector).leftRole->leftAggRole[];
                    (right.theAggregationConnector).rightRole->rightAggRole[];
                    leftAggRole.delete;
                    rightAggRole.delete;
                    none ->right.theAggregationConnector
                if);
                &AssociationConnector[]->con[];
                (left[],right[],associationNode[],theName[],gppProp.list,
                 rightName[],leftName[],current.leftMulFrom,current.leftMulTo,
                 current.rightMulFrom,current.rightMulTo,not
                 (associationNode[] <> none ),none ,gppProp.associations,false,
                 (*srolename*) false, (*smul*) true, (*srightside*) true,
                 (*drolename*) false, (*dmul*) true, (*drightside*) false)
                  ->con.display
             else
                (if left.theAggregationConnector <> none then
                    (left.theAggregationConnector).leftRole->leftAggRole[];
                    (left.theAggregationConnector).rightRole->rightAggRole[];
                    leftAggRole.delete;
                    rightAggRole.delete;
                    none ->left.theAggregationConnector
                if);
                (if right.theAggregationConnector <> none then
                    (right.theAggregationConnector).leftRole->leftAggRole[];
                    (right.theAggregationConnector).rightRole->rightAggRole[];
                    leftAggRole.delete;
                    rightAggRole.delete;
                    none ->right.theAggregationConnector
                if);
                (if
                (
                (theAssociationConnector).leftrole
                  ->(theAssociationConnector).lr[]).thePatternDiagramNode <>
                left[] then
                    (
                    (theAssociationConnector).leftrole
                      ->(theAssociationConnector).lr[]).unmakeRegion;
                    left[]
                      ->
                        (
                        (theAssociationConnector).leftrole
                          ->(theAssociationConnector).lr[]).
                        thePatternDiagramNode;
                    left[]
                      ->
                        (
                        (theAssociationConnector).leftrole
                          ->(theAssociationConnector).lr[]).createRegion;
                    left.geometry->(x,y,w,h);
                    (x-w div 2,y)
                      ->
                        (
                        (theAssociationConnector).leftrole
                          ->(theAssociationConnector).lr[]).center
                if);
                (if
                (
                (theAssociationConnector).rightrole
                  ->(theAssociationConnector).rr[]).thePatternDiagramNode <>
                right[] then
                    (
                    (theAssociationConnector).rightrole
                      ->(theAssociationConnector).rr[]).unmakeRegion;
                    right[]
                      ->
                        (
                        (theAssociationConnector).rightrole
                          ->(theAssociationConnector).rr[]).
                        thePatternDiagramNode;
                    right[]
                      ->
                        (
                        (theAssociationConnector).rightrole
                          ->(theAssociationConnector).rr[]).createRegion;
                    right.geometry->(x,y,w,h);
                    (x-w div 2,y)
                      ->
                        (
                        (theAssociationConnector).rightrole
                          ->(theAssociationConnector).rr[]).center
                if);
                associationNode[]->(theAssociationConnector).associationNode;
                (if associationNode[] = none then
                    true->(theAssociationConnector).embed
                 else
                    false->(theAssociationConnector).embed
                if);
                (if theName[] <> none then
                    (if (theAssociationConnector).name <> none then
                        theName->((theAssociationConnector).name).theText.set;
                        textStyle.italic
                          ->((theAssociationConnector).name).theText.style;
                        ((theAssociationConnector).name).visible
                          ->((theAssociationConnector).name).visible
                     else
                        (
                        (theAssociationConnector).leftrole
                          ->(theAssociationConnector).lr[]).center->(lx,ly);
                        (
                        (theAssociationConnector).rightrole
                          ->(theAssociationConnector).rr[]).center->(rx,ry);
                        &UserDataLabelNode[]->l[];
                        (lx+((rx-lx) div 2),ly+((ry-ly) div 2),10,10,theName)
                          ->l.new;
                        textStyle.italic->l.theText.style;
                        l.fitToText;
                        (lx+((rx-lx) div 2),ly+((ry-ly) div 2)-10)->l.center;
                        theAssociationConnector->l.createRegion;
                        l[]->(theAssociationConnector).name;
                        false->((theAssociationConnector).name).visible
                    if)
                 else
                    (if (theAssociationConnector).name <> none then
                        ((theAssociationConnector).name).delete;
                        none ->(theAssociationConnector).name
                    if)
                if);
                (theAssociationConnector).leftrole
                  ->(theAssociationConnector).lr[];
                (if (theAssociationConnector).lr.name <> none then
                    ((theAssociationConnector).lr.name).visible->rolenameVisible
                 else
                    false->rolenameVisible
                if);
                (rightName[],current.leftMulFrom,current.leftMulTo, (*rolename*)
                 roleNameVisible, (*mult*)
                 ((theAssociationConnector).lr.multiplicity).visible,
                 (*rightside*) (theAssociationConnector).lr.attachRight)
                  ->(theAssociationConnector).lr.redisplay;
                (theAssociationConnector).rightrole
                  ->(theAssociationConnector).rr[];
                (if (theAssociationConnector).rr.name <> none then
                    ((theAssociationConnector).rr.name).visible->rolenameVisible
                 else
                    false->rolenameVisible
                if);
                (leftName[],current.rightMulFrom,current.rightMulTo,
                 (*rolename*) roleNameVisible, (*mult*)
                 ((theAssociationConnector).rr.multiplicity).visible,
                 (*rightside*) (theAssociationConnector).rr.attachRight)
                  ->(theAssociationConnector).rr.redisplay;
                (if not gppProp.associations then
                    false->(theAssociationConnector).visible
                if);
                (if not gppProp.showAttributes then
                    false->(theAssociationConnector).attributesVisible
                if)
            if)
        if)
     #);
   
#)  

-- SimpleNodeDoubleClick: Descriptor --
(# old: @Integer; 
do
   false->IndicateSelection;
   30->trace (#  do 'SimpleDeclaration'->t #);
   (if theObjectDescriptor[] <> none then detail if)
#)  

-- SimpleNodeDetail: DoPart --
do DisplayReference  

-- SimpleNodeDisplay: Descriptor --
(# 
do
   (anAST[],theDeclaration[])->ppAST
     ->
       (t,theName,theObjectDescriptor[],propertyString,theReferenceSpec[],
        theUnExpRefSpec[],theObjectSpec[])
#)  

-- SimpleNodeRedisplay: Descriptor --
(# 
do
   (anAST[],theDeclaration[])->ppAST
     ->
       (t,theName,theObjectDescriptor[],propertyString,theReferenceSpec[],
        theUnExpRefSpec[],theObjectSpec[])
#)  

-- SimpleNodeEdit: DoPart --
do
     (# oadd: ^OADDiagram
     do THIS(ListDiagram)[]->oadd[]; THIS(SimpleNode)[]->oadd.editAttribute
     #)  

-- RepetitionNodeDoubleClick: Descriptor --
(# 
do
   false->IndicateSelection;
   (if theObjectDescriptor[] <> none // true then detail if)
#)  

-- RepetitionNodeDisplay: Descriptor --
(# 
do
   (anAST[],theDeclaration[])->ppAST
     ->
       (t,theName,theObjectDescriptor[],propertyString,theReferenceSpec[],
        theUnExpRefSpec[],theObjectSpec[]);
   
#)  

-- RepetitionNodeRedisplay: Descriptor --
(# 
do
   (anAST[],theDeclaration[])->ppAST
     ->
       (t,theName,theObjectDescriptor[],propertyString,theReferenceSpec[],
        theUnExpRefSpec[],theObjectSpec[]);
   
#)  

-- repetitionNodePPAST: DoPart --
do
     (# theRepDecl: ^betaGram.RepetitionDecl; anAST: ^MPS.AST; 
     do
        theDeclaration[]->theRepDecl[];
        theRepDecl.GetReferenceSpecification->anAST[];
        (if anAST## <= betaGram.referenceSpecification## then
            anAst[]->theReferenceSpec[];
            theReferenceSpec.getson1->theObjectSpec[]
         else
            (if anAST.kind = mps.kinds.unExpanded then
                anAST[]->theUnExpRefSpec[]
            if)
        if)
     #)  

-- RepetitionNodeDisplayReference: DoPart --
do displayAggregation  

-- simpleAttributeDeclPPAST: DoPart --
do
   INNER ppAST;
     (#
        indexText,sdName: @text;
        tmpText: ^text;
        na: ^betaGram.nameApl;
        found: @Boolean;
        rem: ^betaGram.remote;
        unExp: ^mps.unexpanded;
        anAST: ^MPS.AST;
        MakeSimpleDeclName:
          (#
             type: ^Text;
             indexText: @Text;
             frag: ^mps.Fragment;
             mpsAST: ^mps.AST;
             makeKind:
               (# 
               do
                  (if theDeclaration.symbol = betaGram.RepetitionDecl then
                      ': ['->t.puttext;
                      theDeclaration.getson2->anAST[];
                      anAST.frag[]->frag[];
                      anAST[]->mpsAST[];
                      (mps[],frag[],mpsAST[],indextext[],none (*streamName[]*)
                       ,80,0,false (*abstractPresentation*) ,false
                       (*showSemanticErrors*) ,false (*includeComments*) ,false,
                       false,false,false,'',false (*onlyProperties*) ,false,
                       false (*
                              test*) )->ppFragment;
                      (1,indexText.length-3)->indexText.sub->t.puttext;
                      (if theReferenceSpec.symbol
                       // betaGram.StaticItem then
                          '] @ '->t.puttext; 
                       // betaGram.DynamicItem then
                          '] ^ '->t.puttext; 
                       // betaGram.StaticComponent then
                          '] @| '->t.puttext; 
                       // betaGram.DynamicComponent then
                          '] ^| '->t.puttext; 
                       // betaGram.VariablePattern then
                          '] ## '->t.puttext; 
                      if)
                   else
                      (if theReferenceSpec.symbol
                       // betaGram.StaticItem then
                          ': @ '->t.puttext; 
                       // betaGram.DynamicItem then
                          ': ^ '->t.puttext; 
                       // betaGram.StaticComponent then
                          ': @| '->t.puttext; 
                       // betaGram.DynamicComponent then
                          ': ^| '->t.puttext; 
                       // betaGram.VariablePattern then
                          ': ## '->t.puttext; 
                      if)
                  if)
               #);
             
          enter type[]
          do
             (if private.SimpleDeclDisplay
              // gppProp.AsNameAndType then
                 makeKind; type[]->t.puttext
              // gppProp.asName then
                 
              // gppProp.asType then
                 t.clear; makeKind; type[]->t.puttext; 
              // gppProp.asNameAndKind then
                 makeKind; 
             if);
             
          #);
        ppUnExpRefSpec:
          (# t,indexText: @text; anAST: ^MPS.AST
          do
             (if theUnExpRefSpec[] <> none then
                 (if theDeclaration.symbol = betaGram.RepetitionDecl then
                     ': ['->t.puttext;
                     theDeclaration.getson2->anAST[];
                     (mps[],anAST.frag[],anAST[],indextext[],none
                      (*streamName[]*) ,80,0,false (*abstractPresentation*) ,
                      false (*showSemanticErrors*) ,false (*includeComments*) ,
                      false,false,false,false,'',false (*onlyProperties*) ,
                      false,false (*
                                   test*) )->ppFragment;
                     (1,indexText.length-3)->indexText.sub->t.puttext;
                     '] '->t.puttext;
                     theUnExpRefSpec.nonTerminalSymbol->betaGram.symbolToName
                       ->makeNonTerminalSymbol->t.append
                  else
                     ': '->t.append;
                     theUnExpRefSpec.nonTerminalSymbol->betaGram.symbolToName
                       ->makeNonTerminalSymbol->t.append
                 if)
             if)
          exit t[]
          #)
     do
        (if theObjectSpec[] = none then
            70->trace (#  do 'No ObjectSpec.'->t #);
            ppUnExpRefSpec->t.puttext
         else
            (if theObjectSpec.kind
             // mps.kinds.unExpanded then
                theObjectSpec[]->unExp[];
                (if unExp.isSlot
                 // true then
                    (mps[],unExp.frag[],unExp[],indextext[],none
                     (*streamName[]*) ,80,0,false (*abstractPresentation*) ,
                     false (*showSemanticErrors*) ,false (*includeComments*) ,
                     false,false,false,false,'',false (*onlyProperties*) ,false,
                     false (*
                            test*) )->ppFragment;
                    (1,indexText.length-3)->indexText.sub->MakeSimpleDeclName;
                    (*  unExp.theSlot->aSlotDesc[];
                     (if aSlotDesc.category
                     // betaGram.Attributes then
                     'AttributeDecl'->MakeSimpleDeclName; 
                     // betaGram.ObjectDescriptor then
                     'ObjectDescriptor'->MakeSimpleDeclName; 
                     else
                     'Other category: '->t.puttext; aSlotDesc.category->t.putint; 
                     if);*)
                    
                 else
                    unExp.nonTerminalSymbol->betaGram.symbolToName
                      ->makeNonTerminalSymbol->MakeSimpleDeclName
                if)
             // mps.kinds.interior then
                (if theObjectSpec.symbol
                 // betaGram.ObjectDescriptor then
                    theObjectSpec[]->theObjectDescriptor[]
                      ->patterndiagrams.astUtils.getPrefixName->tmpText[];
                    (if tmpText[] <> none then tmpText[]->sdName.puttext if);
                    ' ...'->sdName.puttext;
                    gppProp.AsNameAndType->private.SimpleDeclDisplay;
                    sdName[]->MakeSimpleDeclName
                 // betaGram.NameApl then
                    theObjectSpec[]->na[];
                    na.getNameAppl->anAST[];
                    (if anAST.kind = mps.kinds.unExpanded then
                        '<<NameAppl>>'->MakeSimpleDeclName
                     else
                        na.gettext->MakeSimpleDeclName
                    if)
                 // betaGram.remote then
                    theObjectSpec[]->makeRemote->MakeSimpleDeclName
                 else
                    'ppAST another type '->puttext;
                    theObjectSpec.symbol->putint;
                    newline
                if)
             // mps.kinds.optional then
                'display: mps.kinds.optional'->putline; 
             // mps.kinds.SlotDesc then
                'display: mps.kinds.SlotDesc'->putline; 
             else
                'display: mps.kinds other'->putline; 
            if)
        if)
     #)  

-- SimpleAttributeDeclChangeDisplay: DoPart --
do
   false->repair;
   SimpleDeclDisplay->THIS(SimpleAttributeDecl).private.SimpleDeclDisplay;
   theDeclaration.getSon1->theNames[];
   (theDeclaration[],theNames.getSon1)->Redisplay;
   localNodes.adjustSizes;
   true->repair  

-- SimpleAttrDeclDisplayAggregation: DoPart --
do
   54
     ->trace
       (# 
       do
          'SimpleAttrDeclDisplayAggregation on "%s"'
            ->t.putformat (# help: @text do theText.get->help; help[]->s #)
       #);
   (if (theReferenceSpec.symbol = betaGram.DynamicItem) or
   (theReferenceSpec.symbol = betaGram.StaticItem) then
       patterndiagrams.AggregationList.find
         (#
            predicate:: 
              (# 
              do
                 (theDeclaration.index = current.left) and
                 (theDeclaration.frag.fullname->current.leftFrag.equal)->value
              #);
            ff: ^mps.fragmentForm;
            right: ^AbstractNode;
            theRightNode: ^PatternDiagramNode;
            con: ^AggregationConnector;
            leftRole,rightRole: ^AggregationConnector.Role;
            leftAssRole,rightAssRole: ^DesignObject;
            theSimpleNode: ^SimpleNode;
            anAST: ^mps.ast;
            theNames: ^betaGram.Names;
            theNameDcl: ^betaGram.NameDcl;
            x,y,w,h: @integer;
            makeInvisible,doShow: @boolean;
            kind: @integer
         do
            current.rightFrag[]->topDotOpen->ff[];
            current.right->ff.indexToNode->AstToNode->right[];
            (if right[] <> none then
                (if theDeclaration.symbol = betaGram.SimpleDecl then
                    theDeclaration.getSon2->anAST[]
                 else
                    (if theDeclaration.symbol = betaGram.RepetitionDecl then
                        theDeclaration.getSon3->anAST[]
                    if)
                if);
                (if theAggregationConnector = none then
                    (if theAssociationConnector <> none then
                        (if
                        (
                        (theAssociationConnector).leftrole
                          ->(theAssociationConnector).lr[]).
                        thePatternDiagramNode = THIS(SimpleAttributeDecl)[] then
                            (
                            (theAssociationConnector).rightrole
                              ->(theAssociationConnector).rr[]).
                            thePatternDiagramNode->theSimpleNode[]
                         else
                            (
                            (theAssociationConnector).leftrole
                              ->(theAssociationConnector).lr[]).
                            thePatternDiagramNode->theSimpleNode[]
                        if);
                        none ->theSimpleNode.theAssociationConnector;
                        (theAssociationConnector).leftRole->leftAssRole[];
                        (theAssociationConnector).rightRole->rightAssRole[];
                        leftAssRole.delete;
                        rightAssRole.delete;
                        none ->theAssociationConnector
                    if);
                    &AggregationConnector[]->con[];
                    (if anAST[] <> none then
                        (if anAST.symbol = betaGram.staticItem then
                            (if current.rightMulTo = 1
                            (* most likely a singular (hack FIXME) *) then
                                gppProp.byValue->kind
                             else
                                gppProp.byReference->kind
                            if)
                         else
                            gppProp.byReference->kind
                        if)
                    if);
                    (if right.currentDecomposDiagram <> none then
                        (theDiagram = right.currentDecomposDiagram)
                          ->makeInvisible;
                        (right.currentDecomposDiagram).titleNode[]
                          ->theRightNode[]
                     else
                        (not gppProp.showAttributes) or
                        (theDiagram = right.theDiagram)->makeInvisible;
                        right[]->theRightNode[]
                    if);
                    (THIS(SimpleAttributeDecl)[],theRightNode[],none ,none ,0,
                     none ,none ,current.leftMulFrom,current.leftMulTo,
                     current.rightMulFrom,current.rightMulTo,false,none ,false,
                     (not gppProp.references) or makeinvisible, (*srolename*)
                     false, (*smul*) true, (*srightside*) true, (*drolename*)
                     false,true, (*dmul*) false, (*drightside*) kind)
                      ->con.display;
                    (if not makeInvisible then
                        (if not gppProp.showAttributes then
                            (if right.currentDecomposDiagram <> none then
                                false->con.attributesVisible
                             else
                                false->con.visible
                            if)
                        if)
                    if)
                 else
                    (if theAssociationConnector <> none then
                        (if
                        (
                        (theAssociationConnector).leftrole
                          ->(theAssociationConnector).lr[]).
                        thePatternDiagramNode = THIS(SimpleAttributeDecl)[] then
                            (
                            (theAssociationConnector).rightrole
                              ->(theAssociationConnector).rr[]).
                            thePatternDiagramNode->theSimpleNode[]
                         else
                            (
                            (theAssociationConnector).leftrole
                              ->(theAssociationConnector).lr[]).
                            thePatternDiagramNode->theSimpleNode[]
                        if);
                        none ->theSimpleNode.theAssociationConnector;
                        (theAssociationConnector).leftRole->leftAssRole[];
                        (theAssociationConnector).rightRole->rightAssRole[];
                        leftAssRole.delete;
                        rightAssRole.delete;
                        none ->theAssociationConnector
                    if);
                    (theAggregationConnector).rightrole
                      ->(theAggregationConnector).rr[];
                    (theAggregationConnector).leftrole
                      ->(theAggregationConnector).lr[];
                    (if not
                    (((theAggregationConnector).rr.thePatternDiagramNode =
                      right[]) or
                     ((right.currentDecomposDiagram <> none ) and
                      ((theAggregationConnector).rr.thePatternDiagramNode =
                       (right.currentDecomposDiagram).titleNode[]))) then
                        (if right.currentDecomposDiagram <> none then
                            (theAggregationConnector).rr.unmakeRegion;
                            (right.currentDecomposDiagram).titleNode[]
                              ->
                                (theAggregationConnector).rr.
                                  thePatternDiagramNode;
                            (right.currentDecomposDiagram).titleNode[]
                              ->(theAggregationConnector).rr.createRegion;
                            (right.currentDecomposDiagram).titleNode.geometry
                              ->(x,y,w,h);
                            (theDiagram = right.currentDecomposDiagram)
                              ->makeInvisible
                         else
                            (theAggregationConnector).rr.unmakeRegion;
                            right[]
                              ->
                                (theAggregationConnector).rr.
                                  thePatternDiagramNode;
                            right[]->(theAggregationConnector).rr.createRegion;
                            right.geometry->(x,y,w,h);
                            (not gppProp.showAttributes) or
                            (theDiagram = right.theDiagram)->makeInvisible
                        if);
                        (x-w div 2,y)->(theAggregationConnector).rr.center
                    if);
                    (if anAST[] <> none then
                        (if anAST.symbol = betaGram.staticItem then
                            (if current.rightMulTo = 1
                            (* most likely a singular (hack FIXME) *) then
                                gppProp.byValue->kind
                             else
                                gppProp.byReference->kind
                            if)
                         else
                            gppProp.byReference->kind
                        if)
                    if);
                    (false,none ,0,none ,none ,current.leftMulFrom,
                     current.leftMulTo,current.rightMulFrom,current.rightMulTo,
                     false,none ,(theAggregationConnector).visible,false,false,
                     ((theAggregationConnector).lr.multiplicity).visible,
                     (theAggregationConnector).lr.attachRight,false,
                     ((theAggregationConnector).rr.multiplicity).visible,
                     (theAggregationConnector).rr.attachRight,kind)
                      ->(theAggregationConnector).redisplay;
                    (if not makeInvisible then
                        (if not gppProp.showAttributes then
                            (if right.currentDecomposDiagram <> none then
                                false
                                  ->(theAggregationConnector).attributesVisible
                             else
                                false->(theAggregationConnector).visible
                            if)
                         else
                            true->(theAggregationConnector).attributesVisible
                        if)
                    if)
                if)
            if)
         #)
   if);
   54->trace (#  do 'SimpleAttrDeclDisplayAggregation END'->t #)  

-- SimpleAttrDeclSetUpRelations: DoPart --
do
     (#
        anAST: ^mps.ast;
        rem: ^betaGram.remote;
        od: ^betaGram.ObjectDescriptor;
        na: ^betaGram.nameApl;
        nd: ^betaGram.nameDcl;
        thePrefix: ^betaGram.Prefix;
        attDen: ^betaGram.AttributeDenotation;
        theMainPart: ^betaGram.MainPart;
        theAttributes: ^betaGram.Attributes;
        theQualification: ^betaGram.AttributeDecl;
        prefixName,otherPrefixName: ^text;
        embedAssociation: ^betaGram.SimpleDecl;
        leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer;
        foundAssocOrAggr: @boolean
     do
        (53,54)
          ->trace2
            (# 
            do
               'SimpleAttrDeclSetupRelations on "%s"'
                 ->t.putformat
                   (# help: @text do theText.get->help; help[]->s #)
            #);
        (if theObjectSpec.symbol
         // betaGram.ObjectDescriptor then
            (53,54)->trace2 (#  do 'It was an ObjectDescriptor'->t #);
            (if theObjectSpec.frag.father->ischecked then
                theObjectDescriptor[]->od[];
                findAssocOrAggr:
                  (# 
                  do
                     od.getPrefixOpt->anAST[];
                     (if anAST.kind = mps.kinds.interior then
                         anAST[]->thePrefix[];
                         thePrefix.getAttributeDenotation->attDen[];
                         (if attDen.symbol = betaGram.NameApl then
                             attDen[]->na[];
                             na.getText->prefixName[];
                             (if
                             (prefixName[]
                                ->patterndiagrams.utils.isContainerName) or
                             (prefixName[]
                                ->patterndiagrams.utils.isEmbedAssociationName)
                              then
                                 theObjectDescriptor.getMainPart->theMainPart[];
                                 theMainPart.getAttributes->theAttributes[];
                                 theAttributes.newScan
                                   (#
                                      theFinalDecl: ^betaGram.FinalDecl;
                                      os: ^betaGram.ObjectSpecification;
                                      na: ^betaGram.NameApl;
                                      theRemote: ^betaGram.remote;
                                      theNames: ^betaGram.Names;
                                      theNameDcl: ^betaGram.NameDcl;
                                      t: ^text
                                   do
                                      (if current.symbol = betaGram.FinalDecl
                                       then
                                          current[]->theFinalDecl[];
                                          theFinalDecl.getNames->theNames[];
                                          theNames.getSon1->theNameDcl[];
                                          theNameDcl.getText->t[];
                                          (if 'element'->t.equalNCS then
                                              theFinalDecl.
                                                getObjectSpecification->os[];
                                              (if os.symbol
                                               // betaGram.NameApl then
                                                  os[]->na[];
                                                  ((na.dclRef).father).father
                                                    ->theQualification[];
                                                  
                                               // betaGram.Remote then
                                                  os[]->theRemote[];
                                                  theRemote.getNameApl->na[];
                                                  ((na.dclRef).father).father
                                                    ->theQualification[]
                                              if)
                                          if)
                                      if)
                                   #);
                                 (if theQualification[] <> none then
                                     (if
                                     prefixName[]
                                       ->patterndiagrams.utils.isContainerName
                                      then
                                         ((theObjectDescriptor.father).father,
                                          theQualification[],1,1,- 1,- 1)
                                           ->
                                             patterndiagrams.AggregationList.
                                               insert;
                                         true->foundAssocOrAggr
                                      else
                                         theQualification[]
                                           ->private.getEmbedAssociation
                                           ->
                                             (embedAssociation[],
                                              otherPrefixName[]);
                                         (if embedAssociation[] <> none then
                                             (prefixName[],otherPrefixName[])
                                               ->
                                                 patterndiagrams.utils.
                                                   getEmbedAssMul
                                               ->
                                                 (leftMulFrom,leftMulTo,
                                                  rightMulFrom,rightMulTo);
                                             ((theObjectDescriptor.father).
                                              father,embedAssociation[],
                                              leftMulFrom,leftMulTo,
                                              rightMulFrom,rightMulTo,none )
                                               ->
                                                 patterndiagrams.AssociationList
                                                 .insert;
                                             true->foundAssocOrAggr
                                         if)
                                     if)
                                 if)
                              else
                                 od[]->getPrefix->od[];
                                 (if od[] <> none then
                                     restart findAssocOrAggr
                                 if)
                             if);
                             
                         if)
                     if)
                  #);
                (if not foundAssocOrAggr (* it is a singular *) then
                    ((theObjectDescriptor.father).father,
                     (theObjectDescriptor.father).father,1,1,1,1)
                      ->patterndiagrams.AggregationList.insert
                if)
            if)
         // betaGram.NameApl then
            (53,54)->trace2 (#  do 'It was a NameApl'->t #);
            (if theObjectSpec.frag.father->ischecked
             // true then
                theObjectSpec[]->na[];
                (if (theReferenceSpec.symbol = betaGram.DynamicItem) or
                (theReferenceSpec.symbol = betaGram.StaticItem) then
                    na.dclRef->nd[];
                    (nd.father).father->theQualification[];
                    (if theDeclaration.symbol = betaGram.RepetitionDecl then
                        (theDeclaration[],theQualification[],1,1,- 1,- 1)
                          ->patterndiagrams.AggregationList.insert
                     else
                        (theDeclaration[],theQualification[],1,1,1,1)
                          ->patterndiagrams.AggregationList.insert
                    if)
                if)
            if)
         // betaGram.remote then
            (53,54)->trace2 (#  do 'It was a Remote'->t #);
            (if theObjectSpec.frag.father->ischecked then
                theObjectSpec[]->rem[];
                rem.getnameApl->na[];
                (if (theReferenceSpec.symbol = betaGram.DynamicItem) or
                (theReferenceSpec.symbol = betaGram.StaticItem) then
                    na.dclRef->nd[];
                    (nd.father).father->theQualification[];
                    (if theDeclaration.symbol = betaGram.RepetitionDecl then
                        (theDeclaration[],theQualification[],1,1,- 1,- 1)
                          ->patterndiagrams.AggregationList.insert
                     else
                        (theDeclaration[],theQualification[],1,1,1,1)
                          ->patterndiagrams.AggregationList.insert
                    if);
                    (*  (theDeclaration[],theQualification)
                     ->patternDiagrams.DynReferenceList.insert*)
                    
                if)
            if)
        if);
        (53,54)->trace2 (#  do 'SimpleAttrDeclSetupRelations END'->t #)
     #)  

-- SimpleAttributeDeclOnInit: DoPart --
do
   UDPrivate.UDSimpleAttributeDecl->UserDataInit;
   declTypeNode.Init;
   theAggregationConnector.init;
   theAssociationConnector.init;
   private.SimpleDeclDisplay.init;
   (if not initialisingSaved then
       gppProp.SimpleAttribute->attributeType;
       THIS(SimpleAttributeDecl)[]->attributes.append
   if);
   INNER  

-- SimpleAttributeDecldump: Descriptor --
(# 
do
   'SimpleAttributeDecl'->nodetype[];
   '********declTypeNode********'->putline;
   (if declTypeNode <> none then
       (declTypeNode).id->putint; newline
    else
       'is NONE!'->putline
   if);
   '********TheReferenceSpec********'->putline;
   (if theReferenceSpec[] <> none then
       theReferenceSpec.dump; newline
    else
       'is NONE!'->putline
   if);
   '********TheUnExpRefSpec********'->putline;
   (if theUnExpRefSpec[] <> none then
       theUnExpRefSpec.dump; newline
    else
       'is NONE!'->putline
   if);
   '********theAggregationConnector********'->putline;
   (if theAggregationConnector <> none then
       (theAggregationConnector).id->putint; newline
    else
       'is NONE!'->putline
   if);
   '********theAssociationConnector********'->putline;
   (if theAssociationConnector <> none then
       (theAssociationConnector).id->putint; newline
    else
       'is NONE!'->putline
   if)
#)  

-- SimpleAttibuteDeclPrivate: Descriptor --
(#
   SimpleDeclDisplay: @IntegerUserData;
   getEmbedAssociation:
     (#
        theDecl: ^betaGram.AttributeDecl;
        embedAss: ^betaGram.SimpleDecl;
        thePrefixName: ^text;
        anAST: ^mps.ast;
        theObjectDescriptor,od: ^betaGram.ObjectDescriptor;
        theMainPart: ^betaGram.MainPart;
        theAttributes: ^betaGram.Attributes
     enter theDecl[]
     do
        theDecl.getSon2->anAST[];
        (if anAST.symbol = betaGram.ObjectDescriptor then
            anAST[]->theObjectDescriptor[];
            theObjectDescriptor.getMainPart->theMainPart[];
            theMainPart.getAttributes->theAttributes[];
            theAttributes.newScan
              (#
                 theSimpleDecl: ^betaGram.SimpleDecl;
                 refSpec: ^betaGram.ReferenceSpecification;
                 os: ^betaGram.ObjectSpecification;
                 thePrefix: ^betaGram.Prefix;
                 attDen: ^betaGram.AttributeDenotation;
                 na: ^betaGram.NameApl;
                 prefixName: ^text
              do
                 (if current.symbol = betaGram.SimpleDecl then
                     current[]->theSimpleDecl[];
                     theSimpleDecl.getReferenceSpecification->refSpec[];
                     (if refSpec.symbol = betaGram.StaticItem then
                         refSpec.getSon1->os[];
                         (if os.symbol = betaGram.ObjectDescriptor then
                             os[]->theObjectDescriptor[]->od[];
                             isEmbed:
                               (# 
                               do
                                  od.getPrefixOpt->anAST[];
                                  (if anAST.kind = mps.kinds.interior then
                                      anAST[]->thePrefix[];
                                      thePrefix.getAttributeDenotation
                                        ->attDen[];
                                      (if attDen.symbol = betaGram.NameApl then
                                          attDen[]->na[];
                                          na.getText->prefixName[];
                                          (if
                                          prefixName[]
                                            ->
                                              patterndiagrams.utils.
                                                isEmbedAssociationName then
                                              theObjectDescriptor.getMainPart
                                                ->theMainPart[];
                                              theMainPart.getAttributes
                                                ->theAttributes[];
                                              theAttributes.newScan
                                                (#
                                                   theFinalDecl:
                                                     ^betaGram.FinalDecl;
                                                   os:
                                                     ^betaGram.
                                                        ObjectSpecification;
                                                   na: ^betaGram.NameApl;
                                                   theRemote: ^betaGram.remote;
                                                   theNames: ^betaGram.Names;
                                                   theNameDcl:
                                                     ^betaGram.NameDcl;
                                                   t: ^text;
                                                   theDiagramNode: ^DiagramNode
                                                do
                                                   (if current.symbol =
                                                   betaGram.FinalDecl then
                                                       current[]
                                                         ->theFinalDecl[];
                                                       theFinalDecl.getNames
                                                         ->theNames[];
                                                       theNames.getSon1
                                                         ->theNameDcl[];
                                                       theNameDcl.getText->t[];
                                                       (if
                                                       'element'->t.equalNCS
                                                        then
                                                           theFinalDecl.
                                                             getObjectSpecification
                                                             ->os[];
                                                           (if os.symbol
                                                            // betaGram.NameApl
                                                            then
                                                               os[]->na[]
                                                            // betaGram.Remote
                                                            then
                                                               os[]
                                                                 ->theRemote[];
                                                               theRemote.
                                                                 getNameApl
                                                                 ->na[]
                                                           if);
                                                           (if na[] <> none
                                                            then
                                                               (if
                                                               (
                                                               (na.dclRef).
                                                               father).father
                                                                 ->
                                                                   (
                                                                   (theDiagram).
                                                                   theParentNode
                                                                     ->
                                                                       theDiagramNode[]
                                                                   ).
                                                                   theDeclaration
                                                                   .equal then
                                                                   prefixName[]
                                                                     ->
                                                                       thePrefixname[];
                                                                   theSimpleDecl[]
                                                                     ->
                                                                       embedAss[]
                                                               if)
                                                           if)
                                                       if)
                                                   if)
                                                #)
                                           else
                                              od[]->getPrefix->od[];
                                              (if od[] <> none then
                                                  restart isEmbed
                                              if)
                                          if);
                                          
                                      if)
                                  if)
                               #)
                         if)
                     if)
                 if)
              #)
        if)
     exit (embedAss[],thePrefixName[])
     #)
#)  

-- SimpleNodeDump: Descriptor --
(#  do 'SimpleNode'->nodetype[]; INNER dump #)  

