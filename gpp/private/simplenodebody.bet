ORIGIN 'diagramattributes';
INCLUDE 'gppinterfacebody';
-- SimpleAttrDeclDisplay: Descriptor --
(#
   na: ^betaGram.nameApl;
   nd: ^betaGram.nameDcl;
   od: ^betaGram.ObjectDescriptor;
   thePrefix: ^betaGram.Prefix;
   attDen: ^betaGram.AttributeDenotation;
   theMainPart: ^betaGram.MainPart;
   theAttributes: ^betaGram.Attributes;
   found: @Boolean;
   rem: ^betaGram.remote;
   unExp: ^mps.unexpanded;
   aSlotDesc: ^mps.slotdesc;
   prefixName,otherPrefixName: ^text;
   anAST: ^MPS.AST;
   indexText: @Text;
   embedAssociation: ^betaGram.SimpleDecl;
   leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer;
   MakeSimpleDeclName:
     (#
        type: ^Text;
        indexText: @Text;
        frag: ^mps.Fragment;
        mpsAST: ^mps.AST;
        makeKind:
          (# 
          do
             (if (theDeclaration).symbol = betaGram.RepetitionDecl then
                 ': ['->t.puttext;
                 (theDeclaration).getson2->anAST[];
                 anAST.frag[]->frag[];
                 anAST[]->mpsAST[];
                 (mps[],frag[],mpsAST[],indextext[],none (*streamName[]*) ,80,0,
                  false (*abstractPresentation*) ,false (*showSemanticErrors*) ,
                  false (*includeComments*) ,false,false,false,false,'',false
                  (*onlyProperties*) ,false,false
                  (*
                   test*) )->ppFragment;
                 (1,indexText.length-3)->indexText.sub->t.puttext;
                 (if (theReferenceSpec).symbol
                  // betaGram.StaticItem then
                     '] @ '->t.puttext; 
                  // betaGram.DynamicItem then
                     '] ^ '->t.puttext; 
                  // betaGram.StaticComponent then
                     '] @| '->t.puttext; 
                  // betaGram.DynamicComponent then
                     '] ^| '->t.puttext; 
                  // betaGram.VariablePattern then
                     '] ## '->t.puttext; 
                 if)
              else
                 (if (theReferenceSpec).symbol
                  // betaGram.StaticItem then
                     ': @ '->t.puttext; 
                  // betaGram.DynamicItem then
                     ': ^ '->t.puttext; 
                  // betaGram.StaticComponent then
                     ': @| '->t.puttext; 
                  // betaGram.DynamicComponent then
                     ': ^| '->t.puttext; 
                  // betaGram.VariablePattern then
                     ': ## '->t.puttext; 
                 if)
             if)
          #);
        
     enter type[]
     do
        (if gppProp.SimpleDeclDisplay
         // gppProp.AsNameAndType then
            makeKind; type[]->t.puttext
         // gppProp.asName then
            
         // gppProp.asType then
            t.clear; makeKind; type[]->t.puttext; 
         // gppProp.asNameAndKind then
            makeKind; 
        if);
        
     #);
   getEmbedAssociation:
     (#
        theDecl: ^betaGram.AttributeDecl;
        embedAss: ^betaGram.SimpleDecl;
        thePrefixName: ^text;
        anAST: ^mps.ast;
        theObjectDescriptor: ^betaGram.ObjectDescriptor;
        theMainPart: ^betaGram.MainPart;
        theAttributes: ^betaGram.Attributes
     enter theDecl[]
     do
        theDecl.getSon2->anAST[];
        (if anAST.symbol = betaGram.ObjectDescriptor then
            anAST[]->theObjectDescriptor[];
            theObjectDescriptor.getMainPart->theMainPart[];
            theMainPart.getAttributes->theAttributes[];
            theAttributes.newScan
              (#
                 theSimpleDecl: ^betaGram.SimpleDecl;
                 refSpec: ^betaGram.ReferenceSpecification;
                 os: ^betaGram.ObjectSpecification;
                 thePrefix: ^betaGram.Prefix;
                 attDen: ^betaGram.AttributeDenotation;
                 na: ^betaGram.NameApl;
                 prefixName: ^text
              do
                 (if current.symbol = betaGram.SimpleDecl then
                     current[]->theSimpleDecl[];
                     theSimpleDecl.getReferenceSpecification->refSpec[];
                     (if refSpec.symbol = betaGram.StaticItem then
                         refSpec.getSon1->os[];
                         (if os.symbol = betaGram.ObjectDescriptor then
                             os[]->theObjectDescriptor[];
                             theObjectDescriptor.getPrefixOpt->anAST[];
                             (if anAST.kind = mps.kinds.interior then
                                 anAST[]->thePrefix[];
                                 thePrefix.getAttributeDenotation->attDen[];
                                 (if attDen.symbol = betaGram.NameApl then
                                     attDen[]->na[];
                                     na.getText->prefixName[];
                                     (if
                                     prefixName[]
                                       ->
                                         patternDiagrams.utils.
                                           isEmbedAssociationName then
                                         prefixName[]->thePrefixname[];
                                         theSimpleDecl[]->embedAss[]
                                     if);
                                     
                                 if)
                             if)
                         if)
                     if)
                 if)
              #)
        if)
     exit (embedAss[],thePrefixName[])
     #);
   
do
(* theObjectSpec is either an unExpanded or
 *                         an ObjectSpecification or 
 *                         an AttributeDenotation
 *)
   (if theObjectSpec[]
    // none then
       (if switch[70] // true then 'No ObjectSpec.'->putline if);
       (if theUnExpRefSpec <> none then
           (if (theDeclaration).symbol = betaGram.RepetitionDecl then
               ': ['->t.puttext;
               (theDeclaration).getson2->anAST[];
               (mps[],anAST.frag[],anAST[],indextext[],none (*streamName[]*) ,
                80,0,false (*abstractPresentation*) ,false
                (*showSemanticErrors*) ,false (*includeComments*) ,false,false,
                false,false,'',false (*onlyProperties*) ,false,false
                (*
                 test*) )->ppFragment;
               (1,indexText.length-3)->indexText.sub->t.puttext;
               '] '->t.puttext;
               (theUnExpRefSpec).nonTerminalSymbol->betaGram.symbolToName
                 ->makeNonTerminalSymbol->t.append
            else
               ': '->t.append;
               (theUnExpRefSpec).nonTerminalSymbol->betaGram.symbolToName
                 ->makeNonTerminalSymbol->t.append
           if)
       if);
       
    else
       (if theObjectSpec.kind
        // mps.kinds.unExpanded then
           theObjectSpec[]->unExp[];
           (if unExp.isSlot
            // true then
               (mps[],unExp.frag[],unExp[],indextext[],none (*streamName[]*) ,
                80,0,false (*abstractPresentation*) ,false
                (*showSemanticErrors*) ,false (*includeComments*) ,false,false,
                false,false,'',false (*onlyProperties*) ,false,false
                (*
                 test*) )->ppFragment;
               (1,indexText.length-3)->indexText.sub->MakeSimpleDeclName;
               (*  unExp.theSlot->aSlotDesc[];
                (if aSlotDesc.category
                // betaGram.Attributes then
                'AttributeDecl'->MakeSimpleDeclName; 
                // betaGram.ObjectDescriptor then
                'ObjectDescriptor'->MakeSimpleDeclName; 
                else
                'Other category: '->t.puttext; aSlotDesc.category->t.putint; 
                if);*)
               
            else
               unExp.nonTerminalSymbol->betaGram.symbolToName
                 ->makeNonTerminalSymbol->MakeSimpleDeclName
           if);
           
        // mps.kinds.interior then
           (if theObjectSpec.symbol
            // betaGram.ObjectDescriptor then
            (* it was an ObjectSpecification *) (* try the prefix, if any *)
               theObjectSpec[]->theObjectDescriptor;
               (if CheckForAttributes
                // true then (*gppProp.AbstractedStyle -> theText.style;*)
                   ' ...'->MakeSimpleDeclName; 
               if);
               (if theObjectSpec.frag.father->ischecked then
                   (theObjectDescriptor).getPrefixOpt->anAST[];
                   (if anAST.kind = mps.kinds.interior then
                       anAST[]->thePrefix[];
                       thePrefix.getAttributeDenotation->attDen[];
                       (if attDen.symbol = betaGram.NameApl then
                           attDen[]->na[];
                           na.getText->prefixName[];
                           (if
                           (prefixName[]->patternDiagrams.utils.isContainerName)
                           or
                           (prefixName[]
                              ->patternDiagrams.utils.isEmbedAssociationName)
                            then
                               (theObjectDescriptor).getMainPart->theMainPart[];
                               theMainPart.getAttributes->theAttributes[];
                               theAttributes.newScan
                                 (#
                                    theFinalDecl: ^betaGram.FinalDecl;
                                    os: ^betaGram.ObjectSpecification;
                                    na: ^betaGram.NameApl;
                                    theRemote: ^betaGram.remote;
                                    theNames: ^betaGram.Names;
                                    theNameDcl: ^betaGram.NameDcl;
                                    t: ^text
                                 do
                                    (if current.symbol = betaGram.FinalDecl then
                                        current[]->theFinalDecl[];
                                        theFinalDecl.getNames->theNames[];
                                        theNames.getSon1->theNameDcl[];
                                        theNameDcl.getText->t[];
                                        (if 'element'->t.equalNCS then
                                            theFinalDecl.getObjectSpecification
                                              ->os[];
                                            (if os.symbol
                                             // betaGram.NameApl then
                                                os[]->na[];
                                                ((na.dclRef).father).father
                                                  ->theQualification;
                                                
                                             // betaGram.Remote then
                                                os[]->theRemote[];
                                                theRemote.getNameApl->na[];
                                                ((na.dclRef).father).father
                                                  ->theQualification
                                            if)
                                        if)
                                    if)
                                 #);
                               (if theQualification <> none then
                                   (if
                                   prefixName[]
                                     ->patternDiagrams.utils.isContainerName
                                    then
                                       (((theObjectDescriptor).father).father,
                                        theQualification,1,1,- 1,- 1)
                                         ->
                                           patternDiagrams.AggregationList.
                                             insert
                                    else
                                       theQualification->getEmbedAssociation
                                         ->
                                           (embedAssociation[],
                                            otherPrefixName[]);
                                       (if embedAssociation[] <> none then
                                           (prefixName[],otherPrefixName[])
                                             ->
                                               patternDiagrams.utils.
                                                 getEmbedAssMul
                                             ->
                                               (leftMulFrom,leftMulTo,
                                                rightMulFrom,rightMulTo);
                                           (((theObjectDescriptor).father).
                                            father,embedAssociation[],
                                            leftMulFrom,leftMulTo,rightMulFrom,
                                            rightMulTo,none )
                                             ->
                                               patternDiagrams.AssociationList.
                                                 insert
                                       if)
                                   if)
                               if)
                           if);
                           
                       if)
                   if)
               if);
               
            else
           (* it is an AttributeDenotation *)
           (* try find the descriptor *)
               (if theObjectSpec.symbol
                // betaGram.NameApl then
                   theObjectSpec[]->na[];
                   na.getNameAppl->anAST[];
                   (if anAST.kind = mps.kinds.unExpanded then
                       '<<NameAppl>>'->MakeSimpleDeclName
                    else
                       na.gettext->MakeSimpleDeclName
                   if);
                   (if theObjectSpec.frag.father->ischecked
                    // true then
                       theObjectSpec[]->na[];
                       (if ((theReferenceSpec).symbol = betaGram.DynamicItem) or
                       ((theReferenceSpec).symbol = betaGram.StaticItem) then
                           na.dclRef->nd[];
                           (nd.father).father->theQualification;
                           (if (theDeclaration).symbol = betaGram.RepetitionDecl
                            then
                               (theDeclaration,theQualification,1,1,-1,-1)
                                 ->patternDiagrams.AggregationList.insert
                            else
                               (theDeclaration,theQualification,1,1,1,1)
                                 ->patternDiagrams.AggregationList.insert
                           if)
                       if)
                   if);
                   
                // betaGram.remote then
                   theObjectSpec[]->makeRemote->MakeSimpleDeclName;
                   (if theObjectSpec.frag.father->ischecked
                    // true then
                       theObjectSpec[]->rem[];
                       rem.getnameApl->na[];
                       (if ((theReferenceSpec).symbol = betaGram.DynamicItem) or
                       ((theReferenceSpec).symbol = betaGram.StaticItem) then
                           na.dclRef->nd[];
                           (nd.father).father->theQualification;
                           (if (theDeclaration).symbol = betaGram.RepetitionDecl
                            then
                               (theDeclaration,theQualification,1,1,-1,-1)
                                 ->patternDiagrams.AggregationList.insert
                            else
                               (theDeclaration,theQualification,1,1,1,1)
                                 ->patternDiagrams.AggregationList.insert
                           if);
                           (*  (theDeclaration,theQualification)
                            ->patternDiagrams.DynReferenceList.insert*)
                           
                       if)
                   if);
                   
                else
                   'DISPLAY another type '->puttext;
                   theObjectSpec.symbol->putint;
                   newline;
                   
               if);
               
           if)
        // mps.kinds.optional then
           'display: mps.kinds.optional'->putline; 
        // mps.kinds.SlotDesc then
           'display: mps.kinds.SlotDesc'->putline; 
        else
           'display: mps.kinds other'->putline; 
       if);
       
   if);
   (* DisplayReference *)
   
#)  

-- SimpleAttrDeclRedisplay: Descriptor --
(#
   na: ^betaGram.nameApl;
   nd: ^betaGram.nameDcl;
   found: @Boolean;
   rem: ^betaGram.remote;
   unExp: ^mps.unexpanded;
   os: ^betaGram.ObjectSpecification;
   aSlotDesc: ^mps.slotdesc;
   anAST: ^MPS.AST;
   indexText: @Text;
   MakeSimpleDeclName:
     (#
        type: ^Text;
        indexText: @Text;
        frag: ^mps.Fragment;
        mpsAST: ^mps.AST;
        makeKind:
          (# 
          do
             (if (theDeclaration).symbol = betaGram.RepetitionDecl then
                 ': ['->t.puttext;
                 (theDeclaration).getson2->anAST[];
                 anAST.frag[]->frag[];
                 anAST[]->mpsAST[];
                 (mps[],frag[],mpsAST[],indextext[],none (*streamName[]*) ,80,0,
                  false (*abstractPresentation*) ,false (*showSemanticErrors*) ,
                  false (*includeComments*) ,false,false,false,false,'',false
                  (*onlyProperties*) ,false,false
                  (*
                   test*) )->ppFragment;
                 (1,indexText.length-3)->indexText.sub->t.puttext;
                 (if (theReferenceSpec).symbol
                  // betaGram.StaticItem then
                     '] @ '->t.puttext; 
                  // betaGram.DynamicItem then
                     '] ^ '->t.puttext; 
                  // betaGram.StaticComponent then
                     '] @| '->t.puttext; 
                  // betaGram.DynamicComponent then
                     '] ^| '->t.puttext; 
                  // betaGram.VariablePattern then
                     '] ## '->t.puttext; 
                 if)
              else
                 (if (theReferenceSpec).symbol
                  // betaGram.StaticItem then
                     ': @ '->t.puttext; 
                  // betaGram.DynamicItem then
                     ': ^ '->t.puttext; 
                  // betaGram.StaticComponent then
                     ': @| '->t.puttext; 
                  // betaGram.DynamicComponent then
                     ': ^| '->t.puttext; 
                  // betaGram.VariablePattern then
                     ': ## '->t.puttext; 
                 if)
             if)
          #);
        
     enter type[]
     do
        (if gppProp.SimpleDeclDisplay
         // gppProp.AsNameAndType then
            makeKind; type[]->t.puttext
         // gppProp.asName then
            
         // gppProp.asType then
            t.clear; makeKind; type[]->t.puttext; 
         // gppProp.asNameAndKind then
            makeKind; 
        if);
        
     #);
   
do
(* theObjectSpec is either an unExpanded or
 *                         an ObjectSpecification or 
 *                         an AttributeDenotation
 *)
   (if theObjectSpec[]
    // none then
       (if switch[70] // true then 'No ObjectSpec.'->putline if);
       (if theUnExpRefSpec <> none then
           (if (theDeclaration).symbol = betaGram.RepetitionDecl then
               ': ['->t.puttext;
               (theDeclaration).getson2->anAST[];
               (mps[],anAST.frag[],anAST[],indextext[],none (*streamName[]*) ,
                80,0,false (*abstractPresentation*) ,false
                (*showSemanticErrors*) ,false (*includeComments*) ,false,false,
                false,false,'',false (*onlyProperties*) ,false,false
                (*
                 test*) )->ppFragment;
               (1,indexText.length-3)->indexText.sub->t.puttext;
               '] '->t.puttext;
               (theUnExpRefSpec).nonTerminalSymbol->betaGram.symbolToName
                 ->makeNonTerminalSymbol->t.append
            else
               ': '->t.append;
               (theUnExpRefSpec).nonTerminalSymbol->betaGram.symbolToName
                 ->makeNonTerminalSymbol->t.append
           if)
       if);
       
    else
       (if theObjectSpec.kind
        // mps.kinds.unExpanded then
           theObjectSpec[]->unExp[];
           (if unExp.isSlot
            // true then
               (mps[],unExp.frag[],unExp[],indextext[],none (*streamName[]*) ,
                80,0,false (*abstractPresentation*) ,false
                (*showSemanticErrors*) ,false (*includeComments*) ,false,false,
                false,false,'',false (*onlyProperties*) ,false,false
                (*
                 test*) )->ppFragment;
               (1,indexText.length-3)->indexText.sub->MakeSimpleDeclName;
               (*  unExp.theSlot->aSlotDesc[];
                (if aSlotDesc.category
                // betaGram.Attributes then
                'AttributeDecl'->MakeSimpleDeclName; 
                // betaGram.ObjectDescriptor then
                'ObjectDescriptor'->MakeSimpleDeclName; 
                else
                'Other category: '->t.puttext; aSlotDesc.category->t.putint; 
                if);*)
               
            else
               unExp.nonTerminalSymbol->betaGram.symbolToName
                 ->makeNonTerminalSymbol->MakeSimpleDeclName
           if);
           
        // mps.kinds.interior then
           (if theObjectSpec.symbol
            // betaGram.ObjectDescriptor then
            (* it was an ObjectSpecification *) (* try the prefix, if any *)
               theObjectSpec[]->theObjectDescriptor;
               (if CheckForAttributes
                // true then (*gppProp.AbstractedStyle -> theText.style;*)
                   ' ...'->MakeSimpleDeclName; 
               if);
               
            else
           (* it is an AttributeDenotation *)
           (* try find the descriptor *)
               none ->theObjectDescriptor;
               (if theObjectSpec.symbol
                // betaGram.NameApl then
                   theObjectSpec[]->na[];
                   na.getNameAppl->anAST[];
                   (if anAST.kind = mps.kinds.unExpanded then
                       '<<NameAppl>>'->MakeSimpleDeclName
                    else
                       na.gettext->MakeSimpleDeclName
                   if);
                   (if theObjectSpec.frag.father->ischecked
                    // true then
                       theObjectSpec[]->na[];
                       (if ((theReferenceSpec).symbol = betaGram.DynamicItem) or
                       ((theReferenceSpec).symbol = betaGram.DynamicComponent)
                        then
                           na.dclRef->nd[]; (nd.father).father->theQualification
                       if)
                   if);
                   
                // betaGram.remote then
                   theObjectSpec[]->makeRemote->MakeSimpleDeclName;
                   (if theObjectSpec.frag.father->ischecked
                    // true then
                       theObjectSpec[]->rem[];
                       rem.getnameApl->na[];
                       (if ((theReferenceSpec).symbol = betaGram.DynamicItem) or
                       ((theReferenceSpec).symbol = betaGram.DynamicComponent)
                        then
                           na.dclRef->nd[]; (nd.father).father->theQualification
                       if)
                   if);
                   
                else
                   'DISPLAY another type '->puttext;
                   theObjectSpec.symbol->putint;
                   newline;
                   
               if);
               
           if)
        // mps.kinds.optional then
           'display: mps.kinds.optional'->putline; 
        // mps.kinds.SlotDesc then
           'display: mps.kinds.SlotDesc'->putline; 
        else
           'display: mps.kinds other'->putline; 
       if);
       
   if)
#)  

-- SimpleNodeDisplayReference: Descriptor --
(# 
do
   (if switch[53] or switch[54] then
       'SimpleNodeDisplayReference'->putline
   if);
   patternDiagrams.AssociationList.find
     (#
        predicate:: 
          (# 
          do
             (((theDeclaration).index = current.left) and
              ((theDeclaration).frag.fullname->current.leftFrag.equal)) or
             (((theDeclaration).index = current.right) and
              ((theDeclaration).frag.fullname->current.rightFrag.equal))->value
          #);
        NotFound::  (#  do displayAggregation #);
        ff: ^mps.fragmentForm;
        con: ^AssociationConnector;
        leftRole,rightRole: ^AssociationConnector.Role;
        rightAggRole,leftAggRole: ^DesignObject;
        left,right: ^SimpleNode;
        associationNode: ^PatternNode;
        theNames: ^betaGram.Names;
        anAST: ^mps.ast;
        theNameDcl: ^betaGram.NameDcl;
        theName,leftName,rightName: ^Text;
        x,y,w,h,lx,ly,rx,ry: @integer;
        l: ^UserDataLabelNode
     do
        (if (theDeclaration).index = current.left then
            current.rightFrag[]->topDotOpen->ff[];
            current.right->ff.indexToNode->AstToNode->right[];
            THIS(SimpleNode)[]->left[]
         else
            current.leftFrag[]->topDotOpen->ff[];
            current.left->ff.indexToNode->AstToNode->left[];
            THIS(SimpleNode)[]->right[]
        if);
        (if (current.associationFrag[] <> none ) and
        (current.associationPattern <> 0) then
            current.associationFrag[]->topDotOpen->ff[];
            current.associationPattern->ff.indexToNode->AstToNode
              ->associationNode[]
        if);
        (if associationNode[] <> none then
            (associationNode.theDeclaration).getSon1->theNames[];
            theNames.getSon1->anAST[];
            (if anAST.kind <> mps.kinds.unExpanded then
                anAST[]->theNameDcl[]; theNameDcl.getText->theName[]
            if)
        if);
        (if (left[] <> none ) and (right[] <> none ) then
            (left.theDeclaration).getSon1->theNames[];
            theNames.getSon1->anAST[];
            (if anAST.kind <> mps.kinds.unExpanded then
                anAST[]->theNameDcl[]; theNameDcl.getText->leftName[]
            if);
            (right.theDeclaration).getSon1->theNames[];
            theNames.getSon1->anAST[];
            (if anAST.kind <> mps.kinds.unExpanded then
                anAST[]->theNameDcl[]; theNameDcl.getText->rightName[]
            if);
            (* to prevent onInit from generating code *)
            (* make assignment here to make rightRole.display
             know it's the right role!
             make assignment again below after con.new so that
             it is persistent! *)
            (if theAssociationConnector = none then
                (if left.theAggregationConnector <> none then
                    (left.theAggregationConnector).leftRole->leftAggRole[];
                    (left.theAggregationConnector).rightRole->rightAggRole[];
                    leftAggRole.delete;
                    rightAggRole.delete;
                    none ->left.theAggregationConnector
                if);
                (if right.theAggregationConnector <> none then
                    (right.theAggregationConnector).leftRole->leftAggRole[];
                    (right.theAggregationConnector).rightRole->rightAggRole[];
                    leftAggRole.delete;
                    rightAggRole.delete;
                    none ->right.theAggregationConnector
                if);
                &AssociationConnector[]->con[];
                true->con.initialisingSaved;
                &con.Role[]->leftRole[];
                (rightName[],current.leftMulFrom,current.leftMulTo,left[])
                  ->leftRole.display;
                leftRole[]->con.leftRole;
                &con.Role[]->rightRole[];
                (leftName[],current.rightMulFrom,current.rightMulTo,right[])
                  ->rightRole.display;
                (leftRole[],rightRole[])->con.new;
                con[]->left.theAssociationConnector
                  ->right.theAssociationConnector;
                leftRole[]->con.leftRole;
                rightRole[]->con.rightRole;
                (if theName[] <> none then
                    (con.leftRole->con.lr[]).center->(lx,ly);
                    (con.rightRole->con.rr[]).center->(rx,ry);
                    &UserDataLabelNode[]->l[];
                    (lx+((rx-lx) div 2),ly+((ry-ly) div 2),10,10,theName)
                      ->l.new;
                    textStyle.italic->l.theText.style;
                    l.fitToText;
                    (lx+((rx-lx) div 2),ly+((ry-ly) div 2)-10)->l.move;
                    con[]->l.createRegion;
                    l[]->con.name
                if);
                (if associationNode[] <> none then
                    associationNode[]->con.associationNode
                 else
                    true->con.embed
                if);
                (if not gppProp.associations then false->con.visible if);
                (if not gppProp.showAttributes then
                    false->con.attributesVisible
                if)
             else
                (if left.theAggregationConnector <> none then
                    (left.theAggregationConnector).leftRole->leftAggRole[];
                    (left.theAggregationConnector).rightRole->rightAggRole[];
                    leftAggRole.delete;
                    rightAggRole.delete;
                    none ->left.theAggregationConnector
                if);
                (if right.theAggregationConnector <> none then
                    (right.theAggregationConnector).leftRole->leftAggRole[];
                    (right.theAggregationConnector).rightRole->rightAggRole[];
                    leftAggRole.delete;
                    rightAggRole.delete;
                    none ->right.theAggregationConnector
                if);
                (if ((theAssociationConnector).leftrole->(theAssociationConnector).lr[]).thePatternDiagramNode
                <> left[] then
                    ((theAssociationConnector).leftrole->(theAssociationConnector).lr[]).unmakeRegion;
                    left[]
                      ->
                        ((theAssociationConnector).leftrole->(theAssociationConnector).lr[]).
                        thePatternDiagramNode;
                    left[]->((theAssociationConnector).leftrole->(theAssociationConnector).lr[]).createRegion;
                    left.geometry->(x,y,w,h);
                    (x-w div 2,y)->((theAggregationConnector).leftrole->(theAggregationConnector).lr[]).center
                if);
                (if ((theAssociationConnector).rightrole->(theAssociationConnector).rr[]).thePatternDiagramNode
                <> right[] then
                    ((theAssociationConnector).rightrole->(theAssociationConnector).rr[]).unmakeRegion;
                    right[]
                      ->
                        ((theAssociationConnector).rightrole->(theAssociationConnector).rr[]).
                        thePatternDiagramNode;
                    right[]->((theAssociationConnector).rightrole->(theAssociationConnector).rr[]).createRegion;
                    right.geometry->(x,y,w,h);
                    (x-w div 2,y)->((theAggregationConnector).rightrole->(theAggregationConnector).rr[]).center
                if);
                associationNode[]->(theAssociationConnector).associationNode;
                (if associationNode[] = none then
                    true->(theAssociationConnector).embed
                 else
                    false->(theAssociationConnector).embed
                if);
                (if theName[] <> none then
                    (if (theAssociationConnector).name <> none then
                        theName->((theAssociationConnector).name).theText.set;
                        textStyle.italic
                          ->((theAssociationConnector).name).theText.style
                     else
                        ((theAssociationConnector).leftrole->(theAssociationConnector).lr[]).center->(lx,ly);
                        ((theAssociationConnector).rightrole->(theAssociationConnector).rr[]).center->(rx,ry);
                        &UserDataLabelNode[]->l[];
                        (lx+((rx-lx) div 2),ly+((ry-ly) div 2),10,10,theName)
                          ->l.new;
                        textStyle.italic->l.theText.style;
                        l.fitToText;
                        (lx+((rx-lx) div 2),ly+((ry-ly) div 2)-10)->l.move;
                        theAssociationConnector->l.createRegion;
                        l[]->(theAssociationConnector).name
                    if)
                 else
                    (if (theAssociationConnector).name <> none then
                        ((theAssociationConnector).name).delete;
                        none ->(theAssociationConnector).name
                    if)
                if);
                (rightName[],current.leftMulFrom,current.leftMulTo)
                  ->((theAssociationConnector).leftrole->(theAssociationConnector).lr[]).redisplay;
                (leftName[],current.rightMulFrom,current.rightMulTo)
                  ->((theAssociationConnector).rightrole->(theAssociationConnector).rr[]).redisplay;
                (if not gppProp.associations then
                    false->(theAssociationConnector).visible
                if);
                (if not gppProp.showAttributes then
                    false->(theAssociationConnector).attributesVisible
                if)
            if)
        if)
     #);
   
#)  

-- SimpleNodeDoubleClick: Descriptor --
(# old: @Integer; 
do
   false->IndicateSelection;
   (if switch[30] // true then 'SimpleDeclaration'->putline if);
   (if theObjectDescriptor <> none
    // true then detail
    else
       (if gppProp.ReferenceEdges
        // false then
           (if declTypeNode <> none
            // true then
               (declTypeNode).LineThickNess->old;
               4->(declTypeNode).LineThickNess;
               (declTypeNode).Redraw;
               old->(declTypeNode).LineThickNess;
               (declTypeNode).Redraw;
               
            else
               (if switch[30]
                // true then 'SimpleNode: no declTypeNode'->putline
               if)
           if)
       if)
   if)
#)  

-- SimpleNodeDisplay: Descriptor --
(# theSimpleDecl: ^betaGram.SimpleDecl; anAST: ^MPS.AST
do
   theDeclaration->theSimpleDecl[];
   theSimpleDecl.GetReferenceSpecification->anAST[];
   (if anAST## <= betaGram.referenceSpecification## then
       anAst[]->theReferenceSpec; (theReferenceSpec).getson1->theObjectSpec[]
    else
       (if anAST.kind = mps.kinds.unExpanded then anAST[]->theUnExpRefSpec if)
   if);
   theSimpleDecl->SetRegionType;
   INNER Display;
   
#)  

-- SimpleNodeRedisplay: Descriptor --
(# theSimpleDecl: ^betaGram.SimpleDecl; anAST: ^MPS.AST
do
   theDeclaration->theSimpleDecl[];
   theSimpleDecl.GetReferenceSpecification->anAST[];
   (if anAST## <= betaGram.referenceSpecification## then
       anAst[]->theReferenceSpec; (theReferenceSpec).getson1->theObjectSpec[]
    else
       (if anAST.kind = mps.kinds.unExpanded then anAST[]->theUnExpRefSpec if)
   if);
   theSimpleDecl->SetRegionType;
   INNER ReDisplay;
   
#)  

-- RepetitionNodeDoubleClick: Descriptor --
(# 
do
   false->IndicateSelection;
   (if theObjectDescriptor <> none // true then detail if)
#)  

-- RepetitionNodeDisplay: Descriptor --
(# theRepDecl: ^betaGram.RepetitionDecl; anAST: ^MPS.AST; 
do
   theDeclaration->theRepDecl[];
   (* cast *)
   theRepDecl.GetReferenceSpecification->anAST[];
   (if anAST## <= betaGram.referenceSpecification## then
       anAst[]->theReferenceSpec; (theReferenceSpec).getson1->theObjectSpec[]
    else
       (if anAST.kind = mps.kinds.unExpanded then anAST[]->theUnExpRefSpec if)
   if);
   theRepDecl->SetRegionType;
   INNER Display;
   
#)  

-- RepetitionNodeRedisplay: Descriptor --
(# theRepDecl: ^betaGram.RepetitionDecl; anAST: ^MPS.AST; 
do
   theDeclaration->theRepDecl[];
   (* cast *)
   theRepDecl.GetReferenceSpecification->anAST[];
   (if anAST## <= betaGram.referenceSpecification## then
       anAst[]->theReferenceSpec; (theReferenceSpec).getson1->theObjectSpec[]
    else
       (if anAST.kind = mps.kinds.unExpanded then anAST[]->theUnExpRefSpec if)
   if);
   theRepDecl->SetRegionType;
   INNER Redisplay;
   
#)  

-- RepetitionNodeDisplayReference: DoPart --
do displayAggregation  

-- SimpleAttrDeclDisplayAggregation: DoPart --
do
   (if ((theReferenceSpec).symbol = betaGram.DynamicItem) or
   ((theReferenceSpec).symbol = betaGram.StaticItem) then
       patternDiagrams.AggregationList.find
         (#
            predicate:: 
              (# 
              do
                 ((theDeclaration).index = current.left) and
                 ((theDeclaration).frag.fullname->current.leftFrag.equal)->value
              #);
            ff: ^mps.fragmentForm;
            right: ^PatternNode;
            con: ^AggregationConnector;
            leftRole,rightRole: ^AggregationConnector.Role;
            leftAssRole,rightAssRole: ^DesignObject;
            theSimpleNode: ^SimpleNode;
            anAST: ^mps.ast;
            theNames: ^betaGram.Names;
            theNameDcl: ^betaGram.NameDcl;
            x,y,w,h: @integer;
            makeInvisible,doShow: @boolean
         do
            current.rightFrag[]->topDotOpen->ff[];
            current.right->ff.indexToNode->AstToNode->right[];
            (if right[] <> none then
                (if theObjectDescriptor = none then
                    (if (theDeclaration).symbol = betaGram.SimpleDecl then
                        (theDeclaration).getSon2->anAST[]
                     else
                        (if (theDeclaration).symbol = betaGram.RepetitionDecl
                         then
                            (theDeclaration).getSon3->anAST[]
                        if)
                    if)
                if);
                (if theAggregationConnector = none then
                    (if theAssociationConnector <> none then
                        (if
                        ((theAssociationConnector).leftrole->(theAssociationConnector).lr[]).
                        thePatternDiagramNode = THIS(SimpleAttributeDecl)[] then
                            ((theAssociationConnector).rightrole->(theAssociationConnector).rr[]).
                            thePatternDiagramNode->theSimpleNode[]
                         else
                            ((theAssociationConnector).leftrole->(theAssociationConnector).lr[]).
                            thePatternDiagramNode->theSimpleNode[]
                        if);
                        none ->theSimpleNode.theAssociationConnector;
                        (theAssociationConnector).leftRole->leftAssRole[];
                        (theAssociationConnector).rightRole->rightAssRole[];
                        leftAssRole.delete;
                        rightAssRole.delete;
                        none ->theAssociationConnector
                    if);
                    &AggregationConnector[]->con[];
                    true->con.initialisingSaved;
                    (if anAST[] <> none then
                        (if anAST.symbol = betaGram.staticItem then
                            gppProp.byValue->con.private.kind
                        if)
                    if);
                    &con.Role[]->leftRole[];
                    (none ,current.leftMulFrom,current.leftMulTo,THIS(
                     SimpleAttributeDecl)[])->leftRole.display;
                    leftRole[]->con.leftRole;
                    &con.Role[]->rightRole[];
                    (if right.currentDecomposDiagram <> none then
                        (none ,current.rightMulFrom,current.rightMulTo,
                         (right.currentDecomposDiagram).titleNode[])
                          ->rightRole.display;
                        (theDiagram = right.currentDecomposDiagram)
                          ->makeInvisible
                     else
                        (none ,current.rightMulFrom,current.rightMulTo,right[])
                          ->rightRole.display;
                        (not gppProp.showAttributes) or
                        (theDiagram = right.theDiagram)->makeInvisible
                    if);
                    (leftRole[],rightRole[])->con.new;
                    leftRole[]->con.leftRole;
                    rightRole[]->con.rightRole;
                    con[]->theAggregationConnector;
                    (if (not gppProp.references) or makeinvisible then
                        false->con.visible
                    if);
                    (if not makeInvisible then
                        (if not gppProp.showAttributes then
                            (if right.currentDecomposDiagram <> none then
                                false->con.attributesVisible
                             else
                                false->con.visible
                            if)
                        if)
                    if)
                 else
                    (if theAssociationConnector <> none then
                        (if
                        ((theAssociationConnector).leftrole->(theAssociationConnector).lr[]).
                        thePatternDiagramNode = THIS(SimpleAttributeDecl)[] then
                            ((theAssociationConnector).rightrole->(theAssociationConnector).rr[]).
                            thePatternDiagramNode->theSimpleNode[]
                         else
                            ((theAssociationConnector).leftrole->(theAssociationConnector).lr[]).
                            thePatternDiagramNode->theSimpleNode[]
                        if);
                        none ->theSimpleNode.theAssociationConnector;
                        (theAssociationConnector).leftRole->leftAssRole[];
                        (theAssociationConnector).rightRole->rightAssRole[];
                        leftAssRole.delete;
                        rightAssRole.delete;
                        none ->theAssociationConnector
                    if);
                    (if not
                    ((((theAggregationConnector).rightrole->(theAggregationConnector).rr[]).
                      thePatternDiagramNode = right[]) or
                     ((right.currentDecomposDiagram <> none ) and
                      (((theAggregationConnector).rightrole->(theAggregationConnector).rr[]).
                       thePatternDiagramNode =
                       (right.currentDecomposDiagram).titleNode[]))) then
                        (if right.currentDecomposDiagram <> none then
                            ((theAggregationConnector).rightrole->(theAggregationConnector).rr[]).unmakeRegion;
                            (right.currentDecomposDiagram).titleNode[]
                              ->
                                ((theAggregationConnector).rightrole->(theAggregationConnector).rr[]).
                                thePatternDiagramNode;
                            (right.currentDecomposDiagram).titleNode[]
                              ->
                                ((theAggregationConnector).rightrole->(theAggregationConnector).rr[]).
                                createRegion;
                            (right.currentDecomposDiagram).titleNode.geometry
                              ->(x,y,w,h);
                            (theDiagram = right.currentDecomposDiagram)
                              ->makeInvisible
                         else
                            ((theAggregationConnector).rightrole->(theAggregationConnector).rr[]).unmakeRegion;
                            right[]
                              ->
                                ((theAggregationConnector).rightrole->(theAggregationConnector).rr[]).
                                thePatternDiagramNode;
                            right[]
                              ->
                                ((theAggregationConnector).rightrole->(theAggregationConnector).rr[]).
                                createRegion;
                            right.geometry->(x,y,w,h);
                            (not gppProp.showAttributes) or
                            (theDiagram = right.theDiagram)->makeInvisible
                        if);
                        (x-w div 2,y)
                          ->((theAggregationConnector).rightrole->(theAggregationConnector).rr[]).center
                    if);
                    (if anAST[] <> none then
                        (if anAST.symbol = betaGram.staticItem then
                            gppProp.byValue
                              ->(theAggregationConnector).private.kind
                         else
                            gppProp.byReference
                              ->(theAggregationConnector).private.kind
                        if)
                     else
                        gppProp.byReference
                          ->(theAggregationConnector).private.kind
                    if);
                    (none ,current.leftMulFrom,current.leftMulTo)
                      ->((theAggregationConnector).leftrole->(theAggregationConnector).lr[]).redisplay;
                    (none ,current.rightMulFrom,current.rightMulTo)
                      ->((theAggregationConnector).rightrole->(theAggregationConnector).rr[]).redisplay;
                    (if (not gppProp.references) or makeInvisible then
                        false->(theAggregationConnector).visible
                     else
                        true->(theAggregationConnector).visible
                    if);
                    (if not makeInvisible then
                        (if not gppProp.showAttributes then
                            (if right.currentDecomposDiagram <> none then
                                false
                                  ->(theAggregationConnector).attributesVisible
                             else
                                false->(theAggregationConnector).visible
                            if)
                         else
                            true->(theAggregationConnector).attributesVisible
                        if)
                    if)
                if)
            if)
         #)
   if)  

-- SimpleAttributeDecldump: Descriptor --
(# 
do
   '********declTypeNode********'->putline;
   (if declTypeNode <> none then
       (declTypeNode).id->putint; newline
    else
       'is NONE!'->putline
   if);
   '********TheReferenceSpec********'->putline;
   (if theReferenceSpec <> none then
       (theReferenceSpec).dump; newline
    else
       'is NONE!'->putline
   if);
   '********TheUnExpRefSpec********'->putline;
   (if theUnExpRefSpec <> none then
       (theUnExpRefSpec).dump; newline
    else
       'is NONE!'->putline
   if);
   '********TheQualification********'->putline;
   (if theQualification <> none then
       (theQualification).dump; newline
    else
       'is NONE!'->putline
   if);
   '********theAggregationConnector********'->putline;
   (if theAggregationConnector <> none then
       (theAggregationConnector).id->putint; newline
    else
       'is NONE!'->putline
   if);
   '********theAssociationConnector********'->putline;
   (if theAssociationConnector <> none then
       (theAssociationConnector).id->putint; newline
    else
       'is NONE!'->putline
   if)
#)  

-- SimpleNodeDump: Descriptor --
(#  do INNER dump #)  

