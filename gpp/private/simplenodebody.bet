ORIGIN 'diagramattributes';
-- SimpleAttrDeclDisplay: DescriptorForm --
(#
   od: ^betaGram.ObjectDescriptor;
   na: ^betaGram.nameApl;
   found: @Boolean;
   rem: ^betaGram.remote;
   unExp: ^unExpanded;
   os: ^betaGram.ObjectSpecification;
   aSlotDesc: ^SlotDesc;
   anAST: ^AST;
   makeRemote:
     (#
        anAST: ^AST;
        rem: ^betaGram.remote;
        unExp: ^unExpanded;
        na: ^betaGram.nameApl;
        t: ^text
     enter anAST[]
     do
        &Text[]->t[];
        anAST[]->rem[];
        rem.getAttributeDenotation->anAST[];
        (if anAST.kind = kinds.unExpanded then
            anAST[]->unExp[];
            unExp.NonTerminalSymbol->betaGram.symbolToName
              ->makeNonTerminalSymbol->t.append;
            '.'->t.append
         else
            (if anAST.symbol
             // betaGram.NameApl then
                anAST[]->na[];
                na.getNameAppl->anAST[];
                (if anAST.kind = kinds.unExpanded then
                    '<NameAppl>.'->t.append
                 else
                    na.gettext->t.append; '.'->t.append
                if)
             // betaGram.Remote then
                anAST[]->makeRemote->t.append; '.'->t.append
            if)
        if);
        rem.getNameApl->na[];
        na.getNameAppl->anAST[];
        (if anAST.kind = kinds.unExpanded then
            '<NameAppl>'->t.append
         else
            na.gettext->t.append
        if)
     exit t[]
     #);
   MakeSimpleDeclName:
     (# (* t is the NameDecl *) type: ^Text; (* the NameAppl *)
     enter type[]
     do
        (if gppProp.SimpleDeclDisplay
         // gppProp.AsBetaSyntax then
            (if (theReferenceSpec).symbol
             // betaGram.StaticItem then
                ':  @  '->t.puttext;
             // betaGram.DynamicItem then
                ': ^ '->t.puttext;
             // betaGram.StaticComponent then
                ':  @|  '->t.puttext;
             // betaGram.DynamicComponent then
                ':  ^|  '->t.puttext;
            if);
            type[]->t.puttext
         // gppProp.AsNameAndType then
            (if (theReferenceSpec).symbol
             // betaGram.StaticItem then
                ':  Part  '->t.puttext;
             // betaGram.DynamicItem then
                ':  Ref  '->t.puttext;
             // betaGram.StaticComponent then
                ':  Process  '->t.puttext;
             // betaGram.DynamicComponent then
                ':  Ref Process  '->t.puttext;
            if);
            type[]->t.puttext;
         // gppProp.asName then
            ':'->t.put; (* add : to name *)
         // gppProp.asType then
            type->t; (* just the type *)
         // gppProp.asTypeAndKind then
            (if (theReferenceSpec).symbol
             // betaGram.StaticItem then
                ':  Part  '->t.puttext;
             // betaGram.DynamicItem then
                ':  Ref  '->t.puttext;
             // betaGram.StaticComponent then
                ':  Process  '->t.puttext;
             // betaGram.DynamicComponent then
                ':  Ref Process  '->t.puttext;
            if);
            type[]->t.puttext;
        if);
     #);
do
(* theObjectSpec is either an unExpanded or
 *                         an ObjectSpecification or 
 *                         an AttributeDenotation
 *)
   (if theObjectSpec[]
    // none then
       (if switch[1] // true then 'No ObjectSpec.'->putline if);
       (if theUnExpRefSpec <> none then
           ': '->t.append;
           (theUnExpRefSpec).nonTerminalSymbol->betaGram.symbolToName
             ->makeNonTerminalSymbol->t.append
       if);
    else
       (if theObjectSpec.kind
        // kinds.unExpanded then
           theObjectSpec[]->unExp[];
           (if unExp.isSlot
            // true then
               unExp.theSlot->aSlotDesc[];
               (if aSlotDesc.category
                // betaGram.Attributes then
                   'AttributeDecl'->MakeSimpleDeclName;
                // betaGram.ObjectDescriptor then
                   'ObjectDescriptor'->MakeSimpleDeclName;
                else
                   'Other category: '->t.puttext; aSlotDesc.category->t.putint;
               if);
            else
               unExp.nonTerminalSymbol->betaGram.symbolToName
                 ->makeNonTerminalSymbol->MakeSimpleDeclName
           if);
        // kinds.interior then
           (if theObjectSpec.symbol
            // betaGram.ObjectDescriptor then
            (* it was an ObjectSpecification *) (* try the prefix, if any *)
               theObjectSpec[]->theObjectDescriptor;
               (if theObjectSpec.frag.father->ischecked
                // true then theObjectDescriptor->GetPrefix->od[];
               if);
               (* mark as something is inside; just like a PatternDecl *)
               (if CheckForAttributes
                // true then (*gppProp.AbstractedStyle -> theText.style;*)
                   ' ...'->MakeSimpleDeclName;
               if);
            else
           (* it is an AttributeDenotation *)
           (* try find the descriptor *)
               (if theObjectSpec.symbol
                // betaGram.NameApl then
                   theObjectSpec[]->na[];
                   na.getNameAppl->anAST[];
                   (if anAST.kind = kinds.unExpanded then
                       '<<NameAppl>>'->MakeSimpleDeclName
                    else
                       na.gettext->MakeSimpleDeclName
                   if);
                   (if theObjectSpec.frag.father->ischecked
                    // true then
                       theObjectSpec[]->na[];
                       (if na.descRef <> none
                        // true then
                           theObjectSpec[]->os[]; os.findDescriptor->od[];
                       if)
                   if);
                // betaGram.remote then
                   theObjectSpec[]->makeRemote->MakeSimpleDeclName;
                   (if theObjectSpec.frag.father->ischecked
                    // true then
                       theObjectSpec[]->rem[];
                       rem.getnameApl->na[];
                       (if na.descref <> none
                        // true then
                           theObjectSpec[]->os[]; os.findDescriptor->od[];
                       if)
                   if);
                else
                   'DISPLAY another type '->puttext;
                   theObjectSpec.symbol->putint;
                   newline;
               if);
           if);
           (if false then
               (if od[] <> none
                // true then
                (* if od is declared in the same block then
                 * make a ReferenceConnector between the descriptor and the 
                 * SimpleDecl
                 *)
                   scanner: localNodes.scan
                     (# con: @ReferenceConnector; dummy: ^PatternNode;
                     do
                        (if Current.struc <= PatternNode##
                         // true then
                            Current[]->dummy[];
                            (if od[]->dummy.EqualDescriptor
                             // true then
                                (if gppProp.ReferenceEdges
                                 // true then
                                    (THIS(SimpleAttributeDecl)[],Current[])
                                      ->con.treeNew;
                                    (* was new *)
                                    true->found;
                                 else
                                (* don't show the declaration by arrow, but save
                                 * the RectNode and save that for hiliting later
                                 *)
                                    Current[]->declTypeNode;
                                if);
                                leave scanner;
                            if);
                        if);
                     #);
                   (if found
                    // false then
                       (if theObjectSpec.symbol
                        // betaGram.NameApl then
                           theObjectSpec[]->na[];
                           na.gettext->MakeSimpleDeclName;
                       if);
                   if);
                else
                   (if theObjectSpec.symbol
                    // betaGram.NameApl then
                       theObjectSpec[]->na[];
                       na.getNameAppl->anAST[];
                       (if anAST.kind = kinds.unExpanded then
                           '<NameAppl>'->MakeSimpleDeclName
                        else
                           na.gettext->MakeSimpleDeclName
                       if);
                    // betaGram.Remote then
                       theObjectSpec[]->makeRemote->MakeSimpleDeclName
                   if);
               if)
           if)
        // kinds.optional then
           'display: kinds.optional'->putline;
        // kinds.SlotDesc then
           'display: kinds.SlotDesc'->putline;
        else
           'display: kinds other'->putline;
       if);
   if)
#)  

-- SimpleAttrDeclRedisplay: DescriptorForm --
(#
   od: ^betaGram.ObjectDescriptor;
   na: ^betaGram.nameApl;
   found: @Boolean;
   rem: ^betaGram.remote;
   unExp: ^unExpanded;
   os: ^betaGram.ObjectSpecification;
   aSlotDesc: ^SlotDesc;
   anAST: ^AST;
   makeRemote:
     (#
        anAST: ^AST;
        rem: ^betaGram.remote;
        unExp: ^unExpanded;
        na: ^betaGram.nameApl;
        t: ^text
     enter anAST[]
     do
        &Text[]->t[];
        anAST[]->rem[];
        rem.getAttributeDenotation->anAST[];
        (if anAST.kind = kinds.unExpanded then
            anAST[]->unExp[];
            unExp.NonTerminalSymbol->betaGram.symbolToName
              ->makeNonTerminalSymbol->t.append;
            '.'->t.append
         else
            (if anAST.symbol
             // betaGram.NameApl then
                anAST[]->na[];
                na.getNameAppl->anAST[];
                (if anAST.kind = kinds.unExpanded then
                    '<NameAppl>.'->t.append
                 else
                    na.gettext->t.append; '.'->t.append
                if)
             // betaGram.Remote then
                anAST[]->makeRemote->t.append; '.'->t.append
            if)
        if);
        rem.getNameApl->na[];
        na.getNameAppl->anAST[];
        (if anAST.kind = kinds.unExpanded then
            '<NameAppl>'->t.append
         else
            na.gettext->t.append
        if)
     exit t[]
     #);
   MakeSimpleDeclName:
     (# (* t is the NameDecl *) type: ^Text; (* the NameAppl *)
     enter type[]
     do
        (if gppProp.SimpleDeclDisplay
         // gppProp.AsBetaSyntax then
            (if (theReferenceSpec).symbol
             // betaGram.StaticItem then
                ':  @  '->t.puttext;
             // betaGram.DynamicItem then
                ': ^ '->t.puttext;
             // betaGram.StaticComponent then
                ':  @|  '->t.puttext;
             // betaGram.DynamicComponent then
                ':  ^|  '->t.puttext;
            if);
            type[]->t.puttext
         // gppProp.AsNameAndType then
            (if (theReferenceSpec).symbol
             // betaGram.StaticItem then
                ':  Part  '->t.puttext;
             // betaGram.DynamicItem then
                ':  Ref  '->t.puttext;
             // betaGram.StaticComponent then
                ':  Process  '->t.puttext;
             // betaGram.DynamicComponent then
                ':  Ref Process  '->t.puttext;
            if);
            type[]->t.puttext;
         // gppProp.asName then
            ':'->t.put; (* add : to name *)
         // gppProp.asType then
            type->t; (* just the type *)
         // gppProp.asTypeAndKind then
            (if (theReferenceSpec).symbol
             // betaGram.StaticItem then
                ':  Part  '->t.puttext;
             // betaGram.DynamicItem then
                ':  Ref  '->t.puttext;
             // betaGram.StaticComponent then
                ':  Process  '->t.puttext;
             // betaGram.DynamicComponent then
                ':  Ref Process  '->t.puttext;
            if);
            type[]->t.puttext;
        if);
     #);
do
(* theObjectSpec is either an unExpanded or
 *                         an ObjectSpecification or 
 *                         an AttributeDenotation
 *)
   (if theObjectSpec[]
    // none then
       (if switch[1] // true then 'No ObjectSpec.'->putline if);
       (if theUnExpRefSpec <> none then
           ': '->t.append;
           (theUnExpRefSpec).nonTerminalSymbol->betaGram.symbolToName
             ->makeNonTerminalSymbol->t.append
       if);
    else
       (if theObjectSpec.kind
        // kinds.unExpanded then
           theObjectSpec[]->unExp[];
           (if unExp.isSlot
            // true then
               unExp.theSlot->aSlotDesc[];
               (if aSlotDesc.category
                // betaGram.Attributes then
                   'AttributeDecl'->MakeSimpleDeclName;
                // betaGram.ObjectDescriptor then
                   'ObjectDescriptor'->MakeSimpleDeclName;
                else
                   'Other category: '->t.puttext; aSlotDesc.category->t.putint;
               if);
            else
               unExp.nonTerminalSymbol->betaGram.symbolToName
                 ->makeNonTerminalSymbol->MakeSimpleDeclName
           if);
        // kinds.interior then
           (if theObjectSpec.symbol
            // betaGram.ObjectDescriptor then
            (* it was an ObjectSpecification *) (* try the prefix, if any *)
               theObjectSpec[]->theObjectDescriptor;
               (if theObjectSpec.frag.father->ischecked
                // true then theObjectDescriptor->GetPrefix->od[];
               if);
               (* mark as something is inside; just like a PatternDecl *)
               (if CheckForAttributes
                // true then (*gppProp.AbstractedStyle -> theText.style;*)
                   ' ...'->MakeSimpleDeclName;
               if);
            else
           (* it is an AttributeDenotation *)
           (* try find the descriptor *)
               (if theObjectSpec.symbol
                // betaGram.NameApl then
                   theObjectSpec[]->na[];
                   na.getNameAppl->anAST[];
                   (if anAST.kind = kinds.unExpanded then
                       '<<NameAppl>>'->MakeSimpleDeclName
                    else
                       na.gettext->MakeSimpleDeclName
                   if);
                   (if theObjectSpec.frag.father->ischecked
                    // true then
                       theObjectSpec[]->na[];
                       (if na.descRef <> none
                        // true then
                           theObjectSpec[]->os[]; os.findDescriptor->od[];
                       if)
                   if);
                // betaGram.remote then
                   theObjectSpec[]->makeRemote->MakeSimpleDeclName;
                   (if theObjectSpec.frag.father->ischecked
                    // true then
                       theObjectSpec[]->rem[];
                       rem.getnameApl->na[];
                       (if na.descref <> none
                        // true then
                           theObjectSpec[]->os[]; os.findDescriptor->od[];
                       if)
                   if);
                else
                   'DISPLAY another type '->puttext;
                   theObjectSpec.symbol->putint;
                   newline;
               if);
           if);
           (if false then
               (if od[] <> none
                // true then
                (* if od is declared in the same block then
                 * make a ReferenceConnector between the descriptor and the 
                 * SimpleDecl
                 *)
                   scanner: localNodes.scan
                     (# con: @ReferenceConnector; dummy: ^PatternNode;
                     do
                        (if Current.struc <= PatternNode##
                         // true then
                            Current[]->dummy[];
                            (if od[]->dummy.EqualDescriptor
                             // true then
                                (if gppProp.ReferenceEdges
                                 // true then
                                    (THIS(SimpleAttributeDecl)[],Current[])
                                      ->con.treeNew;
                                    (* was new *)
                                    true->found;
                                 else
                                (* don't show the declaration by arrow, but save
                                 * the RectNode and save that for hiliting later
                                 *)
                                    Current[]->declTypeNode;
                                if);
                                leave scanner;
                            if);
                        if);
                     #);
                   (if found
                    // false then
                       (if theObjectSpec.symbol
                        // betaGram.NameApl then
                           theObjectSpec[]->na[];
                           na.gettext->MakeSimpleDeclName;
                       if);
                   if);
                else
                   (if theObjectSpec.symbol
                    // betaGram.NameApl then
                       theObjectSpec[]->na[];
                       na.getNameAppl->anAST[];
                       (if anAST.kind = kinds.unExpanded then
                           '<NameAppl>'->MakeSimpleDeclName
                        else
                           na.gettext->MakeSimpleDeclName
                       if);
                    // betaGram.Remote then
                       theObjectSpec[]->makeRemote->MakeSimpleDeclName
                   if);
               if)
           if)
        // kinds.optional then
           'display: kinds.optional'->putline;
        // kinds.SlotDesc then
           'display: kinds.SlotDesc'->putline;
        else
           'display: kinds other'->putline;
       if);
   if)
#)  

-- SimpleNodeDoubleClick: DescriptorForm --
(# old: @Integer;
do
   false->IndicateSelection;
   (if switch[1] // true then 'SimpleDeclaration'->putline if);
   (if theObjectDescriptor <> none
    // true then detail
    else
       (if gppProp.ReferenceEdges
        // false then
           (if declTypeNode <> none
            // true then
               (declTypeNode).LineThickNess->old;
               4->(declTypeNode).LineThickNess;
               (declTypeNode).Redraw;
               old->(declTypeNode).LineThickNess;
               (declTypeNode).Redraw;
            else
               (if switch[1]
                // true then 'SimpleNode: no declTypeNode'->putline
               if)
           if)
       if)
   if)
#)  

-- SimpleNodeDisplay: DescriptorForm --
(# theSimpleDecl: ^betaGram.SimpleDecl; anAST: ^AST
do
   theDeclaration->theSimpleDecl[];
   theSimpleDecl.GetReferenceSpecification->anAST[];
   (if anAST## <= betaGram.referenceSpecification## then
       anAst[]->theReferenceSpec; (theReferenceSpec).getson1->theObjectSpec[]
    else
       (if anAST.kind = kinds.unExpanded then anAST[]->theUnExpRefSpec if)
   if);
   theSimpleDecl->SetRegionType;
   INNER Display;
#)  

-- SimpleNodeRedisplay: DescriptorForm --
(# theSimpleDecl: ^betaGram.SimpleDecl; anAST: ^AST
do
   theDeclaration->theSimpleDecl[];
   theSimpleDecl.GetReferenceSpecification->anAST[];
   (if anAST## <= betaGram.referenceSpecification## then
       anAst[]->theReferenceSpec; (theReferenceSpec).getson1->theObjectSpec[]
    else
       (if anAST.kind = kinds.unExpanded then anAST[]->theUnExpRefSpec if)
   if);
   theSimpleDecl->SetRegionType;
   INNER ReDisplay;
#)  

-- RepetitionNodeDoubleClick: DescriptorForm --
(#
do
   false->IndicateSelection;
   (if theObjectDescriptor <> none // true then detail if)
#)  

-- RepetitionNodeDisplay: DescriptorForm --
(# theRepDecl: ^betaGram.RepetitionDecl;
do
   theDeclaration->theRepDecl[];
   (* cast *)
   theRepDecl.GetReferenceSpecification->theReferenceSpec;
   (theReferenceSpec).getson1->theObjectSpec[];
   theRepDecl->SetRegionType;
   INNER Display;
#)  

-- SimpleAttributeDecldump: DescriptorForm --
(#
do
   '********TheReferenceSpec********'->putline;
   (if theReferenceSpec <> none then
       (theReferenceSpec).dump; newline
    else
       'is NONE!'->putline
   if)
#)  

