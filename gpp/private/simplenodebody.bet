ORIGIN 'diagramattributes';
-- SimpleAttrDeclDisplay: Descriptor --
(#
   na: ^betaGram.nameApl;
   nd: ^betaGram.nameDcl;
   found: @Boolean;
   rem: ^betaGram.remote;
   unExp: ^mps.unexpanded;
   aSlotDesc: ^mps.slotdesc;
   anAST: ^MPS.AST;
   indexText: @Text;
   MakeSimpleDeclName:
     (# (* t is the NameDecl *)
        type: ^Text;
        indexText: @Text;
        frag: ^mps.Fragment;
        mpsAST: ^mps.AST;
        makeKind:
          (# 
          do
             (if (theDeclaration).symbol = betaGram.RepetitionDecl then
                 ': ['->t.puttext;
                 (theDeclaration).getson2->anAST[];
                 anAST.frag[]->frag[];
                 anAST[]->mpsAST[];
                 (mps[],frag[],mpsAST[],indextext[],none (*streamName[]*) ,80,0,
                  false (*abstractPresentation*) ,false (*showSemanticErrors*) ,
                  false (*includeComments*) ,false,false,false,false,'',false
                  (*onlyProperties*) ,false
                  (*
                   test*) )->ppFragment;
                 (1,indexText.length-3)->indexText.sub->t.puttext;
                 (if (theReferenceSpec).symbol
                  // betaGram.StaticItem then
                     '] @ '->t.puttext; 
                  // betaGram.DynamicItem then
                     '] ^ '->t.puttext; 
                  // betaGram.StaticComponent then
                     '] @| '->t.puttext; 
                  // betaGram.DynamicComponent then
                     '] ^| '->t.puttext; 
                  // betaGram.VariablePattern then
                     '] ## '->t.puttext; 
                 if)
              else
                 (if (theReferenceSpec).symbol
                  // betaGram.StaticItem then
                     ': @ '->t.puttext; 
                  // betaGram.DynamicItem then
                     ': ^ '->t.puttext; 
                  // betaGram.StaticComponent then
                     ': @| '->t.puttext; 
                  // betaGram.DynamicComponent then
                     ': ^| '->t.puttext; 
                  // betaGram.VariablePattern then
                     ': ## '->t.puttext; 
                 if)
             if)
          #);
        
     enter type[]
     do
        (if gppProp.SimpleDeclDisplay
         // gppProp.AsNameAndType then
            makeKind; type[]->t.puttext
         // gppProp.asName then
            
         // gppProp.asType then
            t.clear; makeKind; type[]->t.puttext; 
         // gppProp.asNameAndKind then
            makeKind; 
        if);
        
     #);
   
do
(* theObjectSpec is either an unExpanded or
 *                         an ObjectSpecification or 
 *                         an AttributeDenotation
 *)
   (if theObjectSpec[]
    // none then
       (if switch[1] // true then 'No ObjectSpec.'->putline if);
       (if theUnExpRefSpec <> none then
           (if (theDeclaration).symbol = betaGram.RepetitionDecl then
               ': ['->t.puttext;
               (theDeclaration).getson2->anAST[];
               (mps[],anAST.frag[],anAST[],indextext[],none (*streamName[]*) ,
                80,0,false (*abstractPresentation*) ,false
                (*showSemanticErrors*) ,false (*includeComments*) ,false,false,
                false,false,'',false (*onlyProperties*) ,false
                (*
                 test*) )->ppFragment;
               (1,indexText.length-3)->indexText.sub->t.puttext;
               '] '->t.puttext;
               (theUnExpRefSpec).nonTerminalSymbol->betaGram.symbolToName
                 ->makeNonTerminalSymbol->t.append
            else
               ': '->t.append;
               (theUnExpRefSpec).nonTerminalSymbol->betaGram.symbolToName
                 ->makeNonTerminalSymbol->t.append
           if)
       if);
       
    else
       (if theObjectSpec.kind
        // mps.kinds.unExpanded then
           theObjectSpec[]->unExp[];
           (if unExp.isSlot
            // true then
               unExp.theSlot->aSlotDesc[];
               (if aSlotDesc.category
                // betaGram.Attributes then
                   'AttributeDecl'->MakeSimpleDeclName; 
                // betaGram.ObjectDescriptor then
                   'ObjectDescriptor'->MakeSimpleDeclName; 
                else
                   'Other category: '->t.puttext; aSlotDesc.category->t.putint; 
               if);
               
            else
               unExp.nonTerminalSymbol->betaGram.symbolToName
                 ->makeNonTerminalSymbol->MakeSimpleDeclName
           if);
           
        // mps.kinds.interior then
           (if theObjectSpec.symbol
            // betaGram.ObjectDescriptor then
            (* it was an ObjectSpecification *) (* try the prefix, if any *)
               theObjectSpec[]->theObjectDescriptor;
               (if CheckForAttributes
                // true then (*gppProp.AbstractedStyle -> theText.style;*)
                   ' ...'->MakeSimpleDeclName; 
               if);
               
            else
           (* it is an AttributeDenotation *)
           (* try find the descriptor *)
               (if theObjectSpec.symbol
                // betaGram.NameApl then
                   theObjectSpec[]->na[];
                   na.getNameAppl->anAST[];
                   (if anAST.kind = mps.kinds.unExpanded then
                       '<<NameAppl>>'->MakeSimpleDeclName
                    else
                       na.gettext->MakeSimpleDeclName
                   if);
                   (if theObjectSpec.frag.father->ischecked
                    // true then
                       theObjectSpec[]->na[];
                       (if ((theReferenceSpec).symbol = betaGram.DynamicItem) or
                       ((theReferenceSpec).symbol = betaGram.DynamicComponent)
                        then
                           na.dclRef->nd[];
                           (nd.father).father->theQualification;
                           (theDeclaration,theQualification)
                             ->patternDiagrams.DynReferenceList.insert
                       if)
                   if);
                   
                // betaGram.remote then
                   theObjectSpec[]->makeRemote->MakeSimpleDeclName;
                   (if theObjectSpec.frag.father->ischecked
                    // true then
                       theObjectSpec[]->rem[];
                       rem.getnameApl->na[];
                       (if ((theReferenceSpec).symbol = betaGram.DynamicItem) or
                       ((theReferenceSpec).symbol = betaGram.DynamicComponent)
                        then
                           na.dclRef->nd[];
                           (nd.father).father->theQualification;
                           (theDeclaration,theQualification)
                             ->patternDiagrams.DynReferenceList.insert
                       if)
                   if);
                   
                else
                   'DISPLAY another type '->puttext;
                   theObjectSpec.symbol->putint;
                   newline;
                   
               if);
               
           if)
        // mps.kinds.optional then
           'display: mps.kinds.optional'->putline; 
        // mps.kinds.SlotDesc then
           'display: mps.kinds.SlotDesc'->putline; 
        else
           'display: mps.kinds other'->putline; 
       if);
       
   if);
   DisplayReference
#)  

-- SimpleAttrDeclRedisplay: Descriptor --
(#
   na: ^betaGram.nameApl;
   nd: ^betaGram.nameDcl;
   found: @Boolean;
   rem: ^betaGram.remote;
   unExp: ^mps.unexpanded;
   os: ^betaGram.ObjectSpecification;
   aSlotDesc: ^mps.slotdesc;
   anAST: ^MPS.AST;
   indexText: @Text;
   MakeSimpleDeclName:
     (# (* t is the NameDecl *)
        type: ^Text;
        indexText: @Text;
        frag: ^mps.Fragment;
        mpsAST: ^mps.AST;
        makeKind:
          (# 
          do
             (if (theDeclaration).symbol = betaGram.RepetitionDecl then
                 ': ['->t.puttext;
                 (theDeclaration).getson2->anAST[];
                 anAST.frag[]->frag[];
                 anAST[]->mpsAST[];
                 (mps[],frag[],mpsAST[],indextext[],none (*streamName[]*) ,80,0,
                  false (*abstractPresentation*) ,false (*showSemanticErrors*) ,
                  false (*includeComments*) ,false,false,false,false,'',false
                  (*onlyProperties*) ,false
                  (*
                   test*) )->ppFragment;
                 (1,indexText.length-3)->indexText.sub->t.puttext;
                 (if (theReferenceSpec).symbol
                  // betaGram.StaticItem then
                     '] @ '->t.puttext; 
                  // betaGram.DynamicItem then
                     '] ^ '->t.puttext; 
                  // betaGram.StaticComponent then
                     '] @| '->t.puttext; 
                  // betaGram.DynamicComponent then
                     '] ^| '->t.puttext; 
                  // betaGram.VariablePattern then
                     '] ## '->t.puttext; 
                 if)
              else
                 (if (theReferenceSpec).symbol
                  // betaGram.StaticItem then
                     ': @ '->t.puttext; 
                  // betaGram.DynamicItem then
                     ': ^ '->t.puttext; 
                  // betaGram.StaticComponent then
                     ': @| '->t.puttext; 
                  // betaGram.DynamicComponent then
                     ': ^| '->t.puttext; 
                  // betaGram.VariablePattern then
                     ': ## '->t.puttext; 
                 if)
             if)
          #);
        
     enter type[]
     do
        (if gppProp.SimpleDeclDisplay
         // gppProp.AsNameAndType then
            makeKind; type[]->t.puttext
         // gppProp.asName then
            
         // gppProp.asType then
            t.clear; makeKind; type[]->t.puttext; 
         // gppProp.asNameAndKind then
            makeKind; 
        if);
        
     #);
   
do
(* theObjectSpec is either an unExpanded or
 *                         an ObjectSpecification or 
 *                         an AttributeDenotation
 *)
   (if theObjectSpec[]
    // none then
       (if switch[1] // true then 'No ObjectSpec.'->putline if);
       (if theUnExpRefSpec <> none then
           (if (theDeclaration).symbol = betaGram.RepetitionDecl then
               ': ['->t.puttext;
               (theDeclaration).getson2->anAST[];
               (mps[],anAST.frag[],anAST[],indextext[],none (*streamName[]*) ,
                80,0,false (*abstractPresentation*) ,false
                (*showSemanticErrors*) ,false (*includeComments*) ,false,false,
                false,false,'',false (*onlyProperties*) ,false
                (*
                 test*) )->ppFragment;
               (1,indexText.length-3)->indexText.sub->t.puttext;
               '] '->t.puttext;
               (theUnExpRefSpec).nonTerminalSymbol->betaGram.symbolToName
                 ->makeNonTerminalSymbol->t.append
            else
               ': '->t.append;
               (theUnExpRefSpec).nonTerminalSymbol->betaGram.symbolToName
                 ->makeNonTerminalSymbol->t.append
           if)
       if);
       
    else
       (if theObjectSpec.kind
        // mps.kinds.unExpanded then
           theObjectSpec[]->unExp[];
           (if unExp.isSlot
            // true then
               unExp.theSlot->aSlotDesc[];
               (if aSlotDesc.category
                // betaGram.Attributes then
                   'AttributeDecl'->MakeSimpleDeclName; 
                // betaGram.ObjectDescriptor then
                   'ObjectDescriptor'->MakeSimpleDeclName; 
                else
                   'Other category: '->t.puttext; aSlotDesc.category->t.putint; 
               if);
               
            else
               unExp.nonTerminalSymbol->betaGram.symbolToName
                 ->makeNonTerminalSymbol->MakeSimpleDeclName
           if);
           
        // mps.kinds.interior then
           (if theObjectSpec.symbol
            // betaGram.ObjectDescriptor then
            (* it was an ObjectSpecification *) (* try the prefix, if any *)
               theObjectSpec[]->theObjectDescriptor;
               (if CheckForAttributes
                // true then (*gppProp.AbstractedStyle -> theText.style;*)
                   ' ...'->MakeSimpleDeclName; 
               if);
               
            else
           (* it is an AttributeDenotation *)
           (* try find the descriptor *)
               (if theObjectSpec.symbol
                // betaGram.NameApl then
                   theObjectSpec[]->na[];
                   na.getNameAppl->anAST[];
                   (if anAST.kind = mps.kinds.unExpanded then
                       '<<NameAppl>>'->MakeSimpleDeclName
                    else
                       na.gettext->MakeSimpleDeclName
                   if);
                   (if theObjectSpec.frag.father->ischecked
                    // true then
                       theObjectSpec[]->na[];
                       (if ((theReferenceSpec).symbol = betaGram.DynamicItem) or
                       ((theReferenceSpec).symbol = betaGram.DynamicComponent)
                        then
                           na.dclRef->nd[]; (nd.father).father->theQualification
                       if)
                   if);
                   
                // betaGram.remote then
                   theObjectSpec[]->makeRemote->MakeSimpleDeclName;
                   (if theObjectSpec.frag.father->ischecked
                    // true then
                       theObjectSpec[]->rem[];
                       rem.getnameApl->na[];
                       (if ((theReferenceSpec).symbol = betaGram.DynamicItem) or
                       ((theReferenceSpec).symbol = betaGram.DynamicComponent)
                        then
                           na.dclRef->nd[]; (nd.father).father->theQualification
                       if)
                   if);
                   
                else
                   'DISPLAY another type '->puttext;
                   theObjectSpec.symbol->putint;
                   newline;
                   
               if);
               
           if)
        // mps.kinds.optional then
           'display: mps.kinds.optional'->putline; 
        // mps.kinds.SlotDesc then
           'display: mps.kinds.SlotDesc'->putline; 
        else
           'display: mps.kinds other'->putline; 
       if);
       
   if)
#)  

-- SimpleNodeDisplayReference: Descriptor --
(#
   theObject: ^PatternDiagramNode;
   theQuaNode: ^DiagramNode;
   theConn: ^DeletableConnector;
   anAST: ^MPS.AST
do
   (if switch[1] then 'SimpleNodeDisplayReference'->putline if);
   (if theReferenceSpec <> none then
       (if ((theReferenceSpec).symbol = betaGram.DynamicItem) or
       ((theReferenceSpec).symbol = betaGram.DynamicComponent) then
           (if not patternDiagrams.DynReferenceList.empty then
               patternDiagrams.DynReferenceList.scan
                 (# ff: ^mps.fragmentform; t: @Text
                 do
                    (if ((theDeclaration).index = current.ref) and
                    ((theDeclaration).frag.fullname->current.refFrag.equal) then
                        current.qualFrag[]->topDotOpen->ff[];
                        current.qual->ff.indexToNode->AstToNode->theObject[];
                        (if theReferenceConnector = none then
                            (if theObject[] <> none then
                                theObject[]->theQuaNode[];
                                (theDeclaration).getSon2->anAST[];
                                (if anAST.symbol
                                 // betaGram.DynamicItem then
                                    &DynamicItemConnector[]->theConn[]
                                 // betaGram.DynamicComponent then
                                    &DynamicComponentConnector[]->theConn[]
                                if);
                                true->theConn.initialisingSaved;
                                (if theQuaNode.currentDecomposDiagram <> none
                                 then
                                    (if theDiagram <>
                                    theQuaNode.currentDecomposDiagram then
                                        (THIS(SimpleNode)[],
                                         (theQuaNode.currentDecomposDiagram).
                                         titleNode[])->theConn.new;
                                        (if not gppProp.references then
                                            false->theConn.BorderVisible
                                        if)
                                    if)
                                 else
                                    (if theDiagram <> theQuaNode.theDiagram then
                                        (THIS(SimpleNode)[],theQuaNode[])
                                          ->theConn.new;
                                        (if not gppProp.references then
                                            false->theConn.BorderVisible
                                        if)
                                    if)
                                if);
                                theConn[]->theReferenceConnector
                             else
                                (if switch[1] then
                                    'SimpleNodeDisplayReference: theObject is NONE'
                                      ->putline
                                if)
                            if)
                        if)
                    if)
                 #)
           if)
       if)
   if);
   (*  (if theQualification <> none then
    theQualification->AstToNode->theObject[];
    (if theObject[] <> none then
    theObject[]->theQuaNode[];
    (theDeclaration).getSon2->anAST[];
    (if anAST.symbol
    // betaGram.DynamicItem then
    &DynamicItemConnector[]->theConn[]
    // betaGram.DynamicComponent then
    &DynamicComponentConnector[]->theConn[]
    if);
    true->theConn.initialisingSaved;
    (if theQuaNode.currentDecomposDiagram <> none then
    (if theDiagram <> theQuaNode.currentDecomposDiagram then
    (THIS(SimpleNode)[],
    (theQuaNode.currentDecomposDiagram).titleNode[])->theConn.new
    if)
    else
    (if theDiagram <> theQuaNode.theDiagram then
    (THIS(SimpleNode)[],theQuaNode[])->theConn.new
    if)
    if)
    else
    (if switch[1] then
    'SimpleNodeDisplayReference: theObject is NONE'->putline
    if)
    if)
    if)*)
   
#)  

-- SimpleNodeDoubleClick: Descriptor --
(# old: @Integer; 
do
   false->IndicateSelection;
   (if switch[1] // true then 'SimpleDeclaration'->putline if);
   (if theObjectDescriptor <> none
    // true then detail
    else
       (if gppProp.ReferenceEdges
        // false then
           (if declTypeNode <> none
            // true then
               (declTypeNode).LineThickNess->old;
               4->(declTypeNode).LineThickNess;
               (declTypeNode).Redraw;
               old->(declTypeNode).LineThickNess;
               (declTypeNode).Redraw;
               
            else
               (if switch[1]
                // true then 'SimpleNode: no declTypeNode'->putline
               if)
           if)
       if)
   if)
#)  

-- SimpleNodeDisplay: Descriptor --
(# theSimpleDecl: ^betaGram.SimpleDecl; anAST: ^MPS.AST
do
   theDeclaration->theSimpleDecl[];
   theSimpleDecl.GetReferenceSpecification->anAST[];
   (if anAST## <= betaGram.referenceSpecification## then
       anAst[]->theReferenceSpec; (theReferenceSpec).getson1->theObjectSpec[]
    else
       (if anAST.kind = mps.kinds.unExpanded then anAST[]->theUnExpRefSpec if)
   if);
   theSimpleDecl->SetRegionType;
   INNER Display;
   
#)  

-- SimpleNodeRedisplay: Descriptor --
(# theSimpleDecl: ^betaGram.SimpleDecl; anAST: ^MPS.AST
do
   theDeclaration->theSimpleDecl[];
   theSimpleDecl.GetReferenceSpecification->anAST[];
   (if anAST## <= betaGram.referenceSpecification## then
       anAst[]->theReferenceSpec; (theReferenceSpec).getson1->theObjectSpec[]
    else
       (if anAST.kind = mps.kinds.unExpanded then anAST[]->theUnExpRefSpec if)
   if);
   theSimpleDecl->SetRegionType;
   INNER ReDisplay;
   
#)  

-- RepetitionNodeDoubleClick: Descriptor --
(# 
do
   false->IndicateSelection;
   (if theObjectDescriptor <> none // true then detail if)
#)  

-- RepetitionNodeDisplay: Descriptor --
(# theRepDecl: ^betaGram.RepetitionDecl; anAST: ^MPS.AST; 
do
   theDeclaration->theRepDecl[];
   (* cast *)
   theRepDecl.GetReferenceSpecification->anAST[];
   (if anAST## <= betaGram.referenceSpecification## then
       anAst[]->theReferenceSpec; (theReferenceSpec).getson1->theObjectSpec[]
    else
       (if anAST.kind = mps.kinds.unExpanded then anAST[]->theUnExpRefSpec if)
   if);
   theRepDecl->SetRegionType;
   INNER Display;
   
#)  

-- RepetitionNodeRedisplay: Descriptor --
(# theRepDecl: ^betaGram.RepetitionDecl; anAST: ^MPS.AST; 
do
   theDeclaration->theRepDecl[];
   (* cast *)
   theRepDecl.GetReferenceSpecification->anAST[];
   (if anAST## <= betaGram.referenceSpecification## then
       anAst[]->theReferenceSpec; (theReferenceSpec).getson1->theObjectSpec[]
    else
       (if anAST.kind = mps.kinds.unExpanded then anAST[]->theUnExpRefSpec if)
   if);
   theRepDecl->SetRegionType;
   INNER Redisplay;
   
#)  

-- SimpleAttributeDecldump: Descriptor --
(# 
do
   '********declTypeNode********'->putline;
   (if declTypeNode <> none then
       (declTypeNode).id->putint; newline
    else
       'is NONE!'->putline
   if);
   '********TheReferenceSpec********'->putline;
   (if theReferenceSpec <> none then
       (theReferenceSpec).dump; newline
    else
       'is NONE!'->putline
   if);
   '********TheUnExpRefSpec********'->putline;
   (if theUnExpRefSpec <> none then
       (theUnExpRefSpec).dump; newline
    else
       'is NONE!'->putline
   if);
   '********TheQualification********'->putline;
   (if theQualification <> none then
       (theQualification).dump; newline
    else
       'is NONE!'->putline
   if)
#)  

-- SimpleNodeDump: Descriptor --
(# 
do
   '********TheReferenceConnector********'->putline;
   (if theReferenceconnector <> none then
       (theReferenceConnector).ID->putInt; newline
    else
       'is NONE!'->putline
   if)
#)  

