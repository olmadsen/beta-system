ORIGIN 'diagramattributes';
LIB_ITEM 'gpp';
INCLUDE '~beta/mps/private/notificationsbody';
-- astUtilsGetEnclosingDecl: DoPart --
do
   (if anAST.father <> none then
       anAST.father->tmpAST[];
       (if not (tmpAST## <= betaGram.AttributeDecl##) then
           tmpAST[]->getEnclosingDecl->enclosingDecl[]
        else
           tmpAST[]->enclosingDecl[]
       if)
    else
       none ->enclosingDecl[]
   if)  

-- astUtilsGetPrefixName: DoPart --
do
   od.getPrefixOpt->anAST[];
   (if anAST.kind = mps.kinds.interior then
       anAST[]->thePrefix[];
       thePrefix.getAttributeDenotation->anAST[];
       (if anAST.symbol = betaGram.NameApl then
           anAST[]->theNameApl[];
           theNameApl.getNameAppl->anAST[];
           (if anAST.kind <> mps.kinds.unExpanded then
               theNameApl.getText->prefixName[]
           if)
       if)
   if)  

-- astUtilsGetPrefixNameOnDecl: DoPart --
do
   theDeclaration.getSon2->anAST[];
   (if anAST.symbol
    // betaGram.StaticItem // betaGram.StaticComponent then
       anAST[]->exp[]; exp.getSon1->anAST[]
   if);
   (if anAST.symbol = betaGram.ObjectDescriptor then
       anAST[]->getPrefixName->name[]
   if)  

-- astUtilsGetDoPart: DoPart --
do
   od.getMainPart->mp[];
   mp.getActionPart->ap[];
   ap.getDoPartOpt->anAST[];
   (if anAST.kind = mps.kinds.interior then
       anAST[]->dp[]
    else
       (if anAST.kind = mps.kinds.unExpanded then
           anAST[]->unexp[]; (if unexp.isSLOT then unexp[]->dp[] if)
       if)
   if)  

-- astUtilsGetCommentPos: DoPart --
do
   (if true
    // theDeclaration.symbol = betaGram.SimpleDecl then
       3->pos
    // theDeclaration.symbol = betaGram.PatternDecl then
       3->pos
    // theDeclaration.symbol = betaGram.VirtualDecl then
       4->pos
    // theDeclaration.symbol = betaGram.BindingDecl then
       5->pos
    // theDeclaration.symbol = betaGram.FinalDecl then
       4->pos
   if)  

-- astUtilsSkipLeadingBlanks: DoPart --
do
   newText.reset;
   true->skipLeadingBlanks;
   commentText.scanAll
     (# 
     do
        (if ch = ascii.newLine then
            newText.newLine; true->skipLeadingBlanks; 
         else
            (if skipLeadingBlanks then
                (if not (ch->ascii.isSpace) then
                    ch->newText.put; false->skipLeadingBlanks
                if)
             else
            (* skipping tabs *)
                (if (ch->ascii.isSpace) then
                    (if ch = ascii.sp then
                        ch->newText.put; 
                     else
                        ' '->newText.put
                    if)
                 else
                    ch->newText.put
                if)
            if)
        if)
     #)  

-- patternDiagramsRedisplayRelations: DoPart --
do private.redisplayRelations  

-- patternDiagramsParseDiagram: DoPart --
do private.parseDiagram  

-- AssociationListEqual: DoPart --
do
   (left.left = right.left) and (left.right = right.right) and
   (left.leftFrag[]->right.leftFrag.equal) and
   (left.rightFrag[]->right.rightFrag.equal)->value;
   (if (left.associationFrag[] = none ) or (right.associationFrag[] = none )
    then
       (left.associationFrag[] = none ) and (right.associationFrag[] = none )
       and value->value
    else
       (left.associationPattern = right.associationPattern) and
       (left.associationFrag[]->right.associationFrag.equal) and value->value
   if)  

-- AssociationListSaveEnds: DoPart --
do
   1+attributeID->attributeID;
   (id,attributeID,left)->writeIntegerUserData;
   1+attributeID->attributeID;
   (id,attributeID,right)->writeIntegerUserData;
   1+attributeID->attributeID;
   (id,attributeID,leftMulFrom)->writeIntegerUserData;
   1+attributeID->attributeID;
   (id,attributeID,leftMulTo)->writeIntegerUserData;
   1+attributeID->attributeID;
   (id,attributeID,rightMulFrom)->writeIntegerUserData;
   1+attributeID->attributeID;
   (id,attributeID,rightMulTo)->writeIntegerUserData;
   1+attributeID->attributeID;
   (id,attributeID,associationPattern)->writeIntegerUserData;
   1+attributeID->attributeID;
   (id,attributeID,leftFrag[])->writeTextUserData;
   1+attributeID->attributeID;
   (id,attributeID,rightFrag[])->writeTextUserData;
   1+attributeID->attributeID;
   (if associationFrag[] <> none then
       (id,attributeID,associationFrag[])->writeTextUserData
    else
       (id,attributeID,' ')->writeTextUserData
   if)  

-- AssociationListDumpEnds: DoPart --
do
   newline;
   'leftFrag: '->puttext;
   leftFrag[]->putline;
   'left: '->puttext;
   left->putint;
   'Multiplicities: '->puttext;
   leftMulFrom->putint;
   '..'->puttext;
   leftMulTo->putint;
   newline;
   'rightFrag: '->puttext;
   rightFrag[]->putline;
   'right: '->puttext;
   right->putint;
   ' Multiplicities: '->puttext;
   rightMulFrom->putint;
   '..'->puttext;
   rightMulTo->putint;
   newline;
   'associationFrag: '->puttext;
   (if associationFrag[] <> none then
       associationFrag[]->putline;
       'associationPattern: '->puttext;
       associationPattern->putint;
       newline
    else
       'is NONE'->putline
   if);
   newline  

-- AssociationListInsert: DoPart --
do
   &Ends[]->theElm[];
   left.index->theElm.left;
   left.frag.fullname->theElm.leftFrag[];
   right.index->theElm.right;
   right.frag.fullname->theElm.rightFrag[];
   leftMulFrom->theElm.leftMulFrom;
   leftMulTo->theElm.leftMulTo;
   rightMulFrom->theElm.rightMulFrom;
   rightMulTo->theElm.rightMulTo;
   (if associationPattern[] <> none then
       associationPattern.frag.fullname->theElm.associationFrag[];
       associationPattern.index->theElm.associationPattern
   if);
   theElm[]->THIS(Set).insert  

-- AssociationListRemove: DoPart --
do
   (if anAST.kind = mps.kinds.interior then
       (if anAST## <= betaGram.AttributeDecl## then
           scan
             (# 
             do
                (if
                ((current.left = anAST.index) and
                 (anAST.frag.fullname->current.leftFrag.equal)) or
                ((current.right = anAST.index) and
                 (anAST.frag.fullname->current.rightFrag.equal)) or
                ((current.associationPattern = anAST.index) and
                 (current.associationFrag[]->(anAST.frag.fullname).equal)) then
                    current[]->delete
                if)
             #)
       if)
   if)  

-- AssociationListUpdate: DoPart --
do
     (#
        enclosingDecl,tmpAst: ^MPS.AST;
        theNameDcl: ^betaGram.NameDcl;
        theNames: ^betaGram.Names;
        theAttributeDecl: ^betaGram.AttributeDecl;
        theObjectDescriptor: ^betaGram.ObjectDescriptor;
        theMainPart: ^betaGram.MainPart;
        theAttributes: ^betaGram.Attributes;
        oldPrefix: ^betaGram.Prefix;
        getPossibleAssociationDecl:
          (#
             anAST,NameDeclAst,enclosingDecl,tmpAst: ^mps.ast;
             theNameDcl: ^betaGram.NameDcl;
             theNameApl: ^betaGram.NameApl;
             thePatternDecl: ^betaGram.PatternDecl;
             theRefSpec: ^betaGram.ReferenceSpecification;
             theObjectDescriptor: ^betaGram.ObjectDescriptor;
             pref: ^betaGram.Prefix;
             theName: ^text;
             checkPrefix:
               (# thePrefix: ^betaGram.Prefix
               enter thePrefix[]
               do
                  thePrefix.getAttributeDenotation->tmpAst[];
                  (if tmpAst.symbol = betaGram.NameApl then
                      tmpAst[]->theNameApl[];
                      theNameApl.getNameAppl->tmpAst[];
                      (if tmpAst.kind <> mps.kinds.unExpanded then
                          theNameApl.getText->theName[];
                          (if switch[53] then
                              'getPossibleAssociationDecl - theName: '->puttext;
                              theName[]->putline
                          if);
                          (if theName[]->utils.isAssociationName then
                              enclosingDecl[]->anAST[]
                          if)
                      if);
                      
                  if)
               #)
          enter anAST[]
          do
             (if switch[53] then
                 'AssociationList getPossibleAssociationDecl: '->puttext;
                 (if anAST[] <> none then
                     anAST.index->putint; newline
                  else
                     'anAST is NONE!'->putline
                 if)
             if);
             anAST[]->theNameDcl[];
             theNameDcl.getNameDecl->NameDeclAst[];
             (if NameDeclAst.kind <> mps.kinds.unExpanded then
                 theNameDcl.getText->theName[];
                 (if ('leftType'->theName.equalNCS) or
                 ('rightType'->theName.equalNCS) or
                 ('oneType'->theName.equalNCS) or
                 ('ManyElmType'->theName.equalNCS) then
                     (if switch[53] then
                         'getPossibleAssociationDecl: recognized bindingDecl in association pattern'
                           ->putLine
                     if);
                     anAST[]->astUtils.getEnclosingDecl->enclosingDecl[];
                     (if enclosingDecl[] <> none then
                         (if switch[53] then
                             'getPossibleAssociationDecl - enclosingDecl: '
                               ->puttext;
                             enclosingDecl.index->putint;
                             newline
                         if);
                         (if enclosingDecl.symbol = betaGram.BindingDecl then
                             (if switch[53] then
                                 'getPossibleAssociationDecl: recognized BindingDecl'
                                   ->putLine
                             if);
                             enclosingDecl[]->astUtils.getEnclosingDecl
                               ->enclosingDecl[];
                             (if enclosingDecl[] <> none then
                                 (if switch[53] then
                                     'getPossibleAssociationDecl - enclosingDecl: '
                                       ->puttext;
                                     enclosingDecl.index->putint;
                                     newline
                                 if);
                                 (if enclosingDecl.symbol = betaGram.PatternDecl
                                  then
                                     (if switch[53] then
                                         'getPossibleAssociationDecl: recognized SimpleDecl'
                                           ->putLine
                                     if);
                                     (if oldPrefix[] = none
                                     (* Avoids:
                                      If prefix was changed we
                                      get new prefix because using
                                      father ref. navigates into AST
                                      containing newAST *) then
                                         enclosingDecl[]->thePatternDecl[];
                                         thePatternDecl.getObjectDescriptor
                                           ->theObjectDescriptor[];
                                         theObjectDescriptor.getPrefixOpt
                                           ->tmpAst[];
                                         (if tmpAst.kind = mps.kinds.interior
                                          then
                                             tmpAst[]->checkPrefix
                                         if)
                                      else
                                         oldPrefix[]->checkPrefix
                                     if)
                                 if)
                             if)
                         if)
                     if)
                 if)
             if)
          exit anAST[]
          #);
        doUpdate:
          (# anAST: ^mps.ast; anExp: ^mps.expanded
          enter anAST[]
          do
             (if anAST.kind = mps.kinds.interior then
                 (if anAST## <= betaGram.AttributeDecl## then
                     scan
                       (# 
                       do
                          (if (current.left = anAST.index) and
                          (anAST.frag.fullname->current.leftFrag.equal) then
                              current[]->delete
                           else
                              (if (current.right = anAST.index) and
                              (anAST.frag.fullname->current.rightFrag.equal)
                               then
                                  current[]->delete
                               else
                                  (if
                                  (current.associationPattern = anAST.index) and
                                  (anAST.frag.fullname
                                     ->current.associationFrag.equal) then
                                      current[]->delete
                                  if)
                              if)
                          if)
                       #)
                 if);
                 anAST[]->anExp[];
                 anExp.scan
                   (#  do current[]->doUpdate #)
             if)
          #)
     do
        (if gppProp.globalInteractiveMode <> gppProp.creatingAssociation then
            (if switch[53] then
                'AssociationList update: '->puttext;
                (if anAST[] <> none then
                    anAST.index->putint; newline
                 else
                    'anAST is NONE!'->putline
                if)
            if);
            (if anAST.symbol
             // betaGram.NameDcl then
                anAST[]->getPossibleAssociationDecl->anAST[]
             // betaGram.NameApl then
                anAST[]->astUtils.getEnclosingDecl->enclosingDecl[];
                (if enclosingDecl[] <> none then
                    (if enclosingDecl.symbol
                     // betaGram.BindingDecl then
                        enclosingDecl[]->theAttributeDecl[];
                        theAttributeDecl.getSon1->theNames[];
                        scanner: theNames.newScan
                          (# tmpAST: ^mps.ast
                          do
                             current[]->getPossibleAssociationDecl->tmpAST[];
                             (if not (tmpAST[]->current.equal) then
                                 tmpAST[]->anAST[]; leave scanner
                             if)
                          #)
                     // betaGram.SimpleDecl then
                        enclosingDecl[]->anAST[]
                    if)
                if)
             // betaGram.Names then
                anAST[]->theNames[];
                scanner: theNames.newScan
                  (# tmpAST: ^mps.ast
                  do
                     current[]->getPossibleAssociationDecl->tmpAST[];
                     (if not (tmpAST[]->current.equal) then
                         tmpAST[]->anAST[]; leave scanner
                     if)
                  #)
             // betaGram.Attributes then
                anAST[]->theAttributes[];
                scanner: theAttributes.newScan
                  (# 
                  do
                     (if current.symbol
                      // betaGram.BindingDecl then
                         current.getSon1->theNames[];
                         theNames.newScan
                           (# tmpAST: ^mps.ast
                           do
                              current[]->getPossibleAssociationDecl->tmpAST[];
                              (if not (tmpAST[]->current.equal) then
                                  tmpAST[]->anAST[]; leave scanner
                              if)
                           #)
                     if)
                  #)
             // betaGram.BindingDecl then
                anAST[]->theAttributeDecl[];
                theAttributeDecl.getSon1->theNames[];
                scanner: theNames.newScan
                  (# tmpAST: ^mps.ast
                  do
                     current[]->getPossibleAssociationDecl->tmpAST[];
                     (if not (tmpAST[]->current.equal) then
                         tmpAST[]->anAST[]; leave scanner
                     if)
                  #)
             // betaGram.MainPart then
                anAST[]->theMainPart[];
                theMainPart.getAttributes->theAttributes[];
                scanner: theAttributes.newScan
                  (# 
                  do
                     (if current.symbol
                      // betaGram.BindingDecl then
                         current.getSon1->theNames[];
                         theNames.newScan
                           (# tmpAST: ^mps.ast
                           do
                              current[]->getPossibleAssociationDecl->tmpAST[];
                              (if not (tmpAST[]->current.equal) then
                                  tmpAST[]->anAST[]; leave scanner
                              if)
                           #)
                     if)
                  #)
             // betaGram.Prefix then
                anAST[]->oldPrefix[];
                (if anAST.father <> none then
                    anAST.father->tmpAst[];
                    (if tmpAst.symbol = betaGram.ObjectDescriptor then
                        tmpAST[]->theObjectDescriptor[];
                        theObjectDescriptor.getMainPart->theMainPart[];
                        theMainPart.getAttributes->theAttributes[];
                        scanner: theAttributes.newScan
                          (# 
                          do
                             (if current.symbol
                              // betaGram.BindingDecl then
                                 current.getSon1->theNames[];
                                 theNames.newScan
                                   (# tmpAST: ^mps.ast
                                   do
                                      current[]->getPossibleAssociationDecl
                                        ->tmpAST[];
                                      (if not (tmpAST[]->current.equal) then
                                          tmpAST[]->anAST[]; leave scanner
                                      if)
                                   #)
                             if)
                          #)
                    if)
                if)
             // betaGram.ObjectDescriptor then
                anAST[]->theObjectDescriptor[];
                theObjectDescriptor.getPrefixOpt->tmpAST[];
                (if tmpAST.kind = mps.kinds.interior then
                    tmpAST[]->oldPrefix[];
                    theObjectDescriptor.getMainPart->theMainPart[];
                    theMainPart.getAttributes->theAttributes[];
                    scanner: theAttributes.newScan
                      (# 
                      do
                         (if current.symbol
                          // betaGram.BindingDecl then
                             current.getSon1->theNames[];
                             theNames.newScan
                               (# tmpAST: ^mps.ast
                               do
                                  current[]->getPossibleAssociationDecl
                                    ->tmpAST[];
                                  (if not (tmpAST[]->current.equal) then
                                      tmpAST[]->anAST[]; leave scanner
                                  if)
                               #)
                         if)
                      #)
                if)
             // betaGram.DynamicItem then
                anAST[]->astUtils.getEnclosingDecl->enclosingDecl[];
                (if enclosingDecl[] <> none then enclosingDecl[]->anAST[] if)
            if);
            (if switch[53] then
                'AssociationList doUpdate: '->puttext;
                (if anAST[] <> none then
                    anAST.index->putint; newline
                 else
                    'anAST is NONE!'->putline
                if)
            if);
            anAST[]->doUpdate
        if)
     #)  

-- AssociationListUpdateElement: DoPart --
do
   (if switch[53] then 'AssociationList - update element '->putline if);
   find
     (#
        predicate:: 
          (# anAST: ^mps.ast
          do
             (if associationPattern[] <> none then
                 (current.left = left.index) and
                 (left.frag.fullname->current.leftFrag.equal) and
                 (current.right = right.index) and
                 (right.frag.fullname->current.rightFrag.equal) and
                 (current.associationPattern = associationPattern.index) and
                 (associationPattern.frag.fullname
                    ->current.associationFrag.equal)->value
              else
                 (current.left = left.index) and
                 (left.frag.fullname->current.leftFrag.equal) and
                 (current.right = right.index) and
                 (right.frag.fullname->current.rightFrag.equal) and
                 (current.associationPattern = 0)->value
             if)
          #);
        notFound:: 
          (# 
          do
             (newLeft[],newRight[],leftMulFrom,leftMulTo,rightMulFrom,
              rightMulTo,newAssociationPattern[])->insert
          #)
     do
        newLeft.index->current.left;
        newLeft.frag.fullname->current.leftFrag[];
        newRight.index->current.right;
        newRight.frag.fullname->current.rightFrag[];
        leftMulFrom->current.leftMulFrom;
        leftMulTo->current.leftMulTo;
        rightMulFrom->current.rightMulFrom;
        rightMulTo->current.rightMulTo;
        (if newAssociationPattern[] <> none then
            newAssociationPattern.index->current.associationPattern;
            newAssociationPattern.frag.fullname->current.associationFrag[]
         else
            0->current.associationPattern; none ->current.associationFrag[]
        if)
     #)  

-- AssociationListSave: DoPart --
do
   resetSaved;
   size*10->noOfAttr;
   (ID,UDStart,noOfAttr)->writeIntegerUserData;
   UDStart->attributeID;
   scan
     (#  do current.save #)  

-- AssociationListResetSaved: DoPart --
do
   (ID,UDStart)->readIntegerUserData->noOfAttr;
   (for i: noOfAttr repeat (ID,UDStart+i)->deleteUserDataType for)  

-- AssociationListLoad: DoPart --
do
   (ID,UDStart)->readIntegerUserData->noOfAttr;
   UDStart->i;
   loop:
   (if i < UDStart+noOfAttr then
       &element[]->theElm[];
       (id,i+1->i)->readIntegerUserData->theElm.left;
       (id,i+1->i)->readIntegerUserData->theElm.right;
       (id,i+1->i)->readIntegerUserData->theElm.leftMulFrom;
       (id,i+1->i)->readIntegerUserData->theElm.leftMulTo;
       (id,i+1->i)->readIntegerUserData->theElm.rightMulFrom;
       (id,i+1->i)->readIntegerUserData->theElm.rightMulTo;
       (id,i+1->i)->readIntegerUserData->theElm.associationPattern;
       (id,i+1->i)->readTextUserData->theElm.leftFrag[];
       (id,i+1->i)->readTextUserData->theElm.rightFrag[];
       (id,i+1->i)->readTextUserData->theElm.associationFrag[];
       theElm[]->THIS(Set).insert;
       restart loop
   if)  

-- AssociationListDump: DoPart --
do
   newline;
   'AssociationList: '->putline;
   scan
     (#  do current.dump #);
   'AssociationList END '->putline  

-- InheritanceListSaveEnds: DoPart --
do
   1+attributeID->attributeID;
   (id,attributeID,subFrag[])->writeTextUserData;
   1+attributeID->attributeID;
   (id,attributeID,superFrag[])->writeTextUserData;
   1+attributeID->attributeID;
   (id,attributeID,sub)->writeIntegerUserData;
   1+attributeID->attributeID;
   (id,attributeID,super)->writeIntegerUserData  

-- InheritanceListEqual: DoPart --
do
   (left.sub = right.sub) and (left.subFrag[]->right.subFrag.equal) and
   (left.super = right.super) and (left.superFrag[]->right.superFrag.equal)
     ->value  

-- InheritanceListInsert: DoPart --
do
   &Ends[]->theElm[];
   subpattern.frag.fullname->theElm.subFrag[];
   subpattern.index->theElm.sub;
   superpattern.frag.fullname->theElm.superFrag[];
   superpattern.index->theElm.super;
   theElm[]->THIS(Set).insert  

-- InheritanceListRemove: DoPart --
do
   (if anAST.kind = mps.kinds.interior then
       (if anAST## <= betaGram.AttributeDecl## then
           scan
             (# 
             do
                (if (current.sub = anAST.index) and
                (anAST.frag.fullname->current.subFrag.equal) then
                    current[]->delete
                if)
             #)
       if)
   if)  

-- InheritanceListUpdate: DoPart --
do
     (#
        doUpdate:
          (# anAST: ^mps.ast; anExp: ^mps.expanded
          enter anAST[]
          do
             (if anAST.kind = mps.kinds.interior then
                 (if anAST## <= betaGram.AttributeDecl## then
                     scan
                       (# 
                       do
                          (if (current.sub = anAST.index) and
                          (anAST.frag.fullname->current.subFrag.equal) then
                              current[]->delete
                           else
                              (if (current.super = anAST.index) and
                              (anAST.frag.fullname->current.superFrag.equal)
                               then
                                  current[]->delete
                              if)
                          if)
                       #)
                 if);
                 anAST[]->anExp[];
                 anExp.scan
                   (#  do current[]->doUpdate #)
             if)
          #)
     do
        (if anAST.symbol
         // betaGram.ObjectDescriptor then
            (if anAST.father <> none then anAST.father->anAST[] if)
         // betaGram.prefix then
            (if anAST.father <> none then
                (if (anAST.father).father <> none then
                    (anAST.father).father->anAST[]
                if)
            if)
        if);
        anAST[]->doUpdate
     #)  

-- InheritanceListSave: DoPart --
do
   resetSaved;
   size*4->noOfAttr;
   (ID,UDStart,noOfAttr)->writeIntegerUserData;
   UDStart->attributeID;
   scan
     (#  do current.save #)  

-- InheritanceListResetSaved: DoPart --
do
   (ID,UDStart)->readIntegerUserData->noOfAttr;
   (for i: noOfAttr repeat (ID,UDStart+i)->deleteUserDataType for)  

-- InheritanceListLoad: DoPart --
do
   (ID,UDStart)->readIntegerUserData->noOfAttr;
   UDStart->i;
   loop:
   (if i < UDStart+noOfAttr then
       &element[]->theElm[];
       (id,i+1->i)->readTextUserData->theElm.subFrag[];
       (id,i+1->i)->readTextUserData->theElm.superFrag[];
       (id,i+1->i)->readIntegerUserData->theElm.sub;
       (id,i+1->i)->readIntegerUserData->theElm.super;
       theElm[]->THIS(Set).insert;
       restart loop
   if)  

-- InheritanceListGetSubPatternDiagrams: DoPart --
do
   &DiagramList[]->aList[];
   (if theDiagram.theParentNode <> none then
       (theDiagram.theParentNode).theDiagram->theParentListDiagram[];
       theDiagram.theParentNode->theDiagramNode[];
       theDiagramNode.theDeclaration.index->superIndex;
       theDiagramNode.theDeclaration.frag.fullname->superFrag[];
       scan
         (# 
         do
            (if (current.super = superIndex) and
            (current.superFrag[]->superFrag.equal) then
                current.subFrag[]->topDotOpen->ff[];
                current.sub->ff.indexToNode->theDecl[];
                theDecl.getSon2->anExp[];
                (if anExp## <= betaGram.StaticItem## then
                    anExp.getson1->anExp[]
                if);
                (anExp.index,current.subFrag[])->theList.findPD->theDiagram[];
                (if theDiagram[] <> none then
                    (current.sub,current.subFrag[],theDiagram[])->aList.insertPD
                if)
            if)
         #)
   if)  

-- InheritanceListGetSortableSubPatternDiagrams: DoPart --
do
   &SortableDiagramList[]->aList[];
   aList.init;
   (if theDiagram.theParentNode <> none then
       (theDiagram.theParentNode).theDiagram->theParentListDiagram[];
       theDiagram.theParentNode->theDiagramNode[];
       theDiagramNode.theDeclaration.index->superIndex;
       theDiagramNode.theDeclaration.frag.fullname->superFrag[];
       scan
         (# 
         do
            (if (current.super = superIndex) and
            (current.superFrag[]->superFrag.equal) then
                current.subFrag[]->topDotOpen->ff[];
                current.sub->ff.indexToNode->theDecl[];
                theDecl.getSon2->anExp[];
                (if anExp## <= betaGram.StaticItem## then
                    anExp.getson1->anExp[]
                if);
                (anExp.index,current.subFrag[])->theList.findPD->theDiagram[];
                (if theDiagram[] <> none then theDiagram[]->aList.insert if)
            if)
         #)
   if)  

-- InheritanceListGetSuperPatternDiagram: DoPart --
do
   (if theDiagram.theParentNode <> none then
       (theDiagram.theParentNode).theDiagram->theParentListDiagram[];
       theDiagram.theParentNode->theDiagramNode[];
       theDiagramNode.theDeclaration.index->subIndex;
       theDiagramNode.theDeclaration.frag.fullname->subFrag[];
       scan
         (# 
         do
            (if (current.sub = subIndex) and (current.subFrag[]->subFrag.equal)
             then
                current.superFrag[]->topDotOpen->ff[];
                current.super->ff.indexToNode->theDecl[];
                theDecl.getSon2->anExp[];
                (if anExp## <= betaGram.StaticItem## then
                    anExp.getson1->anExp[]
                if);
                (anExp.index,current.superFrag[])->theList.findPD
                  ->superDiagram[]
            if)
         #)
   if)  

-- InheritanceListDump: DoPart --
do
   newline;
   'InheritanceList: '->putline;
   scan
     (# 
     do
        'subFrag: '->puttext;
        current.subFrag[]->putline;
        'sub: '->puttext;
        current.sub->putint;
        newline;
        'superFrag: '->puttext;
        current.superFrag[]->putline;
        'super: '->puttext;
        current.super->putint;
        newline
     #)  

-- AggregationListEqual: DoPart --
do
   (left.left = right.left) and (left.right = right.right) and
   (left.leftFrag[]->right.leftFrag.equal) and
   (left.rightFrag[]->right.rightFrag.equal)->value  

-- AggregationListSaveEnds: DoPart --
do
   1+attributeID->attributeID;
   (id,attributeID,left)->writeIntegerUserData;
   1+attributeID->attributeID;
   (id,attributeID,right)->writeIntegerUserData;
   1+attributeID->attributeID;
   (id,attributeID,leftMulFrom)->writeIntegerUserData;
   1+attributeID->attributeID;
   (id,attributeID,leftMulTo)->writeIntegerUserData;
   1+attributeID->attributeID;
   (id,attributeID,rightMulFrom)->writeIntegerUserData;
   1+attributeID->attributeID;
   (id,attributeID,rightMulTo)->writeIntegerUserData;
   1+attributeID->attributeID;
   (id,attributeID,leftFrag[])->writeTextUserData;
   1+attributeID->attributeID;
   (id,attributeID,rightFrag[])->writeTextUserData  

-- AggregationListDumpEnds: DoPart --
do
   newline;
   'leftFrag: '->puttext;
   leftFrag[]->putline;
   'left: '->puttext;
   left->putint;
   'Multiplicities: '->puttext;
   leftMulFrom->putint;
   '..'->puttext;
   leftMulTo->putint;
   newline;
   'rightFrag: '->puttext;
   rightFrag[]->putline;
   'right: '->puttext;
   right->putint;
   ' Multiplicities: '->puttext;
   rightMulFrom->putint;
   '..'->puttext;
   rightMulTo->putint;
   newline;
   newline  

-- AggregationListInsert: DoPart --
do
   &Ends[]->theElm[];
   left.index->theElm.left;
   left.frag.fullname->theElm.leftFrag[];
   right.index->theElm.right;
   right.frag.fullname->theElm.rightFrag[];
   leftMulFrom->theElm.leftMulFrom;
   leftMulTo->theElm.leftMulTo;
   rightMulFrom->theElm.rightMulFrom;
   rightMulTo->theElm.rightMulTo;
   theElm[]->THIS(Set).insert  

-- AggregationListRemove: DoPart --
do
   (if anAST.kind = mps.kinds.interior then
       (if anAST## <= betaGram.AttributeDecl## then
           scan
             (# 
             do
                (if
                ((current.left = anAST.index) and
                 (anAST.frag.fullname->current.leftFrag.equal)) or
                ((current.right = anAST.index) and
                 (anAST.frag.fullname->current.rightFrag.equal)) then
                    current[]->delete
                if)
             #)
       if)
   if)  

-- AggregationListUpdate: DoPart --
do
     (#
        enclosingDecl,tmpAst: ^MPS.AST;
        theNameDcl: ^betaGram.NameDcl;
        theNames: ^betaGram.Names;
        theAttributeDecl: ^betaGram.AttributeDecl;
        theObjectDescriptor: ^betaGram.ObjectDescriptor;
        theMainPart: ^betaGram.MainPart;
        theAttributes: ^betaGram.Attributes;
        oldPrefix: ^betaGram.Prefix;
        getPossibleContainerDecl:
          (#
             anAST,NameDeclAst,enclosingDecl,tmpAst: ^mps.ast;
             theNameDcl: ^betaGram.NameDcl;
             theNameApl: ^betaGram.NameApl;
             theSimpleDecl: ^betaGram.SimpleDecl;
             theRefSpec: ^betaGram.ReferenceSpecification;
             theObjectDescriptor: ^betaGram.ObjectDescriptor;
             pref: ^betaGram.Prefix;
             theName: ^text;
             checkPrefix:
               (# thePrefix: ^betaGram.Prefix
               enter thePrefix[]
               do
                  thePrefix.getAttributeDenotation->tmpAst[];
                  (if tmpAst.symbol = betaGram.NameApl then
                      tmpAst[]->theNameApl[];
                      theNameApl.getNameAppl->tmpAst[];
                      (if tmpAst.kind <> mps.kinds.unExpanded then
                          theNameApl.getText->theName[];
                          (if switch[54] then
                              'getPossibleContainerDecl - theName: '->puttext;
                              theName[]->putline
                          if);
                          (if theName[]->utils.isContainerName then
                              enclosingDecl[]->anAST[]
                          if)
                      if);
                      
                  if)
               #)
          enter anAST[]
          do
             (if switch[54] then
                 'AggregationList getPossibleContainerDecl: '->puttext;
                 (if anAST[] <> none then
                     anAST.index->putint; newline
                  else
                     'anAST is NONE!'->putline
                 if)
             if);
             anAST[]->theNameDcl[];
             theNameDcl.getNameDecl->NameDeclAst[];
             (if NameDeclAst.kind <> mps.kinds.unExpanded then
                 theNameDcl.getText->theName[];
                 (if 'element'->theName.equalNCS then
                     (if switch[54] then
                         'getPossibleContainerDecl: recognized element'->putLine
                     if);
                     anAST[]->astUtils.getEnclosingDecl->enclosingDecl[];
                     (if enclosingDecl[] <> none then
                         (if switch[54] then
                             'getPossibleContainerDecl - enclosingDecl: '
                               ->puttext;
                             enclosingDecl.index->putint;
                             newline
                         if);
                         (if enclosingDecl.symbol = betaGram.FinalDecl then
                             (if switch[54] then
                                 'getPossibleContainerDecl: recognized FinalDecl'
                                   ->putLine
                             if);
                             enclosingDecl[]->astUtils.getEnclosingDecl
                               ->enclosingDecl[];
                             (if enclosingDecl[] <> none then
                                 (if switch[54] then
                                     'getPossibleContainerDecl - enclosingDecl: '
                                       ->puttext;
                                     enclosingDecl.index->putint;
                                     newline
                                 if);
                                 (if enclosingDecl.symbol = betaGram.SimpleDecl
                                  then
                                     (if switch[54] then
                                         'getPossibleContainerDecl: recognized SimpleDecl'
                                           ->putLine
                                     if);
                                     (if oldPrefix[] = none
                                     (* Avoids:
                                      If prefix was changed we
                                      get new prefix because using
                                      father ref. navigates into AST
                                      containing newAST *) then
                                         enclosingDecl[]->theSimpleDecl[];
                                         theSimpleDecl.getReferenceSpecification
                                           ->theRefSpec[];
                                         theRefSpec.getSon1
                                           ->theObjectDescriptor[];
                                         theObjectDescriptor.getPrefixOpt
                                           ->tmpAst[];
                                         (if tmpAst.kind = mps.kinds.interior
                                          then
                                             tmpAst[]->checkPrefix
                                         if)
                                      else
                                         oldPrefix[]->checkPrefix
                                     if)
                                 if)
                             if)
                         if)
                     if)
                 if)
             if)
          exit anAST[]
          #);
        doUpdate:
          (# anAST: ^mps.ast; anExp: ^mps.expanded
          enter anAST[]
          do
             (if anAST.kind = mps.kinds.interior then
                 (if anAST## <= betaGram.AttributeDecl## then
                     scan
                       (# 
                       do
                          (if (current.left = anAST.index) and
                          (anAST.frag.fullname->current.leftFrag.equal) then
                              current[]->delete
                           else
                              (if (current.right = anAST.index) and
                              (anAST.frag.fullname->current.rightFrag.equal)
                               then
                                  current[]->delete
                              if)
                          if)
                       #)
                 if);
                 anAST[]->anExp[];
                 anExp.scan
                   (#  do current[]->doUpdate #)
             if)
          #)
     do
        (if gppProp.globalInteractiveMode <> gppProp.creatingAggregation then
            (if switch[54] then
                'AggregationList update: '->puttext;
                (if anAST[] <> none then
                    anAST.index->putint; newline
                 else
                    'anAST is NONE!'->putline
                if)
            if);
            (if anAST.symbol
             // betaGram.NameDcl then
                anAST[]->getPossibleContainerDecl->anAST[]
             // betaGram.NameApl then
                anAST[]->astUtils.getEnclosingDecl->enclosingDecl[];
                (if enclosingDecl[] <> none then
                    (if enclosingDecl.symbol
                     // betaGram.FinalDecl then
                        enclosingDecl[]->theAttributeDecl[];
                        theAttributeDecl.getSon1->theNames[];
                        scanner: theNames.newScan
                          (# tmpAST: ^mps.ast
                          do
                             current[]->getPossibleContainerDecl->tmpAST[];
                             (if not (tmpAST[]->current.equal) then
                                 tmpAST[]->anAST[]; leave scanner
                             if)
                          #)
                     // betaGram.SimpleDecl then
                        enclosingDecl[]->anAST[]
                     // betaGram.RepetitionDecl then
                        enclosingDecl[]->anAST[]
                    if)
                if)
             // betaGram.Names then
                anAST[]->theNames[];
                scanner: theNames.newScan
                  (# tmpAST: ^mps.ast
                  do
                     current[]->getPossibleContainerDecl->tmpAST[];
                     (if not (tmpAST[]->current.equal) then
                         tmpAST[]->anAST[]; leave scanner
                     if)
                  #)
             // betaGram.Attributes then
                anAST[]->theAttributes[];
                scanner: theAttributes.newScan
                  (# 
                  do
                     (if current.symbol
                      // betaGram.FinalDecl then
                         current.getSon1->theNames[];
                         theNames.newScan
                           (# tmpAST: ^mps.ast
                           do
                              current[]->getPossibleContainerDecl->tmpAST[];
                              (if not (tmpAST[]->current.equal) then
                                  tmpAST[]->anAST[]; leave scanner
                              if)
                           #)
                     if)
                  #)
             // betaGram.FinalDecl then
                anAST[]->theAttributeDecl[];
                theAttributeDecl.getSon1->theNames[];
                scanner: theNames.newScan
                  (# tmpAST: ^mps.ast
                  do
                     current[]->getPossibleContainerDecl->tmpAST[];
                     (if not (tmpAST[]->current.equal) then
                         tmpAST[]->anAST[]; leave scanner
                     if)
                  #)
             // betaGram.MainPart then
                anAST[]->theMainPart[];
                theMainPart.getAttributes->theAttributes[];
                scanner: theAttributes.newScan
                  (# 
                  do
                     (if current.symbol
                      // betaGram.FinalDecl then
                         current.getSon1->theNames[];
                         theNames.newScan
                           (# tmpAST: ^mps.ast
                           do
                              current[]->getPossibleContainerDecl->tmpAST[];
                              (if not (tmpAST[]->current.equal) then
                                  tmpAST[]->anAST[]; leave scanner
                              if)
                           #)
                     if)
                  #)
             // betaGram.Prefix then
                anAST[]->oldPrefix[];
                (if anAST.father <> none then
                    anAST.father->tmpAst[];
                    (if tmpAst.symbol = betaGram.ObjectDescriptor then
                        tmpAST[]->theObjectDescriptor[];
                        theObjectDescriptor.getMainPart->theMainPart[];
                        theMainPart.getAttributes->theAttributes[];
                        scanner: theAttributes.newScan
                          (# 
                          do
                             (if current.symbol
                              // betaGram.FinalDecl then
                                 current.getSon1->theNames[];
                                 theNames.newScan
                                   (# tmpAST: ^mps.ast
                                   do
                                      current[]->getPossibleContainerDecl
                                        ->tmpAST[];
                                      (if not (tmpAST[]->current.equal) then
                                          tmpAST[]->anAST[]; leave scanner
                                      if)
                                   #)
                             if)
                          #)
                    if)
                if)
             // betaGram.ObjectDescriptor then
                anAST[]->theObjectDescriptor[];
                theObjectDescriptor.getPrefixOpt->tmpAST[];
                (if tmpAST.kind = mps.kinds.interior then
                    tmpAST[]->oldPrefix[];
                    theObjectDescriptor.getMainPart->theMainPart[];
                    theMainPart.getAttributes->theAttributes[];
                    scanner: theAttributes.newScan
                      (# 
                      do
                         (if current.symbol
                          // betaGram.FinalDecl then
                             current.getSon1->theNames[];
                             theNames.newScan
                               (# tmpAST: ^mps.ast
                               do
                                  current[]->getPossibleContainerDecl->tmpAST[];
                                  (if not (tmpAST[]->current.equal) then
                                      tmpAST[]->anAST[]; leave scanner
                                  if)
                               #)
                         if)
                      #)
                if)
             // betaGram.StaticItem // betaGram.DynamicItem then
                anAST[]->astUtils.getEnclosingDecl->enclosingDecl[];
                (if enclosingDecl[] <> none then enclosingDecl[]->anAST[] if)
            if);
            (if switch[54] then
                'AggregationList doUpdate: '->puttext;
                (if anAST[] <> none then
                    anAST.index->putint; newline
                 else
                    'anAST is NONE!'->putline
                if)
            if);
            anAST[]->doUpdate
        if)
     #)  

-- AggregationListUpdateElement: DoPart --
do
   (if switch[54] then
       'AggregationList - update element: '->puttext;
       left.index->putint;
       '  '->puttext;
       right.index->putint;
       '  '->puttext;
       newLeft.index->putint;
       newline
   if);
   find
     (#
        predicate:: 
          (# anAST: ^mps.ast
          do
             (current.left = left.index) and
             (left.frag.fullname->current.leftFrag.equal) and
             (current.right = right.index) and
             (right.frag.fullname->current.rightFrag.equal)->value
          #);
        notFound:: 
          (# 
          do
             (newLeft[],right[],leftMulFrom,leftMulTo,rightMulFrom,rightMulTo)
               ->insert
          #)
     do
        newLeft.index->current.left;
        newLeft.frag.fullname->current.leftFrag[];
        right.index->current.right;
        right.frag.fullname->current.rightFrag[];
        leftMulFrom->current.leftMulFrom;
        leftMulTo->current.leftMulTo;
        rightMulFrom->current.rightMulFrom;
        rightMulTo->current.rightMulTo
     #)  

-- AggregationListSave: DoPart --
do
   54->trace (#  do 'AggregationList.save'->t #);
   resetSaved;
   size*8->noOfAttr;
   (ID,UDStart,noOfAttr)->writeIntegerUserData;
   UDStart->attributeID;
   scan
     (#  do current.save #);
   54->trace (#  do 'AggregationList.save END'->t #)  

-- AggregationListResetSaved: DoPart --
do
   (ID,UDStart)->readIntegerUserData->noOfAttr;
   (for i: noOfAttr repeat (ID,UDStart+i)->deleteUserDataType for)  

-- AggregationListLoad: DoPart --
do
   54
     ->trace
       (# 
       do 'AggregationList.load on PageID =%i'->t.putformat (#  do ID->i #)
       #);
   (ID,UDStart)->readIntegerUserData->noOfAttr;
   UDStart->i;
   loop:
   (if i < UDStart+noOfAttr then
       &element[]->theElm[];
       (id,i+1->i)->readIntegerUserData->theElm.left;
       (id,i+1->i)->readIntegerUserData->theElm.right;
       (id,i+1->i)->readIntegerUserData->theElm.leftMulFrom;
       (id,i+1->i)->readIntegerUserData->theElm.leftMulTo;
       (id,i+1->i)->readIntegerUserData->theElm.rightMulFrom;
       (id,i+1->i)->readIntegerUserData->theElm.rightMulTo;
       (id,i+1->i)->readTextUserData->theElm.leftFrag[];
       (id,i+1->i)->readTextUserData->theElm.rightFrag[];
       theElm[]->THIS(Set).insert;
       54->trace (#  do 'Loaded element:'->putline; ; theElm.dump #);
       restart loop
   if);
   54->trace (#  do 'AggregationList.load END'->t #);
     

-- AggregationListDump: DoPart --
do
   newline;
   'AggregationList: '->putline;
   scan
     (#  do current.dump #);
   'AggregationList END '->putline  

-- PatternDiagramsPrivate: Descriptor --
(#
   redisplayRelations:
     (# connectorList: ^ObjectList
     do
        false->repair;
        AssociationList.clear;
        InheritanceList.clear;
        AggregationList.clear;
        theList.scan
          (#
             thePatternDeclDiagram: ^PatternDeclDiagram;
             theFather: ^MPS.AST;
             parentListDiag,theListDiagram: ^ListDiagram;
             theDiagramNode: ^parentListDiag.DiagramNode;
             theNode: ^PatternDiagramNode;
             theSuperNode: ^theListDiagram.AbstractNode;
             node1,node2: ^DesignObject;
             foundInheritance: @boolean;
             con: ^DeletableConnector
          do
             (if current.e## <= FragmentDiagram## then
                 
              else
                 (if current.e## <= PatternDeclDiagram## then
                     current.e[]->thePatternDeclDiagram[];
                     (if thePatternDeclDiagram.theDescriptor[] = none then
                         'theDescriptor = none for diagram = %s\n'
                           ->putformat
                             (#  do thePatterndecldiagram.titletext[]->s #)
                     if);
                     (if
                     thePatternDeclDiagram.theDescriptor.frag.father->isChecked
                      then
                         thePatternDeclDiagram.theDescriptor[]->getPrefix
                           ->thePatternDeclDiagram.thePrefix[];
                         (if thePatternDeclDiagram.thePrefix[] <> none then
                             thePatternDeclDiagram.theDescriptor.father
                               ->theFather[];
                             (if theFather## <= betaGram.AttributeDecl## then
                                 (theFather[],
                                  thePatternDeclDiagram.thePrefix.father)
                                   ->InheritanceList.insert;
                                 true->foundInheritance
                              else
                             (*could be a singular*)
                                 theFather.father->theFather[];
                                 (if theFather[] <> none then
                                     (if theFather## <= betaGram.AttributeDecl##
                                      then
                                         ((
                                          thePatternDeclDiagram.theDescriptor.
                                            father).father,
                                          thePatternDeclDiagram.thePrefix.
                                            father)->InheritanceList.insert;
                                         true->foundInheritance
                                     if)
                                 if)
                             if);
                             (if foundInheritance then
                                 thePatternDeclDiagram.thePrefix.father
                                   ->AstToNode->theNode[];
                                 (if theNode[] <> none then
                                     theNode.theDiagram->theListDiagram[];
                                     theNode[]->theSuperNode[];
                                     (if theSuperNode.currentDecomposDiagram <>
                                     none then
                                         (if
                                         thePatternDeclDiagram.titleNode.
                                           thePrefixConn <> none then
                                             (
                                             thePatternDeclDiagram.titleNode.
                                               thePrefixConn).getEnds
                                               ->(node1[],node2[]);
                                             node2[]->boxToNode->node2[];
                                             (if node2[] <>
                                             (
                                             theSuperNode.currentDecomposDiagram
                                             ).titleNode[] then
                                                 thePatternDeclDiagram.titleNode
                                                 .unMakeRegion;
                                                 (thePatternDeclDiagram.
                                                    titleNode.getTopParent,
                                                  thePatternDeclDiagram.
                                                    titleNode[],
                                                  (
                                                  (
                                                  theSuperNode.
                                                    currentDecomposDiagram).
                                                  theSurroundBox).getTopParent,
                                                  (
                                                  theSuperNode.
                                                    currentDecomposDiagram).
                                                  theSurroundBox)
                                                   ->
                                                     (
                                                     thePatternDeclDiagram.
                                                       titleNode.thePrefixConn).
                                                     setEnds;
                                                 (
                                                 theSuperNode.
                                                   currentDecomposDiagram).
                                                 titleNode[]
                                                   ->
                                                     thePatternDeclDiagram.
                                                       titleNode.createRegion
                                             if)
                                          else
                                             &PrefixConnector[]->con[];
                                             (* to prevent onInit from generating code *)
                                             true->con.initialisingSaved;
                                             (thePatternDeclDiagram.titleNode[],
                                              (
                                              theSuperNode.
                                                currentDecomposDiagram).
                                              theSurroundBox)->con.new;
                                             con[]
                                               ->
                                                 thePatternDeclDiagram.titleNode
                                                 .thePrefixConn;
                                             (
                                             theSuperNode.currentDecomposDiagram
                                             ).titleNode[]
                                               ->
                                                 thePatternDeclDiagram.titleNode
                                                 .createRegion;
                                             (if not gppProp.specializations
                                              then
                                                 false->con.borderVisible;
                                                 false->con.selectable
                                             if)
                                         if)
                                      else
                                         (if
                                         thePatternDeclDiagram.titleNode.
                                           thePrefixConn <> none then
                                             (
                                             thePatternDeclDiagram.titleNode.
                                               thePrefixConn).delete
                                         if)
                                     if)
                                  else
                                     (if
                                     thePatternDeclDiagram.titleNode.
                                       thePrefixConn <> none then
                                         (
                                         thePatternDeclDiagram.titleNode.
                                           thePrefixConn).delete
                                     if)
                                 if)
                             if)
                         if)
                      else
                         (if thePatternDeclDiagram.theParentNode <> none then
                             (thePatternDeclDiagram.theParentNode).theDiagram
                               ->parentListDiag[];
                             thePatternDeclDiagram.theParentNode
                               ->theDiagramNode[];
                             (if theDiagramNode.thePrefix[] <> none then
                                 theDiagramNode.thePrefix[]
                                   ->thePatternDeclDiagram.thePrefix[]
                             if)
                         if)
                     if)
                 if);
                 current.e[]->theListDiagram[];
                 theListDiagram.localNodes.scan
                   (#
                      thePatternNode: ^theListDiagram.PatternNode;
                      theSimpleNode: ^theListDiagram.SimpleAttributeDecl;
                      anAST: ^mps.ast;
                      theObjectSpec: ^MPS.AST;
                      na: ^betaGram.nameApl;
                      nd: ^betaGram.nameDcl;
                      rem: ^betaGram.remote;
                      thePrefix: ^betaGram.prefix;
                      attDen: ^betaGram.AttributeDenotation;
                      prefixName: ^text;
                      theMainPart: ^betaGram.MainPart;
                      theAttributes: ^betaGram.Attributes;
                      theQualification: ^betaGram.AttributeDecl;
                      foundAggregation: @Boolean;
                      leftMulFrom,leftMulTo,rightMulFrom,rightMulTo: @integer
                   do
                      false->foundAggregation;
                      none ->theQualification[];
                      (if current## <= theListDiagram.PatternNode## then
                          current[]->thePatternNode[];
                          thePatternNode.setupAssociation
                       else
                          (if current## <= theListDiagram.SimpleAttributeDecl##
                           then
                              current[]->theSimpleNode[];
                              (if theSimpleNode.theReferenceSpec[] <> none then
                                  theSimpleNode.theReferenceSpec.getson1
                                    ->theObjectSpec[]
                                    ->theSimpleNode.setupRelations;
                                  (if false then
                                      (if theObjectSpec.symbol
                                       // betaGram.ObjectDescriptor then
                                          (if
                                          theObjectSpec.frag.father->ischecked
                                           then
                                              theSimpleNode.theObjectDescriptor.
                                                getPrefixOpt->anAST[];
                                              (if anAST.kind =
                                              mps.kinds.interior then
                                                  anAST[]->thePrefix[];
                                                  thePrefix.
                                                    getAttributeDenotation
                                                    ->attDen[];
                                                  (if attDen.symbol =
                                                  betaGram.NameApl then
                                                      attDen[]->na[];
                                                      na.getText->prefixName[];
                                                      (if
                                                      ('arrayContainer'
                                                         ->prefixName.equalNCS)
                                                      or
                                                      ('hashTable'
                                                         ->prefixName.equalNCS)
                                                      or
                                                      ('extensibleHashTable'
                                                         ->prefixName.equalNCS)
                                                      or
                                                      ('List'
                                                         ->prefixName.equalNCS)
                                                      or
                                                      ('Set'
                                                         ->prefixName.equalNCS)
                                                      or
                                                      ('MultiSet'
                                                         ->prefixName.equalNCS)
                                                      or
                                                      ('Stack'
                                                         ->prefixName.equalNCS)
                                                      or
                                                      ('Queue'
                                                         ->prefixName.equalNCS)
                                                      or
                                                      ('PriorityQueue'
                                                         ->prefixName.equalNCS)
                                                       then
                                                          theSimpleNode.
                                                            theObjectDescriptor.
                                                            getMainPart
                                                            ->theMainPart[];
                                                          theMainPart.
                                                            getAttributes
                                                            ->theAttributes[];
                                                          theAttributes.newScan
                                                            (#
                                                               theFinalDecl:
                                                                 ^betaGram.
                                                                    FinalDecl;
                                                               os:
                                                                 ^betaGram.
                                                                    ObjectSpecification;
                                                               na:
                                                                 ^betaGram.
                                                                    NameApl;
                                                               theRemote:
                                                                 ^betaGram.
                                                                    remote;
                                                               theNames:
                                                                 ^betaGram.
                                                                    Names;
                                                               theNameDcl:
                                                                 ^betaGram.
                                                                    NameDcl;
                                                               t: ^text
                                                            do
                                                               (if
                                                               current.symbol =
                                                               betaGram.
                                                                 FinalDecl then
                                                                   current[]
                                                                     ->
                                                                       theFinalDecl[];
                                                                   theFinalDecl.
                                                                     getNames
                                                                     ->
                                                                       theNames[];
                                                                   theNames.
                                                                     getSon1
                                                                     ->
                                                                       theNameDcl[];
                                                                   theNameDcl.
                                                                     getText
                                                                     ->t[];
                                                                   (if
                                                                   'element'
                                                                     ->
                                                                       t.
                                                                         equalNCS
                                                                    then
                                                                       theFinalDecl
                                                                       .
                                                                         getObjectSpecification
                                                                         ->os[];
                                                                       (if
                                                                       os.symbol
                                                                        //
                                                                        betaGram
                                                                        .NameApl
                                                                        then
                                                                           os[]
                                                                             ->
                                                                               na[];
                                                                           (
                                                                           (
                                                                           na.
                                                                             dclRef
                                                                           ).
                                                                           father
                                                                           ).
                                                                           father
                                                                             ->
                                                                               theQualification[];
                                                                           
                                                                        //
                                                                        betaGram
                                                                        .Remote
                                                                        then
                                                                           os[]
                                                                             ->
                                                                               theRemote[];
                                                                           theRemote
                                                                           .
                                                                             getNameApl
                                                                             ->
                                                                               na[];
                                                                           (
                                                                           (
                                                                           na.
                                                                             dclRef
                                                                           ).
                                                                           father
                                                                           ).
                                                                           father
                                                                             ->
                                                                               theQualification[]
                                                                       if)
                                                                   if)
                                                               if)
                                                            #);
                                                          (if
                                                          theQualification[] <>
                                                          none then
                                                              true
                                                                ->
                                                                  foundAggregation;
                                                              (1,1,- 1,- 1)
                                                                ->
                                                                  (leftMulFrom,
                                                                   leftMulTo,
                                                                   rightMulFrom,
                                                                   rightMulTo)
                                                          if)
                                                      if);
                                                      
                                                  if)
                                              if)
                                          if)
                                       // betaGram.NameApl then
                                          (if
                                          theObjectSpec.frag.father->ischecked
                                           // true then
                                              theObjectSpec[]->na[];
                                              (if
                                              (theSimpleNode.theReferenceSpec.
                                                 symbol = betaGram.DynamicItem)
                                              or
                                              (theSimpleNode.theReferenceSpec.
                                                 symbol = betaGram.StaticItem)
                                               then
                                                  na.dclRef->nd[];
                                                  (nd.father).father
                                                    ->theQualification[];
                                                  (if
                                                  theSimpleNode.theDeclaration.
                                                    symbol =
                                                  betaGram.RepetitionDecl then
                                                      true->foundAggregation;
                                                      (1,1,- 1,- 1)
                                                        ->
                                                          (leftMulFrom,
                                                           leftMulTo,
                                                           rightMulFrom,
                                                           rightMulTo)
                                                   else
                                                      true->foundAggregation;
                                                      (1,1,1,1)
                                                        ->
                                                          (leftMulFrom,
                                                           leftMulTo,
                                                           rightMulFrom,
                                                           rightMulTo)
                                                  if)
                                              if)
                                          if);
                                          
                                       // betaGram.remote then
                                          (if
                                          theObjectSpec.frag.father->ischecked
                                           // true then
                                              theObjectSpec[]->rem[];
                                              rem.getnameApl->na[];
                                              (if
                                              (theSimpleNode.theReferenceSpec.
                                                 symbol = betaGram.DynamicItem)
                                              or
                                              (theSimpleNode.theReferenceSpec.
                                                 symbol = betaGram.StaticItem)
                                               then
                                                  na.dclRef->nd[];
                                                  (nd.father).father
                                                    ->theQualification[];
                                                  (if
                                                  theSimpleNode.theDeclaration.
                                                    symbol =
                                                  betaGram.RepetitionDecl then
                                                      true->foundAggregation;
                                                      (1,1,- 1,- 1)
                                                        ->
                                                          (leftMulFrom,
                                                           leftMulTo,
                                                           rightMulFrom,
                                                           rightMulTo)
                                                   else
                                                      true->foundAggregation;
                                                      (1,1,1,1)
                                                        ->
                                                          (leftMulFrom,
                                                           leftMulTo,
                                                           rightMulFrom,
                                                           rightMulTo)
                                                  if);
                                                  (*  (theDeclaration,theQualification)
                                                   ->patternDiagrams.DynReferenceList.insert*)
                                                  
                                              if)
                                          if);
                                          
                                      if);
                                      (if foundAggregation then
                                          (theSimpleNode.theDeclaration[],
                                           theQualification[],leftMulFrom,
                                           leftMulTo,rightMulFrom,rightMulTo)
                                            ->AggregationList.insert
                                      if)
                                  if)
                              if)
                          if)
                      if)
                   #)
             if)
          #);
        theList.scan
          (#
             thePatternDeclDiagram: ^PatternDeclDiagram;
             theListDiagram: ^ListDiagram
          do
             (if current.e## <= FragmentDiagram## then
                 
              else
                 current.e[]->theListDiagram[];
                 theListDiagram.localNodes.scan
                   (# theSimpleNode: ^theListDiagram.SimpleAttributeDecl
                   do
                      (if current## <= theListDiagram.SimpleAttributeDecl## then
                          current[]->theSimpleNode[];
                          theSimpleNode.displayReference
                      if)
                   #)
             if)
          #);
        true->repair
     #);
   parseDiagram:
   (* scans through patternDiagramNodes and
    sets up ast references on the nodes according
    to the structure of the diagram *)
     (#
        doUpdate: @boolean;
        performedUpdates: @text;
        removeDiagram:
        (* remove all diagrams from WorkPage and GroupPage that has to do with fragNode.theGroup *)
          (#
             theGroupName: ^text;
             thePropDiag: ^SimplePropertyDiagram;
             theFragDiag: ^FragmentDiagram
          enter theGroupName[]
          do
             (if theGroupName[] <> none then
                 theList.scanPropertyDiagrams
                   (# 
                   do
                      (if
                      thisDiagram.titlenode.UDtheGroup.theGroupName
                        ->theGroupName.equal then
                          thisDiagram[]->thePropDiag[]
                      if)
                   #);
                 theList.scanFragmentDiagrams
                   (# 
                   do
                      (if thisDiagram.fullname->theGroupName.equal then
                          thisDiagram[]->theFragDiag[]
                      if)
                   #);
                 (if theFragDiag[] <> none then
                     theFragDiag.titleNode.abstract
                 if);
                 (if thePropDiag[] <> none then
                     thePropDiag.titleNode.abstract
                 if)
             if)
          #);
        askUpdate:
          (# ok: @integer; fgname: ^text
          enter fgname[]
          do
             (if true (* to avoid bugs when users answers "No" *) then
                 yes->ok; true->doUpdate
              else
                 (if doUpdate then
                     yes->ok
                  else
                     ('Open Diagram',
                      'Inconsistencies between diagram and code were detected.\nAutomatically update diagram?')
                       ->promptForYesNo->ok;
                     (if ok = yes then
                         true->doUpdate
                      else
                         fgname[]->removeDiagram; (*askConvertToGraphics*) 
                     if)
                 if)
             if)
          exit ok
          #);
        askConvertToGraphics:
          (# ok: @integer; fgname: ^text
          do
             ('Open Diagram',
              'If you wish to further edit or print your un-updated diagram\nthis can be done by converting it to graphics-only pages. Convert?')
               ->promptForBoolean->ok;
             (if ok = yes then currentDiagramName[]->LoadGraphicsPages if)
          exit ok
          #);
        consistentFFCategory:
          (#
             ff: ^mps.fragmentForm;
             fn: ^PatternDiagramNode;
             value: @boolean;
             ld: ^ListDiagram
          enter (ff[],fn[])
          do
             fn.theDiagram->ld[];
             (if ff.root.symbol
              // betaGram.AttributesForm then
                 (fn## <= ld.AttributesNode##)->value
              // betaGram.DescriptorForm then
                 (fn## <= ld.DescriptorNode##)->value
              // betaGram.DoPart then
                 (fn## <= ld.DoPartNode##)->value
             if)
          exit value
          #);
        getFFattributes:
        (* returns topmost attributes list AND updates
         theAST or theDescriptor ref. on relevant diagram *)
          (#
             ff: ^mps.fragmentform;
             theAttributes: ^betaGram.attributes;
             attForm: ^betaGram.AttributesForm;
             descForm: ^betaGram.DescriptorForm;
             od: ^betaGram.ObjectDescriptor;
             mp: ^betaGram.MainPart;
             ld: ^ListDiagram;
             pad: ^PatternAttDiagram;
             pdd: ^PatternDeclDiagram
          enter (ff[],ld[])
          do
             (if ff.root.symbol
              // betaGram.AttributesForm then
                 ff.root[]->attForm[];
                 attForm.getAttributes->theAttributes[];
                 ld[]->pad[];
                 theAttributes[]->pad.theAST[];
                 (pad[],theAttributes.index,theAttributes.frag.fullname)
                   ->theWorkPage.patternDiagrams.theList.updateIndex
              // betaGram.DescriptorForm then
                 ff.root[]->descForm[];
                 descForm.getObjectDescriptor->od[];
                 od.getMainPart->mp[];
                 mp.getAttributes->theAttributes[];
                 ld[]->pdd[];
                 od[]->pdd.theDescriptor[];
                 (pad[],od.index,od.frag.fullname)
                   ->theWorkPage.patternDiagrams.theList.updateIndex
             if)
          exit theAttributes[]
          #);
        parseAttributes:
          (# ld: ^listDiagram; theAttributes: ^betaGram.Attributes
          enter (theAttributes[],ld[])
          do
             18
               ->trace
                 (# 
                 do
                    'parseDiagram: %s'
                      ->t.putformat (#  do ld.titletext[]->s #)
                 #);
             thisOp:
               (# 
               do
                  theAttributes[]
                    ->ld.scanAttributeDecls
                      (#
                         ndtexts:
                         (* to cope with same name
                          declared more than once in
                          attribute list *) @list
                           (#
                              element:: text;
                              occurrenceNo:
                                (# ndtext: ^text; no: @integer
                                enter ndtext[]
                                do
                                   ndtexts.scan
                                     (# 
                                     do
                                        (if current[]->ndtext.equal then
                                            no+1->no
                                        if)
                                     #);
                                   ndtext[]->ndtexts.append;
                                   no+1->no
                                exit no
                                #)
                           #);
                         nonTerminals:
                         (* to cope with more than
                          one attributeDeclOpt in
                          attribute list *) @integer;
                         slottexts:
                         (* to cope with same slot
                          declared more than once in
                          attribute list *) @list
                           (#
                              element:: text;
                              occurrenceNo:
                                (# slottext: ^text; no: @integer
                                enter slottext[]
                                do
                                   slottexts.scan
                                     (# 
                                     do
                                        (if current[]->slottext.equal then
                                            no+1->no
                                        if)
                                     #);
                                   slottext[]->slottexts.append;
                                   no+1->no
                                exit no
                                #)
                           #);
                         thisAttribute:: 
                           (#
                              checkCategoryAndSignature:
                                (#
                                   nd: ^betaGram.nameDcl;
                                   theNode: ^ld.DiagramNode;
                                   nodeType: ##ld.abstractNode;
                                   ok: @integer
                                enter (nd[],theNode[],nodeType##)
                                do
                                   (if theNode## = nodeType## then
                                       18
                                         ->trace
                                           (# 
                                           do
                                              'Found node matching category!'->T
                                           #);
                                       (nd[],theNode[])->signatureMatch
                                    else
                                       (nd.frag.father).fullname->askUpdate->ok;
                                       (if ok = yes then
                                           (theNode[],true)
                                             ->
                                               (theNode.theDiagram).
                                               deleteDiagramNode;
                                           (((nd.father).father).father,
                                            ((nd.father).father).sonNo)
                                             ->listElementInserted;
                                           'Changed syntactical category of %s in %s\n'
                                             ->performedUpdates.putformat
                                               (# 
                                               do
                                                  ndtext[]->s; ld.titletext[]->s
                                               #)
                                        else
                                           leave thisOp
                                       if)
                                   if)
                                #);
                              signatureMatch:
                                (#
                                   updateASTRefs:
                                     (#
                                        updateComment:
                                          (#
                                             cm: ^ld.CommentMark;
                                             nodeText: @text;
                                             commentText: ^text;
                                             theCom: ^mps.comment;
                                             commentPos: @integer
                                          do
                                             (if theNode.theMarkNode <> none
                                              then
                                                 (if
                                                 theNode.theDeclaration.
                                                   hasComment then
                                                     theNode.theMarkNode->cm[];
                                                     (if cm.theCommentNode <>
                                                     none then
                                                         (cm.theCommentNode).
                                                         theText.get->nodeText;
                                                         theNode.theDeclaration.
                                                           getComment->theCom[];
                                                         theNode.
                                                           theDeclaration[]
                                                           ->
                                                             astUtils.
                                                               getCommentPos
                                                           ->commentPos;
                                                         (commentPos,1)
                                                           ->
                                                             theNode.
                                                               theDeclaration.
                                                               getSubcomment
                                                           ->commentText[];
                                                         (if not
                                                         (commentText[]
                                                            ->nodeText.equal)
                                                          then
                                                             commentText
                                                               ->
                                                                 (
                                                                 cm.
                                                                   theCommentNode
                                                                 ).theText.set
                                                         if)
                                                     if);
                                                     theNode.theDeclaration.
                                                       getComment
                                                       ->cm.theComment[]
                                                  else
                                                     (theNode.theMarkNode).
                                                     delete;
                                                     none ->theNode.theMarkNode
                                                 if)
                                              else
                                                 (if
                                                 theNode.theDeclaration.
                                                   hasComment then
                                                     &ld.CommentMark[]->cm[];
                                                     (theNode[],
                                                      theNode.theDeclaration.
                                                        getComment)->cm.display
                                                 if)
                                             if)
                                          #)
                                     do
                                        (nd.father).father
                                          ->theNode.theDeclaration[];
                                        theNode.theDeclaration.index
                                          ->theNode.astIndex;
                                        newOD[]->theNode.theObjectDescriptor[];
                                        (if sad[] <> none then
                                            theRefSpec[]
                                              ->sad.theReferenceSpec[];
                                            theUnExpRefSpec[]
                                              ->sad.theUnExpRefSpec[]
                                        if);
                                        theNode.updateComment
                                     #);
                                   checkParseAttributes:
                                     (# 
                                     do
                                        (if (newOD[] <> none ) and
                                        (theNode.currentDecomposDiagram <> none
                                         ) then
                                            newOD[]
                                              ->
                                                (theNode.currentDecomposDiagram)
                                                  .theDescriptor[];
                                            (theNode.currentDecomposDiagram,
                                             newOD.index,newOD.frag.fullname)
                                              ->
                                                theWorkPage.patternDiagrams.
                                                  theList.updateIndex;
                                            newOD.getMainPart->mp[];
                                            (mp.getAttributes,
                                             theNode.currentDecomposDiagram)
                                              ->parseAttributes
                                        if)
                                     #);
                                   nd: ^betaGram.NameDcl;
                                   theNode: ^ld.DiagramNode;
                                   value: @boolean;
                                   newOD: ^betaGram.ObjectDescriptor;
                                   mp: ^betaGram.MainPart;
                                   theRefSpec:
                                     ^betaGram.ReferenceSpecification;
                                   theUnExpRefSpec: ^mps.UnExpanded;
                                   theObjSpec: ^mps.ast;
                                   newName,propString: ^text;
                                   newText,oldText: @text;
                                   sad: ^ld.SimpleAttributeDecl;
                                   ok: @integer
                                enter (nd[],theNode[])
                                do
                                   (if theNode## <= ld.SimpleAttributeDecl##
                                    then
                                       theNode[]->sad[];
                                       (nd[],(nd.father).father)->sad.ppAST
                                         ->
                                           (newText,newName[],newOD[],
                                            propString[],theRefSpec[],
                                            theUnExpRefSpec[],theObjSpec[])
                                    else
                                       (nd[],(nd.father).father)->theNode.ppAST
                                         ->
                                           (newText,newName[],newOD[],
                                            propString[])
                                   if);
                                   theNode.theText.get->oldText;
                                   (if oldText[]->newText.equal then
                                       18
                                         ->trace
                                           (# 
                                           do '...and signatures match!!'->t
                                           #);
                                       true->value;
                                       updateASTRefs;
                                       checkParseAttributes
                                    else
                                       18
                                         ->trace
                                           (# 
                                           do
                                              '...but signatures don\'t match: new=%s old=%s\n'
                                                ->t.putformat
                                                  (# 
                                                  do newText[]->s; oldText[]->s
                                                  #)
                                           #);
                                       (nd.frag.father).fullname->askUpdate->ok;
                                       (if ok = yes then
                                           newText->theNode.theText.set;
                                           ndtext[]->theNode.theName;
                                           updateASTRefs;
                                           'Updated attribute signature "%s" in %s to new signature "%s"\n'
                                             ->performedUpdates.putformat
                                               (# 
                                               do
                                                  oldtext[]->s;
                                                  ld.titletext[]->s;
                                                  newtext[]->s
                                               #);
                                           checkParseAttributes
                                        else
                                           leave thisOp
                                       if)
                                   if)
                                exit value
                                #);
                              ndecl: ^mps.NameDecl;
                              ndtext: ^text;
                              anAST: ^mps.ast;
                              theNode: ^ld.DiagramNode;
                              help: @text;
                              ok: @integer
                           do
                              18
                                ->trace
                                  (# 
                                  do
                                     'scanAttributeDecls: it was an attribute'
                                       ->t.puttext
                                  #);
                              nd.getNameDecl->anAST[];
                              (if anAST.kind
                               // mps.kinds.unExpanded then
                                  '<<NameDecl>>'->ndtext[]
                               // mps.kinds.optional then
                                  '<<Optional>>'->ndtext[]; 
                               else
                              (* is a real name *)
                                  anAST[]->ndecl[]; ndecl.getText->ndtext[]
                              if);
                              (if ndtext[] <> none then
                                  (ndtext[],ndtext[]->ndtexts.occurrenceNo)
                                    ->ld.nameToNode->theNode[];
                                  18
                                    ->trace
                                      (# 
                                      do
                                         'parseDiagram: ndtext = %s ld=%s\n'
                                           ->T.putformat
                                             (# dummy: @text
                                             do
                                                ndtext[]->s;
                                                ld.titleNode.theText.get->dummy;
                                                dummy[]->s
                                             #)
                                      #);
                                  (if theNode[] <> none then
                                      18
                                        ->trace
                                          (# 
                                          do
                                             'parseDiagram: corresponding node = %s\n'
                                               ->putformat
                                                 (# 
                                                 do theNode.theName->s
                                                 #)
                                          #);
                                      (if ((nd.father).father).symbol
                                       // betaGram.PatternDecl then
                                          (nd[],theNode[],ld.PatternNode##)
                                            ->checkCategoryAndSignature
                                       // betaGram.SimpleDecl then
                                          (nd[],theNode[],ld.SimpleNode##)
                                            ->checkCategoryAndSignature
                                       // betaGram.RepetitionDecl then
                                          (nd[],theNode[],ld.RepetitionNode##)
                                            ->checkCategoryAndSignature
                                       // betaGram.VirtualDecl then
                                          (nd[],theNode[],ld.VirtualNode##)
                                            ->checkCategoryAndSignature
                                       // betaGram.BindingDecl then
                                          (nd[],theNode[],ld.BindingNode##)
                                            ->checkCategoryAndSignature
                                       // betaGram.FinalDecl then
                                          (nd[],theNode[],ld.FinalNode##)
                                            ->checkCategoryAndSignature
                                      if)
                                   else
                                      (nd.frag.father).fullname->askUpdate->ok;
                                      (if ok = yes then
                                          (((nd.father).father).father,
                                           ((nd.father).father).sonNo)
                                            ->listElementInserted;
                                          'Attribute %s inserted in %s\n'
                                            ->performedUpdates.putformat
                                              (# 
                                              do ndtext[]->s; ld.titletext[]->s
                                              #)
                                       else
                                          leave thisOp
                                      if)
                                  if)
                              if)
                           #);
                         thisUnExp:: 
                           (#
                              theNode: ^ld.nonTerminalNode;
                              help: @text;
                              ok: @integer
                           do
                              18
                                ->trace
                                  (# 
                                  do
                                     'scanAttributeDecls: it was an unExp'
                                       ->t.puttext
                                  #);
                              nonTerminals+1->nonTerminals->ld.noToNonTerminal
                                ->theNode[];
                              (if theNode[] <> none then
                                  unExp[]->theNode.unExp[];
                                  unExp.index->theNode.astIndex
                               else
                                  (unExp.frag.father).fullname->askUpdate->ok;
                                  (if ok = yes then
                                      (unExp.father,unExp.sonNo)
                                        ->listElementInserted;
                                      'Nonterminal attribute, "<<AttributeDeclOpt>>" inserted in %s\n'
                                        ->performedUpdates.putformat
                                          (#  do ld.titletext[]->s #)
                                   else
                                      leave thisOp
                                  if)
                              if)
                           #);
                         thisOptional:: 
                           (# 
                           do
                              18
                                ->trace
                                  (# 
                                  do
                                     'scanAttributeDecls: it was an optional'
                                       ->t.puttext
                                  #)
                           #);
                         thisSlot:: 
                           (#
                              theNode: ^ld.SlotNode;
                              help,indextext: @text;
                              slotText: ^text;
                              ok: @integer
                           do
                              18
                                ->trace
                                  (# 
                                  do
                                     'scanAttributeDecls: it was a SLOT'
                                       ->t.puttext
                                  #);
                              (mps[],unExp.frag[],unExp[],indextext[],none
                               (*streamName[]*) ,80,0,false
                               (*abstractPresentation*) ,false
                               (*showSemanticErrors*) ,false (*includeComments*)
                               ,false,false,false,false,'',false
                               (*onlyProperties*) ,false,false
                               (*
                                test*) )->ppFragment;
                              (1,indexText.length-3)->indexText.sub->slotText[];
                              (slottext[],slottext[]->slottexts.occurrenceNo)
                                ->ld.slotNameToNode->theNode[];
                              (if theNode[] <> none then
                                  unExp[]->theNode.unExp[];
                                  unExp.index->theNode.astIndex
                               else
                                  (unExp.frag.father).fullname->askUpdate->ok;
                                  (if ok = yes then
                                      (unExp.father,unExp.sonNo)
                                        ->listElementInserted;
                                      'SLOT attribute, "%s" inserted in %s\n'
                                        ->performedUpdates.putformat
                                          (# 
                                          do slottext[]->s; ld.titletext[]->s
                                          #)
                                   else
                                      leave thisOp
                                  if)
                              if)
                           #)
                      #);
                  ld.localNodes.scan
                    (#
                       dn: ^ld.DiagramNode;
                       ntn: ^ld.NonTerminalNode;
                       sn: ^ld.SlotNode;
                       fndiag: ^FragmentDiagram;
                       fn: ^FragmentDiagram.FragmentNode;
                       ok: @integer
                    do
                       (if true
                        // current## <= ld.DiagramNode## then
                           current[]->dn[];
                           (if dn.theDeclaration[] = none then
                               ((dn.theDiagram).theFragmentNode).theDiagram
                                 ->fndiag[];
                               (dn.theDiagram).theFragmentNode->fn[];
                               fn.theFragment.theGroupName->askUpdate->ok;
                               (if ok = yes then
                                   'Deleted %s in %s\n'
                                     ->performedUpdates.putformat
                                       (# 
                                       do dn.theName->s; ld.titletext[]->s
                                       #);
                                   (dn[],true)->ld.deleteDiagramNode
                                else
                                   leave thisOp
                               if)
                           if)
                        // current## <= ld.NonTerminalNode## then
                           current[]->ntn[];
                           (if ntn.unexp[] = none then
                               ((ntn.theDiagram).theFragmentNode).theDiagram
                                 ->fndiag[];
                               (ntn.theDiagram).theFragmentNode->fn[];
                               fn.theFragment.theGroupName->askUpdate->ok;
                               (if ok = yes then
                                   'Deleted <<AttributeDeclOpt>> in %s\n'
                                     ->performedUpdates.putformat
                                       (#  do ld.titletext[]->s #);
                                   (ntn[],true)->ld.deleteDiagramNode
                                else
                                   leave thisOp
                               if)
                           if)
                        // current## <= ld.SlotNode## then
                           current[]->sn[];
                           (if sn.unexp[] = none then
                               ((sn.theDiagram).theFragmentNode).theDiagram
                                 ->fndiag[];
                               (sn.theDiagram).theFragmentNode->fn[];
                               fn.theFragment.theGroupName->askUpdate->ok;
                               (if ok = yes then
                                   'Deleted %s in %s\n'
                                     ->performedUpdates.putformat
                                       (# help: @text
                                       do
                                          sn.theText.get->help;
                                          help[]->s;
                                          ld.titletext[]->s
                                       #);
                                   (sn[],true)->ld.deleteDiagramNode
                                else
                                   leave thisOp
                               if)
                           if)
                       if)
                    #)
               #)
          #);
        updateRelations:
          (#
             doUpdateRelations:
               (# connectors: ^ObjectList
               do
                  theWorkPage.patternDiagrams.AssociationList.clear;
                  theWorkPage.patternDiagrams.InheritanceList.clear;
                  theWorkPage.patternDiagrams.AggregationList.clear;
                  theWorkPage.getConnectors->connectors[];
                  (if connectors[] <> none then
                      connectors.scan
                        (#
                           updatePrefixInfo:
                             (#
                                pc: ^theWorkPage.PrefixConnector;
                                n2: ^theWorkPage.node;
                                node1,node2: ^theWorkPage.PatternDiagramNode;
                                pdd1: ^theWorkPage.PatternDeclDiagram;
                                ld1: ^theWorkPage.ListDiagram;
                                dn1: ^ld1.DiagramNode;
                                ld2: ^theWorkPage.ListDiagram;
                                dn2: ^ld2.DiagramNode;
                                oadd2: ^theWorkPage.OADDiagram
                             enter pc[]
                             do
                                true->pc.getEnds->(node1[],n2[]);
                                n2[]->theWorkPage.boxtonode->node2[];
                                node1.theDiagram->pdd1[];
                                (pdd1.theParentNode).theDiagram->ld1[];
                                pdd1.theParentNode->dn1[];
                                node2.theDiagram->oadd2[];
                                oadd2.theDescriptor[]->pdd1.thePrefix[];
                                pdd1.thePrefix[]->dn1.thePrefix[];
                                (oadd2.theParentNode).theDiagram->ld2[];
                                oadd2.theParentNode->dn2[];
                                (dn1.theDeclaration[],dn2.theDeclaration[])
                                  ->
                                    theWorkPage.patternDiagrams.InheritanceList.
                                      insert
                             #);
                           updateAssociationInfo:
                             (#
                                ac: ^theWorkPage.AssociationConnector;
                                ld,leftLD,rightLD: ^ListDiagram;
                                dn: ^ld.DiagramNode;
                                leftDn: ^leftLD.DiagramNode;
                                rightDn: ^rightLD.DiagramNode;
                                anAST: ^mps.ast;
                                thePrefix: ^betaGram.Prefix;
                                nameApl: ^betaGram.NameApl;
                                theNames: ^betaGram.Names;
                                nameDcl: ^betaGram.NameDcl;
                                si: ^betaGram.StaticItem;
                                od: ^betaGram.ObjectDescriptor;
                                thePrefName,t,leftName,rightName: ^text;
                                leftMulFrom,leftMulTo,rightMulFrom,rightMulTo:
                                  @integer
                             enter ac[]
                             do
                                ((ac.leftRole->ac.lr[]).thePatternDiagramNode).
                                theDiagram->leftLD[];
                                (ac.leftRole->ac.lr[]).thePatternDiagramNode
                                  ->leftDn[];
                                ((ac.rightRole->ac.rr[]).thePatternDiagramNode).
                                theDiagram->rightLD[];
                                (ac.rightRole->ac.rr[]).thePatternDiagramNode
                                  ->rightDn[];
                                (if ac.associationNode <> none then
                                    (ac.associationNode).theDiagram->ld[];
                                    ac.associationNode->dn[];
                                    (if dn.theObjectDescriptor[] <> none then
                                        dn.theObjectDescriptor[]
                                          ->astUtils.getPrefixName
                                          ->thePrefName[];
                                        (if thePrefName[] <> none then
                                            (if
                                            thePrefName[]
                                              ->utils.isAssociationName then
                                                thePrefName[]->utils.getAssMul
                                                  ->
                                                    (leftMulFrom,leftMulTo,
                                                     rightMulFrom,rightMulTo);
                                                (leftDn.theDeclaration[],
                                                 rightDn.theDeclaration[],
                                                 leftMulFrom,leftMulTo,
                                                 rightMulFrom,rightMulTo,
                                                 dn.theDeclaration[])
                                                  ->
                                                    theWorkPage.patternDiagrams.
                                                      AssociationList.insert
                                            if)
                                        if)
                                    if)
                                 else
                                    leftDn.theDeclaration[]
                                      ->astUtils.getPrefixNameOnDecl
                                      ->leftName[];
                                    rightDn.theDeclaration[]
                                      ->astUtils.getPrefixNameOnDecl
                                      ->rightName[];
                                    (if (leftName[] <> none ) and
                                    (rightName[] <> none ) then
                                        (leftName[],rightName[])
                                          ->utils.getEmbedAssMul
                                          ->
                                            (leftMulFrom,leftMulTo,rightMulFrom,
                                             rightMulTo);
                                        (leftDn.theDeclaration[],
                                         rightDn.theDeclaration[],leftMulFrom,
                                         leftMulTo,rightMulFrom,rightMulTo,none
                                         )
                                          ->
                                            theWorkPage.patternDiagrams.
                                              AssociationList.insert
                                    if)
                                if)
                             #);
                           updateAggregationInfo:
                             (#
                                agc: ^theWorkPage.AggregationConnector;
                                leftLD: ^theWorkPage.ListDiagram;
                                rightOADD: ^theWorkPage.OADDiagram;
                                leftDn: ^leftLD.DiagramNode;
                                rightDn: ^rightOADD.DiagramNode;
                                anAST: ^mps.ast;
                                si: ^betaGram.StaticItem;
                                os: ^betaGram.ObjectSpecification;
                                prefName: ^text;
                                theObject: ^PatternDiagramNode;
                                foundAggr: @boolean
                             enter agc[]
                             do
                                ((agc.leftRole->agc.lr[]).thePatternDiagramNode)
                                  .theDiagram->leftLD[];
                                (agc.leftRole->agc.lr[]).thePatternDiagramNode
                                  ->leftDn[];
                                ((agc.rightRole->agc.rr[]).thePatternDiagramNode
                                ).theDiagram->rightOADD[];
                                (if
                                (agc.rightRole->agc.rr[]).thePatternDiagramNode
                                = rightOADD.titleNode[] then
                                    rightOADD.theParentNode->rightDn[]
                                 else
                                    (agc.rightRole->agc.rr[]).
                                    thePatternDiagramNode->rightDn[]
                                if);
                                (if leftDn.theDeclaration.symbol
                                 // betaGram.SimpleDecl then
                                    leftDn.theDeclaration.getSon2->anAST[];
                                    (if anAST.symbol
                                     // betaGram.StaticItem then
                                        anAST[]->si[];
                                        si.getObjectSpecification->os[];
                                        (if os.symbol
                                         // betaGram.ObjectDescriptor then
                                            findAggr:
                                              (# 
                                              do
                                                 os[]->astUtils.getPrefixName
                                                   ->prefName[];
                                                 (if prefName[] <> none then
                                                     (if
                                                     prefName[]
                                                       ->utils.isContainerName
                                                      then
                                                         (leftDn.
                                                            theDeclaration[],
                                                          rightDn.
                                                            theDeclaration[],1,
                                                          1,- 1,- 1)
                                                           ->
                                                             theWorkPage.
                                                               patternDiagrams.
                                                               AggregationList.
                                                               insert;
                                                         true->FoundAggr
                                                      else
                                                         os[]->getPrefix->os[];
                                                         (if os[] <> none then
                                                             restart findAggr
                                                         if)
                                                     if)
                                                 if)
                                              #);
                                            (if not foundAggr
                                            (* it is a singular *) then
                                                (leftDn.theDeclaration[],
                                                 rightDn.theDeclaration[],1,1,1,
                                                 1)
                                                  ->
                                                    theWorkPage.patternDiagrams.
                                                      AggregationList.insert
                                            if)
                                         else
                                            (leftDn.theDeclaration[],
                                             rightDn.theDeclaration[],1,1,1,1)
                                              ->
                                                theWorkPage.patternDiagrams.
                                                  AggregationList.insert
                                        if)
                                     else
                                        (leftDn.theDeclaration[],
                                         rightDn.theDeclaration[],1,1,1,1)
                                          ->
                                            theWorkPage.patternDiagrams.
                                              AggregationList.insert
                                    if)
                                 // betaGram.RepetitionDecl then
                                    (leftDn.theDeclaration[],
                                     rightDn.theDeclaration[],1,1,- 1,- 1)
                                      ->
                                        theWorkPage.patternDiagrams.
                                          AggregationList.insert
                                if)
                             #)
                        do
                           (if true
                            // current## = theWorkPage.PrefixConnector## then
                               current[]->updatePrefixInfo
                            // current## = theWorkPage.AssociationConnector##
                            then
                               current[]->updateAssociationInfo
                            // current## = theWorkPage.AggregationConnector##
                            then
                               current[]->updateAggregationInfo
                           if)
                        #)
                  if)
               #);
             ok: @integer;
             fg: ^mps.fragmentGroup
          enter fg[]
          do
             doUpdateRelations;
             (if doUpdate then
                 ('Open Diagram',
                  'To ensure that all relations shown in the diagram are consistent with the code,\nit is necessary to (re-)build the semantic links\n\nInvoke checker now? (recommended!)')
                   ->promptForBoolean->ok;
                 doUpdateRelations;
                 (if ok = yes then fg[]->callChecker if)
             if)
          #);
        openFormsInSif: theList.scanFragmentDiagrams
          (# status: @boolean;
             ok: @integer (* Added by olm to elim bool/int mix;
                           * without this declaration it seemed that
                           * the ok in the enclosing pattern was used
                           *)
          do
             18
               ->trace
                 (# 
                 do
                    'parseDiagram.openFormsInSif scanning fgDiagram: %s'
                      ->t.putformat (#  do thisDiagram.titleText[]->s #)
                 #);
             true->status;
             thisOperation:
               (# 
               do
                  thisDiagram.localNodes.scan
                    (#
                       fgNotFound:
                         (#
                            updatePropertyDiag:
                              (# oldName,newName: ^text
                              enter (oldName[],newName[])
                              do
                                 theList.scanPropertyDiagrams
                                   (# 
                                   do
                                      (if
                                      thisDiagram.titlenode.UDtheGroup.
                                        theGroupName->oldName.equal then
                                          newName[]
                                            ->
                                              thisDiagram.titleNode.UDtheGroup.
                                                theGroupName;
                                          18
                                            ->trace
                                              (# 
                                              do
                                                 'Updated theGroupName on propertyDiagram to: %s'
                                                   ->t.putformat
                                                     (# 
                                                     do
                                                        thisDiagram.titleNode.
                                                          UDtheGroup.
                                                          theGroupName->s
                                                     #)
                                              #)
                                      if)
                                   #)
                              #);
                            fn: ^thisDiagram.FragmentNode;
                            retry: @boolean;
                            help,name: @text;
                            ok: @integer;
                            oldGroupName: ^text
                         enter fn[]
                         do
                            'Fragment file does not exist: %s\nSelect new location of file?'
                              ->help.putformat
                                (#  do fn.theFragment.theGroupName->s #);
                            ('Open Diagram',help[])->promptForBoolean->ok;
                            (if ok = yes then
                                fn.theFragment.theGroupName->oldGroupName[];
                                fileSelectDialog->name;
                                (if not name.empty then
                                    name[]->fn.theFragment.theGroupName;
                                    (oldGroupName[],name[])->updatePropertyDiag;
                                    true->retry;
                                    18
                                      ->trace
                                        (# 
                                        do
                                           'New location of file: %s'
                                             ->t.putformat
                                               (# 
                                               do
                                                  fn.theFragment.theGroupName->s
                                               #)
                                        #)
                                 else
                                    fn.theFragment.theGroupName->removeDiagram
                                if)
                             else
                                fn.theFragment.theGroupName->removeDiagram
                            if)
                         exit retry
                         #);
                       fn: ^thisDiagram.FragmentNode;
                       fg: ^mps.fragmentGroup;
                       ff: ^mps.fragmentForm;
                       error: ^Stream;
                       ld: ^listDiagram;
                       didRecover: @boolean
                    do
                       current[]->fn[];
                       18
                         ->trace
                           (# 
                           do
                              'Opening fg = %s\n(showDiagramCalled = %s)'
                                ->t.putformat
                                  (# 
                                  do
                                     fn.theFragment.theGroupName->s;
                                     (if showDiagramCalled then
                                         'true'->s
                                      else
                                         'false'->s
                                     if)
                                  #)
                           #);
                       fgOpen:
                       (if (fn.theFragment.theGroupName->topDotOpen->fg[]) <>
                       none then
                           fg[]->thisDiagram.theGroup;
                           (if not showDiagramCalled then
                               (if not fg.private.wasRecovered then
                                   fg[]->sifCheckAutoSaveFile->didRecover;
                                   (if didRecover then
                                       true->fg.private.wasRecovered
                                   if)
                               if)
                           if);
                           18
                             ->trace
                               (# 
                               do
                                  'Opening ff = %s'
                                    ->t.putformat
                                      (# 
                                      do fn.theFragment.theFragName->s
                                      #)
                               #);
                           ffOpen:
                           (fn.theFragment.theFragName,error[])
                             ->fg.open
                               (#
                                  mess: @text;
                                  astOverflow::< 
                                    (# 
                                    do
                                       none ->f[];
                                       none ->mps.theCatcher[];
                                       'AST overflow for '->mess;
                                       fn.theFragment.theFragName->mess.puttext;
                                       mess[]->AlertUser;
                                       false->status;
                                       leave thisOperation
                                    #);
                                  fragmentNotExisting::< 
                                    (# t: ^text
                                    do
                                       none ->f[];
                                       none ->mps.theCatcher[];
                                       leave ffOpen;
                                       (*(if fn[]->fgNotFound then
                                        restart fgOpen
                                        else
                                        false->status; leave thisOperation
                                        if)*)
                                       
                                    #);
                                  grammarNotFound::< 
                                    (# 
                                    do
                                       none ->f[];
                                       none ->mps.theCatcher[];
                                       'Grammar was not found'->mess;
                                       mess[]->AlertUser;
                                       false->status;
                                       leave thisOperation
                                    #);
                                  badFormat::< 
                                    (# 
                                    do
                                       none ->f[];
                                       none ->mps.theCatcher[];
                                       'Bad format: '->mess;
                                       fn.theFragment.theFragName->mess.puttext;
                                       mess[]->AlertUser;
                                       false->status;
                                       leave thisOperation
                                    #);
                                  fatalParseError::< 
                                    (# 
                                    do
                                       none ->f[];
                                       none ->mps.theCatcher[];
                                       'Fatal parse error: '->mess;
                                       errNo->mess.putInt;
                                       ' for '->mess.puttext;
                                       fn.theFragment.theFragName->mess.puttext;
                                       mess[]->AlertUser;
                                       false->status;
                                       leave thisOperation
                                    #);
                                  doubleFormDeclaration::< 
                                    (# 
                                    do
                                       none ->f[];
                                       none ->mps.theCatcher[];
                                       'Double form declaration in '->mess;
                                       fn.theFragment.theFragName->mess.puttext;
                                       mess[]->AlertUser;
                                       false->status;
                                       leave thisOperation
                                    #);
                                  readAccessError::< 
                                    (# 
                                    do
                                       none ->f[];
                                       none ->mps.theCatcher[];
                                       'No read access to '->mess;
                                       fn.theFragment.theFragName->mess.puttext;
                                       mess[]->AlertUser;
                                       false->status;
                                       leave thisOperation
                                    #);
                                  EOSError::< 
                                    (# 
                                    do
                                       none ->f[];
                                       none ->mps.theCatcher[];
                                       'End Of Stream error in '->mess;
                                       fn.theFragment.theFragName->mess.puttext;
                                       mess[]->AlertUser;
                                       false->status;
                                       leave thisOperation
                                    #);
                                  noSuchFileError::< 
                                    (# 
                                    do
                                       none ->f[];
                                       none ->mps.theCatcher[];
                                       'No such file: '->mess;
                                       fn.theFragment.theFragName->mess.puttext;
                                       mess[]->AlertUser;
                                       false->status;
                                       leave thisOperation
                                    #);
                                  fileExistsError::< 
                                    (# 
                                    do
                                       none ->f[];
                                       none ->mps.theCatcher[];
                                       'File exists error'->mess;
                                       mess[]->AlertUser;
                                       false->status;
                                       leave thisOperation
                                    #);
                                  noSpaceLeftError::< 
                                    (# 
                                    do
                                       none ->f[];
                                       none ->mps.theCatcher[];
                                       'No space left on device'->mess;
                                       mess[]->AlertUser;
                                       false->status;
                                       leave thisOperation
                                    #);
                                  otherFileError::< 
                                    (# 
                                    do
                                       none ->f[];
                                       none ->mps.theCatcher[];
                                       'File error for: '->mess;
                                       fn.theFragment.theFragName->mess.puttext;
                                       mess[]->AlertUser;
                                       false->status;
                                       leave thisOperation
                                    #);
                                  WriteAccessOnLstFileError::< 
                                    (# 
                                    do
                                       none ->f[];
                                       none ->mps.theCatcher[];
                                       'Access error on .lst file for '->mess;
                                       fn.theFragment.theFragName->mess.puttext;
                                       mess[]->AlertUser;
                                       false->status;
                                       leave thisOperation
                                       (*'Access error on .lst file'->myException*)
                                    #);
                                  writeAccessError::< 
                                    (# 
                                    do
                                       none ->f[];
                                       none ->mps.theCatcher[];
                                       'No write access'->mess;
                                       mess[]->AlertUser;
                                       false->status;
                                       leave thisOperation
                                       (*'Write access error'->myException
                                        * *)
                                    #);
                                  startingParsing::< 
                                    (# 
                                    do
                                       'Parsing '->mess;
                                       fn.theFragment.theFragName->mess.putText;
                                       mess[]->alertUser
                                    #);
                                  ParseErrors::< 
                                    (# 
                                    do
                                       none ->f[];
                                       none ->mps.theCatcher[];
                                       mess[]->AlertUser;
                                       false->status;
                                       leave thisOperation
                                    #)
                               #)->ff[];
                           (if ff[] <> none then
                               fg.fullname->thisDiagram.fullname;
                               (if (ff[],fn[])->consistentFFcategory then
                                   (ff[],fn[])->theGroupPage.openFormInSif;
                                   (if didRecover then
                                       fn.sifEditorInstance.fragmentTouched
                                   if);
                                   ff.root[]->fn.theRoot[];
                                   ff.root.index->fn.astindex;
                                   (if (fn.currentDecomposDiagram->ld[]) <> none
                                   then
                                       ((ff[],ld[])->getFFattributes,ld[])
                                         ->parseAttributes
                                   if)
                                else
                                   'FragmentForm has changed category!'
                                     ->alertUser;
                                   false->status;
                                   fn.theFragment.theGroupName->removeDiagram;
                                   leave thisOperation
                               if)
                            else
                               18
                                 ->trace
                                   (# 
                                   do
                                      'ff was not opened, deleting fragmentNode'
                                        ->t
                                   #);
                               fn.theFragment.theGroupName->askUpdate->ok;
                               (if ok = yes then
                                   'Deleted %s in %s\n'
                                     ->performedUpdates.putformat
                                       (# 
                                       do
                                          fn.theName->s;
                                          thisDiagram.titletext[]->s
                                       #);
                                   fn[]->thisDiagram.deleteFragmentNode
                                else
                                   fn.theFragment.theGroupName->removeDiagram;
                                   leave thisOperation
                               if)
                           if)
                        else
                           (if fn[]->fgNotFound then
                               restart fgOpen
                            else
                               false->status; leave thisOperation
                           if)
                       if)
                    #);
                  (thisDiagram.theGroup).scan
                    (# currentFF: ^mps.fragmentForm
                    do
                       current[]->currentFF[];
                       thisDiagram.localNodes.find
                         (#
                            predicate:: 
                              (# fn: ^thisDiagram.FragmentNode
                              do
                                 current[]->fn[];
                                 (fn.theRoot.frag[] = currentFF[])->value
                              #);
                            notFound:: 
                              (# 
                              do
                                 (currentFF.father).fullname->askUpdate->ok;
                                 (if ok = yes then
                                     currentFF[]->theGroupPage.fragmentInserted;
                                     'Fragment %s inserted in %s\n'
                                       ->performedUpdates.putformat
                                         (# 
                                         do
                                            currentFF.name->s;
                                            thisDiagram.titletext[]->s
                                         #)
                                  else
                                     leave thisOperation
                                 if)
                              #)
                         #)
                    #);
                  (if doUpdate then
                      'The following has been updated in the diagram:\n\n'
                        ->performedUpdates.prepend;
                      performedUpdates[]->alertUser
                  if);
                  false->doUpdate
               #)
          exit status
          #);
        ok: @boolean
     do
        18->trace (#  do '--------------- parseDiagram start'->t #);
        true->gppProp.ignoreFocusChanged;
        openFormsInSif->ok;
        (if ok then 18->trace (#  do 'openFormsInSif ok=true'->t #) if);
        theList.scanFragmentDiagrams
          (# 
          do
             thisOperation: thisDiagram.localNodes.scan
               (# fn: ^thisDiagram.FragmentNode; fg: ^mps.fragmentGroup
               do current[]->fn[]; fn.getGroup->fg[]; fg[]->updateRelations
               #)
          #);
        false->gppProp.ignoreFocusChanged;
        18->trace (#  do '--------------- parseDiagram end'->t #)
     #)
#)  

