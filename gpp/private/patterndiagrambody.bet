ORIGIN 'diagramattributes';
(* switches 
 * 30: trace prefix connectors 
 *)
(****************** PatternDiagram *******************)
-- PatternDiagramOnInit: Descriptor --
(# pos: @Point; w1,h1: @Integer; x2,y2,w2,h2: @integer; 
do
   UDPrivate.UDPatternDiagram->UserDataInit;
   (if not initialisingSaved then
       titleText->theText.set;
       (if switch[18] then
           '******** patterndiagrambody-PatternDiagramOnInit before fitToText ********'
             ->putline;
           geometry->(x2,y2,w2,h2);
           'x: '->putText;
           x2->putint;
           newLine;
           'y: '->putText;
           y2->putint;
           newLine;
           'w: '->putText;
           w2->putint;
           newLine;
           'h: '->putText;
           h2->putint;
           newLine;
           titleText[]->putLine;
           
       if);
       FitToText;
       (if switch[18] then
           '******** patterndiagrambody-PatternDiagramOnInit after fitToText and before size ********'
             ->putline;
           geometry->(x2,y2,w2,h2);
           'x: '->putText;
           x2->putint;
           newLine;
           'y: '->putText;
           y2->putint;
           newLine;
           'w: '->putText;
           w2->putint;
           newLine;
           'h: '->putText;
           h2->putint;
           newLine;
           
       if);
       Size->(w1,h1);
       (if w1 mod 2 // 1 then (w1+1,h1)->Size if);
       (if switch[18] then
           '******** patterndiagrambody-PatternDiagramOnInit after size ********'
             ->putline;
           geometry->(x2,y2,w2,h2);
           'x: '->putText;
           x2->putint;
           newLine;
           'y: '->putText;
           y2->putint;
           newLine;
           'w: '->putText;
           w2->putint;
           newLine;
           'h: '->putText;
           h2->putint;
           newLine;
           
       if);
       (if gppProp.ShowLocals
        // true then
           geometry->(x,y,w,h);
           THIS(patternDiagram).titleNode[]->THIS(OADPage).scrollIntoView;
           (x-(w+1) div 2,y+(h+1) div 2)->pos;
           pos->DisplayDeclarations;
           
       if)
   if);
   
#)
(****************** PatternAttDiagram *******************)  

-- PatternDiagramNodeDump: Descriptor --
(# x,y,w,h: @integer
do
   '********theDiagram********'->putline;
   (if theDiagram <> none then
       (theDiagram).titleText[]->putline
    else
       'is NONE!'->putline
   if);
   '********astIndex********'->putline;
   astIndex->putint;
   newline;
   '********pos and size********'->putline;
   geometry->(x,y,w,h);
   'x: '->putText;
   x->putint;
   newLine;
   'y: '->putText;
   y->putint;
   newLine;
   'w: '->putText;
   w->putint;
   newLine;
   'h: '->putText;
   h->putint;
   newLine
#)  

-- OADDiagramOnInit: Descriptor --
(#  do UDPrivate.UDOADDiagram->UserDataInit; UDtheDescriptor.Init #)  

-- OADDiagramDump: Descriptor --
(# 
do
   '********theDescriptor********'->putline;
   (if theDescriptor <> none then
       (theDescriptor).dump; newline
    else
       'is NONE!'->putline
   if)
#)  

-- PatternAttDiagramDump: Descriptor --
(# 
do
   '********theAST********'->putline;
   (if theAST <> none then
       (theAST).dump; newline
    else
       'is NONE!'->putline
   if)
#)  

-- PatternDiagramNodeOnInit: Descriptor --
(# 
do
   false->theText.wrap;
   UDPrivate.UDPatternDiagramNode->UserDataInit;
   theDiagram.Init;
   theMarkNode.Init;
   defaultShape.Init;
   astIndex.Init
#)  

-- PatternDiagramNodeOnInitAfter: Descriptor --
(#  do LeftJustification->theText.Just #)  

-- PatternAttDiagramDisplayDeclarations: Descriptor --
(# anAST: ^AST do theAST->anAST[]; anAST[]->theAttributes[];  #)  

-- PatternAttDiagramNew: Descriptor --
(# 
do
   (if anAST.symbol
    // betaGram.Attributes then
       anAST[]->theAST;
       titleshape->Display;
       (anAST.index,THIS(PatternAttDiagram)[])
         ->PatternDiagrams.theList.insertPD;
       
    else
       'PatternAttDiagram New: unknown AST symbol'->putline; 
   if);
   
#)
(****************** PatternDeclDiagram *******************)  

-- PatternAttDiagramOnInit: Descriptor --
(#  do UDPrivate.UDPatternAttDiagram->UserDataInit; UdtheAST.Init #)  

-- PatternDeclDiagramDump: Descriptor --
(# 
do
   '********thePrefix********'->putline;
   (if thePrefix <> none then
       (thePrefix).dump; newline
    else
       'is NONE!'->putline
   if)
#)  

-- PatternDeclDiagramDisplayDeclarations: Descriptor --
(# main: ^betaGram.MainPart; theDummyDesc: ^betaGram.ObjectDescriptor
do
   (if theDescriptor
    // none then none ->theAttributes[]; 
    else
       theDescriptor->theDummyDesc[];
       theDummyDesc.getMainPart->main[];
       main.getAttributes->theAttributes[];
       
   if);
   
#)  

-- PatternDeclDiagramDisplay: Descriptor --
(#
   x,y: @Integer;
   subList: ^DiagramList;
   prefixDiagram: ^PatternDiagram;
   e: ^localNodes.element;
   theDummyDesc: ^betaGram.ObjectDescriptor;
   theDiagramNode: ^DiagramNode;
   anAST,theFather: ^AST
do
   (if theDescriptor
    // none then (* I must be generated from a non-terminal *)
       none ->thePrefix; 
    else
       theDescriptor->theDummyDesc[];
       (if theDummyDesc.frag.father->isChecked
        // true then
           theDescriptor->getPrefix->thePrefix;
           (if thePrefix <> none then
               theDummyDesc.father->theFather[];
               (if theFather## <= betaGram.AttributeDecl## then
                   (theFather[],(thePrefix).father)
                     ->patternDiagrams.InheritanceList.insert
                else
               (*could be a singular*)
                   theFather.father->theFather[];
                   (if theFather[] <> none then
                       (if theFather## <= betaGram.AttributeDecl## then
                           ((theDummyDesc.father).father,(thePrefix).father)
                             ->patternDiagrams.InheritanceList.insert
                       if)
                   if)
               if)
           if)
        else
           theParentNode->theDiagramNode[];
           (if theDiagramNode[] <> none then
               (if theDiagramNode.thePrefix <> none then
                   theDiagramNode.thePrefix->thePrefix
               if)
           if)
       if);
       
   if);
   (if thePrefix <> none
    // true then (* find diagram *)
       (thePrefix).index->PatternDiagrams.theList.findPD->prefixDiagram[];
       (if prefixDiagram[]
        // none then
           (PatternDiagrams.NextFreeColumn,PatternDiagrams.NextFreeLine)
             ->theCenter;
           
        else
       (* we have a prefixDiagram: 
        * draw the subpattern diagram in relation
        * (below) the prefixDiagram
        *)
           prefixDiagram[]->PatternDiagrams.theList.GetSubPatternDiagrams
             ->subList[];
           (if subList.size
            // 0 then (* I am the first subpat of perfixDiagram[] *)
               (if prefixDiagram.localNodes.size > 0
                // true then
                   prefixDiagram.localNodes.Last
                     (#  do position.elm[]->e[]; e.Center->(x,y) #);
                   
                else
                   prefixDiagram.titleNode.Center->(x,y); 
               if);
               prefixDiagram.titleNode.Center->theCenter;
               (if x-gppProp.width > theCenter.x
                // true then
                (* the last box is not in the same column as the
                 * title:  use center of the last box *)
                   x->theCenter.x; 
               if);
               y+gppProp.DownFromPrefix->theCenter.y;
               
            else
               (- 10000,- 10000)->theCenter;
               subList.scanPatternDiagrams
                 (# p1: @Point; 
                 do
                    (if thisDiagram[]
                     // THIS(PatternDeclDiagram)[] then 
                     else
                        thisDiagram.titleNode.Center->p1;
                        (if p1.x > theCenter.x
                         // true then p1->theCenter
                        if);
                        
                    if);
                    
                 #);
               theCenter.x+gppProp.width+gppProp.RightFromPrevious->theCenter.x;
               
           if);
           
       if)
   if);
   
#)  

-- PatternDiagramDisplayPrefix: Descriptor --
(# prefixDiagram: ^PatternDiagram; con: ^PrefixConnector; 
do
   (if switch[30]
    // true then 'PatternDiagramDisplayPrefix'->screen.putline; 
   if);
   (if theDescriptor <> none
    // true then
       (if thePrefix <> none
        // true then (* is the prefix displayed on this page *)
           (thePrefix).index->PatternDiagrams.theList.findPD->prefixDiagram[];
           (if prefixDiagram[] <> none
            // true then (* Yes, go make a connector between the diagrams *)
               &PrefixConnector[]->con[];
               (if prefixDiagram.localNodes.size > 0
                // true then
                   prefixDiagram.localNodes.Last
                     (# 
                     do
                        (titleNode[],position.elm[])
                          ->con.prefixNew (* was con.new *);
                        (if not gppProp.specializations then
                            false->con.BorderVisible
                        if)
                     #);
                   
                else
                   (titleNode[],prefixDiagram.titleNode[])
                     ->con.prefixNew (* was con.new *);
                   (if not gppProp.specializations then
                       false->con.BorderVisible
                   if)
               if);
               prefixDiagram.titleNode[]->titleNode.CreateRegion;
               (* and make THIS to a region of prefix *)
               con[]->titleNode.thePrefixConn;
               
            else
           (* could be on another page!! *)
                 (# thePages: ^ObjectList; 
                 do
                    GetPages->thePages[];
                    scanner: thePages.scan
                      (#
                      (* ESS kja&toby 3-2-94 :
                       aPage: ^OADPage
                       This qualification is wrong, 
                       if there are other types of pages in
                       the document when scanning 
                       (e.q. ObjectPages, DesignPages)*)
                         aPage: ^page;
                         anEllipse: @DesignEllipse;
                         x,y,w,h: @Integer;
                         
                      do
                         current[]->aPage[];
                         (thePrefix).index->PatternDiagrams.theList.findPD
                           ->prefixDiagram[];
                         (if prefixDiagram[] <> none
                          // true then
                             titleNode.geometry->(x,y,w,h);
                             prefixDiagram.titleNode[]
                               ->THIS(OADPage).scrollIntoView;
                             (x-gppProp.LeftFromPrefix,y,gppProp.width,
                              gppProp.height)->anEllipse.new;
                             (titleNode[],anEllipse[])->con.prefixNew;
                             (* was con.new *)
                             (if not gppProp.specializations then
                                 false->con.BorderVisible
                             if);
                             anEllipse[]->titleNode.CreateRegion;
                             leave scanner;
                             
                         if)
                      #)
                 #)
           if)
        else
       (* No prefix *)
           
       if);
       (* now check for any shown subpatterns of this descriptor *)
       PatternDiagrams.theList.scanPatternDiagrams
         (# con: ^PrefixConnector; theDummyDesc: ^betaGram.ObjectDescriptor
         do
            (if thisDiagram.thePrefix <> none
             // true then
                theDescriptor->theDummyDesc[];
                (if thisDiagram.thePrefix->theDummyDesc.equal
                 // true then (* yes this diagram *)
                    &PrefixConnector[]->con[];
                    (if localNodes.size > 0
                     // true then
                        localNodes.Last
                          (# 
                          do
                             (thisDiagram.titleNode[],position.elm[])
                               ->con.prefixNew;
                             (* was con.new *)
                             (if not gppProp.specializations then
                                 false->con.BorderVisible
                             if)
                          #);
                        
                     else
                        (thisDiagram.titleNode[],titleNode[])->con.prefixNew;
                        (* was con.new *)
                        (if not gppProp.specializations then
                            false->con.BorderVisible
                        if);
                        
                    if);
                    titleNode[]->thisDiagram.titleNode.CreateRegion;
                    (* and make THIS to a region of prefix *)
                    con[]->thisDiagram.titleNode.thePrefixConn;
                    
                if)
            if)
         #);
       
    else
       (if switch[1]
        // true then 'DisplayPrefix: No Descriptor!!!'->putline
       if);
       
   if);
   
#)  

-- PatternDeclDiagramDisplayInheritance: Descriptor --
(#
   prefixDiagram,subDiagram: ^PatternDiagram;
   con: ^PrefixConnector;
   theParent,theNode: ^PatternDiagramNode;
   superNode,subNode: ^theListDiagram.AbstractNode;
   theListDiagram: ^ListDiagram;
   theDiagramNode: ^theListDiagram.DiagramNode;
   theDecl: ^betaGram.AttributeDecl
do
   (if switch[30] then 'DisplayInheritance: '->putline if);
   (if not patternDiagrams.InheritanceList.empty then
       (if theParentNode <> none then
           theParentNode->theParent[];
           theParent.theDiagram->theListDiagram[];
           (if theParent## <= theListDiagram.DiagramNode## then
               theParent[]->theDiagramNode[];
               theDiagramNode.theDeclaration->theDecl[];
               patternDiagrams.InheritanceList.scan
                 (# ff: ^fragmentForm; t: @Text
                 do
                    (if (theDecl.index = current.sub) and
                    (theDecl.frag.fullname->current.subFrag.equal) then
                        (current.superFrag[],t[])->top.open->ff[];
                        current.super->ff.indexToNode->AstToNode->theNode[];
                        (if theNode[] <> none then
                            theNode.theDiagram->theListDiagram[];
                            theNode[]->superNode[];
                            (if superNode.CurrentDecomposDiagram <> none then
                                superNode.CurrentDecomposDiagram
                                  ->prefixDiagram[];
                                &PrefixConnector[]->con[];
                                (if prefixDiagram.localNodes.size > 0
                                 // true then
                                    (if titleNode.thePrefixConn = none then
                                        prefixDiagram.localNodes.Last
                                          (# 
                                          do
                                             (titleNode[],position.elm[])
                                               ->
                                             con.prefixNew; (* was con.new *)
                                             (if not gppProp.specializations then
                                                 false->con.BorderVisible
                                             if)
                                          #)
                                    if)
                                 else
                                    (if titleNode.thePrefixConn = none then
                                        (titleNode[],prefixDiagram.titleNode[])
                                          ->con.prefixNew; (* was con.new *)
                                        (if not gppProp.specializations then
                                            false->con.BorderVisible
                                        if)
                                    if)
                                if);
                                (if titleNode.thePrefixConn = none then
                                    prefixDiagram.titleNode[]
                                      ->titleNode.CreateRegion;
                                    con[]->titleNode.thePrefixConn
                                if)
                            if)
                        if)
                    if);
                    (if (theDecl.index = current.super) and
                    (theDecl.frag.fullname->current.superFrag.equal) then
                        (current.subFrag[],t[])->top.open->ff[];
                        current.sub->ff.indexToNode->AstToNode->theNode[];
                        (if theNode[] <> none then
                            theNode.theDiagram->theListDiagram[];
                            theNode[]->subNode[];
                            (if subNode.CurrentDecomposDiagram <> none then
                                subNode.CurrentDecomposDiagram->subDiagram[];
                                &subDiagram.PrefixConnector[]->con[];
                                (if localNodes.size > 0
                                 // true then
                                    (if subDiagram.titleNode.thePrefixConn =
                                    none then
                                        localNodes.Last
                                          (# 
                                          do
                                             (subDiagram.titleNode[],
                                              position.elm[])->con.prefixNew;
                                             (* was con.new *)
                                             (if not gppProp.specializations then
                                                 false->con.BorderVisible
                                             if)
                                          #)
                                    if);
                                    
                                 else
                                    (if subDiagram.titleNode.thePrefixConn =
                                    none then
                                        (subDiagram.titleNode[],titleNode[])
                                          ->con.prefixNew;
                                        (if not gppProp.specializations then
                                            false->con.BorderVisible
                                        if)
                                    if);
                                    (* was con.new *)
                                    
                                if);
                                (if subDiagram.titleNode.thePrefixConn = none
                                 then
                                    titleNode[]
                                      ->subDiagram.titleNode.CreateRegion;
                                    con[]->subDiagram.titleNode.thePrefixConn
                                if)
                            if)
                        if)
                    if)
                 #)
           if);
           (* now check for any shown subpatterns of this descriptor *)
           
       if)
   if);
   
#)  

-- PatternDeclDiagramOnInit: Descriptor --
(#
   fd: ^FragmentDiagram;
   index: @integer;
   t,tt: ^text;
   theDummyFragNode: ^PatternDiagramNode;
   theDummyGroup: ^FragmentGroup
do
   UDPrivate.UDPatternDeclDiagram->UserDataInit;
   UDthePrefix.Init;
   (if not initialisingSaved then
       theFragmentNode->theDummyFragNode[];
       theDummyFragNode.theDiagram->fd[];
       DisplayInheritance;
       (*(if gppProp.CompositionDType > gppProp.CompositionNested
        // false then
        theFragmentNode->theDummyFragNode[];
        theDummyFragNode.theDiagram->fd[];
        (if true [* (fd.theGroup->isChecked) *]
        // true then [*DisplayPrefix; *] DisplayInheritance
        else
        (if gppProp.ShowLocals
        // false then
        'Classification cannot be shown, because "'->t[];
        fd.theGroup->theDummyGroup[];
        theDummyGroup.name->tt[];
        '/'->tt.findCh (#  do inx->index #);
        (index+1,tt.lgth)->tt.sub->t.puttext;
        '" has not been checked or contains semantic errors'->t.puttext;
        t->gppalert;
        
        else
        [*'WARNING: Group not checked:'->screen.puttext;
        fd.theGroup->theDummyGroup[];
        theDummyGroup.name->screen.putline;*]
        
        if);
        
        if)
        if)*)
       
   if);
   
#)  

-- PatternDeclDiagramNew: Descriptor --
(# 
do
   (if anAST.symbol
    // betaGram.ObjectDescriptor then
       anAST[]->theDescriptor; titleShape->Display; 
    else
       'PatternDeclDiagram New: unknown AST symbol'->putline; 
   if);
   
#)
(****************** Pattern Classification Diagram *******************)  

-- PatternClassificationDiagramDisplay: Descriptor --
(#
   root: ^expanded;
   LookForInheritance:
     (# root: ^expanded; 
     enter root[]
     do
        betaGram.ObjectDescriptor
          ->root.suffixWalkforProd
            (#
               scanCat::< betaGram.ObjectDescriptor;
               tempAst: ^ast;
               pref: ^betaGram.prefix;
               ad: ^betaGram.attributeDenotation;
               thisInheritor: ^betaGram.ObjectDescriptor;
               inheritorDiagram: ^PatternDeclDiagram;
               con: ^PrefixConnector;
               
            do
               (if switch[30]
                // true then
                   'PatternClassificationDiagramDisplay'->screen.putline; 
               if);
               current.getPrefixOpt->tempAst[];
               (if tempAst.kind
                // kinds.interior then
                   (if switch[30] // true then '.'->screen.put;  if);
                   tempAst[]->pref[];
                   pref.getAttributeDenotation->tempAst[];
                   (if tempAst.kind
                    // kinds.interior then
                       tempAst[]->ad[];
                       ad.findDescriptor->thisInheritor[];
                       (if thisInheritor[]
                        // theDescriptor then
                           (if switch[30]
                            // true then 'Found inheritor.'->screen.putline; 
                           if);
                           thisInheritor.index->PatternDiagrams.theList.findPD
                             ->inheritorDiagram[];
                           (if inheritorDiagram[]
                            // none then
                               (if switch[30]
                                // true then 'Not displayed'->screen.putline; 
                               if);
                               
                            else
                               (if switch[30]
                                // true then
                                   'Already displayed, create perfix connector'
                                     ->screen.putline;
                                   
                               if);
                               &PrefixConnector[]->con[];
                               (if localNodes.size > 0
                                // true then
                                   localNodes.Last
                                     (# 
                                     do
                                        (inheritorDiagram.titleNode[],
                                         position.elm[])
                                          ->con.prefixNew; (* was con.new *)
                                        (if not gppProp.specializations then
                                            false->con.BorderVisible
                                        if)
                                     #);
                                   
                                else
                                   (inheritorDiagram.titleNode[],titleNode[])
                                     ->con.prefixNew; (* was con.new *)
                                   (if not gppProp.specializations then
                                       false->con.BorderVisible
                                   if)
                               if);
                               titleNode[]
                                 ->inheritorDiagram.titleNode.CreateRegion;
                               (* and make THIS to a region of prefix *)
                               con[]->inheritorDiagram.titleNode.thePrefixConn;
                               
                           if)
                       if)
                   if)
               if)
            #)
     #);
   theDiagram: ^theGroupPage.FragmentDiagram;
   theDummyGroup: ^FragmentGroup
do
   theGroupPage.FragmentDiagram##
     ->theGroupPage.ScanDiagrams
       (# 
       do
          current[]->theDiagram[];
          (if switch[30]
           // true then theDiagram.fullname->screen.putline; 
          if);
          (if (theDiagram.theGroup->isChecked)
           // true then
              theDiagram.theGroup->theDummyGroup[];
              theDummyGroup.fragmentlist.scan
                (# ff: ^FragmentForm; 
                do
                   (if current.type
                    // FormType then
                       current.f[]->ff[];
                       (if ff.root[]
                        // none then 
                        else
                           ff.root[]->LookForInheritance; 
                       if)
                   if)
                #)
          if)
       #)
#)
(****************** Pattern NonTerminal Diagram *******************)  

-- PatternClassificationDiagramOnInit: Descriptor --
(#  do UDPrivate.UDPatternClassificationDiagram->UserDataInit #)  

-- PatternNonTerminalDiagramNew: Descriptor --
(# 
do
   'PatternNonTerminalDiagramNew: '->screen.puttext;
   titletext[]->screen.putline;
   (if anAst[]
    // none then 'PatternNonTerminalDiagramNew anAST is NONE'->putline; 
    else
       (if anAST.symbol
        // betaGram.ObjectDescriptor then
           anAST[]->theDescriptor; titleshape->Display; 
        else
           'PatternNonTerminalDiagram New: unknown AST symbol'->putline; 
       if)
   if);
   
#)  

-- PatternNonTerminalDisplayDeclarations: Descriptor --
(#
   nt: ^NonTerminalNode;
   unExp: ^unexpanded;
   x,y: @Integer;
   main: ^betaGram.MainPart;
   theDummyDesc: ^betaGram.ObjectDescriptor
do
   (if theDescriptor
    // none then
       none ->theAttributes[];
       'NonTerminal: theDescriptor is NONE'->putline;
       (*&NonTerminalNode[] -> nt[];
        (gram.attributedecl,theDescriptor.frag[]) -> betagram.newUnexpanded -> unExp[];
        (startpos,unExp[]) -> nt.display;
        THIS(PatternNonTerminalDiagram)[] -> nt.theDiagram[];*)
       
    else
       theDescriptor->theDummyDesc[];
       theDummyDesc.getMainPart->main[];
       main.getAttributes->theAttributes[];
       
   if);
   
#)  

-- PatternNonTerminalDiagramOnInit: Descriptor --
(# 
do UDPrivate.UDPatternNonTerminalDiagram->UserDataInit; UDtheDesc.Init
#)  

-- CommentNodeOnInit: Descriptor --
(#  do UDPrivate.UDCommentNode->UserDataInit #)  

-- prefixNew: Descriptor --
(# x,y,w,h: @Integer; wed: ^WedgeNode; 
do
   (pnode1).geometry->(x,y,w,h);
   pnode1->THIS(OADPage).scrollIntoView;
   &WedgeNode[]->wed[];
   (x,y-(h div 2)-1,10,10)->wed.new;
   (270,90)->wed.angles;
   false->wed.selectable;
   false->wed.sizeable;
   (wed[],pnode2)->new;
   pnode1->wed.createRegion;
   (*  (if gppProp.SimpleHierarchyPresentation
    // true then (pnode1,pnode2)->new
    else
    (pnode1).geometry->(x,y,w,h);
    pnode1->THIS(OADPage).scrollIntoView;
    &WedgeNode[]->wed[];
    (x,y-(h div 2)-1,10,10)->wed.new;
    (270,90)->wed.angles;
    false->wed.selectable;
    false->wed.sizeable;
    (wed[],pnode2)->new;
    pnode1->wed.createRegion;
    
    if)*)
   
#)  

-- treeNew: Descriptor --
(# x,y,w,h: @Integer; r: ^RectNode; 
do
   (if gppProp.SimpleHierarchyPresentation
    // true then (node1[],node2[])->new
    else
       node2.geometry->(x,y,w,h);
       node2[]->THIS(OADPage).scrollIntoView;
       &RectNode[]->r[];
       (x,y-(h div 2)-2,6,6)->r.new;
       false->r.sizeable;
       false->r.selectable;
       (node1[],r[])->new;
       node2[]->r.createRegion;
       
   if)
#)  

-- myNodeOninit: Descriptor --
(# 
do
   LocalNodesUDAttributes.init;
   oldLocalNodesUDAttributes.init;
   LocalNodesUDAttributes->oldLocalNodesUDAttributes;
   LocalNodesUserDataStart->LocalNodesUDAttributes;
   decomposDiagramsUDAttributes.init;
   oldDecomposDiagramsUDAttributes.init;
   decomposDiagramsUDAttributes->oldDecomposDiagramsUDAttributes;
   decomposDiagramsUserDataStart->decomposDiagramsUDAttributes;
   INNER onInit
#)  

-- PrefixConnectorDelete: Descriptor --
(#  do (if wedge[] <> none then wedge.delete if) #)  

-- PrefixConnectorOnDelete: Descriptor --
(#
   node1,node2,dummy: ^PatternDiagramNode;
   theTitleNode: ^theOADDiagram.title;
   theDiagramNode: ^theOADDiagram.DiagramNode;
   titleText: @Text;
   theOADDiagram,theOtherOADDiagram: ^OADDiagram;
   thePatternDeclDiagram: ^PatternDeclDiagram;
   anAST: ^AST;
   theDesc: ^betaGram.ObjectDescriptor;
   theMainPart: ^betaGram.MainPart;
   nd1,nd2: @integerRef;
   object1,object2: ^designObject;
   theParentNode: ^PatternDiagramNode;
   theParentDiagram: ^ListDiagram;
   theParentDiagramNode: ^theParentDiagram.DiagramNode
do
   (if switch[1] then 'InheritanceConnector onRemove!'->putline if);
   (if (ID,true,nd1[],nd2[])->DSRdAttrGetConnEnds then
       nd1->theObjectList.Find->object1[];
       (if object1[] <> none then
           (if object1## <= wedgeNode## then
               object1[]->wedge[]
            else
               nd2->theObjectList.Find->object2[];
               (if object2[] <> none then
                   (if object2## <= wedgeNode## then object2[]->wedge[] if)
               if)
           if)
       if)
    else
       'GetEnds failed connector ID: '->puttext; ID->putint; newline
   if);
   true->getEnds->(node1[],node2[]);
   node1.theDiagram->theOADDiagram[];
   node2.theDiagram->theOtherOADDiagram[];
   (if node1## <= theOADDiagram.title## then
       
    else
       (if node2## <= theOtherOADDiagram.title## then
           node1[]->dummy[];
           node2[]->node1[];
           dummy[]->node2[];
           theOtherOADDiagram[]->theOADDiagram[]
       if)
   if);
   node1[]->theTitleNode[];
   none ->theTitleNode.thePrefixConn;
   theOADDiagram[]->thePatternDeclDiagram[];
   none ->thePatternDeclDiagram.thePrefix;
   theOADDiagram.theParentNode->theDiagramNode[];
   none ->theDiagramNode.thePrefix;
   theOADDiagram.theParentNode->theParentNode[];
   theParentNode.theDiagram->theParentDiagram[];
   theParentNode[]->theParentDiagramNode[];
   theParentDiagramNode.theDeclaration->patternDiagrams.InheritanceList.remove;
   node1.unmakeRegion;
   '#'->t[];
   node2.SifEditorInstanceNo->t.putint;
   ' parse '->t.puttext;
   theOADDiagram.theDescriptor->theDesc[];
   theDesc.getPrefixOpt->anAST[];
   anAST.index->t.putint;
   t[]->sendSifCommand
#)  

-- PrefixConnectorOnReattach: Descriptor --
(# node1,node2,dummy: ^DesignObject; theCon: ^Connector
do
   true->getEnds->(node1[],node2[]);
   (if switch[1] then
       'InheritanceConnectorOnReattach!'->putline;
       'node1: '->puttext;
       node1.id->putint;
       newline;
       'node2: '->puttext;
       node2.id->putint;
       newline
   if);
   'Moving inheritance relation is not yet implemented!'->DSUIUserAckMessage;
   false->ok
#)  

