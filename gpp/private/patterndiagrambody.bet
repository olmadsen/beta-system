ORIGIN 'diagramattributes';
(* switches 
 * 30: trace prefix connectors 
 *)
(****************** PatternDiagram *******************)
-- PatternDiagramOnInit: DescriptorForm --
(# pos: @Point; w1,h1: @Integer;
do
   UDPrivate.UDPatternDiagram->UserDataInit;
   (if not initialisingSaved then
       titleText->theText.set;
       FitToText;
       Size->(w1,h1);
       (if w1 mod 2 // 1 then (w1+1,h1)->Size if);
       (if gppProp.ShowLocals
        // true then
           geometry->(x,y,w,h);
           THIS(patternDiagram).titleNode[]->THIS(OADPage).scrollIntoView;
           (* show patterns starting at low-left of the title *)
           (x-(w+1) div 2,y+(h+1) div 2)->pos;
           pos->DisplayDeclarations;
       if)
   if);
#)
(****************** PatternAttDiagram *******************)  

-- PatternDiagramNodeDump: DescriptorForm --
(# do '********astIndex********'->putline; astIndex->putint; newline #)  

-- OADDiagramOnInit: DescriptorForm --
(# do UDPrivate.UDOADDiagram->UserDataInit; UDtheDescriptor.Init #)  

-- OADDiagramDump: DescriptorForm --
(#
do
   '********theDescriptor********'->putline;
   (if theDescriptor <> none then
       (theDescriptor).dump; newline
    else
       'is NONE!'->putline
   if)
#)  

-- PatternAttDiagramDump: DescriptorForm --
(#
do
   '********theAST********'->putline;
   (if theAST <> none then
       (theAST).dump; newline
    else
       'is NONE!'->putline
   if)
#)  

-- PatternDiagramNodeOnInit: DescriptorForm --
(#
do
   UDPrivate.UDPatternDiagramNode->UserDataInit;
   theDiagram.Init;
   theMarkNode.Init;
   defaultShape.Init;
   astIndex.Init
#)  

-- PatternDiagramNodeOnInitAfter: DescriptorForm --
(# do LeftJustification->theText.Just #)  

-- PatternAttDiagramDisplayDeclarations: DescriptorForm --
(# anAST: ^AST do theAST->anAST[]; anAST[]->theAttributes[]; #)  

-- PatternAttDiagramNew: DescriptorForm --
(#
do
   (if anAST.symbol
    // betaGram.Attributes then
       anAST[]->theAST;
       titleshape->Display;
       (anAST.index,THIS(PatternAttDiagram)[])
         ->PatternDiagrams.theList.insertPD;
    else
       'PatternAttDiagram New: unknown AST symbol'->putline;
   if);
#)
(****************** PatternDeclDiagram *******************)  

-- PatternAttDiagramOnInit: DescriptorForm --
(# do UDPrivate.UDPatternAttDiagram->UserDataInit; UdtheAST.Init #)  

-- PatternDeclDiagramDump: DescriptorForm --
(#
do
   '********thePrefix********'->putline;
   (if thePrefix <> none then
       (thePrefix).dump; newline
    else
       'is NONE!'->putline
   if)
#)  

-- PatternDeclDiagramDisplayDeclarations: DescriptorForm --
(# main: ^betaGram.MainPart; theDummyDesc: ^betaGram.ObjectDescriptor
do
   (if theDescriptor
    // none then none ->theAttributes[];
    else
       theDescriptor->theDummyDesc[];
       theDummyDesc.getMainPart->main[];
       main.getAttributes->theAttributes[];
   if);
#)  

-- PatternDeclDiagramDisplay: DescriptorForm --
(#
   x,y: @Integer;
   subList: ^DiagramList;
   prefixDiagram: ^PatternDiagram;
   e: ^localNodes.element;
   theDummyDesc: ^betaGram.ObjectDescriptor
do
   (if theDescriptor
    // none then (* I must be generated from a non-terminal *)
       none ->thePrefix;
    else
       theDescriptor->theDummyDesc[];
       (if theDummyDesc.frag.father->isChecked
        // true then theDescriptor->getPrefix->thePrefix;
       if);
   if);
   (if thePrefix <> none
    // true then (* find diagram *)
       (thePrefix).index->PatternDiagrams.theList.findPD->prefixDiagram[];
       (if prefixDiagram[]
        // none then
           (PatternDiagrams.NextFreeColumn,PatternDiagrams.NextFreeLine)
             ->theCenter;
        else
       (* we have a prefixDiagram: 
        * draw the subpattern diagram in relation
        * (below) the prefixDiagram
        *)
           prefixDiagram[]->PatternDiagrams.theList.GetSubPatternDiagrams
             ->subList[];
           (if subList.size
            // 0 then (* I am the first subpat of perfixDiagram[] *)
               (if prefixDiagram.localNodes.size > 0
                // true then
                   prefixDiagram.localNodes.Last
                     (# do position.elm[]->e[]; e.Center->(x,y) #);
                else
                   prefixDiagram.titleNode.Center->(x,y);
               if);
               prefixDiagram.titleNode.Center->theCenter;
               (if x-gppProp.width > theCenter.x
                // true then
                (* the last box is not in the same column as the
                 * title:  use center of the last box *)
                   x->theCenter.x;
               if);
               y+gppProp.DownFromPrefix->theCenter.y;
            else
               (- 10000,- 10000)->theCenter;
               subList.scanPatternDiagrams
                 (# p1: @Point;
                 do
                    (if thisDiagram[]
                     // THIS(PatternDeclDiagram)[] then
                     else
                        thisDiagram.titleNode.Center->p1;
                        (if p1.x > theCenter.x
                         // true then p1->theCenter
                        if);
                    if);
                 #);
               (* now we got the coordinates of the leftmost 
                * subpatternDiagram; offset it *)
               theCenter.x+gppProp.width+gppProp.RightFromPrevious->theCenter.x;
               (* we have gone to the right of the column *)
               (*theCenter.y + gppProp.DownFromPrefix  -> PatternDiagrams.SecondFreeLine;*)
           if);
       if)
   if);
#)  

-- PatternDiagramDisplayPrefix: DescriptorForm --
(# prefixDiagram: ^PatternDiagram; con: ^PrefixConnector;
do
   (if switch[30]
    // true then 'PatternDiagramDisplayPrefix'->screen.putline;
   if);
   (if theDescriptor <> none
    // true then
       (if thePrefix <> none
        // true then (* is the prefix displayed on this page *)
           (thePrefix).index->PatternDiagrams.theList.findPD->prefixDiagram[];
           (if prefixDiagram[] <> none
            // true then (* Yes, go make a connector between the diagrams *)
               &PrefixConnector[]->con[];
               (if prefixDiagram.localNodes.size > 0
                // true then
                   prefixDiagram.localNodes.Last
                     (#
                     do
                        (titleNode[],position.elm[])
                          ->con.prefixNew (* was con.new *)
                     #);
                else
                   (titleNode[],prefixDiagram.titleNode[])
                     ->con.prefixNew (* was con.new *)
               if);
               prefixDiagram.titleNode[]->titleNode.CreateRegion;
               (* and make THIS to a region of prefix *)
               con[]->titleNode.thePrefixConn;
            else
           (* could be on another page!! *)
                 (# thePages: ^ObjectList;
                 do
                    GetPages->thePages[];
                    scanner: thePages.scan
                      (#
                      (* ESS kja&toby 3-2-94 :
                       aPage: ^OADPage
                       This qualification is wrong, 
                       if there are other types of pages in
                       the document when scanning 
                       (e.q. ObjectPages, DesignPages)*)
                         aPage: ^page;
                         anEllipse: @DesignEllipse;
                         x,y,w,h: @Integer;
                      do
                         current[]->aPage[];
                         (thePrefix).index->PatternDiagrams.theList.findPD
                           ->prefixDiagram[];
                         (if prefixDiagram[] <> none
                          // true then
                             titleNode.geometry->(x,y,w,h);
                             prefixDiagram.titleNode[]
                               ->THIS(OADPage).scrollIntoView;
                             (x-gppProp.LeftFromPrefix,y,gppProp.width,
                              gppProp.height)->anEllipse.new;
                             (titleNode[],anEllipse[])->con.prefixNew;
                             (* was con.new *)
                             anEllipse[]->titleNode.CreateRegion;
                             leave scanner;
                         if)
                      #)
                 #)
           if)
        else
       (* No prefix *)
       if);
       (* now check for any shown subpatterns of this descriptor *)
       PatternDiagrams.theList.scanPatternDiagrams
         (# con: ^PrefixConnector; theDummyDesc: ^betaGram.ObjectDescriptor
         do
            (if thisDiagram.thePrefix <> none
             // true then
                theDescriptor->theDummyDesc[];
                (if thisDiagram.thePrefix->theDummyDesc.equal
                 // true then (* yes this diagram *)
                    &PrefixConnector[]->con[];
                    (if localNodes.size > 0
                     // true then
                        localNodes.Last
                          (#
                          do
                             (thisDiagram.titleNode[],position.elm[])
                               ->con.prefixNew;
                             (* was con.new *)
                          #);
                     else
                        (thisDiagram.titleNode[],titleNode[])->con.prefixNew;
                        (* was con.new *)
                    if);
                    titleNode[]->thisDiagram.titleNode.CreateRegion;
                    (* and make THIS to a region of prefix *)
                    con[]->thisDiagram.titleNode.thePrefixConn;
                if)
            if)
         #);
    else
       (if switch[1]
        // true then 'DisplayPrefix: No Descriptor!!!'->putline
       if);
   if);
#)  

-- PatternDeclDiagramOnInit: DescriptorForm --
(#
   fd: ^FragmentDiagram;
   index: @integer;
   t,tt: ^text;
   theDummyFragNode: ^PatternDiagramNode;
   theDummyGroup: ^FragmentGroup
do
   UDPrivate.UDPatternDeclDiagram->UserDataInit;
   UDthePrefix.Init;
   (if not initialisingSaved then
       (if gppProp.CompositionDType > gppProp.CompositionNested
        // false then
           theFragmentNode->theDummyFragNode[];
           theDummyFragNode.theDiagram->fd[];
           (if (fd.theGroup->isChecked)
            // true then DisplayPrefix;
            else
               (if gppProp.ShowLocals
                // false then
                   'Classification cannot be shown, because "'->t[];
                   fd.theGroup->theDummyGroup[];
                   theDummyGroup.name->tt[];
                   '/'->tt.findCh (# do inx->index #);
                   (index+1,tt.lgth)->tt.sub->t.puttext;
                   '" has not been checked or contains semantic errors'
                     ->t.puttext;
                   t->gppalert;
                else 
                   (*'WARNING: Group not checked:'->screen.puttext;
                   fd.theGroup->theDummyGroup[];
                   theDummyGroup.name->screen.putline;*)
               if);
           if)
       if)
   if);
#)  

-- PatternDeclDiagramNew: DescriptorForm --
(#
do
   (if anAST.symbol
    // betaGram.ObjectDescriptor then
       anAST[]->theDescriptor; titleShape->Display;
    else
       'PatternDeclDiagram New: unknown AST symbol'->putline;
   if);
#)
(****************** Pattern Classification Diagram *******************)  

-- PatternClassificationDiagramDisplay: DescriptorForm --
(#
   root: ^expanded;
   LookForInheritance:
     (# root: ^expanded;
     enter root[]
     do
        betaGram.ObjectDescriptor
          ->root.suffixWalkforProd
            (#
               scanCat::< betaGram.ObjectDescriptor;
               tempAst: ^ast;
               pref: ^betaGram.prefix;
               ad: ^betaGram.attributeDenotation;
               thisInheritor: ^betaGram.ObjectDescriptor;
               inheritorDiagram: ^PatternDeclDiagram;
               con: ^PrefixConnector;
            do
               (if switch[30]
                // true then
                   'PatternClassificationDiagramDisplay'->screen.putline;
               if);
               current.getPrefixOpt->tempAst[];
               (if tempAst.kind
                // kinds.interior then
                   (if switch[30] // true then '.'->screen.put; if);
                   tempAst[]->pref[];
                   pref.getAttributeDenotation->tempAst[];
                   (if tempAst.kind
                    // kinds.interior then
                       tempAst[]->ad[];
                       ad.findDescriptor->thisInheritor[];
                       (if thisInheritor[]
                        // theDescriptor then
                           (if switch[30]
                            // true then 'Found inheritor.'->screen.putline;
                           if);
                           thisInheritor.index->PatternDiagrams.theList.findPD
                             ->inheritorDiagram[];
                           (if inheritorDiagram[]
                            // none then
                               (if switch[30]
                                // true then 'Not displayed'->screen.putline;
                               if);
                            else
                               (if switch[30]
                                // true then
                                   'Already displayed, create perfix connector'
                                     ->screen.putline;
                               if);
                               &PrefixConnector[]->con[];
                               (if localNodes.size > 0
                                // true then
                                   localNodes.Last
                                     (#
                                     do
                                        (inheritorDiagram.titleNode[],
                                         position.elm[])
                                          ->con.prefixNew (* was con.new *)
                                     #);
                                else
                                   (inheritorDiagram.titleNode[],titleNode[])
                                     ->con.prefixNew (* was con.new *)
                               if);
                               titleNode[]
                                 ->inheritorDiagram.titleNode.CreateRegion;
                               (* and make THIS to a region of prefix *)
                               con[]->inheritorDiagram.titleNode.thePrefixConn;
                           if)
                       if)
                   if)
               if)
            #)
     #);
   theDiagram: ^theGroupPage.FragmentDiagram;
   theDummyGroup: ^FragmentGroup
do
   theGroupPage.FragmentDiagram##
     ->theGroupPage.ScanDiagrams
       (#
       do
          current[]->theDiagram[];
          (if switch[30]
           // true then theDiagram.fullname->screen.putline;
          if);
          (if (theDiagram.theGroup->isChecked)
           // true then
              theDiagram.theGroup->theDummyGroup[];
              theDummyGroup.fragmentlist.scan
                (# ff: ^FragmentForm;
                do
                   (if current.type
                    // FormType then
                       current.f[]->ff[];
                       (if ff.root[]
                        // none then
                        else
                           ff.root[]->LookForInheritance;
                       if)
                   if)
                #)
          if)
       #)
#)
(****************** Pattern NonTerminal Diagram *******************)  

-- PatternClassificationDiagramOnInit: DescriptorForm --
(# do UDPrivate.UDPatternClassificationDiagram->UserDataInit #)  

-- PatternNonTerminalDiagramNew: DescriptorForm --
(#
do
   'PatternNonTerminalDiagramNew: '->screen.puttext;
   titletext[]->screen.putline;
   (if anAst[]
    // none then 'PatternNonTerminalDiagramNew anAST is NONE'->putline;
    else
       (if anAST.symbol
        // betaGram.ObjectDescriptor then
           anAST[]->theDescriptor; titleshape->Display;
        else
           'PatternNonTerminalDiagram New: unknown AST symbol'->putline;
       if)
   if);
#)  

-- PatternNonTerminalDisplayDeclarations: DescriptorForm --
(#
   nt: ^NonTerminalNode;
   unExp: ^unexpanded;
   x,y: @Integer;
   main: ^betaGram.MainPart;
   theDummyDesc: ^betaGram.ObjectDescriptor
do
   (if theDescriptor
    // none then
       none ->theAttributes[];
       'NonTerminal: theDescriptor is NONE'->putline;
       (*&NonTerminalNode[] -> nt[];
        (gram.attributedecl,theDescriptor.frag[]) -> betagram.newUnexpanded -> unExp[];
        (startpos,unExp[]) -> nt.display;
        THIS(PatternNonTerminalDiagram)[] -> nt.theDiagram[];*)
    else
       theDescriptor->theDummyDesc[];
       theDummyDesc.getMainPart->main[];
       main.getAttributes->theAttributes[];
   if);
#)  

-- PatternNonTerminalDiagramOnInit: DescriptorForm --
(#
do UDPrivate.UDPatternNonTerminalDiagram->UserDataInit; UDtheDesc.Init
#)  

-- CommentNodeOnInit: DescriptorForm --
(# do UDPrivate.UDCommentNode->UserDataInit #)  

-- prefixNew: DescriptorForm --
(# x,y,w,h: @Integer; wed: ^WedgeNode;
do
   (if gppProp.SimpleHierarchyPresentation
    // true then (node1[],node2[])->new
    else
       node1.geometry->(x,y,w,h);
       node1[]->THIS(OADPage).scrollIntoView;
       &WedgeNode[]->wed[];
       (x,y-(h div 2)-1,10,10)->wed.new;
       (270,90)->wed.angles;
       false->wed.selectable;
       false->wed.sizeable;
       (wed[],node2[])->new;
       node1[]->wed.createRegion;
   if)
#)  

-- treeNew: DescriptorForm --
(# x,y,w,h: @Integer; r: ^RectNode;
do
   (if gppProp.SimpleHierarchyPresentation
    // true then (node1[],node2[])->new
    else
       node2.geometry->(x,y,w,h);
       node2[]->THIS(OADPage).scrollIntoView;
       &RectNode[]->r[];
       (x,y-(h div 2)-2,6,6)->r.new;
       false->r.sizeable;
       false->r.selectable;
       (node1[],r[])->new;
       node2[]->r.createRegion;
   if)
#)  

-- myNodeOninit: DescriptorForm --
(#
do
   LocalNodesUDAttributes.init;
   oldLocalNodesUDAttributes.init;
   LocalNodesUDAttributes->oldLocalNodesUDAttributes;
   LocalNodesUserDataStart->LocalNodesUDAttributes;
   decomposDiagramsUDAttributes.init;
   oldDecomposDiagramsUDAttributes.init;
   decomposDiagramsUDAttributes->oldDecomposDiagramsUDAttributes;
   decomposDiagramsUserDataStart->decomposDiagramsUDAttributes;
   INNER onInit
#)  

-- InheritanceConnectorOnInit: DescriptorForm --
(# do 0->Orient #)  

-- InheritanceConnectorOnDelete: DescriptorForm --
(#
   node1,node2,dummy: ^PatternDiagramNode;
   titleText: @Text;
   theOADDiagram,theOtherOADDiagram: ^OADDiagram;
   anAST: ^AST;
   theDesc: ^betaGram.ObjectDescriptor;
   theMainPart: ^betaGram.MainPart
do
   (if switch[1] then 'InheritanceConnector onRemove!'->putline if);
   true->getEnds->(node1[],node2[]);
   node1.theDiagram->theOADDiagram[];
   node2.theDiagram->theOtherOADDiagram[];
   (if node2## <= theOtherOADDiagram.title## then
       node1[]->dummy[];
       node2[]->node1[];
       dummy[]->node2[];
       theOtherOADDiagram[]->theOADDiagram[]
   if);
   node1.unmakeRegion;
   '#'->t[];
   node2.SifEditorInstanceNo->t.putint;
   ' parse '->t.puttext;
   theOADDiagram.theDescriptor->theDesc[];
   theDesc.getPrefixOpt->anAST[];
   anAST.index->t.putint
#)  

-- InheritanceConnectorOnReattach: DescriptorForm --
(# node1,node2,dummy: ^DesignObject; theCon: ^Connector
do
   true->getEnds->(node1[],node2[]);
   (if switch[1] then
       'InheritanceConnectorOnReattach!'->putline;
       'node1: '->puttext;
       node1.id->putint;
       newline;
       'node2: '->puttext;
       node2.id->putint;
       newline
   if);
   'Moving inheritance relation is not yet implemented!'->DSUIUserAckMessage;
   false->ok
#)  

